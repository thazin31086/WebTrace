IssueID,Title,Description,Title_Description,PullRequestID,FixedByID,RepoID
1437,Disable failing test,"ValidFileOptions test is failing.  Disable it.","Disable failing test  ValidFileOptions test is failing.  Disable it.",42837,halter73,corefx
1436,Improve performance of BigInteger.Multiply,"To introduce performance tweaks for BigInteger's operations a new static class `BigCalc` implements those algorithms based on raw uint[] objects, partially switching even to pointer arithmetic to spare some index calculations. First of all a multiplication implementation is included, furthermore an optimized version for squaring.

A basic performance comparison based on [this code](https://gist.github.com/axelheer/3b701c91271b7c762586) unveils the following results:

**Multiply**

| # of bits | # of vals | before ms | after ms |
| --: | --: | --: | --: |
| 16 | 1,000,000 | 41 | 35 |
| 64 | 1,000,000 | 127 | 89 |
| 256 | 1,000,000 | 284 | 182 |
| 1,024 | 100,000 | 236 | 147 |
| 4,096 | 10,000 | 323 | 142 |
| 16,384 | 1,000 | 495 | 132 |
| 65,536 | 100 | 785 | 121 |

**Square**

| # of bits | # of vals | before ms | after ms |
| --: | --: | --: | --: |
| 16 | 1,000,000 | 41 | 42 |
| 64 | 1,000,000 | 127 | 78 |
| 256 | 1,000,000 | 284 | 147 |
| 1,024 | 100,000 | 236 | 102 |
| 4,096 | 10,000 | 323 | 98 |
| 16,384 | 1,000 | 495 | 92 |
| 65,536 | 100 | 785 | 84 |

_Note:_ the performance gain is not as big as expected based on my previous work (as mentioned within the issue), but I'd still call it significant. I actually had some difficulties executing a custom build of _System.Runtime.Numerics_ though, since just dropping in the _dll_ as described [here](https://github.com/dotnet/corefx/wiki/Open-Source-Signing) does not work 'cause of some ""type forwards"". I finally managed to execute it using _kre-coreclr-win-x64.1.0.0-beta3_ and some hacks... :flushed:
#1307","Improve performance of BigInteger.Multiply  To introduce performance tweaks for BigInteger's operations a new static class `BigCalc` implements those algorithms based on raw uint[] objects, partially switching even to pointer arithmetic to spare some inde",42837,halter73,corefx
30892,Remove WinHttpHandler fallback from HttpClientHandler,"A developer can explicitly use WinHttpHandler by referencing the nuget package and constructing one.  The meant-to-be-temporary environment-variable-controlled fallback is not only additional code to be maintained and additional complexity on how the code is structured, it forces every consumer of System.Net.Http.dll on Windows to carry the WinHttpHandler code internal to System.Net.Http.dll, which increases the size of the binary by ~70K.",Remove WinHttpHandler fallback from HttpClientHandler  A developer can explicitly use WinHttpHandler by referencing the nuget package and constructing one.  The meant-to-be-temporary environment-variable-controlled fallback is not only additional code to,42451,ManickaP,corefx
30893,Remove CurlHandler fallback from HttpClientHandler,"SocketsHttpHandler has progressed to the point where we shouldn't need the fallback behind HttpClientHandler, and having it significantly increases the size of System.Net.Http.dll on Unix, while also requiring System.Net.Http.Native.so/dylib, and impacting distribution with libcurl.  We should remove the fallback and all associated code, and if any additional and impactful gaps are discovered, fix them in SocketsHttpHandler.","Remove CurlHandler fallback from HttpClientHandler  SocketsHttpHandler has progressed to the point where we shouldn't need the fallback behind HttpClientHandler, and having it significantly increases the size of System.Net.Http.dll on Unix, while also req",42451,ManickaP,corefx
40611,"FileSystem.Unix.File.Move uses ""rename"" in more cases","with the goal of avoiding link/copy when possible, since not reverting to LinkOrCopy when not necessary improves performance on file systems that do not support hard links, such as FAT.

Before this PR ""rename"" is used only when source and dest file exist and are on the same device and are the same file on that device.

With this PR ""rename"" is used when source file exist and source and dest are on the same device and either source and dest are the same file on that device (as before) **or dest file does not exist (new)**.

This latter case permits to use ""rename"" for simply moving a file to an non existing new name on the same device, instead of ""LinkOrCopyFile"". Consequently, calling File.Move for such cases on file systems that do not support link (e.g. FAT) will result in much faster operations, because copy won't be used.


See https://github.com/mono/mono/issues/16435","FileSystem.Unix.File.Move uses ""rename"" in more cases  with the goal of avoiding link/copy when possible, since not reverting to LinkOrCopy when not necessary improves performance on file systems that do not support hard links, such as FAT.

Before this",42430,wfurt,corefx
31383,FileSystemWatcher tests on MacOS constantly fail on Outerloop CI run,"https://dev.azure.com/dnceng/public/_build/results?buildId=414240&view=ms.vss-test-web.build-test-results-tab

![image](https://user-images.githubusercontent.com/7684835/68095358-a11da900-fe5d-11e9-8e9a-1ae9f4b1ba03.png)","FileSystemWatcher tests on MacOS constantly fail on Outerloop CI run  https://dev.azure.com/dnceng/public/_build/results?buildId=414240&view=ms.vss-test-web.build-test-results-tab

![image](https://user-images.githubusercontent.com/7684835/68095358-a11d",42430,wfurt,corefx
31209,tracing in NameResolution should be improved,"I wrote simple app to lookup one name expected to succeed and one expected to fail:
 
```c#
Task t1 = Task.Run(() => Dns.GetHostEntry(""www.foo.com""));
Task t2 = Task.Run(() => Dns.GetHostEntry(""www.foo22.com""));
Task t3 = Dns.GetHostEntryAsync(""www.foo.com"");
Task t4 = Dns.GetHostEntryAsync(""www.foo22.com""); 
```
and I enabled tracing for NameResolution (or use dotnet-trace) 
```
COMPlus_EnableEventPipe=1
COMPlus_EventPipeConfig=Microsoft-System-Net-NameResolution:0xFFFFFFFFFFFFFFFF:5
```
I get following entries for synchronous successful call:
```
<Event MSec=  ""6067.9290"" PID=""10091"" PName=""Process(10091)"" TID=""10091"" EventName=""Enter"" ProviderName=""Microsoft-System-Net-NameResolution"" thisOrContextObject=""(null)"" memberName=""GetHostEntry"" parameters=""(www.foo.com)""/>
<Event MSec=  ""6068.6685"" PID=""10091"" PName=""Process(10091)"" TID=""10091"" EventName=""Enter"" ProviderName=""Microsoft-System-Net-NameResolution"" thisOrContextObject=""(null)"" memberName=""InternalGetHostByName"" parameters=""(www.foo.com)""/>
<Event MSec= ""11089.9084"" PID=""10091"" PName=""Process(10091)"" TID=""10091"" EventName=""Exit"" ProviderName=""Microsoft-System-Net-NameResolution"" thisOrContextObject=""(null)"" memberName=""InternalGetHostByName"" result=""IPHostEntry#33476626""/>
<Event MSec= ""11089.9167"" PID=""10091"" PName=""Process(10091)"" TID=""10091"" EventName=""Exit"" ProviderName=""Microsoft-System-Net-NameResolution"" thisOrContextObject=""(null)"" memberName=""GetHostEntry"" result=""IPHostEntry#33476626""/>
```
and this for failing one:
```
<Event MSec=  ""4770.0633"" PID=""10308"" PName=""Process(10308)"" TID=""10308"" EventName=""Enter"" ProviderName=""Microsoft-System-Net-NameResolution"" thisOrContextObject=""(null)"" memberName=""GetHostEntry"" parameters=""(www.foo2.com)""/>
<Event MSec=  ""4771.6036"" PID=""10308"" PName=""Process(10308)"" TID=""10308"" EventName=""Enter"" ProviderName=""Microsoft-System-Net-NameResolution"" thisOrContextObject=""(null)"" memberName=""InternalGetHostByName"" parameters=""(www.foo22.com)""/>
```

There are several issue: 
- the successful case has duplicate entires - one for GetHostEntry and one for InternalGetHostByName. It seems like we should either trace entry/exit on  public function or on internal implementation. Right now we create trace entires without added value. 
- the unsuccessful case has no details or entry about failure. If somebody would use filter like `COMPlus_EventPipeConfig=*:0xFFFFFFFFFFFFFFFF:3` to get all errors (or higher) would get nothing at all. 

The Async version is similar. For two sucessfull lookups I get something like 
```
<Event MSec=  ""1622.1247"" PID=""11101"" PName=""Process(11101)"" TID=""11101"" EventName=""Enter"" ProviderName=""Microsoft-System-Net-NameResolution"" thisOrContextObject=""(null)"" memberName=""BeginGetHostEntry"" parameters=""(www.foo.com)""/>
<Event MSec=  ""1624.5354"" PID=""11101"" PName=""Process(11101)"" TID=""11101"" EventName=""Exit"" ProviderName=""Microsoft-System-Net-NameResolution"" thisOrContextObject=""(null)"" memberName=""BeginGetHostEntry"" result=""DnsResolveAsyncResult#33476626""/>
<Event MSec=  ""1624.5881"" PID=""11101"" PName=""Process(11101)"" TID=""11101"" EventName=""Enter"" ProviderName=""Microsoft-System-Net-NameResolution"" thisOrContextObject=""(null)"" memberName=""BeginGetHostEntry"" parameters=""(www.foo.com)""/>
<Event MSec=  ""1625.0484"" PID=""11101"" PName=""Process(11101)"" TID=""11101"" EventName=""Exit"" ProviderName=""Microsoft-System-Net-NameResolution"" thisOrContextObject=""(null)"" memberName=""BeginGetHostEntry"" result=""DnsResolveAsyncResult#27252167""/>
<Event MSec=  ""6647.5183"" PID=""11101"" PName=""Process(11101)"" TID=""11112"" EventName=""Enter"" ProviderName=""Microsoft-System-Net-NameResolution"" thisOrContextObject=""(null)"" memberName=""EndGetHostEntry"" parameters=""(DnsResolveAsyncResult#27252167)""/>
<Event MSec=  ""6647.5809"" PID=""11101"" PName=""Process(11101)"" TID=""11109"" EventName=""Enter"" ProviderName=""Microsoft-System-Net-NameResolution"" thisOrContextObject=""(null)"" memberName=""EndGetHostEntry"" parameters=""(DnsResolveAsyncResult#33476626)""/>
<Event MSec=  ""6647.6229"" PID=""11101"" PName=""Process(11101)"" TID=""11112"" EventName=""Exit"" ProviderName=""Microsoft-System-Net-NameResolution"" thisOrContextObject=""(null)"" memberName=""EndGetHostEntry"" result=""IPHostEntry#4032828""/>
<Event MSec=  ""6647.6674"" PID=""11101"" PName=""Process(11101)"" TID=""11109"" EventName=""Exit"" ProviderName=""Microsoft-System-Net-NameResolution"" thisOrContextObject=""(null)"" memberName=""EndGetHostEntry"" result=""IPHostEntry#6044116""/>
```

* since tasks are executed on ThreadPool I cannot anymore use TID to find matching Exit entries for Entry. So I cannot figure out how long took to do lookup and it is not possible find failing lookups by looking for missing Exit entries. 

**Proposal:** 

* We currently don't set context on entry/exit. We could set it to passed in string. That would allow us distinguish between lookups for different instances
* We could try/catch/throw in public functions but as @stephentoub quickly pointed out there is performance cost associated with that. We could do something like `catch (Exception) when (IsTracingEnabled())`  do pay the cost when tracing is enabled. However if we go with above proposal or if we find better way how to trace identity we can emit traces at the places where we throw. 

```c#
        private static object GetHostEntryOrAddressesCore(string hostName, bool justAddresses)
        {
            int hash = hostName.GetHashCode();
            if (NetEventSource.IsEnabled) NetEventSource.Enter(hostName, hostName);
            Console.WriteLine(""GetHostEntryOrAddressesCore start: {0} {1}"",  hostName, hostName.GetHashCode());
            ValidateHostName(hostName);

            SocketError errorCode = NameResolutionPal.TryGetAddrInfo(hostName, justAddresses, out string newHostName, out string[] aliases, out IPAddress[] addresses, out int nativeErrorCode);
            if (errorCode != SocketError.Success)
            {
+                if (NetEventSource.IsEnabled) NetEventSource.Error(hostName, $""{hostName} DNS lookup failed with {errorCode}"");
                throw SocketExceptionFactory.CreateSocketException(errorCode, nativeErrorCode);
            }
```
```
<Event MSec=   ""322.2866"" PID=""14211"" PName=""Process(14211)"" TID=""14211"" EventName=""Info"" ProviderName=""Microsoft-System-Net-NameResolution"" thisOrContextObject=""String#-263748031"" memberName=""GetHostEntryOrAddressesCoreAsync"" message=""www.foo.com""/>
<Event MSec=   ""324.5510"" PID=""14211"" PName=""Process(14211)"" TID=""14211"" EventName=""Info"" ProviderName=""Microsoft-System-Net-NameResolution"" thisOrContextObject=""String#-349866304"" memberName=""GetHostEntryOrAddressesCoreAsync"" message=""www.foo22.com""/>
<Event MSec=   ""326.1782"" PID=""14211"" PName=""Process(14211)"" TID=""14219"" EventName=""Enter"" ProviderName=""Microsoft-System-Net-NameResolution"" thisOrContextObject=""String#-263748031"" memberName=""GetHostEntryOrAddressesCore"" parameters=""(www.foo.com)""/>
<Event MSec=   ""326.2288"" PID=""14211"" PName=""Process(14211)"" TID=""14221"" EventName=""Enter"" ProviderName=""Microsoft-System-Net-NameResolution"" thisOrContextObject=""String#-349866304"" memberName=""GetHostEntryOrAddressesCore"" parameters=""(www.foo22.com)""/>
<Event MSec=  ""5354.9991"" PID=""14211"" PName=""Process(14211)"" TID=""14219"" EventName=""Exit"" ProviderName=""Microsoft-System-Net-NameResolution"" thisOrContextObject=""String#-263748031"" memberName=""GetHostEntryOrAddressesCore"" result=""IPHostEntry#6044116, 2""/>
<Event MSec=  ""5366.5515"" PID=""14211"" PName=""Process(14211)"" TID=""14221"" EventName=""ErrorMessage"" ProviderName=""Microsoft-System-Net-NameResolution"" thisOrContextObject=""String#-349866304"" memberName=""GetHostEntryOrAddressesCore"" message=""www.foo22.com DNS lookup failed with HostNotFound""/>

``` 

This would allow to pair Enter/Exit for successful cases as well as provide useful info on failures. When `*:0xFFFFFFFFFFFFFFFF:3` filter is used, it would show just the failing message without any additional craft. For that reason I think we should repeat failing name instead  of relying on Entry (as the record may not be available) 

For successful case I also throw  length of address list `result=""IPHostEntry#6044116, 2""/>` so the log would show to how many IP addresses name resolved to. 

```c#
 if (NetEventSource.IsEnabled) NetEventSource.Exit(hostName, result, addresses.Length);
```
","tracing in NameResolution should be improved  I wrote simple app to lookup one name expected to succeed and one expected to fail:
 
```c#
Task t1 = Task.Run(() => Dns.GetHostEntry(""www.foo.com""));
Task t2 = Task.Run(() => Dns.GetHostEntry(""www.foo22.c",42428,wfurt,corefx
23284,PrivateMemorySize64,"Writing code in Dotcore 2.0 and trying to use ```Process.GetCurrentProcess().PrivateMemorySize64``` on Linux will yield 0 as a result where by Windows OS's return the expected results.

Is this intended ?","PrivateMemorySize64  Writing code in Dotcore 2.0 and trying to use ```Process.GetCurrentProcess().PrivateMemorySize64``` on Linux will yield 0 as a result where by Windows OS's return the expected results.

Is this intended ?",42370,danmosemsft,corefx
28990,.NET Core Process APIs not Consistent (or always useful) in all situations,"# .NET Core Process APIs not Consistent (or always useful) in all situations

The Process APIs should return accurate and useful values in all situations. I wrote a [simple app that uses all the memory APIs](https://gist.github.com/richlander/6a88c41e06dc92751fa28e43124796cf) I could find. I am happy to add more if people direct me to them.

Major take-aways:

* Multiple properties return a value of 0 on Unix.
* `Process.MaxWorkingSet` != `memory.limit_in_bytes` when memory limited
* `Process.WorkingSet64` != `memory.usage_in_bytes`

Related issues:

* [PrivateMemorySize64](https://github.com/dotnet/corefx/issues/23449)
* [Process.MaxWorkingSet should read from /sys/fs/cgroup/memory when available](https://github.com/dotnet/corefx/issues/35638)

## On Windows

```console
C:\testapps\memory>dotnet run

***Configuration**
Build: .NET Core 3.0.0-preview4-27514-07
OS: Microsoft Windows 10.0.17763
OS Arch: X64

***Working set****
Process.MinWorkingSet: 204800
Process.MaxWorkingSet: 1413120
Process.PeakWorkingSet64: 15667200
Process.WorkingSet64: 15663104

***Memory*********
Process.PeakPagedMemorySize64: 267993088
Process.PrivateMemorySize64: 267993088
Process.NonpagedSystemMemorySize64: 42288
Process.PagedMemorySize64: 267993088
Process.PagedSystemMemorySize64: 138040

***Virtual memory
Process.VirtualMemorySize64: 2307580309504
Process.PeakVirtualMemorySize64: 2307580309504
```

## On Linux

```console
rich@tofino:~/memory$ dotnet run

***Configuration**
Build: .NET Core 3.0.0-preview4-27514-07
OS: Linux 3.10.105-bsp-1.2 dotnet/corefx#2 SMP PREEMPT Sat Oct 27 19:24:05 IST 2018
OS Arch: Arm64

***Working set****
Process.MinWorkingSet: 0
Process.MaxWorkingSet: 9223372036854775807
Process.PeakWorkingSet64: 0
Process.WorkingSet64: 18436096

***Memory*********
Process.PeakPagedMemorySize64: 0
Process.PrivateMemorySize64: 0
Process.NonpagedSystemMemorySize64: 0
Process.PagedMemorySize64: 0
Process.PagedSystemMemorySize64: 0

***Virtual memory
Process.VirtualMemorySize64: 2735525888
Process.PeakVirtualMemorySize64: 0

***CGroup*********
CGroup usage: 1644941312
CGroup memory limit: 9223372036854775807
```

## On macOS

```console
Richards-MacBook-Pro:memory rich$ dotnet run

***Configuration**
Build: .NET Core 3.0.0-preview4-27514-07
OS: Darwin 18.2.0 Darwin Kernel Version 18.2.0: Thu Dec 20 20:46:53 PST 2018; root:xnu-4903.241.1~1/RELEASE_X86_64
OS Arch: X64

***Working set****
Process.MinWorkingSet: 0
Process.MaxWorkingSet: 9223372036854775807
Process.PeakWorkingSet64: 0
Process.WorkingSet64: 18923520

***Memory*********
Process.PeakPagedMemorySize64: 0
Process.PrivateMemorySize64: 0
Process.NonpagedSystemMemorySize64: 0
Process.PagedMemorySize64: 0
Process.PagedSystemMemorySize64: 0

***Virtual memory
Process.VirtualMemorySize64: 6893395968
Process.PeakVirtualMemorySize64: 0
```

## On WSL

```console
rich@phantomlake:/mnt/c/testapps/memory$ ~/dotnet/dotnet run

***Configuration**
Build: .NET Core 3.0.0-preview4-27514-07
OS: Linux 4.4.0-17763-Microsoft dotnet/corefx#253-Microsoft Mon Dec 31 17:49:00 PST 2018
OS Arch: X64

***Working set****
Process.MinWorkingSet: 0
Process.MaxWorkingSet: 9223372036854775807
Process.PeakWorkingSet64: 0
Process.WorkingSet64: 17985536

***Memory*********
Process.PeakPagedMemorySize64: 0
Process.PrivateMemorySize64: 0
Process.NonpagedSystemMemorySize64: 0
Process.PagedMemorySize64: 0
Process.PagedSystemMemorySize64: 0

***Virtual memory
Process.VirtualMemorySize64: 84865474560
Process.PeakVirtualMemorySize64: 0
```

## On Linux running in a Debian container on Windows

```console
C:\testapps\memory>docker run --rm -v c:\testapps\memory:/app -w /app mcr.microsoft.com/dotnet/core-nightly/sdk:3.0 dotnet run

***Configuration**
Build: .NET Core 3.0.0-preview4-27508-07
OS: Linux 4.9.125-linuxkit dotnet/corefx#1 SMP Fri Sep 7 08:20:28 UTC 2018
OS Arch: X64

***Working set****
Process.MinWorkingSet: 0
Process.MaxWorkingSet: 9223372036854775807
Process.PeakWorkingSet64: 0
Process.WorkingSet64: 25559040

***Memory*********
Process.PeakPagedMemorySize64: 0
Process.PrivateMemorySize64: 0
Process.NonpagedSystemMemorySize64: 0
Process.PagedMemorySize64: 0
Process.PagedSystemMemorySize64: 0

***Virtual memory
Process.VirtualMemorySize64: 2689052672
Process.PeakVirtualMemorySize64: 0

***CGroup*********
CGroup usage: 76718080
CGroup memory limit: 9223372036854771712
```
## On Linux running in a Debian container on Windows -- memory-limited to 100MB

```console
C:\testapps\memory>docker run -m 100mb --rm -v c:\testapps\memory:/app -w /app mcr.microsoft.com/dotnet/core-nightly/sdk:3.0 dotnet run

***Configuration**
Build: .NET Core 3.0.0-preview4-27508-07
OS: Linux 4.9.125-linuxkit dotnet/corefx#1 SMP Fri Sep 7 08:20:28 UTC 2018
OS Arch: X64

***Working set****
Process.MinWorkingSet: 0
Process.MaxWorkingSet: 9223372036854775807
Process.PeakWorkingSet64: 0
Process.WorkingSet64: 25604096

***Memory*********
Process.PeakPagedMemorySize64: 0
Process.PrivateMemorySize64: 0
Process.NonpagedSystemMemorySize64: 0
Process.PagedMemorySize64: 0
Process.PagedSystemMemorySize64: 0

***Virtual memory
Process.VirtualMemorySize64: 2688528384
Process.PeakVirtualMemorySize64: 0

***CGroup*********
CGroup usage: 72470528
CGroup memory limit: 104857600
```",".NET Core Process APIs not Consistent (or always useful) in all situations  # .NET Core Process APIs not Consistent (or always useful) in all situations

The Process APIs should return accurate and useful values in all situations. I wrote a [simple app",42370,danmosemsft,corefx
31309,JsonSerializer NRE when deserializing object from array (bad error message),"I accidentally tried to deserialize some JSON using the wrong datatype and got a `NullReferenceException`. I think the error message should be improved.

sample:
```csharp
using System;
using System.Collections.Generic;

namespace stjCrash
{
    class Program
    {
        static void Main(string[] args)
        {
            var json = ""{\""key\"":[{\""name\"": \""something\""}]}"";

            TryRun(""System.Text.Json correct type"", () => System.Text.Json.JsonSerializer.Deserialize<Dictionary<string, List<Value>>>(json));
            TryRun(""System.Text.Json wrong type"", () => System.Text.Json.JsonSerializer.Deserialize<Dictionary<string, Value>>(json));

            TryRun(""Newtonsoft.Json correct type"", () => Newtonsoft.Json.JsonConvert.DeserializeObject<Dictionary<string, List<Value>>>(json));
            TryRun(""Newtonsoft.Json wrong type"", () => Newtonsoft.Json.JsonConvert.DeserializeObject<Dictionary<string, Value>>(json));
        }

        private static void TryRun(string name, Func<object> a)
        {
            try
            {
                a.Invoke();
                Console.WriteLine(name + "" succeeded"");
            }
            catch (Exception e)
            {
                Console.WriteLine(name + "" crashed ("" + e.GetType().Name + ""): "" + e.Message);
            }
        }

        private class Value
        {
            public string Name { get; set; }
        }
    }
}
```

output:
```text
System.Text.Json correct type succeeded
System.Text.Json wrong type crashed (NullReferenceException): Object reference not set to an instance of an object.
Newtonsoft.Json correct type succeeded
Newtonsoft.Json wrong type crashed (JsonSerializationException): Cannot deserialize the current JSON array (e.g. [1,2,3]) into type 'stjCrash.Program+Value' because the type requires a JSON object (e.g. {""name"":""value""}) to deserialize correctly.
To fix this error either change the JSON to a JSON object (e.g. {""name"":""value""}) or change the deserialized type to an array or a type that implements a collection interface (e.g. ICollection, IList) like List<T> that can be deserialized from a JSON array. JsonArrayAttribute can also be added to the type to force it to deserialize from a JSON array.
Path 'key', line 1, position 8.
```","JsonSerializer NRE when deserializing object from array (bad error message)  I accidentally tried to deserialize some JSON using the wrong datatype and got a `NullReferenceException`. I think the error message should be improved.

sample:
```csharp
us",42308,layomia,corefx
31192,[System.Text.Json] Null ref when attempting to deserialize an json object as an array,"Ran in to this by accident. Not entirely sure if it's already fixed \ tracked since there's a few that are pretty similar to this one:

```C#
using System.Text.Json;

namespace ConsoleApp3
{
    class Program
    {
        static void Main(string[] args)
        {
            var json = JsonSerializer.Deserialize<int[]>(""{ \""a\"": \""b\"" }"");
        }
    }
}
```

```
Unhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.
   at System.Text.Json.JsonClassInfo.GetProperty(ReadOnlySpan`1 propertyName, ReadStackFrame& frame)
   at System.Text.Json.JsonSerializer.HandlePropertyName(JsonSerializerOptions options, Utf8JsonReader& reader, ReadStack& state)
   at System.Text.Json.JsonSerializer.ReadCore(JsonSerializerOptions options, Utf8JsonReader& reader, ReadStack& readStack)
   at System.Text.Json.JsonSerializer.ReadCore(Type returnType, JsonSerializerOptions options, Utf8JsonReader& reader)
   at System.Text.Json.JsonSerializer.ParseCore(String json, Type returnType, JsonSerializerOptions options)
   at System.Text.Json.JsonSerializer.Deserialize[TValue](String json, JsonSerializerOptions options)
```","[System.Text.Json] Null ref when attempting to deserialize an json object as an array  Ran in to this by accident. Not entirely sure if it's already fixed \ tracked since there's a few that are pretty similar to this one:

```C#
using System.Text.Json;",42308,layomia,corefx
40490,Fix issue causing subsequent properties to be skipped during deserialization once a dictionary has been skipped,"Given a class set up like this...
```
        public class ClassWithPopulatedDictionaryAndNoSetter
        {
            public Dictionary<string, string> MyDictionary { get; } = new Dictionary<string, string>() { { ""Key"", ""Value"" } };

            public IDictionary<string, string> MyDictionaryWithSetter { get; set; }
        }
```
...and some json like this...
```
{""MyDictionary"":{""Key1"":""Value1"", ""Key2"":""Value2""},""MyDictionaryWithSetter"":{""Key1"":""Value1""}}
```
...the JsonSerializer.Deserialize operation will correctly skip ""MyDictionary"" because it doesn't have a public setter, but won't parse ""MyDictionaryWithSetter"" because it gets stuck in an open dictionary state.","Fix issue causing subsequent properties to be skipped during deserialization once a dictionary has been skipped  Given a class set up like this...
```
        public class ClassWithPopulatedDictionaryAndNoSetter
        {
            public Dictionary",40629,steveharter,corefx
40598,Add additional skip tests and prevent reset of property index for perf,"Additional tests added on top of https://github.com/dotnet/corefx/pull/40490. That PR along with these tests will be added to 3.0 ask mode.

Also changed a call from `EndObject` to `EndProperty` so the property ""index"" doesn't reset to 0. This only affects perf since that index is used to quickly look up properties from the property cache, and when reset to 0 will have to search more properties.

cc @CodeBlanch, @ericstj
","Add additional skip tests and prevent reset of property index for perf  Additional tests added on top of https://github.com/dotnet/corefx/pull/40490. That PR along with these tests will be added to 3.0 ask mode.

Also changed a call from `EndObject` to",40629,steveharter,corefx
31779,Optimize some Matrix4x4 operations with SSE,"This PR optimizes some `Matrix4x4` operations with SSE (see https://github.com/dotnet/corefx/issues/31425). Some of the operations could also be optimized with AVX but for some reason on my PC it performs worse than SSE ([VZEROUPPER](https://github.com/dotnet/coreclr/issues/18575)? or maybe CPU decreases AVX frequency due to rapid benchmarking?).

Environment:
```ini
.NET Core: .NET Core SDK=3.0.100-alpha1-20180720-2

Windows 10:
   Intel Core i7-8700K CPU 3.70GHz (Coffee Lake), 1 CPU, 12 logical and 6 physical cores

macOS 10.13:
   Intel Core i7-4980HQ CPU 2.80GHz (Haswell), 1 CPU, 8 logical and 4 physical cores
```

## Matrix4x4.Add (Matrix4x4, Matrix4x4) and Subtract
`Matrix4x4 result = matrix1 + matrix2;`

Windows (Coffee Lake):

|  Method |      Mean | Scaled |
|-------- |----------:|-------:|
| Add_old | 13.353 ns |   1.00 |
| Add_new |  4.486 ns |   0.34 |

macOS (Haswell):

|  Method |      Mean | Scaled |
|-------- |----------:|-------:|
| Add_old | 15.347 ns |   1.00 |
| Add_new |  7.473 ns |   0.49 |


## Matrix4x4.Lerp (Matrix4x4, Matrix4x4, float)
`Matrix4x4 result = Matrix4x4.Lerp(matrix1, matrix2, amount);`

Windows (Coffee Lake):

|   Method |      Mean | Scaled |
|--------- |----------:|-------:|
| Lerp_old | 15.286 ns |   1.00 |
| Lerp_new |  5.365 ns |   0.35 |

macOS (Haswell):

|   Method |      Mean | Scaled |
|--------- |----------:|-------:|
| Lerp_old | 17.047 ns |   1.00 |
| Lerp_new |  7.657 ns |   0.45 |

## Matrix4x4.Multiply (Matrix4x4, Matrix4x4)
`Matrix4x4 result = matrix1 * matrix2;`

Windows (Coffee Lake):

|       Method |      Mean | Scaled |
|------------- |----------:|-------:|
| Multiply_old | 27.146 ns |   1.00 |
| Multiply_new |  7.461 ns |   0.27 |

macOS (Haswell):

|       Method |     Mean | Scaled |
|------------- |---------:|-------:|
| Multiply_old | 32.05 ns |   1.00 |
| Multiply_new | 11.24 ns |   0.35 |

## Matrix4x4.Multiply (Matrix4x4, float)
`Matrix4x4 result = matrix1 * scalar;`

Windows (Coffee Lake):

|               Method |      Mean | Scaled |
|--------------------- |----------:|-------:|
| MultiplyByScalar_old | 12.927 ns |   1.00 |
| MultiplyByScalar_new |  3.284 ns |   0.25 |

macOS (Haswell):

|               Method |      Mean | Scaled |
|--------------------- |----------:|-------:|
| MultiplyByScalar_old | 14.334 ns |   1.00 |
| MultiplyByScalar_new |  5.086 ns |   0.35 |

## Matrix4x4.Negate (Matrix4x4)
`Matrix4x4 result = -matrix1;`

Windows (Coffee Lake):

|     Method |      Mean | Scaled |
|----------- |----------:|-------:|
| Negate_old | 12.932 ns |   1.00 |
| Negate_new |  3.187 ns |   0.25 |

macOS (Haswell):

|     Method |      Mean | Scaled |
|----------- |----------:|-------:|
| Negate_old | 14.877 ns |   1.00 |
| Negate_new |  5.201 ns |   0.35 |

## Matrix4x4.Equals (Matrix4x4)
`bool result = matrix1 == matrix2;`

Windows (Coffee Lake):

|              Method |     Mean |
|-------------------- |---------:|
| Equals_NotEqual_old | 1.742 ns |
| Equals_NotEqual_new | 1.581 ns |
|    Equals_Equal_old | 7.081 ns |
|    Equals_Equal_new | 2.960 ns |

macOS (Haswell):

|              Method |     Mean |
|-------------------- |---------:|
| Equals_NotEqual_old | 3.172 ns |
| Equals_NotEqual_new | 3.022 ns |
|    Equals_Equal_old | 8.180 ns |
|    Equals_Equal_new | 4.618 ns |

## Matrix4x4.Transpose (Matrix4x4)
`Matrix4x4 result = Matrix4x4.Transpose(matrix1);`

Windows (Coffee Lake):

|        Method |      Mean | Scaled |
|-------------- |----------:|-------:|
| Transpose_old | 12.720 ns |   1.00 |
| Transpose_new |  3.156 ns |   0.25 |

macOS (Haswell):

|        Method |      Mean | Scaled |
|-------------- |----------:|-------:|
| Transpose_old | 14.297 ns |   1.00 |
| Transpose_new |  5.548 ns |   0.39 |

Benchmarks: https://gist.github.com/EgorBo/c80a25517245374c8dcdca2af4536ffe",Optimize some Matrix4x4 operations with SSE  This PR optimizes some `Matrix4x4` operations with SSE (see https://github.com/dotnet/corefx/issues/31425). Some of the operations could also be optimized with AVX but for some reason on my PC it performs worse,40564,aashikgowda,corefx
30420,Audit the existing System.Numerics tests to validate the inputs are not all the same,"It was discovered that https://github.com/dotnet/corefx/pull/31779 introduced a regression due to the values for certain tests being the same between the LHS and RHS inputs.

We should audit the tests to ensure that they are testing unique inputs as well so that core functionality isn't missed and more regressions aren't introduced.",Audit the existing System.Numerics tests to validate the inputs are not all the same  It was discovered that https://github.com/dotnet/corefx/pull/31779 introduced a regression due to the values for certain tests being the same between the LHS and RHS inp,40564,aashikgowda,corefx
29995,Intermittent failure in FileSystemWatcherTests,"From https://github.com/dotnet/coreclr/pull/25351

```
Unhandled Exception of Type System.IO.DirectoryNotFoundException
Message :
System.IO.DirectoryNotFoundException : Could not find a part of the path '/tmp/FileSystemWatcherTests_vofmaf3s.f0n/FileSystemWatcher_Directory_Delete_MultipleFilters_1052_599c36fe/FileSystemWatcher_Directory_Delete_MultipleFilters_1053_43fc314a'.
Stack Trace :
   at System.IO.FileSystem.RemoveDirectory(String fullPath, Boolean recursive) in /_/src/System.IO.FileSystem/src/System/IO/FileSystem.Unix.cs:line 383
   at System.IO.Tests.FileSystemWatcherTest.ExecuteAndVerifyEvents(FileSystemWatcher watcher, WatcherChangeTypes expectedEvents, Action action, Boolean assertExpected, String[] expectedPaths, Int32 timeout) in /_/src/System.IO.FileSystem.Watcher/tests/Utility/FileSystemWatcherTest.cs:line 254
   at System.IO.Tests.FileSystemWatcherTest.ExpectEvent(FileSystemWatcher watcher, WatcherChangeTypes expectedEvents, Action action, Action cleanup, String[] expectedPaths, Int32 attempts, Int32 timeout) in /_/src/System.IO.FileSystem.Watcher/tests/Utility/FileSystemWatcherTest.cs:line 182
   at System.IO.Tests.FileSystemWatcherTests.FileSystemWatcher_Directory_Delete_MultipleFilters()
```","Intermittent failure in FileSystemWatcherTests  From https://github.com/dotnet/coreclr/pull/25351

```
Unhandled Exception of Type System.IO.DirectoryNotFoundException
Message :
System.IO.DirectoryNotFoundException : Could not find a part of the path",40543,wfurt,corefx
28319,FileSystemWatcher_File_Create_ForceLoopRestart failed on Unix,"Seems rare/sporadic.
```
System.IO.Tests.FileSystemWatcher_Multiple_Test.FileSystemWatcher_File_Create_ForceLoopRestart(useExistingWatchers: False)
Failed 5 hours ago
Duration0:00:03.310
Ownernot available

Debug

Work items

Attachments

History
Error message
Assert.True() Failure\nExpected: True\nActual: False
Stack trace
   at System.IO.Tests.FileSystemWatcher_Multiple_Test.<>c__DisplayClass3_0.<FileSystemWatcher_File_Create_ForceLoopRestart>b__0() in /__w/1/s/src/System.IO.FileSystem.Watcher/tests/FileSystemWatcher.MultipleWatchers.cs:line 144
   at System.IO.Tests.FileSystemWatcherTest.ExecuteWithRetry(Action action, Int32 maxAttempts) in /__w/1/s/src/System.IO.FileSystem.Watcher/tests/Utility/FileSystemWatcherTest.cs:line 198
   at System.IO.Tests.FileSystemWatcher_Multiple_Test.FileSystemWatcher_File_Create_ForceLoopRestart(Boolean useExistingWatchers) in /__w/1/s/src/System.IO.FileSystem.Watcher/tests/FileSystemWatcher.MultipleWatchers.cs:line 189
```","FileSystemWatcher_File_Create_ForceLoopRestart failed on Unix  Seems rare/sporadic.
```
System.IO.Tests.FileSystemWatcher_Multiple_Test.FileSystemWatcher_File_Create_ForceLoopRestart(useExistingWatchers: False)
Failed 5 hours ago
Duration0:00:03.310",40543,wfurt,corefx
30633,Possible unintended NullReferenceException thrown from JsonSerializer.Deserialize,"Tested with master branch (as of 2fac89f63c644ab81d936d62c91e6003302e718d)
The following code:

```c#
using System.Text.Json;
using System.Collections.Generic;

interface X {}

class A : List<X> {}

class Program
{
  static void Main(string[] args) => JsonSerializer.Deserialize<A>(""false"");
}
```

throws `NullReferenceException`:

```
Unhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.
   at System.Text.Json.JsonPropertyInfo.Read(JsonTokenType tokenType, ReadStack& state, Utf8JsonReader& reader)
   at System.Text.Json.JsonSerializer.HandleValue(JsonTokenType tokenType, JsonSerializerOptions options, Utf8JsonReader& reader, ReadStack& state)
   at System.Text.Json.JsonSerializer.ReadCore(JsonSerializerOptions options, Utf8JsonReader& reader, ReadStack& readStack)
   at System.Text.Json.JsonSerializer.ReadCore(Type returnType, JsonSerializerOptions options, Utf8JsonReader& reader)
   at System.Text.Json.JsonSerializer.ParseCore(String json, Type returnType, JsonSerializerOptions options)
   at System.Text.Json.JsonSerializer.Deserialize[TValue](String json, JsonSerializerOptions options)
```

if we remove `: List<X>`, then it throws `JsonException`:

```
Unhandled exception. System.Text.Json.JsonException: The JSON value could not be converted to myApp.A. Path: $ | LineNumber: 0 | BytePositionInLine: 5.
   at System.Text.Json.ThrowHelper.ThrowJsonException(String message, Utf8JsonReader& reader, String path, Exception innerException)
   at System.Text.Json.ThrowHelper.ThrowJsonException_DeserializeUnableToConvertValue(Type propertyType, Utf8JsonReader& reader, String path, Exception innerException)
   at System.Text.Json.JsonPropertyInfoNotNullable`4.OnRead(JsonTokenType tokenType, ReadStack& state, Utf8JsonReader& reader)
   at System.Text.Json.JsonPropertyInfo.Read(JsonTokenType tokenType, ReadStack& state, Utf8JsonReader& reader)
   at System.Text.Json.JsonSerializer.HandleValue(JsonTokenType tokenType, JsonSerializerOptions options, Utf8JsonReader& reader, ReadStack& state)
   at System.Text.Json.JsonSerializer.ReadCore(JsonSerializerOptions options, Utf8JsonReader& reader, ReadStack& readStack)
   at System.Text.Json.JsonSerializer.ReadCore(Type returnType, JsonSerializerOptions options, Utf8JsonReader& reader)
   at System.Text.Json.JsonSerializer.ParseCore(String json, Type returnType, JsonSerializerOptions options)
   at System.Text.Json.JsonSerializer.Deserialize[TValue](String json, JsonSerializerOptions options)
```

if we keep `: List<X>` and replace `""false""` with `""{}""`, then we get `NotSupportedException`:

```
Unhandled exception. System.NotSupportedException: Deserialization of interface types is not supported. Type 'X'
   at System.Text.Json.ThrowHelper.ThrowInvalidOperationException_DeserializePolymorphicInterface(Type invalidType)
   at System.Text.Json.JsonSerializer.HandleStartObject(JsonSerializerOptions options, Utf8JsonReader& reader, ReadStack& state)
   at System.Text.Json.JsonSerializer.ReadCore(JsonSerializerOptions options, Utf8JsonReader& reader, ReadStack& readStack)
   at System.Text.Json.JsonSerializer.ReadCore(Type returnType, JsonSerializerOptions options, Utf8JsonReader& reader)
   at System.Text.Json.JsonSerializer.ParseCore(String json, Type returnType, JsonSerializerOptions options)
   at System.Text.Json.JsonSerializer.Deserialize[TValue](String json, JsonSerializerOptions options)
```

I think `NotSupportedException` is desired in place of NRE from the original repro until there is an interface support. After the support is added, `JsonException` would be desired here (similar to the one we get without `: List<X>`).","Possible unintended NullReferenceException thrown from JsonSerializer.Deserialize  Tested with master branch (as of 2fac89f63c644ab81d936d62c91e6003302e718d)
The following code:

```c#
using System.Text.Json;
using System.Collections.Generic;

inte",40501,am11,corefx
39838,fix Matrix4x4 + and - operator bugs,"The new SSE versions of the operators add/subtract `value1` to/from itself.  The tests were set up with the same value for both arguments, so they didn't catch the issue.  Fixed both.","fix Matrix4x4 + and - operator bugs  The new SSE versions of the operators add/subtract `value1` to/from itself.  The tests were set up with the same value for both arguments, so they didn't catch the issue.  Fixed both.",39889,tannergooding,corefx
31779,Optimize some Matrix4x4 operations with SSE,"This PR optimizes some `Matrix4x4` operations with SSE (see https://github.com/dotnet/corefx/issues/31425). Some of the operations could also be optimized with AVX but for some reason on my PC it performs worse than SSE ([VZEROUPPER](https://github.com/dotnet/coreclr/issues/18575)? or maybe CPU decreases AVX frequency due to rapid benchmarking?).

Environment:
```ini
.NET Core: .NET Core SDK=3.0.100-alpha1-20180720-2

Windows 10:
   Intel Core i7-8700K CPU 3.70GHz (Coffee Lake), 1 CPU, 12 logical and 6 physical cores

macOS 10.13:
   Intel Core i7-4980HQ CPU 2.80GHz (Haswell), 1 CPU, 8 logical and 4 physical cores
```

## Matrix4x4.Add (Matrix4x4, Matrix4x4) and Subtract
`Matrix4x4 result = matrix1 + matrix2;`

Windows (Coffee Lake):

|  Method |      Mean | Scaled |
|-------- |----------:|-------:|
| Add_old | 13.353 ns |   1.00 |
| Add_new |  4.486 ns |   0.34 |

macOS (Haswell):

|  Method |      Mean | Scaled |
|-------- |----------:|-------:|
| Add_old | 15.347 ns |   1.00 |
| Add_new |  7.473 ns |   0.49 |


## Matrix4x4.Lerp (Matrix4x4, Matrix4x4, float)
`Matrix4x4 result = Matrix4x4.Lerp(matrix1, matrix2, amount);`

Windows (Coffee Lake):

|   Method |      Mean | Scaled |
|--------- |----------:|-------:|
| Lerp_old | 15.286 ns |   1.00 |
| Lerp_new |  5.365 ns |   0.35 |

macOS (Haswell):

|   Method |      Mean | Scaled |
|--------- |----------:|-------:|
| Lerp_old | 17.047 ns |   1.00 |
| Lerp_new |  7.657 ns |   0.45 |

## Matrix4x4.Multiply (Matrix4x4, Matrix4x4)
`Matrix4x4 result = matrix1 * matrix2;`

Windows (Coffee Lake):

|       Method |      Mean | Scaled |
|------------- |----------:|-------:|
| Multiply_old | 27.146 ns |   1.00 |
| Multiply_new |  7.461 ns |   0.27 |

macOS (Haswell):

|       Method |     Mean | Scaled |
|------------- |---------:|-------:|
| Multiply_old | 32.05 ns |   1.00 |
| Multiply_new | 11.24 ns |   0.35 |

## Matrix4x4.Multiply (Matrix4x4, float)
`Matrix4x4 result = matrix1 * scalar;`

Windows (Coffee Lake):

|               Method |      Mean | Scaled |
|--------------------- |----------:|-------:|
| MultiplyByScalar_old | 12.927 ns |   1.00 |
| MultiplyByScalar_new |  3.284 ns |   0.25 |

macOS (Haswell):

|               Method |      Mean | Scaled |
|--------------------- |----------:|-------:|
| MultiplyByScalar_old | 14.334 ns |   1.00 |
| MultiplyByScalar_new |  5.086 ns |   0.35 |

## Matrix4x4.Negate (Matrix4x4)
`Matrix4x4 result = -matrix1;`

Windows (Coffee Lake):

|     Method |      Mean | Scaled |
|----------- |----------:|-------:|
| Negate_old | 12.932 ns |   1.00 |
| Negate_new |  3.187 ns |   0.25 |

macOS (Haswell):

|     Method |      Mean | Scaled |
|----------- |----------:|-------:|
| Negate_old | 14.877 ns |   1.00 |
| Negate_new |  5.201 ns |   0.35 |

## Matrix4x4.Equals (Matrix4x4)
`bool result = matrix1 == matrix2;`

Windows (Coffee Lake):

|              Method |     Mean |
|-------------------- |---------:|
| Equals_NotEqual_old | 1.742 ns |
| Equals_NotEqual_new | 1.581 ns |
|    Equals_Equal_old | 7.081 ns |
|    Equals_Equal_new | 2.960 ns |

macOS (Haswell):

|              Method |     Mean |
|-------------------- |---------:|
| Equals_NotEqual_old | 3.172 ns |
| Equals_NotEqual_new | 3.022 ns |
|    Equals_Equal_old | 8.180 ns |
|    Equals_Equal_new | 4.618 ns |

## Matrix4x4.Transpose (Matrix4x4)
`Matrix4x4 result = Matrix4x4.Transpose(matrix1);`

Windows (Coffee Lake):

|        Method |      Mean | Scaled |
|-------------- |----------:|-------:|
| Transpose_old | 12.720 ns |   1.00 |
| Transpose_new |  3.156 ns |   0.25 |

macOS (Haswell):

|        Method |      Mean | Scaled |
|-------------- |----------:|-------:|
| Transpose_old | 14.297 ns |   1.00 |
| Transpose_new |  5.548 ns |   0.39 |

Benchmarks: https://gist.github.com/EgorBo/c80a25517245374c8dcdca2af4536ffe",Optimize some Matrix4x4 operations with SSE  This PR optimizes some `Matrix4x4` operations with SSE (see https://github.com/dotnet/corefx/issues/31425). Some of the operations could also be optimized with AVX but for some reason on my PC it performs worse,39889,tannergooding,corefx
30295,HTTP2: Hang when sending multiple requests from a HttpClient,"I'm not sure what the cause of this hang is, it appears to happen at HttpClient.SendAsync when the client has made at least one previous call.

Repro:
1. `git clone https://github.com/JamesNK/grpc-dotnet.git`
2. `git checkout jamesnk/hang-multiple-calls`
3. `dotnet test test\FunctionalTests --filter Name~DuplexStream_SendToUnimplementedMethodAfterResponseReceived_Hang`

Logic in the test is like:
1. Client makes HTTP/2 duplex call to the server
2. Server immediately returns 200 and ends request.
3. Client inspects headers.
4. Client completes request stream.
5. Go to 1.

It consistently hangs making the second or third call.

```
.NET Core SDK (reflecting any global.json):
 Version:   3.0.100-preview8-013248
 Commit:    135af55c46
```","HTTP2: Hang when sending multiple requests from a HttpClient  I'm not sure what the cause of this hang is, it appears to happen at HttpClient.SendAsync when the client has made at least one previous call.

Repro:
1. `git clone https://github.com/JamesN",39882,geoffkizer,corefx
30488,HTTP2: _expect100ContinueWaiter should use TaskCreationOptions.RunContinuationsAsynchronously,"https://github.com/dotnet/corefx/blob/master/src/System.Net.Http/src/System/Net/Http/SocketsHttpHandler/Http2Stream.cs#L119

It's using TaskContinuationOptions.RunContinuationsAsynchronously, which is incorrect.","HTTP2: _expect100ContinueWaiter should use TaskCreationOptions.RunContinuationsAsynchronously  https://github.com/dotnet/corefx/blob/master/src/System.Net.Http/src/System/Net/Http/SocketsHttpHandler/Http2Stream.cs#L119

It's using TaskContinuationOption",39882,geoffkizer,corefx
39834,HTTP2: Ensure we never send EndStream after RST_STREAM,"Fixes #39586 
Fixes #39819 

There's a timing gap currently which can result in us sending EndStream on the request body after we've already sent RST_STREAM, which is not allowed.

Fix this by ensuring we never send EndStream if we've already sent RST_STREAM.

@danmosemsft This will need to get ported to the 3.0 branch -- GRPC stress issue.

@eiriktsarpalis Can we add a stress variation that tries to induce this issue? See description in #39819 (edit: fixed issue # here) ","HTTP2: Ensure we never send EndStream after RST_STREAM  Fixes #39586 
Fixes #39819 

There's a timing gap currently which can result in us sending EndStream on the request body after we've already sent RST_STREAM, which is not allowed.

Fix this by e",39874,geoffkizer,corefx
30295,HTTP2: Hang when sending multiple requests from a HttpClient,"I'm not sure what the cause of this hang is, it appears to happen at HttpClient.SendAsync when the client has made at least one previous call.

Repro:
1. `git clone https://github.com/JamesNK/grpc-dotnet.git`
2. `git checkout jamesnk/hang-multiple-calls`
3. `dotnet test test\FunctionalTests --filter Name~DuplexStream_SendToUnimplementedMethodAfterResponseReceived_Hang`

Logic in the test is like:
1. Client makes HTTP/2 duplex call to the server
2. Server immediately returns 200 and ends request.
3. Client inspects headers.
4. Client completes request stream.
5. Go to 1.

It consistently hangs making the second or third call.

```
.NET Core SDK (reflecting any global.json):
 Version:   3.0.100-preview8-013248
 Commit:    135af55c46
```","HTTP2: Hang when sending multiple requests from a HttpClient  I'm not sure what the cause of this hang is, it appears to happen at HttpClient.SendAsync when the client has made at least one previous call.

Repro:
1. `git clone https://github.com/JamesN",39874,geoffkizer,corefx
30393,HTTP2: Race between response body Dispose and request body completion,"Found during GRPC stress.

If the client finishes sending the request body at approximately the same time that it disposes the response body without reading to the end, then there's a race between sending EndStream for the request body and RST_STREAM caused by the dispose. If the RST_STREAM ends up getting sent first, then this is a protocol violation.
","HTTP2: Race between response body Dispose and request body completion   Found during GRPC stress.

If the client finishes sending the request body at approximately the same time that it disposes the response body without reading to the end, then there's",39874,geoffkizer,corefx
39857,Fix WriteLargeKeyOrValue System.Text.Json test,"When the Utf8JsonWriter is disposed in the first part of the test, it flushes the WriteStartObject token to the ArrayBufferWriter, such that the output.WrittenCount is already 1 when the second part of the test starts, and then the Assert.Equal(0, output.WrittenCount) is doomed to fail.

Fixes https://github.com/dotnet/corefx/issues/39856

This was just broken by https://github.com/dotnet/corefx/pull/39560 in master and https://github.com/dotnet/corefx/pull/39850 in release/3.0.

cc: @ahsonkhan 

@danmosemsft, what are the rules now about porting to release/3.0, in this case a test-only fix?","Fix WriteLargeKeyOrValue System.Text.Json test  When the Utf8JsonWriter is disposed in the first part of the test, it flushes the WriteStartObject token to the ArrayBufferWriter, such that the output.WrittenCount is already 1 when the second part of the t",39867,stephentoub,corefx
30410,Utf8JsonWriterTests.WriteLargeKeyOrValue tests are failing,"```
      System.Text.Json.Tests.Utf8JsonWriterTests.WriteLargeKeyOrValue(formatted: True, skipValidation: True) [FAIL]
        Assert.Equal() Failure
        Expected: 0
        Actual:   1
        Stack Trace:
          d:\repos\corefx\src\System.Text.Json\tests\Utf8JsonWriterTests.cs(4996,0): at System.Text.Json.Tests.Utf8JsonWriterTests.WriteLargeKeyOrValue(Boolean formatted, Boolean skipValidation)
      System.Text.Json.Tests.Utf8JsonWriterTests.WriteLargeKeyOrValue(formatted: True, skipValidation: False) [FAIL]
        Assert.Equal() Failure
        Expected: 0
        Actual:   1
        Stack Trace:
          d:\repos\corefx\src\System.Text.Json\tests\Utf8JsonWriterTests.cs(4996,0): at System.Text.Json.Tests.Utf8JsonWriterTests.WriteLargeKeyOrValue(Boolean formatted, Boolean skipValidation)
      System.Text.Json.Tests.Utf8JsonWriterTests.WriteLargeKeyOrValue(formatted: False, skipValidation: True) [FAIL]
        Assert.Equal() Failure
        Expected: 0
        Actual:   1
        Stack Trace:
          d:\repos\corefx\src\System.Text.Json\tests\Utf8JsonWriterTests.cs(4996,0): at System.Text.Json.Tests.Utf8JsonWriterTests.WriteLargeKeyOrValue(Boolean formatted, Boolean skipValidation)
        Assert.Equal() Failure
      System.Text.Json.Tests.Utf8JsonWriterTests.WriteLargeKeyOrValue(formatted: False, skipValidation: False) [FAIL]
        Expected: 0
        Actual:   1
        Stack Trace:
          d:\repos\corefx\src\System.Text.Json\tests\Utf8JsonWriterTests.cs(4996,0): at System.Text.Json.Tests.Utf8JsonWriterTests.WriteLargeKeyOrValue(Boolean formatted, Boolean skipValidation)
```
cc: @ahsonkhan","Utf8JsonWriterTests.WriteLargeKeyOrValue tests are failing  ```
      System.Text.Json.Tests.Utf8JsonWriterTests.WriteLargeKeyOrValue(formatted: True, skipValidation: True) [FAIL]
        Assert.Equal() Failure
        Expected: 0
        Actual:   1",39867,stephentoub,corefx
39560,Use relaxed JavascriptEncoder in S.T.JSON specific tests to improve coverage.,cc @steveharter,Use relaxed JavascriptEncoder in S.T.JSON specific tests to improve coverage.  cc @steveharter,39867,stephentoub,corefx
39850,[release/3.0] Use relaxed JavascriptEncoder in S.T.JSON specific tests to improve coverage.,"Bringing in test additions from https://github.com/dotnet/corefx/pull/39560

cc @ericstj","[release/3.0] Use relaxed JavascriptEncoder in S.T.JSON specific tests to improve coverage.  Bringing in test additions from https://github.com/dotnet/corefx/pull/39560

cc @ericstj",39867,stephentoub,corefx
30393,HTTP2: Race between response body Dispose and request body completion,"Found during GRPC stress.

If the client finishes sending the request body at approximately the same time that it disposes the response body without reading to the end, then there's a race between sending EndStream for the request body and RST_STREAM caused by the dispose. If the RST_STREAM ends up getting sent first, then this is a protocol violation.
","HTTP2: Race between response body Dispose and request body completion   Found during GRPC stress.

If the client finishes sending the request body at approximately the same time that it disposes the response body without reading to the end, then there's",39860,eiriktsarpalis,corefx
39834,HTTP2: Ensure we never send EndStream after RST_STREAM,"Fixes #39586 
Fixes #39819 

There's a timing gap currently which can result in us sending EndStream on the request body after we've already sent RST_STREAM, which is not allowed.

Fix this by ensuring we never send EndStream if we've already sent RST_STREAM.

@danmosemsft This will need to get ported to the 3.0 branch -- GRPC stress issue.

@eiriktsarpalis Can we add a stress variation that tries to induce this issue? See description in #39819 (edit: fixed issue # here) ","HTTP2: Ensure we never send EndStream after RST_STREAM  Fixes #39586 
Fixes #39819 

There's a timing gap currently which can result in us sending EndStream on the request body after we've already sent RST_STREAM, which is not allowed.

Fix this by e",39860,eiriktsarpalis,corefx
30295,HTTP2: Hang when sending multiple requests from a HttpClient,"I'm not sure what the cause of this hang is, it appears to happen at HttpClient.SendAsync when the client has made at least one previous call.

Repro:
1. `git clone https://github.com/JamesNK/grpc-dotnet.git`
2. `git checkout jamesnk/hang-multiple-calls`
3. `dotnet test test\FunctionalTests --filter Name~DuplexStream_SendToUnimplementedMethodAfterResponseReceived_Hang`

Logic in the test is like:
1. Client makes HTTP/2 duplex call to the server
2. Server immediately returns 200 and ends request.
3. Client inspects headers.
4. Client completes request stream.
5. Go to 1.

It consistently hangs making the second or third call.

```
.NET Core SDK (reflecting any global.json):
 Version:   3.0.100-preview8-013248
 Commit:    135af55c46
```","HTTP2: Hang when sending multiple requests from a HttpClient  I'm not sure what the cause of this hang is, it appears to happen at HttpClient.SendAsync when the client has made at least one previous call.

Repro:
1. `git clone https://github.com/JamesN",39834,geoffkizer,corefx
30393,HTTP2: Race between response body Dispose and request body completion,"Found during GRPC stress.

If the client finishes sending the request body at approximately the same time that it disposes the response body without reading to the end, then there's a race between sending EndStream for the request body and RST_STREAM caused by the dispose. If the RST_STREAM ends up getting sent first, then this is a protocol violation.
","HTTP2: Race between response body Dispose and request body completion   Found during GRPC stress.

If the client finishes sending the request body at approximately the same time that it disposes the response body without reading to the end, then there's",39834,geoffkizer,corefx
39579,"Debian 10/Win8.1 fixes: Allow explicitly using SSLv3, TLS1.0/1.1","Fixes: #38444
Possibly fixes some other debian 10 issues (I've seen 50+ failures locally)

This fixes couple of things:
- Allow explicitly using SSLv3, TLS1.0/1.1 - before this fix OpenSSL defaulted to always disable them on some OSes (if you use SslProtocols.None this change has no effect for that)
- Same way lower bar for protocols when using AllowNoEncryption/NoEncryption
- Fixes Win 8.1 issue where explicitly setting protocols to TLS1.2 or higher and SSL2 at the same time is causing negotiation to always fail
- Convert System.Net.Security tests to not require IPv6 (they don't need it and it's disabled on docker by default)
- Couple of test fixes

With this my test run is green on Debian10 docker image","Debian 10/Win8.1 fixes: Allow explicitly using SSLv3, TLS1.0/1.1  Fixes: #38444
Possibly fixes some other debian 10 issues (I've seen 50+ failures locally)

This fixes couple of things:
- Allow explicitly using SSLv3, TLS1.0/1.1 - before this fix Open",39820,krwq,corefx
29850,"[Fedora.30] Test failure: System.Net.Security.Tests.ApmSslStreamSystemDefaultTest.ClientAndServer_OneOrBothUseDefault_Ok(clientProtocols: Tls12, serverProtocols: null)","Test `System.Net.Security.Tests.ApmSslStreamSystemDefaultTest/ClientAndServer_OneOrBothUseDefault_Ok(clientProtocols: Default, serverProtocols: null) ` has failed.

Message :
```
System.Security.Authentication.AuthenticationException : Authentication failed, see inner exception.
---- Interop+OpenSsl+SslException : SSL Handshake failed with OpenSSL error - SSL_ERROR_SSL.
-------- Interop+Crypto+OpenSslCryptographicException : error:141E70BF:SSL routines:tls_construct_client_hello:no protocols available
```
Stack Trace :
```
  at System.Net.Security.SslStream.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, ExceptionDispatchInfo exception) in /_/src/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs:line 713
   at System.Net.Security.SslStream.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest) in /_/src/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs:line 557
   at System.Net.Security.SslStream.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest) in /_/src/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs:line 528
   at System.Net.Security.SslStream.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest) in /_/src/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs:line 398
   at System.Net.Security.SslStream.ProcessAuthentication(LazyAsyncResult lazyResult, CancellationToken cancellationToken) in /_/src/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs:line 312
   at System.Net.Security.SslStream.BeginAuthenticateAsClient(SslClientAuthenticationOptions sslClientAuthenticationOptions, CancellationToken cancellationToken, AsyncCallback asyncCallback, Object asyncState) in /_/src/System.Net.Security/src/System/Net/Security/SslStream.cs:line 234
   at System.Net.Security.SslStream.BeginAuthenticateAsClient(String targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, Boolean checkCertificateRevocation, AsyncCallback asyncCallback, Object asyncState) in /_/src/System.Net.Security/src/System/Net/Security/SslStream.cs:line 222
   at System.Net.Security.Tests.ApmSslStreamSystemDefaultTest.<>c__DisplayClass0_0.<AuthenticateClientAsync>b__0(AsyncCallback callback, Object state) in /_/src/System.Net.Security/tests/FunctionalTests/SslStreamSystemDefaultsTest.cs:line 177
   at System.Threading.Tasks.TaskFactory`1.FromAsyncImpl(Func`3 beginMethod, Func`2 endFunction, Action`1 endAction, Object state, TaskCreationOptions creationOptions) in /_/src/System.Private.CoreLib/shared/System/Threading/Tasks/FutureFactory.cs:line 777
   at System.Threading.Tasks.TaskFactory.FromAsync(Func`3 beginMethod, Action`1 endMethod, Object state) in /_/src/System.Private.CoreLib/shared/System/Threading/Tasks/TaskFactory.cs:line 886
   at System.Net.Security.Tests.ApmSslStreamSystemDefaultTest.AuthenticateClientAsync(String targetHost, X509CertificateCollection clientCertificates, Boolean checkCertificateRevocation, Nullable`1 protocols) in /_/src/System.Net.Security/tests/FunctionalTests/SslStreamSystemDefaultsTest.cs:line 176
   at System.Net.Security.Tests.SslStreamSystemDefaultTest.ClientAndServer_OneOrBothUseDefault_Ok(Nullable`1 clientProtocols, Nullable`1 serverProtocols) in /_/src/System.Net.Security/tests/FunctionalTests/SslStreamSystemDefaultsTest.cs:line 60
--- End of stack trace from previous location where exception was thrown ---
----- Inner Stack Trace -----
   at Interop.OpenSsl.DoSslHandshake(SafeSslHandle context, Byte[] recvBuf, Int32 recvOffset, Int32 recvCount, Byte[]& sendBuf, Int32& sendCount) in /_/src/Common/src/Interop/Unix/System.Security.Cryptography.Native/Interop.OpenSsl.cs:line 282
   at System.Net.Security.SslStreamPal.HandshakeInternal(SafeFreeCredentials credential, SafeDeleteContext& context, ArraySegment`1 inputBuffer, Byte[]& outputBuffer, SslAuthenticationOptions sslAuthenticationOptions) in /_/src/System.Net.Security/src/System/Net/Security/SslStreamPal.Unix.cs:line 120
----- Inner Stack Trace -----
```
Build: -[20190610.76](https://mc.dot.net/#/user/dotnet-bot/pr~2Fdotnet~2Fcorefx~2Frefs~2Fheads~2Fmaster/test~2Ffunctional~2Fcli~2Finnerloop~2F/20190610.76)(Master)

Failing configurations:

- Debian.10.Amd64.Open-x64-Release
Details:
https://mc.dot.net/#/user/dotnet-bot/pr~2Fdotnet~2Fcorefx~2Frefs~2Fheads~2Fmaster/test~2Ffunctional~2Fcli~2Finnerloop~2F/20190610.76/workItem/System.Net.Security.Tests/analysis/xunit/System.Net.Security.Tests.ApmSslStreamSystemDefaultTest~2FClientAndServer_OneOrBothUseDefault_Ok(clientProtocols:%20Default,%20serverProtocols:%20null)","[Fedora.30] Test failure: System.Net.Security.Tests.ApmSslStreamSystemDefaultTest.ClientAndServer_OneOrBothUseDefault_Ok(clientProtocols: Tls12, serverProtocols: null)   Test `System.Net.Security.Tests.ApmSslStreamSystemDefaultTest/ClientAndServer_OneOrBo",39820,krwq,corefx
30361,JsonConverterAttribute cannot be applied to an Enum,"Since I'm trying to migrate from `Newtonsoft.Json` to the new `System.Text.Json` APIs, I have to be able to use a Enum-string converter.  

In json.net you can do this really easily with this attribute on the enum.  
```
[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
```

Since there is both a [JsonConverterAttribute](https://docs.microsoft.com/en-us/dotnet/api/system.text.json.serialization.jsonconverterattribute?view=netcore-3.0) and a [JsonStringEnumConverter](https://docs.microsoft.com/en-us/dotnet/api/system.text.json.serialization.jsonstringenumconverter?view=netcore-3.0) class, I thought you would do it like this:
```
[System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
```

However after getting a compiler error I quickly realized that the `JsonConverterAttribute` can't even be used on an Enum because it only has the following three `AttributeTargets`-flags.  
 - `AttributeTargets.Class`
 - `AttributeTargets.Struct`
 - `AttributeTargets.Property`

Are you not supposed to use this attribute and converter like this?  
Are there any samples because there I've not found any in [the docs](https://docs.microsoft.com/en-us/dotnet/api/system.text.json.serialization?view=netcore-3.0)?","JsonConverterAttribute cannot be applied to an Enum  Since I'm trying to migrate from `Newtonsoft.Json` to the new `System.Text.Json` APIs, I have to be able to use a Enum-string converter.  

In json.net you can do this really easily with this attribut",39812,steveharter,corefx
39790,Allow JsonConverterAttribute to be applied to an Enum,"Fixes https://github.com/dotnet/corefx/issues/39741

Add capability to specify custom converter for an Enum by using [JsonConverter] just like we support for properties, etc.

This does affect the ref/System.Text.Json.cs but only to change the attribute targets (not really an API change).

@ericstj assuming approved for master, requesting approval for release/3.0.","Allow JsonConverterAttribute to be applied to an Enum  Fixes https://github.com/dotnet/corefx/issues/39741

Add capability to specify custom converter for an Enum by using [JsonConverter] just like we support for properties, etc.

This does affect the",39812,steveharter,corefx
29684,SocketAddress with arbitrary AddressFamily throws PNSE on Unix,"This succeeds on Windows:
```C#
new SocketAddress((AddressFamily)12345).ToString()
```
returning:
```
""12345:32:{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}""
```
but on Linux and macOS it throws:
```
Unhandled Exception of Type System.PlatformNotSupportedException
Message :
System.PlatformNotSupportedException : Operation is not supported on this platform.
Stack Trace :
   at System.Net.SocketAddressPal.ThrowOnFailure(Error err) in /_/src/Common/src/System/Net/SocketAddressPal.Unix.cs:line 51
   at System.Net.SocketAddressPal.SetAddressFamily(Byte[] buffer, AddressFamily family) in /_/src/Common/src/System/Net/SocketAddressPal.Unix.cs:line 76
   at System.Net.SocketAddress..ctor(AddressFamily family, Int32 size) in /_/src/Common/src/System/Net/SocketAddress.cs:line 96
```","SocketAddress with arbitrary AddressFamily throws PNSE on Unix  This succeeds on Windows:
```C#
new SocketAddress((AddressFamily)12345).ToString()
```
returning:
```
""12345:32:{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}""
```
but",39785,wfurt,corefx
30099,System.Text.Json tests crashing outerloop on Unix,"e.g.
https://mc.dot.net/#/user/dotnet-bot/pr~2Fdotnet~2Fcorefx~2Frefs~2Fpull~2F38804~2Fmerge/test~2Ffunctional~2Fcli~2Finnerloop~2F/20190701.1/workItem/System.Text.Json.Tests/wilogs

cc: @ahsonkhan, @steveharter, @bartonjs","System.Text.Json tests crashing outerloop on Unix  e.g.
https://mc.dot.net/#/user/dotnet-bot/pr~2Fdotnet~2Fcorefx~2Frefs~2Fpull~2F38804~2Fmerge/test~2Ffunctional~2Fcli~2Finnerloop~2F/20190701.1/workItem/System.Text.Json.Tests/wilogs

cc: @ahsonkhan, @s",39784,steveharter,corefx
39751,Reduce memory usage of tests and fix checks for escaped size,"Fixes https://github.com/dotnet/corefx/issues/39081

On Linux, some writer tests were failing randomly by `SIGKILL`. I was able to repro these failures locally on Centos with 8.5GB of RAM max (including swap file).

The obvious fix is to just run these tests on Windows\OSX where OutOfMemoryException is gracefully thrown and the process is not killed (due to Linux out-of-memory-killer). However, when inspecting the tests some were allocating unnecessary large amounts of memory in order to cause an expected exception. So the first change was to:
- Change a couple tests to use appropriate max unescaped size + 1 (instead of 1GB+1 use 166.66MB + 1)

In addition, upon further testing I found asserts in the product code (not test code) were incorrectly comparing against unescaped (166.66MB) instead of max escaped (1GB) sizes for already-escaped values. So second change:
- Fix Debug.Asserts that compare Length against already-escaped values to use appropriate length of 1GB (see `JsonConstants.MaxEscapedTokenSize` in the code)
- Added test `WriteLargeKeyEscapedValue` to ensure the Debug.Assert changes are hit appropriately

With these changes, I no longer encountered the `SIGKILL` on my 8.5GB Centos machine. However, to guard against future issues with machines < 8.5GB:
- Tests that allocate large amounts of memory now only run on Windows and OSX.

cc @ericstj requesting approval to also add this to 3.0 branch once in master.","Reduce memory usage of tests and fix checks for escaped size  Fixes https://github.com/dotnet/corefx/issues/39081

On Linux, some writer tests were failing randomly by `SIGKILL`. I was able to repro these failures locally on Centos with 8.5GB of RAM max",39784,steveharter,corefx
30356,PostAsyncDuplex_RequestContentExceptionAfterResponseEndReceivedButBeforeConsumed_ResetsStreamAndThrowsOnResponseStreamRead failed in CI,"``` System.Net.Http.Functional.Tests.SocketsHttpHandlerTest_Http2/PostAsyncDuplex_RequestContentExceptionAfterResponseEndReceivedButBeforeConsumed_ResetsStreamAndThrowsOnResponseStreamRead

Windows.7.Amd64.Open-x86-Release
Get Repro environment
Unhandled Exception of Type Xunit.Sdk.ThrowsException
Message :
Assert.Throws() Failure
Expected: typeof(System.IO.IOException)
Actual:   (No exception was thrown)
Stack Trace :
   at System.Net.Http.Functional.Tests.HttpClientHandlerTest_Http2.PostAsyncDuplex_RequestContentExceptionAfterResponseEndReceivedButBeforeConsumed_ResetsStreamAndThrowsOnResponseStreamRead() in /_/src/System.Net.Http/tests/FunctionalTests/HttpClientHandlerTest.Http2.cs:line 2252
--- End of stack trace from previous location where exception was thrown ---
```",PostAsyncDuplex_RequestContentExceptionAfterResponseEndReceivedButBeforeConsumed_ResetsStreamAndThrowsOnResponseStreamRead failed in CI  ``` System.Net.Http.Functional.Tests.SocketsHttpHandlerTest_Http2/PostAsyncDuplex_RequestContentExceptionAfterResponse,39781,geoffkizer,corefx
39745,HTTP2: fix race between request failure and response body read,"Fixes #39729
","HTTP2: fix race between request failure and response body read  Fixes #39729
",39781,geoffkizer,corefx
39775,[release/3.0] HTTP2: Rework shutdown handling,"Fixes #39630
Fixes #39624
Incomplete attempt to fix #39586
Fixes #39461
Fixes #39460
Fixes #39458
Fixes #39459
Fixes #39404

Port of #39638 from master to release/3.0.

Rework shutdown handling to be reliable and consistent, for both streams and connections.

Each Http2Stream has to complete both request and response before shutting down, at which time it will remove itself from the stream dictionary and clean up associated state.

The request body and response body can each be cancelled, and these are now cancelled at appropriate times (e.g. Dispose on response stream before reading to end).

The behavior of early non-success status codes is changed to not cancel the request body. This matches HTTP/1.1 behavior.

The connection is now shut down only when all streams are removed from the dictionary. Receiving EndStream or RST_STREAM does not automatically remove the stream; instead we let the stream manage its own shutdown and then remove it from the dictionary.

Add relevant tests, fix up some existing tests, and remove one bogus test.

I haven't run stress tests on this yet -- I wanted to get the review out first. Will report when I have stress results.

<hr/>

@danmosemsft 

Note: #39745 will need to go into release/3.0 too. It's currently blocked on eng system issues. If these get resolved, I will add to this PR. Can you approve that fix too?","[release/3.0] HTTP2: Rework shutdown handling  Fixes #39630
Fixes #39624
Incomplete attempt to fix #39586
Fixes #39461
Fixes #39460
Fixes #39458
Fixes #39459
Fixes #39404

Port of #39638 from master to release/3.0.

Rework shutdown handling to",39781,geoffkizer,corefx
30315,HTTP2: Post method with ExpectAndContinue hangs after a first bunch of requests,"The Post ExpectContinue task is getting hanged when the cancellation rate is not zero. 

I was not able to get any helpful info from the trace or aspnetlog. After some time it just throws an exception and hangs again.  The exception thrown is 

```
[Exit] thisOrContextObject: HttpClient#62601592, memberName: SendAsync, result: System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[System.Net.Http.HttpResponseMessage,System.Net.Http.RedirectHandler+<SendAsync>d__4]
[HandlerMessage] poolId: 66166301, workerId: 56140151, requestId: 0, memberName: AbortStreams, message: abortException=System.IO.IOException: Unable to read data from the transport connection: An established connection was aborted by the software in your host machine..
 ---> System.Net.Sockets.SocketException (10053): An established connection was aborted by the software in your host machine.
   --- End of inner exception stack trace ---
   at System.Net.Security.SslStream.<WriteSingleChunk>g__CompleteAsync|210_1[TWriteAdapter](ValueTask writeTask, Byte[] bufferToReturn)
   at System.Net.Security.SslStream.WriteAsyncInternal[TWriteAdapter](TWriteAdapter writeAdapter, ReadOnlyMemory`1 buffer)
   at System.Net.Http.Http2Connection.FlushOutgoingBytesAsync()
[HandlerMessage] poolId: 66166301, workerId: 56140151, requestId: 97, memberName: OnAbort, message: abortException=System.IO.IOException: Unable to read data from the transport connection: An established connection was aborted by the software in your host machine..
 ---> System.Net.Sockets.SocketException (10053): An established connection was aborted by the software in your host machine.
   --- End of inner exception stack trace ---
   at System.Net.Security.SslStream.<WriteSingleChunk>g__CompleteAsync|210_1[TWriteAdapter](ValueTask writeTask, Byte[] bufferToReturn)
   at System.Net.Security.SslStream.WriteAsyncInternal[TWriteAdapter](TWriteAdapter writeAdapter, ReadOnlyMemory`1 buffer)
   at System.Net.Http.Http2Connection.FlushOutgoingBytesAsync()
[HandlerMessage] poolId: 66166301, workerId: 56140151, requestId: 99, memberName: OnAbort, message: abortException=System.IO.IOException: Unable to read data from the transport connection: An established connection was aborted by the software in your host machine..
 ---> System.Net.Sockets.SocketException (10053): An established connection was aborted by the software in your host machine.
   --- End of inner exception stack trace ---
   at System.Net.Security.SslStream.<WriteSingleChunk>g__CompleteAsync|210_1[TWriteAdapter](ValueTask writeTask, Byte[] bufferToReturn)
   at System.Net.Security.SslStream.WriteAsyncInternal[TWriteAdapter](TWriteAdapter writeAdapter, ReadOnlyMemory`1 buffer)
   at System.Net.Http.Http2Connection.FlushOutgoingBytesAsync()
[Enter] thisOrContextObject: HttpConnectionPoolManager#52747788, memberName: RemoveStalePools, parameters: 
[HandlerMessage] poolId: 66166301, workerId: 0, requestId: 0, memberName: CleanCacheAndDisposeIfUnused, message: Cleaning pool.
[Exit] thisOrContextObject: HttpConnectionPoolManager#52747788, memberName: RemoveStalePools, result: 
[Enter] thisOrContextObject: HttpConnectionPoolManager#52747788, memberName: RemoveStalePools, parameters: 
[HandlerMessage] poolId: 66166301, workerId: 0, requestId: 0, memberName: CleanCacheAndDisposeIfUnused, message: Cleaning pool.
[Exit] thisOrContextObject: HttpConnectionPoolManager#52747788, memberName: RemoveStalePools, result: 
```

When cancelation rate is zero it works perfectly fine.

cc @stephentoub @eiriktsarpalis","HTTP2: Post method with ExpectAndContinue hangs after a first bunch of requests  The Post ExpectContinue task is getting hanged when the cancellation rate is not zero. 

I was not able to get any helpful info from the trace or aspnetlog. After some time",39775,geoffkizer,corefx
30310,HTTP2: The Request stream either getting reset or closed during the post deplex operation,"Exceptions being thrown 

// Client error
```C#
System.Net.Http.HttpRequestException: Error while copying content to a stream.
 ---> System.IO.IOException: An error occurred while sending the request.
 ---> System.OperationCanceledException: The operation was canceled.
   --- End of inner exception stack trace ---
   at System.IO.Stream.CopyToAsyncInternal(Stream destination, Int32 bufferSize, CancellationToken cancellationToken)
   at System.Net.Http.HttpConnectionResponseContent.SerializeToStreamAsync(Stream stream, TransportContext context, CancellationToken cancellationToken)
   at System.Net.Http.HttpContent.LoadIntoBufferAsyncCore(Task serializeToStreamTask, MemoryStream tempBuffer)
   --- End of inner exception stack trace ---
   at System.Net.Http.HttpContent.LoadIntoBufferAsyncCore(Task serializeToStreamTask, MemoryStream tempBuffer)
   at System.Net.Http.HttpContent.WaitAndReturnAsync[TState,TResult](Task waitTask, TState state, Func`2 returnFunc)
   at Program.<>c__DisplayClass1_0.<<Run>b__9>d.MoveNext() in C:\git\corefx\src\System.Net.Http\tests\StressTests\HttpStress\Program.cs:line 267
--- End of stack trace from previous location where exception was thrown ---
   at Program.<>c__DisplayClass1_4.<<Run>b__40>d.MoveNext() in C:\git\corefx\src\System.Net.Http\tests\StressTests\HttpStress\Program.cs:line 607
```

// server error
```C#
fail: Microsoft.AspNetCore.Server.Kestrel[13]
      Connection id ""0HLOCE8NMUALO"", Request id ""0HLOCE8NMUALO:000001EB"": An unhandled exception was thrown by the application.
System.IO.IOException: The client reset the request stream.
   at Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpRequestStream.CopyToAsyncInternal(Stream destination, CancellationToken cancellationToken)
   at Program.<>c.<<Run>b__1_30>d.MoveNext() in C:\git\corefx\src\System.Net.Http\tests\StressTests\HttpStress\Program.cs:line 486
--- End of stack trace from previous location where exception was thrown ---
   at Microsoft.AspNetCore.Routing.EndpointMiddleware.<Invoke>g__AwaitRequestTask|6_0(Endpoint endpoint, Task requestTask, ILogger logger)
   at Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol.ProcessRequests[TContext](IHttpApplication`1 application)
fail: Microsoft.AspNetCore.Server.Kestrel[13]
      Connection id ""0HLOCE8NMUALO"", Request id ""0HLOCE8NMUALO:000001EF"": An unhandled exception was thrown by the application.
System.IO.IOException: The request stream was aborted.
 ---> Microsoft.AspNetCore.Connections.ConnectionAbortedException: The HTTP/2 connection faulted.
 ---> Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2ConnectionErrorException: HTTP/2 connection error (STREAM_CLOSED): The client sent a DATA frame to closed stream ID 491.
   at Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2Connection.ProcessDataFrameAsync(ReadOnlySequence`1& payload)
   at Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2Connection.ProcessRequestsAsync[TContext](IHttpApplication`1 application)
   --- End of inner exception stack trace ---
   --- End of inner exception stack trace ---
   at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()
   at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)
   at System.IO.Pipelines.Pipe.GetReadAsyncResult()
   at Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2MessageBody.ReadAsync(CancellationToken cancellationToken)
   at Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpRequestStream.CopyToAsyncInternal(Stream destination, CancellationToken cancellationToken)
   at Program.<>c.<<Run>b__1_30>d.MoveNext() in C:\git\corefx\src\System.Net.Http\tests\StressTests\HttpStress\Program.cs:line 486
--- End of stack trace from previous location where exception was thrown ---
   at Microsoft.AspNetCore.Routing.EndpointMiddleware.<Invoke>g__AwaitRequestTask|6_0(Endpoint endpoint, Task requestTask, ILogger logger)
   at Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol.ProcessRequests[TContext](IHttpApplication`1 application)
```


// Trace file output
``` C#
   at System.Net.Http.HttpClient.FinishSendAsyncUnbuffered(Task`1 sendTask, HttpRequestMessage request, CancellationTokenSource cts, Boolean disposeCts)
[HandlerMessage] poolId: 4831898, workerId: 23081642, requestId: 3775, memberName: SendRequestBodyAsync, message: Failed to send request body: System.Net.Http.HttpRequestException: Error while copying content to a stream.
 ---> System.IO.IOException: The request was aborted.
   at System.Net.Http.Http2Connection.AcquireWriteLockAsync(CancellationToken cancellationToken)
   at System.Net.Http.Http2Connection.StartWriteAsync(Int32 writeBytes, CancellationToken cancellationToken)
   at System.Net.Http.Http2Connection.SendStreamDataAsync(Int32 streamId, ReadOnlyMemory`1 buffer, CancellationToken cancellationToken)
   at System.Net.Http.Http2Connection.Http2Stream.SendDataAsync(ReadOnlyMemory`1 buffer, CancellationToken cancellationToken)
   at System.Net.Http.HttpContent.CopyToAsyncCore(ValueTask copyTask)
   --- End of inner exception stack trace ---
   at System.Net.Http.HttpContent.CopyToAsyncCore(ValueTask copyTask)
   at System.Net.Http.Http2Connection.Http2Stream.SendRequestBodyAsync(CancellationToken cancellationToken)
```

command ``` dotnet run -n 3 -maxContentLength 1000 -http 2.0 -ops 7 ```

I ran it on the master branch and it error doesn't repro with 1.1


cc @stephentoub @eiriktsarpalis","HTTP2: The Request stream either getting reset or closed during the post deplex operation  Exceptions being thrown 

// Client error
```C#
System.Net.Http.HttpRequestException: Error while copying content to a stream.
 ---> System.IO.IOException: An",39775,geoffkizer,corefx
30295,HTTP2: Hang when sending multiple requests from a HttpClient,"I'm not sure what the cause of this hang is, it appears to happen at HttpClient.SendAsync when the client has made at least one previous call.

Repro:
1. `git clone https://github.com/JamesNK/grpc-dotnet.git`
2. `git checkout jamesnk/hang-multiple-calls`
3. `dotnet test test\FunctionalTests --filter Name~DuplexStream_SendToUnimplementedMethodAfterResponseReceived_Hang`

Logic in the test is like:
1. Client makes HTTP/2 duplex call to the server
2. Server immediately returns 200 and ends request.
3. Client inspects headers.
4. Client completes request stream.
5. Go to 1.

It consistently hangs making the second or third call.

```
.NET Core SDK (reflecting any global.json):
 Version:   3.0.100-preview8-013248
 Commit:    135af55c46
```","HTTP2: Hang when sending multiple requests from a HttpClient  I'm not sure what the cause of this hang is, it appears to happen at HttpClient.SendAsync when the client has made at least one previous call.

Repro:
1. `git clone https://github.com/JamesN",39775,geoffkizer,corefx
30250,HTTP2: Dispose on response stream before stream is fully consumed does not remove stream from the stream dictionary,"If you dispose the response stream before consuming all the data, we do not remove the Http2Stream from the connection's stream dictionary. This means that the connection still thinks the Http2Stream is open, and the connection will never go away.","HTTP2: Dispose on response stream before stream is fully consumed does not remove stream from the stream dictionary  If you dispose the response stream before consuming all the data, we do not remove the Http2Stream from the connection's stream dictionary",39775,geoffkizer,corefx
30249,HTTP2 Duplex: Receiving non-success status code does not allow response body to be read,"When we receive a non-success status code (e.g. 403), we stop sending the request body. However, we also immediately send a RST_STREAM, which causes the server to stop sending the response body if it hasn't finished already. This means the client cannot reliably read the response body. (Note this works for HTTP/1.1, though we only do this when Expect: 100-continue is used; for HTTP2 we always do it.)

We should simply stop sending the request body and defer the RST_STREAM until the response body has been fully read.","HTTP2 Duplex: Receiving non-success status code does not allow response body to be read  When we receive a non-success status code (e.g. 403), we stop sending the request body. However, we also immediately send a RST_STREAM, which causes the server to sto",39775,geoffkizer,corefx
30247,HTTP2: Receiving RST_STREAM from server does not interrupt request body send,"If you do a POST and send request content, and the server sends a RST_STREAM, we continue to allow writes on the request body stream, and in fact we keep sending DATA frames to the server.

Instead, we should fail the next attempted write on the request stream and not send any more DATA frames to the server.

I'm working on a PR to add a test for this.","HTTP2: Receiving RST_STREAM from server does not interrupt request body send  If you do a POST and send request content, and the server sends a RST_STREAM, we continue to allow writes on the request body stream, and in fact we keep sending DATA frames to",39775,geoffkizer,corefx
30248,HTTP2: Exception during request body send does not send a RST_STREAM to the server,"If an exception occurs while sending the request body (i.e. HttpContent.SerializeToStreamAsync), we do not send a RST_STREAM to the server. We should.

I'm working on a PR to add a test for this.
","HTTP2: Exception during request body send does not send a RST_STREAM to the server  If an exception occurs while sending the request body (i.e. HttpContent.SerializeToStreamAsync), we do not send a RST_STREAM to the server. We should.

I'm working on a",39775,geoffkizer,corefx
30230,Bidirectional HTTP/2 streaming truncates the request body if the response ends,"RE: https://github.com/dotnet/corefx/issues/38559. There's also a functional issue where as soon as the client disposes the response stream no future request data frames are sent to the server. The server eventually times out and aborts the connection.

@stephentoub @geoffkizer 

This is happening with Microsoft.NETCore.App 3.0.0-preview8-27904-06.

Flow:
- Client sends headers, Expect 100-Continue
- Server sends 100-Continue
- Client sends first message ""Hello World""
- Server echos ""Hello World"" and completes the response (END_STREAM)
- Client consumes the response and disposes the response stream.
- Client sends final message ""Hello World"" and closes the request.
Bug: this message is never sent. Nor does the client send a RST or otherwise indicate it is done with the request. The server times out and aborts the whole connection.
Expected: the client would send the last message and END_STREAM. Alternatively it must at least send a RST.
Workaround: Do not Dispose the response stream after the last write returns 0.

See the 6 second gap in the logs after sending the response END_STREAM.
```
[0.003s] [TestLifetime] [Information] Starting test BidirectionalStreamingMoreClientData-http at 2019-07-11T18:47:34
[0.006s] [Microsoft.Extensions.Hosting.Internal.Host] [Debug] Hosting starting
[0.009s] [Microsoft.Hosting.Lifetime] [Information] Now listening on: http://127.0.0.1:21567
[0.009s] [Microsoft.AspNetCore.Hosting.Diagnostics] [Debug] Loaded hosting startup assembly Interop.FunctionalTests
[0.009s] [Microsoft.Hosting.Lifetime] [Information] Application started. Press Ctrl+C to shut down.
[0.010s] [Microsoft.Hosting.Lifetime] [Information] Hosting environment: Production
[0.010s] [Microsoft.Hosting.Lifetime] [Information] Content root path: D:\github\AspNetCore\artifacts\bin\Interop.FunctionalTests\Debug\netcoreapp3.0\
[0.011s] [Microsoft.Extensions.Hosting.Internal.Host] [Debug] Hosting started
[0.015s] [Microsoft.AspNetCore.Server.Kestrel] [Debug] Connection id ""0HLO660SITO23"" started.
[0.017s] [Microsoft.AspNetCore.Server.Kestrel] [Verbose] Connection id ""0HLO660SITO23"" sending SETTINGS frame for stream ID 0 with length 18 and flags NONE
[0.017s] [Microsoft.AspNetCore.Server.Kestrel] [Verbose] Connection id ""0HLO660SITO23"" sending WINDOW_UPDATE frame for stream ID 0 with length 4 and flags 0x0
[0.017s] [Microsoft.AspNetCore.Server.Kestrel] [Verbose] Connection id ""0HLO660SITO23"" received SETTINGS frame for stream ID 0 with length 12 and flags NONE
[0.017s] [Microsoft.AspNetCore.Server.Kestrel] [Verbose] Connection id ""0HLO660SITO23"" sending SETTINGS frame for stream ID 0 with length 0 and flags ACK
[0.018s] [Microsoft.AspNetCore.Server.Kestrel] [Verbose] Connection id ""0HLO660SITO23"" received WINDOW_UPDATE frame for stream ID 0 with length 4 and flags 0x0
[0.018s] [Microsoft.AspNetCore.Server.Kestrel] [Verbose] Connection id ""0HLO660SITO23"" received HEADERS frame for stream ID 1 with length 35 and flags END_HEADERS
[0.018s] [Microsoft.AspNetCore.Server.Kestrel] [Verbose] Connection id ""0HLO660SITO23"" received SETTINGS frame for stream ID 0 with length 0 and flags ACK
[0.020s] [Microsoft.AspNetCore.Hosting.Diagnostics] [Information] Request starting HTTP/2 POST http://127.0.0.1:21567/  
[0.020s] [Microsoft.AspNetCore.Server.Kestrel] [Debug] Connection id ""0HLO660SITO23"", Request id ""0HLO660SITO23:00000001"": started reading request body.
[0.021s] [Microsoft.AspNetCore.Server.Kestrel] [Verbose] Connection id ""0HLO660SITO23"" sending HEADERS frame for stream ID 1 with length 5 and flags END_HEADERS
[0.023s] [Microsoft.AspNetCore.Server.Kestrel] [Verbose] Connection id ""0HLO660SITO23"" received DATA frame for stream ID 1 with length 11 and flags NONE
[0.023s] [Microsoft.AspNetCore.Server.Kestrel] [Verbose] Connection id ""0HLO660SITO23"" sending HEADERS frame for stream ID 1 with length 53 and flags END_HEADERS
[0.024s] [Microsoft.AspNetCore.Server.Kestrel] [Verbose] Connection id ""0HLO660SITO23"" sending DATA frame for stream ID 1 with length 11 and flags NONE
[0.024s] [Microsoft.AspNetCore.Server.Kestrel] [Verbose] Connection id ""0HLO660SITO23"" sending DATA frame for stream ID 1 with length 0 and flags END_STREAM
[6.017s] [Microsoft.AspNetCore.Server.Kestrel] [Information] Connection id ""0HLO660SITO23"", Request id ""null"": the request timed out because it was not sent by the client at a minimum of 240 bytes/second.
[6.019s] [Microsoft.AspNetCore.Server.Kestrel] [Debug] Connection id ""0HLO660SITO23"" is closed. The last processed stream ID was 1.
[6.020s] [Microsoft.AspNetCore.Server.Kestrel] [Verbose] Connection id ""0HLO660SITO23"" sending GOAWAY frame for stream ID 0 with length 8 and flags 0x0
[6.022s] [Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets] [Debug] Connection id ""0HLO660SITO23"" sending FIN because: ""Reading the request body timed out due to data arriving too slowly. See MinRequestBodyDataRate.""
[6.025s] [Microsoft.AspNetCore.Hosting.Diagnostics] [Information] Request finished in 6005.1414ms 200 
[6.026s] [Microsoft.AspNetCore.Server.Kestrel] [Debug] Connection id ""0HLO660SITO23"", Request id ""0HLO660SITO23:00000001"": done reading request body.
[6.026s] [Microsoft.AspNetCore.Server.Kestrel] [Information] Connection id ""0HLO660SITO23"", Request id ""0HLO660SITO23:00000001"": the application completed without reading the entire request body.
[6.026s] [Microsoft.AspNetCore.Server.Kestrel] [Debug] Some connections failed to close gracefully during server shutdown.
[6.027s] [Microsoft.AspNetCore.Server.Kestrel] [Debug] Connection id ""0HLO660SITO23"" stopped.
[6.032s] [TestLifetime] [Information] Finished test BidirectionalStreamingMoreClientData-http in 6.028651399999999s
```

<details><summary>Test code:</summary>

```
        public async Task BidirectionalStreamingMoreClientData(string scheme)
        {
            var lastPacket = new TaskCompletionSource<string>(TaskCreationOptions.RunContinuationsAsynchronously);
            var hostBuilder = new HostBuilder()
                .ConfigureWebHost(webHostBuilder =>
                {
                    ConfigureKestrel(webHostBuilder, scheme);
                    webHostBuilder.ConfigureServices(AddTestLogging)
                    .Configure(app => app.Run(async context =>
                    {
                        var reader = context.Request.BodyReader;

                        var readResult = await reader.ReadAsync();
                        while (!readResult.IsCompleted && readResult.Buffer.Length < ""Hello World"".Length)
                        {
                            reader.AdvanceTo(readResult.Buffer.Start, readResult.Buffer.End);
                            readResult = await reader.ReadAsync();
                        }

                        var sequence = readResult.Buffer.Slice(0, ""Hello World"".Length);
                        Assert.True(sequence.IsSingleSegment);
                        await context.Response.BodyWriter.WriteAsync(sequence.First);
                        reader.AdvanceTo(sequence.End);
                        await context.Features.Get<IHttpResponseCompletionFeature>().CompleteAsync();

                        try
                        {
                            // The client sends one more packet after the server completes
                            readResult = await reader.ReadAsync();
                            while (!readResult.IsCompleted && readResult.Buffer.Length < ""Hello World"".Length)
                            {
                                reader.AdvanceTo(readResult.Buffer.Start, readResult.Buffer.End);
                                readResult = await reader.ReadAsync();
                            }

                            Assert.True(readResult.Buffer.IsSingleSegment);
                            var result = Encoding.UTF8.GetString(readResult.Buffer.FirstSpan);
                            reader.AdvanceTo(readResult.Buffer.End);

                            var finalResult = await reader.ReadAsync();
                            Assert.True(finalResult.IsCompleted && finalResult.Buffer.Length == 0);
                            lastPacket.SetResult(result);
                        }
                        catch (Exception ex)
                        {
                            lastPacket.SetException(ex);
                        }
                    }));
                });
            using var host = await hostBuilder.StartAsync();

            var url = $""{scheme}://127.0.0.1:{host.GetPort().ToString(CultureInfo.InvariantCulture)}/"";

            using var client = CreateClient();
            client.DefaultRequestHeaders.ExpectContinue = true;

            var streamingContent = new StreamingContent();
            var request = new HttpRequestMessage(HttpMethod.Post, url)
            {
                Version = HttpVersion.Version20,
                Content = streamingContent,
            };
            var responseTask = client.SendAsync(request, HttpCompletionOption.ResponseHeadersRead).DefaultTimeout();
            // The server doesn't respond until we send the first set of data
            await streamingContent.SendAsync(""Hello World"").DefaultTimeout();
            var response = await responseTask;

            Assert.Equal(HttpVersion.Version20, response.Version);
            var stream = await response.Content.ReadAsStreamAsync();
            var responseBuffer = new byte[""Hello World"".Length];

            var read = await stream.ReadAsync(responseBuffer, 0, responseBuffer.Length).DefaultTimeout();
            Assert.Equal(responseBuffer.Length, read);
            Assert.Equal(""Hello World"", Encoding.UTF8.GetString(responseBuffer));

            read = await stream.ReadAsync(responseBuffer, 0, responseBuffer.Length).DefaultTimeout();
            Assert.Equal(0, read);
            stream.Dispose();

            // Send one more message after the server has finished.
            await streamingContent.SendAsync(""Hello World"").DefaultTimeout();
            streamingContent.Complete();

            var lastData = await lastPacket.Task.DefaultTimeout();
            Assert.Equal(""Hello World"", lastData);

            await host.StopAsync();
        }

        private class StreamingContent : HttpContent
        {
            private TaskCompletionSource<int> _sendStarted = new TaskCompletionSource<int>(TaskCreationOptions.RunContinuationsAsynchronously);
            private Func<string, Task> _sendContent;
            private TaskCompletionSource<int> _sendComplete;

            public StreamingContent()
            {
            }

            public async Task SendAsync(string text)
            {
                await _sendStarted.Task;
                await _sendContent(text);
            }

            public void Complete()
            {
                if (_sendComplete == null)
                {
                    throw new InvalidOperationException(""Sending hasn't started yet."");
                }
                _sendComplete.TrySetResult(0);
            }

            protected override Task SerializeToStreamAsync(Stream stream, TransportContext context)
            {
                _sendComplete = new TaskCompletionSource<int>(TaskCreationOptions.RunContinuationsAsynchronously);
                _sendContent = async text =>
                {
                    try
                    {
                        var bytes = Encoding.UTF8.GetBytes(text);
                        await stream.WriteAsync(bytes);
                    }
                    catch (Exception ex)
                    {
                        _sendComplete.TrySetException(ex);
                    }
                };
                _sendStarted.SetResult(0);
                return _sendComplete.Task;
            }

            protected override bool TryComputeLength(out long length)
            {
                length = 0;
                return false;
            }
        }

        private static HttpClient CreateClient()
        {
            var handler = new HttpClientHandler();
            handler.ServerCertificateCustomValidationCallback = HttpClientHandler.DangerousAcceptAnyServerCertificateValidator;
            var client = new HttpClient(handler);
            client.DefaultRequestVersion = HttpVersion.Version20;
            return client;
        }

        private static void ConfigureKestrel(IWebHostBuilder webHostBuilder, string scheme)
        {
            webHostBuilder.UseKestrel(options =>
            {
                options.Listen(IPAddress.Loopback, 0, listenOptions =>
                {
                    listenOptions.Protocols = HttpProtocols.Http2;
                    if (scheme == ""https"")
                    {
                        listenOptions.UseHttps(TestResources.GetTestCertificate());
                    }
                });
            });
        }
```
</details>",Bidirectional HTTP/2 streaming truncates the request body if the response ends  RE: https://github.com/dotnet/corefx/issues/38559. There's also a functional issue where as soon as the client disposes the response stream no future request data frames are s,39775,geoffkizer,corefx
39638,HTTP2: Rework shutdown handling,"Fixes #39630
Fixes #39624
Incomplete attempt to fix #39586
Fixes #39461
Fixes #39460
Fixes #39458
Fixes #39459
Fixes #39404

Rework shutdown handling to be reliable and consistent, for both streams and connections.

Each Http2Stream has to complete both request and response before shutting down, at which time it will remove itself from the stream dictionary and clean up associated state.

The request body and response body can each be cancelled, and these are now cancelled at appropriate times (e.g. Dispose on response stream before reading to end).

The behavior of early non-success status codes is changed to not cancel the request body. This matches HTTP/1.1 behavior.

The connection is now shut down only when all streams are removed from the dictionary. Receiving EndStream or RST_STREAM does not automatically remove the stream; instead we let the stream manage its own shutdown and then remove it from the dictionary.

Add relevant tests, fix up some existing tests, and remove one bogus test.

I haven't run stress tests on this yet -- I wanted to get the review out first. Will report when I have stress results.

cc @stephentoub @dotnet/ncl","HTTP2: Rework shutdown handling  Fixes #39630
Fixes #39624
Incomplete attempt to fix #39586
Fixes #39461
Fixes #39460
Fixes #39458
Fixes #39459
Fixes #39404

Rework shutdown handling to be reliable and consistent, for both streams and connections",39775,geoffkizer,corefx
39745,HTTP2: fix race between request failure and response body read,"Fixes #39729
","HTTP2: fix race between request failure and response body read  Fixes #39729
",39775,geoffkizer,corefx
38430,Checking if the eventlog registry key is actually an eventlog,".Net considers that the subkeys under the event log registry key is a ""eventlog"" which is not the case anymore. So we are just filtering out the eventlog entries if we cnt open it.


@tarekgh i verified that the release handle is being called by close handle.","Checking if the eventlog registry key is actually an eventlog  .Net considers that the subkeys under the event log registry key is a ""eventlog"" which is not the case anymore. So we are just filtering out the eventlog entries if we cnt open it.


@tare",39752,Anipik,corefx
39705,Only removing logs which throw invalid parameters exception from eventLogs,"The handle returned on the https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs#L663 is invalid if the user doesnot have access to this log eg non admin trying to access security log.
The code added in this https://github.com/dotnet/corefx/pull/38430 ended up removing such logs as well.
This Pr fixes that problem",Only removing logs which throw invalid parameters exception from eventLogs  The handle returned on the https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs#L663 is invalid if the user doesnot have,39752,Anipik,corefx
30220,"Test failure: Microsoft.VisualBasic.Tests.FinancialTests/DDB(Cost: 10000, Salvage: 4350, Life: 84, Period: 35, Factor: 2, expectedOld: 57.3268063538875, expected)","Test `Microsoft.VisualBasic.Tests.FinancialTests/DDB(Cost: 10000, Salvage: 4350, Life: 84, Period: 35, Factor: 2, expectedOld: 57.3268063538875, expected)` has failed.

Message :
```
Assert.Equal() Failure
Expected: 57.32680635388748
Actual:   57.32680635388746
```
Stack Trace :
```
   at Microsoft.VisualBasic.Tests.FinancialTests.AreEqual[T](T expectedOld, T expectedNew, T actual) in /_/src/Microsoft.VisualBasic.Core/tests/FinancialTests.cs:line 20
   at Microsoft.VisualBasic.Tests.FinancialTests.DDB(Double Cost, Double Salvage, Double Life, Double Period, Double Factor, Double expectedOld, Double expectedNew) in /_/src/Microsoft.VisualBasic.Core/tests/FinancialTests.cs:line 38
```
Build: -[20190710.51](https://mc.dot.net/#/user/dotnet-bot/pr~2Fdotnet~2Fcorefx~2Frefs~2Fheads~2Fmaster/test~2Ffunctional~2Fcli~2F~2F/20190710.51)(master)

Failing configuration:

- Windows.10.Arm64.Open-arm64-Release

Details:
https://mc.dot.net/#/user/dotnet-bot/pr~2Fdotnet~2Fcorefx~2Frefs~2Fheads~2Fmaster/test~2Ffunctional~2Fcli~2F~2F/20190710.51/workItem/Microsoft.VisualBasic.Core.Tests/analysis/xunit/Microsoft.VisualBasic.Tests.FinancialTests~2FDDB(Cost:%2010000,%20Salvage:%204350,%20Life:%2084,%20Period:%2035,%20Factor:%202,%20expectedOld:%2057.3268063538875,%20expected)","Test failure: Microsoft.VisualBasic.Tests.FinancialTests/DDB(Cost: 10000, Salvage: 4350, Life: 84, Period: 35, Factor: 2, expectedOld: 57.3268063538875, expected)  Test `Microsoft.VisualBasic.Tests.FinancialTests/DDB(Cost: 10000, Salvage: 4350, Life: 84,",39742,cston,corefx
30226,Allow for some variance in Microsoft.VisualBasic.Tests.FinancialTests,See https://github.com/dotnet/corefx/pull/39391/files#r302621690,Allow for some variance in Microsoft.VisualBasic.Tests.FinancialTests  See https://github.com/dotnet/corefx/pull/39391/files#r302621690,39742,cston,corefx
28681,Fix race condition in DiagnosticsSourceEventSource implicit transform code,"From https://github.com/dotnet/corefx/pull/35269#issuecomment-463322814:

> Also looking at the implicit transform code it has a simmilar race to the one you fixed (it has a _expectedArgType, which indicates whether the '_implicitTransforms' should be reused or pitched). It is just that it does not cause a exception (the underlying fetching gives up silently on falure).
It would be good to fix that race in the same way (basically an optional Type field on TransformSpec).","Fix race condition in DiagnosticsSourceEventSource implicit transform code  From https://github.com/dotnet/corefx/pull/35269#issuecomment-463322814:

> Also looking at the implicit transform code it has a simmilar race to the one you fixed (it has a _ex",35764,vancem,corefx
28682,Change DiagnosticsSourceEventSource caching to be per event type,"From https://github.com/dotnet/corefx/pull/35269#issuecomment-463322814

> Later in the design, the issue of discovery was addressed. The idea was that you wanted implicit transformation (try to serialize anything that can be serialized, and tostring the rest). This allows you to discover what information is available (without having to look at the source code). However this logic did not 'remember' these transformations on a per-event-name basis, which means the remembered transformations never get reused, which is definately bad from a perf perspective.

> To fix the caching we need to replace the _implicitTransforms with a dictionary keyed by diagnosticSource/event name.","Change DiagnosticsSourceEventSource caching to be per event type  From https://github.com/dotnet/corefx/pull/35269#issuecomment-463322814

> Later in the design, the issue of discovery was addressed. The idea was that you wanted implicit transformation",35764,vancem,corefx
27862,Add GetCommentValue to Utf8JsonReader,"We have a GetStringValue today and although comments are strings, the GetCommentValue would have different semantics. For instance, it would not do any unescaping (and you would get the comment delimiters here where you don't for strings, i.e. quotes). Keeping comment reading as part of GetStringValue makes documenting the semantics of the API difficult.

Context: https://github.com/dotnet/corefx/commit/3d24832abe217779fd9886e1a01ab4ee06f1488e#r31224311

Hence, add a separate API:
```C#
public ref partial struct Utf8JsonReader
{
    public string GetCommentValue();
}
```

cc @bartonjs, @stephentoub","Add GetCommentValue to Utf8JsonReader  We have a GetStringValue today and although comments are strings, the GetCommentValue would have different semantics. For instance, it would not do any unescaping (and you would get the comment delimiters here where",35705,WinCPP,corefx
33393,"Utf8JsonReader.cs - Add support for single line comments ending on \r, \r\n","Add support in `Utf8JsonReader` in `System.Text.Json` to parse single line comments ending in `\r`, `\r\n`

Fixes: https://github.com/dotnet/corefx/issues/33293

cc: @ahsonkhan, @steveharter","Utf8JsonReader.cs - Add support for single line comments ending on \r, \r\n  Add support in `Utf8JsonReader` in `System.Text.Json` to parse single line comments ending in `\r`, `\r\n`

Fixes: https://github.com/dotnet/corefx/issues/33293

cc: @ahsonkh",35705,WinCPP,corefx
35641,Fix the SslStream order of intermediate certificates with long chains,"Addresses #35640 in master.

Testing was done manually, because there's not an obvious/easy way of inspecting the wire cert order with the test infrastructure we have.","Fix the SslStream order of intermediate certificates with long chains  Addresses #35640 in master.

Testing was done manually, because there's not an obvious/easy way of inspecting the wire cert order with the test infrastructure we have.",35699,bartonjs,corefx
28813,Linux SslStream sends intermediate certificates in wrong order,"When a certificate chain has 4 or more elements (end-entity -> low issuer -> ... -> high issuer -> root) the intermediate certificates are written in the wrong order on the wire.

* Create a certificate whose chain has 4 or more elements
* Trust the root
* Use the end-entity certificate in a server-role SslStream
* Connect to the endpoint using `openssl s_client` (e.g. `openssl s_client -connect localhost:8000`)
* Observe the certificate ordering

Expected:

```
---
Certificate chain
 0 s:/CN=End-Entity
   i:/CN=Low Issuer
 1 s:/CN=Low Issuer
   i:/CN=High Issuer
 2 s:/CN=High Issuer
   i:/CN=Trusted Root
---
```

Actual:

```
---
Certificate chain
 0 s:/CN=End-Entity
   i:/CN=Low Issuer
 1 s:/CN=High Issuer
   i:/CN=Trusted Root
 2 s:/CN=Low Issuer
   i:/CN=High Issuer
---
```

This puts our ""long chain"" implementation out of compliance with https://tools.ietf.org/html/rfc5246#section-7.4.2

``` 
   certificate_list
      This is a sequence (chain) of certificates.  The sender's
      certificate MUST come first in the list.  Each following
      certificate MUST directly certify the one preceding it.  [...]
```","Linux SslStream sends intermediate certificates in wrong order  When a certificate chain has 4 or more elements (end-entity -> low issuer -> ... -> high issuer -> root) the intermediate certificates are written in the wrong order on the wire.

* Create",35699,bartonjs,corefx
24591,Tests failed: System.Net.Http.Functional.Tests.ManagedHandler_HttpClientHandler_SslProtocols_Test / GetAsync_*SSLVersion_Succeeds,"Regression caused by dotnet/corefx#26135 (@geoffkizer)

## Types of failures

Affected tests:
* GetAsync_AllowedSSLVersion_Succeeds
* GetAsync_SupportedSSLVersion_Succeeds

### GetAsync_AllowedSSLVersion_Succeeds - The client and server cannot communicate, because they do not possess a common algorithm

Build [20180105.02](https://mc.dot.net/#/product/netcore/master/source/official~2Fcorefx~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180105.02/workItem/System.Net.Http.Functional.Tests/analysis/xunit/System.Net.Http.Functional.Tests.ManagedHandler_HttpClientHandler_SslProtocols_Test~2FGetAsync_AllowedSSLVersion_Succeeds(acceptedProtocol:%20Tls11,%20requestOnlyThisProtocol:%20False)):
```
System.Security.Authentication.AuthenticationException : A call to SSPI failed, see inner exception.
---- System.ComponentModel.Win32Exception : The client and server cannot communicate, because they do not possess a common algorithm
at System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, ExceptionDispatchInfo exception) in E:\A\_work\640\s\corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs:line 975
at System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest) in E:\A\_work\640\s\corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs:line 802
at System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest) in E:\A\_work\640\s\corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs:line 792
at System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest) in E:\A\_work\640\s\corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs:line 961
at System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest) in E:\A\_work\640\s\corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs:line 916
at System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest) in E:\A\_work\640\s\corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs:line 864
at System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest) in E:\A\_work\640\s\corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs:line 673
at System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult) in E:\A\_work\640\s\corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs:line 594
at System.Net.Security.SslStream.BeginAuthenticateAsServer(SslServerAuthenticationOptions sslServerAuthenticationOptions, CancellationToken cancellationToken, AsyncCallback asyncCallback, Object asyncState) in E:\A\_work\640\s\corefx\src\System.Net.Security\src\System\Net\Security\SslStream.cs:line 242
at System.Net.Security.SslStream.BeginAuthenticateAsServer(X509Certificate serverCertificate, Boolean clientCertificateRequired, SslProtocols enabledSslProtocols, Boolean checkCertificateRevocation, AsyncCallback asyncCallback, Object asyncState) in E:\A\_work\640\s\corefx\src\System.Net.Security\src\System\Net\Security\SslStream.cs:line 219
at System.Net.Security.SslStream.<>c.<AuthenticateAsServerAsync>b__47_1(X509Certificate arg1, Boolean arg2, SslProtocols arg3, AsyncCallback callback, Object state) in E:\A\_work\640\s\corefx\src\System.Net.Security\src\System\Net\Security\SslStream.cs:line 404
at System.Threading.Tasks.TaskFactory`1.FromAsyncImpl[TArg1,TArg2,TArg3](Func`6 beginMethod, Func`2 endFunction, Action`1 endAction, TArg1 arg1, TArg2 arg2, TArg3 arg3, Object state, TaskCreationOptions creationOptions) in E:\A\_work\1734\s\src\mscorlib\src\System\Threading\Tasks\FutureFactory.cs:line 1218
at System.Net.Security.SslStream.AuthenticateAsServerAsync(X509Certificate serverCertificate, Boolean clientCertificateRequired, SslProtocols enabledSslProtocols, Boolean checkCertificateRevocation) in E:\A\_work\640\s\corefx\src\System.Net.Security\src\System\Net\Security\SslStream.cs:line 405
at System.Net.Test.Common.LoopbackServer.<AcceptSocketAsync>d__11.MoveNext() in E:\A\_work\640\s\corefx\src\Common\tests\System\Net\Http\LoopbackServer.cs:line 164
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Http.Functional.Tests.HttpClientHandler_SslProtocols_Test.<>c__DisplayClass4_1.<<GetAsync_AllowedSSLVersion_Succeeds>b__0>d.MoveNext() in E:\A\_work\640\s\corefx\src\System.Net.Http\tests\FunctionalTests\HttpClientHandlerTest.SslProtocols.cs:line 115
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Test.Common.LoopbackServer.<>c__DisplayClass3_0.<CreateServerAsync>b__0(Task t) in E:\A\_work\640\s\corefx\src\Common\tests\System\Net\Http\LoopbackServer.cs:line 67
at System.Threading.Tasks.ContinuationTaskFromTask.InnerInvoke() in E:\A\_work\1734\s\src\mscorlib\src\System\Threading\Tasks\TaskContinuation.cs:line 59
at System.Threading.Tasks.Task.<>c.<.cctor>b__278_1(Object obj) in E:\A\_work\1734\s\src\mscorlib\src\System\Threading\Tasks\Task.cs:line 2480
at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state) in E:\A\_work\1734\s\src\mscorlib\shared\System\Threading\ExecutionContext.cs:line 151
at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task& currentTaskSlot) in E:\A\_work\1734\s\src\mscorlib\src\System\Threading\Tasks\Task.cs:line 2440
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Http.Functional.Tests.HttpClientHandler_SslProtocols_Test.<GetAsync_AllowedSSLVersion_Succeeds>d__4.MoveNext() in E:\A\_work\640\s\corefx\src\System.Net.Http\tests\FunctionalTests\HttpClientHandlerTest.SslProtocols.cs:line 113
--- End of stack trace from previous location where exception was thrown ---
--- End of stack trace from previous location where exception was thrown ---
--- End of stack trace from previous location where exception was thrown ---
----- Inner Stack Trace -----
```

### GetAsync_SupportedSSLVersion_Succeeds - The function requested is not supported

Build [20180105.02](https://mc.dot.net/#/product/netcore/master/source/official~2Fcorefx~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180105.02/workItem/System.Net.Http.Functional.Tests/analysis/xunit/System.Net.Http.Functional.Tests.ManagedHandler_HttpClientHandler_SslProtocols_Test~2FGetAsync_SupportedSSLVersion_Succeeds(sslProtocols:%20Tls11,%20url:%20%5C%22https:~2F~2Fwww.ssllabs.com:10302~2F%5C%22))
```
System.Net.Http.HttpRequestException : The SSL connection could not be established, see inner exception.
---- System.Security.Authentication.AuthenticationException : A call to SSPI failed, see inner exception.
-------- System.ComponentModel.Win32Exception : The function requested is not supported
at System.Net.Http.HttpConnectionHandler.<EstablishSslConnection>d__5.MoveNext() in E:\A\_work\640\s\corefx\src\System.Net.Http\src\System\Net\Http\Managed\HttpConnectionHandler.cs:line 82
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Http.HttpConnectionHandler.<CreateConnection>d__6.MoveNext() in E:\A\_work\640\s\corefx\src\System.Net.Http\src\System\Net\Http\Managed\HttpConnectionHandler.cs:line 136
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Http.HttpConnectionPool.<WaitForCreatedConnectionAsync>d__15.MoveNext() in E:\A\_work\640\s\corefx\src\System.Net.Http\src\System\Net\Http\Managed\HttpConnectionPool.cs:line 226
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Http.HttpConnectionHandler.<SendAsyncWithAwaitedConnection>d__4.MoveNext() in E:\A\_work\640\s\corefx\src\System.Net.Http\src\System\Net\Http\Managed\HttpConnectionHandler.cs:line 42
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Http.CookieHandler.<SendAsync>d__3.MoveNext() in E:\A\_work\640\s\corefx\src\System.Net.Http\src\System\Net\Http\Managed\CookieHandler.cs:line 31
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Http.AuthenticateAndRedirectHandler.<SendAsync>d__7.MoveNext() in E:\A\_work\640\s\corefx\src\System.Net.Http\src\System\Net\Http\Managed\AuthenticateAndRedirectHandler.cs:line 62
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Http.HttpClient.<FinishSendAsyncBuffered>d__62.MoveNext() in E:\A\_work\640\s\corefx\src\System.Net.Http\src\System\Net\Http\HttpClient.cs:line 488
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Test.Common.RemoteServerQuery.<Run>d__0`1.MoveNext() in E:\A\_work\640\s\corefx\src\Common\tests\System\Net\RemoteServerQuery.cs:line 44
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Http.Functional.Tests.HttpClientHandler_SslProtocols_Test.<GetAsync_SupportedSSLVersion_Succeeds>d__6.MoveNext() in E:\A\_work\640\s\corefx\src\System.Net.Http\tests\FunctionalTests\HttpClientHandlerTest.SslProtocols.cs:line 148
--- End of stack trace from previous location where exception was thrown ---
--- End of stack trace from previous location where exception was thrown ---
--- End of stack trace from previous location where exception was thrown ---
----- Inner Stack Trace -----
at System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, ExceptionDispatchInfo exception) in E:\A\_work\640\s\corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs:line 975
at System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest) in E:\A\_work\640\s\corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs:line 802
at System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest) in E:\A\_work\640\s\corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs:line 792
at System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest) in E:\A\_work\640\s\corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs:line 961
at System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest) in E:\A\_work\640\s\corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs:line 916
at System.Net.Security.SslState.PartialFrameCallback(AsyncProtocolRequest asyncRequest) in E:\A\_work\640\s\corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs:line 1096
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Security.SslState.InternalEndProcessAuthentication(LazyAsyncResult lazyResult) in E:\A\_work\640\s\corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs:line 735
at System.Net.Security.SslState.EndProcessAuthentication(IAsyncResult result) in E:\A\_work\640\s\corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs:line 708
at System.Net.Security.SslStream.EndAuthenticateAsClient(IAsyncResult asyncResult) in E:\A\_work\640\s\corefx\src\System.Net.Security\src\System\Net\Security\SslStream.cs:line 194
at System.Net.Security.SslStream.<>c.<AuthenticateAsClientAsync>b__44_1(IAsyncResult iar) in E:\A\_work\640\s\corefx\src\System.Net.Security\src\System\Net\Security\SslStream.cs:line 381
at System.Threading.Tasks.TaskFactory`1.FromAsyncCoreLogic(IAsyncResult iar, Func`2 endFunction, Action`1 endAction, Task`1 promise, Boolean requiresSynchronization) in E:\A\_work\1734\s\src\mscorlib\src\System\Threading\Tasks\FutureFactory.cs:line 533
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Http.HttpConnectionHandler.<EstablishSslConnection>d__5.MoveNext() in E:\A\_work\640\s\corefx\src\System.Net.Http\src\System\Net\Http\Managed\HttpConnectionHandler.cs:line 68
----- Inner Stack Trace -----
```

### GetAsync_AllowedSSLVersion_Succeeds

```
System.Net.Http.HttpRequestException : An error occurred while sending the request.
---- System.IO.IOException : The decryption operation failed, see inner exception.
-------- Interop+OpenSsl+SslException : Decrypt failed with OpenSSL error - SSL_ERROR_SSL.
------------ System.Security.Cryptography.CryptographicException : Error occurred during a cryptographic operation.
at System.Net.Http.HttpConnection.<SendAsync>d__38.MoveNext() in /root/corefx-1266141/src/System.Net.Http/src/System/Net/Http/Managed/HttpConnection.cs:line 438
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Http.HttpConnectionHandler.<SendAsyncWithAwaitedConnection>d__4.MoveNext() in /root/corefx-1266141/src/System.Net.Http/src/System/Net/Http/Managed/HttpConnectionHandler.cs:line 43
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Http.CookieHandler.<SendAsync>d__3.MoveNext() in /root/corefx-1266141/src/System.Net.Http/src/System/Net/Http/Managed/CookieHandler.cs:line 31
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Http.AuthenticateAndRedirectHandler.<SendAsync>d__7.MoveNext() in /root/corefx-1266141/src/System.Net.Http/src/System/Net/Http/Managed/AuthenticateAndRedirectHandler.cs:line 62
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Http.HttpClient.<FinishSendAsyncBuffered>d__62.MoveNext() in /root/corefx-1266141/src/System.Net.Http/src/System/Net/Http/HttpClient.cs:line 488
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Http.Functional.Tests.HttpClientHandler_SslProtocols_Test.<>c__DisplayClass4_1.<<GetAsync_AllowedSSLVersion_Succeeds>b__0>d.MoveNext() in /root/corefx-1266141/src/System.Net.Http/tests/FunctionalTests/HttpClientHandlerTest.SslProtocols.cs:line 115
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Test.Common.LoopbackServer.<>c__DisplayClass3_0.<CreateServerAsync>b__0(Task t) in /root/corefx-1266141/src/Common/tests/System/Net/Http/LoopbackServer.cs:line 68
at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state) in /root/coreclr/src/mscorlib/shared/System/Threading/ExecutionContext.cs:line 151
at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task& currentTaskSlot) in /root/coreclr/src/mscorlib/src/System/Threading/Tasks/Task.cs:line 2440
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Http.Functional.Tests.HttpClientHandler_SslProtocols_Test.<GetAsync_AllowedSSLVersion_Succeeds>d__4.MoveNext() in /root/corefx-1266141/src/System.Net.Http/tests/FunctionalTests/HttpClientHandlerTest.SslProtocols.cs:line 113
--- End of stack trace from previous location where exception was thrown ---
--- End of stack trace from previous location where exception was thrown ---
--- End of stack trace from previous location where exception was thrown ---
----- Inner Stack Trace -----
at System.Net.Security.SslStreamInternal.<ReadAsyncInternal>d__32`1.MoveNext() in /root/corefx-1266141/src/System.Net.Security/src/System/Net/Security/SslStreamInternal.cs:line 285
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Http.HttpConnection.<FillAsync>d__64.MoveNext() in /root/corefx-1266141/src/System.Net.Http/src/System/Net/Http/Managed/HttpConnection.cs:line 958
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Http.HttpConnection.<ReadNextLineAsync>d__62.MoveNext() in /root/corefx-1266141/src/System.Net.Http/src/System/Net/Http/Managed/HttpConnection.cs:line 867
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Http.HttpConnection.<SendAsync>d__38.MoveNext() in /root/corefx-1266141/src/System.Net.Http/src/System/Net/Http/Managed/HttpConnection.cs:line 313
----- Inner Stack Trace -----
at Interop.OpenSsl.Decrypt(SafeSslHandle context, Byte[] outBuffer, Int32 offset, Int32 count, SslErrorCode& errorCode) in /root/corefx-1266141/src/Common/src/Interop/Unix/System.Security.Cryptography.Native/Interop.OpenSsl.cs:line 269
at System.Net.Security.SslStreamPal.EncryptDecryptHelper(SafeDeleteContext securityContext, ReadOnlyMemory`1 input, Int32 offset, Int32 size, Boolean encrypt, Byte[]& output, Int32& resultSize) in /root/corefx-1266141/src/System.Net.Security/src/System/Net/Security/SslStreamPal.Unix.cs:line 207
----- Inner Stack Trace -----
```

## History of failures

Day | Build | OS | Test name
--- | --- | --- | --- 
7/6-7/8 | many | Various Linux | 80x failed in each build (similar SSPI errors) - 480 failures
7/6-7/11 | many | Win7 | 4x & 4x failed in each build (same/similar SSPI errors) - 128 failures
7/11 | N/A | All | Tests were disabled in https://github.com/geoffkizer/corefx/commit/9c4af2973699aea35ce5c60c00f7dd14398e7a14#diff-fd4b6c323e531f0e41d566955e6fbffa
1/5 | 20180105.01 | Win7 | 4x GetAsync_AllowedSSLVersion_Succeeds &<br/>4x GetAsync_SupportedSSLVersion_Succeeds<br/>(both Win7-x86 and Win7-amd64) - [link](https://mc.dot.net/#/product/netcore/master/source/official~2Fcorefx~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180105.01/workItem/System.Net.Http.Functional.Tests)
1/5 | 20180105.02 | Win7 | 4x GetAsync_AllowedSSLVersion_Succeeds &<br/>4x GetAsync_SupportedSSLVersion_Succeeds<br/>(both Win7-x86 and Win7-amd64) - [link](https://mc.dot.net/#/product/netcore/master/source/official~2Fcorefx~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180105.02/workItem/System.Net.Http.Functional.Tests)
1/5 | 20180105.02 | RedHat73 | GetAsync_AllowedSSLVersion_Succeeds - [link](https://mc.dot.net/#/product/netcore/master/source/official~2Fcorefx~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180105.02/workItem/System.Net.Http.Functional.Tests/analysis/xunit/System.Net.Http.Functional.Tests.ManagedHandler_HttpClientHandler_SslProtocols_Test~2FGetAsync_AllowedSSLVersion_Succeeds(acceptedProtocol:%20Tls,%20requestOnlyThisProtocol:%20False))","Tests failed: System.Net.Http.Functional.Tests.ManagedHandler_HttpClientHandler_SslProtocols_Test / GetAsync_*SSLVersion_Succeeds  Regression caused by dotnet/corefx#26135 (@geoffkizer)

## Types of failures

Affected tests:
* GetAsync_AllowedSSLVers",35605,wfurt,corefx
35574,improve Ssl3 detection,"fixes #35537
It seems like recent Windows images have registry keys to disable SSLv3. This change updates detection to deal with is properly. It was verified on image created via reproTool. 

Note, that this does not seems directly related to discussion about defaulting SSLv3 when registry keys are missing. ","improve Ssl3 detection  fixes #35537
It seems like recent Windows images have registry keys to disable SSLv3. This change updates detection to deal with is properly. It was verified on image created via reproTool. 

Note, that this does not seems direc",35605,wfurt,corefx
28530,Incorrect exception message shown during NTLM authentication,"Split from dotnet/runtime#25827

As of .NET Core 2.1, the default HTTP stack is based on SocketsHttpHandler.  SocketsHttpHandler uses the GSSAPI for handling HTTP AUTH schemes of 'Negotiate' and 'NTLM'.

On *Nix and OSX machines, this requires installing the GSSAPI support packages for both Kerberos and NTLM. The default docker images for .NET Core do not include the NTLM support package (i.e. gss-ntlmssp). As a result, HttpClient will throw an exception when trying to authenticate against an NTLM server because the NTLM related package is not installed on the machine.

The exception message currently looks like this:

>Unhandled Exception: System.ComponentModel.Win32Exception: GSSAPI operation failed with error - An invalid status code was supplied (Unknown error).
   at System.Net.Security.NegotiateStreamPal.AcquireCredentialsHandle(String package, Boolean isServer, NetworkCredential credential)
...

This issue will address fixing up the error message text to be more descriptive of the problem and solution.

<details>
<summary>
Repo code
</summary>

```c#
using System;
using System.IO;
using System.Net;
using System.Net.Http;
using System.Net.Sockets;
using System.Threading.Tasks;

namespace NtlmErrorTest
{
    class Program
    {
        static void Main()
        {
            using (var listener = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp))
            {
                listener.Bind(new IPEndPoint(IPAddress.Loopback, 0));
                listener.Listen(int.MaxValue);
                var ep = (IPEndPoint)listener.LocalEndPoint;
                var uri = new Uri($""http://{ep.Address}:{ep.Port}/"");

                Task.Run(async () =>
                {
                    while (true)
                    {
                        Socket s = await listener.AcceptAsync();
                        var ignored = Task.Run(() =>
                        {
                            using (var ns = new NetworkStream(s))
                            using (var reader = new StreamReader(ns))
                            using (var writer = new StreamWriter(ns) { AutoFlush = true })
                            {
                                while (true)
                                {
                                    while (!string.IsNullOrEmpty(reader.ReadLine())) ;
                                    writer.Write(""HTTP/1.1 401 OK\r\nWww-Authenticate: NTLM\r\nContent-Length: 5\r\n\r\nhello"");
                                }
                            }
                        });
                    }
                });

                var handler = new HttpClientHandler();
                handler.Credentials = new NetworkCredential(""user"", ""password"", ""domain"");
                using (var client = new HttpClient(handler))
                {
                    Console.WriteLine(uri.AbsoluteUri.ToString());
                    using (HttpResponseMessage response = client.GetAsync(uri).GetAwaiter().GetResult())
                    {
                        Console.WriteLine($""{(int)response.StatusCode} {response.ReasonPhrase}"");
                    }
                }
            }
        }
    }
}
```

</details>
","Incorrect exception message shown during NTLM authentication  Split from dotnet/runtime#25827

As of .NET Core 2.1, the default HTTP stack is based on SocketsHttpHandler.  SocketsHttpHandler uses the GSSAPI for handling HTTP AUTH schemes of 'Negotiate'",34883,davidsh,corefx
28415,Test failure: System.Runtime.InteropServices.Tests.ByteTests/ReadByte_StructWithReferenceTypes_ReturnsExpected,"Opened on behalf of @AriNuer

The test `System.Runtime.InteropServices.Tests.ByteTests/ReadByte_StructWithReferenceTypes_ReturnsExpected` has failed.

Failure Message:
```
Assert.NotEqual() Failure
Expected: Not 0
Actual:   0
```

Stack Trace:
```
   at System.Runtime.InteropServices.Tests.ByteTests.ReadByte_StructWithReferenceTypes_ReturnsExpected() in /Users/vsts/agent/2.144.0/work/1/s/src/System.Runtime.InteropServices/tests/System/Runtime/InteropServices/Marshal/ReadWrite/ByteTests.cs:line 136
```

Build : 3.0 - 20190113.2 (Core Tests)
Failing configurations:
- OSX.1014.Amd64-x64
  - Release
Details:
https://mc.dot.net/#/product/netcore/30/source/official~2Fdotnet~2Fcorefx~2Frefs~2Fheads~2Fmaster/type/test~2Ffunctional~2Fcli~2F/build/20190113.2/workItem/System.Runtime.InteropServices.Tests/analysis/xunit/System.Runtime.InteropServices.Tests.ByteTests~2FReadByte_StructWithReferenceTypes_ReturnsExpected","Test failure: System.Runtime.InteropServices.Tests.ByteTests/ReadByte_StructWithReferenceTypes_ReturnsExpected  Opened on behalf of @AriNuer

The test `System.Runtime.InteropServices.Tests.ByteTests/ReadByte_StructWithReferenceTypes_ReturnsExpected` has",34589,jkoritzinsky,corefx
34445,Mitigate potential case where allocated marshal data is aligned to th…,"…e primitive being read.

 - Int16 and Int8.","Mitigate potential case where allocated marshal data is aligned to th…  …e primitive being read.

 - Int16 and Int8.",34589,jkoritzinsky,corefx
28142,[arm32/Linux] System.Net.Http.Functional.Tests failures on arm32 linux,"Running the arm32 tests on linux for System.Net.Http.Functional.Tests produced the following results: passed 5815/5833 tests.

18 tests failed for different reasons. Attaching the testResults.xml or a better analysis.

[testResults.zip](https://github.com/dotnet/corefx/files/2669431/testResults.zip)","[arm32/Linux] System.Net.Http.Functional.Tests failures on arm32 linux  Running the arm32 tests on linux for System.Net.Http.Functional.Tests produced the following results: passed 5815/5833 tests.

18 tests failed for different reasons. Attaching the t",34559,wfurt,corefx
29810,Fix WebSocket.Client tests on UAP,"Fixed WinRTWebSocket for the edge case of dealing with 0-byte receive calls.

Made a few adjustments to the tests for UAP test runs.

Fixes #28755.","Fix WebSocket.Client tests on UAP  Fixed WinRTWebSocket for the edge case of dealing with 0-byte receive calls.

Made a few adjustments to the tests for UAP test runs.

Fixes #28755.",34558,davidsh,corefx
28000,UWP 6.2.2: Connection Error : System.Net.WebSockets.WebSocketException,"System : Windows 10 1803 Build 17134
UWP Min Build : 16299
UWP Target Build : 17134
Visual Studio 15.9

```
Connection Error : 
System.Net.WebSockets.WebSocketException (203): An exception caused the WebSocket to enter the Aborted state. Please see the InnerException, if present, for more details.
---> System.ArgumentException: The specified buffer index is not within the buffer capacity.
   at System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.CopyTo(IBuffer source, UInt32 sourceIndex, Byte[] destination, Int32 destinationIndex, Int32 count)
   at System.Net.WebSockets.WinRTWebSocket.OnMessageReceived(MessageWebSocket sender, MessageWebSocketMessageReceivedEventArgs args)
   at System.Net.WebSockets.WinRTWebSocket.ReceiveAsync(ArraySegment`1 buffer, CancellationToken cancellationToken)
   at Microsoft.AspNet.SignalR.WebSockets.WebSocketMessageReader.ReadMessageAsync(WebSocket webSocket, Int32 bufferSize, Nullable`1 maxMessageSize, CancellationToken disconnectToken)
   at Microsoft.AspNet.SignalR.WebSockets.WebSocketHandler.ProcessWebSocketRequestAsync(WebSocket webSocket, CancellationToken disconnectToken, Func`2 messageRetriever, Object state)
```","UWP 6.2.2: Connection Error : System.Net.WebSockets.WebSocketException  System : Windows 10 1803 Build 17134
UWP Min Build : 16299
UWP Target Build : 17134
Visual Studio 15.9

```
Connection Error : 
System.Net.WebSockets.WebSocketException (203):",34558,davidsh,corefx
28343,Microsoft Security Advisory CVE-2019-0545: .NET Core Information Disclosure Vulnerability,"# Microsoft Security Advisory CVE-2019-0545: .NET Core Information Disclosure Vulnerability

## <a name=""executive-summary""></a>Executive summary

Microsoft is releasing this security advisory to provide information about a vulnerability in .NET Core 2.1 and 2.2. This advisory also provides guidance on what developers can do to update their applications to remove this vulnerability.

Microsoft is aware of an information disclosure vulnerability exists in .NET Framework and .NET Core which allows bypassing Cross-origin Resource Sharing (CORS) configurations. An attacker who successfully exploited the vulnerability could retrieve content, that is normally restricted, from a web application.

The security update addresses the vulnerability by enforcing CORS configuration to prevent its bypass.

## Announcement

The original announcement for this issue can be found at https://github.com/dotnet/announcements/issues/94

### <a name=""mitigation-factors""></a>Mitigation factors

Microsoft has not identified any mitigating factors for this vulnerability.

## <a name=""affected-software""></a>Affected software

Any .NET Core based application that uses the [System.Net.Http](https://www.nuget.org/packages/System.Net.Http/) package with a vulnerable version listed below.

Package name | Vulnerable versions | Secure versions
------------ | ------------------- | -------------------------
Microsoft.NETCore.App (System.Net.Http) | 2.1.0, 2.1.1, 2.1.2, 2.1.3, 2.1.4, 2.1.5, 2.1.6 | 2.1.7
Microsoft.NETCore.App (System.Net.Http) | 2.2.0 | 2.2.1

## <a name=""advisory-faq""></a>Advisory FAQ

### <a name=""how-affected""></a>How do I know if I am affected?

#### Applications that use Microsoft.NetCore.App

`System.Net.Http` is distributed as part of the .NET Core 2.1 runtime. To check the currently installed runtimes, open a command prompt and run the `dotnet --info` command. If you have a 2.1 or greater runtime installed, you'll see output like the following;

```text
.NET Core SDK (reflecting any global.json):
 Version:   2.2.100
 Commit:    b9f2fa0ca8

Runtime Environment:
 OS Name:     Windows
 OS Version:  10.0.17134
 OS Platform: Windows
 RID:         win10-x64
 Base Path:   C:\Program Files\dotnet\sdk\2.2.100\

Host (useful for support):
  Version: 2.2.0
  Commit:  1249f08fed

.NET Core SDKs installed:
  2.1.5 [C:\Program Files\dotnet\sdk]
  2.1.502 [C:\Program Files\dotnet\sdk]
  2.2.100 [C:\Program Files\dotnet\sdk]

.NET Core runtimes installed:
  Microsoft.AspNetCore.All 2.1.6 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.App 2.1.6 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.All 2.2.0 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.App 2.2.0 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.NETCore.App 2.1.6 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.2.0 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]

To install additional .NET Core runtimes or SDKs:
  https://aka.ms/dotnet-download
```

If your host version is 2.1.x and the highest `Microsoft.NETCore.App` runtime version is less than 2.1.7, you're vulnerable to this issue.
If your host version is 2.2.x and the highest 2.1.x `Microsoft.NETCore.App` runtime version is less than 2.1.7, you're vulnerable to this issue.

You will not see SDK versions if you have only installed the runtime.

#### Applications not using Microsoft.NetCore.App

The affected assembly is also available separately as a NuGet package. If you are not using Microsoft.NetCore.App, you may still be affected if you are referencing the packages listed above.

##### Direct dependencies

Direct dependencies are discoverable by examining your `csproj` file. They can be fixed by [editing the project file](#fixing-direct-dependencies) or using NuGet to update the dependency.

##### Transitive dependencies

Transitive dependencies occur when you add a package to your project that in turn relies on another package. For example, if Contoso publishes a package `Contoso.Utility` which, in turn, depends on `Contoso.Internals` and you add the `Contoso.Utility` package to your project now your project has a direct dependency on `Contoso.Utility` and, because `Contoso.Utility` depends 'Contoso.Internals', your application gains a transitive dependency on the `Contoso.Internals` package.

Transitive dependencies are reviewable in two ways:

* In the Visual Studio Solution Explorer window, which supports searching.
* By examining the `project.assets.json` file contained in the obj directory of your project for `csproj` based projects

The `project.assets.json` files are the authoritative list of all packages used by your project, containing both direct and transitive dependencies.

There are two ways to view transitive dependencies. You can either [use Visual Studio’s Solution Explorer](#vs-solution-explorer), or you can review [the `project.assets.json` file](#project-assets-json)).

##### <a name=""vs-solution-explorer""></a>Using Visual Studio Solution Explorer

To use Solution Explorer, open the project in Visual Studio, and then press Ctrl+; to activate the search in Solution Explorer. Search for the [vulnerable package](#affected-software) and make a note of the version numbers of any results you find.

For example, searching for `Microsoft.AspNetCore.Mvc.Core` in an example project that contains a package that takes a dependency on `Microsoft.AspNetCore.Mvc` shows the following results in Visual Studio 2017:

![Screenshot of search results in Visual Studio 2017](https://cloud.githubusercontent.com/assets/796298/25858816/8ecdc2b4-3491-11e7-9363-746804bb9832.png)

The search results appear as a tree. In the previous results, you can see that a reference to `Microsoft.AspNetCore.Mvc.Core` version 1.1.2 is discovered.

Under the Dependencies node is a NuGet node. Under the NuGet node is the list of packages you have directly taken a dependency on and their versions.
In screenshot, the application takes a direct dependency on `Microsoft.AspNetCore.Mvc`. `Microsoft.AspNetCore.Mvc` in turn has leaf nodes that list its dependencies and their versions.
The `Microsoft.AspNetCore.Mvc` package takes a dependency on a version of `Microsoft.AspNetCore.Mvc.ApiExplorer`, that in turn takes a dependency on a version of `Microsoft.AspNetCore.Mvc.Core`.

##### <a name=""project-assets-json""></a> Manually reviewing project.assets.json

Open the *project.assets.json* file from your project’s obj directory in your editor. We suggest you use an editor that understands JSON and allows you to collapse and expand nodes to review this file.
Visual Studio and Visual Studio Code provide JSON friendly editing.

Search the *project.assets.json* file for the [vulnerable package](#affected-software), using the format `packagename/` for each of the package names from the preceding table. If you find the assembly name in your search:

* Examine the line on which they are found, the version number is after the `/`.
* Compare to the [vulnerable versions table](#affected-software).

For example, a search result that shows `SSystem.Net.Http/4.3.0` is a reference to version 4.3.0 of `System.Net.Http`.

If your *project.assets.json* file includes references to the [vulnerable package](#affected-software), then you need to fix the transitive dependencies.

If you have not found any reference to any vulnerable packages, this means either

* None of your direct dependencies depend on any vulnerable packages, or
* You have already fixed the problem by updating the direct dependencies.

### <a name=""how-fix""></a>How do I fix the issue?

#### Updating the version of Microsoft.NETCore.App

If your host version is a 2.1.x host you must install version 2.1.7 or later of the [.NET Core 2.1 runtime](https://dotnet.microsoft.com/download/dotnet-core/2.1), or corresponding [.NET Core 2.1 SDK](https://dotnet.microsoft.com/download/dotnet-core/2.1).

If your host version is a 2.2.x you must install version 2.2.1 or later of the [.NET Core 2.2 runtime](https://dotnet.microsoft.com/download/dotnet-core/2.2), or corresponding  [.NET Core 2.2 SDK](https://dotnet.microsoft.com/download/dotnet-core/2.2).

#### <a name=""fixing-direct-dependencies""></a>Fixing direct dependencies

Open *projectname.csproj* in your editor. If you're using Visual Studio, right-click the project and choose **Edit projectname.csproj** from the context menu, where projectname is the name of your project. Look for `PackageReference` elements. The following shows an example project file:

```xml
<Project Sdk=""Microsoft.NET.Sdk.Web"">
  <PropertyGroup>
    <TargetFramework>netcoreapp2.1</TargetFramework>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include=""System.Net.Http"" Version=""4.3.0"" />
  </ItemGroup>
</Project>
```

The preceding example has a reference to the [vulnerable package](#affected-software), as seen by the single `PackageReference` element. The name of the package is in the `Include` attribute.
The package version number is in the `Version` attribute. The previous example shows a single direct dependency on `System.Net.Http` version 4.3.0

To update the version to the secure package, change the version number to the updated package version as listed on the table [previously](#affected-software).
In this example, update `System.IO.Pipelines` to the appropriate [fixed package number](#affected-software) for your major version. Save the *csproj* file. The example *csproj* now looks as follows:

```xml
<Project Sdk=""Microsoft.NET.Sdk.Web"">
  <PropertyGroup>
    <TargetFramework>netcoreapp2.1</TargetFramework>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include=""System.Net.Http"" Version=""4.3.5"" />
  </ItemGroup>
</Project>
```

If you're using Visual Studio and you save your updated *csproj* file, Visual Studio will restore the new package version.
You can see the restore results by opening the **Output** window (Ctrl+Alt+O) and changing the **Show output from** drop-down list to **Package Manager**.

If you're not using Visual Studio, open a command line and change to your project directory. Execute the `dotnet restore` command to restore the updated dependencies.

Now recompile your application. If after recompilation you see a *Dependency conflict warning*, you must update your other direct dependencies to versions that take a dependency on the updated package.

#### <a name=""transitive-dependencies""></a>Fixing transitive dependencies

If your transitive dependency review found references to the [vulnerable package](#affected-software), you must add a direct dependency to the updated package to your *csproj* file to override the transitive dependency.

Open *projectname.csproj* in your editor. If you're using Visual Studio, right-click the project and choose **Edit projectname.csproj** from the context menu, where projectname is the name of your project.
Look for `PackageReference` nodes, for example:

```xml
<Project Sdk=""Microsoft.NET.Sdk."">
  <PropertyGroup>
    <TargetFramework>net461</TargetFramework>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include=""ThirdParty.NotUpdatedYet"" Version=""2.0.0"" />
  </ItemGroup>
</Project>
```

You must add a direct dependency to the updated version of the [vulnerable package](#affected-software) by adding it to the *csproj* file.
You do this by adding a new line to the dependencies section, referencing the fixed version.
For example, if your search showed a transitive reference to a vulnerable `System.ServiceModel.Http` version, you'd add a reference to the [fixed package number](#affected-software).

```xml
<Project Sdk=""Microsoft.NET.Sdk.Web"">
  <PropertyGroup>
    <TargetFramework>net461</TargetFramework>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include=""System.Net.Http"" Version=""4.3.5"" />
    <PackageReference Include=""ThirdParty.NotUpdatedYet"" Version=""2.0.0"" />
  </ItemGroup>
</Project>
```

After you've added the direct dependency reference, save your *csproj* file.

If you're using Visual Studio, save your updated *csproj* file and Visual Studio will restore the new package versions.
You can see the restore results by opening the **Output** window (Ctrl+Alt+O) and changing the **Show output from** drop-down list to **Package Manager**.

If you're not using Visual Studio, open a command line and change to your project directory. Execute the `dotnet restore` command to restore the new dependencies.

##### Rebuilding your application

Finally, you must rebuild your application, test, and redeploy.

## Other Information

### Reporting Security Issues

If you have found a potential security issue in .NET Core, please email details to secure@microsoft.com. Reports may qualify for the .NET Core Bug Bounty. Details of the .NET Core Bug Bounty including terms and conditions are at [https://aka.ms/corebounty](https://aka.ms/corebounty).

### Support

You can ask questions about this issue on GitHub in the .NET Core or ASP.NET Core organizations. These are located at https://github.com/dotnet/ and https://github.com/aspnet/. The Announcements repo for each product (https://github.com/dotnet/Announcements and https://github.com/aspnet/Announcements) will contain this bulletin as an issue and will include a link to a discussion issue. You can ask questions in the discussion issue.

### Disclaimer

The information provided in this advisory is provided ""as is"" without warranty of any kind. Microsoft disclaims all warranties, either express or implied, including the warranties of merchantability and fitness for a particular purpose. In no event shall Microsoft Corporation or its suppliers be liable for any damages whatsoever including direct, indirect, incidental, consequential, loss of business profits or special damages, even if Microsoft Corporation or its suppliers have been advised of the possibility of such damages. Some states do not allow the exclusion or limitation of liability for consequential or incidental damages so the foregoing limitation may not apply.

### External Links

[CVE-2019-0545](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-0545)

### Revisions

V1.1 (January 9, 2019): Correct affected package table. 
V1.0 (January 8, 2019): Advisory published.

_Version 1.1_

_Last Updated 2019-01-09_","Microsoft Security Advisory CVE-2019-0545: .NET Core Information Disclosure Vulnerability  # Microsoft Security Advisory CVE-2019-0545: .NET Core Information Disclosure Vulnerability

## <a name=""executive-summary""></a>Executive summary

Microsoft is",34507,caesar-chen,corefx
26979,SocketsHttpHandler doesn't support response headers with a 100 status code,"According to [RFC7231 section 6.2](https://tools.ietf.org/html/rfc7231#section-6.2)

> 1xx responses are terminated by the first empty line after
> the status-line (the empty line signaling the end of the header
> section).

This means that a server can send headers before the empty line that terminates a 100 continue status response. The WCF team has a customer who is trying to communicate with a SOAP service which returns headers along with the 100 status response. This is tracked in issue dotnet/wcf#3008.","SocketsHttpHandler doesn't support response headers with a 100 status code  According to [RFC7231 section 6.2](https://tools.ietf.org/html/rfc7231#section-6.2)

> 1xx responses are terminated by the first empty line after
> the status-line (the empty l",34507,caesar-chen,corefx
26451,HttpRequestException when creating empty key in AWS S3,"Hello,

I'm getting a `System.Net.Http.HttpRequestException` after an AWS S3 PUT operation. I'm trying to create an S3 ""folder"" (ie: an empty object) usign the AWS SDK for S3. The folder itself is successfully created. The error happens on every request. Environment is ASP.NET Core 2.1, Windows 10 (dev computer).

I'm currently working around this by catching the exception and re-querying the S3 key to confirm creation. But something looks very out of place. And surely AWS is so heaveily used that this bug is would be rampent! (Which makes me wonder if this is something special or unusual). The stack dump is pointing at `HttpConnection.SendAsyncCore()`, so I don't think this is Amazon's fault.

I've checked in [HttpConnection.SendAsyncCore()](https://github.com/dotnet/corefx/blob/02b11fae98fd2d6662e1c490cae8462b0ce1ecdf/src/System.Net.Http/src/System/Net/Http/SocketsHttpHandler/HttpConnection.cs) but that method is.... complex. And the places where `ThrowInvalidHttpResponse()` is called don't obviously correspond to anythign wrong with the HTTP response.

From the HTTP response, the only error I can see is it's *200 OK* rather than *204 Empty*. Other corefx issues raised with this exception have missing headers or extra whitespace or missing colons, but the headers all look OK to me.

It would also be nice for the exception to ""tag"" which site it is thrown from, given there are ~15 possible places in HttpConnection.cs. Even if its an error number or short code, anything to narrow down the exact throw!

Regards
Murray

**HTTP Request**

```
PUT https://circuitlink-bt.s3.ap-southeast-2.amazonaws.com/_Unprocessed/BTR12357/FIRMWARE/ HTTP/1.1
Expect: 100-continue
User-Agent: aws-sdk-dotnet-coreclr/3.3.18.3 aws-sdk-dotnet-core/3.3.24.0 .NET_Core/4.6.26515.07 OS/Microsoft_Windows_10.0.16299 ClientAsync
Host: circuitlink-bt.s3.ap-southeast-2.amazonaws.com
X-Amz-Date: 20180612T023113Z
X-Amz-Content-SHA256: e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
Authorization: AWS4-HMAC-SHA256 Credential=[redacted]/20180612/ap-southeast-2/s3/aws4_request, SignedHeaders=content-length;content-type;host;user-agent;x-amz-content-sha256;x-amz-date, Signature=[redacted]
Content-Length: 0
Content-Type: text/plain
```

**HTTP Response**

```
HTTP/1.1 200 OK
x-amz-id-2: VECzyxSK/10lyVcQQickFaiZxvDpNRQiUKhUXN2IHQJD6OpJ+pJWGXvimA0YjeZlcKFwGJisoEU=
x-amz-request-id: 7CB4D3B7B2438CA0
Date: Tue, 12 Jun 2018 02:31:15 GMT
ETag: ""d41d8cd98f00b204e9800998ecf8427e""
Content-Length: 0
Server: AmazonS3
```

**Client Code**

```c#
public async Task CreateDirectory(string relativePath)
{
	// relativePath = ""FIRMWARE""
    var putRequest = new PutObjectRequest();
    putRequest.BucketName = _Config.BucketName;		// = ""circuitlink-bt""
    putRequest.Key = (String.IsNullOrEmpty(_Config.BasePath) ? """" : _Config.BasePath + ""/"")		// BasePath = ""_Unprocessed""
                + relativePath + ""/"";       // Need trailing slash to create a folder.
    putRequest.ContentBody = """";
    Logger.Debug(""Creating directory '{0}' in S3 bucket '{1}'."", putRequest.Key, putRequest.BucketName);
	// Logs: Creating directory '_Unprocessed/BTR12357/FIRMWARE/' in S3 bucket 'circuitlink-bt'.
    PutObjectResponse response;
    try
    {
        response = await _S3Client.PutObjectAsync(putRequest);
		// Next line is never hit.
        Logger.Debug(""Created directory '{0}' in S3 bucket '{1}' successfully."", putRequest.Key, putRequest.BucketName);
    }
    catch (System.Net.Http.HttpRequestException ex)
    {
        Logger.Error(ex, ""Exception while creating S3 directory '{0}' in S3 bucket '{1}'."", putRequest.Key, putRequest.BucketName);
		// Logs: Exception while creating S3 directory '_Unprocessed/BTR12357/FIRMWARE/' in S3 bucket 'circuitlink-bt'.
		// Stack dump below.
        throw;
    }
}
```

**Exception and Stack Dump**

```
13:57:36.6|DEBUG| | 4: | CL.BTCloud.Services.AWS.DeviceServerStorage.DeviceServerStorageOnS3 | http://localhost/api/register/BTC| HttpRequestException while creating S3 directory '_Unprocessed/BTR12357/FIRMWARE/' in S3 bucket 'circuitlink-bt'. System.Net.Http.HttpRequestException: The server returned an invalid or unrecognized response.
   at System.Net.Http.HttpConnection.ThrowInvalidHttpResponse()
   at System.Net.Http.HttpConnection.SendAsyncCore(HttpRequestMessage request, CancellationToken cancellationToken)
   at System.Net.Http.HttpConnectionPool.SendWithRetryAsync(HttpRequestMessage request, Boolean doRequestAuth, CancellationToken cancellationToken)
   at System.Net.Http.HttpClient.FinishSendAsyncUnbuffered(Task`1 sendTask, HttpRequestMessage request, CancellationTokenSource cts, Boolean disposeCts)
   at Amazon.Runtime.HttpWebRequestMessage.GetResponseAsync(CancellationToken cancellationToken) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\HttpHandler\_mobile\HttpRequestMessageFactory.cs:line 428
   at Amazon.Runtime.Internal.HttpHandler`1.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\HttpHandler\HttpHandler.cs:line 175
   at Amazon.Runtime.Internal.RedirectHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.Unmarshaller.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.S3.Internal.AmazonS3ResponseHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.ErrorHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.CredentialsRetriever.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\Handlers\CredentialsRetriever.cs:line 98
   at Amazon.Runtime.Internal.RetryHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.RetryHandler.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\RetryHandler\RetryHandler.cs:line 137
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.S3.Internal.AmazonS3ExceptionHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.ErrorCallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.MetricsHandler.InvokeAsync[T](IExecutionContext executionContext)
   at CL.BTCloud.Services.AWS.DeviceServerStorage.DeviceServerStorageOnS3.CreateDirectory(String relativePath) in C:\Projects\CircuitLink\Intelligo\Braketesta\Shared\BTCloud.Services.AWS\DeviceServerStorage\DeviceServerStorageOnS3.cs:line 47
```","HttpRequestException when creating empty key in AWS S3  Hello,

I'm getting a `System.Net.Http.HttpRequestException` after an AWS S3 PUT operation. I'm trying to create an S3 ""folder"" (ie: an empty object) usign the AWS SDK for S3. The folder itself is",34507,caesar-chen,corefx
26990,System.Net.Http.HttpRequestException: The server returned an invalid or unrecognized response,"Similar to dotnet/runtime#26774 and potentially [others](https://github.com/dotnet/corefx/issues?q=is%3Aissue+%22invalid+or+unrecognized+response%22+is%3Aopen), we're getting `System.Net.Http.HttpRequestException: The server returned an invalid or unrecognized response` when  making a HTTPS certificate authenticated request to Bloomberg's Web API. We want to use dotnetcore but this is blocking us.

- Windows 10 Enterprise 2016 LTSB 1607 Build 14393.2368 64bit
- .NET Core 2.1
- VS 15.7.5 Microsoft WCF Web Service Provider generated proxy of [https://service.bloomberg.com/assets/dl/dlws.wsdl](https://service.bloomberg.com/assets/dl/dlws.wsdl)
- Dependencies:
```
<ItemGroup>
    <PackageReference Include=""log4net"" Version=""2.0.8"" />
    <PackageReference Include=""Newtonsoft.Json"" Version=""11.0.2"" />
    <PackageReference Include=""System.ServiceModel.Duplex"" Version=""4.5.3"" />
    <PackageReference Include=""System.ServiceModel.Http"" Version=""4.5.3"" />
    <PackageReference Include=""System.ServiceModel.NetTcp"" Version=""4.5.3"" />
    <PackageReference Include=""System.ServiceModel.Security"" Version=""4.5.3"" />
</ItemGroup>
```


Please let me know if I can provide any more detail since this will be hard for anyone to reproduce unless they mock a server to return the exact response Bloomberg's servers do. 

```
System.ServiceModel.CommunicationException: The server returned an invalid or unrecognized response. ---> System.Net.Http.HttpRequestException: The server returned an invalid or unrecognized response.
   at System.Net.Http.HttpConnection.ThrowInvalidHttpResponse()
   at System.Net.Http.HttpConnection.SendAsyncCore(HttpRequestMessage request, CancellationToken cancellationToken)
   at System.Net.Http.AuthenticationHelper.SendWithNtAuthAsync(HttpRequestMessage request, Uri authUri, ICredentials credentials, Boolean isProxyAuth, HttpConnection connection, CancellationToken cancellationToken)
   at System.Net.Http.HttpConnectionPool.SendWithRetryAsync(HttpRequestMessage request, Boolean doRequestAuth, CancellationToken cancellationToken)
   at System.Net.Http.AuthenticationHelper.SendWithAuthAsync(HttpRequestMessage request, Uri authUri, ICredentials credentials, Boolean preAuthenticate, Boolean isProxyAuth, Boolean doRequestAuth, HttpConnectionPool pool, CancellationToken cancellationToken)
   at System.Net.Http.RedirectHandler.SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
   at System.Net.Http.DecompressionHandler.SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
   at System.Net.Http.HttpClient.FinishSendAsyncUnbuffered(Task`1 sendTask, HttpRequestMessage request, CancellationTokenSource cts, Boolean disposeCts)
   at System.ServiceModel.Channels.HttpChannelFactory`1.HttpClientRequestChannel.HttpClientChannelAsyncRequest.SendRequestAsync(Message message, TimeoutHelper timeoutHelper)
   --- End of inner exception stack trace ---
   at System.Runtime.AsyncResult.End[TAsyncResult](IAsyncResult result)
   at System.ServiceModel.Channels.ServiceChannel.SendAsyncResult.End(SendAsyncResult result)
   at System.ServiceModel.Channels.ServiceChannel.EndCall(String action, Object[] outs, IAsyncResult result)
   at System.ServiceModel.Channels.ServiceChannelProxy.TaskCreator.<>c__DisplayClass1_0.<CreateGenericTask>b__0(IAsyncResult asyncResult)
--- End of stack trace from previous location where exception was thrown ---
```

Below is the client setup code using NETCOREAPP;NETCOREAPP2_1. This was migrated from .NET 4.5 where the only changes are the 5 lines commented out as those properties are not supported in core 2.1.

``` C#
public PerSecurityWSClient GetPerSecurityWsClient() {
	var binding = new BasicHttpBinding();
	binding.Name = ""PerSecurityWSBinding"";
	binding.CloseTimeout = TimeSpan.FromMinutes(1);
	binding.OpenTimeout = TimeSpan.FromMinutes(1);
	binding.ReceiveTimeout = TimeSpan.FromMinutes(10);
	binding.SendTimeout = TimeSpan.FromMinutes(1);
	binding.BypassProxyOnLocal = false;
	//binding.HostNameComparisonMode = HostNameComparisonMode.StrongWildcard;
	binding.MaxBufferPoolSize = 524288;
	binding.MaxBufferSize = 65536000;
	binding.MaxReceivedMessageSize = 65536000;
	//binding.MessageEncoding = WSMessageEncoding.Text;
	binding.TextEncoding = Encoding.UTF8;
	binding.UseDefaultWebProxy = true;
	binding.AllowCookies = false;
	binding.TransferMode = TransferMode.Buffered;
	binding.ReaderQuotas.MaxDepth = 32;
	binding.ReaderQuotas.MaxArrayLength = 16384;
	binding.ReaderQuotas.MaxStringContentLength = 8192;
	binding.ReaderQuotas.MaxBytesPerRead = 4096;
	binding.ReaderQuotas.MaxNameTableCharCount = 16384;
	binding.Security.Mode = BasicHttpSecurityMode.Transport;
	binding.Security.Transport.ClientCredentialType = HttpClientCredentialType.Certificate;
	binding.Security.Transport.ProxyCredentialType = HttpProxyCredentialType.None;            
	//binding.Security.Transport.Realm = """";            
	//binding.Security.Message.ClientCredentialType = BasicHttpMessageCredentialType.Certificate;
	//binding.Security.Message.AlgorithmSuite = SecurityAlgorithmSuite.Default;

	var endpoint = new EndpointAddress(""https://dlws.bloomberg.com/dlps"");
	var client = new PerSecurityWSClient(binding, endpoint);
	var clientCert = new X509Certificate2(Properties.Resources.DLWSCert, ""<cert secret>"");
	client.ClientCredentials.ClientCertificate.Certificate = clientCert;

	return client;
}
```

Fiddler traces show TLS handshake succeeding:

```
CONNECT dlws.bloomberg.com:443 HTTP/1.1
Host: dlws.bloomberg.com:443

A SSLv3-compatible ClientHello handshake was found. Fiddler extracted the parameters below.

Version: 3.3 (TLS/1.2)
Random: 5B 5B 29 76 72 A8 37 E8 E2 4D AD 4A 8A FB 2B 55 53 61 83 63 78 98 C0 A1 7E 31 36 0E D1 42 7B 64
""Time"": 10/26/2032 12:44:11 PM
SessionID: empty
Extensions: 
	server_name	dlws.bloomberg.com
	elliptic_curves	unknown [0x1D), secp256r1 [0x17], secp384r1 [0x18]
	ec_point_formats	uncompressed [0x0]
	signature_algs	sha256_rsa, sha384_rsa, sha1_rsa, sha256_ecdsa, sha384_ecdsa, sha1_ecdsa, sha1_dsa, sha512_rsa, sha512_ecdsa
	SessionTicket	empty
	extended_master_secret	empty
	renegotiation_info	00
Ciphers: 
	[C02C]	TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
	[C02B]	TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
	[C030]	TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
	[C02F]	TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
	[009F]	TLS_DHE_RSA_WITH_AES_256_GCM_SHA384
	[009E]	TLS_DHE_RSA_WITH_AES_128_GCM_SHA256
	[C024]	TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384
	[C023]	TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256
	[C028]	TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384
	[C027]	TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256
	[C00A]	TLS1_CK_ECDHE_ECDSA_WITH_AES_256_CBC_SHA
	[C009]	TLS1_CK_ECDHE_ECDSA_WITH_AES_128_CBC_SHA
	[C014]	TLS1_CK_ECDHE_RSA_WITH_AES_256_CBC_SHA
	[C013]	TLS1_CK_ECDHE_RSA_WITH_AES_128_CBC_SHA
	[0039]	TLS_DHE_RSA_WITH_AES_256_SHA
	[0033]	TLS_DHE_RSA_WITH_AES_128_SHA
	[009D]	TLS_RSA_WITH_AES_256_GCM_SHA384
	[009C]	TLS_RSA_WITH_AES_128_GCM_SHA256
	[003D]	TLS_RSA_WITH_AES_256_CBC_SHA256
	[003C]	TLS_RSA_WITH_AES_128_CBC_SHA256
	[0035]	TLS_RSA_AES_256_SHA
	[002F]	TLS_RSA_AES_128_SHA
	[000A]	SSL_RSA_WITH_3DES_EDE_SHA
	[006A]	TLS_DHE_DSS_WITH_AES_256_CBC_SHA256
	[0040]	TLS_DHE_DSS_WITH_AES_128_CBC_SHA256
	[0038]	TLS_DHE_DSS_WITH_AES_256_SHA
	[0032]	TLS_DHE_DSS_WITH_AES_128_SHA
	[0013]	SSL_DHE_DSS_WITH_3DES_EDE_SHA

Compression: 
	[00]	NO_COMPRESSION

```

```
HTTP/1.1 200 Connection Established
FiddlerGateway: Direct
StartTime: 10:17:26.127
Connection: close

Encrypted HTTPS traffic flows through this CONNECT tunnel. HTTPS Decryption is enabled in Fiddler, so decrypted sessions running in this tunnel will be shown in the Web Sessions list.

Secure Protocol: Tls12
Cipher: Aes256 256bits
Hash Algorithm: Sha384 ?bits
Key Exchange: ECDHE_RSA (0xae06) 256bits

== Client Certificate ==========
[Subject]
  E=datalicense@bloomberg.net, CN=<redacted>:DLWS, OU=DataLicense, O=Bloomberg L.P, S=NY, C=US

[Issuer]
  CN=Data License SubCA

[Serial Number]
  <redacted>

[Not Before]
  6/2/2016 4:29:29 PM

[Not After]
  6/2/2021 4:39:29 PM

[Thumbprint]
  <redacted>


== Server Certificate ==========
[Subject]
  CN=dlws.bloomberg.com, O=Bloomberg LP, L=New York, S=New York, C=US, SERIALNUMBER=2110234, OID.1.3.6.1.4.1.311.60.2.1.2=Delaware, OID.1.3.6.1.4.1.311.60.2.1.3=US, OID.2.5.4.15=Private Organization

[Issuer]
  CN=DigiCert SHA2 Extended Validation Server CA, OU=www.digicert.com, O=DigiCert Inc, C=US

[Serial Number]
  0CA53FCF9C01626E39697942999764F6

[Not Before]
  12/12/2017 7:00:00 PM

[Not After]
  12/18/2019 7:00:00 AM

[Thumbprint]
  899E0AEE49C6A6BF5AD87A0AD1C780DF149F32F3

[SubjectAltNames]
dlws.bloomberg.com, services.bloomberg.com

```

After handshake, here is the proceeding request and response. 

```
POST https://dlws.bloomberg.com/dlps HTTP/1.1
Cache-Control: no-cache, max-age=0
SOAPAction: ""submitGetDataRequest""
Expect: 100-continue
Accept-Encoding: gzip, deflate
Content-Type: text/xml; charset=utf-8
Content-Length: 643
Host: dlws.bloomberg.com

<s:Envelope xmlns:s=""http://schemas.xmlsoap.org/soap/envelope/""><s:Body xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xmlns:xsd=""http://www.w3.org/2001/XMLSchema""><submitGetDataRequest xmlns=""http://services.bloomberg.com/datalicense/dlws/ps/20071001""><headers><programflag>oneshot</programflag><secid>BB_GLOBAL</secid><secmaster>true</secmaster><yellowkey>Equity</yellowkey><pricing>true</pricing></headers><fields><field>ID_BB_UNIQUE</field><field>PX_LAST</field></fields><instruments><instrument><id>MSFT.US</id><yellowkey>Equity</yellowkey><type>TICKER</type></instrument></instruments></submitGetDataRequest></s:Body></s:Envelope>
```

The error occurs immediately after digesting the response below.

```
HTTP/1.1 200 OK
Connection: Keep-Alive
Date: Fri, 27 Jul 2018 14:17:26+0000
Via: BAS/1.0 nybasv3
Content-Length: 625
Content-Type: text/xml; charset=utf-8
Server: Apache-Coyote/1.1
bb-request-id: d916550e-36a4-4be5-bc24-4cba127367d2
com.bloomberg.bas-recipientTask: machine=0; instance=0;
com.bloomberg.bas-serviceId: 125322
com.bloomberg.bas-serviceVersion: 3.1
Set-Cookie: machineNumber=0; path=/
X-Powered-By: Servlet 2.4; JBoss-4.3.0.GA_CP04 (build: SVNTag=JBPAPP_4_3_0_GA_CP04 date=200902200048)/JBossWeb-2.0

<?xml version=""1.0"" encoding=""UTF-8"" ?><soap:Envelope xmlns:soap=""http://schemas.xmlsoap.org/soap/envelope/""><soap:Body><dlws:submitGetDataResponse xmlns='http://services.bloomberg.com/datalicense/dlws/ps/20071001' xmlns:dlws=""http://services.bloomberg.com/datalicense/dlws/ps/20071001"" xmlns:env=""http://schemas.xmlsoap.org/soap/envelope/""><dlws:statusCode><dlws:code>0</dlws:code><dlws:description>Success</dlws:description></dlws:statusCode><dlws:requestId>d916550e-36a4-4be5-bc24-4cba127367d2</dlws:requestId><dlws:responseId>1532701047-721515399</dlws:responseId></dlws:submitGetDataResponse></soap:Body></soap:Envelope>

```
I thought maybe it was related to dotnet/runtime#22404 with invalid headers but they appear to be OK according to these checks ([valid-header-name.js](https://github.com/m59peacemaker/js-check-header/blob/master/valid-header-name.js) and [valid-header-value.js](https://github.com/m59peacemaker/js-check-header/blob/master/valid-header-value.js).)

Any help on the subject would be appreciated.","System.Net.Http.HttpRequestException: The server returned an invalid or unrecognized response  Similar to dotnet/runtime#26774 and potentially [others](https://github.com/dotnet/corefx/issues?q=is%3Aissue+%22invalid+or+unrecognized+response%22+is%3Aopen),",34507,caesar-chen,corefx
26981,"SocketsHttpHandler doesn't support receiving multiple ""100 continue"" status responses","According to [RFC7231 section 6.2](https://tools.ietf.org/html/rfc7231#section-6.2), multiple ""100 continue"" status responses should be supported:

> A client MUST be able to parse one or more 1xx responses received
> prior to a final response, even if the client does not expect one.  A
> user agent MAY ignore unexpected 1xx responses.

WCF has a customer who is communicating with a SOAP service which is returning multiple 100 status responses. The second 100 status response is being returned to WCF as the final response. Additionally, after looking at the code, I don't believe SocketsHttpHandler supports receiving a 100 status response when the `Expect: 100-continue` header was absent in the outgoing request. This could be as a result of an intermediate proxy having added an Expect header when forwarding the request and not removing the 100 status response on the reply. The WCF issue tracking this is dotnet/wcf#3048","SocketsHttpHandler doesn't support receiving multiple ""100 continue"" status responses  According to [RFC7231 section 6.2](https://tools.ietf.org/html/rfc7231#section-6.2), multiple ""100 continue"" status responses should be supported:

> A client MUST be",34507,caesar-chen,corefx
27787,Add API for resolving component dependencies,"This is a proposal to add new public API which would expose functionality to help with resolution of managed and unmanaged dependencies of components.

### Proposed Surface Area
``` C#
namespace System.Runtime.Loader
{
    public sealed class ComponentDependencyResolver
    {
        public ComponentDependencyResolver(string componentAssemblyPath);

        public string ResolveAssemblyToPath(AssemblyName assemblyName);
        public string ResolveUnmanagedDllToPath(string unmanagedDllName);
    }
}
```

### Functionality
Given the path to a component assembly (the main `.dll` of a given component, for example the build result of a class library project), the constructor creates a resolver object which can resolve managed and unmanaged dependencies of the component. The constructor would look for the `.deps.json` file next to the main assembly and use it to compute the set of dependencies.

The `ResolveAssemblyToPath` and `ResolveUnmanagedDllToPath` methods are then used to resolve references to managed and unmanaged dependencies. These methods take the name of the dependency and return either null if such dependency can't be resolved by the component, or a full path to the file (managed assembly or unmanaged library).

The constructor is expected to catch most error cases and report them as exceptions. The `Resolve` methods should in general not throw and instead return null if the dependency can't be resolved.

### Scenario: Dynamic component loading

The proposed API can be used to greatly simplify dynamic loading of components. It provides a powerful building block to use for implementing custom `AssemblyLoadContext` or event handlers for the binding events like `AppDomain.AssemblyResolve` and `AssemblyLoadContext.Resolving`.

Example of using the new API to load plugins with `AssemblyLoadContext` in isolation:
``` C#
class PluginLoadContext : AssemblyLoadContext
{
    ComponentDependencyResolver _resolver;
    
    public PluginLoadContext(string pluginPath)
    {
        _resolver = new ComponentDependencyResolver(pluginPath);
    }

    public override Assembly Load(AssemblyName assemblyName)
    {
        string assemblyPath = _resolver.ResolveAssemblyToPath(assemblyName);
        if (assemblyPath != null)
        {
            return LoadFromAssemblyPath(assemblyPath);
        }
    
        return null;
    }
}

PluginLoadContext pluginContext = new PluginLoadContext(""/pathtoplugin/plugin.dll"");
Assembly pluginAssembly = pluginContext.LoadFromAssemblyName(new AssemblyName(""Plugin""));

// ... use the pluginAssembly and reflection to invoke functionality from the plugin.
// Dependencies of the plugin are resolved by the event handler above using the resolver
// to provide the actual resolution from assembly name to file path.
```

### Scenario: Inspecting IL metadata of components

Using the newly proposed `MetadataLoadContext` API (see the [proposal](https://github.com/dotnet/corefx/issues/2800)) to inspect IL metadata of components. This API requires an assembly resolver to resolve dependencies of the component. The proposed `ComponentDependencyResolver` would be used to implement such resolver for components produced by the .NET Core SDK.

Example of using the new API to implement `MetadataAssemblyResolver`:
``` C#
public class ComponentMetadataAssemblyResolver : MetadataAssemblyResolver
{
    private ComponentDependencyResolver dependencyResolver;

    public override Assembly Resolve(MetadataLoadContext context, AssemblyName assemblyName)
    {
        string assemblyPath = dependencyResolver.ResolveAssemblyToPath(assemblyName);
        if (assemblyPath != null)
        {
            return context.LoadFromAssemblyPath(assemblyPath);
        }

        // Code to load framework dependencies from the running app for example
        // using Assembly.Load and so on.

        return null;
    }
}
```

### Context

.NET Core SDK (used by VS, VS Code, VS for Mac and so on) describes component dependencies in the build output via the `.deps.json` files ([description](https://github.com/dotnet/cli/blob/master/Documentation/specs/runtime-configuration-file.md)). These files are consumed by the hosting components (`dotnet.exe` or the app's executable) and they're used to compute the list of dependencies needed to run the application. This happens at startup and through this mechanism all static dependencies of the app are resolved.

Currently there's no such mechanism for components which are loaded dynamically. Applications can use [`Microsoft.Extensions.DependencyModel`](https://github.com/dotnet/core-setup/tree/master/src/managed/Microsoft.Extensions.DependencyModel) package which provides object model of the `.deps.json` file, but it's relatively complex to use this for dependency resolution. It's also very likely that the behavior of such custom solution would be somewhat different from what the hosting layer does for static dependencies.

### Open issues

* **Naming** - The use of `Component` in the class name was chosen to differentiate from `Assembly` as the proposed API will only work on entire components produced by the SDK. Using `Assembly` seems to mean that the API would inspect the assembly itself to determine its dependencies, which is not the purpose of this API. That said it could be either. Also using the term `Resolver` can be seen as somewhat misleading. *Resolve* in the context of assembly binding typically means to find and actually load the dependency. The purpose of this API is to simply find the file, not to load it. So maybe it should be more explicit by using for example `PathResolver`. Candidates then could be `AssemblyDepednencyResolver`, `AssemblyDependencyPathResolver`, `ComponentDependencyPathResolver`.

### Notes

* As proposed the resolver would not resolve framework dependencies. For the typical case of dynamically loaded component, resolving framework dependencies would actually just introduce more issues and probably provide unwanted behavior. This is something we would look into in the future, as it's an important scenario for the `MetadataLoadContext`.
* The resolver has no ties to the runtime. This means that the dependencies are resolved to file paths without any consideration to what assemblies are already loaded into the application. This is important for scenarios where full isolation is required. For partial or no isolation scenarios it is expected that the loading of the dependencies will be combined with the appropriate fallback to the default load context.","Add API for resolving component dependencies  This is a proposal to add new public API which would expose functionality to help with resolution of managed and unmanaged dependencies of components.

### Proposed Surface Area
``` C#
namespace System.Run",34484,jkoritzinsky,corefx
21896,[release/2.0] Disable StartInfo_TextFile_ShellExecute on Win8 (#21397),"Port disabling ShellExecute test for Win8.

Porting PR #21397","[release/2.0] Disable StartInfo_TextFile_ShellExecute on Win8 (#21397)  Port disabling ShellExecute test for Win8.

Porting PR #21397",34484,jkoritzinsky,corefx
17587,[Ping] Unix - System.Net.Ping ignores PingOptions,"[Relevant code](https://github.com/dotnet/corefx/blob/master/src/System.Net.Ping/src/System/Net/NetworkInformation/Ping.Unix.cs#L59)

Ignoring DontFragment or TTL produces different behaviour between linux and windows builds when implementing a simple ICMP trace.

Is this the intended/by-design behaviour? Wouldn't a NotImplementedException if PingOptions are given/non default be a nicer signal to the developer?","[Ping] Unix - System.Net.Ping ignores PingOptions  [Relevant code](https://github.com/dotnet/corefx/blob/master/src/System.Net.Ping/src/System/Net/NetworkInformation/Ping.Unix.cs#L59)

Ignoring DontFragment or TTL produces different behaviour between li",34435,wfurt,corefx
30324,add option to handle Ping TTL for raw socket and system utility,"related to #9350 

This adds TTL option to Unix Ping implementation. It handles both - raw socket as well as system command line utility. I did some testing and -t seems pretty standard even on busybox on Alpine. 

Don't fragment will need some more research and testing.  It is less common (like busybox does not have it). Also PMTU discovery is default now on Linux so ""don't fragment is set by default"". 

I tested the fix running tests as normal user and root. All existing tests are passing. 
To really test this, we would need Outerloop test with some predictable and stable target.","add option to handle Ping TTL for raw socket and system utility  related to #9350 

This adds TTL option to Unix Ping implementation. It handles both - raw socket as well as system command line utility. I did some testing and -t seems pretty standard ev",34435,wfurt,corefx
28251,Improve XML testing and fuzzing.,"This is an offshoot from issue dotnet/runtime#28217 and PR dotnet/corefx#34116

- [x]  Consider bringing *.cxx code generation templates up to date: (per https://github.com/dotnet/corefx/pull/34116#issuecomment-449081565, PR dotnet/corefx#34224)
   * src/System.Private.Xml/src/System/Xml/Core/HtmlRawTextWriterGenerator.cxx
   * src/System.Private.Xml/src/System/Xml/Core/TextRawTextWriterGenerator.cxx
   * src/System.Private.Xml/src/System/Xml/Core/XmlRawTextWriterGenerator.cxx
- [x]  ~~Consider rewriting to use programmatic abstractions instead of precompiler code generation.~~ (PR dotnet/corefx#34280)
- [ ]  Break code into means that allows better access from inside of tests. (per https://github.com/dotnet/corefx/pull/34116#issuecomment-449081565)
- [ ]  Improve test coverage https://ci.dot.net/job/dotnet_corefx/job/master/job/code_coverage_windows/Code_Coverage_Report/ (per https://github.com/dotnet/corefx/pull/34116#issuecomment-447678538)
- [ ]  Introduce mechanism to add testing with guarded memory to detect OoB reads. (per https://github.com/dotnet/corefx/pull/34116#issuecomment-449084357)","Improve XML testing and fuzzing.  This is an offshoot from issue dotnet/runtime#28217 and PR dotnet/corefx#34116

- [x]  Consider bringing *.cxx code generation templates up to date: (per https://github.com/dotnet/corefx/pull/34116#issuecomment-44908156",34224,jlennox,corefx
24617,Expand Process.Kill to Optionally Kill a Process Tree,"## Issue
.Net Standard does not provide a means to kill a process tree (that is, a given process and all of its child/descendant processes). 

In the Windows world, this can be done by assembling the list of descendant processes to terminate using [WMI's Win32_Process management object](https://stackoverflow.com/a/7189381/117424), [performance counters](https://stackoverflow.com/a/2336322/117424) or [P/Invoke](https://stackoverflow.com/a/3346055/117424), then killing each one, then killing the parent/root process. However, since .Net Standard doesn't provide a way to enumerate child/descendant processes, it's impossible for a user to directly implement this approach in a cross-platform way using only .Net Standard.

If the ability to enumerate child processes were added (as dotnet/runtime#24423 proposes), there'd still be complexities involved with using the child process list to kill a process tree as care is needed to ensure that unrelated processes aren't inadvertently terminated because of process ID reuse. This proposal saves the developer from needing to worry about such complexities and instead provides a simple, one-line way to terminate a process tree.

## Rationale
Sometimes, it's necessary to end a process tree. :-)

For example, [`Microsoft.DotNet.Tools.Test.Utilities.ProcessExtension`](https://github.com/dotnet/cli/blob/35e661bbb3b2f0943590cb63747ae53a68e6eb5d/test/Microsoft.DotNet.Tools.Tests.Utilities/Extensions/ProcessExtensions.cs#L27) relies on different code paths to handle killing a process tree on Windows and Linux. Both code paths involve invoking one or more command-line processes. If this proposal were implemented, presumably this logic could be replaced with a single-line kill all method call followed possibly by a call to [`WaithForExit(int milliseconds)`](https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.process.waitforexit?view=netstandard-2.0#System_Diagnostics_Process_WaitForExit_System_Int32_). No multiple code paths. No need to invoke command-line processes.

Another example: A project I'm currently working on uses integration tests that use [`Process`](https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.process?view=netstandard-2.0) to call `dotnet run` to start a server process. When the test has completed, it's possible to use Process's `Kill()` to end the parent dotnet process. However, this leaves child processes still running—which causes problems.

## Proposal

Extend `Process` as follows:

**Original (ignore—left for reference purposes):**
```c#
    public class Process : ....    {
        public void Kill(bool entireProcessTree = false); // false = existing behavior of Kill()
    }
```
**Revision (ignore—left for reference purposes):**
```c#
    public enum ProcessGroup { 
            CurrentProcess, 
            EntireTree 
    }

    public class Process : ....    {
        public void Kill(ProcessGroup group = ProcessGroup.CurrentProcess) { } // default = existing behavior of Kill()
    }
```

**Approved Version:**
```
    public class Process : ....    {
        public void Kill(bool entireProcessTree); 
    }
```


With this change, `Kill` will behave exactly as it does at current if it is called with no arguments or with `false` as its argument. However, when called with `true` as its argument, in a platform-appropriate way all descendant processes will be killed, followed by the process represented by the current `Process` instance.  

[edited by @danmosemsft to add c# formatting only]","Expand Process.Kill to Optionally Kill a Process Tree  ## Issue
.Net Standard does not provide a means to kill a process tree (that is, a given process and all of its child/descendant processes). 

In the Windows world, this can be done by assembling t",34147,bgribaudo,corefx
24423,Expose Parent/Child Process Information via System.Diagnostics.Process,"## Issue
.Net Standard does not seem to provide a means to identify the parent or child processes of a given process. 

In the Windows world, this information can be obtained or extrapolated using [WMI's Win32_Process management object](https://stackoverflow.com/a/7189381/117424), [performance counters](https://stackoverflow.com/a/2336322/117424) or [P/Invoke](https://stackoverflow.com/a/3346055/117424). 

However, there doesn't seem to be a cross-platform .Net Standard way to do this. (If there is, please let me know! :-))

## Rationale
The ability to determine which processes are children (or grandchildren or great-grandchildren, etc.) of a process is needed in order to be able to kill a process tree without using platform-specific code.

For example, [`Microsoft.DotNet.Tools.Test.Utilities.ProcessExtension`](https://github.com/dotnet/cli/blob/master/test/Microsoft.DotNet.Tools.Tests.Utilities/Extensions/ProcessExtensions.cs) relies on different code paths to handle killing a process tree on Windows and Linux. Both code paths involve invoking one or more command-line processes. If this proposal were implemented, this logic could potentially be replaced with OS-agnostic .Net Standard code that iterates through the process's children, calls [Kill](https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.process.kill?view=netstandard-2.0) on each of them, then calls Kill on the parent. No multiple code paths. No need to invoke command-line processes.

For completeness, it would be nice to have the ability to navigate both up (parent process) and down (child processes) the process tree.

## Proposal

    public partial class Process : ....    {
        public int GetParentProcessId() { ... } // returns parent process Id currently associated with this process
        public Process GetParentProcess() { … } // returns parent process currently associated with this process
        public Process[] GetChildProcesses(bool includeAllDescendants = false) { ... } // setting the parameter to true results in grandchildren, great-grandchildren, etc., being included in the results; otherwise, only direct children are returned
    }

At first glance, it might seem more appropriate to make the first two methods properties (e.g. `public int ParentProcessId { get { ... }}`). However, a process's parent can change. The API design guidelines suggest preferring a method over a property when ""calling the member twice in succession results in different results.""","Expose Parent/Child Process Information via System.Diagnostics.Process  ## Issue
.Net Standard does not seem to provide a means to identify the parent or child processes of a given process. 

In the Windows world, this information can be obtained or ex",34147,bgribaudo,corefx
31827,Adding Kill(bool entireProcessTree) -- best-effort attempt to terminate a process tree,"[Implements API approved by #26234]

## Summary
When `Kill(bool entireProcessTree)`'s argument is false, behaves identical to `Kill()`; when true, makes a best-effort attempt to terminate the current process and all descendant processes (children, grandchildren, etc.).

## Platform Implementation Status
Implemented for Windows and Linux; not implemented for UAP, UnknownUnix or FreeBSD/OSX. 

Looks easy to implement for OSX (comment added in Process.OSX.cs with implementation idea), just don't have an OSX system to test against.

## Notes
Potential low-hanging fruit: Behind-the-scenes, the logic in this PR enumerates child processes. This functionality could be leveraged to easily implement #25855. 

Windows-specific logic inspired by [msbuild's NativeMethodsShared KillTree](https://github.com/Microsoft/msbuild/blob/0591c15d6c638cad38091fbe625dde968f86748d/src/Shared/NativeMethodsShared.cs#L1068).","Adding Kill(bool entireProcessTree) -- best-effort attempt to terminate a process tree  [Implements API approved by #26234]

## Summary
When `Kill(bool entireProcessTree)`'s argument is false, behaves identical to `Kill()`; when true, makes a best-effo",34147,bgribaudo,corefx
28184,HTTP2: Respect SETTINGS_INITIAL_WINDOW_SIZE setting from peer,Separating this from dotnet/runtime#26920 since it requires some additional implementation and refactoring to support properly.,HTTP2: Respect SETTINGS_INITIAL_WINDOW_SIZE setting from peer  Separating this from dotnet/runtime#26920 since it requires some additional implementation and refactoring to support properly.,34131,geoffkizer,corefx
26919,HTTP2: Handle SETTINGS_MAX_CONCURRENT_STREAMS from server,"Per RFC, this setting:

> Indicates the maximum number
      of concurrent streams that the sender will allow.

When this is set, we need to add a semaphore or equivalent to throttle the number of active streams. Note that it can change at any time and we need to handle this as well.","HTTP2: Handle SETTINGS_MAX_CONCURRENT_STREAMS from server  Per RFC, this setting:

> Indicates the maximum number
      of concurrent streams that the sender will allow.

When this is set, we need to add a semaphore or equivalent to throttle the numb",34131,geoffkizer,corefx
27032,HTTP2: Receiving a frame on a closed stream should not close the connection,"According to the spec, any (non-priority) frame received after a RST_STREAM frame should be treated as a (recoverable) _stream_ error:
```
An endpoint MUST NOT send frames other than PRIORITY on a closed stream. An endpoint that 
receives any frame other than PRIORITY after receiving a RST_STREAM MUST treat that as a
stream error (Section 5.4.2) of type STREAM_CLOSED.
```
The current implementation treats this error as a _connection_ error, and closes the underlying socket. For reliability reasons we should consider this error recoverable, and allow the other streams on the connection to continue.","HTTP2: Receiving a frame on a closed stream should not close the connection  According to the spec, any (non-priority) frame received after a RST_STREAM frame should be treated as a (recoverable) _stream_ error:
```
An endpoint MUST NOT send frames othe",34131,geoffkizer,corefx
27161,[HTTP2] loopback server is not sending valid RstStreamFrame(),"[The tests](https://github.com/dotnet/corefx/blob/66649ff5862c7b723fded40c505942de19bdb107/src/System.Net.Http/tests/FunctionalTests/SocketsHttpHandlerTest.Http2.cs) related to sending RST_FRAME seem not right: 

1. When do `new RstStreamFrame()`, the `frameHeader.Length` will set to 13 -> `Frame.FrameHeaderLength + 4`: https://github.com/dotnet/corefx/blob/66649ff5862c7b723fded40c505942de19bdb107/src/Common/tests/System/Net/Http/Http2Frames.cs#L244
2. SocketsHttpHandler is expecting `RstStreamLength` is 4: https://github.com/dotnet/corefx/blob/eedddac1bd10a7c8629a9db7f46fc8afc7385d63/src/System.Net.Http/src/System/Net/Http/SocketsHttpHandler/Http2Connection.cs#L441

Therefore, `Http2ProtocolException(Http2ProtocolErrorCode.FrameSizeError)` will always be thrown. We are actually testing the case for invalid RST_FRAME, not testing RST_FRAME functionality.",[HTTP2] loopback server is not sending valid RstStreamFrame()  [The tests](https://github.com/dotnet/corefx/blob/66649ff5862c7b723fded40c505942de19bdb107/src/System.Net.Http/tests/FunctionalTests/SocketsHttpHandlerTest.Http2.cs) related to sending RST_FRA,34131,geoffkizer,corefx
27162,[HTTP2] loopback server is not correctly reading RstStreamFrame,"This issue may related to general loopback server frame reading. (I have only verified RstStreamFrame case)

When HTTP/2 loopback server is sending a malformed frame to SocketsHttpHandler, so that SocketsHttpHandler will send back a RstStreamFrame, the loopback server side is not correctly reading the RstStreamFrame:

```
System.IndexOutOfRangeException : Index was outside the bounds of the array.
        Stack Trace:
           E:\A\_work\104\s\src\System.Private.CoreLib\shared\System\ReadOnlySpan.Fast.cs(145,0): at System.ReadOnlySpan`1.get_Item(Int32 index)
           D:\corefx\src\Common\tests\System\Net\Http\Http2Frames.cs(252,0): at System.Net.Test.Common.RstStreamFrame.ReadFrom(Frame header, ReadOnlySpan`1 buffer)
           D:\corefx\src\Common\tests\System\Net\Http\Http2LoopbackServer.cs(124,0): at System.Net.Test.Common.Http2LoopbackServer.ReadFrameAsync(TimeSpan timeout)
           // This line is not important, my new test D:\corefx\src\System.Net.Http\tests\FunctionalTests\SocketsHttpHandlerTest.Http2.cs(208,0): at System.Net.Http.Functional.Tests.SocketsHttpHandler_HttpClientHan
  dler_Http2_Test.DataFrame_PaddingOnly_ResetsStream()
           --- End of stack trace from previous location where exception was thrown ---
```","[HTTP2] loopback server is not correctly reading RstStreamFrame  This issue may related to general loopback server frame reading. (I have only verified RstStreamFrame case)

When HTTP/2 loopback server is sending a malformed frame to SocketsHttpHandler,",34131,geoffkizer,corefx
28035,Properly factor DllImports into Common\src\Interop,"We now have a bunch of libraries with their own DllImports, whereas the expected approach is that all DllImports in product src should be included from src\Common\src\Interop, appropriately factored by platform and library, and then those source files included into the relevant assemblies that need them.

- [ ] Microsoft.Diagnostics.Tracing.EventSource.Redist
- [ ] System.Data.SqlClient
- [x] System.Diagnostics.EventLog
- [ ] System.DirectoryServices
- [ ] System.DirectoryServices.AccountManagement
- [ ] System.DirectoryServices.Protocols
- [ ] System.Drawing.Common
- [x] System.IO.Compression
- [ ] System.IO.Compression.Brotli
- [ ] System.IO.Ports
- [x] System.Management
- [ ] System.Reflection.Metadata
- [x] System.Runtime.Caching
- [x] System.Security.Cryptography.Csp
- [x] System.Security.Cryptography.Pkcs
- [ ] System.Security.Cryptography.X509Certificates

This all needs to be refactored and dedup'd.

https://github.com/dotnet/corefx/blob/master/Documentation/coding-guidelines/interop-guidelines.md","Properly factor DllImports into Common\src\Interop  We now have a bunch of libraries with their own DllImports, whereas the expected approach is that all DllImports in product src should be included from src\Common\src\Interop, appropriately factored by p",34129,Marusyk,corefx
33988,System.Security.Cryptography.Csp. Refactor DllImports,"Issue #33774

I'm not sure about some enums. Please suggest. 

Please review","System.Security.Cryptography.Csp. Refactor DllImports  Issue #33774

I'm not sure about some enums. Please suggest. 

Please review",34129,Marusyk,corefx
26918,HTTP2: Disable PUSH_PROMISE on connection creation,"We don't plan to support server push in the current release. 

As part of the initial SETTINGS frame, we should set SETTINGS_ENABLE_PUSH to 0 (false).","HTTP2: Disable PUSH_PROMISE on connection creation  We don't plan to support server push in the current release. 

As part of the initial SETTINGS frame, we should set SETTINGS_ENABLE_PUSH to 0 (false).",34090,geoffkizer,corefx
27112,HTTP2: Consider setting SETTINGS_HEADER_TABLE_SIZE to 0,"We should consider disabling the dynamic header table entirely by setting SETTINGS_HEADER_TABLE_SIZE to 0 in our initial settings frame to the server. This would simplify our HPACK implementation.

It's not clear how common it is for servers to actually use this table. I suspect it's not particularly common today. We can always reconsider implementing this later.","HTTP2: Consider setting SETTINGS_HEADER_TABLE_SIZE to 0  We should consider disabling the dynamic header table entirely by setting SETTINGS_HEADER_TABLE_SIZE to 0 in our initial settings frame to the server. This would simplify our HPACK implementation.",34090,geoffkizer,corefx
26972,HTTP2: Assert failures when disallowed frame types are sent on stream 0,"The HTTP/2 spec explicitly forbids data frames to be sent on stream 0. From [section 6.1](https://tools.ietf.org/html/rfc7540#section-6.1) of the spec:
```
DATA frames MUST be associated with a stream.  If a DATA frame is
   received whose stream identifier field is 0x0, the recipient MUST
   respond with a connection error (Section 5.4.1) of type
   PROTOCOL_ERROR.
``` 

The current HTTP/2 implementation does not respond with PROTOCOL_ERROR when a data frame is sent on stream 0, and instead fails an assert in HttpConnectionPool.cs without sending a response:
https://github.com/dotnet/corefx/blob/f391820c4808bcb02c7b3dd88b684f36a0a98b6a/src/System.Net.Http/src/System/Net/Http/SocketsHttpHandler/HttpConnectionPool.cs#L861-L865

<details>
<summary>Full stack trace of the assert:</summary>

     Assertion Failed
     at System.Net.Http.HttpConnectionPool.InvalidateHttp2Connection(Http2Connection connection) in C:\corefx\src\System.Net.Http\src\System\Net\Http\SocketsHttpHandler\HttpConnectionPool.cs:line 863
     at System.Net.Http.Http2Connection.AbortStreams(Int32 lastValidStream) in C:\corefx\src\System.Net.Http\src\System\Net\Http\SocketsHttpHandler\Http2Connection.cs:line 503
     at System.Net.Http.Http2Connection.ProcessIncomingFrames() in C:\corefx\src\System.Net.Http\src\System\Net\Http\SocketsHttpHandler\Http2Connection.cs:line 155
     at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[TStateMachine](TStateMachine& stateMachine) in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Runtime\CompilerServices\AsyncMethodBuilder.cs:line 930
     at System.Net.Http.Http2Connection.ProcessIncomingFrames()
     at System.Net.Http.Http2Connection.SetupAsync() in C:\corefx\src\System.Net.Http\src\System\Net\Http\SocketsHttpHandler\Http2Connection.cs:line 98
     at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state) in E:\A\_work\41\s\src\System.Private.CoreLib\shared\System\Threading\ExecutionContext.cs:line 166
     at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.AsyncStateMachineBox`1.MoveNext() in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Runtime\CompilerServices\AsyncMethodBuilder.cs:line 559
     at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(IAsyncStateMachineBox box, Boolean allowInlining) in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Threading\Tasks\TaskContinuation.cs:line 798
     at System.Threading.Tasks.Task.RunContinuations(Object continuationObject) in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Threading\Tasks\Task.cs:line 3272
     at System.Threading.Tasks.Task`1.TrySetResult(TResult result) in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Threading\Tasks\future.cs:line 421
     at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetExistingTaskResult(TResult result) in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Runtime\CompilerServices\AsyncMethodBuilder.cs:line 639
     at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetResult(TResult result) in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Runtime\CompilerServices\AsyncMethodBuilder.cs:line 629
     at System.Net.Http.Http2Connection.ReadFrameAsync() in C:\corefx\src\System.Net.Http\src\System\Net\Http\SocketsHttpHandler\Http2Connection.cs:line 138
     at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state) in E:\A\_work\41\s\src\System.Private.CoreLib\shared\System\Threading\ExecutionContext.cs:line 166
     at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.AsyncStateMachineBox`1.MoveNext() in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Runtime\CompilerServices\AsyncMethodBuilder.cs:line 559
     at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(IAsyncStateMachineBox box, Boolean allowInlining) in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Threading\Tasks\TaskContinuation.cs:line 798
     at System.Threading.Tasks.Task.RunContinuations(Object continuationObject) in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Threading\Tasks\Task.cs:line 3272
     at System.Threading.Tasks.Task`1.TrySetResult(TResult result) in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Threading\Tasks\future.cs:line 421
     at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetExistingTaskResult(TResult result) in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Runtime\CompilerServices\AsyncMethodBuilder.cs:line 639
     at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.SetResult() in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Runtime\CompilerServices\AsyncMethodBuilder.cs:line 254
     at System.Net.Http.Http2Connection.EnsureIncomingBytesAsync(Int32 minReadBytes) in C:\corefx\src\System.Net.Http\src\System\Net\Http\SocketsHttpHandler\Http2Connection.cs:line 112
     at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state) in E:\A\_work\41\s\src\System.Private.CoreLib\shared\System\Threading\ExecutionContext.cs:line 166
     at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.AsyncStateMachineBox`1.MoveNext() in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Runtime\CompilerServices\AsyncMethodBuilder.cs:line 559
     at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(IAsyncStateMachineBox box, Boolean allowInlining) in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Threading\Tasks\TaskContinuation.cs:line 798
     at System.Threading.Tasks.Task.RunContinuations(Object continuationObject) in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Threading\Tasks\Task.cs:line 3272
     at System.Threading.Tasks.Task`1.TrySetResult(TResult result) in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Threading\Tasks\future.cs:line 421
     at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetExistingTaskResult(TResult result) in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Runtime\CompilerServices\AsyncMethodBuilder.cs:line 639
     at System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1.SetResult(TResult result) in E:\A\_work\41\s\src\System.Private.CoreLib\shared\System\Runtime\CompilerServices\AsyncValueTaskMethodBuilder.cs:line 169
     at System.Net.Http.Http2Connection.ReadAtLeastAsync(Stream stream, Memory`1 buffer, Int32 minReadBytes) in C:\corefx\src\System.Net.Http\src\System\Net\Http\SocketsHttpHandler\Http2Connection.cs:line 1278
     at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state) in E:\A\_work\41\s\src\System.Private.CoreLib\shared\System\Threading\ExecutionContext.cs:line 166
     at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.AsyncStateMachineBox`1.MoveNext() in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Runtime\CompilerServices\AsyncMethodBuilder.cs:line 559
     at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(IAsyncStateMachineBox box, Boolean allowInlining) in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Threading\Tasks\TaskContinuation.cs:line 798
     at System.Threading.Tasks.Task.RunContinuations(Object continuationObject) in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Threading\Tasks\Task.cs:line 3272
     at System.Threading.Tasks.Task`1.TrySetResult(TResult result) in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Threading\Tasks\future.cs:line 421
     at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetExistingTaskResult(TResult result) in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Runtime\CompilerServices\AsyncMethodBuilder.cs:line 639
     at System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1.SetResult(TResult result) in E:\A\_work\41\s\src\System.Private.CoreLib\shared\System\Runtime\CompilerServices\AsyncValueTaskMethodBuilder.cs:line 169
     at System.Net.Security.SslStreamInternal.ReadAsyncInternal[TReadAdapter](TReadAdapter adapter, Memory`1 buffer) in C:\corefx\src\System.Net.Security\src\System\Net\Security\SslStreamInternal.cs:line 338
     at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state) in E:\A\_work\41\s\src\System.Private.CoreLib\shared\System\Threading\ExecutionContext.cs:line 166
     at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.AsyncStateMachineBox`1.MoveNext() in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Runtime\CompilerServices\AsyncMethodBuilder.cs:line 559
     at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(IAsyncStateMachineBox box, Boolean allowInlining) in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Threading\Tasks\TaskContinuation.cs:line 798
     at System.Threading.Tasks.Task.RunContinuations(Object continuationObject) in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Threading\Tasks\Task.cs:line 3272
     at System.Threading.Tasks.Task`1.TrySetResult(TResult result) in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Threading\Tasks\future.cs:line 421
     at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetExistingTaskResult(TResult result) in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Runtime\CompilerServices\AsyncMethodBuilder.cs:line 639
     at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetResult(TResult result) in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Runtime\CompilerServices\AsyncMethodBuilder.cs:line 629
     at System.Net.Security.SslStreamInternal.<FillBufferAsync>g__InternalFillBufferAsync|38_0[TReadAdapter](TReadAdapter adap, ValueTask`1 task, Int32 min, Int32 initial) in C:\corefx\src\System.Net.Security\src\System\Net\Security\SslStreamInternal.cs:line 515
     at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state) in E:\A\_work\41\s\src\System.Private.CoreLib\shared\System\Threading\ExecutionContext.cs:line 166
     at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.AsyncStateMachineBox`1.MoveNext() in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Runtime\CompilerServices\AsyncMethodBuilder.cs:line 559
     at System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.InvokeContinuation(Action`1 continuation, Object state, Boolean forceAsync) in C:\corefx\src\System.Net.Sockets\src\System\Net\Sockets\Socket.Tasks.cs:line 1038
     at System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.OnCompleted(SocketAsyncEventArgs _) in C:\corefx\src\System.Net.Sockets\src\System\Net\Sockets\Socket.Tasks.cs:line 869
     at System.Net.Sockets.SocketAsyncEventArgs.FinishOperationAsyncSuccess(Int32 bytesTransferred, SocketFlags flags) in C:\corefx\src\System.Net.Sockets\src\System\Net\Sockets\SocketAsyncEventArgs.cs:line 770
     at System.Net.Sockets.SocketAsyncEventArgs.<>c.<.cctor>b__174_0(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* nativeOverlapped) in C:\corefx\src\System.Net.Sockets\src\System\Net\Sockets\SocketAsyncEventArgs.Windows.cs:line 1195
     at System.Threading._IOCompletionCallback.PerformIOCompletionCallback(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* pNativeOverlapped) in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Threading\Overlapped.cs:line 65
</details>


cc: @geoffkizer","HTTP2: Assert failures when disallowed frame types are sent on stream 0  The HTTP/2 spec explicitly forbids data frames to be sent on stream 0. From [section 6.1](https://tools.ietf.org/html/rfc7540#section-6.1) of the spec:
```
DATA frames MUST be asso",34090,geoffkizer,corefx
27036,HTTP2: Assert failure when data frames are larger than the maximum allowed size,"When SocketsHttpHandler receives a frame that is larger than the SETTINGS_MAX_FRAME_SIZE (default is 16,384 octets), it should cause the connection to fail with a protocol error:
```
SETTINGS_MAX_FRAME_SIZE (0x5):
Indicates the size of the largest frame payload that the sender is willing to receive, in octets.

The initial value is 214 (16,384) octets. The value advertised by an endpoint MUST be between 
this initial value and the maximum allowed frame size (224-1 or 16,777,215 octets), inclusive. 
Values outside this range MUST be treated as a connection error (Section 5.4.1) of type 
PROTOCOL_ERROR.
```

Instead, the current implementation fails an assert in the FrameHeader constructor.
<details>
<summary>Full stack trace of the assert:</summary>
```
  Assertion Failed

     at System.Net.Http.Http2Connection.FrameHeader..ctor(Int32 length, FrameType type, FrameFlags flags, Int32 streamId) in C:\corefx\src\System.Net.Http\src\System\Net\Http\SocketsHttpHandler\Http2Connection.cs:line 602
     at System.Net.Http.Http2Connection.FrameHeader.ReadFrom(ReadOnlySpan`1 buffer) in C:\corefx\src\System.Net.Http\src\System\Net\Http\SocketsHttpHandler\Http2Connection.cs:line 621
     at System.Net.Http.Http2Connection.ReadFrameAsync() in C:\corefx\src\System.Net.Http\src\System\Net\Http\SocketsHttpHandler\Http2Connection.cs:line 126
     at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state) in E:\A\_work\41\s\src\System.Private.CoreLib\shared\System\Threading\ExecutionContext.cs:line 166
     at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.AsyncStateMachineBox`1.MoveNext() in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Runtime\CompilerServices\AsyncMethodBuilder.cs:line 559
     at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(IAsyncStateMachineBox box, Boolean allowInlining) in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Threading\Tasks\TaskContinuation.cs:line 798
     at System.Threading.Tasks.Task.RunContinuations(Object continuationObject) in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Threading\Tasks\Task.cs:line 3272
     at System.Threading.Tasks.Task`1.TrySetResult(TResult result) in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Threading\Tasks\future.cs:line 421
     at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetExistingTaskResult(TResult result) in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Runtime\CompilerServices\AsyncMethodBuilder.cs:line 639
     at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.SetResult() in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Runtime\CompilerServices\AsyncMethodBuilder.cs:line 254
     at System.Net.Http.Http2Connection.EnsureIncomingBytesAsync(Int32 minReadBytes) in C:\corefx\src\System.Net.Http\src\System\Net\Http\SocketsHttpHandler\Http2Connection.cs:line 112
     at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state) in E:\A\_work\41\s\src\System.Private.CoreLib\shared\System\Threading\ExecutionContext.cs:line 166
     at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.AsyncStateMachineBox`1.MoveNext() in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Runtime\CompilerServices\AsyncMethodBuilder.cs:line 559
     at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(IAsyncStateMachineBox box, Boolean allowInlining) in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Threading\Tasks\TaskContinuation.cs:line 798
     at System.Threading.Tasks.Task.RunContinuations(Object continuationObject) in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Threading\Tasks\Task.cs:line 3272
     at System.Threading.Tasks.Task`1.TrySetResult(TResult result) in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Threading\Tasks\future.cs:line 421
     at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetExistingTaskResult(TResult result) in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Runtime\CompilerServices\AsyncMethodBuilder.cs:line 639
     at System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1.SetResult(TResult result) in E:\A\_work\41\s\src\System.Private.CoreLib\shared\System\Runtime\CompilerServices\AsyncValueTaskMethodBuilder.cs:line 169
     at System.Net.Http.Http2Connection.ReadAtLeastAsync(Stream stream, Memory`1 buffer, Int32 minReadBytes) in C:\corefx\src\System.Net.Http\src\System\Net\Http\SocketsHttpHandler\Http2Connection.cs:line 1278
     at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state) in E:\A\_work\41\s\src\System.Private.CoreLib\shared\System\Threading\ExecutionContext.cs:line 166
     at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.AsyncStateMachineBox`1.MoveNext() in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Runtime\CompilerServices\AsyncMethodBuilder.cs:line 559
     at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(IAsyncStateMachineBox box, Boolean allowInlining) in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Threading\Tasks\TaskContinuation.cs:line 798
     at System.Threading.Tasks.Task.RunContinuations(Object continuationObject) in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Threading\Tasks\Task.cs:line 3272
     at System.Threading.Tasks.Task`1.TrySetResult(TResult result) in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Threading\Tasks\future.cs:line 421
     at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetExistingTaskResult(TResult result) in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Runtime\CompilerServices\AsyncMethodBuilder.cs:line 639
     at System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1.SetResult(TResult result) in E:\A\_work\41\s\src\System.Private.CoreLib\shared\System\Runtime\CompilerServices\AsyncValueTaskMethodBuilder.cs:line 169
     at System.Net.Security.SslStreamInternal.ReadAsyncInternal[TReadAdapter](TReadAdapter adapter, Memory`1 buffer) in C:\corefx\src\System.Net.Security\src\System\Net\Security\SslStreamInternal.cs:line 338
     at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state) in E:\A\_work\41\s\src\System.Private.CoreLib\shared\System\Threading\ExecutionContext.cs:line 166
     at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.AsyncStateMachineBox`1.MoveNext() in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Runtime\CompilerServices\AsyncMethodBuilder.cs:line 559
     at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(IAsyncStateMachineBox box, Boolean allowInlining) in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Threading\Tasks\TaskContinuation.cs:line 798
     at System.Threading.Tasks.Task.RunContinuations(Object continuationObject) in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Threading\Tasks\Task.cs:line 3272
     at System.Threading.Tasks.Task`1.TrySetResult(TResult result) in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Threading\Tasks\future.cs:line 421
     at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetExistingTaskResult(TResult result) in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Runtime\CompilerServices\AsyncMethodBuilder.cs:line 639
     at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetResult(TResult result) in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Runtime\CompilerServices\AsyncMethodBuilder.cs:line 629
     at System.Net.Security.SslStreamInternal.<FillBufferAsync>g__InternalFillBufferAsync|38_0[TReadAdapter](TReadAdapter adap, ValueTask`1 task, Int32 min, Int32 initial) in C:\corefx\src\System.Net.Security\src\System\Net\Security\SslStreamInternal.cs:line 515
     at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state) in E:\A\_work\41\s\src\System.Private.CoreLib\shared\System\Threading\ExecutionContext.cs:line 166
     at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.AsyncStateMachineBox`1.MoveNext() in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Runtime\CompilerServices\AsyncMethodBuilder.cs:line 559
     at System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.InvokeContinuation(Action`1 continuation, Object state, Boolean forceAsync) in C:\corefx\src\System.Net.Sockets\src\System\Net\Sockets\Socket.Tasks.cs:line 1038
     at System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.OnCompleted(SocketAsyncEventArgs _) in C:\corefx\src\System.Net.Sockets\src\System\Net\Sockets\Socket.Tasks.cs:line 869
     at System.Net.Sockets.SocketAsyncEventArgs.FinishOperationAsyncSuccess(Int32 bytesTransferred, SocketFlags flags) in C:\corefx\src\System.Net.Sockets\src\System\Net\Sockets\SocketAsyncEventArgs.cs:line 770
     at System.Net.Sockets.SocketAsyncEventArgs.<>c.<.cctor>b__174_0(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* nativeOverlapped) in C:\corefx\src\System.Net.Sockets\src\System\Net\Sockets\SocketAsyncEventArgs.Windows.cs:line 1195
     at System.Threading._IOCompletionCallback.PerformIOCompletionCallback(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* pNativeOverlapped) in E:\A\_work\41\s\src\System.Private.CoreLib\src\System\Threading\Overlapped.cs:line 65
``` 
</details>","HTTP2: Assert failure when data frames are larger than the maximum allowed size  When SocketsHttpHandler receives a frame that is larger than the SETTINGS_MAX_FRAME_SIZE (default is 16,384 octets), it should cause the connection to fail with a protocol er",34090,geoffkizer,corefx
27031,"Api Proposal: File.Move(string,string, bool) overload","The proposal is to add the following member:
```cs
class File {
       public static void Move(string sourceFileName, string destFileName, bool overwrite);
}
```
The reason is to solve a current frustration, that when calling the `File.Move(string, string)` method, an exception is thrown if the file exists. E.g. You have to check if the file exists before overriding it.

On windows, `File.Move` internally uses [`Kernel32.MoveFileExW()`](https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-movefileexw) function  which has a flag that can be passed `MOVEFILE_REPLACE_EXISTING` to allow you to override an existing file. Currently, the only flag passed is `MOVEFILE_COPY_ALLOWED`

As an alternative, a developer could use the the following helper method.
```cs
public static void MoveOrOverride(string sourceFileName, string destFileName)
{
     if (File.Exists(destFileName))
     {
          File.Delete(destFileName);
     }

     File.Move(sourceFileName, destFileName);
}
```
But this is slower, and could still fail if run in a multi-threaded environment where more than one thread is trying to write to this destination file location.

Inexplicably this API is available through the visual basic helper apis. The equivalent of `File.Move` the function `Microsoft.VisualBasic.FileIO.FileSystem.MoveFile` has an override flag.","Api Proposal: File.Move(string,string, bool) overload  The proposal is to add the following member:
```cs
class File {
       public static void Move(string sourceFileName, string destFileName, bool overwrite);
}
```
The reason is to solve a current",33054,jbhensley,corefx
33078,Modify call to MoveFileExW to use MOVEFILE_WRITE_THROUGH,"See conversation on PR #33054. The only diff between that PR and this one is this one changes:

```C#
uint flags = MOVEFILE_COPY_ALLOWED;
```

to

```C#
uint flags = MOVEFILE_WRITE_THROUGH | MOVEFILE_COPY_ALLOWED;
```","Modify call to MoveFileExW to use MOVEFILE_WRITE_THROUGH  See conversation on PR #33054. The only diff between that PR and this one is this one changes:

```C#
uint flags = MOVEFILE_COPY_ALLOWED;
```

to

```C#
uint flags = MOVEFILE_WRITE_THROUGH",33054,jbhensley,corefx
21253,"Desktop: System.Security.Cryptography.Cng.Tests.ECDsaCngTests.TestVerify521_EcdhKey failed with ""System.ArgumentException""","Failed test: System.Security.Cryptography.Cng.Tests.ECDsaCngTests.TestVerify521_EcdhKey

Configration: outerloop_netfx_windows_nt_debug

Detail: https://ci.dot.net/job/dotnet_corefx/job/master/job/outerloop_netfx_windows_nt_debug/26/testReport/System.Security.Cryptography.Cng.Tests/ECDsaCngTests/TestVerify521_EcdhKey/

MESSAGE:
~~~
System.ArgumentException : Keys used with the ECDsaCng algorithm must have an algorithm group of ECDsa.
     Parameter name: key
~~~
STACK TRACE:
~~~
at System.Security.Cryptography.ECDsaCng..ctor(CngKey key) 
at System.Security.Cryptography.Cng.Tests.ECDsaCngTests.TestVerify521_EcdhKey() 
in D:\j\workspace\outerloop_net---903ddde6\src\System.Security.Cryptography.Cng\tests\ECDsaCngTests.cs:line 93
~~~","Desktop: System.Security.Cryptography.Cng.Tests.ECDsaCngTests.TestVerify521_EcdhKey failed with ""System.ArgumentException""  Failed test: System.Security.Cryptography.Cng.Tests.ECDsaCngTests.TestVerify521_EcdhKey

Configration: outerloop_netfx_windows_nt",32289,bartonjs,corefx
21921,System.Security.Cryptography.Cng.ImportExport tests fail in Desktop,"This tests are conditioned through `ConditionalFact` where they will run if the current running framework is 4.6.2 or newer as this was supposed to be fixed in that version of the framework: https://github.com/dotnet/corefx/issues/19041#issuecomment-297855354

They are failing with:
```
System.Security.Cryptography.Rsa.Tests.ImportExport.LargeKeyImportExport [FAIL]
        System.Security.Cryptography.CryptographicException : The requested operation is not supported.

        Stack Trace:
             at System.Security.Cryptography.NCryptNative.ExportKey(SafeNCryptKeyHandle key, String format)
             at System.Security.Cryptography.CngKey.Export(CngKeyBlobFormat format)
             at System.Security.Cryptography.RSACng.ExportParameters(Boolean includePrivateParameters)
          D:\repos\corefxCopy\corefx\src\Common\tests\System\Security\Cryptography\AlgorithmImplementations\RSA\ImportExport.cs(95,0): at System.Security.Cryptography.Rsa.Tests.ImportExport.LargeKeyImportExport()
```

cc: @bartonjs @ianhays @steveharter",System.Security.Cryptography.Cng.ImportExport tests fail in Desktop  This tests are conditioned through `ConditionalFact` where they will run if the current running framework is 4.6.2 or newer as this was supposed to be fixed in that version of the framew,32289,bartonjs,corefx
16445,"Initial implementation of X509Certificates, HttpClient, and SslStream for macOS","Broken by this change:
* A lot of TLS CipherSuites have no metadata defined.
* macOS does not support version skipping in TLS.  So `Tls | Tls12` is an invalid choice.

In this change:
General:
* All OSStatus related exceptions now look up the error message.

X509Certificates:
* X509Certificate moves to using SecCertificateRef from OpenSSL's X509.
* X509 metadata comes from a managed reader after being loaded by Security.framework,
due to the significant amount of data that has no public export in Apple's libraries.
* Significant code was factored out to be shared by OpenSSL and Apple implementations for X500DistinguishedName and X509Certficate2Collection.Find.
* Loading a PFX (or, rather, the private keys from a PFX) via Apple's platform
requires importing into a Keychain, and a Keychain requires a file on disk.
A temporary keychain is created during cert loading and erased when safe.
Like the perphemeral key load on Windows this can leak files due to
abnormal program termination.
* The X.509 My store for CurrentUser and LocalMachine are the default (user) and System keychains.
* The X.509 Root store is an interpretation of the Apple SecTrustSettings data.
* The X.509 Disallowed store hasn't been implemented yet, but should be a very small change.
* Other X.509 stores cannot be created due to keychain complexity.

HttpClient:
* Initialization no longer wakes up OpenSSL

SslStream:
* New implementation based on Apple SecureTransport.
* Currently has support for SNI (for AuthenticateAsClient)","Initial implementation of X509Certificates, HttpClient, and SslStream for macOS  Broken by this change:
* A lot of TLS CipherSuites have no metadata defined.
* macOS does not support version skipping in TLS.  So `Tls | Tls12` is an invalid choice.

In",32286,bartonjs,corefx
30572,NetFX compatibility fixes for X500DistinguishedName.,Fixes https://github.com/dotnet/corefx/issues/27466.,NetFX compatibility fixes for X500DistinguishedName.  Fixes https://github.com/dotnet/corefx/issues/27466.,32286,bartonjs,corefx
15463,Unix X500DistinguishedName prints multicomponent RDNs different than Windows,"""Normal"" certificate subjects are similar to

```
Sequence(
    Set(Sequence(Oid(CN), PrintableString(""CommonName""))),
    Set(Sequence(Oid(O), PrintableString(""Organization""))))
```

When presented with a multi-component RDN like

```
Sequence(
    Set(
        Sequence(Oid(CN), PrintableString(""CommonName"")),
        Sequence(Oid(O), PrintableString(""Organization""))))
```

Windows prints `CN=CommonName + O=Organization`.  The OpenSSL library seems to float the latter into the former, resulting in Unix builds printing `CN=CommonName, O=Organization`.

This is not expected to be very common, and Windows has an explicit disrecommendation for this on MSDN (https://msdn.microsoft.com/en-us/library/windows/desktop/aa376556%28v=vs.85%29.aspx - under Remarks):

> We recommend against using multicomponent RDNs (e.g., CN=James+O=Microsoft) to avoid possible ordering problems when decoding occurs. Instead, consider using single valued RDNs (e.g., CN=James, O=Microsoft). ","Unix X500DistinguishedName prints multicomponent RDNs different than Windows  ""Normal"" certificate subjects are similar to

```
Sequence(
    Set(Sequence(Oid(CN), PrintableString(""CommonName""))),
    Set(Sequence(Oid(O), PrintableString(""Organizatio",32286,bartonjs,corefx
27340,SignedCms.ComputeSignature throws invalid exception type when signer certificate is not provided,"Repro:

```csharp
ContentInfo ci = new ContentInfo(new byte[1]);
SignedCms cms = new SignedCms(ci);
cms.ComputeSignature();
```

On full framework we get following exception (this is what's expected):

```
System.InvalidOperationException: The recipient certificate is not specified.
```

.NET Core exception:

```
System.PlatformNotSupportedException: No signer certificate was provided. This platform does not implement the certificate picker UI.
```","SignedCms.ComputeSignature throws invalid exception type when signer certificate is not provided  Repro:

```csharp
ContentInfo ci = new ContentInfo(new byte[1]);
SignedCms cms = new SignedCms(ci);
cms.ComputeSignature();
```

On full framework we",32226,bartonjs,corefx
27347,SignedCms.ComputeSignature doesn't implement SubjectIdentifierType.NoSignature correctly,"References: dotnet/runtime#27340, dotnet/corefx#32186

The following code crashes with `NullReferenceException`:

```c#
ContentInfo ci = new ContentInfo(new byte[1]);
SignedCms cms = new SignedCms(ci);
cms.ComputeSignature(new CmsSigner(SubjectIdentifierType.NoSignature));
```

The code path is not properly implemented and still tries to access `CmsSigner.Certificate` which is not available. Unit test coverage for this scenario is also missing.","SignedCms.ComputeSignature doesn't implement SubjectIdentifierType.NoSignature correctly  References: dotnet/runtime#27340, dotnet/corefx#32186

The following code crashes with `NullReferenceException`:

```c#
ContentInfo ci = new ContentInfo(new byt",32226,bartonjs,corefx
32186,System.Security: Fix SubjectIdentifierType.NoSignature implementation in SignedCms,"Fix for #32171 and #32187.

- Fixes calculating the signature for `SubjectIdentifierType.NoSignature` by emitting the special `No signature (szOID_PKIX_NO_SIGNATURE)` algorithm identifier and storing the data hash in the signature value. This matches what NetFX implements.
- Implements the parameter-less `SignedCms.ComputeSignature` method by storing the value of `SubjectIdentifierType` from the constructor and using it to create new `CmsSigner` object. The utility of this is very limited since it will throw exception for anything but `SubjectIdentifierType.NoSignature`. Contrary to the official documentation it specifies the default value for `silent` parameter as `true`, which matches the behavior of NetFX 4.7.2.
- Added check for unspecified `Certificate` in `CmsSigner` passed to the `SignedCms.ComputeSignature` method. Now it will throw `InvalidOperationException` (for silent mode) or `PlatformNotSupportedException` (for non-silent UI mode) instead of crashing with `NullReferenceException`.
- Added unit tests. They fail on NetFX due to bug mentioned in #32187. Workaround is to pass some dummy certificate as a parameter to `CmsSigner`.","System.Security: Fix SubjectIdentifierType.NoSignature implementation in SignedCms  Fix for #32171 and #32187.

- Fixes calculating the signature for `SubjectIdentifierType.NoSignature` by emitting the special `No signature (szOID_PKIX_NO_SIGNATURE)` al",32226,bartonjs,corefx
32127,Fix extract out of directory,"Without ensuring a trailing directory separator you cannot compare paths for nesting.  `/Foo/Bar` does not contain `/Foo/Barber`, but does contain `/Foo/Bar/Bell`. This adds the separator and tests.","Fix extract out of directory  Without ensuring a trailing directory separator you cannot compare paths for nesting.  `/Foo/Bar` does not contain `/Foo/Barber`, but does contain `/Foo/Bar/Bell`. This adds the separator and tests.",32165,maryamariyan,corefx
31589,[release/2.1] Handle NT auth with Connection: close on initial challenge #31527,"When we receive an initial NT auth challenge that has Connection: close set on the response,
we need to proceed with authentication on a new connection.

Fixes #30327","[release/2.1] Handle NT auth with Connection: close on initial challenge #31527  When we receive an initial NT auth challenge that has Connection: close set on the response,
we need to proceed with authentication on a new connection.

Fixes #30327",32146,geoffkizer,corefx
27327,ObjectDisposedException from HttpContent.LoadIntoBufferAsync with WindowsAuth,"Starting Sept 2nd ASP.NET Core started seeing unusual ODEs from HttpClient. There have been 26 automated repros in the last four days. 2.2 and 3.0 both reproduce the issue. I have not been able to reproduce it manually in 2.2, but it fails every time in 3.0. https://github.com/aspnet/HttpSysServer/issues/474

In the 3.0 branch the failures started after updating to .NET Core 3.0.0-preview1-26905-03.

```
System.ObjectDisposedException : Cannot access a disposed object.
Object name: 'System.Net.Http.HttpConnection+HttpConnectionResponseContent'.
   at System.Net.Http.HttpContent.CheckDisposed()
   at System.Net.Http.HttpContent.LoadIntoBufferAsync(Int64 maxBufferSize, CancellationToken cancellationToken)
   at System.Net.Http.HttpClient.FinishSendAsyncBuffered(Task`1 sendTask, HttpRequestMessage request, CancellationTokenSource cts, Boolean disposeCts)
   at Microsoft.AspNetCore.Server.HttpSys.AuthenticationTests.SendRequestAsync(String uri, Boolean useDefaultCredentials) in /_/test/Microsoft.AspNetCore.Server.HttpSys.FunctionalTests/AuthenticationTests.cs:line 377
   at Microsoft.AspNetCore.Server.HttpSys.AuthenticationTests.AuthTypes_UnathorizedAuthenticatedAuthType_Unauthorized(AuthenticationSchemes authType) in /_/test/Microsoft.AspNetCore.Server.HttpSys.FunctionalTests/AuthenticationTests.cs:line 364
--- End of stack trace from previous location where exception was thrown ---
```

The scenario is Windows Auth Negotiate tests with HttpSys server. The NTLM variant is not impacted. There have been no server side changes here for some time.
https://github.com/aspnet/HttpSysServer/blob/9cb675fec89702d28b5f188e0ab4f7d671d7aa11/test/Microsoft.AspNetCore.Server.HttpSys.FunctionalTests/AuthenticationTests.cs#L349-L369

The client code is not doing anything interesting that should lead to an ODE:
https://github.com/aspnet/HttpSysServer/blob/9cb675fec89702d28b5f188e0ab4f7d671d7aa11/test/Microsoft.AspNetCore.Server.HttpSys.FunctionalTests/AuthenticationTests.cs#L371-L379

The test fails in only 1 second so timeouts should not be a factor. Nothing else the server does should be capable of causing an ODE here on the client.

I see some recent changes in this code path on the client that may be related: https://github.com/dotnet/corefx/pull/31589/files

@davidsh",ObjectDisposedException from HttpContent.LoadIntoBufferAsync with WindowsAuth  Starting Sept 2nd ASP.NET Core started seeing unusual ODEs from HttpClient. There have been 26 automated repros in the last four days. 2.2 and 3.0 both reproduce the issue. I h,32146,geoffkizer,corefx
25782,[Uri] Fix IPv6 address format,"Here are the issues in Uri with IPv6 address we may want to fix:

1. **[Pending discussion]** `Uri.IdnHost` should include `[]` around IPv6 address.
    * Currently it returns `::1234`, it should return `[::1234]`.
2. [Originally done with PR dotnet/corefx#29829 but reverted with dotnet/corefx#30062]  `Uri.Host` LLA (Link-local address) IPv6 address doesn't contain `%number` part.
    * Currently it returns `[fe80::e077:c9a3:eeba:b8e9]`, it should return `[fe80::e077:c9a3:eeba:b8e9%18]`.
    * Note: `Uri.IdnHost` correctly contains the `%number` part.

If we choose to fix these problems, we can undo workarounds in dotnet/corefx#28740, dotnet/corefx#28578, dotnet/corefx#28849 and dotnet/corefx#28971.

/cc: @dotnet/ncl","[Uri] Fix IPv6 address format  Here are the issues in Uri with IPv6 address we may want to fix:

1. **[Pending discussion]** `Uri.IdnHost` should include `[]` around IPv6 address.
    * Currently it returns `::1234`, it should return `[::1234]`.
2. [O",31123,davidsh,corefx
26846,HttpWebRequest not using system proxy settings,"While investigating other HttpClient/HttpWebRequest proxy-related bugs, I discovered that
HttpWebRequest was not honoring system proxy settings as defined on Windows with IE
settings or on Linux using environment variables.

Repro:
```c#
HttpWebRequest webRequest = WebRequest.CreateHttp(""http://corefx-net.cloudapp.net/echo.ashx"");
HttpWebResponse webResponse = webRequest.GetResponse() as HttpWebResponse;

using (Stream httpStream = webResponse.GetResponseStream())
{
    using (StreamReader httpReader = new StreamReader(httpStream))
    {
        string response = httpReader.ReadToEnd();
        Console.WriteLine(response);
     }
}
```

On Linux (but it repro's on Windows as well), set system proxy settings using 'http_proxy' environment variable.  Assume a proxy is running on that server.

```
export http_proxy=http://172.17.0.3:8888
```

When running against HttpClient, the request goes thru a proxy. You can see the 'Via' request header that was sent as sent back from the echo server.  But using HttpWebRequest, there is no 'Via' request header since the request did not go thru the proxy.
```
root@546974bdd7f0:/home/root/httptest# dotnet run
Sending request with HttpClient
200 OK
{""Method"":""GET"",""Url"":""/echo.ashx"",""Headers"": {
    ""Connection"": ""close"",
    ""Via"": ""1.1 tinyproxy (tinyproxy/1.8.4)"",
    ""Host"": ""corefx-net.cloudapp.net""
  },
  ""Cookies"": {},
  ""BodyContent"": """",
  ""BodyLength"": 0,
  ""SecureConnection"": false,
  ""ClientCertificatePresent"": false,
  ""ClientCertificate"": null
}
Sending request with HttpWebRequest
{""Method"":""GET"",""Url"":""/echo.ashx"",""Headers"": {
    ""Connection"": ""Keep-Alive"",
    ""Host"": ""corefx-net.cloudapp.net""
  },
  ""Cookies"": {},
  ""BodyContent"": """",
  ""BodyLength"": 0,
  ""SecureConnection"": false,
  ""ClientCertificatePresent"": false,
  ""ClientCertificate"": null
}
```","HttpWebRequest not using system proxy settings  While investigating other HttpClient/HttpWebRequest proxy-related bugs, I discovered that
HttpWebRequest was not honoring system proxy settings as defined on Windows with IE
settings or on Linux using envi",31123,davidsh,corefx
24697,Microsoft.VisualBasic string methods not implemented,"Inside the Microsft.VisualBasic.Strings namespace, not all methods from the .NET framework have been implemented. Left has been, but Trim, Right, Mid etc. haven't

Is this something that can be added?","Microsoft.VisualBasic string methods not implemented  Inside the Microsft.VisualBasic.Strings namespace, not all methods from the .NET framework have been implemented. Left has been, but Trim, Right, Mid etc. haven't

Is this something that can be added",31086,danmosemsft,corefx
26259,While Calling an VB.Net Shared method from .NET Core project throwing Runtime exceptions,"Throwing Runtime exception called 

> Could not load type 'Microsoft.VisualBasic.Information' from assembly 'Microsoft.VisualBasic, Version=10.0.3.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a'.

When calling a mesage queue service which intern calling the another vb.net shared method.
 Seems there is some issue while calling a shared method of vb.net from .Net core 2.1 app","While Calling an VB.Net Shared method from .NET Core project throwing Runtime exceptions   Throwing Runtime exception called 

> Could not load type 'Microsoft.VisualBasic.Information' from assembly 'Microsoft.VisualBasic, Version=10.0.3.0, Culture=neut",31086,danmosemsft,corefx
19588,Question: Microsoft.VisualBasic functions port,"I have some ex-VB assemblies that still call into some of the old legacy VB helper functions. Do you mind if I port some of that surface area to core?

Specifically:
Strings.Right
Strings.Left
Strings.Mid
Strings.Replace
DateAndTime.DateDiff
Information.IsDate
Information.IsNumeric","Question: Microsoft.VisualBasic functions port  I have some ex-VB assemblies that still call into some of the old legacy VB helper functions. Do you mind if I port some of that surface area to core?

Specifically:
Strings.Right
Strings.Left
Strings.M",31086,danmosemsft,corefx
25968,"Add FileLogTraceListener, Log and Asp​Log classes to .Net Core","FileLogTraceListener class is available in .net framework in the Microsoft.VisualBasic.Logging namespace. It has some useful features that are not available in other TraceListeners, as descried here:
https://docs.microsoft.com/en-us/dotnet/api/microsoft.visualbasic.logging.filelogtracelistener?view=netframework-4.7.2

This class is not available in .Net Core, so I suggest you add it and make it available to both VB.NET and C#.
And I suggest the same for Log Class
https://docs.microsoft.com/en-us/dotnet/api/microsoft.visualbasic.logging.log?view=netframework-4.7.2
and Asp​Log Class:
https://docs.microsoft.com/en-us/dotnet/api/microsoft.visualbasic.logging.asplog?view=netframework-4.7.2","Add FileLogTraceListener, Log and Asp​Log classes to .Net Core  FileLogTraceListener class is available in .net framework in the Microsoft.VisualBasic.Logging namespace. It has some useful features that are not available in other TraceListeners, as descri",31086,danmosemsft,corefx
19366,SqlConnection should support Azure AD token-based authentication,"The desktop .NET Framework 4.6 and newer has an `AccessToken` property on the `SqlConnection` class ([MSDN](https://msdn.microsoft.com/en-us/library/system.data.sqlclient.sqlconnection.accesstoken(v=vs.110).aspx)) which can be used to authenticate to a SQL Azure database using an access token issued by Azure AD ([examples here](https://azure.microsoft.com/en-us/documentation/articles/sql-database-aad-authentication/#7-connect-by-using-azure-ad-identities)). However, this property is not present on the version of `SqlConnection` provided in the System.Data.SqlClient NuGet package, including the latest preview v4.3.0-preview1-24530-04. In case it's an important detail, the project in question is a library project targeting 'netstandard1.6'.

The lack of the `AccessToken` property makes it difficult, if not impossible, to support modern directory-based auth scenarios for Azure SQL DB while also targeting .NET Standard (I have not attempted to use the connection string-based AAD options, but for various reasons those would not be applicable for my project). I have yet to find a workaround other than setting the target framework to 'net46', which I would like to avoid except as a last resort.",SqlConnection should support Azure AD token-based authentication  The desktop .NET Framework 4.6 and newer has an `AccessToken` property on the `SqlConnection` class ([MSDN](https://msdn.microsoft.com/en-us/library/system.data.sqlclient.sqlconnection.acce,31039,AfsanehR,corefx
30342,Azure Active Directory Authentication using Access Token,Fixes #[13660](https://github.com/dotnet/corefx/issues/13660) This pull request will enable authentication using only **Access Token**.,Azure Active Directory Authentication using Access Token  Fixes #[13660](https://github.com/dotnet/corefx/issues/13660) This pull request will enable authentication using only **Access Token**.,31039,AfsanehR,corefx
19082,Stop disposing of request content in HttpClient,"HttpClient on Unix fails for some sites, in cases where the site sends a response before it’s fully received the entirety of the request.  That’s because HttpClient has logic to Dispose of the request content once the Task returned from the handler’s SendAsync completes, and unlike WinHTTP, libcurl doesn’t require that the whole request be sent before any of the response is processed.  That means that CurlHandler may receive the response (or the response headers), complete the SendAsync task, but still be reading from the request content, which may then be disposed of by HttpClient while it’s still in use, causing potential corruption, exceptions, etc.

The Dispose behavior has other problems with it.  A more generalized version of the above is that it prevents handlers that want to support full duplex communication, since it essentially requires that the whole request be sent before the response is processed.  It also forces extra cost onto consuming code in some situations, as it means that the request content objects can’t be pooled and reused (since disposal typically invalidates objects for such a purpose, though in some cases a custom content could be developed to override and ignore Dispose).

A variety of approaches were explored to address this:
- Change CurlHandler to only complete the SendAsync Task when both the request has been fully sent and the appropriate portion of the response has been received.  This is problematic, though, as with the pull model employed by libcurl, we don’t know reliably when the request has been fully sent.
- Change the disposal to be handled by the handlers rather than by HttpClient.  This could help in that a handler like CurlHandler could simply defer disposal until libcurl tells it the “easy” operation is done.  But it has other downsides. Today code can use an HttpClientHandler without HttpClient, e.g. by using HttpMessageInvoker instead of HttpClient, in which case it bypasses this disposal logic (and other logic provided by the relatively thin HttpClient wrapper). If we were to move the disposal logic to the HttpClientHandler, now such code that was never having its request content disposed will start to, which is bad and exactly the opposite of what we want. It also causes problems for chains of handlers, e.g. if HttpClient is given a handler that wraps CurlHandler, and that handler expects to be able to look at the request content after the SendAsync Task from CurlHandler completes but before it itself completes its SendAsync Task. And while such a scenario may seem far fetched, we effectively have it in the bits today: the diagnostic handler that's used to pass details off to DiagnosticListeners is injected in the middle like this, and it does pass off the request content after the wrapped SendAsync Task completes... if a listener was expecting a non-disposed request content at that point, it would be sorely disappointed.
- Simply stop disposing.  The primary downside here is existing code that may have expected disposal to happen, e.g. if a StreamContent wrapping a FileStream isn't explicitly disposed of by the app code, cleanup of the FileStream will be left to its finalizer.

The least bad option is to simply stop disposing.  This PR makes that change.

Fixes https://github.com/dotnet/corefx/issues/9006
Fixes https://github.com/dotnet/corefx/issues/16259
Fixes https://github.com/dotnet/corefx/issues/1794
cc: @davidsh, @cipop, @geoffkizer, @Priya91, @davidfowl, @mikeharder","Stop disposing of request content in HttpClient  HttpClient on Unix fails for some sites, in cases where the site sends a response before it’s fully received the entirety of the request.  That’s because HttpClient has logic to Dispose of the request conte",31031,davidsh,corefx
26772,Test failure: System.Net.Http.Functional.Tests.PlatformHandler_PostScenarioTest/PostRewindableStreamContentMultipleTimes_StreamContentFullySent(serverUri: http://corefx-net.cloudapp.net/Echo.ashx),"Opened on behalf of @Sunny-pu

The test `System.Net.Http.Functional.Tests.PlatformHandler_PostScenarioTest/PostRewindableStreamContentMultipleTimes_StreamContentFullySent(serverUri: http://corefx-net.cloudapp.net/Echo.ashx)` has failed.

System.ObjectDisposedException : Cannot access a closed Stream.

        Stack Trace:

           at System.IO.__Error.StreamIsClosed()
       at System.IO.MemoryStream.get_Position()
       at System.Net.Http.Functional.Tests.PostScenarioTest.<PostRewindableStreamContentMultipleTimes_StreamContentFullySent>d__9.MoveNext()
    --- End of stack trace from previous location where exception was thrown ---
       at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
       at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
    --- End of stack trace from previous location where exception was thrown ---
       at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
       at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
    --- End of stack trace from previous location where exception was thrown ---
       at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
       at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
Build : Master - 20180711.01 (Full Framework Tests)
Failing configurations:
- Windows.10.Amd64.ClientRS4-x64
  - Release
- Windows.10.Amd64.ClientRS4-x86
  - Release

Details: https://mc.dot.net/#/product/netcore/master/source/official~2Fcorefx~2Fmaster~2F/type/test~2Ffunctional~2Fdesktop~2Fcli~2F/build/20180711.01/workItem/System.Net.Http.Functional.Tests/analysis/xunit/System.Net.Http.Functional.Tests.PlatformHandler_PostScenarioTest~2FPostRewindableStreamContentMultipleTimes_StreamContentFullySent(serverUri:%20http:~2F~2Fcorefx-net.cloudapp.net~2FEcho.ashx)","Test failure: System.Net.Http.Functional.Tests.PlatformHandler_PostScenarioTest/PostRewindableStreamContentMultipleTimes_StreamContentFullySent(serverUri: http://corefx-net.cloudapp.net/Echo.ashx)  Opened on behalf of @Sunny-pu

The test `System.Net.Htt",31031,davidsh,corefx
30947,Ensure ConcurrentBag's TryTake is linearizable,"For .NET Core 2.0, I ported the ThreadPool's work-stealing implementation to ConcurrentBag, leading to significant performance throughput and allocation improvements.  However, there's a subtle difference in the concurrency guarantees the ThreadPool's implementation provided from what ConcurrentBag needs, which ends up breaking certain usage patterns on top of ConcurrentBag.

Specifically, ThreadPool's ""steal"" implementation need not be fully linearizable.  It's possible for a thread to see the bag's count as 1, and then while the thread is doing a take/steal for its count to never drop below 1, but for the steal to still fail, even though there was always an item available.  This is ok for the thread pool because it manages a known count of work items in the queues separately, and if it sees that there are still items available after a steal has failed, it'll try again.  That ""try again"" logic provided above the work-stealing queue thus didn't make it over to ConcurrentBag, which breaks some usages of ConcurrentBag, in particular cases where a type like BlockingCollection is wrapping the bag and managing its own count.  It's possible now for BlockingCollection to know that there's an item in the bag but to then fail to take it, which causes problems such as exceptions being thrown.

The fix is to port back the relevant portion of ConcurrentBag from .NET Core 1.x / .NET Framework, where local push operations on a list track the number of times the list transitions from empty to non-empty.  A steal operation then looks at those counts prior to doing the steal, and if the steal fails, it looks again after: if the count has increased, it retries.  This unfortunately means that local pushes on small lists are now more expensive than in .NET Core 2.0/2.1, as if there are <= 2 items in the list, it takes the lock, but this seems unavoidable given the work-stealing design.

Contributes to https://github.com/dotnet/corefx/issues/30781
cc: @kouvel, @tarekgh, @ReubenBond
Please pay close attention to the details of the change.  I've convinced myself that it's correct, but I've also been staring at it for a while, so it's very possible I've missed something.  I tried to keep the logic as close to the original .NET Core 1.x / .NET Framework logic as possible.  The main difference is that rather than having each list maintain its own empty-to-nonempty transition count, I have a single count that's incremented via interlocked increment by all of them.  I did that in part to keep things simpler, even though it adds a bit more expense, but also because I couldn't convince myself that the original logic used by netfx here was actually correct; if you can, we could consider switching to that, which would make some adds slightly less expensive while making steals more expensive.","Ensure ConcurrentBag's TryTake is linearizable  For .NET Core 2.0, I ported the ThreadPool's work-stealing implementation to ConcurrentBag, leading to significant performance throughput and allocation improvements.  However, there's a subtle difference in",31009,stephentoub,corefx
26671,BlockingCollection<T>.TryTakeFromAny throws InvalidOperationException when underlying collection is ConcurrentBag<T>,"When the underlying collection for `BlockingCollection<T>` is `ConcurrentBag<T>`, concurrent calls to the static [`BlockingCollection<T>.TryTakeFromAny`](https://msdn.microsoft.com/en-us/library/dd267314(v=vs.110).aspx) method can sometimes throw `InvalidOperationException` with the message ""The underlying collection was modified from outside of the BlockingCollection<T>"". This can occur without any external modification to the collection.

This behavior is present in .NET Core 2.0/2.1 but not in .NET Framework 4.6.1.

Repro: https://gist.github.com/ReubenBond/98de2cede0d57a989ededa8e113b0f39#file-blockingcollection_concurrentbag_issue-cs

EDIT: This can be reproduced without `TryTakeFromAny` by replacing that line in the repro with `success = blockingCollection.TryTake(out _)`.

EDIT 2: This does not reproduce with an underlying collection of type `ConcurrentQueue<T>`

EDIT 3: Updated repro to use ThreadPool instead of tasks - it reproduces much more frequently now.","BlockingCollection<T>.TryTakeFromAny throws InvalidOperationException when underlying collection is ConcurrentBag<T>  When the underlying collection for `BlockingCollection<T>` is `ConcurrentBag<T>`, concurrent calls to the static [`BlockingCollection<T>.",31009,stephentoub,corefx
31132,[release/2.1] Revert - Ensure ConcurrentBag's TryTake is linearizable,"Reverts PR #31009

Pulling this temporarily as it missed 2.1.3 and they want a clean branch in case they need to rebuild 2.1.3 for some reason.

Just hit ""revert""  button.","[release/2.1] Revert - Ensure ConcurrentBag's TryTake is linearizable  Reverts PR #31009

Pulling this temporarily as it missed 2.1.3 and they want a clean branch in case they need to rebuild 2.1.3 for some reason.

Just hit ""revert""  button.",31009,stephentoub,corefx
26727,Update HttpStatusCode enum,"Closes: #4382

/cc: @dotnet/ncl","Update HttpStatusCode enum  Closes: #4382

/cc: @dotnet/ncl",30954,rmkerr,corefx
30398,Add support and tests for HTTP 308 Permanent Redirect,"The HttpStatusCode enum was only recently updated to include HTTP status code 308, via PR #26727. With the platform handlers we support whatever cURL and WinHttp support, so 308 works even though the status code did not exist in the enum until recently. However in SocketsHttpHandler we only support the redirects that were in the enum when that code was written, which at the time did not include 308.

This PR adds support for 308 redirects to SocketsHttpHandler, and enables 308 redirects in our tests. It is not well documented when WinHttp and cURL added support for HTTP 308, so it is possible these tests will fail on older operating systems. If so I believe we should still take the change, but should add documentation on our support on older systems. 

Fixes: #30389","Add support and tests for HTTP 308 Permanent Redirect  The HttpStatusCode enum was only recently updated to include HTTP status code 308, via PR #26727. With the platform handlers we support whatever cURL and WinHttp support, so 308 works even though the",30954,rmkerr,corefx
26495,Behavioral change in SocketsHttpHandler - no automatic redirection for 308 Permanent Redirect,"The older (pre 2.1.0) `HttpClientHandler` performs automatic redirection for *308 Permanent Redirect*. Unfortunately the `GetUriForRedirect` method of `RedirectHandler` which is being used by `SocketsHttpHandler` doesn't support this status code.

https://github.com/dotnet/corefx/blob/c6efb248fd3c633e09733b2c9514d5729577a701/src/System.Net.Http/src/System/Net/Http/SocketsHttpHandler/RedirectHandler.cs#L88-L99

Currently the only way to have automatic redirection for *308 Permanent Redirect* is to configure a process to use the older `HttpClientHandler` (`AppContext.SetSwitch(""System.Net.Http.UseSocketsHttpHandler"", false)`).",Behavioral change in SocketsHttpHandler - no automatic redirection for 308 Permanent Redirect  The older (pre 2.1.0) `HttpClientHandler` performs automatic redirection for *308 Permanent Redirect*. Unfortunately the `GetUriForRedirect` method of `Redirect,30954,rmkerr,corefx
20367,"Test failure: System.Net.Security tests failing with ""Authentication failed because the remote party has closed the transport stream""","There is a group of tests that are failing intermittently with the error ```System.IO.IOException : Authentication failed because the remote party has closed the transport stream.```. I'm tracking their failures in this issue as they are likely due to the same underlying issue.

The following tests have failed at some point with this error:
- [ClientAsyncAuthenticateTest.ClientAsyncAuthenticate_MismatchProtocols_Fails(serverProtocol: Tls12, clientProtocol: Tls11](https://github.com/dotnet/corefx/issues/16968)
- [ClientAsyncAuthenticateTest.ClientAsyncAuthenticate_EachClientUnsupportedProtocol_Fail](https://github.com/dotnet/corefx/issues/10909)
- [ClientAsyncAuthenticateTest.ClientAsyncAuthenticate_AllServerAllClient_Success](https://github.com/dotnet/corefx/issues/14177)
- ClientAsyncAuthenticateTest.ClientAsyncAuthenticate_IndividualServerVsAllClientSupportedProtocols_Success(serverProtocol: Tls11) 
- ClientDefaultEncryptionTest.ClientDefaultEncryption_ServerAllowNoEncryption_ConnectWithEncryption
- [ServerNoEncryptionTest.ServerNoEncryption_ClientAllowNoEncryption_ConnectWithNoEncryption failed.](https://github.com/dotnet/corefx/issues/9130)
- [ServerNoEncryptionTest.ServerNoEncryption_ClientNoEncryption_ConnectWithNoEncryption](https://github.com/dotnet/corefx/issues/11624)
- ServerAllowNoEncryptionTest.ServerAllowNoEncryption_ClientNoEncryption_ConnectWithNoEncryption
- [ServerAllowNoEncryptionTest.ServerAllowNoEncryption_ClientRequireEncryption_ConnectWithEncryption](https://github.com/dotnet/corefx/issues/14504)


None of these test failures are reproducible on local machines regardless of the number of runs executed, which suggests the issue lies in either the infrastructure or interference from other tests run alongside these. They only fail on Windows.

It might be helpful to get another pair of eyes on this to see if anything stands out. As it is, I've been unable to narrow the symptoms down to any definitive problem and @steveharter and my's attempts to reproduce failures have been fruitless. I'll be disabling this entire group of tests to regain stability until we can get more information on their source. They are possibly related to https://github.com/dotnet/corefx/issues/16516.","Test failure: System.Net.Security tests failing with ""Authentication failed because the remote party has closed the transport stream""  There is a group of tests that are failing intermittently with the error ```System.IO.IOException : Authentication faile",29875,davidsh,corefx
21606,Ping API calls are failing in appcontainer with access denied,"They don't fail that way in ILC

https://mc.dot.net/#/product/netcore/master/source/official~2Fcorefx~2Fmaster~2F/type/test~2Ffunctional~2Fuwp~2F/build/20170510.01/workItem/System.Net.Ping.Functional.Tests

Check we have the internet capability. Whatever manifest we use for our test app, it should enable all capabilities.

@AlexGhiondea where is it?
cc @ViktorHofer","Ping API calls are failing in appcontainer with access denied  They don't fail that way in ILC

https://mc.dot.net/#/product/netcore/master/source/official~2Fcorefx~2Fmaster~2F/type/test~2Ffunctional~2Fuwp~2F/build/20170510.01/workItem/System.Net.Ping.F",29875,davidsh,corefx
21464,Tests failed: System.Net.Requests.Tests / System.Net.Tests.HttpWebRequestHeaderTest,"Tests under ""System.Net.Requests.Tests"" failed to generate the test result.

Detail: https://mc.dot.net/#/product/netcore/master/source/official~2Fcorefx~2Fmaster~2F/type/test~2Ffunctional~2Fdesktop~2Fcli~2F/build/20170502.01/workItem/System.Net.Requests.Tests/wilogs

~~~
2017-05-02 01:17:30,513: INFO: proc(54): run_and_log_output: Output:   Discovering: System.Net.Requests.Tests
2017-05-02 01:17:30,779: INFO: proc(54): run_and_log_output: Output:   Discovered:  System.Net.Requests.Tests
2017-05-02 01:17:30,795: INFO: proc(54): run_and_log_output: Output:   Starting:    System.Net.Requests.Tests
2017-05-02 01:19:12,552: INFO: proc(54): run_and_log_output: Output:     System.Net.Tests.HttpWebRequestHeaderTest.HttpWebRequest_KeepAlive_CorrectConnectionHeaderSent(keepAlive: null) [FAIL]
2017-05-02 01:19:12,552: INFO: proc(54): run_and_log_output: Output:       System.Net.WebException : The operation has timed out
2017-05-02 01:19:12,552: INFO: proc(54): run_and_log_output: Output:       Stack Trace:
2017-05-02 01:19:12,569: INFO: proc(54): run_and_log_output: Output:            at System.Net.HttpWebRequest.GetResponse()
2017-05-02 01:19:12,569: INFO: proc(54): run_and_log_output: Output:         E:\A\_work\211\s\corefx\src\System.Net.Requests\tests\HttpWebRequestHeaderTest.cs(253,0): at System.Net.Tests.HttpWebRequestHeaderTest.HttpWebRequest_KeepAlive_CorrectConnectionHeaderSent(Nullable`1 keepAlive)
2017-05-02 01:20:52,540: INFO: proc(54): run_and_log_output: Output:     System.Net.Tests.HttpWebRequestHeaderTest.HttpWebRequest_KeepAlive_CorrectConnectionHeaderSent(keepAlive: False) [FAIL]
2017-05-02 01:20:52,540: INFO: proc(54): run_and_log_output: Output:       System.Net.WebException : The operation has timed out
2017-05-02 01:20:52,540: INFO: proc(54): run_and_log_output: Output:       Stack Trace:
2017-05-02 01:20:52,540: INFO: proc(54): run_and_log_output: Output:            at System.Net.HttpWebRequest.GetResponse()
2017-05-02 01:20:52,540: INFO: proc(54): run_and_log_output: Output:         E:\A\_work\211\s\corefx\src\System.Net.Requests\tests\HttpWebRequestHeaderTest.cs(253,0): at System.Net.Tests.HttpWebRequestHeaderTest.HttpWebRequest_KeepAlive_CorrectConnectionHeaderSent(Nullable`1 keepAlive)
2017-05-02 01:22:32,558: INFO: proc(54): run_and_log_output: Output:     System.Net.Tests.HttpWebRequestHeaderTest.HttpWebRequest_KeepAlive_CorrectConnectionHeaderSent(keepAlive: True) [FAIL]
2017-05-02 01:22:32,558: INFO: proc(54): run_and_log_output: Output:       System.Net.WebException : The operation has timed out
2017-05-02 01:22:32,558: INFO: proc(54): run_and_log_output: Output:       Stack Trace:
2017-05-02 01:22:32,558: INFO: proc(54): run_and_log_output: Output:            at System.Net.HttpWebRequest.GetResponse()
2017-05-02 01:22:32,558: INFO: proc(54): run_and_log_output: Output:         E:\A\_work\211\s\corefx\src\System.Net.Requests\tests\HttpWebRequestHeaderTest.cs(253,0): at System.Net.Tests.HttpWebRequestHeaderTest.HttpWebRequest_KeepAlive_CorrectConnectionHeaderSent(Nullable`1 keepAlive)
2017-05-02 01:24:12,622: INFO: proc(54): run_and_log_output: Output:     System.Net.Tests.HttpWebRequestHeaderTest.HttpWebRequest_PreAuthenticateGetSet_Ok [FAIL]
2017-05-02 01:24:12,622: INFO: proc(54): run_and_log_output: Output:       System.Net.WebException : The operation has timed out
2017-05-02 01:24:12,622: INFO: proc(54): run_and_log_output: Output:       Stack Trace:
2017-05-02 01:24:12,622: INFO: proc(54): run_and_log_output: Output:            at System.Net.HttpWebRequest.GetResponse()
2017-05-02 01:24:12,622: INFO: proc(54): run_and_log_output: Output:         E:\A\_work\211\s\corefx\src\System.Net.Requests\tests\HttpWebRequestHeaderTest.cs(234,0): at System.Net.Tests.HttpWebRequestHeaderTest.HttpWebRequest_PreAuthenticateGetSet_Ok()
~~~","Tests failed: System.Net.Requests.Tests / System.Net.Tests.HttpWebRequestHeaderTest  Tests under ""System.Net.Requests.Tests"" failed to generate the test result.

Detail: https://mc.dot.net/#/product/netcore/master/source/official~2Fcorefx~2Fmaster~2F/ty",29833,davidsh,corefx
25611,System.Net.Tests.HttpWebRequestTest.KeepAlive_CorrectConnectionHeaderSent,"Looks like should be marked Conditional on `LocalServerAvailable`


```
xUnit.net console test runner (64-bit .NET Core)
Copyright (C) 2014 Outercurve Foundation.

Discovering: System.Net.Requests.Tests
Discovered:  System.Net.Requests.Tests
Starting:    System.Net.Requests.Tests
   System.Net.Tests.FtpWebRequestTest.Ftp_RenameFileSubDir_Success [SKIP]
      Condition(s) not met: \""LocalServerAvailable\""
   System.Net.Tests.FtpWebRequestTest.Ftp_LargeFile [SKIP]
      Condition(s) not met: \""LocalServerAvailable\""
   System.Net.Tests.FtpWebRequestTest.Ftp_CreateAndDelete [SKIP]
      Condition(s) not met: \""LocalServerAvailable\""
   System.Net.Tests.FtpWebRequestTest.Ftp_RenameFile [SKIP]
      Condition(s) not met: \""LocalServerAvailable\""
   System.Net.Tests.FtpWebRequestTest.Ftp_MakeAndRemoveDir_Success [SKIP]
      Condition(s) not met: \""LocalServerAvailable\""
   System.Net.Tests.FtpWebRequestTest.Ftp_AppendFile [SKIP]
      Condition(s) not met: \""LocalServerAvailable\""
   System.Net.Tests.HttpWebRequestTest.KeepAlive_CorrectConnectionHeaderSent(keepAlive: False) [FAIL]
      Assert.Contains() Failure
      Not found: ""Connection"": ""close""
      In value:  {""Method"":""GET"",""Url"":""/Echo.ashx"",""Headers"": {
          ""Connection"": ""Keep-Alive"",
          ""Via"": ""1.1 10.38.1.212 (McAfee Web Gateway 7.6.2.8.0.22994)"",
          ""Host"": ""corefx-net.cloudapp.net"",
          ""X-Forwarded-For"": ""10.228.198.226""
        },
        ""Cookies"": {},
        ""BodyContent"": """",
        ""BodyLength"": 0,
        ""SecureConnection"": false,
        ""ClientCertificatePresent"": false,
        ""ClientCertificate"": null
      }
      Stack Trace:
         /home/vmjenkins/workspace/Dotnet/build_corefx/src/System.Net.Requests/tests/HttpWebRequestTest.cs(457,0): at System.Net.Tests.HttpWebRequestTest.KeepAlive_CorrectConnectionHeaderSent(Nullable`1 keepAlive)
Finished:    System.Net.Requests.Tests
```","System.Net.Tests.HttpWebRequestTest.KeepAlive_CorrectConnectionHeaderSent  Looks like should be marked Conditional on `LocalServerAvailable`


```
xUnit.net console test runner (64-bit .NET Core)
Copyright (C) 2014 Outercurve Foundation.

Discoveri",29833,davidsh,corefx
29790,Fix getting attributes for sharing violation files,"Some files, such as the pagefile, refuse to allow you to get attributes directly.
You need to enumerate to get the attributes.

Enumerating is expensive, so we had changed from an opt-out to an opt-in. As
it took nearly a year to find this case, switching back to an opt-out with a
larger set of known cases where we get no value from trying again.

Also add an assert to flush out other error codes and scenarios.

Relates to #29782

Note that I couldn't repro the failure by manually locking our own file, but added cases nonetheless.

cc: @iSazonov","Fix getting attributes for sharing violation files  Some files, such as the pagefile, refuse to allow you to get attributes directly.
You need to enumerate to get the attributes.

Enumerating is expensive, so we had changed from an opt-out to an opt-in",29832,JeremyKuhne,corefx
26216,Can no longer get file attributes from exclusively locked files,"### Problem ###
IO.File.GetAttributes() doesn't return attributes for exclusively locked file like c:\pagefile.sys
IO.File.Exist() doesn't found such file (return false).

### Repo on PowerShell ###
```PowerShell
#########
[IO.File]::GetAttributes(""c:\pagefile.sys"")

Exception calling ""GetAttributes"" with ""1"" argument(s): ""The process cannot access the file 'c:\pagefile.sys' because it is being used by another process.""
At line:1 char:1
+ [IO.File]::GetAttributes(""c:\pagefile.sys"")
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ CategoryInfo          : NotSpecified: (:) [], MethodInvocationException
+ FullyQualifiedErrorId : IOException


$error[0].exception.InnerException | fl -Force

Message        : The process cannot access the file 'c:\pagefile.sys' because it is being used by another process.
Data           : {}
InnerException :
TargetSite     : System.IO.FileAttributes GetAttributes(System.String)
StackTrace     :    at System.IO.FileSystem.GetAttributes(String fullPath)
                    at CallSite.Target(Closure , CallSite , Type , String )
HelpLink       :
Source         : System.IO.FileSystem
HResult        : -2147024864


#########
[IO.File]::Exists(""c:\pagefile.sys"")

false
```

In PowerShell repo we have a workaround:
1. https://github.com/PowerShell/PowerShell/blob/5cbf1b43de52fe9025bf756990b1cc6eb4e694e9/src/System.Management.Automation/namespaces/FileSystemProvider.cs#L6994-L7013
2. https://github.com/PowerShell/PowerShell/blob/5cbf1b43de52fe9025bf756990b1cc6eb4e694e9/src/System.Management.Automation/engine/Utils.cs#L989-L1029

Without the workaround PowerShell doesn't show the file:
```powershell
dir c:\pagefile.sys -Hidden
```
but cmd.exe show the file:
```
C:\Users\sie>dir c:\pagefile.sys /AH
 Volume in drive C has no label.
 Volume Serial Number is 824F-BBDF

 Directory of c:\

04/18/2018  10:48 AM    11,811,160,064 pagefile.sys
               1 File(s) 11,811,160,064 bytes
               0 Dir(s)  236,808,941,568 bytes free
```
### Suggestion ###
I believe the issue should be fixed in CoreFX here
https://github.com/dotnet/corefx/blob/f25eb288a449010574a6e95fe298f3ad880ada1e/src/System.IO.FileSystem/src/System/IO/FileSystem.Windows.cs#L203-L223

ERROR_SHARING_VIOLATION should be added.","Can no longer get file attributes from exclusively locked files  ### Problem ###
IO.File.GetAttributes() doesn't return attributes for exclusively locked file like c:\pagefile.sys
IO.File.Exist() doesn't found such file (return false).

### Repo on Po",29832,JeremyKuhne,corefx
25782,[Uri] Fix IPv6 address format,"Here are the issues in Uri with IPv6 address we may want to fix:

1. **[Pending discussion]** `Uri.IdnHost` should include `[]` around IPv6 address.
    * Currently it returns `::1234`, it should return `[::1234]`.
2. [Originally done with PR dotnet/corefx#29829 but reverted with dotnet/corefx#30062]  `Uri.Host` LLA (Link-local address) IPv6 address doesn't contain `%number` part.
    * Currently it returns `[fe80::e077:c9a3:eeba:b8e9]`, it should return `[fe80::e077:c9a3:eeba:b8e9%18]`.
    * Note: `Uri.IdnHost` correctly contains the `%number` part.

If we choose to fix these problems, we can undo workarounds in dotnet/corefx#28740, dotnet/corefx#28578, dotnet/corefx#28849 and dotnet/corefx#28971.

/cc: @dotnet/ncl","[Uri] Fix IPv6 address format  Here are the issues in Uri with IPv6 address we may want to fix:

1. **[Pending discussion]** `Uri.IdnHost` should include `[]` around IPv6 address.
    * Currently it returns `::1234`, it should return `[::1234]`.
2. [O",29829,MarcoRossignoli,corefx
29769,Fix Uri.Host for IPv6 Link-local address,"contributes to #28863 

this PR address the second part of issue:

2)  `Uri.Host` LLA (Link-local address) IPv6 address doesn't contain `%number` part.
* Currently it returns `[fe80::e077:c9a3:eeba:b8e9]`, it should return `[fe80::e077:c9a3:eeba:b8e9%18]`.
* Note: `Uri.IdnHost` correctly contains the `%number` part.

cc: @rmkerr @caesar1995 @davidsh","Fix Uri.Host for IPv6 Link-local address  contributes to #28863 

this PR address the second part of issue:

2)  `Uri.Host` LLA (Link-local address) IPv6 address doesn't contain `%number` part.
* Currently it returns `[fe80::e077:c9a3:eeba:b8e9]`, it",29829,MarcoRossignoli,corefx
29818,"Revert ""Fix Uri.Host for IPv6 Link-local address (#29769)""","This reverts commit e1ded5ac59d5101a19ea549d19aa9532f2074239.

#29769 broke outerloop on both Windows and Linux, specifically the GetAsync_IPv6LinkLocalAddressUri_Success test with both the platform handlers and SocketsHttpHandler.

Fixes https://github.com/dotnet/corefx/issues/29812

cc: @rmkerr, @davidsh, @MarcoRossignoli","Revert ""Fix Uri.Host for IPv6 Link-local address (#29769)""  This reverts commit e1ded5ac59d5101a19ea549d19aa9532f2074239.

#29769 broke outerloop on both Windows and Linux, specifically the GetAsync_IPv6LinkLocalAddressUri_Success test with both the pla",29829,MarcoRossignoli,corefx
26224,[UWP] Many Http tests failing / hanging,"Many dozen of Http tests are failing on UAP test runs.  This is not showing up during PR/CI because the UWP leg only is building the product and test sources and not actually running any tests.  However, the test failures show up in Helix and also when run locally on a dev machine i.e.

```
build.cmd -framework:uap
cd src/System.Net.Http/tests/FunctionalTests
msbuild /t:rebuildandtest /p:TargetGroup=uap /p:Outerloop=true
```

For now, these tests will be disabled in bulk in order to get the test runs clean.","[UWP] Many Http tests failing / hanging  Many dozen of Http tests are failing on UAP test runs.  This is not showing up during PR/CI because the UWP leg only is building the product and test sources and not actually running any tests.  However, the test f",29803,davidsh,corefx
25404,[UWP] HttpClient: Bunch of UAP tests disabled with closed issue #20010,"There are a bunch of HttpClient tests disabled on UAP with a reference to dotnet/runtime#21834.  However, this issue is closed.  We should either change the tests to be disabled with a better issue/explanation, or reenable the tests.

","[UWP] HttpClient: Bunch of UAP tests disabled with closed issue #20010  There are a bunch of HttpClient tests disabled on UAP with a reference to dotnet/runtime#21834.  However, this issue is closed.  We should either change the tests to be disabled with",29803,davidsh,corefx
24845,Change EnsureSuccessStatusCode to not dispose response content,"Currently the `HttpResponseMessage.EnsureSuccessStatusCode` method always disposes the content of the response. The reason is explained in [a comment](https://github.com/dotnet/corefx/blob/bcc2940faeb58cc92a66c61ca404bed54a3a3bb3/src/System.Net.Http/src/System/Net/Http/HttpResponseMessage.cs#L152-L155):

```csharp
// Disposing the content should help users: If users call EnsureSuccessStatusCode(), an exception is
// thrown if the response status code is != 2xx. I.e. the behavior is similar to a failed request (e.g.
// connection failure). Users don't expect to dispose the content in this case: If an exception is
// thrown, the object is responsible fore cleaning up its state.
```

However, this isn't always helpful. It's frequent for web APIs to return details about the error in the response body. If I want to map the error to a specific domain exception, I might write something along these lines:

```csharp
private async Task<T> GetResponseAsync<T>(HttpRequestMessage request)
{
    using (var response = await _client.SendAsync(request))
    {
        try
        {
            response.EnsureSuccessStatusCode();
            return await response.Content.ReadAsAsync<T>();
        }
        catch (HttpRequestException ex)
        {
            var errorDetails = await response.Content.ReadAsAsync<ErrorDetails>();
            throw CreateDomainExceptionFromDetails(errorDetails, ex);
        }
    }
}

private Exception CreateDomainExceptionFromDetails(ErrorDetails errorDetails, Exception innerException)
{
    // Some logic based on the error details
    // ...
}
```

However, this doesn't work, because when I try to read the content in the `catch` block, the content is already disposed. So I need to read the content in the `try` block instead, before the call to `EnsureSuccessStatusCode`:

```csharp
private async Task<T> GetResponseAsync<T>(HttpRequestMessage request)
{
    using (var response = await _client.SendAsync(request))
    {
        string content = null;
        try
        {
            content = await response.Content.ReadAsStringAsync();
            response.EnsureSuccessStatusCode();
            return JsonConvert.DeserializeObject<T>(content);
        }
        catch (HttpRequestException ex) when (content != null)
        {
            var errorDetails = JsonConvert.DeserializeObject<ErrorDetails>(content);
            throw CreateDomainExceptionFromDetails(errorDetails, ex);
        }
    }
}
```

It's less intuitive and makes the code harder to read

An `EnsureSuccessStatusCode(bool disposeContent)` overload would be helpful in this case. It would let the user state that they're taking responsibility for disposing the content (in the exemple above, the content would be disposed when the response is disposed at the end of the `using` statement).

(I'm aware that I could just check the `IsSuccessStatusCode` property, but I want the ""normal"" `HttpRequestException` as the inner exception of my domain exception)

I'm willing to submit a pull request if the proposal is approved.",Change EnsureSuccessStatusCode to not dispose response content  Currently the `HttpResponseMessage.EnsureSuccessStatusCode` method always disposes the content of the response. The reason is explained in [a comment](https://github.com/dotnet/corefx/blob/bc,29795,davidsh,corefx
26174,System.Management.ManagementDateTimeConverter fail parsing on DateTime.MinValue,"The conversion from DateTime to Dmtf works fine even with DateTime.MinValue but if we parse the value back ( in my case ""00010101000000.000000+060"") it raise:

System.ArgumentOutOfRangeException: 'The added or subtracted value results in an un-representable DateTime.'

Step to reproduce the bug:

            var date = ManagementDateTimeConverter.ToDmtfDateTime(DateTime.MinValue);
            var parsed = ManagementDateTimeConverter.ToDateTime(date);","System.Management.ManagementDateTimeConverter fail parsing on DateTime.MinValue  The conversion from DateTime to Dmtf works fine even with DateTime.MinValue but if we parse the value back ( in my case ""00010101000000.000000+060"") it raise:

System.Argum",29774,pjanotti,corefx
27683,Fix `ManagementDateTimeConverter.ToDateTime` bug of using `TimeZone` class,Fix `ManagementDateTimeConverter.ToDateTime` bug of using `TimeZone` class. See https://github.com/dotnet/corefx/issues/27652 issue.,Fix `ManagementDateTimeConverter.ToDateTime` bug of using `TimeZone` class  Fix `ManagementDateTimeConverter.ToDateTime` bug of using `TimeZone` class. See https://github.com/dotnet/corefx/issues/27652 issue.,29774,pjanotti,corefx
28792,Enable faster invoke in interpreter,"The change follows up on several TODOs and commented out unfinished implementation.

In cases where it is possible, we can avoid expensive calls via reflection and use more efficient delegate-based thunks. These are also the most common scenarios. 
When optimized invocations are not possible (too many arguments, byref arguments, etc..) we still use reflection.

For the cases where we create thunks, there are small caches to hold the recently used ones - just to opportunistically avoid costs of creating thunk delegates again. That is particularly important when the thunks are created via Ref.Emit.

- [x] enable fast invoke pass
- [x] enable caching on reverse invoke (at the entry points to the interpreter lambdas)
- [x] enable fast invoker creation

","Enable faster invoke in interpreter  The change follows up on several TODOs and commented out unfinished implementation.

In cases where it is possible, we can avoid expensive calls via reflection and use more efficient delegate-based thunks. These are",29734,MichalStrehovsky,corefx
26142,Test failure: System.Composition.Lightweight.UnitTests.CustomerReportedMetadataBug/SampleServicesCorrectlyImported,"Opened on behalf of @Sunny-pu

The test `System.Composition.Lightweight.UnitTests.CustomerReportedMetadataBug/SampleServicesCorrectlyImported` has failed.

System.Reflection.MissingMetadataException : This operation cannot be carried out because metadata for the following object was removed for performance reasons:\
    \
      <unavailable>\
    \
    No further information is available. Rebuild in debug mode for better information.\
    \
    

        Stack Trace:

           at System.Reflection.Runtime.TypeInfos.RuntimeConstructedGenericTypeInfo.ConstructedGenericTypeTable.Factory($UnificationKey key) in f:\dd\ndp\fxcore\CoreRT\src\System.Private.Reflection.Core\src\System\Reflection\Runtime\General\TypeUnifier.cs:line 441
       at System.Collections.Concurrent.ConcurrentUnifierWKeyed$2<System.Reflection.Runtime.TypeInfos.RuntimeConstructedGenericTypeInfo.UnificationKey,System.__Canon>.GetOrAdd($UnificationKey key) in f:\dd\ndp\fxcore\CoreRT\src\Common\src\System\Collections\Concurrent\ConcurrentUnifierWKeyed.cs:line 136
       at System.Reflection.Runtime.TypeInfos.RuntimeTypeInfo.MakeGenericType(Type[] typeArguments) in f:\dd\ndp\fxcore\CoreRT\src\System.Private.Reflection.Core\src\System\Reflection\Runtime\TypeInfos\RuntimeTypeInfo.cs:line 472
       at System.Linq.Expressions.Interpreter.CallInstruction.GetHelperType(MethodInfo info, Type[] arrTypes) in E:\A\_work\4\s\corefx\src\System.Linq.Expressions\src\System\Linq\Expressions\Interpreter\CallInstruction.Generated.cs:line 202
       at System.Linq.Expressions.Interpreter.CallInstruction.SlowCreate(MethodInfo info, ParameterInfo[] pis) in E:\A\_work\4\s\corefx\src\System.Linq.Expressions\src\System\Linq\Expressions\Interpreter\CallInstruction.cs:line 238
       at System.Linq.Expressions.Interpreter.CallInstruction.Create(MethodInfo info, ParameterInfo[] parameters) in E:\A\_work\4\s\corefx\src\System.Linq.Expressions\src\System\Linq\Expressions\Interpreter\CallInstruction.cs:line 94
       at System.Linq.Expressions.Interpreter.LightCompiler.CompileMethodCallExpression($Expression object, MethodInfo method, $IArgumentProvider arguments) in E:\A\_work\4\s\corefx\src\System.Linq.Expressions\src\System\Linq\Expressions\Interpreter\LightCompiler.cs:line 2197
       at System.Linq.Expressions.Interpreter.LightCompiler.CompileMethodCallExpression($Expression expr) in E:\A\_work\4\s\corefx\src\System.Linq.Expressions\src\System\Linq\Expressions\Interpreter\LightCompiler.cs:line 2141
       at System.Linq.Expressions.Interpreter.LightCompiler.CompileNoLabelPush($Expression expr) in E:\A\_work\4\s\corefx\src\System.Linq.Expressions\src\System\Linq\Expressions\Interpreter\LightCompiler.cs:line 3079
       at System.Linq.Expressions.Interpreter.LightCompiler.Compile($Expression expr) in E:\A\_work\4\s\corefx\src\System.Linq.Expressions\src\System\Linq\Expressions\Interpreter\LightCompiler.cs:line 3115
       at System.Linq.Expressions.Interpreter.LightCompiler.CompileAddress($Expression node, Int32 index) in E:\A\_work\4\s\corefx\src\System.Linq.Expressions\src\System\Linq\Expressions\Interpreter\LightCompiler.cs:line 2361
       at System.Linq.Expressions.Interpreter.LightCompiler.CompileMemberAssignment(Boolean asVoid, MemberInfo refMember, $Expression value, Boolean forBinding) in E:\A\_work\4\s\corefx\src\System.Linq.Expressions\src\System\Linq\Expressions\Interpreter\LightCompiler.cs:line 672
       at System.Linq.Expressions.Interpreter.LightCompiler.CompileMemberAssignment($BinaryExpression node, Boolean asVoid) in E:\A\_work\4\s\corefx\src\System.Linq.Expressions\src\System\Linq\Expressions\Interpreter\LightCompiler.cs:line 658
       at System.Linq.Expressions.Interpreter.LightCompiler.CompileAssignBinaryExpression($Expression expr, Boolean asVoid) in E:\A\_work\4\s\corefx\src\System.Linq.Expressions\src\System\Linq\Expressions\Interpreter\LightCompiler.cs:line 740
       at System.Linq.Expressions.Interpreter.LightCompiler.CompileAsVoid($Expression expr) in E:\A\_work\4\s\corefx\src\System.Linq.Expressions\src\System\Linq\Expressions\Interpreter\LightCompiler.cs:line 2992
       at System.Linq.Expressions.Interpreter.LightCompiler.CompileBlockStart($BlockExpression node) in E:\A\_work\4\s\corefx\src\System.Linq.Expressions\src\System\Linq\Expressions\Interpreter\LightCompiler.cs:line 556
       at System.Linq.Expressions.Interpreter.LightCompiler.CompileBlockExpression($Expression expr, Boolean asVoid) in E:\A\_work\4\s\corefx\src\System.Linq.Expressions\src\System\Linq\Expressions\Interpreter\LightCompiler.cs:line 520
       at System.Linq.Expressions.Interpreter.LightCompiler.CompileNoLabelPush($Expression expr) in E:\A\_work\4\s\corefx\src\System.Linq.Expressions\src\System\Linq\Expressions\Interpreter\LightCompiler.cs:line 3094
       at System.Linq.Expressions.Interpreter.LightCompiler.CompileTop($LambdaExpression node) in E:\A\_work\4\s\corefx\src\System.Linq.Expressions\src\System\Linq\Expressions\Interpreter\LightCompiler.cs:line 318
       at System.Linq.Expressions.Expression$1<System.__Canon>.Compile(Boolean preferInterpretation) in E:\A\_work\4\s\corefx\src\System.Linq.Expressions\src\System\Linq\Expressions\LambdaExpression.cs:line 211
       at System.Linq.Expressions.Expression$1<System.__Canon>.Compile() in E:\A\_work\4\s\corefx\src\System.Linq.Expressions\src\System\Linq\Expressions\LambdaExpression.cs:line 192
       at System.Composition.Hosting.Providers.Metadata.MetadataViewProvider.GetMetadataViewProvider<System.__UniversalCanon>() in E:\A\_work\4\s\corefx\src\System.Composition.Hosting\src\System\Composition\Hosting\Providers\Metadata\MetadataViewProvider.cs:line 69
       at System.Composition.Hosting.Providers.Lazy.LazyWithMetadataExportDescriptorProvider.GetLazyDefinitions<System.__UniversalCanon, System.__UniversalCanon>($CompositionContract lazyContract, $DependencyAccessor definitionAccessor) in E:\A\_work\4\s\corefx\src\System.Composition.Hosting\src\System\Composition\Hosting\Providers\Lazy\LazyWithMetadataExportDescriptorProvider.cs:line 31
       at System.Func$3<System.UInt32,System.Int16,System.__Canon>.InvokeOpenStaticThunk(UInt32 arg1, Int16 arg2) in InvokeOpenStaticThunk:line 16707566
       at System.Composition.Hosting.Core.CompositeActivator.Invoke($LifetimeContext context, $CompositionOperation operation) in Invoke:line 16707566
       at System.Composition.Hosting.Providers.Lazy.LazyWithMetadataExportDescriptorProvider.GetExportDescriptors($CompositionContract exportKey, $DependencyAccessor definitionAccessor) in E:\A\_work\4\s\corefx\src\System.Composition.Hosting\src\System\Composition\Hosting\Providers\Lazy\LazyWithMetadataExportDescriptorProvider.cs:line 26
       at System.Composition.Hosting.Core.ExportDescriptorRegistryUpdate.GetPromises($CompositionContract contract) in E:\A\_work\4\s\corefx\src\System.Composition.Hosting\src\System\Composition\Hosting\Core\ExportDescriptorRegistryUpdate.cs:line 147
       at System.Composition.Hosting.Core.DependencyAccessor.ResolveDependencies(Object site, $CompositionContract contract, Boolean isPrerequisite) in E:\A\_work\4\s\corefx\src\System.Composition.Hosting\src\System\Composition\Hosting\Core\DependencyAccessor.cs:line 31
       at System.Composition.Hosting.Providers.ImportMany.ImportManyExportDescriptorProvider.<>c__DisplayClass3_0$1<System.__UniversalCanon>.<GetImportManyDescriptor>b__0() in E:\A\_work\4\s\corefx\src\System.Composition.Hosting\src\System\Composition\Hosting\Providers\ImportMany\ImportManyExportDescriptorProvider.cs:line 46
       at Internal.Runtime.Augments.RuntimeAugments.CallDescrWorker(IntPtr callDescr) in f:\dd\ndp\fxcore\CoreRT\src\System.Private.CoreLib\src\Internal\Runtime\Augments\RuntimeAugments.cs:line 969
       at Internal.Runtime.TypeLoader.CallConverterThunk.InvokeTarget(Void* allocatedStackBuffer, $CallConversionParameters conversionParams) in InvokeTarget:line 16707566
       at Internal.Runtime.Augments.RuntimeAugments.RunFunctionWithConservativelyReportedBufferInternal<Internal.Runtime.TypeLoader.CallConversionParameters>(Int32 cbBuffer, IntPtr pfnTargetToInvoke, $CallConversionParameters context, ConservativelyReportedRegionDesc regionDesc) in RunFunctionWithConservativelyReportedBufferInternal:line 15732480
       at Internal.Runtime.Augments.RuntimeAugments.RunFunctionWithConservativelyReportedBuffer<Internal.Runtime.TypeLoader.CallConversionParameters>(Int32 cbBuffer, IntPtr pfnTargetToInvoke, $CallConversionParameters context) in RunFunctionWithConservativelyReportedBuffer:line 16707566
       at Internal.Runtime.TypeLoader.CallConverterThunk.CallConversionThunk(IntPtr callerTransitionBlockParam, IntPtr callConversionId) in CallConversionThunk:line 16707566
       at System.Composition.Hosting.Core.ExportDescriptorPromise.<>c__DisplayClass6_0.<.ctor>b__0() in E:\A\_work\4\s\corefx\src\System.Composition.Hosting\src\System\Composition\Hosting\Core\ExportDescriptorPromise.cs:line 48
       at System.Func$1<System.__Canon>.Invoke() in Invoke:line 16707566
       at System.Lazy$1<System.__Canon>.ViaFactory$catch$0() in f:\dd\ndp\fxcore\CoreRT\src\System.Private.CoreLib\shared\System\Lazy.cs:line 330
       at System.Lazy$1<System.__Canon>.CreateValue() in f:\dd\ndp\fxcore\CoreRT\src\System.Private.CoreLib\shared\System\Lazy.cs:line 408
       at System.Composition.Hosting.Core.ExportDescriptorRegistryUpdate.CheckTarget($CompositionDependency dependency, $HashSet$1<$ExportDescriptorPromise> checked, $Stack$1<$CompositionDependency> checking) in E:\A\_work\4\s\corefx\src\System.Composition.Hosting\src\System\Composition\Hosting\Core\ExportDescriptorRegistryUpdate.cs:line 73
       at System.Composition.Hosting.Core.ExportDescriptorRegistryUpdate.Execute($CompositionContract contract) in E:\A\_work\4\s\corefx\src\System.Composition.Hosting\src\System\Composition\Hosting\Core\ExportDescriptorRegistryUpdate.cs:line 42
       at System.Composition.Hosting.Core.ExportDescriptorRegistry.TryGetSingleForExport($CompositionContract exportKey, $ExportDescriptor& defaultForExport) in E:\A\_work\4\s\corefx\src\System.Composition.Hosting\src\System\Composition\Hosting\Core\ExportDescriptorRegistry.cs:line 32
       at System.Composition.Hosting.Core.LifetimeContext.TryGetExport($CompositionContract contract, Object& export) in E:\A\_work\4\s\corefx\src\System.Composition.Hosting\src\System\Composition\Hosting\Core\LifetimeContext.cs:line 196
       at System.Composition.Hosting.CompositionHost.TryGetExport($CompositionContract contract, Object& export) in E:\A\_work\4\s\corefx\src\System.Composition.Hosting\src\System\Composition\Hosting\CompositionHost.cs:line 76
       at System.Composition.CompositionContextExtensions.SatisfyImportsInternal($CompositionContext exportProvider, Object objectWithLooseImports, $AttributedModelProvider conventions) in E:\A\_work\4\s\corefx\src\System.Composition.TypedParts\src\System\Composition\CompositionContextExtensions.cs:line 61
       at System.Composition.Lightweight.UnitTests.CustomerReportedMetadataBug.SampleServicesCorrectlyImported() in E:\A\_work\4\s\corefx\src\System.Composition\tests\CustomerReportedMetadataBug.cs:line 49
       at _$ILCT$.$ILT$ReflectionDynamicInvoke$.InvokeRetV(Object thisPtr, IntPtr methodToCall, ArgSetupState argSetupState, Boolean targetIsThisCall)
       at System.InvokeUtils.CalliIntrinsics.Call(IntPtr dynamicInvokeHelperMethod, Object thisPtr, IntPtr methodToCall, ArgSetupState argSetupState, Boolean isTargetThisCall)
       at System.InvokeUtils.CallDynamicInvokeMethod(Object thisPtr, IntPtr methodToCall, Object thisPtrDynamicInvokeMethod, IntPtr dynamicInvokeHelperMethod, IntPtr dynamicInvokeHelperGenericDictionary, Object targetMethodOrDelegate, Object[] parameters, BinderBundle binderBundle, Boolean wrapInTargetInvocationException, Boolean invokeMethodHelperIsThisCall, Boolean methodToCallIsThisCall) in CallDynamicInvokeMethod:line 16707566
    
Build : Master - 20180511.01 (UWP ILC Tests)
Failing configurations:
- Windows.10.Amd64.ClientRS3-x86
  - Release
- Windows.10.Amd64.ClientRS3-x64
  - Release

Details:
https://mc.dot.net/#/product/netcore/master/source/official~2Fcorefx~2Fmaster~2F/type/test~2Ffunctional~2Filc~2F/build/20180511.01/workItem/System.Composition.Tests","Test failure: System.Composition.Lightweight.UnitTests.CustomerReportedMetadataBug/SampleServicesCorrectlyImported  Opened on behalf of @Sunny-pu

The test `System.Composition.Lightweight.UnitTests.CustomerReportedMetadataBug/SampleServicesCorrectlyImpo",29734,MichalStrehovsky,corefx
26063,[Test] SendAsync_ExpectedDiagnosticSynchronousExceptionActivityLogging is not testing synchronous exception,"The purpose for this test is to verify if synchronous exception activity will be logged for `DiagnosticsHandler` SendAsync/GetAsync.
https://github.com/dotnet/corefx/blob/cebcf436358600a4808656b142a74f57d1e8f6f0/src/System.Net.Http/tests/FunctionalTests/DiagnosticsTests.cs#L505-L519

However, it's not forcing a synchronous exception for SocketsHttpHandler: https://github.com/dotnet/corefx/blob/master/src/System.Net.Http/src/System/Net/Http/SocketsHttpHandler/SocketsHttpHandler.cs#L339-L343
And for PlatformHandler, because of dotnet/corefx#29337, HttpClientHandler will intercept the Exception in CookieContainer setter, before passing the value to SendAsync.

We do have synchronous exception in the SendAsync path, and we need to rework this test (by using Reflection to force the exception, for example).","[Test] SendAsync_ExpectedDiagnosticSynchronousExceptionActivityLogging is not testing synchronous exception  The purpose for this test is to verify if synchronous exception activity will be logged for `DiagnosticsHandler` SendAsync/GetAsync.
https://gith",29701,caesar-chen,corefx
29337,Unify setting null CookieContainer behavior on HttpClientHandler,"For HttpClientHandler layer (above the WinHttpHandler layer on Windows), we should be consistent and throw the exception in the CookieContainer setter when null value is provided, to match .NET Framework's behavior.
This would keep the same behavior across all platforms for the setter of the HttpClientHandler.CookieContainer property.

Close: #3205","Unify setting null CookieContainer behavior on HttpClientHandler  For HttpClientHandler layer (above the WinHttpHandler layer on Windows), we should be consistent and throw the exception in the CookieContainer setter when null value is provided, to match",29701,caesar-chen,corefx
24976,[Cookie] CurlHandler: container cookies are not sent if you add a Cookie header to the header collection,"If you add a Cookie header via

```csharp
    requestMessage.Headers.Add(""Cookie"", ""A=1"");
```

This causes cookies from the cookie container to not be sent.

WinHttpHandler appends the cookies from the cookie container to the specified Cookie: header.","[Cookie] CurlHandler: container cookies are not sent if you add a Cookie header to the header collection  If you add a Cookie header via

```csharp
    requestMessage.Headers.Add(""Cookie"", ""A=1"");
```

This causes cookies from the cookie container t",29701,caesar-chen,corefx
20879,Apparently dead sources in S.Diagnostics.Tracing,"In a quick look there seems lots of dead code in tracing. Should any of it be being compiled, or possibly deleted? 
@brianrob 
```
src/Common/tests/System/Diagnostics/Tracing/ConsoleEventListener.cs
src/System.Diagnostics.Tracing/src/System/Diagnostics/Tracing/ActivityTracker.cs
src/System.Diagnostics.Tracing/src/System/Diagnostics/Tracing/EventActivityOptions.cs
src/System.Diagnostics.Tracing/src/System/Diagnostics/Tracing/EventProvider.cs
src/System.Diagnostics.Tracing/src/System/Diagnostics/Tracing/EventSource.cs
src/System.Diagnostics.Tracing/src/System/Diagnostics/Tracing/EventSourceException.cs
src/System.Diagnostics.Tracing/src/System/Diagnostics/Tracing/EventSource_ProjectN.cs
src/System.Diagnostics.Tracing/src/System/Diagnostics/Tracing/StubEnvironment.cs
src/System.Diagnostics.Tracing/src/System/Diagnostics/Tracing/TraceLogging/ArrayTypeInfo.cs
src/System.Diagnostics.Tracing/src/System/Diagnostics/Tracing/TraceLogging/ConcurrentSet.cs
src/System.Diagnostics.Tracing/src/System/Diagnostics/Tracing/TraceLogging/ConcurrentSetItem.cs
src/System.Diagnostics.Tracing/src/System/Diagnostics/Tracing/TraceLogging/DataCollector.cs
src/System.Diagnostics.Tracing/src/System/Diagnostics/Tracing/TraceLogging/EmptyStruct.cs
src/System.Diagnostics.Tracing/src/System/Diagnostics/Tracing/TraceLogging/EnumHelper.cs
src/System.Diagnostics.Tracing/src/System/Diagnostics/Tracing/TraceLogging/EnumerableTypeInfo.cs
src/System.Diagnostics.Tracing/src/System/Diagnostics/Tracing/TraceLogging/EventDataAttribute.cs
src/System.Diagnostics.Tracing/src/System/Diagnostics/Tracing/TraceLogging/EventFieldAttribute.cs
src/System.Diagnostics.Tracing/src/System/Diagnostics/Tracing/TraceLogging/EventFieldFormat.cs
src/System.Diagnostics.Tracing/src/System/Diagnostics/Tracing/TraceLogging/EventIgnoreAttribute.cs
src/System.Diagnostics.Tracing/src/System/Diagnostics/Tracing/TraceLogging/EventPayload.cs
src/System.Diagnostics.Tracing/src/System/Diagnostics/Tracing/TraceLogging/EventSourceActivity.cs
src/System.Diagnostics.Tracing/src/System/Diagnostics/Tracing/TraceLogging/EventSourceOptions.cs
src/System.Diagnostics.Tracing/src/System/Diagnostics/Tracing/TraceLogging/FieldMetadata.cs
src/System.Diagnostics.Tracing/src/System/Diagnostics/Tracing/TraceLogging/InvokeTypeInfo.cs
src/System.Diagnostics.Tracing/src/System/Diagnostics/Tracing/TraceLogging/NameInfo.cs
src/System.Diagnostics.Tracing/src/System/Diagnostics/Tracing/TraceLogging/PropertyAnalysis.cs
src/System.Diagnostics.Tracing/src/System/Diagnostics/Tracing/TraceLogging/SimpleEventTypes.cs
src/System.Diagnostics.Tracing/src/System/Diagnostics/Tracing/TraceLogging/SimpleTypeInfos.cs
src/System.Diagnostics.Tracing/src/System/Diagnostics/Tracing/TraceLogging/Statics.cs
src/System.Diagnostics.Tracing/src/System/Diagnostics/Tracing/TraceLogging/TraceLoggingDataCollector.cs
src/System.Diagnostics.Tracing/src/System/Diagnostics/Tracing/TraceLogging/TraceLoggingDataType.cs
src/System.Diagnostics.Tracing/src/System/Diagnostics/Tracing/TraceLogging/TraceLoggingEventSource.cs
src/System.Diagnostics.Tracing/src/System/Diagnostics/Tracing/TraceLogging/TraceLoggingEventTraits.cs
src/System.Diagnostics.Tracing/src/System/Diagnostics/Tracing/TraceLogging/TraceLoggingEventTypes.cs
src/System.Diagnostics.Tracing/src/System/Diagnostics/Tracing/TraceLogging/TraceLoggingMetadataCollector.cs
src/System.Diagnostics.Tracing/src/System/Diagnostics/Tracing/TraceLogging/TraceLoggingTypeInfo.cs
src/System.Diagnostics.Tracing/src/System/Diagnostics/Tracing/TraceLogging/TypeAnalysis.cs
src/System.Diagnostics.Tracing/src/System/Diagnostics/Tracing/Winmeta.cs
src/System.Diagnostics.Tracing/tests/BasicEventSourceTest/TestsLowTrust.cs
src/System.Diagnostics.Tracing/tests/CustomEventSources/EventSourceNamedEventSource.cs
src/System.Diagnostics.Tracing/tests/CustomEventSources/EventSourceWithInheritance.cs
src/System.Diagnostics.Tracing/tests/EvtSrcForReflection/EsrResources.Designer.cs
src/System.Diagnostics.Tracing/tests/EvtSrcForReflection/EventSourceForReflection.cs
```

Perhaps these also?
```
Common/src/Interop/Windows/advapi32/Interop.EventRegister.cs
Common/src/Interop/Windows/advapi32/Interop.EventSetInformation.cs
Common/src/Interop/Windows/advapi32/Interop.EventUnregister.cs
Common/src/Interop/Windows/advapi32/Interop.EventWrite.cs
Common/src/Interop/Windows/advapi32/Interop.EventWriteTransfer.cs
```","Apparently dead sources in S.Diagnostics.Tracing  In a quick look there seems lots of dead code in tracing. Should any of it be being compiled, or possibly deleted? 
@brianrob 
```
src/Common/tests/System/Diagnostics/Tracing/ConsoleEventListener.cs
sr",29665,stephentoub,corefx
13868,Fix typos in comments,"I've found some typos in comments in various places, I'll do a pull request soon (created issue as per contributing guidelines).","Fix typos in comments  I've found some typos in comments in various places, I'll do a pull request soon (created issue as per contributing guidelines).",28540,maryamariyan,corefx
17288,Change 10 sec timeout in ServiceControllerTests.cs to 30 sec,"Change 10 sec timeout in ServiceControllerTests.cs to 30 sec

File: corefx / src / System.ServiceProcess.ServiceController / tests / System.ServiceProcess.ServiceController.Tests / ServiceControllerTests.cs","Change 10 sec timeout in ServiceControllerTests.cs to 30 sec  Change 10 sec timeout in ServiceControllerTests.cs to 30 sec

File: corefx / src / System.ServiceProcess.ServiceController / tests / System.ServiceProcess.ServiceController.Tests / ServiceCon",28540,maryamariyan,corefx
25422,MatchingRefApiCompat issues in System.Security.Principal.Windows,"See baseline file
https://github.com/dotnet/corefx/blob/master/src/System.Security.Principal.Windows/src/MatchingRefApiCompatBaseline.txt

We should do one of the following:
1. Expose the APIs publicly in the reference assembly
2. Make the APIs in the implementation internal
3. Add a comment to the baseline file why you cannot do either (1) or (2) and keep them baselined.

See PR https://github.com/dotnet/corefx/pull/27881/ for extra context.","MatchingRefApiCompat issues in System.Security.Principal.Windows  See baseline file
https://github.com/dotnet/corefx/blob/master/src/System.Security.Principal.Windows/src/MatchingRefApiCompatBaseline.txt

We should do one of the following:
1. Expose t",28526,bartonjs,corefx
20972,MembersMustExist: System.Security.Principal,"I am currently looking into differences between Core and Desktop and opening this issue as a child of https://github.com/dotnet/corefx/issues/15255#issuecomment-291137517

The following members are missing in corefx but are available in netfx:

```
MembersMustExist : Member 'System.Security.Principal.IdentityReferenceCollection.IsReadOnly.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Security.Principal.WindowsIdentity..ctor(System.IntPtr, System.String, System.Security.Principal.WindowsAccountType)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Security.Principal.WindowsIdentity..ctor(System.IntPtr, System.String, System.Security.Principal.WindowsAccountType, System.Boolean)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Security.Principal.WindowsIdentity..ctor(System.Security.Principal.WindowsIdentity)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Security.Principal.WindowsIdentity..ctor(System.String, System.String)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Security.Principal.WindowsIdentity.DeviceClaims.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Security.Principal.WindowsIdentity.Impersonate()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Security.Principal.WindowsIdentity.Impersonate(System.IntPtr)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Security.Principal.WindowsIdentity.UserClaims.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Security.Principal.WindowsPrincipal.DeviceClaims.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Security.Principal.WindowsPrincipal.UserClaims.get()' does not exist in the implementation but it does exist in the contract.
```

@bartonjs @steveharter: It is possible / Does it make sense to port these members to Core? They live in System.Security.Principal.Windows. https://apisof.net/catalog/System.Security.Principal.IdentityReferenceCollection","MembersMustExist: System.Security.Principal  I am currently looking into differences between Core and Desktop and opening this issue as a child of https://github.com/dotnet/corefx/issues/15255#issuecomment-291137517

The following members are missing in",28526,bartonjs,corefx
20647,Some System.Security.Principal types are missing members present in Desktop,"The following members are on types implemented in .NET Core. However on desktop in 4.5+ they have more members. The members below are missing from Core. 

The problem with this situation is
- it defies user expectations that if a type X exists, code from other platforms that use X will work on .NET Core: instead they have to reason about individual members on X
- in some cases it cannot be fixed without servicing -- for instance methods we could supply a package with extension methods, but it would not be binary-compatible as different type identity

I didn't look at usage data. Any that are not be technically possible on Core in ideally would exist but throw PlatformNotSupportedException. Even if we don't have time to implement them, it's potentially valuable to do that (allows compile to succeed, for a runtime path that may not be followed). 

This is not a NS2.0 issue. The types are not in NS2.0

```
MembersMustExist : Member 'System.Security.Principal.IdentityReferenceCollection.IsReadOnly.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Security.Principal.WindowsIdentity..ctor(System.IntPtr, System.String, System.Security.Principal.WindowsAccountType)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Security.Principal.WindowsIdentity..ctor(System.IntPtr, System.String, System.Security.Principal.WindowsAccountType, System.Boolean)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Security.Principal.WindowsIdentity..ctor(System.Security.Principal.WindowsIdentity)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Security.Principal.WindowsIdentity..ctor(System.String, System.String)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Security.Principal.WindowsIdentity.DeviceClaims.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Security.Principal.WindowsIdentity.Impersonate()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Security.Principal.WindowsIdentity.Impersonate(System.IntPtr)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Security.Principal.WindowsIdentity.UserClaims.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Security.Principal.WindowsPrincipal.DeviceClaims.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Security.Principal.WindowsPrincipal.UserClaims.get()' does not exist in the implementation but it does exist in the contract.
```
also
```

MembersMustExist : Member 'System.Security.SecurityContext.SuppressFlow()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Security.SecurityContext.SuppressFlowWindowsIdentity()' does not exist in the implementation but it does exist in the contract
```

For completeness, these relevant types are missing:
```
TypesMustExist : Type 'System.Security.Principal.WindowsAccountType' does not exist in the implementation but it does exist in the contract.
TypesMustExist : Type 'System.Security.Principal.WindowsImpersonationContext' does not exist in the implementation but it does exist in the contract.
```","Some System.Security.Principal types are missing members present in Desktop  The following members are on types implemented in .NET Core. However on desktop in 4.5+ they have more members. The members below are missing from Core. 

The problem with this",28526,bartonjs,corefx
10219,MEF2 throws a System.TypeLoadException,"Make sure the typeArguments follow the generic type parameters
constraints.
If not, then the part is not a match and must be ignored.
Otherwise, _partType.MakeGenericType throws a System.TypeLoadException.
(Unlike MEF2, MEF on the full .NET framework filters correctly and
ignores parts that do not match the constraints, so this fix makes the
behavior the same in both versions).","MEF2 throws a System.TypeLoadException  Make sure the typeArguments follow the generic type parameters
constraints.
If not, then the part is not a match and must be ignored.
Otherwise, _partType.MakeGenericType throws a System.TypeLoadException.
(Unli",28483,maryamariyan,corefx
23356,"System.Composition v1.1.0 no exports found when using ""where"" clause in exported interface","Example:

    public interface IMefCollection
    {
        void WriteTypeNameOfSecondParam();
    }

    public interface IMefCollection<TC,TP> : IList<TC>, IMefCollection   where TC : TP
    {
    }

    [Export(typeof(IMefCollection<,>))]
    public class MefCollection<TC, TP> : ObservableCollection<TC>, IMefCollection<TC,TP>   where TC : TP
    {
        public void WriteTypeNameOfSecondParam()
        {
            Console.WriteLine(""Type: "" + typeof(TP).ToString());
        }
    }

Works well with system.composition version 1.0.31. 

With version 1.1.0 no exports are found until where clause is removed.
","System.Composition v1.1.0 no exports found when using ""where"" clause in exported interface  Example:

    public interface IMefCollection
    {
        void WriteTypeNameOfSecondParam();
    }

    public interface IMefCollection<TC,TP> : IList<TC>",28483,maryamariyan,corefx
19476,Improve test coverage for List..ctor(IEnumerable<T>) and AddRange,"In conjunction with the changes at: dotnet/coreclr#8306. In particular, it doesn't look like there are tests exercising the path where `this == c` (where `c` is the collection to be added) in https://github.com/dotnet/corefx/blob/master/src/System.Collections/tests/Generic/List/List.Generic.Tests.AddRange.cs. So code coverage can probably be improved.","Improve test coverage for List..ctor(IEnumerable<T>) and AddRange  In conjunction with the changes at: dotnet/coreclr#8306. In particular, it doesn't look like there are tests exercising the path where `this == c` (where `c` is the collection to be added)",28465,johnnyRose,corefx
23345,Code coverage for System.Private.CoreLib is broken in CI,"It appears we're no longer able to get code coverage of System.Private.CoreLib, even when using CoreCLROverridePath, even when using `set COMPlus_ZapDisable=1`.

cc: @mellinoe, @danmosemsft","Code coverage for System.Private.CoreLib is broken in CI  It appears we're no longer able to get code coverage of System.Private.CoreLib, even when using CoreCLROverridePath, even when using `set COMPlus_ZapDisable=1`.

cc: @mellinoe, @danmosemsft",28465,johnnyRose,corefx
24780,UTF32Encoding and XmlTransformation when ByteOrderMark is set to false still contains the mark on .NET Core 2,"I've been updating Cake to be .NET Standard 2.0 and run on `netcoreapp2.0` here: https://github.com/cake-build/cake/pull/1812

There was a battery of XML tests that were full framework only that I enabled for `netstandard2.0` because they now exist on that footprint.  There's one problem test that works still on `net46`/`net461` but not on `netcoreapp2.0`

```csharp
            [Fact]
            public void Should_Transform_Xml_String_And_Xsl_String_To_Result_String_With_Utf32Xml_Declaration()
            {
                // Given
                var xml = Resources.XmlTransformation_Xml;
                var xsl = Resources.XmlTransformation_Xsl;
                var settings = new XmlTransformationSettings
                {
                    Encoding = new UTF32Encoding(false, false, true)
                };

                // When
                var result = string.Concat(XmlTransformation.Transform(xsl, xml, settings).Take(39));

                // Then
                Assert.Equal(""<?xml version=\""1.0\"" encoding=\""utf-32\""?>"", result);
            }
```

I can't tell if it's just an issue with `UTF32Encoding` (I don't believe so) or something else in the XML Transform.","UTF32Encoding and XmlTransformation when ByteOrderMark is set to false still contains the mark on .NET Core 2  I've been updating Cake to be .NET Standard 2.0 and run on `netcoreapp2.0` here: https://github.com/cake-build/cake/pull/1812

There was a bat",28440,clarkis117,corefx
25549,Test failure: System.Xml.Tests.XmlWriterTests_Encoding/WriteWithUtf32EncodingNoBom,"Opened on behalf of @Sunny-pu

The test `System.Xml.Tests.XmlWriterTests_Encoding/WriteWithUtf32EncodingNoBom` has failed.

System.PlatformNotSupportedException : Compilation of XSLT is not supported on this platform.

        Stack Trace:

           at System.Xml.Xsl.XslCompiledTransform.CompileQilToMsil(XsltSettings settings) in E:\A\_work\14\s\corefx\src\System.Private.Xml\src\System\Xml\Xslt\XslCompiledTransform.cs:line 204
       at System.Xml.Xsl.XslCompiledTransform.LoadInternal(Object stylesheet, XsltSettings settings, XmlResolver stylesheetResolver) in E:\A\_work\14\s\corefx\src\System.Private.Xml\src\System\Xml\Xslt\XslCompiledTransform.cs:line 172
       at System.Xml.Xsl.XslCompiledTransform.Load(XmlReader stylesheet) in E:\A\_work\14\s\corefx\src\System.Private.Xml\src\System\Xml\Xslt\XslCompiledTransform.cs:line 107
       at System.Xml.Tests.XmlWriterTests_Encoding.WriteWithUtf32EncodingNoBom() in E:\A\_work\14\s\corefx\src\System.Private.Xml\tests\XmlWriter\WriteWithEncoding.cs:line 69
Build : ProdCon - Master - 20180321.01 (UWP F5 Tests)
Failing configurations:
- Windows.10.Arm64-arm
  - Release
- Windows.10.Amd64.ClientRS3-x64
  - Release
- Windows.10.Amd64.ClientRS3-x86
  - Release

Details:
https://mc.dot.net/#/product/netcore/prodconmaster/source/prodcon~2Fcorefx~2Fmaster~2F/type/test~2Ffunctional~2Fuwp~2F/build/20180321.01/workItem/System.Xml.RW.XmlWriter.Tests/analysis/xunit/System.Xml.Tests.XmlWriterTests_Encoding~2FWriteWithUtf32EncodingNoBom","Test failure: System.Xml.Tests.XmlWriterTests_Encoding/WriteWithUtf32EncodingNoBom  Opened on behalf of @Sunny-pu

The test `System.Xml.Tests.XmlWriterTests_Encoding/WriteWithUtf32EncodingNoBom` has failed.

System.PlatformNotSupportedException : Comp",28440,clarkis117,corefx
24944,Adopt new dotnet parameter conversion in sgen,"user -- instead of /
e.g. ""--help"" instead of ""/help""","Adopt new dotnet parameter conversion in sgen  user -- instead of /
e.g. ""--help"" instead of ""/help""",28439,jiayi11,corefx
27332,Update sgen usage and --parameters,"#26901 
#26902 
@huanwu  @zhenlan  @mconnew","Update sgen usage and --parameters  #26901 
#26902 
@huanwu  @zhenlan  @mconnew",28439,jiayi11,corefx
25605,Test failure: PlatformHandler_HttpProtocolTests / GetAsync_Chunked_VaryingSizeChunks_ReceivedCorrectly,"Discovered this while running System.Net.Http Outerloop tests:

```
System.Net.Http.Functional.Tests.PlatformHandler_HttpProtocolTests.GetAsync_Chunked_VaryingSizeChunks_ReceivedCorrectly(maxChunkSize: 1, lineEnding: \""\\r
  \\n\"", useCopyToAsync: True) [FAIL]
        System.IO.IOException : The read operation failed, see inner exception.
        ---- System.Net.Http.WinHttpException : Error 12030 calling WinHttpQueryDataAvailable, 'The connection with the server was terminated abnormally'.
        Stack Trace:
```","Test failure: PlatformHandler_HttpProtocolTests / GetAsync_Chunked_VaryingSizeChunks_ReceivedCorrectly  Discovered this while running System.Net.Http Outerloop tests:

```
System.Net.Http.Functional.Tests.PlatformHandler_HttpProtocolTests.GetAsync_Chun",28425,davidsh,corefx
25606,Test failure: PlatformHandler_HttpClientHandler_ResponseDrain_Test / GetAsyncWithMaxConnections_DisposeBeforeReadingToEnd_KillsConnection,"Discovered this while running System.Net.Http Outerloop tests:

```
System.Net.Http.Functional.Tests.PlatformHandler_HttpClientHandler_ResponseDrain_Test.GetAsyncWithMaxConnections_DisposeBeforeReadingToEnd_KillsConnection
  (totalSize: 2000000, readSize: 0, mode: BytePerChunk) [FAIL]
        System.IO.IOException : Unable to read data from the transport connection: An existing connection was forcibly closed by the remote host.
        ---- System.Net.Sockets.SocketException : An existing connection was forcibly closed by the remote host
        Stack Trace:
           s:\GitHub\corefx\src\System.Net.Sockets\src\System\Net\Sockets\Socket.Tasks.cs(1087,0): at System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.T
  hrowException(SocketError error)
           s:\GitHub\corefx\src\System.Net.Sockets\src\System\Net\Sockets\Socket.Tasks.cs(1079,0): at System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.S
  ystem.Threading.Tasks.Sources.IValueTaskSource.GetResult(Int16 token)
           E:\A\_work\104\s\src\mscorlib\shared\System\IO\StreamWriter.cs(979,0): at System.IO.StreamWriter.FlushAsyncInternal(StreamWriter _this, Boolean flus
  hStream, Boolean flushEncoder, Char[] charBuffer, Int32 charPos, Boolean haveWrittenPreamble, Encoding encoding, Encoder encoder, Byte[] byteBuffer, Stream s
  tream, CancellationToken cancellationToken)
           E:\A\_work\104\s\src\mscorlib\shared\System\IO\StreamWriter.cs(586,0): at System.IO.StreamWriter.WriteAsyncInternal(StreamWriter _this, String value
  , Char[] charBuffer, Int32 charPos, Int32 charLen, Char[] coreNewLine, Boolean autoFlush, Boolean appendNewLine)
           s:\GitHub\corefx\src\Common\tests\System\Net\Http\LoopbackServer.cs(389,0): at System.Net.Test.Common.LoopbackServer.Connection.ReadRequestHeaderAnd
  SendCustomResponseAsync(String response)
           s:\GitHub\corefx\src\Common\tests\System\Net\Http\LoopbackServer.cs(130,0): at System.Net.Test.Common.LoopbackServer.<>c__DisplayClass13_0.<<AcceptC
  onnectionSendCustomResponseAndCloseAsync>b__0>d.MoveNext()
           --- End of stack trace from previous location where exception was thrown ---
           s:\GitHub\corefx\src\Common\tests\System\Net\Http\LoopbackServer.cs(117,0): at System.Net.Test.Common.LoopbackServer.AcceptConnectionAsync(Func`2 fu
  ncAsync)
           s:\GitHub\corefx\src\Common\tests\System\Net\Http\LoopbackServer.cs(128,0): at System.Net.Test.Common.LoopbackServer.AcceptConnectionSendCustomRespo
  nseAndCloseAsync(String response)
           s:\GitHub\corefx\src\System.Net.Http\tests\FunctionalTests\HttpClientHandlerTest.ResponseDrain.cs(255,0): at System.Net.Http.Functional.Tests.HttpCl
  ientHandler_ResponseDrain_Test.<>c__DisplayClass6_1.<<GetAsyncWithMaxConnections_DisposeBeforeReadingToEnd_KillsConnection>b__2>d.MoveNext()
           --- End of stack trace from previous location where exception was thrown ---
           s:\GitHub\corefx\src\Common\tests\System\Net\Http\LoopbackServer.cs(117,0): at System.Net.Test.Common.LoopbackServer.AcceptConnectionAsync(Func`2 fu
  ncAsync)
           s:\GitHub\corefx\src\System.Net.Http\tests\FunctionalTests\HttpClientHandlerTest.ResponseDrain.cs(246,0): at System.Net.Http.Functional.Tests.HttpCl
  ientHandler_ResponseDrain_Test.<>c__DisplayClass6_0.<<GetAsyncWithMaxConnections_DisposeBeforeReadingToEnd_KillsConnection>b__1>d.MoveNext()
           --- End of stack trace from previous location where exception was thrown ---
           s:\GitHub\corefx\src\Common\tests\System\Net\Http\LoopbackServer.cs(84,0): at System.Net.Test.Common.LoopbackServer.<>c__DisplayClass11_0.<<CreateCl
  ientAndServerAsync>b__0>d.MoveNext()
           --- End of stack trace from previous location where exception was thrown ---
           s:\GitHub\corefx\src\Common\tests\System\Net\Http\LoopbackServer.cs(67,0): at System.Net.Test.Common.LoopbackServer.CreateServerAsync(Func`2 funcAsy
  nc, Options options)
           s:\GitHub\corefx\src\System.Net.Http\tests\FunctionalTests\HttpClientHandlerTest.ResponseDrain.cs(216,0): at System.Net.Http.Functional.Tests.HttpCl
  ientHandler_ResponseDrain_Test.GetAsyncWithMaxConnections_DisposeBeforeReadingToEnd_KillsConnection(Int32 totalSize, Int32 readSize, ContentMode mode)
           --- End of stack trace from previous location where exception was thrown ---
           ----- Inner Stack Trace -----
```

And after getting this exception, the test hangs due to some await problem regarding the loopback server response.  It looks like a loopback server bug or a place where a SocketException needs to be handled better.

## Failures history

Build | OS | Details
-- | -- | --
20180225.01 | Win7 | SocketException: An existing connection was forcibly closed by the remote host
20180301.04 | Win7 | SocketException: An existing connection was forcibly closed by the remote host
20180302.06 | Win7 | SocketException: An existing connection was forcibly closed by the remote host
20180303.03 | Win7 | WinHttpException: The operation has been canceled
20180303.03 | Win7 | SocketException: An existing connection was forcibly closed by the remote host
20180304.02 | Win7 | SocketException: An existing connection was forcibly closed by the remote host
20180304.03 | Win7 | WinHttpException: The operation has been canceled
20180308.02 | Win8.1 | WinHttpException: The operation has been canceled
20180308.06 | Win7 | WinHttpException: The operation has been canceled
20180314.02 | Win10 | WinHttpException: The operation has been canceled
20180314.05 | Win7 | TaskCanceledException: A task was canceled.
20180314.05 | Win7 | WinHttpException: The handle is invalid
20180316.03 | Win7 | SocketException: An existing connection was forcibly closed by the remote host
20180318.01 | Win7 | SocketException: An existing connection was forcibly closed by the remote host ","Test failure: PlatformHandler_HttpClientHandler_ResponseDrain_Test / GetAsyncWithMaxConnections_DisposeBeforeReadingToEnd_KillsConnection  Discovered this while running System.Net.Http Outerloop tests:

```
System.Net.Http.Functional.Tests.PlatformHand",28425,davidsh,corefx
25599,"Test failure: System.IO.Tests.Perf_Directory/RecursiveCreateDirectory(depth: 1000, times: 1)","All RecursiveCreateDirectory tests are failing

https://mc.dot.net/#/product/netcore/master/source/official~2Fcorefx~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180323.06/workItem/System.IO.FileSystem.Performance.Tests 

The test `System.IO.Tests.Perf_Directory/RecursiveCreateDirectory(depth: 1000, times: 1)` has failed.

System.Exception : Benchmark did not execute any iterations.  Please use one of the iteration methods in Microsoft.Xunit.Performance.Benchmark

        Stack Trace:

           at Microsoft.Xunit.Performance.BenchmarkTestInvoker.<>c__DisplayClass1_0.<<CallTestMethod>b__0>d.MoveNext()
    --- End of stack trace from previous location where exception was thrown ---
       at Microsoft.Xunit.Performance.Internal.BenchmarkIterator.RunAsync(Func`1 testMethod)
    --- End of stack trace from previous location where exception was thrown ---
Build : Master - 20180323.06 (Core Tests)
Failing configurations:
- OSX.1013.Amd64-x64
  - Release
- OSX.1012.Amd64-x64
  - Release
- Alpine.36.Amd64-x64
  - Release
- RedHat.69.Amd64-x64
  - Release
- Fedora.27.Amd64-x64
  - Release
- Fedora.26.Amd64-x64
  - Release
- SLES.12.Amd64-x64
  - Release
- OpenSuse.423.Amd64-x64
  - Release
- Ubuntu.1804.Amd64-x64
  - Release
- Ubuntu.1710.Amd64-x64
  - Release
- Ubuntu.1604.Amd64-x64
  - Release
- Ubuntu.1404.Amd64-x64
  - Release
- Debian.90.Amd64-x64
  - Release
- Debian.87.Amd64-x64
  - Release
- RedHat.74.Amd64-x64
  - Release
- RedHat.73.Amd64-x64
  - Release
- Centos.74.Amd64-x64
  - Release
- Centos.73.Amd64-x64
  - Release","Test failure: System.IO.Tests.Perf_Directory/RecursiveCreateDirectory(depth: 1000, times: 1)  All RecursiveCreateDirectory tests are failing

https://mc.dot.net/#/product/netcore/master/source/official~2Fcorefx~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2",28421,Anipik,corefx
25600,"Test failure: System.IO.Tests.Perf_Directory/RecursiveCreateDirectory(depth: 100, times: 10)","@anipik please disable RecursiveCreateDirectory perf test for .NET Framework, as it hits path limit.

The test `System.IO.Tests.Perf_Directory/RecursiveCreateDirectory(depth: 100, times: 10)` has failed.

System.IO.PathTooLongException : The specified path, file name, or both are too long. The fully qualified file name must be less than 260 characters, and the directory name must be less than 248 characters.

        Stack Trace:

           at System.IO.PathHelper.GetFullPathName()
       at System.IO.Path.LegacyNormalizePath(String path, Boolean fullCheck, Int32 maxPathLength, Boolean expandShortPaths)
       at System.IO.Path.GetFullPathInternal(String path)
       at System.IO.Directory.InternalCreateDirectoryHelper(String path, Boolean checkHost)
       at System.IO.Tests.Perf_Directory.RecursiveCreateDirectory(Int32 depth, Int32 times)
Build : Master - 20180323.06 (Full Framework Tests)
Failing configurations:
- Windows.10.Amd64-x64
  - Release
- Windows.10.Amd64-x86
  - Release","Test failure: System.IO.Tests.Perf_Directory/RecursiveCreateDirectory(depth: 100, times: 10)  @anipik please disable RecursiveCreateDirectory perf test for .NET Framework, as it hits path limit.

The test `System.IO.Tests.Perf_Directory/RecursiveCreateD",28421,Anipik,corefx
17,SqlClient implementation and API is not complete in Core,"The following members are on types implemented in .NET Core. However these particular members are missing, although they are present on Desktop.

The problem with this situation is
- it defies user expectations that if a type X exists, code from other platforms that use X will work on .NET Core
- it cannot be fixed without servicing -- it is not possible to supply a standalone package with the rest of the type definition

No work is necessarily required here for 2.0. It's not part of NS2.0. I didn't look at usage data. I'm just flagging this so we're doing this consciously.

---

**Updated lists to reflect current status (5/15):**

### Missing APIs
```
T:System.Data.SqlClient.OnChangeEventHandler
T:System.Data.SqlClient.PoolBlockingPeriod
T:System.Data.SqlClient.SqlAuthenticationMethod
M:System.Data.SqlClient.SqlBulkCopyColumnMappingCollection.Clear
M:System.Data.SqlClient.SqlBulkCopyColumnMappingCollection.RemoveAt(System.Int32)
F:System.Data.SqlClient.SqlBulkCopyOptions.AllowEncryptedValueModifications
M:System.Data.SqlClient.SqlClientFactory.System#IServiceProvider#GetService(System.Type)
T:System.Data.SqlClient.SqlClientMetaDataCollectionNames
T:System.Data.SqlClient.SqlColumnEncryptionCertificateStoreProvider
T:System.Data.SqlClient.SqlColumnEncryptionCngProvider
T:System.Data.SqlClient.SqlColumnEncryptionCspProvider
T:System.Data.SqlClient.SqlColumnEncryptionKeyStoreProvider
P:System.Data.SqlClient.SqlCommand.ColumnEncryptionSetting
P:System.Data.SqlClient.SqlCommand.Notification
P:System.Data.SqlClient.SqlCommand.NotificationAutoEnlist
M:System.Data.SqlClient.SqlCommand.BeginExecuteNonQuery
M:System.Data.SqlClient.SqlCommand.BeginExecuteNonQuery(System.AsyncCallback,System.Object)
M:System.Data.SqlClient.SqlCommand.BeginExecuteReader
M:System.Data.SqlClient.SqlCommand.BeginExecuteReader(System.AsyncCallback,System.Object)
M:System.Data.SqlClient.SqlCommand.BeginExecuteReader(System.AsyncCallback,System.Object,System.Data.CommandBehavior)
M:System.Data.SqlClient.SqlCommand.BeginExecuteReader(System.Data.CommandBehavior)
M:System.Data.SqlClient.SqlCommand.BeginExecuteXmlReader
M:System.Data.SqlClient.SqlCommand.BeginExecuteXmlReader(System.AsyncCallback,System.Object)
M:System.Data.SqlClient.SqlCommand.EndExecuteNonQuery(System.IAsyncResult)
M:System.Data.SqlClient.SqlCommand.EndExecuteReader(System.IAsyncResult)
M:System.Data.SqlClient.SqlCommand.EndExecuteXmlReader(System.IAsyncResult)
M:System.Data.SqlClient.SqlCommand.ResetCommandTimeout
T:System.Data.SqlClient.SqlCommandBuilder
T:System.Data.SqlClient.SqlCommandColumnEncryptionSetting
M:System.Data.SqlClient.SqlConnection.#ctor(System.String,System.Data.SqlClient.SqlCredential)
P:System.Data.SqlClient.SqlConnection.AccessToken
P:System.Data.SqlClient.SqlConnection.ColumnEncryptionKeyCacheTtl
P:System.Data.SqlClient.SqlConnection.ColumnEncryptionQueryMetadataCacheEnabled
P:System.Data.SqlClient.SqlConnection.ColumnEncryptionTrustedMasterKeyPaths
P:System.Data.SqlClient.SqlConnection.Credential
M:System.Data.SqlClient.SqlConnection.ChangePassword(System.String,System.Data.SqlClient.SqlCredential,System.Security.SecureString)
M:System.Data.SqlClient.SqlConnection.ChangePassword(System.String,System.String)
M:System.Data.SqlClient.SqlConnection.EnlistDistributedTransaction(System.EnterpriseServices.ITransaction)
M:System.Data.SqlClient.SqlConnection.RegisterColumnEncryptionKeyStoreProviders(System.Collections.Generic.IDictionary{System.String,System.Data.SqlClient.SqlColumnEncryptionKeyStoreProvider})
T:System.Data.SqlClient.SqlConnectionColumnEncryptionSetting
P:System.Data.SqlClient.SqlConnectionStringBuilder.AsynchronousProcessing
P:System.Data.SqlClient.SqlConnectionStringBuilder.Authentication
P:System.Data.SqlClient.SqlConnectionStringBuilder.ColumnEncryptionSetting
P:System.Data.SqlClient.SqlConnectionStringBuilder.ConnectionReset
P:System.Data.SqlClient.SqlConnectionStringBuilder.ContextConnection
P:System.Data.SqlClient.SqlConnectionStringBuilder.Enlist
P:System.Data.SqlClient.SqlConnectionStringBuilder.NetworkLibrary
P:System.Data.SqlClient.SqlConnectionStringBuilder.PoolBlockingPeriod
P:System.Data.SqlClient.SqlConnectionStringBuilder.TransactionBinding
P:System.Data.SqlClient.SqlConnectionStringBuilder.TransparentNetworkIPResolution
T:System.Data.SqlClient.SqlCredential
M:System.Data.SqlClient.SqlDataReader.IsCommandBehavior(System.Data.CommandBehavior)
M:System.Data.SqlClient.SqlDataReader.System#Data#IDataRecord#GetData(System.Int32)
T:System.Data.SqlClient.SQLDebugging
T:System.Data.SqlClient.SqlDependency
T:System.Data.SqlClient.SqlNotificationEventArgs
T:System.Data.SqlClient.SqlNotificationInfo
T:System.Data.SqlClient.SqlNotificationSource
T:System.Data.SqlClient.SqlNotificationType
M:System.Data.SqlClient.SqlParameter.#ctor(System.String,System.Data.SqlDbType,System.Int32,System.Data.ParameterDirection,System.Boolean,System.Byte,System.Byte,System.String,System.Data.DataRowVersion,System.Object)
M:System.Data.SqlClient.SqlParameter.#ctor(System.String,System.Data.SqlDbType,System.Int32,System.Data.ParameterDirection,System.Byte,System.Byte,System.String,System.Data.DataRowVersion,System.Boolean,System.Object,System.String,System.String,System.String)
P:System.Data.SqlClient.SqlParameter.ForceColumnEncryption
P:System.Data.SqlClient.SqlParameter.UdtTypeName
M:System.Data.SqlClient.SqlParameterCollection.Add(System.String,System.Object)
M:System.Data.SqlClient.SqlParameterCollection.Add(System.String,System.Data.SqlDbType,System.Int32,System.String)
```

#### By Design missing
* `T:System.Data.SqlClient.SqlProviderServices` -  It is part of the EF provider model for old versions of EF that were part of .NET Framework.  - see https://github.com/dotnet/corefx/issues/17126#issuecomment-301640792

### Missing overrides
```
P:System.Data.SqlClient.SqlClientFactory.CanCreateDataSourceEnumerator
M:System.Data.SqlClient.SqlClientFactory.CreateCommandBuilder
M:System.Data.SqlClient.SqlClientFactory.CreateDataSourceEnumerator
M:System.Data.SqlClient.SqlClientFactory.CreatePermission(System.Security.Permissions.PermissionState)
M:System.Data.SqlClient.SqlClientPermission.Add(System.String,System.String,System.Data.KeyRestrictionBehavior)
M:System.Data.SqlClient.SqlClientPermission.Copy
M:System.Data.SqlClient.SqlClientPermissionAttribute.CreatePermission
M:System.Data.SqlClient.SqlColumnEncryptionCertificateStoreProvider.DecryptColumnEncryptionKey(System.String,System.String,System.Byte[])
M:System.Data.SqlClient.SqlColumnEncryptionCertificateStoreProvider.EncryptColumnEncryptionKey(System.String,System.String,System.Byte[])
M:System.Data.SqlClient.SqlColumnEncryptionCngProvider.DecryptColumnEncryptionKey(System.String,System.String,System.Byte[])
M:System.Data.SqlClient.SqlColumnEncryptionCngProvider.EncryptColumnEncryptionKey(System.String,System.String,System.Byte[])
M:System.Data.SqlClient.SqlColumnEncryptionCspProvider.DecryptColumnEncryptionKey(System.String,System.String,System.Byte[])
M:System.Data.SqlClient.SqlColumnEncryptionCspProvider.EncryptColumnEncryptionKey(System.String,System.String,System.Byte[])
P:System.Data.SqlClient.SqlCommandBuilder.CatalogLocation
P:System.Data.SqlClient.SqlCommandBuilder.CatalogSeparator
P:System.Data.SqlClient.SqlCommandBuilder.QuotePrefix
P:System.Data.SqlClient.SqlCommandBuilder.QuoteSuffix
P:System.Data.SqlClient.SqlCommandBuilder.SchemaSeparator
M:System.Data.SqlClient.SqlCommandBuilder.QuoteIdentifier(System.String)
M:System.Data.SqlClient.SqlCommandBuilder.UnquoteIdentifier(System.String)
M:System.Data.SqlClient.SqlConnection.GetSchema
M:System.Data.SqlClient.SqlConnection.GetSchema(System.String)
M:System.Data.SqlClient.SqlConnection.GetSchema(System.String,System.String[])
P:System.Data.SqlClient.SqlConnectionStringBuilder.IsFixedSize
P:System.Data.SqlClient.SqlDataAdapter.UpdateBatchSize
M:System.Data.SqlClient.SqlDataReader.Close
M:System.Data.SqlClient.SqlDataReader.GetSchemaTable
```

**These were removed based on further investigation:**
```
M:System.Data.SqlClient.SqlConnection.EnlistTransaction(System.Transactions.Transaction)
P:System.Data.SqlClient.SqlParameter.SourceVersion
P:System.Data.SqlClient.SqlParameterCollection.IsFixedSize
P:System.Data.SqlClient.SqlParameterCollection.IsReadOnly
P:System.Data.SqlClient.SqlParameterCollection.IsSynchronized
```

**These were already fixed:**
* `M:System.Data.SqlClient.SqlClientFactory.CreateDataAdapter` - https://github.com/dotnet/corefx/commit/88f562c80d8d78218ccc7b4be8b23ceab712a5f6

----------

Original obsolete list:
<details>
```
MembersMustExist : Member 'Microsoft.SqlServer.Server.SqlMetaData..ctor(System.String, System.Data.SqlDbType, System.Type)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'Microsoft.SqlServer.Server.SqlMetaData..ctor(System.String, System.Data.SqlDbType, System.Type, System.String)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'Microsoft.SqlServer.Server.SqlMetaData..ctor(System.String, System.Data.SqlDbType, System.Type, System.String, System.Boolean, System.Boolean, System.Data.SqlClient.SortOrder, System.Int32)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'Microsoft.SqlServer.Server.SqlMetaData.DbType.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'Microsoft.SqlServer.Server.SqlMetaData.Type.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataRow[])' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataTable)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataTable, System.Data.DataRowState)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.IDataReader)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataRow[])' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataRow[], System.Threading.CancellationToken)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable, System.Data.DataRowState)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable, System.Data.DataRowState, System.Threading.CancellationToken)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable, System.Threading.CancellationToken)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.IDataReader)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.IDataReader, System.Threading.CancellationToken)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlBulkCopyOptions System.Data.SqlClient.SqlBulkCopyOptions.AllowEncryptedValueModifications' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlClientFactory.CreatePermission(System.Security.Permissions.PermissionState)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlCommand..ctor(System.String, System.Data.SqlClient.SqlConnection, System.Data.SqlClient.SqlTransaction, System.Data.SqlClient.SqlCommandColumnEncryptionSetting)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlCommand.BeginExecuteNonQuery()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlCommand.BeginExecuteNonQuery(System.AsyncCallback, System.Object)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlCommand.BeginExecuteReader()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlCommand.BeginExecuteReader(System.AsyncCallback, System.Object)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlCommand.BeginExecuteReader(System.AsyncCallback, System.Object, System.Data.CommandBehavior)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlCommand.BeginExecuteReader(System.Data.CommandBehavior)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlCommand.BeginExecuteXmlReader()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlCommand.BeginExecuteXmlReader(System.AsyncCallback, System.Object)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlCommand.Clone()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlCommand.ColumnEncryptionSetting.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlCommand.EndExecuteNonQuery(System.IAsyncResult)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlCommand.EndExecuteReader(System.IAsyncResult)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlCommand.EndExecuteXmlReader(System.IAsyncResult)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlCommand.Notification.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlCommand.Notification.set(System.Data.Sql.SqlNotificationRequest)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlCommand.NotificationAutoEnlist.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlCommand.NotificationAutoEnlist.set(System.Boolean)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlCommand.ResetCommandTimeout()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnection..ctor(System.String, System.Data.SqlClient.SqlCredential)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnection.AccessToken.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnection.AccessToken.set(System.String)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnection.ChangePassword(System.String, System.Data.SqlClient.SqlCredential, System.Security.SecureString)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnection.ChangePassword(System.String, System.String)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnection.ColumnEncryptionTrustedMasterKeyPaths.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnection.Credential.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnection.Credential.set(System.Data.SqlClient.SqlCredential)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnection.EnlistDistributedTransaction(System.EnterpriseServices.ITransaction)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnection.RegisterColumnEncryptionKeyStoreProviders(System.Collections.Generic.IDictionary<System.String, System.Data.SqlClient.SqlColumnEncryptionKeyStoreProvider>)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnectionStringBuilder.AsynchronousProcessing.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnectionStringBuilder.AsynchronousProcessing.set(System.Boolean)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnectionStringBuilder.Authentication.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnectionStringBuilder.Authentication.set(System.Data.SqlClient.SqlAuthenticationMethod)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnectionStringBuilder.ColumnEncryptionSetting.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnectionStringBuilder.ColumnEncryptionSetting.set(System.Data.SqlClient.SqlConnectionColumnEncryptionSetting)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnectionStringBuilder.ConnectionReset.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnectionStringBuilder.ConnectionReset.set(System.Boolean)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnectionStringBuilder.ContextConnection.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnectionStringBuilder.ContextConnection.set(System.Boolean)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnectionStringBuilder.Enlist.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnectionStringBuilder.Enlist.set(System.Boolean)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnectionStringBuilder.NetworkLibrary.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnectionStringBuilder.NetworkLibrary.set(System.String)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnectionStringBuilder.TransactionBinding.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnectionStringBuilder.TransactionBinding.set(System.String)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnectionStringBuilder.TransparentNetworkIPResolution.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnectionStringBuilder.TransparentNetworkIPResolution.set(System.Boolean)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlDataReader.IsCommandBehavior(System.Data.CommandBehavior)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlParameter..ctor(System.String, System.Data.SqlDbType, System.Int32, System.Data.ParameterDirection, System.Boolean, System.Byte, System.Byte, System.String, System.Data.DataRowVersion, System.Object)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlParameter..ctor(System.String, System.Data.SqlDbType, System.Int32, System.Data.ParameterDirection, System.Byte, System.Byte, System.String, System.Data.DataRowVersion, System.Boolean, System.Object, System.String, System.String, System.String)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlParameter.ForceColumnEncryption.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlParameter.ForceColumnEncryption.set(System.Boolean)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlParameter.UdtTypeName.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlParameter.UdtTypeName.set(System.String)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlParameterCollection.Add(System.String, System.Data.SqlDbType, System.Int32, System.String)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlParameterCollection.Add(System.String, System.Object)' does not exist in the implementation but it does exist in the contract.
```
</details>

from https://github.com/dotnet/corefx/blob/master/src/shims/ApiCompatBaseline.netcoreapp.netfx461.txt","SqlClient implementation and API is not complete in Core  The following members are on types implemented in .NET Core. However these particular members are missing, although they are present on Desktop.

The problem with this situation is
- it defies u",26252,joelbraun,corefx
26016,Enable BeginExecuteNonQuery functions in .NET Core,Make public previously private BeginExecuteNonQuery and related functions. Add basic functional tests.,Enable BeginExecuteNonQuery functions in .NET Core  Make public previously private BeginExecuteNonQuery and related functions. Add basic functional tests.,26252,joelbraun,corefx
23744,"Add Dictionary<TKey, TValue>.Capacity to let you resize map after created","[edited by @danmosemsft to put into review format]

## Latest Proposal

See https://github.com/dotnet/corefx/issues/24445#issuecomment-352869027

```c#
    public partial class Dictionary<TKey, TValue> :  ...
    {
           // Makes sure that capacity is at least that capacity, ie, the dictionary can accept this many items without resizing its internal data structures
           public int EnsureCapacity(int capacity);
           public void TrimExcess(); // Calls the other passing Count
           public void TrimExcess(int capacity);
    }
```

## Issue 
While I can set the initial capability of a dictionary when it's created, I cannot resize it after it's created.  Please add `Dictionary<TKey, TValue>.Capacity` property or an `EnsureCapacity` method so that that you can.

## Rationale
MSBuild, are resizing multiple times during Add that they cannot avoid without recreating the dictionary: https://github.com/Microsoft/msbuild/issues/2587. 
Another case came up in an Azure service profile today, where a dictionary was being copied into another dictionary which had already been constructed and resize CPU and allocation cost was high.

## Proposal (old)
```c#
    public partial class Dictionary<TKey, TValue> :  ...
    {
        public Dictionary(int capacity) { }   // existing constructor 
        public int Capacity { get { } set { } }
    }
```
The name `Capacity` is chosen to match the parameter name of the existing constructor.  

Setting Capacity to `value` causes the Dictionary to ensure it can have up to `value` elements without resizing. Behind the scenes if `value` is less than the existing capacity it calls Resize to increase the backing storage to the smallest Prime that is not less than the requested `value`.

The getter is probably not terribly useful (debugging?) but a setter without a getter is strange.

## Discussion
Implementation of this looks like it will be straightforward, not significantly increase the instantiated size of Dictionary's, and not affect code paths that do not call it. The resizing codepath obviously already exists, although right now it is never given a desired size: it starts with doubling.","Add Dictionary<TKey, TValue>.Capacity to let you resize map after created  [edited by @danmosemsft to put into review format]

## Latest Proposal

See https://github.com/dotnet/corefx/issues/24445#issuecomment-352869027

```c#
    public partial cl",26239,maryamariyan,corefx
20100,CI isn't functioning,"Tests aren't being triggered, and https://ci.dot.net/ inaccessible.","CI isn't functioning  Tests aren't being triggered, and https://ci.dot.net/ inaccessible.",26239,maryamariyan,corefx
26158,Adding EnsureCapacity to Dictionary and adding tests,"Partly addresses: #24445

Adding EnsureCapacity API to Dictionary and Adding Tests.
Implementation changes made in a coreclr PR separately here https://github.com/dotnet/coreclr/pull/15729.

cc: @benaadams @danmosemsft 

TODO Next in a separate PR:
- Will add EnsureCapacity to SortedSet and HashSet 
- Will add TrimExcess to Dictionary, SortedSet ","Adding EnsureCapacity to Dictionary and adding tests  Partly addresses: #24445

Adding EnsureCapacity API to Dictionary and Adding Tests.
Implementation changes made in a coreclr PR separately here https://github.com/dotnet/coreclr/pull/15729.

cc: @",26239,maryamariyan,corefx
26135,reenable ssl tests,"Fixes #23138 

@stephentoub @karelz @wfurt @Priya91","reenable ssl tests  Fixes #23138 

@stephentoub @karelz @wfurt @Priya91",26197,wfurt,corefx
24591,Tests failed: System.Net.Http.Functional.Tests.ManagedHandler_HttpClientHandler_SslProtocols_Test / GetAsync_*SSLVersion_Succeeds,"Regression caused by dotnet/corefx#26135 (@geoffkizer)

## Types of failures

Affected tests:
* GetAsync_AllowedSSLVersion_Succeeds
* GetAsync_SupportedSSLVersion_Succeeds

### GetAsync_AllowedSSLVersion_Succeeds - The client and server cannot communicate, because they do not possess a common algorithm

Build [20180105.02](https://mc.dot.net/#/product/netcore/master/source/official~2Fcorefx~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180105.02/workItem/System.Net.Http.Functional.Tests/analysis/xunit/System.Net.Http.Functional.Tests.ManagedHandler_HttpClientHandler_SslProtocols_Test~2FGetAsync_AllowedSSLVersion_Succeeds(acceptedProtocol:%20Tls11,%20requestOnlyThisProtocol:%20False)):
```
System.Security.Authentication.AuthenticationException : A call to SSPI failed, see inner exception.
---- System.ComponentModel.Win32Exception : The client and server cannot communicate, because they do not possess a common algorithm
at System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, ExceptionDispatchInfo exception) in E:\A\_work\640\s\corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs:line 975
at System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest) in E:\A\_work\640\s\corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs:line 802
at System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest) in E:\A\_work\640\s\corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs:line 792
at System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest) in E:\A\_work\640\s\corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs:line 961
at System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest) in E:\A\_work\640\s\corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs:line 916
at System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest) in E:\A\_work\640\s\corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs:line 864
at System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest) in E:\A\_work\640\s\corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs:line 673
at System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult) in E:\A\_work\640\s\corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs:line 594
at System.Net.Security.SslStream.BeginAuthenticateAsServer(SslServerAuthenticationOptions sslServerAuthenticationOptions, CancellationToken cancellationToken, AsyncCallback asyncCallback, Object asyncState) in E:\A\_work\640\s\corefx\src\System.Net.Security\src\System\Net\Security\SslStream.cs:line 242
at System.Net.Security.SslStream.BeginAuthenticateAsServer(X509Certificate serverCertificate, Boolean clientCertificateRequired, SslProtocols enabledSslProtocols, Boolean checkCertificateRevocation, AsyncCallback asyncCallback, Object asyncState) in E:\A\_work\640\s\corefx\src\System.Net.Security\src\System\Net\Security\SslStream.cs:line 219
at System.Net.Security.SslStream.<>c.<AuthenticateAsServerAsync>b__47_1(X509Certificate arg1, Boolean arg2, SslProtocols arg3, AsyncCallback callback, Object state) in E:\A\_work\640\s\corefx\src\System.Net.Security\src\System\Net\Security\SslStream.cs:line 404
at System.Threading.Tasks.TaskFactory`1.FromAsyncImpl[TArg1,TArg2,TArg3](Func`6 beginMethod, Func`2 endFunction, Action`1 endAction, TArg1 arg1, TArg2 arg2, TArg3 arg3, Object state, TaskCreationOptions creationOptions) in E:\A\_work\1734\s\src\mscorlib\src\System\Threading\Tasks\FutureFactory.cs:line 1218
at System.Net.Security.SslStream.AuthenticateAsServerAsync(X509Certificate serverCertificate, Boolean clientCertificateRequired, SslProtocols enabledSslProtocols, Boolean checkCertificateRevocation) in E:\A\_work\640\s\corefx\src\System.Net.Security\src\System\Net\Security\SslStream.cs:line 405
at System.Net.Test.Common.LoopbackServer.<AcceptSocketAsync>d__11.MoveNext() in E:\A\_work\640\s\corefx\src\Common\tests\System\Net\Http\LoopbackServer.cs:line 164
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Http.Functional.Tests.HttpClientHandler_SslProtocols_Test.<>c__DisplayClass4_1.<<GetAsync_AllowedSSLVersion_Succeeds>b__0>d.MoveNext() in E:\A\_work\640\s\corefx\src\System.Net.Http\tests\FunctionalTests\HttpClientHandlerTest.SslProtocols.cs:line 115
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Test.Common.LoopbackServer.<>c__DisplayClass3_0.<CreateServerAsync>b__0(Task t) in E:\A\_work\640\s\corefx\src\Common\tests\System\Net\Http\LoopbackServer.cs:line 67
at System.Threading.Tasks.ContinuationTaskFromTask.InnerInvoke() in E:\A\_work\1734\s\src\mscorlib\src\System\Threading\Tasks\TaskContinuation.cs:line 59
at System.Threading.Tasks.Task.<>c.<.cctor>b__278_1(Object obj) in E:\A\_work\1734\s\src\mscorlib\src\System\Threading\Tasks\Task.cs:line 2480
at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state) in E:\A\_work\1734\s\src\mscorlib\shared\System\Threading\ExecutionContext.cs:line 151
at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task& currentTaskSlot) in E:\A\_work\1734\s\src\mscorlib\src\System\Threading\Tasks\Task.cs:line 2440
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Http.Functional.Tests.HttpClientHandler_SslProtocols_Test.<GetAsync_AllowedSSLVersion_Succeeds>d__4.MoveNext() in E:\A\_work\640\s\corefx\src\System.Net.Http\tests\FunctionalTests\HttpClientHandlerTest.SslProtocols.cs:line 113
--- End of stack trace from previous location where exception was thrown ---
--- End of stack trace from previous location where exception was thrown ---
--- End of stack trace from previous location where exception was thrown ---
----- Inner Stack Trace -----
```

### GetAsync_SupportedSSLVersion_Succeeds - The function requested is not supported

Build [20180105.02](https://mc.dot.net/#/product/netcore/master/source/official~2Fcorefx~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180105.02/workItem/System.Net.Http.Functional.Tests/analysis/xunit/System.Net.Http.Functional.Tests.ManagedHandler_HttpClientHandler_SslProtocols_Test~2FGetAsync_SupportedSSLVersion_Succeeds(sslProtocols:%20Tls11,%20url:%20%5C%22https:~2F~2Fwww.ssllabs.com:10302~2F%5C%22))
```
System.Net.Http.HttpRequestException : The SSL connection could not be established, see inner exception.
---- System.Security.Authentication.AuthenticationException : A call to SSPI failed, see inner exception.
-------- System.ComponentModel.Win32Exception : The function requested is not supported
at System.Net.Http.HttpConnectionHandler.<EstablishSslConnection>d__5.MoveNext() in E:\A\_work\640\s\corefx\src\System.Net.Http\src\System\Net\Http\Managed\HttpConnectionHandler.cs:line 82
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Http.HttpConnectionHandler.<CreateConnection>d__6.MoveNext() in E:\A\_work\640\s\corefx\src\System.Net.Http\src\System\Net\Http\Managed\HttpConnectionHandler.cs:line 136
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Http.HttpConnectionPool.<WaitForCreatedConnectionAsync>d__15.MoveNext() in E:\A\_work\640\s\corefx\src\System.Net.Http\src\System\Net\Http\Managed\HttpConnectionPool.cs:line 226
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Http.HttpConnectionHandler.<SendAsyncWithAwaitedConnection>d__4.MoveNext() in E:\A\_work\640\s\corefx\src\System.Net.Http\src\System\Net\Http\Managed\HttpConnectionHandler.cs:line 42
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Http.CookieHandler.<SendAsync>d__3.MoveNext() in E:\A\_work\640\s\corefx\src\System.Net.Http\src\System\Net\Http\Managed\CookieHandler.cs:line 31
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Http.AuthenticateAndRedirectHandler.<SendAsync>d__7.MoveNext() in E:\A\_work\640\s\corefx\src\System.Net.Http\src\System\Net\Http\Managed\AuthenticateAndRedirectHandler.cs:line 62
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Http.HttpClient.<FinishSendAsyncBuffered>d__62.MoveNext() in E:\A\_work\640\s\corefx\src\System.Net.Http\src\System\Net\Http\HttpClient.cs:line 488
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Test.Common.RemoteServerQuery.<Run>d__0`1.MoveNext() in E:\A\_work\640\s\corefx\src\Common\tests\System\Net\RemoteServerQuery.cs:line 44
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Http.Functional.Tests.HttpClientHandler_SslProtocols_Test.<GetAsync_SupportedSSLVersion_Succeeds>d__6.MoveNext() in E:\A\_work\640\s\corefx\src\System.Net.Http\tests\FunctionalTests\HttpClientHandlerTest.SslProtocols.cs:line 148
--- End of stack trace from previous location where exception was thrown ---
--- End of stack trace from previous location where exception was thrown ---
--- End of stack trace from previous location where exception was thrown ---
----- Inner Stack Trace -----
at System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, ExceptionDispatchInfo exception) in E:\A\_work\640\s\corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs:line 975
at System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest) in E:\A\_work\640\s\corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs:line 802
at System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest) in E:\A\_work\640\s\corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs:line 792
at System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest) in E:\A\_work\640\s\corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs:line 961
at System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest) in E:\A\_work\640\s\corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs:line 916
at System.Net.Security.SslState.PartialFrameCallback(AsyncProtocolRequest asyncRequest) in E:\A\_work\640\s\corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs:line 1096
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Security.SslState.InternalEndProcessAuthentication(LazyAsyncResult lazyResult) in E:\A\_work\640\s\corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs:line 735
at System.Net.Security.SslState.EndProcessAuthentication(IAsyncResult result) in E:\A\_work\640\s\corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs:line 708
at System.Net.Security.SslStream.EndAuthenticateAsClient(IAsyncResult asyncResult) in E:\A\_work\640\s\corefx\src\System.Net.Security\src\System\Net\Security\SslStream.cs:line 194
at System.Net.Security.SslStream.<>c.<AuthenticateAsClientAsync>b__44_1(IAsyncResult iar) in E:\A\_work\640\s\corefx\src\System.Net.Security\src\System\Net\Security\SslStream.cs:line 381
at System.Threading.Tasks.TaskFactory`1.FromAsyncCoreLogic(IAsyncResult iar, Func`2 endFunction, Action`1 endAction, Task`1 promise, Boolean requiresSynchronization) in E:\A\_work\1734\s\src\mscorlib\src\System\Threading\Tasks\FutureFactory.cs:line 533
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Http.HttpConnectionHandler.<EstablishSslConnection>d__5.MoveNext() in E:\A\_work\640\s\corefx\src\System.Net.Http\src\System\Net\Http\Managed\HttpConnectionHandler.cs:line 68
----- Inner Stack Trace -----
```

### GetAsync_AllowedSSLVersion_Succeeds

```
System.Net.Http.HttpRequestException : An error occurred while sending the request.
---- System.IO.IOException : The decryption operation failed, see inner exception.
-------- Interop+OpenSsl+SslException : Decrypt failed with OpenSSL error - SSL_ERROR_SSL.
------------ System.Security.Cryptography.CryptographicException : Error occurred during a cryptographic operation.
at System.Net.Http.HttpConnection.<SendAsync>d__38.MoveNext() in /root/corefx-1266141/src/System.Net.Http/src/System/Net/Http/Managed/HttpConnection.cs:line 438
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Http.HttpConnectionHandler.<SendAsyncWithAwaitedConnection>d__4.MoveNext() in /root/corefx-1266141/src/System.Net.Http/src/System/Net/Http/Managed/HttpConnectionHandler.cs:line 43
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Http.CookieHandler.<SendAsync>d__3.MoveNext() in /root/corefx-1266141/src/System.Net.Http/src/System/Net/Http/Managed/CookieHandler.cs:line 31
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Http.AuthenticateAndRedirectHandler.<SendAsync>d__7.MoveNext() in /root/corefx-1266141/src/System.Net.Http/src/System/Net/Http/Managed/AuthenticateAndRedirectHandler.cs:line 62
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Http.HttpClient.<FinishSendAsyncBuffered>d__62.MoveNext() in /root/corefx-1266141/src/System.Net.Http/src/System/Net/Http/HttpClient.cs:line 488
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Http.Functional.Tests.HttpClientHandler_SslProtocols_Test.<>c__DisplayClass4_1.<<GetAsync_AllowedSSLVersion_Succeeds>b__0>d.MoveNext() in /root/corefx-1266141/src/System.Net.Http/tests/FunctionalTests/HttpClientHandlerTest.SslProtocols.cs:line 115
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Test.Common.LoopbackServer.<>c__DisplayClass3_0.<CreateServerAsync>b__0(Task t) in /root/corefx-1266141/src/Common/tests/System/Net/Http/LoopbackServer.cs:line 68
at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state) in /root/coreclr/src/mscorlib/shared/System/Threading/ExecutionContext.cs:line 151
at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task& currentTaskSlot) in /root/coreclr/src/mscorlib/src/System/Threading/Tasks/Task.cs:line 2440
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Http.Functional.Tests.HttpClientHandler_SslProtocols_Test.<GetAsync_AllowedSSLVersion_Succeeds>d__4.MoveNext() in /root/corefx-1266141/src/System.Net.Http/tests/FunctionalTests/HttpClientHandlerTest.SslProtocols.cs:line 113
--- End of stack trace from previous location where exception was thrown ---
--- End of stack trace from previous location where exception was thrown ---
--- End of stack trace from previous location where exception was thrown ---
----- Inner Stack Trace -----
at System.Net.Security.SslStreamInternal.<ReadAsyncInternal>d__32`1.MoveNext() in /root/corefx-1266141/src/System.Net.Security/src/System/Net/Security/SslStreamInternal.cs:line 285
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Http.HttpConnection.<FillAsync>d__64.MoveNext() in /root/corefx-1266141/src/System.Net.Http/src/System/Net/Http/Managed/HttpConnection.cs:line 958
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Http.HttpConnection.<ReadNextLineAsync>d__62.MoveNext() in /root/corefx-1266141/src/System.Net.Http/src/System/Net/Http/Managed/HttpConnection.cs:line 867
--- End of stack trace from previous location where exception was thrown ---
at System.Net.Http.HttpConnection.<SendAsync>d__38.MoveNext() in /root/corefx-1266141/src/System.Net.Http/src/System/Net/Http/Managed/HttpConnection.cs:line 313
----- Inner Stack Trace -----
at Interop.OpenSsl.Decrypt(SafeSslHandle context, Byte[] outBuffer, Int32 offset, Int32 count, SslErrorCode& errorCode) in /root/corefx-1266141/src/Common/src/Interop/Unix/System.Security.Cryptography.Native/Interop.OpenSsl.cs:line 269
at System.Net.Security.SslStreamPal.EncryptDecryptHelper(SafeDeleteContext securityContext, ReadOnlyMemory`1 input, Int32 offset, Int32 size, Boolean encrypt, Byte[]& output, Int32& resultSize) in /root/corefx-1266141/src/System.Net.Security/src/System/Net/Security/SslStreamPal.Unix.cs:line 207
----- Inner Stack Trace -----
```

## History of failures

Day | Build | OS | Test name
--- | --- | --- | --- 
7/6-7/8 | many | Various Linux | 80x failed in each build (similar SSPI errors) - 480 failures
7/6-7/11 | many | Win7 | 4x & 4x failed in each build (same/similar SSPI errors) - 128 failures
7/11 | N/A | All | Tests were disabled in https://github.com/geoffkizer/corefx/commit/9c4af2973699aea35ce5c60c00f7dd14398e7a14#diff-fd4b6c323e531f0e41d566955e6fbffa
1/5 | 20180105.01 | Win7 | 4x GetAsync_AllowedSSLVersion_Succeeds &<br/>4x GetAsync_SupportedSSLVersion_Succeeds<br/>(both Win7-x86 and Win7-amd64) - [link](https://mc.dot.net/#/product/netcore/master/source/official~2Fcorefx~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180105.01/workItem/System.Net.Http.Functional.Tests)
1/5 | 20180105.02 | Win7 | 4x GetAsync_AllowedSSLVersion_Succeeds &<br/>4x GetAsync_SupportedSSLVersion_Succeeds<br/>(both Win7-x86 and Win7-amd64) - [link](https://mc.dot.net/#/product/netcore/master/source/official~2Fcorefx~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180105.02/workItem/System.Net.Http.Functional.Tests)
1/5 | 20180105.02 | RedHat73 | GetAsync_AllowedSSLVersion_Succeeds - [link](https://mc.dot.net/#/product/netcore/master/source/official~2Fcorefx~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180105.02/workItem/System.Net.Http.Functional.Tests/analysis/xunit/System.Net.Http.Functional.Tests.ManagedHandler_HttpClientHandler_SslProtocols_Test~2FGetAsync_AllowedSSLVersion_Succeeds(acceptedProtocol:%20Tls,%20requestOnlyThisProtocol:%20False))","Tests failed: System.Net.Http.Functional.Tests.ManagedHandler_HttpClientHandler_SslProtocols_Test / GetAsync_*SSLVersion_Succeeds  Regression caused by dotnet/corefx#26135 (@geoffkizer)

## Types of failures

Affected tests:
* GetAsync_AllowedSSLVers",26197,wfurt,corefx
23821,"NamedPipeClientStream depends on WaitNamedPipe, which is not supported in Windows Containers","`NamedPipeClientStream.TryConnect` calls into native `WaitNamedPipe` first to make sure the pipe is available and only then into native `CreateNamedPipeClient`. The problem is that currently `WaitNamedPipe` is not supported from inside of Windows Containers (however `CreateNamedPipeClient` works ok). It fails with `ERROR_FILE_NOT_FOUND`. As such, managed code using `NamedPipeClientStream` is broken in Windows Containers due to the ordering of the calls. This includes Docker.Dotnet library and projects depending on it. Since both these calls happen in a loop which is making sure that the given timeout is not exceeded, we could swap them and call `WaitNamedPipe` only if `CreateNamedPipeClient` fails in a predicable manner first.","NamedPipeClientStream depends on WaitNamedPipe, which is not supported in Windows Containers  `NamedPipeClientStream.TryConnect` calls into native `WaitNamedPipe` first to make sure the pipe is available and only then into native `CreateNamedPipeClient`.",26118,pjanotti,corefx
22678,Race in NamedPipeClientStream.TryConnect leads to unexpected exception,"The Windows version of [`TryConnect`](https://github.com/dotnet/corefx/blob/master/src/System.IO.Pipes/src/System/IO/Pipes/NamedPipeClientStream.Windows.cs#L25) first calls `WaitNamedPipe` and if it returns ""file not found"" it tries again until the timeout expires. If `WaitNamedPipe` succeeds then the code calls `CreateNamedPipeClient` (`CreateFile`) and if that returns any error other than ""pipe busy"" it throws an exception. If the server dies between the call to `WaitNamedPipe` and `CreateNamedPipeClient` you'll end up with an unexpected  `FileNotFoundException`.

IMO `TryConnect` should just call `CreateNamedPipeClient` first and fall back to `WaitNamedPipe` if it returns ""file not found"" or ""pipe busy"".",Race in NamedPipeClientStream.TryConnect leads to unexpected exception  The Windows version of [`TryConnect`](https://github.com/dotnet/corefx/blob/master/src/System.IO.Pipes/src/System/IO/Pipes/NamedPipeClientStream.Windows.cs#L25) first calls `WaitNamed,26118,pjanotti,corefx
23841,NamedPipeClientStream not handling error cases correctly,"According to the documentation this isn't correct:

```C#
// The timeout has expired.
if (errorCode == Interop.Errors.ERROR_SUCCESS)
{
    if (cancellationToken.CanBeCanceled)
    {
    ...
```

It should be checking ERROR_SEM_TIMEOUT.

https://msdn.microsoft.com/en-us/library/windows/desktop/aa365800.aspx
https://msdn.microsoft.com/en-us/library/cc232125.aspx
","NamedPipeClientStream not handling error cases correctly  According to the documentation this isn't correct:

```C#
// The timeout has expired.
if (errorCode == Interop.Errors.ERROR_SUCCESS)
{
    if (cancellationToken.CanBeCanceled)
    {
    ...",26118,pjanotti,corefx
24616,Switch WaitNamedPipe and CreateNamedPipeClient invocation ordering.,"We need to do this as WaitNamedPipe is not supported in Windows Containers.
With this change, CreateNamedPipeClient will be called first, with call to WaitNamedPipe as
a fallback only. This will allow us to use NamedPipeClientStream inside Windows
Containers.

This should handle both https://github.com/dotnet/corefx/issues/24594 and https://github.com/dotnet/corefx/issues/22014.

Fixes #22014 per @jiria request keeping #24594 open until it is ported to the next servicing release.

[Edit: added last line to close one issue and make clear why the other one is still open]","Switch WaitNamedPipe and CreateNamedPipeClient invocation ordering.  We need to do this as WaitNamedPipe is not supported in Windows Containers.
With this change, CreateNamedPipeClient will be called first, with call to WaitNamedPipe as
a fallback only.",26118,pjanotti,corefx
25323,Porting: Switch WaitNamedPipe and CreateNamedPipeClient invocation ordering.,"(Original PR #24616)

* Switch WaitNamedPipe and CreateNamedPipeClient invocation ordering.

We need to do this as WaitNamedPipe is not supported in Windows Containers.
By default using CreateNamedPipeClient first with call to WaitNamedPipe as
a fallback only will allow us to use NamedPipeClientStream inside Windows
Containers.

* Integrate feedback from PR.","Porting: Switch WaitNamedPipe and CreateNamedPipeClient invocation ordering.   (Original PR #24616)

* Switch WaitNamedPipe and CreateNamedPipeClient invocation ordering.

We need to do this as WaitNamedPipe is not supported in Windows Containers.
By",26118,pjanotti,corefx
19779,Passing dynamic arg to indexer property of a generic type implementing a derived interface throws,"Yes, that's a mouthful, but it's the simplest way I've been able to reproduce this! There seems to be a limitation (bug?) in RuntimeBinder when it tries to call an indexed property on an interface through a ""derived"" interface. It appears that the RuntimeBinder doesn't see the indexed property of the ""base"" interface and throws an exception:

```
Unhandled Exception: Microsoft.CSharp.RuntimeBinder.RuntimeBinderException: Cannot apply indexing with [] to an expression of type 'ConsoleApplication1.IFakeStringLocalizer2'
 at CallSite.Target(Closure, CallSite, IFakeStringLocalizer2, Object)
 at System.Dynamic.UpdateDelegates.UpdateAndExecute2[T0, T1, TRet](CallSite site, T0 arg0, T1 arg1)
 at ConsoleApplication1.Program.Main(String[] args) in Program.cs:line 17
```

Long story short, here's the simplest code I've been able to make that reproduces the problem. It's very subtle and I've made a note wherever there are critical parts of the code.

```c#
namespace ConsoleApplication1
{
    class Program
    {
        static void Main(string[] args)
        {
            // The *declared* type of this variable is IMPORTANT. Change it to the concrete type and it works
            IFakeStringLocalizer2 s = new FakeStringLocalizer<int>();

            dynamic d = new object();

            // This next line of code throws at runtime:
            //Unhandled Exception: Microsoft.CSharp.RuntimeBinder.RuntimeBinderException: Cannot apply indexing with [] to an expression of type 'ConsoleApplication1.IFakeStringLocalizer2'
            // at CallSite.Target(Closure, CallSite, IFakeStringLocalizer2, Object)
            // at System.Dynamic.UpdateDelegates.UpdateAndExecute2[T0, T1, TRet](CallSite site, T0 arg0, T1 arg1)
            // at ConsoleApplication1.Program.Main(String[] args) in Program.cs:line 17
            var x = s[d];
        }
    }

    // The generic type here DOES seem to matter.
    public class FakeStringLocalizer<T> : IFakeStringLocalizer2
    {
        public int this[int b] { get { return -1; } }
    }

    // This extra interface DOES seem to matter.
    public interface IFakeStringLocalizer2 : IFakeStringLocalizer
    {
    }

    public interface IFakeStringLocalizer
    {
        // Return type and indexer arg type don't matter here
        int this[int b] { get; }
    }
}
```

Originally filed here: https://github.com/aspnet/Localization/issues/308","Passing dynamic arg to indexer property of a generic type implementing a derived interface throws  Yes, that's a mouthful, but it's the simplest way I've been able to reproduce this! There seems to be a limitation (bug?) in RuntimeBinder when it tries to",25827,JonHanna,corefx
22868,Remove checks for impossible conditions from Microsoft.CSharp,"dotnet/corefx#22456 removed some error codes that were never used, but there is other code in Microsoft.CSharp that checks for conditions that are irrelevant (can only happen when defining a type, constant operations, or other cases that only come up in static code) or impossible (lacking a mscorlib, types like `int` and `object` aren't available, in which case there would have been a fatal error before the code had a chance to run).

The removal of this dead code of course needs to be careful of removing a condition that actually could happen, in which case a test cases that hit it should be added or if that's difficult for some reason the condition should be clearly documented in a comment.

This issue is to track that.

The following is a list of all errors not currently hit during testing. This isn't a perfect to-do list (the same error could have both possible and impossible paths to it) and it includes some cases that I think should definitely be reachable (but they should be covered by tests anyway for dotnet/runtime#19616 and marked off as soon as confirmed as reachable, and besides I could be wrong), but it will serve as a gauge. There could also be cases that cannot be hit but should be, as per dotnet/corefx#22534)

- [x] CS0031 ConstOutOfRange (#25825)
- [x] CS0035 AmbigUnaryOp (#22549)
- [x] CS0038 WrongNestedThis (#26417)
- [x] CS0120 ObjectRequired (#22682)
- [x] CS0123 MethDelegateMismatch (#25217)
- [ ] CS0131 AssgLvalueExpected
- [x] CS0143 NoConstructors (#23069)
- [x] CS0148 BadDelegateConstructor (#23371)
- [x] CS0176 ObjectProhibited (#22682)
- [x] CS0192 RefReadonly (#25042)
- [ ] CS0198 AssgReadonlyStatic
- [x] CS0199 RefReadonlyStatic (#25042)
- [x] CS0205 AbstractBaseCall (#22518)
- [x] CS0206 RefProperty (#25042)
- [x] CS0218 MustHaveOpTF (#22782)
- [x] CS0221 ConstOutOfRangeChecked (#25825)
- [x] CS0229 AmbigMember (#25827)
- [x] CS0233 SizeofUnsafe (#22519)
- [x] CS0245 CallingFinalizeDepracated (#22518)
- [x] CS0250 CallingBaseFinalizeDeprecated (#22518)
- [x] CS0306 BadTypeArgument (#23286)
- [x] CS0307 TypeArgsNotAllowed (#23069)
- [x] CS0312 GenericConstraintNotSatisfiedNullableEnum (#23069)
- [x] CS0313 GenericConstraintNotSatisfiedNullableInterface (#23069)
- [x] CS0314 GenericConstraintNotSatisfiedTyVar (#23287)
- [x] CS0403 TypeVarCantBeNull (#23278)
- [x] CS0407 BadRetType (#23371)
- [x] CS0428 MethGrpToNonDel (#23371)
- [x] CS0452 RefConstraintNotSatisfied (#22549)
- [x] CS0518 PredefinedTypeNotFound (#22471)
- [ ] CS0570 BindToBogus
- [x] CS0571 CantCallSpecialMethod (#22549)
- [x] CS0648 BogusType (#22537)
- [x] CS0656 MissingPredefinedMember (#22541)
- [x] CS0664 LiteralDoubleCast (#22533)
- [x] CS0716 ConvertToStaticClass (#22549)
- [x] CS0718 GenericArgIsStaticClass (#23286)
- [x] CS0762 PartialMethodToDelegate (#22548)
- [x] CS1061 NoSuchMemberOrExtension (#22999)
- [x] CS1113 ValueTypeExtDelegate (#22999)
- [x] CS1503 BadArgType (#22748)
- [x] CS1510 RefLvalueExpected (#25042)
- [x] CS1545 BindToBogusProp2 (Should be used but wasn't, fixed in dotnet/corefx#22537)
- [x] CS1546 BindToBogusProp1 (Should be used but wasn't, fixed in dotnet/corefx#22537)
- [x] CS1594 BadDelArgTypes (#25218)
- [x] CS1604 AssgReadonlyLocal (#25042)
- [x] CS1605 RefReadonlyLocal (#25042)
- [x] CS1612 ReturnNotLValue (#26370)
- [x] CS1615 BadArgExtraRef (#22748)
- [x] CS1620 BadArgRef (#22748)
- [x] CS1648 AssgReadonly2 (#26370)
- [x] CS1649 RefReadonly2 (#25042)
- [x] CS1650 AssgReadonlyStatic2 (#26370)
- [x] CS1651 RefReadonlyStatic2 (#25042)
- [x] CS1656 AssgReadonlyLocalCause (#25214)
- [x] CS1657 RefReadonlyLocalCause (#25042)
- [x] CS1728 DelegateOnNullable (#23371)
- [x] CS1729 BadCtorArgCount (#23069)
- [x] CS1740 DuplicateNamedArgument (Enum value 5005) (#23281)
- [x] CS1744 NamedArgumentSpecificationBeforeFixedArgument (Enum value 5002) (#23281)
- [x] CS1928 BadExtensionArgTypes (#22999)
- [x] CS1929 BadInstanceArgType  (#22748)
- [x] CS1950 BadArgTypesForCollectionAdd (#22525)
- [x] CS1954 InitializerAddHasParamModifiers (#22525)
","Remove checks for impossible conditions from Microsoft.CSharp  dotnet/corefx#22456 removed some error codes that were never used, but there is other code in Microsoft.CSharp that checks for conditions that are irrelevant (can only happen when defining a t",25827,JonHanna,corefx
24404,Microsoft.CSharp fails on ones-complement on enums smaller than 32-bit in size in checked context,"```C#
public enum Int8Enum : byte
{
	A,
	B,
	C,
	D,
	E
}
 /* … */

dynamic d = Int8Enum.A;
checked{
var result = ~d; // Throws OverflowException
}
```

I'm afraid I introduced this regression with 184d882d which was meant to remove all of the setting of `CheckedNormal` and `CheckedNormal` (since merged as `Checked`) and leave the false default, but it left the redundant setting of it before then, so it can now be set wrong (it should always be false, but that will set it to true if the initial context is checked).

The same regression can cause assignments to have slightly less good (but still reasonable) error messages.","Microsoft.CSharp fails on ones-complement on enums smaller than 32-bit in size in checked context  ```C#
public enum Int8Enum : byte
{
	A,
	B,
	C,
	D,
	E
}
 /* … */

dynamic d = Int8Enum.A;
checked{
var result = ~d; // Throws OverflowExceptio",25825,JonHanna,corefx
22868,Remove checks for impossible conditions from Microsoft.CSharp,"dotnet/corefx#22456 removed some error codes that were never used, but there is other code in Microsoft.CSharp that checks for conditions that are irrelevant (can only happen when defining a type, constant operations, or other cases that only come up in static code) or impossible (lacking a mscorlib, types like `int` and `object` aren't available, in which case there would have been a fatal error before the code had a chance to run).

The removal of this dead code of course needs to be careful of removing a condition that actually could happen, in which case a test cases that hit it should be added or if that's difficult for some reason the condition should be clearly documented in a comment.

This issue is to track that.

The following is a list of all errors not currently hit during testing. This isn't a perfect to-do list (the same error could have both possible and impossible paths to it) and it includes some cases that I think should definitely be reachable (but they should be covered by tests anyway for dotnet/runtime#19616 and marked off as soon as confirmed as reachable, and besides I could be wrong), but it will serve as a gauge. There could also be cases that cannot be hit but should be, as per dotnet/corefx#22534)

- [x] CS0031 ConstOutOfRange (#25825)
- [x] CS0035 AmbigUnaryOp (#22549)
- [x] CS0038 WrongNestedThis (#26417)
- [x] CS0120 ObjectRequired (#22682)
- [x] CS0123 MethDelegateMismatch (#25217)
- [ ] CS0131 AssgLvalueExpected
- [x] CS0143 NoConstructors (#23069)
- [x] CS0148 BadDelegateConstructor (#23371)
- [x] CS0176 ObjectProhibited (#22682)
- [x] CS0192 RefReadonly (#25042)
- [ ] CS0198 AssgReadonlyStatic
- [x] CS0199 RefReadonlyStatic (#25042)
- [x] CS0205 AbstractBaseCall (#22518)
- [x] CS0206 RefProperty (#25042)
- [x] CS0218 MustHaveOpTF (#22782)
- [x] CS0221 ConstOutOfRangeChecked (#25825)
- [x] CS0229 AmbigMember (#25827)
- [x] CS0233 SizeofUnsafe (#22519)
- [x] CS0245 CallingFinalizeDepracated (#22518)
- [x] CS0250 CallingBaseFinalizeDeprecated (#22518)
- [x] CS0306 BadTypeArgument (#23286)
- [x] CS0307 TypeArgsNotAllowed (#23069)
- [x] CS0312 GenericConstraintNotSatisfiedNullableEnum (#23069)
- [x] CS0313 GenericConstraintNotSatisfiedNullableInterface (#23069)
- [x] CS0314 GenericConstraintNotSatisfiedTyVar (#23287)
- [x] CS0403 TypeVarCantBeNull (#23278)
- [x] CS0407 BadRetType (#23371)
- [x] CS0428 MethGrpToNonDel (#23371)
- [x] CS0452 RefConstraintNotSatisfied (#22549)
- [x] CS0518 PredefinedTypeNotFound (#22471)
- [ ] CS0570 BindToBogus
- [x] CS0571 CantCallSpecialMethod (#22549)
- [x] CS0648 BogusType (#22537)
- [x] CS0656 MissingPredefinedMember (#22541)
- [x] CS0664 LiteralDoubleCast (#22533)
- [x] CS0716 ConvertToStaticClass (#22549)
- [x] CS0718 GenericArgIsStaticClass (#23286)
- [x] CS0762 PartialMethodToDelegate (#22548)
- [x] CS1061 NoSuchMemberOrExtension (#22999)
- [x] CS1113 ValueTypeExtDelegate (#22999)
- [x] CS1503 BadArgType (#22748)
- [x] CS1510 RefLvalueExpected (#25042)
- [x] CS1545 BindToBogusProp2 (Should be used but wasn't, fixed in dotnet/corefx#22537)
- [x] CS1546 BindToBogusProp1 (Should be used but wasn't, fixed in dotnet/corefx#22537)
- [x] CS1594 BadDelArgTypes (#25218)
- [x] CS1604 AssgReadonlyLocal (#25042)
- [x] CS1605 RefReadonlyLocal (#25042)
- [x] CS1612 ReturnNotLValue (#26370)
- [x] CS1615 BadArgExtraRef (#22748)
- [x] CS1620 BadArgRef (#22748)
- [x] CS1648 AssgReadonly2 (#26370)
- [x] CS1649 RefReadonly2 (#25042)
- [x] CS1650 AssgReadonlyStatic2 (#26370)
- [x] CS1651 RefReadonlyStatic2 (#25042)
- [x] CS1656 AssgReadonlyLocalCause (#25214)
- [x] CS1657 RefReadonlyLocalCause (#25042)
- [x] CS1728 DelegateOnNullable (#23371)
- [x] CS1729 BadCtorArgCount (#23069)
- [x] CS1740 DuplicateNamedArgument (Enum value 5005) (#23281)
- [x] CS1744 NamedArgumentSpecificationBeforeFixedArgument (Enum value 5002) (#23281)
- [x] CS1928 BadExtensionArgTypes (#22999)
- [x] CS1929 BadInstanceArgType  (#22748)
- [x] CS1950 BadArgTypesForCollectionAdd (#22525)
- [x] CS1954 InitializerAddHasParamModifiers (#22525)
","Remove checks for impossible conditions from Microsoft.CSharp  dotnet/corefx#22456 removed some error codes that were never used, but there is other code in Microsoft.CSharp that checks for conditions that are irrelevant (can only happen when defining a t",25825,JonHanna,corefx
24405,Microsoft.CSharp throws InvalidCast on complement of constant enum value,"```C#
var cs =CallSite<Func<CallSite, object, object>>.Create(
	Microsoft.CSharp.RuntimeBinder. Binder.UnaryOperation(
		CSharpBinderFlags.CheckedContext , ExpressionType.OnesComplement, GetType(),
		new[] { CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.Constant, null) }));
cs.Target(cs, StringComparison.CurrentCulture);
```
or
```C#
var cs =CallSite<Func<CallSite, object, object>>.Create(
	Microsoft.CSharp.RuntimeBinder. Binder.UnaryOperation(
		CSharpBinderFlags.None , ExpressionType.OnesComplement, GetType(),
		new[] { CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.Constant, null) }));
cs.Target(cs, StringComparison.CurrentCulture);
```
Throws `InvalidCastException` ""Unable to cast object of type 'Microsoft.CSharp.RuntimeBinder.Semantics.EXPRCONSTANT' to type 'Microsoft.CSharp.RuntimeBinder.Semantics.EXPRCAST'.""

Same issue exists in NetFX.","Microsoft.CSharp throws InvalidCast on complement of constant enum value  ```C#
var cs =CallSite<Func<CallSite, object, object>>.Create(
	Microsoft.CSharp.RuntimeBinder. Binder.UnaryOperation(
		CSharpBinderFlags.CheckedContext , ExpressionType.OnesCom",25825,JonHanna,corefx
23419,Don't directly throw Exception,"When looking at https://github.com/Microsoft/dotnet/issues/471, I noticed that the thrown exception is `Exception`, not a type derived from `Exception`.

I think this should not be done and [the Framework Design Guidelines](https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/using-standard-exception-types#exception-and-systemexception) agree. Instead, some derived type should be thrown.

This issue seems to happen in a few places in CoreFX:

```
$ git grep -n 'new Exception(' | grep -v tests | cut -d: -f1,2
Common/src/System/Drawing/ColorConverterCommon.cs:131
System.ComponentModel.TypeConverter/src/System/ComponentModel/BaseNumberConverter.cs:48
System.Configuration.ConfigurationManager/src/System/Configuration/GenericEnumConverter.cs:35
System.Configuration.ConfigurationManager/src/System/Configuration/GenericEnumConverter.cs:42
System.Configuration.ConfigurationManager/src/System/Configuration/GenericEnumConverter.cs:47
System.Configuration.ConfigurationManager/src/System/Configuration/ProtectedConfigurationSection.cs:58
System.Configuration.ConfigurationManager/src/System/Configuration/ProtectedConfigurationSection.cs:88
System.Data.SqlClient/src/System/Data/SqlClient/SNI/SNIProxy.cs:162
System.Data.SqlClient/src/System/Data/SqlClient/SNI/SNIProxy.cs:166
System.Data.SqlClient/src/System/Data/SqlClient/SqlUtil.cs:191
System.Drawing.Common/src/System/Drawing/Graphics.cs:216
System.IO.FileSystem.AccessControl/src/System/Security/AccessControl/DirectoryObjectSecurity.cs:352
System.IO.FileSystem.AccessControl/src/System/Security/AccessControl/DirectoryObjectSecurity.cs:398
System.IO.FileSystem.AccessControl/src/System/Security/AccessControl/DirectoryObjectSecurity.cs:417
System.IO.FileSystem.AccessControl/src/System/Security/AccessControl/DirectoryObjectSecurity.cs:493
System.Net.Http/src/System/Net/Http/Unix/CurlHandler.CurlResponseMessage.cs:61
System.Net.Mail/src/System/Net/Mail/MailHeaderInfo.cs:79
System.Net.WebSockets.Client/src/System/Net/WebSockets/WebSocketHandle.WinRT.cs:49
System.Private.DataContractSerialization/src/System/Runtime/Serialization/DiagnosticUtility.cs:83
System.Private.DataContractSerialization/src/System/Runtime/Serialization/Json/XmlJsonReader.cs:357
System.Private.Xml/src/System/Xml/BinaryXml/XmlBinaryReader.cs:3217
System.Private.Xml/src/System/Xml/BinaryXml/XmlBinaryReader.cs:3219
System.Private.Xml/src/System/Xml/Core/XmlTextReaderImplAsync.cs:3609
System.Private.Xml/src/System/Xml/Serialization/XmlSerializationWriter.cs:1925
System.Private.Xml/src/System/Xml/Serialization/Xmlcustomformatter.cs:80
System.Private.Xml/src/System/Xml/Serialization/Xmlcustomformatter.cs:246
System.Private.Xml/src/System/Xml/Xsl/Xslt/XPathPatternBuilder.cs:331
System.Runtime.WindowsRuntime/src/System/Runtime/InteropServices/WindowsRuntime/WindowsRuntimeBuffer.cs:94
System.Runtime.WindowsRuntime/src/System/Threading/Tasks/TaskToAsyncInfoAdapter.cs:983
System.Security.AccessControl/src/System/Security/AccessControl/SecurityDescriptor.cs:675
System.Threading.Tasks.Dataflow/src/Base/DataflowBlock.cs:1356
```

There are also many cases where CoreFX tests throw `Exception`, but I think that's okay.","Don't directly throw Exception  When looking at https://github.com/Microsoft/dotnet/issues/471, I noticed that the thrown exception is `Exception`, not a type derived from `Exception`.

I think this should not be done and [the Framework Design Guideline",25822,satano,corefx
25139,Removed throwing general Exception in ConfigurationManager,"This PR addresses issue #23748, project **System.Configuration.ConfigurationManager**.

Throwing general `Exception` class is removed.","Removed throwing general Exception in ConfigurationManager  This PR addresses issue #23748, project **System.Configuration.ConfigurationManager**.

Throwing general `Exception` class is removed.",25822,satano,corefx
24256,"""Don't directly throw Exception"" System.Drawing","@safern i'm trying to fix ""throw new Exception()"" on System.Drawing(#23748) but as @karelz thought may be a compatibility concerns, with netfx. What do you think?I could split tests per platform, but i think that is not a good idea. Is it better to skip System.Drawing and go on with other?","""Don't directly throw Exception"" System.Drawing  @safern i'm trying to fix ""throw new Exception()"" on System.Drawing(#23748) but as @karelz thought may be a compatibility concerns, with netfx. What do you think?I could split tests per platform, but i thin",25791,MarcoRossignoli,corefx
23419,Don't directly throw Exception,"When looking at https://github.com/Microsoft/dotnet/issues/471, I noticed that the thrown exception is `Exception`, not a type derived from `Exception`.

I think this should not be done and [the Framework Design Guidelines](https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/using-standard-exception-types#exception-and-systemexception) agree. Instead, some derived type should be thrown.

This issue seems to happen in a few places in CoreFX:

```
$ git grep -n 'new Exception(' | grep -v tests | cut -d: -f1,2
Common/src/System/Drawing/ColorConverterCommon.cs:131
System.ComponentModel.TypeConverter/src/System/ComponentModel/BaseNumberConverter.cs:48
System.Configuration.ConfigurationManager/src/System/Configuration/GenericEnumConverter.cs:35
System.Configuration.ConfigurationManager/src/System/Configuration/GenericEnumConverter.cs:42
System.Configuration.ConfigurationManager/src/System/Configuration/GenericEnumConverter.cs:47
System.Configuration.ConfigurationManager/src/System/Configuration/ProtectedConfigurationSection.cs:58
System.Configuration.ConfigurationManager/src/System/Configuration/ProtectedConfigurationSection.cs:88
System.Data.SqlClient/src/System/Data/SqlClient/SNI/SNIProxy.cs:162
System.Data.SqlClient/src/System/Data/SqlClient/SNI/SNIProxy.cs:166
System.Data.SqlClient/src/System/Data/SqlClient/SqlUtil.cs:191
System.Drawing.Common/src/System/Drawing/Graphics.cs:216
System.IO.FileSystem.AccessControl/src/System/Security/AccessControl/DirectoryObjectSecurity.cs:352
System.IO.FileSystem.AccessControl/src/System/Security/AccessControl/DirectoryObjectSecurity.cs:398
System.IO.FileSystem.AccessControl/src/System/Security/AccessControl/DirectoryObjectSecurity.cs:417
System.IO.FileSystem.AccessControl/src/System/Security/AccessControl/DirectoryObjectSecurity.cs:493
System.Net.Http/src/System/Net/Http/Unix/CurlHandler.CurlResponseMessage.cs:61
System.Net.Mail/src/System/Net/Mail/MailHeaderInfo.cs:79
System.Net.WebSockets.Client/src/System/Net/WebSockets/WebSocketHandle.WinRT.cs:49
System.Private.DataContractSerialization/src/System/Runtime/Serialization/DiagnosticUtility.cs:83
System.Private.DataContractSerialization/src/System/Runtime/Serialization/Json/XmlJsonReader.cs:357
System.Private.Xml/src/System/Xml/BinaryXml/XmlBinaryReader.cs:3217
System.Private.Xml/src/System/Xml/BinaryXml/XmlBinaryReader.cs:3219
System.Private.Xml/src/System/Xml/Core/XmlTextReaderImplAsync.cs:3609
System.Private.Xml/src/System/Xml/Serialization/XmlSerializationWriter.cs:1925
System.Private.Xml/src/System/Xml/Serialization/Xmlcustomformatter.cs:80
System.Private.Xml/src/System/Xml/Serialization/Xmlcustomformatter.cs:246
System.Private.Xml/src/System/Xml/Xsl/Xslt/XPathPatternBuilder.cs:331
System.Runtime.WindowsRuntime/src/System/Runtime/InteropServices/WindowsRuntime/WindowsRuntimeBuffer.cs:94
System.Runtime.WindowsRuntime/src/System/Threading/Tasks/TaskToAsyncInfoAdapter.cs:983
System.Security.AccessControl/src/System/Security/AccessControl/SecurityDescriptor.cs:675
System.Threading.Tasks.Dataflow/src/Base/DataflowBlock.cs:1356
```

There are also many cases where CoreFX tests throw `Exception`, but I think that's okay.","Don't directly throw Exception  When looking at https://github.com/Microsoft/dotnet/issues/471, I noticed that the thrown exception is `Exception`, not a type derived from `Exception`.

I think this should not be done and [the Framework Design Guideline",25791,MarcoRossignoli,corefx
24374,S.L.Expressions rejects valid conversions,"Given an interface `IInterface` and an unsealed class `UnsealedClass` that does not implement it, then the following delegate is valid, and works:

```C#
Func<NotSealed[], IInterface[]> f = x => (IInterface[])x;
```

It will fail at runtime if we call `f(new UnsealedClass[0])` but could work if there was a derived class that implemented `IInterface` and we called `f(new Derived[0])`, etc.

However the equivalent expression:

```C#
Expression<Func<NotSealed[], IInterface[]>> f = x => (IInterface[])x;
```

…fails with `InvalidOperationException`, ""No coercion operator is defined between types 'NotSealed[]' and 'IInterface[]'.""

This is the root cause of dotnet/runtime#24370","S.L.Expressions rejects valid conversions  Given an interface `IInterface` and an unsealed class `UnsealedClass` that does not implement it, then the following delegate is valid, and works:

```C#
Func<NotSealed[], IInterface[]> f = x => (IInterface[])",25768,JonHanna,corefx
24370,Explicit dynamic conversion between some runtime-uncastable types gives wrong exception at wrong time.,"Given an interface `IInterface` and an unsealed class `UnsealedClass` that does not implement it, then the following fails at runtime with `InvalidCastException`:

```C#
var uc = new UnsealedClass[0];
IInterface[] ar = (IInterface[])uc;
```

However, the following:
```C#
dynamic uc = new UnsealedClass[0];
IInterface[] ar = (IInterface[])uc;
```

Fails with `InvalidOperationException` and the inappropriate message ""No coercion operator is defined between types 'UnsealedClass[]' and 'IInterface[]'."" (inappropriate as if it had been an array of a type that implemented `IInterface` no coercion operator would have been necessary).

Also, any calling code that had a separation between creating the `DynamicMetaObject` for the operation and later getting the result or raising the exception will have the exception thrown at the initial stage that shouldn't throw; potentially when the client may not be prepared to recover from it.

Similar issues exist in other cases where the C# rules for which explicit casts are allowed to be compiled depend on examining components of the types involved (e.g. between `UnsealedClass[]` and `IList<IInterface>`.

There are worse cases with explicitly typed source types, as if `uc` above was `(UnsealedClass[])Derived[0]` where `Derived` is derived from `UnsealedClass` and implements `IInterface` then the cast would work, but the equivalent explicitly typed `Binder.Convert()` would throw.","Explicit dynamic conversion between some runtime-uncastable types gives wrong exception at wrong time.  Given an interface `IInterface` and an unsealed class `UnsealedClass` that does not implement it, then the following fails at runtime with `InvalidCast",25768,JonHanna,corefx
24054,Test failure: System.Diagnostics.Tests.EventLogEntryCollectionTests/CheckingEntryEqualityAndIndex,"Opened on behalf of @Sunny-pu

The test `System.Diagnostics.Tests.EventLogEntryCollectionTests/CheckingEntryEqualityAndIndex` has failed.

Assert.Equal() Failure\r
    Expected: 1\r
    Actual:   0

        Stack Trace:

           at System.Diagnostics.Tests.Helpers.WaitForEventLog(EventLog eventLog, Int32 entriesExpected) in E:\A\_work\1586\s\corefx\src\System.Diagnostics.EventLog\tests\Helpers.cs:line 69
       at System.Diagnostics.Tests.EventLogEntryCollectionTests.CheckingEntryEqualityAndIndex() in E:\A\_work\1586\s\corefx\src\System.Diagnostics.EventLog\tests\EventLogEntryCollectionTests.cs:line 85
Build : Master - 20171106.02 (Core Tests)
Failing configurations:
- Windows.81.Amd64-x86
  - Release
- Windows.7.Amd64-x86
  - Release","Test failure: System.Diagnostics.Tests.EventLogEntryCollectionTests/CheckingEntryEqualityAndIndex  Opened on behalf of @Sunny-pu

The test `System.Diagnostics.Tests.EventLogEntryCollectionTests/CheckingEntryEqualityAndIndex` has failed.

Assert.Equal(",25695,Anipik,corefx
23960,EventLogEntryCollectionTests.CheckingEntryEqualityAndIndex failed with ArgumentException,"https://mc.dot.net/#/user/stephentoub/pr~2Fjenkins~2Fdotnet~2Fcorefx~2Fmaster~2F/test~2Ffunctional~2Fcli~2F/94474b7e9325802a019eace4ffce5cb6add96b0b/workItem/System.Diagnostics.EventLog.Tests/analysis/xunit/System.Diagnostics.Tests.EventLogEntryCollectionTests~2FCheckingEntryEqualityAndIndex
```
Unhandled Exception of Type System.ArgumentException
Message :
System.ArgumentException : Index -1 is out of bounds.
Stack Trace :
   at System.Diagnostics.EventLogInternal.GetEntryAt(Int32 index)
   at System.Diagnostics.EventLogEntryCollection.get_Item(Int32 index)
   at System.Diagnostics.Tests.EventLogEntryCollectionTests.CheckingEntryEqualityAndIndex()
```",EventLogEntryCollectionTests.CheckingEntryEqualityAndIndex failed with ArgumentException  https://mc.dot.net/#/user/stephentoub/pr~2Fjenkins~2Fdotnet~2Fcorefx~2Fmaster~2F/test~2Ffunctional~2Fcli~2F/94474b7e9325802a019eace4ffce5cb6add96b0b/workItem/System.,25695,Anipik,corefx
12061,Minor change to avoid an allocation in Uri,"We can avoid allocating a substring and just fix directly on `relativeStr`.

@CIPop @davidsh ","Minor change to avoid an allocation in Uri  We can avoid allocating a substring and just fix directly on `relativeStr`.

@CIPop @davidsh ",25643,rmkerr,corefx
24266,Ctor of System.Uri transform Uri to lowercase,"I got into this bug when was moving library to .Net Standard 2:
When we construct Uri by combining two Uri's, one with absolute path, and another with Relative:
`var sut = new Uri(new Uri(""https://your_azure_account.restv2.westeurope.media.azure.net/api/"", UriKind.Absolute), new Uri(""ContentKeys('nb:kid:UUID:7deef38d-3432-4747-a5b2-0cd2f06a6edd')/GetKeyDeliveryUrl"", UriKind.Relative));`

It lowers ""ContentKeys"":
`https://your_azure_account.restv2.westeurope.media.azure.net/api/contentkeys('nb:kid:UUID:7deef38d-3432-4747-a5b2-0cd2f06a6edd')/GetKeyDeliveryUrl`
instead of 
`https://your_azure_account.restv2.westeurope.media.azure.net/api/ContentKeys('nb:kid:UUID:7deef38d-3432-4747-a5b2-0cd2f06a6edd')/GetKeyDeliveryUrl`
which you'll get e.g. in .Net 4.7.2. 

Interesting, but GetKeyDeliveryUrl isn't getting lowered.

This bug breaks retrieving of key delivery Url if you're using Microsoft.Data.Services.Client library.","Ctor of System.Uri transform Uri to lowercase  I got into this bug when was moving library to .Net Standard 2:
When we construct Uri by combining two Uri's, one with absolute path, and another with Relative:
`var sut = new Uri(new Uri(""https://your_azur",25643,rmkerr,corefx
24037,"Test: System.Net.Security.Tests.SslStreamAlpnTests/SslStream_StreamToStream_Alpn_Success failed with ""Xunit.Sdk.EqualException""","Opened on behalf of @Jiayili1

The test `System.Net.Security.Tests.SslStreamAlpnTests/SslStream_StreamToStream_Alpn_Success(clientProtocols: [http/1.1, h2], serverProtocols: [h2], expected: h2)` has failed.

Assert.Equal() Failure
    Expected: h2
    Actual:   (null)

        Stack Trace:

           at System.Net.Security.Tests.SslStreamAlpnTests.SslStream_StreamToStream_Alpn_Success(List`1 clientProtocols, List`1 serverProtocols, SslApplicationProtocol expected) in /root/corefx-1108295/src/System.Net.Security/tests/FunctionalTests/SslStreamAlpnTests.cs:line 113
Build : Master - 20171103.01 (Core Tests)
Failing configurations:
- RedHat.69.Amd64-x64
  - Debug
  - Release

Detail: https://mc.dot.net/#/product/netcore/master/source/official~2Fcorefx~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20171103.01/workItem/System.Net.Security.Tests/analysis/xunit/System.Net.Security.Tests.SslStreamAlpnTests~2FSslStream_StreamToStream_Alpn_Success(clientProtocols:%20%5Bhttp~2F1.1,%20h2%5D,%20serverProtocols:%20%5Bh2%5D,%20expected:%20h2)","Test: System.Net.Security.Tests.SslStreamAlpnTests/SslStream_StreamToStream_Alpn_Success failed with ""Xunit.Sdk.EqualException""  Opened on behalf of @Jiayili1

The test `System.Net.Security.Tests.SslStreamAlpnTests/SslStream_StreamToStream_Alpn_Success(",25637,Priya91,corefx
24323,ALPN tests failing on RedHat,"https://mc.dot.net/#/user/Drawaes/pr~2Fjenkins~2Fdotnet~2Fcorefx~2Fmaster~2F/test~2Ffunctional~2Fcli~2F/5e70fee9f1339db71f723caac7a85d55346c9a09/workItem/System.Net.Security.Tests/wilogs
```
2017-12-02 23:41:32,500: INFO: proc(54): run_and_log_output: Output:    System.Net.Security.Tests.SslStreamAlpnTests.SslStream_StreamToStream_Alpn_NonMatchingProtocols_Fail [FAIL]
2017-12-02 23:41:32,500: INFO: proc(54): run_and_log_output: Output:       AuthenticationException was not thrown.
2017-12-02 23:41:32,500: INFO: proc(54): run_and_log_output: Output:       Expected: True
2017-12-02 23:41:32,501: INFO: proc(54): run_and_log_output: Output:       Actual:   False
2017-12-02 23:41:32,513: INFO: proc(54): run_and_log_output: Output:       Stack Trace:
2017-12-02 23:41:32,870: INFO: proc(54): run_and_log_output: Output:          /mnt/j/workspace/dotnet_corefx/master/linux-TGroup_netcoreapp+CGroup_Release+AGroup_x64+TestOuter_false_prtest/src/System.Net.Security/tests/FunctionalTests/SslStreamAlpnTests.cs(157,0): at System.Net.Security.Tests.SslStreamAlpnTests.<SslStream_StreamToStream_Alpn_NonMatchingProtocols_Fail>d__4.MoveNext()
2017-12-02 23:41:32,870: INFO: proc(54): run_and_log_output: Output:          --- End of stack trace from previous location where exception was thrown ---
2017-12-02 23:41:32,870: INFO: proc(54): run_and_log_output: Output:          --- End of stack trace from previous location where exception was thrown ---
2017-12-02 23:41:32,870: INFO: proc(54): run_and_log_output: Output:          --- End of stack trace from previous location where exception was thrown ---
2017-12-02 23:41:32,870: INFO: proc(54): run_and_log_output: Output:    System.Net.Security.Tests.SslStreamAlpnTests.SslStream_StreamToStream_Alpn_Success(clientProtocols: [http/1.1, h2], serverProtocols: [h2], expected: h2) [FAIL]
2017-12-02 23:41:32,870: INFO: proc(54): run_and_log_output: Output:       Assert.Equal() Failure
2017-12-02 23:41:32,870: INFO: proc(54): run_and_log_output: Output:       Expected: h2
2017-12-02 23:41:32,870: INFO: proc(54): run_and_log_output: Output:       Actual:   (null)
2017-12-02 23:41:32,870: INFO: proc(54): run_and_log_output: Output:       Stack Trace:
2017-12-02 23:41:32,871: INFO: proc(54): run_and_log_output: Output:          /mnt/j/workspace/dotnet_corefx/master/linux-TGroup_netcoreapp+CGroup_Release+AGroup_x64+TestOuter_false_prtest/src/System.Net.Security/tests/FunctionalTests/SslStreamAlpnTests.cs(116,0): at System.Net.Security.Tests.SslStreamAlpnTests.<SslStream_StreamToStream_Alpn_Success>d__3.MoveNext()
2017-12-02 23:41:32,871: INFO: proc(54): run_and_log_output: Output:          --- End of stack trace from previous location where exception was thrown ---
2017-12-02 23:41:32,871: INFO: proc(54): run_and_log_output: Output:          --- End of stack trace from previous location where exception was thrown ---
2017-12-02 23:41:32,871: INFO: proc(54): run_and_log_output: Output:          --- End of stack trace from previous location where exception was thrown ---
2017-12-02 23:41:33,124: INFO: proc(54): run_and_log_output: Output:    System.Net.Security.Tests.SslStreamAlpnTests.SslStream_StreamToStream_Alpn_Success(clientProtocols: [http/1.1], serverProtocols: [http/1.1, h2], expected: http/1.1) [FAIL]
2017-12-02 23:41:33,124: INFO: proc(54): run_and_log_output: Output:       Assert.Equal() Failure
2017-12-02 23:41:33,124: INFO: proc(54): run_and_log_output: Output:       Expected: http/1.1
2017-12-02 23:41:33,124: INFO: proc(54): run_and_log_output: Output:       Actual:   (null)
2017-12-02 23:41:33,124: INFO: proc(54): run_and_log_output: Output:       Stack Trace:
2017-12-02 23:41:33,125: INFO: proc(54): run_and_log_output: Output:          /mnt/j/workspace/dotnet_corefx/master/linux-TGroup_netcoreapp+CGroup_Release+AGroup_x64+TestOuter_false_prtest/src/System.Net.Security/tests/FunctionalTests/SslStreamAlpnTests.cs(116,0): at System.Net.Security.Tests.SslStreamAlpnTests.<SslStream_StreamToStream_Alpn_Success>d__3.MoveNext()
2017-12-02 23:41:33,125: INFO: proc(54): run_and_log_output: Output:          --- End of stack trace from previous location where exception was thrown ---
2017-12-02 23:41:33,125: INFO: proc(54): run_and_log_output: Output:          --- End of stack trace from previous location where exception was thrown ---
2017-12-02 23:41:33,125: INFO: proc(54): run_and_log_output: Output:          --- End of stack trace from previous location where exception was thrown ---
2017-12-02 23:41:33,214: INFO: proc(54): run_and_log_output: Output:    System.Net.Security.Tests.SslStreamAlpnTests.SslStream_StreamToStream_Alpn_Success(clientProtocols: [http/1.1, h2], serverProtocols: [http/1.1, h2], expected: http/1.1) [FAIL]
2017-12-02 23:41:33,214: INFO: proc(54): run_and_log_output: Output:       Assert.Equal() Failure
2017-12-02 23:41:33,214: INFO: proc(54): run_and_log_output: Output:       Expected: http/1.1
2017-12-02 23:41:33,214: INFO: proc(54): run_and_log_output: Output:       Actual:   (null)
2017-12-02 23:41:33,214: INFO: proc(54): run_and_log_output: Output:       Stack Trace:
2017-12-02 23:41:33,215: INFO: proc(54): run_and_log_output: Output:          /mnt/j/workspace/dotnet_corefx/master/linux-TGroup_netcoreapp+CGroup_Release+AGroup_x64+TestOuter_false_prtest/src/System.Net.Security/tests/FunctionalTests/SslStreamAlpnTests.cs(116,0): at System.Net.Security.Tests.SslStreamAlpnTests.<SslStream_StreamToStream_Alpn_Success>d__3.MoveNext()
2017-12-02 23:41:33,215: INFO: proc(54): run_and_log_output: Output:          --- End of stack trace from previous location where exception was thrown ---
2017-12-02 23:41:33,215: INFO: proc(54): run_and_log_output: Output:          --- End of stack trace from previous location where exception was thrown ---
2017-12-02 23:41:33,215: INFO: proc(54): run_and_log_output: Output:          --- End of stack trace from previous location where exception was thrown ---
```","ALPN tests failing on RedHat  https://mc.dot.net/#/user/Drawaes/pr~2Fjenkins~2Fdotnet~2Fcorefx~2Fmaster~2F/test~2Ffunctional~2Fcli~2F/5e70fee9f1339db71f723caac7a85d55346c9a09/workItem/System.Net.Security.Tests/wilogs
```
2017-12-02 23:41:32,500: INFO: p",25637,Priya91,corefx
23460,System.Net.Http httpClient ServerCertificateCustomValidationCallback does not include the intermediate certificates provided by the server,"When we assign a callback to ServerCertificateCustomValidationCallback (SCCVC) (tested on Win7/Win8.1,) the passed ""chain"" arg only includes the server certificate but no intermediate certs passed by the server. The ""chain"" only has multiple ChainElements if the server cert is signed by a certificate, intermediate or root, that exists in the local store. If we have a cert signed by an intermediate CA and that cert is chained by the server, even if that CA cert is in turn signed by a root/intermediate CA that exists in the store, the chain will not include any of the intermediate certificates, and will show just the server certificate. In such a case where the root cert exists in the store and the intermediate cert is chained by the HTTPS server, the request will go through successfully when no callback is defined, yet show up in the callback with ChainElements.Count == 1 and SslPolicyErrors != none; which some might find a smidge ironic. 

The following are the current behaviors and the corresponding behavior in the ServerCertificateValidationCallback (SCVC) in .NET Framework which I assume should be the expected behavior here.

1) When the server passes a certificate chain and a given certificate is _different_ to the one in the store for the same CN/SAN, SCCVC gets the store cert, while SCVC (expected) gets the one passed by the server.

2) When the server passes a certificate chain which does not conflict with the store, SCCVC does not get any of the certificates passed to ""chain"" other than the server cert itself. Expected behavior per SCVC is to have the server intermediate certs passed along and ADDITIONAL certs, only if the final cert is not self-signed, added to the chain where appropriate.

This is preventing us from using httpClient in production. We have our certs signed by an intermediate CA which we cannot install on target systems' local cert stores. Furthermore, we use an internal root CA for testing and we would prefer to compare the CA cert to the final cert in the chain in the validation callback, rather than installing and re-installing certs as test CAs pop in and out of existence.","System.Net.Http httpClient ServerCertificateCustomValidationCallback does not include the intermediate certificates provided by the server  When we assign a callback to ServerCertificateCustomValidationCallback (SCCVC) (tested on Win7/Win8.1,) the passed",23951,davidsh,corefx
15694,WinHTTP certificate chain build algorithm is potentially not including certificates obtained from the TLS connection,"Similarly to how SslStream is including TLS certificates obtained from Schannel, WinHTTP should use the `PCERT_CONTEXT` obtained using `WINHTTP_OPTION_SERVER_CERT_CONTEXT` to extract certificates from the virtual store and use them during chain construction.

See https://github.com/dotnet/corefx/blob/master/src/Common/src/Interop/Windows/SChannel/UnmanagedCertificateContext.cs for reference.","WinHTTP certificate chain build algorithm is potentially not including certificates obtained from the TLS connection  Similarly to how SslStream is including TLS certificates obtained from Schannel, WinHTTP should use the `PCERT_CONTEXT` obtained using `W",23951,davidsh,corefx
21463,Make IdnaConformance tests easier to diagnose when they go wrong,"See #21344

Now we get this
```
System.Globalization.Tests.IdnMappingIdnaConformanceTests.GetAscii_Invalid [FAIL]
        Assert.All() Failure: 1 out of 195 items in the collection did not pass.
        [160]: System.Exception: Expected IdnMapping.GetAscii(""\u55298\u56818\u0046\u0045\u0045\u0045\u1701\u2002"") to
  throw an ArgumentException.
                  at System.Globalization.Tests.IdnMappingIdnaConformanceTests.<>c.<GetAscii_Invalid>b__2_1(IConformanc
  eIdnaTest entry)
                  at Xunit.Assert.All[T](IEnumerable`1 collection, Action`1 action)
        Stack Trace:
              at System.Globalization.Tests.IdnMappingIdnaConformanceTests.GetAscii_Invalid()

``","Make IdnaConformance tests easier to diagnose when they go wrong  See #21344

Now we get this
```
System.Globalization.Tests.IdnMappingIdnaConformanceTests.GetAscii_Invalid [FAIL]
        Assert.All() Failure: 1 out of 195 items in the collection did",23933,danmosemsft,corefx
21488,Fix failing Globalization test for Windows updates and update GetCodePoints,"Fixes #21344

@viktorhofer @tarekgh","Fix failing Globalization test for Windows updates and update GetCodePoints  Fixes #21344

@viktorhofer @tarekgh",23933,danmosemsft,corefx
23339,"HttpUtility.ParseQueryString does HTML decoding first on CoreFX, but not on NetFX","The version of `HttpUtility.ParseQueryString` in CoreFX does HTML decoding first, differing from desktop:

```C#
HttpUtility.ParseQueryString(""name=value&amp;name2=value2"").ToString()
// name=value&amp%3bname2=value2 on Desktop
// name=value&name2=value2 on CoreFX

HttpUtility.ParseQueryString(""?name=valu&#xe9;"")[""name""]
// valu on Desktop
// valué on CoreFX
```

dotnet/runtime#23334 is a knock-on effect of this. (Closing as such).
dotnet/runtime#23335 is an indirect knock-on effect in that ? is stripped both before and after HTML decoding that shouldn't be done at all.","HttpUtility.ParseQueryString does HTML decoding first on CoreFX, but not on NetFX  The version of `HttpUtility.ParseQueryString` in CoreFX does HTML decoding first, differing from desktop:

```C#
HttpUtility.ParseQueryString(""name=value&amp;name2=value",23918,JonHanna,corefx
23335,HttpUtility.ParseQueryString incorrect if first item's name begins with a question mark,"If a query-string's first name-value pair begins with a question mark then the initial question mark is stripped twice, so the name in the parsed collection is incorrect.

E.g. with `??name=value&x=y` the result is a collection where `[""name""] == ""value""` while if it isn't the first element, as in `?x=y&?name=value` then it has the correct result of `[""?name""] == ""value""`","HttpUtility.ParseQueryString incorrect if first item's name begins with a question mark  If a query-string's first name-value pair begins with a question mark then the initial question mark is stripped twice, so the name in the parsed collection is incorr",23918,JonHanna,corefx
23591,Fix two issues in System.Web.HttpUtility,"* Don't HTML-decode in HttpUtility.ParseQueryString

Fixes #23582

* Only strip initial ? in HttpUtility.ParseQueryString once.

Fixes #23574

* Simplify ParseQueryString exit logic.

Checks for exit conditions two ways, when just one suffices.

* Inline private ParseQueryString into caller.

Allows for avoiding allocation for initial ?

* Add more HttpUtilityTests","Fix two issues in System.Web.HttpUtility  * Don't HTML-decode in HttpUtility.ParseQueryString

Fixes #23582

* Only strip initial ? in HttpUtility.ParseQueryString once.

Fixes #23574

* Simplify ParseQueryString exit logic.

Checks for exit con",23918,JonHanna,corefx
22983,Serialization test case DCS_BasicPerSerializerRoundTripAndCompare_SampleTypes_FailedInuapaot_IncludeDataSet failed when targeting uapaot,"This case is a part of test case DCS_BasicPerSerializerRoundTripAndCompare_SampleTypes , it was failed when **targeting `uapaot`** , so we move these scenarios into a new case.

**Detail** : the class include **DataSet** will fail when serialization.

**Error Message** : System.Runtime.Serialization.InvalidDataContractException : Type 'System.Data.DataSet' does not have a static method 'GetDataSetSchema' that takes a parameter of type 'System.Xml.Schema.XmlSchemaSet' as specified by the XmlSchemaProviderAttribute attribute.","Serialization test case DCS_BasicPerSerializerRoundTripAndCompare_SampleTypes_FailedInuapaot_IncludeDataSet failed when targeting uapaot  This case is a part of test case DCS_BasicPerSerializerRoundTripAndCompare_SampleTypes , it was failed when **targeti",23869,shmao,corefx
22984,Serialization test case DCS_BasicPerSerializerRoundTripAndCompare_SampleTypes_FailedInuapaot_InheritedFromIList failed when targeting uapaot,"This case is a part of test case DCS_BasicPerSerializerRoundTripAndCompare_SampleTypes , it failed when **targeting `uapaot `**, so we move these scenarios into a new case.

**Detail** : the class in these scenarios  inherit from **IList**  will fail when serialization.

**Error Message** : System.Runtime.Serialization.InvalidDataContractException : Collection type 'SerializationTestTypes.SampleListTExplicitWithoutDC' does not have a valid Add method.

**Note** : I checked the test classes they already implement interface explicitly and have a method named **`ICollection<..>.Add`**.","Serialization test case DCS_BasicPerSerializerRoundTripAndCompare_SampleTypes_FailedInuapaot_InheritedFromIList failed when targeting uapaot  This case is a part of test case DCS_BasicPerSerializerRoundTripAndCompare_SampleTypes , it failed when **targeti",23869,shmao,corefx
22985,Serialization test case DCS_BasicPerSerializerRoundTripAndCompare_SampleTypes_FailedInuapaot_InheritedFromIList_CanPassInReflectionOnly failed when targeting uapaot,"This case is a part of test case DCS_BasicPerSerializerRoundTripAndCompare_SampleTypes , it failed when **targeting `uapaot`** , so we move these scenarios into a new case.

**Detail** : the class in these scenarios inherit from **IList** will fail when serialization, but it can pass in project ReflectionOnly. 

**Error Message** : System.Runtime.Serialization.InvalidDataContractException : Collection type 'SerializationTestTypes.SampleListExplicitWithoutDC' does not have a valid Add method.

**Note** : I checked the test classes they already implement interface **IList** explicitly and have a method named **IList.Add**.","Serialization test case DCS_BasicPerSerializerRoundTripAndCompare_SampleTypes_FailedInuapaot_InheritedFromIList_CanPassInReflectionOnly failed when targeting uapaot  This case is a part of test case DCS_BasicPerSerializerRoundTripAndCompare_SampleTypes ,",23869,shmao,corefx
22986,Serialization test case DCS_BasicPerSerializerRoundTripAndCompare_Collections_FailedInuapaot_InCollections failed when targeting uapaot,"This case is a part of test case DCS_BasicPerSerializerRoundTripAndCompare_Collections , it failed when **targeting `uapaot`** , so we move these scenarios into a new case.

**Detail** : the class in these scenarios has **DataMember attribute decorate Collections type** ,has different result with baseline when serialization.

**Baseline** : … <List2 i:type=\""b:System.Collections.Generic.List`1[[SerializationTestTypes.SimpleDC, System.Runtime.Serialization.Xml.Tests, Version=4.1.4.0, Culture=neutral, PublicKeyToken=9d77cc7ad39b68eb]]\"" xmlns:b=\""System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\""><SimpleDC z:Ref=\""i2\""/><SimpleDC z:Ref=\""i6\""/></List2>…

**Actual**: …<List2><SimpleDC z:Ref=\""i2\""/><SimpleDC z:Ref=\""i6\""/></List2>…

**Missing assembly information of the List**.","Serialization test case DCS_BasicPerSerializerRoundTripAndCompare_Collections_FailedInuapaot_InCollections failed when targeting uapaot  This case is a part of test case DCS_BasicPerSerializerRoundTripAndCompare_Collections , it failed when **targeting `u",23869,shmao,corefx
23817,Fix LargeArrayBuilder.CopyTo returning incorrect end-of-copy position,"Fixes #23680
Replaces #23730

cc @stephentoub @VSadov @jamesqo","Fix LargeArrayBuilder.CopyTo returning incorrect end-of-copy position  Fixes #23680
Replaces #23730

cc @stephentoub @VSadov @jamesqo",23865,OmarTawfik,corefx
23389,LINQ bug: ConcatNIterator.LazyToArray() produces incorrect results,"Here's a repro: https://github.com/gulbanana/repro-corefx-concat-toarray
```
banana@forsyth MINGW64 /c/code/repro-corefx-concat-toarray (master)
$ dotnet run -f netcoreapp1.0                                      
A B C                                                              
                                                               
banana@forsyth MINGW64 /c/code/repro-corefx-concat-toarray (master)
$ dotnet run -f netcoreapp2.0                                      
A B A                                                              
```

The problem occurs when using Concat multiple times and then calling ToArray().
```c#
using System;
using System.Collections.Generic;
using System.Linq;

class Program
{
    class A { public override string ToString() => ""A""; }
    class B { public override string ToString() => ""B""; }
    class C { public override string ToString() => ""C""; }

    static void Main(string[] args)
    {
        var results = new List<A> { new A() }
            .Concat(new List<object> { new B() })
            .Concat(new List<C> { new C() })
            .ToArray();

        Console.WriteLine(string.Join(' ', results));
    }
}
```

This program should print ""A B C"", but it instead prints ""A B A"". I believe the problem is in the specialised implementation of concatenation for 3+-enumerables-of-collections. I ran into it in an actual project (an IEnumerable<BaseType> containing multiple subclass instances) but I've worked around the bug by using `ToList()` instead.

[EDIT] Add C# syntax highlight by @karelz","LINQ bug: ConcatNIterator.LazyToArray() produces incorrect results  Here's a repro: https://github.com/gulbanana/repro-corefx-concat-toarray
```
banana@forsyth MINGW64 /c/code/repro-corefx-concat-toarray (master)
$ dotnet run -f netcoreapp1.0",23865,OmarTawfik,corefx
23666,backport of REGEX_DEFAULT_MATCH_TIMEOUT,Fixes https://github.com/dotnet/corefx/issues/15173,backport of REGEX_DEFAULT_MATCH_TIMEOUT  Fixes https://github.com/dotnet/corefx/issues/15173,23861,ViktorHofer,corefx
19920,Add a static property Regex.DefaultRegexMatchTimeout to configure default timeouts globally,"`System.Text.RegularExpressions.Regex` has [a `.MatchTimeout` property](https://msdn.microsoft.com/en-us/library/system.text.regularexpressions.regex.matchtimeout(v=vs.110).aspx), but there has never been a good way to configure this **globally**. It's always been a very roundabout way (which AFAIK has been removed in .NET Core). Previously, you'd do this:
```c#
AppDomain.CurrentDomain.SetData(""REGEX_DEFAULT_MATCH_TIMEOUT"", TimeSpan.FromSeconds(20));
```

Or in ASP.NET:
```xml
<system.web>
  <httpRuntime defaultRegexMatchTimeout=""00:00:20"" />
</system.web>
```

Otherwise, we're depending on every developer to set their match timeouts inline, for each regex. The problems with that are:
- It's either a maintenance burden, or we create *our own* global config anyway to use everywhere.
- It defaults to failure if the developer forgets (creating a security and stability issue, since regexes can be a CPU-killing attack vector)

If we had a static property, like this:
```c#
namespace System.Text.RegularExpressions
{
     public partial class Regex
     {
         // Set a default value, to be used if not overridden.
         public static TimeSpan DefaultMatchTimeout = Timeout.InfiniteTimeSpan;
     }
}
```
...we could do this gracefully in code. Thoughts?

cc @terrajobst @blowdart @davidfowl 

[edited by @Priya91 for syntax]",Add a static property Regex.DefaultRegexMatchTimeout to configure default timeouts globally  `System.Text.RegularExpressions.Regex` has [a `.MatchTimeout` property](https://msdn.microsoft.com/en-us/library/system.text.regularexpressions.regex.matchtimeout,23861,ViktorHofer,corefx
23389,LINQ bug: ConcatNIterator.LazyToArray() produces incorrect results,"Here's a repro: https://github.com/gulbanana/repro-corefx-concat-toarray
```
banana@forsyth MINGW64 /c/code/repro-corefx-concat-toarray (master)
$ dotnet run -f netcoreapp1.0                                      
A B C                                                              
                                                               
banana@forsyth MINGW64 /c/code/repro-corefx-concat-toarray (master)
$ dotnet run -f netcoreapp2.0                                      
A B A                                                              
```

The problem occurs when using Concat multiple times and then calling ToArray().
```c#
using System;
using System.Collections.Generic;
using System.Linq;

class Program
{
    class A { public override string ToString() => ""A""; }
    class B { public override string ToString() => ""B""; }
    class C { public override string ToString() => ""C""; }

    static void Main(string[] args)
    {
        var results = new List<A> { new A() }
            .Concat(new List<object> { new B() })
            .Concat(new List<C> { new C() })
            .ToArray();

        Console.WriteLine(string.Join(' ', results));
    }
}
```

This program should print ""A B C"", but it instead prints ""A B A"". I believe the problem is in the specialised implementation of concatenation for 3+-enumerables-of-collections. I ran into it in an actual project (an IEnumerable<BaseType> containing multiple subclass instances) but I've worked around the bug by using `ToList()` instead.

[EDIT] Add C# syntax highlight by @karelz","LINQ bug: ConcatNIterator.LazyToArray() produces incorrect results  Here's a repro: https://github.com/gulbanana/repro-corefx-concat-toarray
```
banana@forsyth MINGW64 /c/code/repro-corefx-concat-toarray (master)
$ dotnet run -f netcoreapp1.0",23817,OmarTawfik,corefx
23730,[WIP] Fix LargeArrayBuilder.CopyTo returning incorrect end-of-copy position,"**Note:** This only affects the `LAB.CopyTo` overload that returns a `CopyPosition`. The other void overload isn't affected. The only type that uses this method is `SparseArrayBuilder` (SAB), so really only consumers of SAB are affected. Only LINQ uses SAB even though it's in Common, specifically in the functions `Concat`, `SelectMany`, `Append`, and `Prepend`. `Append` and `Prepend` weren't affected by this bug for reasons that will be explained later.

---

The job of `LAB.CopyTo` is to accept a `CopyPosition` to start copying from, and to return a `CopyPosition` representing the position copied up to. Previously, it was always returning an incorrect `CopyPosition` because of this line:

```cs
for (; count > 0; row++, column = 0)
```

The loop statement here, `row++, column = 0`, is the cause of the bug; it should not be running on the very last iteration of the loop. To give a better understanding of what it's causing, consider the following repro from @OmarTawfik:

```cs

var results = new TestEnumerable<int>(new[] { 1 })
    .Concat(new[] { 2 })
    .Concat(new TestEnumerable<int>(new[] { 3 }))
    .ToArray();

Assert.Equal(new[] { 1, 2, 3 }, results); // Actual: { 1, 2, 1 }
```

First, the SAB buffers the contents of all non-collections into a LAB, and stores references to the collections in an array (without copying the contents of those collections). It also maintains a list of ""markers"", which are indices at which the contents of the collections will be inserted in the future. So the above calls will create this:

```
LAB: [ [1, 3] ]
Markers: [ [ Index: 1, CollectionCount: 1 ] ]
CollectionReferences: [ [ 2 ] ]
```

Then in SAB.ToArray comes the bug. **When a marker is sandwiched between the contents of two non-collections,** this bug occurs.

- We start out with `[ 0 0 0 ]` for the output array.

- What happens in the above example is SAB.ToArray (correctly) calls LAB.CopyTo to copy the contents of the first collection, with `position = (0, 0)` and `count = 1`. Now the output array is `[ 1 0 0 ]`.
  - It receives back the position `(1, 0)` due to aforementioned bug, when it should really receive `(0, 1)`.

- Then we (correctly) reserve space for the second collection, skipping over the 2nd slot.

- Then we continue copying, starting from the position we received from the last LAB.CopyTo call.
  - Since the LAB doesn't even have 2 buffers, you would think starting the copy from `(1, 0)` (which means index 0 in the buffer at index 1) should throw an exception/raise an assert/etc. However, due to the way it's currently written, `GetBuffer(1)` returns the same as `GetBuffer(0)`, the first buffer which is `[ 1 3 ]`.
  - So then we copy 1 item starting at index 0 of `[ 1 3 ]` to the output array, resulting in `[ 1 0 1 ]`.

- Then we fill in the collections' contents, finally resulting in `[ 1 2 1 ]`.

---

This bug doesn't affect `Append` or `Prepend` because they don't use the faulty position from `CopyTo`; to put it another way, there's no way they can sandwich a marker between 2 non-collections. If we call `nonCollection.Append(item).Prepend(item).ToArray()`, we get this during the first stage above:

```
Marker | NonCollection | Marker
```

---

This PR fixes the implementation, refactors some loop logic into a `CopyToCore` method and adds regression tests.",[WIP] Fix LargeArrayBuilder.CopyTo returning incorrect end-of-copy position  **Note:** This only affects the `LAB.CopyTo` overload that returns a `CopyPosition`. The other void overload isn't affected. The only type that uses this method is `SparseArrayBu,23817,OmarTawfik,corefx
17,SqlClient implementation and API is not complete in Core,"The following members are on types implemented in .NET Core. However these particular members are missing, although they are present on Desktop.

The problem with this situation is
- it defies user expectations that if a type X exists, code from other platforms that use X will work on .NET Core
- it cannot be fixed without servicing -- it is not possible to supply a standalone package with the rest of the type definition

No work is necessarily required here for 2.0. It's not part of NS2.0. I didn't look at usage data. I'm just flagging this so we're doing this consciously.

---

**Updated lists to reflect current status (5/15):**

### Missing APIs
```
T:System.Data.SqlClient.OnChangeEventHandler
T:System.Data.SqlClient.PoolBlockingPeriod
T:System.Data.SqlClient.SqlAuthenticationMethod
M:System.Data.SqlClient.SqlBulkCopyColumnMappingCollection.Clear
M:System.Data.SqlClient.SqlBulkCopyColumnMappingCollection.RemoveAt(System.Int32)
F:System.Data.SqlClient.SqlBulkCopyOptions.AllowEncryptedValueModifications
M:System.Data.SqlClient.SqlClientFactory.System#IServiceProvider#GetService(System.Type)
T:System.Data.SqlClient.SqlClientMetaDataCollectionNames
T:System.Data.SqlClient.SqlColumnEncryptionCertificateStoreProvider
T:System.Data.SqlClient.SqlColumnEncryptionCngProvider
T:System.Data.SqlClient.SqlColumnEncryptionCspProvider
T:System.Data.SqlClient.SqlColumnEncryptionKeyStoreProvider
P:System.Data.SqlClient.SqlCommand.ColumnEncryptionSetting
P:System.Data.SqlClient.SqlCommand.Notification
P:System.Data.SqlClient.SqlCommand.NotificationAutoEnlist
M:System.Data.SqlClient.SqlCommand.BeginExecuteNonQuery
M:System.Data.SqlClient.SqlCommand.BeginExecuteNonQuery(System.AsyncCallback,System.Object)
M:System.Data.SqlClient.SqlCommand.BeginExecuteReader
M:System.Data.SqlClient.SqlCommand.BeginExecuteReader(System.AsyncCallback,System.Object)
M:System.Data.SqlClient.SqlCommand.BeginExecuteReader(System.AsyncCallback,System.Object,System.Data.CommandBehavior)
M:System.Data.SqlClient.SqlCommand.BeginExecuteReader(System.Data.CommandBehavior)
M:System.Data.SqlClient.SqlCommand.BeginExecuteXmlReader
M:System.Data.SqlClient.SqlCommand.BeginExecuteXmlReader(System.AsyncCallback,System.Object)
M:System.Data.SqlClient.SqlCommand.EndExecuteNonQuery(System.IAsyncResult)
M:System.Data.SqlClient.SqlCommand.EndExecuteReader(System.IAsyncResult)
M:System.Data.SqlClient.SqlCommand.EndExecuteXmlReader(System.IAsyncResult)
M:System.Data.SqlClient.SqlCommand.ResetCommandTimeout
T:System.Data.SqlClient.SqlCommandBuilder
T:System.Data.SqlClient.SqlCommandColumnEncryptionSetting
M:System.Data.SqlClient.SqlConnection.#ctor(System.String,System.Data.SqlClient.SqlCredential)
P:System.Data.SqlClient.SqlConnection.AccessToken
P:System.Data.SqlClient.SqlConnection.ColumnEncryptionKeyCacheTtl
P:System.Data.SqlClient.SqlConnection.ColumnEncryptionQueryMetadataCacheEnabled
P:System.Data.SqlClient.SqlConnection.ColumnEncryptionTrustedMasterKeyPaths
P:System.Data.SqlClient.SqlConnection.Credential
M:System.Data.SqlClient.SqlConnection.ChangePassword(System.String,System.Data.SqlClient.SqlCredential,System.Security.SecureString)
M:System.Data.SqlClient.SqlConnection.ChangePassword(System.String,System.String)
M:System.Data.SqlClient.SqlConnection.EnlistDistributedTransaction(System.EnterpriseServices.ITransaction)
M:System.Data.SqlClient.SqlConnection.RegisterColumnEncryptionKeyStoreProviders(System.Collections.Generic.IDictionary{System.String,System.Data.SqlClient.SqlColumnEncryptionKeyStoreProvider})
T:System.Data.SqlClient.SqlConnectionColumnEncryptionSetting
P:System.Data.SqlClient.SqlConnectionStringBuilder.AsynchronousProcessing
P:System.Data.SqlClient.SqlConnectionStringBuilder.Authentication
P:System.Data.SqlClient.SqlConnectionStringBuilder.ColumnEncryptionSetting
P:System.Data.SqlClient.SqlConnectionStringBuilder.ConnectionReset
P:System.Data.SqlClient.SqlConnectionStringBuilder.ContextConnection
P:System.Data.SqlClient.SqlConnectionStringBuilder.Enlist
P:System.Data.SqlClient.SqlConnectionStringBuilder.NetworkLibrary
P:System.Data.SqlClient.SqlConnectionStringBuilder.PoolBlockingPeriod
P:System.Data.SqlClient.SqlConnectionStringBuilder.TransactionBinding
P:System.Data.SqlClient.SqlConnectionStringBuilder.TransparentNetworkIPResolution
T:System.Data.SqlClient.SqlCredential
M:System.Data.SqlClient.SqlDataReader.IsCommandBehavior(System.Data.CommandBehavior)
M:System.Data.SqlClient.SqlDataReader.System#Data#IDataRecord#GetData(System.Int32)
T:System.Data.SqlClient.SQLDebugging
T:System.Data.SqlClient.SqlDependency
T:System.Data.SqlClient.SqlNotificationEventArgs
T:System.Data.SqlClient.SqlNotificationInfo
T:System.Data.SqlClient.SqlNotificationSource
T:System.Data.SqlClient.SqlNotificationType
M:System.Data.SqlClient.SqlParameter.#ctor(System.String,System.Data.SqlDbType,System.Int32,System.Data.ParameterDirection,System.Boolean,System.Byte,System.Byte,System.String,System.Data.DataRowVersion,System.Object)
M:System.Data.SqlClient.SqlParameter.#ctor(System.String,System.Data.SqlDbType,System.Int32,System.Data.ParameterDirection,System.Byte,System.Byte,System.String,System.Data.DataRowVersion,System.Boolean,System.Object,System.String,System.String,System.String)
P:System.Data.SqlClient.SqlParameter.ForceColumnEncryption
P:System.Data.SqlClient.SqlParameter.UdtTypeName
M:System.Data.SqlClient.SqlParameterCollection.Add(System.String,System.Object)
M:System.Data.SqlClient.SqlParameterCollection.Add(System.String,System.Data.SqlDbType,System.Int32,System.String)
```

#### By Design missing
* `T:System.Data.SqlClient.SqlProviderServices` -  It is part of the EF provider model for old versions of EF that were part of .NET Framework.  - see https://github.com/dotnet/corefx/issues/17126#issuecomment-301640792

### Missing overrides
```
P:System.Data.SqlClient.SqlClientFactory.CanCreateDataSourceEnumerator
M:System.Data.SqlClient.SqlClientFactory.CreateCommandBuilder
M:System.Data.SqlClient.SqlClientFactory.CreateDataSourceEnumerator
M:System.Data.SqlClient.SqlClientFactory.CreatePermission(System.Security.Permissions.PermissionState)
M:System.Data.SqlClient.SqlClientPermission.Add(System.String,System.String,System.Data.KeyRestrictionBehavior)
M:System.Data.SqlClient.SqlClientPermission.Copy
M:System.Data.SqlClient.SqlClientPermissionAttribute.CreatePermission
M:System.Data.SqlClient.SqlColumnEncryptionCertificateStoreProvider.DecryptColumnEncryptionKey(System.String,System.String,System.Byte[])
M:System.Data.SqlClient.SqlColumnEncryptionCertificateStoreProvider.EncryptColumnEncryptionKey(System.String,System.String,System.Byte[])
M:System.Data.SqlClient.SqlColumnEncryptionCngProvider.DecryptColumnEncryptionKey(System.String,System.String,System.Byte[])
M:System.Data.SqlClient.SqlColumnEncryptionCngProvider.EncryptColumnEncryptionKey(System.String,System.String,System.Byte[])
M:System.Data.SqlClient.SqlColumnEncryptionCspProvider.DecryptColumnEncryptionKey(System.String,System.String,System.Byte[])
M:System.Data.SqlClient.SqlColumnEncryptionCspProvider.EncryptColumnEncryptionKey(System.String,System.String,System.Byte[])
P:System.Data.SqlClient.SqlCommandBuilder.CatalogLocation
P:System.Data.SqlClient.SqlCommandBuilder.CatalogSeparator
P:System.Data.SqlClient.SqlCommandBuilder.QuotePrefix
P:System.Data.SqlClient.SqlCommandBuilder.QuoteSuffix
P:System.Data.SqlClient.SqlCommandBuilder.SchemaSeparator
M:System.Data.SqlClient.SqlCommandBuilder.QuoteIdentifier(System.String)
M:System.Data.SqlClient.SqlCommandBuilder.UnquoteIdentifier(System.String)
M:System.Data.SqlClient.SqlConnection.GetSchema
M:System.Data.SqlClient.SqlConnection.GetSchema(System.String)
M:System.Data.SqlClient.SqlConnection.GetSchema(System.String,System.String[])
P:System.Data.SqlClient.SqlConnectionStringBuilder.IsFixedSize
P:System.Data.SqlClient.SqlDataAdapter.UpdateBatchSize
M:System.Data.SqlClient.SqlDataReader.Close
M:System.Data.SqlClient.SqlDataReader.GetSchemaTable
```

**These were removed based on further investigation:**
```
M:System.Data.SqlClient.SqlConnection.EnlistTransaction(System.Transactions.Transaction)
P:System.Data.SqlClient.SqlParameter.SourceVersion
P:System.Data.SqlClient.SqlParameterCollection.IsFixedSize
P:System.Data.SqlClient.SqlParameterCollection.IsReadOnly
P:System.Data.SqlClient.SqlParameterCollection.IsSynchronized
```

**These were already fixed:**
* `M:System.Data.SqlClient.SqlClientFactory.CreateDataAdapter` - https://github.com/dotnet/corefx/commit/88f562c80d8d78218ccc7b4be8b23ceab712a5f6

----------

Original obsolete list:
<details>
```
MembersMustExist : Member 'Microsoft.SqlServer.Server.SqlMetaData..ctor(System.String, System.Data.SqlDbType, System.Type)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'Microsoft.SqlServer.Server.SqlMetaData..ctor(System.String, System.Data.SqlDbType, System.Type, System.String)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'Microsoft.SqlServer.Server.SqlMetaData..ctor(System.String, System.Data.SqlDbType, System.Type, System.String, System.Boolean, System.Boolean, System.Data.SqlClient.SortOrder, System.Int32)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'Microsoft.SqlServer.Server.SqlMetaData.DbType.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'Microsoft.SqlServer.Server.SqlMetaData.Type.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataRow[])' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataTable)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataTable, System.Data.DataRowState)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.IDataReader)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataRow[])' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataRow[], System.Threading.CancellationToken)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable, System.Data.DataRowState)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable, System.Data.DataRowState, System.Threading.CancellationToken)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable, System.Threading.CancellationToken)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.IDataReader)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.IDataReader, System.Threading.CancellationToken)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlBulkCopyOptions System.Data.SqlClient.SqlBulkCopyOptions.AllowEncryptedValueModifications' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlClientFactory.CreatePermission(System.Security.Permissions.PermissionState)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlCommand..ctor(System.String, System.Data.SqlClient.SqlConnection, System.Data.SqlClient.SqlTransaction, System.Data.SqlClient.SqlCommandColumnEncryptionSetting)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlCommand.BeginExecuteNonQuery()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlCommand.BeginExecuteNonQuery(System.AsyncCallback, System.Object)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlCommand.BeginExecuteReader()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlCommand.BeginExecuteReader(System.AsyncCallback, System.Object)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlCommand.BeginExecuteReader(System.AsyncCallback, System.Object, System.Data.CommandBehavior)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlCommand.BeginExecuteReader(System.Data.CommandBehavior)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlCommand.BeginExecuteXmlReader()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlCommand.BeginExecuteXmlReader(System.AsyncCallback, System.Object)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlCommand.Clone()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlCommand.ColumnEncryptionSetting.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlCommand.EndExecuteNonQuery(System.IAsyncResult)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlCommand.EndExecuteReader(System.IAsyncResult)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlCommand.EndExecuteXmlReader(System.IAsyncResult)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlCommand.Notification.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlCommand.Notification.set(System.Data.Sql.SqlNotificationRequest)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlCommand.NotificationAutoEnlist.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlCommand.NotificationAutoEnlist.set(System.Boolean)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlCommand.ResetCommandTimeout()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnection..ctor(System.String, System.Data.SqlClient.SqlCredential)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnection.AccessToken.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnection.AccessToken.set(System.String)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnection.ChangePassword(System.String, System.Data.SqlClient.SqlCredential, System.Security.SecureString)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnection.ChangePassword(System.String, System.String)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnection.ColumnEncryptionTrustedMasterKeyPaths.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnection.Credential.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnection.Credential.set(System.Data.SqlClient.SqlCredential)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnection.EnlistDistributedTransaction(System.EnterpriseServices.ITransaction)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnection.RegisterColumnEncryptionKeyStoreProviders(System.Collections.Generic.IDictionary<System.String, System.Data.SqlClient.SqlColumnEncryptionKeyStoreProvider>)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnectionStringBuilder.AsynchronousProcessing.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnectionStringBuilder.AsynchronousProcessing.set(System.Boolean)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnectionStringBuilder.Authentication.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnectionStringBuilder.Authentication.set(System.Data.SqlClient.SqlAuthenticationMethod)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnectionStringBuilder.ColumnEncryptionSetting.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnectionStringBuilder.ColumnEncryptionSetting.set(System.Data.SqlClient.SqlConnectionColumnEncryptionSetting)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnectionStringBuilder.ConnectionReset.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnectionStringBuilder.ConnectionReset.set(System.Boolean)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnectionStringBuilder.ContextConnection.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnectionStringBuilder.ContextConnection.set(System.Boolean)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnectionStringBuilder.Enlist.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnectionStringBuilder.Enlist.set(System.Boolean)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnectionStringBuilder.NetworkLibrary.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnectionStringBuilder.NetworkLibrary.set(System.String)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnectionStringBuilder.TransactionBinding.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnectionStringBuilder.TransactionBinding.set(System.String)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnectionStringBuilder.TransparentNetworkIPResolution.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlConnectionStringBuilder.TransparentNetworkIPResolution.set(System.Boolean)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlDataReader.IsCommandBehavior(System.Data.CommandBehavior)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlParameter..ctor(System.String, System.Data.SqlDbType, System.Int32, System.Data.ParameterDirection, System.Boolean, System.Byte, System.Byte, System.String, System.Data.DataRowVersion, System.Object)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlParameter..ctor(System.String, System.Data.SqlDbType, System.Int32, System.Data.ParameterDirection, System.Byte, System.Byte, System.String, System.Data.DataRowVersion, System.Boolean, System.Object, System.String, System.String, System.String)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlParameter.ForceColumnEncryption.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlParameter.ForceColumnEncryption.set(System.Boolean)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlParameter.UdtTypeName.get()' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlParameter.UdtTypeName.set(System.String)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlParameterCollection.Add(System.String, System.Data.SqlDbType, System.Int32, System.String)' does not exist in the implementation but it does exist in the contract.
MembersMustExist : Member 'System.Data.SqlClient.SqlParameterCollection.Add(System.String, System.Object)' does not exist in the implementation but it does exist in the contract.
```
</details>

from https://github.com/dotnet/corefx/blob/master/src/shims/ApiCompatBaseline.netcoreapp.netfx461.txt","SqlClient implementation and API is not complete in Core  The following members are on types implemented in .NET Core. However these particular members are missing, although they are present on Desktop.

The problem with this situation is
- it defies u",23787,joelbraun,corefx
19544,adding SqlParameter constructor,"I added SqlParmeter constructor to resolve this issue:
***
Someone is trying to use good ol’ DataSets with a .NET Standard 2.0 class library.
* The designer doesn’t work in the new project system (it doesn’t like that the core assembly isn’t mscorlib)
*  Copying over the generated code from .NET Framework 4.6.1 doesn’t work 
   * The designer uses a bunch of types that .NET Standard 2.0 doesn’t have (e.g. TypedTableBase<T>, EnumerableRowCollection etc)
   * Worked this around by creating a .NET Framework 2.0 project and regenerated the code there
   * This fixes all compilation errors except for [one constructor on SqlParameter](https://msdn.microsoft.com/en-us/library/t547y10h(v=vs.110).aspx)
","adding SqlParameter constructor  I added SqlParmeter constructor to resolve this issue:
***
Someone is trying to use good ol’ DataSets with a .NET Standard 2.0 class library.
* The designer doesn’t work in the new project system (it doesn’t like that t",23787,joelbraun,corefx
22840,Add TextReader and TextWriter Span/Buffer-based APIs,"Separated out of https://github.com/dotnet/corefx/issues/21281 for tracking purposes.

- [x] Implement in System.Runtime.Extensions
- [x] Expose from System.Runtime.Extensions contract
- [x] Add tests to System.Runtime.Extensions.Tests

```C#
namespace System.IO
{
    public class TextReader
    {
        public virtual int Read(Span<char> destination);
        public virtual ValueTask<int> ReadAsync(Buffer<char> destination, CancellationToken cancellationToken = default(CancellationToken));
        public virtual int ReadBlock(Span<char> destination);
        public virtual ValueTask<int> ReadBlockAsync(Buffer<char> destination, CancellationToken cancellationToken = default(CancellationToken));
        …
    }

    public class TextWriter
    {
        public virtual void Write(ReadOnlySpan<char> source);
        public virtual Task WriteAsync(ReadOnlyBuffer<char> source, CancellationToken cancellationToken = default(CancellationToken));
        public virtual void WriteLine(ReadOnlySpan<char> source);
        public virtual Task WriteLineAsync(ReadOnlyBuffer<char> source, CancellationToken cancellationToken = default(CancellationToken));
        …
    }
}
```
EDIT 7/25/2017: Updated with CancellationTokens per API review.","Add TextReader and TextWriter Span/Buffer-based APIs  Separated out of https://github.com/dotnet/corefx/issues/21281 for tracking purposes.

- [x] Implement in System.Runtime.Extensions
- [x] Expose from System.Runtime.Extensions contract
- [x] Add te",23786,WinCPP,corefx
22642,"Test: System.IO.Tests.DirectoryInfo_Delete_bool/Unix_NotFoundDirectory_ReadOnlyVolume failed with ""Xunit.Sdk.TrueException""","Opened on behalf of @Jiayili1

The test `System.IO.Tests.DirectoryInfo_Delete_bool/Unix_NotFoundDirectory_ReadOnlyVolume` has failed.

Assert.True() Failure
    Expected: True
    Actual:   False

        Stack Trace:

           at System.IO.Tests.FileSystemTest.RunAsSudo(String commandLine) in /root/corefx/src/System.IO.FileSystem/tests/FileSystemTest.cs:line 69
       at System.IO.Tests.FileSystemTest.ReadOnly_FileSystemHelper(Action`1 testAction, String subDirectoryName) in /root/corefx/src/System.IO.FileSystem/tests/FileSystemTest.cs:line 98
       at System.IO.Tests.Directory_Delete_str.Unix_NotFoundDirectory_ReadOnlyVolume() in /root/corefx/src/System.IO.FileSystem/tests/Directory/Delete.cs:line 214
Build : Master - 20170706.01 (Core Tests)
Failing configurations:
- Ubuntu.1404.Amd64-x64
  - Debug

Detail: https://mc.dot.net/#/product/netcore/master/source/official~2Fcorefx~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20170706.01/workItem/System.IO.FileSystem.Tests/analysis/xunit/System.IO.Tests.DirectoryInfo_Delete_bool~2FUnix_NotFoundDirectory_ReadOnlyVolume","Test: System.IO.Tests.DirectoryInfo_Delete_bool/Unix_NotFoundDirectory_ReadOnlyVolume failed with ""Xunit.Sdk.TrueException""  Opened on behalf of @Jiayili1

The test `System.IO.Tests.DirectoryInfo_Delete_bool/Unix_NotFoundDirectory_ReadOnlyVolume` has fa",23775,tarekgh,corefx
23366,"Test: System.IO.Pipes.Tests.AnonymousPipeTest_Specific/Linux_BufferSizeRoundtrips failed with ""System.PlatformNotSupportedException""","Opened on behalf of @Jiayili1

The test `System.IO.Pipes.Tests.AnonymousPipeTest_Specific/Linux_BufferSizeRoundtrips` has failed.

System.PlatformNotSupportedException : Operation is not supported on this platform.

        Stack Trace:

           at System.IO.Pipes.PipeStream.GetPipeBufferSize() in /root/corefx-954865/src/System.IO.Pipes/src/System/IO/Pipes/PipeStream.Unix.cs:line 396
       at System.IO.Pipes.Tests.AnonymousPipeTest_Specific.Linux_BufferSizeRoundtrips() in /root/corefx-954865/src/System.IO.Pipes/tests/AnonymousPipeTests/AnonymousPipeTest.Specific.cs:line 90
Build : Master - 20170829.01 (Core Tests)
Failing configurations:
- RedHat.69.Amd64-x64
  - Release
  - Debug

Detail: https://mc.dot.net/#/product/netcore/master/source/official~2Fcorefx~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20170829.01/workItem/System.IO.Pipes.Tests/analysis/xunit/System.IO.Pipes.Tests.AnonymousPipeTest_Specific~2FLinux_BufferSizeRoundtrips","Test: System.IO.Pipes.Tests.AnonymousPipeTest_Specific/Linux_BufferSizeRoundtrips failed with ""System.PlatformNotSupportedException""  Opened on behalf of @Jiayili1

The test `System.IO.Pipes.Tests.AnonymousPipeTest_Specific/Linux_BufferSizeRoundtrips` h",23775,tarekgh,corefx
23427,Test failed: System.Net.WebSockets.Client.Tests.SendReceiveTest / SendReceive_VaryingLengthBuffers_Success,"## Types of failures

Few of variants on Linux and Mac:

```
System.OperationCanceledException : Aborted
---- System.ObjectDisposedException : Cannot access a disposed object.
Object name: 'SslStream'.

System.OperationCanceledException : The operation was canceled.
---- System.ObjectDisposedException : Cannot access a disposed object.
Object name: 'SslStream'.

System.OperationCanceledException : The operation was canceled.
---- System.IO.IOException : Unable to transfer data on the transport connection: Operation canceled.
-------- System.Net.Sockets.SocketException : Operation canceled
```

Windows:
```
System.OperationCanceledException : The operation was canceled.
```

## History of failures (before test disabled on 2017/9/2)

Day | Build | OS
-- | -- | --
8/1 | 20170801.01 | Ubuntu17.10
8/1 | 20170801.02 | Ubuntu17.10
8/1 | 20170801.03 | Ubuntu17.10
8/2 | 20170802.01 | Ubuntu17.10
8/4 | 20170804.01 | Ubuntu14.04
8/4 | 20170804.01 | Ubuntu17.10
8/4 | 20170804.01 | Win8.1
8/24 | 20170824.01 | RedHat73
8/24 | 20170824.01 | Fedora26
8/30 | 20170830.01 | OSX10.12
9/2 | 20170902.01 | RedHat72
9/2 | 20170902.02 | Fedora26
9/2 | 20170902.02 | RedHat73
9/3 | 20170903.01 | RedHat73
9/3 | 20170903.01 | Ubuntu16.04
9/3 | 20170903.01 | Centos73
9/3 | 20170903.01 | Debian87
9/3 | 20170903.01 | RedHat72

# Original report

Test failed during PR run:
https://mc.dot.net/#/user/davidsh/pr~2Fjenkins~2Fdotnet~2Fcorefx~2Fmaster~2F/test~2Ffunctional~2Fcli~2F/169daaad2062ab623fdafa738c3fdbc778d3652e


Unhandled Exception of Type System.OperationCanceledException
Message :
System.OperationCanceledException : The operation was canceled.
---- System.IO.IOException : Unable to transfer data on the transport connection: Operation canceled.
-------- System.Net.Sockets.SocketException : Operation canceled","Test failed: System.Net.WebSockets.Client.Tests.SendReceiveTest / SendReceive_VaryingLengthBuffers_Success  ## Types of failures

Few of variants on Linux and Mac:

```
System.OperationCanceledException : Aborted
---- System.ObjectDisposedException",23772,davidsh,corefx
23428,Test failed: WebProxy_BypassOnLocal_MatchesExpected,"## Types of failures

Error messages (ExtendedSocketException text)
* Linux: No such device or address
* OSX: Device not configured

Build 20170902.01:
```
System.Net.Internals.SocketExceptionFactory+ExtendedSocketException : No such device or address
at   System.Net.Dns.InternalGetHostByName(String hostName, Boolean includeIPv6) in   /root/corefx-966039/src/System.Net.NameResolution/src/System/Net/DNS.cs:line   46
System.Net.Dns.ResolveCallback(Object context) in   /root/corefx-966039/src/System.Net.NameResolution/src/System/Net/DNS.cs:line   290
--- End of stack trace from previous location where exception was   thrown ---
System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
System.Net.Dns.HostResolutionEndHelper(IAsyncResult asyncResult) in   /root/corefx-966039/src/System.Net.NameResolution/src/System/Net/DNS.cs:line   420
System.Net.Dns.EndGetHostEntry(IAsyncResult asyncResult) in   /root/corefx-966039/src/System.Net.NameResolution/src/System/Net/DNS.cs:line   562
System.Threading.Tasks.TaskFactory`1.FromAsyncCoreLogic(IAsyncResult iar,   Func`2 endFunction, Action`1 endAction, Task`1 promise, Boolean   requiresSynchronization)
--- End of stack trace from previous location   where exception was thrown ---
System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task   task)
at System.Net.Tests.WebProxyTest.<BypassOnLocal_MemberData>d__10.MoveNext()
at   System.Linq.Enumerable.SelectEnumerableIterator`2.MoveNext() in   /root/corefx-966039/src/System.Linq/src/System/Linq/Select.cs:line 129
```

## History of failures (before disabling on 2017/9/2)

Note: The test was renamed in https://github.com/dotnet/corefx/commit/cd7ae0572ed600eb7c0ae3350a6f08653fc20946 (on 2017/6/29) from `BypassOnLocal_MatchesExpected` to `WebProxy_BypassOnLocal_MatchesExpected`

Day | Build | OS
-- | -- | --
5/7 | 20170507.02 | Ubuntu16.04
5/28 | 20170528.02 | OSX10.12
6/9 | 20170609.01 | Ubuntu16.04
6/12 | 20170612.02 | Ubuntu16.04
6/17 | 20170617.01 | Ubuntu14.04
6/23 | 20170623.02 | Debian90
6/26 | 20170626.03 | Debian90
6/27 | 20170627.01 | Debian90
6/27 | 20170627.01 | Suse42.2
6/27 | 20170627.02 | Suse42.2
7/2 | 20170702.02 | OSX10.12
7/18 | 20170718.02 | Debian87
7/20 | 20170720.92 | OSX10.12
8/2 | 20170802.02 | Debian87
8/4 | 20170804.03 | Debian90
8/15 | 20170815.02 | Ubuntu14.04
8/16 | 20170816.01 | Suse42.2
8/20 | 20170820.02 | SLES12
8/21 | 20170821.01 | OSX10.12
8/21 | 20170821.02 | OSX10.12
8/23 | 20170823.06 | OSX10.12
8/24 | 20170824.02 | Debian90
8/30 | 20170830.01 | Debian90
9/2 | 20170902.01 | SLES12


# Original report

Test failed during PR run:
https://mc.dot.net/#/user/davidsh/pr~2Fjenkins~2Fdotnet~2Fcorefx~2Fmaster~2F/test~2Ffunctional~2Fcli~2F/169daaad2062ab623fdafa738c3fdbc778d3652e

Unhandled Exception of Type System.Net.Internals.SocketExceptionFactory+ExtendedSocketException
Message :
System.Net.Internals.SocketExceptionFactory+ExtendedSocketException : No such device or address","Test failed: WebProxy_BypassOnLocal_MatchesExpected  ## Types of failures

Error messages (ExtendedSocketException text)
* Linux: No such device or address
* OSX: Device not configured

Build 20170902.01:
```
System.Net.Internals.SocketExceptionFa",23772,davidsh,corefx
23429,Test failure: System.Net.Sockets.Tests.TimeoutTest / ReceiveTimesOut_Throws,"## Types of failures

Similar to dotnet/corefx#24804 (`SendTimesOut_Throws`)

Build 20170814.02:
```
Assert.InRange() Failure
Range:  (1500 - 3000)
Actual: 1346.6928

at System.Net.Sockets.Tests.TimeoutTest.ReceiveTimesOut_Throws(Boolean forceNonBlocking) in /root/corefx-923915/src/System.Net.Sockets/tests/FunctionalTests/TimeoutTest.cs:line 83
```

## History of failures

Day | Build | OS
-- | -- | --
8/14 | 20170814.02 | Debian90

# Original report

Test failed during PR run:
 ReceiveTimesOut_Throws(forceNonBlocking: True)
https://mc.dot.net/#/user/davidsh/pr~2Fjenkins~2Fdotnet~2Fcorefx~2Fmaster~2F/test~2Ffunctional~2Fcli~2F/169daaad2062ab623fdafa738c3fdbc778d3652e

ReceiveTimesOut_Throws(forceNonBlocking: True) (Ubuntu)
```
Assert.InRange() Failure
Range:  (1500 - 3000)
Actual: -15521.3745
```","Test failure: System.Net.Sockets.Tests.TimeoutTest / ReceiveTimesOut_Throws  ## Types of failures

Similar to dotnet/corefx#24804 (`SendTimesOut_Throws`)

Build 20170814.02:
```
Assert.InRange() Failure
Range:  (1500 - 3000)
Actual: 1346.6928

a",23772,davidsh,corefx
23430,Test failure: System.Net.Http.Functional.Tests.HttpClientHandlerTest / PostAsync_RedirectWith307_LargePayload,"## History of failures

Day | Build | OS | Error message
-- | -- | -- | --
8/1 | 20170801.02 | Ubuntu17.10 | TaskCanceledException: A task was canceled.
8/1 | 20170801.03 | Ubuntu16.04 | TaskCanceledException: A task was canceled.
8/2 | 20170802.01 | Ubuntu16.04 | TaskCanceledException: A task was canceled.
8/4 | 20170804.01 | Win7 | [ManagedHandler] TaskCanceledException: A task was canceled.
8/4 | 20170804.01 | Win7 | TaskCanceledException: A task was canceled.
8/16 | 20170816.01 | Debian90 | [ManagedHandler] OperationCanceledException: The operation was canceled.
9/1 | 20170901.01 | Debian90 | [ManagedHandler] OperationCanceledException: The operation was canceled.
9/1 | 20170901.02 | Ubuntu17.10 | [ManagedHandler] OperationCanceledException: The operation was canceled.
1/19 | | | Test re-enabled in PR dotnet/corefx#26399
1/21 | 20180121.02 | SLES12 | [ManagedHandler] OperationCanceledException : The operation was canceled. - [link](https://mc.dot.net/#/product/netcore/master/source/official~2Fcorefx~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180121.02/workItem/System.Net.Http.Functional.Tests/analysis/xunit/System.Net.Http.Functional.Tests.ManagedHandler_HttpClientHandlerTest~2FPostAsync_RedirectWith307_LargePayload)
1/22 | 20180122.02 | Ubuntu16.04 | [ManagedHandler] OperationCanceledException : The operation was canceled. - [link](https://mc.dot.net/#/product/netcore/master/source/official~2Fcorefx~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180122.02/workItem/System.Net.Http.Functional.Tests/analysis/xunit/System.Net.Http.Functional.Tests.ManagedHandler_HttpClientHandlerTest~2FPostAsync_RedirectWith307_LargePayload)


# Original report

Test failed during PR run:
https://mc.dot.net/#/user/davidsh/pr~2Fjenkins~2Fdotnet~2Fcorefx~2Fmaster~2F/test~2Ffunctional~2Fcli~2F/169daaad2062ab623fdafa738c3fdbc778d3652e


Unhandled Exception of Type System.Threading.Tasks.TaskCanceledException
Message :
System.Threading.Tasks.TaskCanceledException : A task was canceled.","Test failure: System.Net.Http.Functional.Tests.HttpClientHandlerTest / PostAsync_RedirectWith307_LargePayload   ## History of failures

Day | Build | OS | Error message
-- | -- | -- | --
8/1 | 20170801.02 | Ubuntu17.10 | TaskCanceledException: A task",23772,davidsh,corefx
23431,HttpClient test failed: AllowAutoRedirect_True_ValidateNewMethodUsedOnRedirection,"## History of failures

It failed **222x** during 8/12-9/1 (more than 10x/day) on Win7-Win10

# Original report

Test failed during PR run:
https://mc.dot.net/#/user/davidsh/pr~2Fjenkins~2Fdotnet~2Fcorefx~2Fmaster~2F/test~2Ffunctional~2Fcli~2F/169daaad2062ab623fdafa738c3fdbc778d3652e

Unhandled Exception of Type System.Net.Http.HttpRequestException
Message :
System.Net.Http.HttpRequestException : An error occurred while sending the request.
---- System.IO.IOException : The server returned an invalid or unrecognized response.
","HttpClient test failed: AllowAutoRedirect_True_ValidateNewMethodUsedOnRedirection  ## History of failures

It failed **222x** during 8/12-9/1 (more than 10x/day) on Win7-Win10

# Original report

Test failed during PR run:
https://mc.dot.net/#/user",23772,davidsh,corefx
23432,HttpClient test failed: RequestVersion20_ResponseVersion20IfHttp2Supported,"Test failed during PR run:
https://mc.dot.net/#/user/davidsh/pr~2Fjenkins~2Fdotnet~2Fcorefx~2Fmaster~2F/test~2Ffunctional~2Fcli~2F/169daaad2062ab623fdafa738c3fdbc778d3652e

RequestVersion20_ResponseVersion20IfHttp2Supported(server: https://http2.akamai.com/) (Linux)
Unhandled Exception of Type System.Net.Http.HttpRequestException
Message :
System.Net.Http.HttpRequestException : An error occurred while sending the request.
---- System.Net.Http.CurlException : Operation was aborted by an application callback
-------- Assert.Equal() Failure
Expected: PartialChain
Actual:   NotSignatureValid","HttpClient test failed: RequestVersion20_ResponseVersion20IfHttp2Supported  Test failed during PR run:
https://mc.dot.net/#/user/davidsh/pr~2Fjenkins~2Fdotnet~2Fcorefx~2Fmaster~2F/test~2Ffunctional~2Fcli~2F/169daaad2062ab623fdafa738c3fdbc778d3652e

Req",23772,davidsh,corefx
1477,Test failed: DiagnosticsTest / SendAsync_HttpTracingEnabled_Succeeds,"Test failed during PR run:
https://mc.dot.net/#/user/davidsh/pr~2Fjenkins~2Fdotnet~2Fcorefx~2Fmaster~2F/test~2Ffunctional~2Fcli~2F/169daaad2062ab623fdafa738c3fdbc778d3652e

DiagnosticsTest/SendAsync_HttpTracingEnabled_Succeeds (Linux) (ManagedHandler)
Unhandled Exception of Type Xunit.Sdk.TrueException
Message :
Exit code was 139 but it should have been 42
Expected: True
Actual:   False","Test failed: DiagnosticsTest / SendAsync_HttpTracingEnabled_Succeeds   Test failed during PR run:
https://mc.dot.net/#/user/davidsh/pr~2Fjenkins~2Fdotnet~2Fcorefx~2Fmaster~2F/test~2Ffunctional~2Fcli~2F/169daaad2062ab623fdafa738c3fdbc778d3652e

Diagnost",23772,davidsh,corefx
22103,Unix paths with backslashes are converted to forward slashes when uri is created with the file scheme,"A backslash is a valid character in a unix path. It is not used to separate path segments, it is part of a directory/file name.
The Uri class will convert these backslashes to forward slashes, causing the resulting uri to no longer point at the correct file.
e.g. `new Uri(file:///one\two)` refers to the `/one/two` instead of `/one\two`

When creating a Uri without the file scheme, the Uri class will preserve the backslashes.
e.g. `new Uri(/one\two)` refers to `/one\two`
Note that the `ToString` of this uri returns `file:///one\two`. Which gives the strange behavior that `new Uri(new Uri(/one\two).ToString())` refers to `/one/two`

The Uri class is very persistent in converting backslashes to forward slashes. Even when providing a percent encoded backslash, it is converted to a forward slash.

One way to fix this is to no longer convert backslashes for `file:///` uris on Unix.
The Uri class has special semantics for two types of files: Dos paths and Unc paths. Dos paths (e.g. c:\) don't start with a slash. Unc paths start with 2 slashes.
So paths starting with a single slash can be treated as unix uris (i.e. no forward slash conversion). This is implemented https://github.com/dotnet/corefx/pull/20623. The behavior is only changed on Unix for paths that start with file:/// (3 slashes = 2 slashes of the scheme + 1 slash of the unix path).

With the current behavior it is not possible to create a Uri with a file:// argument to refer to a path that contains backslashes.
When this behavior is changed, existing code that relied on the backslash-to-forwardslash conversion will break.
An example of this can be seen in this PR (https://github.com/dotnet/corefx/pull/20564). Here the implementation was changed from `new Uri(""file://"" + path)` to `new Uri(path)`. Due to slashes no longer being converted, some tests needed changes.

@karelz @stephentoub @sepidehMS","Unix paths with backslashes are converted to forward slashes when uri is created with the file scheme  A backslash is a valid character in a unix path. It is not used to separate path segments, it is part of a directory/file name.
The Uri class will conv",21290,Priya91,corefx
20623,Uri: preserve backslash for file:/// uris on Unix,"This changes the handling of file:/// uris to preserve the backslash on Unix. The uris must start with exactly 3 slashes (uris with more slashes are Unc uris).

This make things work like:
```C#
var path = ""/one\two"";
var uri1 = new Uri(path);
var uri2 = new Uri(uri1.ToString());
var uri3 = new Uri(""file://"" + path);
Assert.Equal(uri1.LocalPath, uri2.LocalPath);
Assert.Equal(uri1.LocalPath, uri3.LocalPath);
```
Otherwise uri2 and uri1 contain forward slashes.

CC @stephentoub","Uri: preserve backslash for file:/// uris on Unix  This changes the handling of file:/// uris to preserve the backslash on Unix. The uris must start with exactly 3 slashes (uris with more slashes are Unc uris).

This make things work like:
```C#
var p",21290,Priya91,corefx
21263,Allow file Uris to terminate the host with '\' on Unix.,"Reverts part of https://github.com/dotnet/corefx/pull/20623 which discards these uris as BadAuthorityTerminator.

With this change, these uris work the same as on Windows.

CC @Priya91 @stephentoub @karelz","Allow file Uris to terminate the host with '\' on Unix.  Reverts part of https://github.com/dotnet/corefx/pull/20623 which discards these uris as BadAuthorityTerminator.

With this change, these uris work the same as on Windows.

CC @Priya91 @stephent",21290,Priya91,corefx
21482,Escape '\' on Unix file uris to '%5C' for canonical form.,"On Unix it is valid for filenames to have char '\\'. According to URI RFC, on the wire, the backslash needs to be in percent-encoded form as %5C. Hence we are converting all '\\' and '%5C' in unix file uris to be '%5C' in Uri.AbsolutePath and Uri.AbsoluteUri. These return the canonical URI values. Also note, the Uri.LocalPath will return these unescaped as before.

Fixes #20628

cc @tmds @CIPop @wfurt @karelz","Escape '\' on Unix file uris to '%5C' for canonical form.  On Unix it is valid for filenames to have char '\\'. According to URI RFC, on the wire, the backslash needs to be in percent-encoded form as %5C. Hence we are converting all '\\' and '%5C' in unix",21290,Priya91,corefx
21100,[2.0 Port] Fixing NativeOverlapped lifetime issue,"Port of #20793 to 2.0.0.

Fixes #20400 .

@karelz @DavidGoll PTAL","[2.0 Port] Fixing NativeOverlapped lifetime issue  Port of #20793 to 2.0.0.

Fixes #20400 .

@karelz @DavidGoll PTAL",21239,CIPop,corefx
22017,[HttpListener][Porting] authentication failures with GetContextAsync throw an Unhandled inner exception for NativeOverlapped used for multiple operations,"Steps to reproduce:

1. Pull in this commit https://github.com/hughbe/corefx/commit/aa948b02cc9ad4f23fde77502382f5f6a9c42e8b
2. Run the tests

Observe:

```
Discovering: System.Net.HttpListener.Tests
  Discovered:  System.Net.HttpListener.Tests
  Starting:    System.Net.HttpListener.Tests

  Unhandled Exception:
  Unhandled Exception:
  Unhandled Exception:
  Unhandled Exception: System.InvalidOperationException: NativeOverlapped cannot be reused for multiple operations.
     at System.Threading.ThreadPoolBoundHandleOverlapped.CompletionCallback(UInt32 errorCode, UInt32 numBytes, NativeOv
  erlapped* nativeOverlapped)
     at System.Threading._IOCompletionCallback.PerformIOCompletionCallback(UInt32 errorCode, UInt32 numBytes, NativeOve
  rlapped* pOVERLAP)
  System.InvalidOperationException: NativeOverlapped cannot be reused for multiple operations.
     at System.Threading.ThreadPoolBoundHandleOverlapped.CompletionCallback(UInt32 errorCode, UInt32 numBytes, NativeOv
  erlapped* nativeOverlapped)
     at System.Threading._IOCompletionCallback.PerformIOCompletionCallback(UInt32 errorCode, UInt32 numBytes, NativeOve
  rlapped* pOVERLAP)
  System.InvalidOperationException: NativeOverlapped cannot be reused for multiple operations.
     at System.Threading.ThreadPoolBoundHandleOverlapped.CompletionCallback(UInt32 errorCode, UInt32 numBytes, NativeOv
  erlapped* nativeOverlapped)
     at System.Threading._IOCompletionCallback.PerformIOCompletionCallback(UInt32 errorCode, UInt32 numBytes, NativeOve
  rlapped* pOVERLAP)
  System.InvalidOperationException: NativeOverlapped cannot be reused for multiple operations.
     at System.Threading.ThreadPoolBoundHandleOverlapped.CompletionCallback(UInt32 errorCode, UInt32 numBytes, NativeOv
  erlapped* nativeOverlapped)
     at System.Threading._IOCompletionCallback.PerformIOCompletionCallback(UInt32 errorCode, UInt32 numBytes, NativeOve
  rlapped* pOVERLAP)

  Finished running tests.  End time=11:41:39.75, Exit code = -532462766
```

@CIPop you were taking a look at authentication recently","[HttpListener][Porting] authentication failures with GetContextAsync throw an Unhandled inner exception for NativeOverlapped used for multiple operations  Steps to reproduce:

1. Pull in this commit https://github.com/hughbe/corefx/commit/aa948b02cc9ad4",21239,CIPop,corefx
22297,ILC mode will clear out ParamName for ArgumentNullException,"System.Net.Sockets NullArgs_Throw() test runs fine in netcore/netfx/uap mode. But in ILC ('uap-aot') mode it is failing.  It seems that the ParamName field has been optimized away:

```c#
        public void NullArgs_Throw(SocketImplementationType type)
        {
            int port;
            using (SocketTestServer.SocketTestServerFactory(type, _serverAddress, out port))
            {
                using (Socket sock = new Socket(AddressFamily.InterNetworkV6, SocketType.Stream, ProtocolType.Tcp))
                {
                    sock.Connect(new IPEndPoint(_serverAddress, port));

                    ArgumentNullException ex = Assert.Throws<ArgumentNullException>(() =>
                    {
                        sock.SendPacketsAsync(null);
                    });
                    Assert.Equal(""e"", ex.ParamName); //failure here, ex.ParamName == null
                }
            }
        }
```

Here is the implementation for SendPacketsAsync:

```c#
        public bool SendPacketsAsync(SocketAsyncEventArgs e)
        {
            ...
            if (e == null)
            {
                throw new ArgumentNullException(nameof(e));
            }
            ...
        }
```

https://docs.microsoft.com/en-us/dotnet/api/system.argumentnullexception.-ctor?view=netcore-1.1#System_ArgumentNullException__ctor_System_String_
No matter what paramName value I passed in, ex.ParamName is always null.

But if I do:
```c#
                    SocketAsyncEventArgs e = null;
                    ArgumentNullException testEx = new ArgumentNullException(nameof(e));
```
This works, testEx.ParamName is ""e"".

cc: @davidsh","ILC mode will clear out ParamName for ArgumentNullException  System.Net.Sockets NullArgs_Throw() test runs fine in netcore/netfx/uap mode. But in ILC ('uap-aot') mode it is failing.  It seems that the ParamName field has been optimized away:

```c#",21171,caesar-chen,corefx
22295,Socket SelectTest.Poll_NotReady() fail in ILC mode due to metadata removed for performance reason,"System.Net.Sockets tests run fine in F5 ('uap') mode. But in ILC ('uap-aot') mode they are failing.  It seems that the metadata the test needs to look up has been removed:

```c#
        [Theory]
        [InlineData(SelectMode.SelectRead)]
        [InlineData(SelectMode.SelectError)]
        public void Poll_NotReady(SelectMode mode)
        {
            KeyValuePair<Socket, Socket> pair = CreateConnectedSockets();
            try
            {
                Assert.False(pair.Key.Poll(SmallTimeoutMicroseconds, mode));
            }
            finally
            {
                pair.Key.Dispose();
                pair.Value.Dispose();
            }
        }
```

We get failures like this:

>System.Reflection.MissingMetadataException : This operation cannot be carried out because metadata for the following object was removed for performance reasons:\n\n  System.Net.Sockets.SelectMode\n\nNo further information is available. Rebuild in debug mode for better information.\n\n

Is this an expected problem from the UWP test runner in ILC mode? Or we need to fix this?

cc: @davidsh",Socket SelectTest.Poll_NotReady() fail in ILC mode due to metadata removed for performance reason  System.Net.Sockets tests run fine in F5 ('uap') mode. But in ILC ('uap-aot') mode they are failing.  It seems that the metadata the test needs to look up ha,21171,caesar-chen,corefx
22043,DCS/DCJS Failed to Serialize System Types in ReflectionOnly Mode,"DCS/DCJS failed to serialize System types in ReflectionOnly mode due to the reflection on the types being blocked.

The following tests failed.

```
DataContractSerializerTests.DCS_ReadOnlyDictionary
DataContractSerializerTests.DCS_GenericStack
DataContractSerializerTests.DCS_Stack
DataContractSerializerTests.DCS_SystemVersion
DataContractSerializerTests.DCS_ListMembers
DataContractSerializerTests.DCS_BasicRoundtripDCRDefaultCollections
DataContractSerializerTests.DCS_SortedList
DataContractSerializerTests.DCS_GenericQueue
DataContractSerializerTests.DCS_Queue
DataContractSerializerTests.DCS_ReadOnlyCollection

DataContractJsonSerializerTests.DCJS_Queue
DataContractJsonSerializerTests.DCJS_GetOonlyDictionary_UseSimpleDictionaryFormat
DataContractJsonSerializerTests.DCJS_Stack
DataContractJsonSerializerTests.DCJS_ReadOnlyDictionary
DataContractJsonSerializerTests.DCJS_GenericQueue
DataContractJsonSerializerTests.DCJS_ReadOnlyCollection
DataContractJsonSerializerTests.DCJS_GenericStack
DataContractJsonSerializerTests.DCJS_SortedList
DataContractJsonSerializerTests.DCJS_SystemVersion
```

Example call stack:

```
      <test name=""DataContractSerializerTests.DCS_ReadOnlyCollection"" type=""DataContractSerializerTests"" method=""DCS_ReadOnlyCollection"" time=""0.0003206"" result=""Fail"">
        <failure exception-type=""Xunit.Sdk.TrueException"">
          <message><![CDATA[XML comparison is also failing\r\nTest failed for input: System.Collections.ObjectModel.ReadOnlyCollection`1[System.String]\r\n
Expected: <ReadOnlyCollectionOfstring xmlns=\""http://schemas.datacontract.org/2004/07/System.Collections.ObjectModel\"" xmlns:i=\""http://www.w3.org/2001/XMLSchema-instance\""><list xmlns:a=\""http://schemas.microsoft.com/2003/10/Serialization/Arrays\""><a:string>Foo</a:string><a:string>Bar</a:string></list></ReadOnlyCollectionOfstring>\r\n
Actual:   <ReadOnlyCollectionOfstring xmlns=\""http://schemas.datacontract.org/2004/07/System.Collections.ObjectModel\"" xmlns:i=\""http://www.w3.org/2001/XMLSchema-instance\""/>\r\n
Expected: True\r\n
Actual:   False]]>
          </message>
          <stack-trace><![CDATA[   at DataContractSerializerTests.SerializeAndDeserialize<System.__Canon>(__Canon value, String baseline, $DataContractSerializerSettings settings, Func$1<$DataContractSerializer> serializerFactory, Boolean skipStringCompare) in d:\OSS\corefx-1\corefx\src\System.Runtime.Serialization.Xml\tests\DataContractSerializer.cs:line 3163
   at DataContractSerializerTests.DCS_ReadOnlyCollection() in d:\OSS\corefx-1\corefx\src\System.Runtime.Serialization.Xml\tests\DataContractSerializer.cs:line 1885
   at _$ILCT$.$ILT$ReflectionDynamicInvoke$.InvokeRetV(Object thisPtr, IntPtr methodToCall, ArgSetupState argSetupState, Boolean targetIsThisCall)
   at System.InvokeUtils.CalliIntrinsics.Call(IntPtr dynamicInvokeHelperMethod, Object thisPtr, IntPtr methodToCall, ArgSetupState argSetupState, Boolean isTargetThisCall)
   at System.InvokeUtils.CallDynamicInvokeMethod(Object thisPtr, IntPtr methodToCall, Object thisPtrDynamicInvokeMethod, IntPtr dynamicInvokeHelperMethod, IntPtr dynamicInvokeHelperGenericDictionary, Object targetMethodOrDelegate, Object[] parameters, BinderBundle binderBundle, Boolean invokeMethodHelperIsThisCall, Boolean methodToCallIsThisCall) in f:\dd\ndp\fxcore\CoreRT\src\System.Private.CoreLib\src\System\InvokeUtils.cs:line 400]]></stack-trace>
        </failure>
      </test>
```","DCS/DCJS Failed to Serialize System Types in ReflectionOnly Mode  DCS/DCJS failed to serialize System types in ReflectionOnly mode due to the reflection on the types being blocked.

The following tests failed.

```
DataContractSerializerTests.DCS_Rea",21144,shmao,corefx
22045,Test DCJS_VerifyDictionaryFormat Failed on Uapaot Using Sg.exe,"```
     DataContractJsonSerializerTests.DCJS_VerifyDictionaryFormat [FAIL]
        System.Runtime.Serialization.SerializationException : The dictionary of type 'System.Collections.Generic.Dictionary`2[[TestStruct, System.Runtime.Serialization.Json.Tests, V
  ersion=4.0.4.0, Culture=neutral, PublicKeyToken=9d77cc7ad39b68eb],[TestStruct, System.Runtime.Serialization.Json.Tests, Version=4.0.4.0, Culture=neutral, PublicKeyToken=9d77cc7ad3
  9b68eb]]' cannot be deserialized as a simple dictionary because its key type 'TestStruct' does not have a public static Parse method.
        Stack Trace:
              at Type924.ReadArrayOfKeyValueOfTestStructTestStructaI91YjnmFromJson($XmlReaderDelegator A_0, $XmlObjectSerializerReadContextComplexJson A_1, $XmlDictionaryString A_2,
   $XmlDictionaryString A_3, $CollectionDataContract A_4)
           InvokeOpenStaticThunk(16707566,0): at System.Runtime.Serialization.XmlFormatCollectionReaderDelegate.InvokeOpenStaticThunk($XmlReaderDelegator xmlReader, $XmlObjectSerial
  izerReadContext context, $XmlDictionaryString itemName, $XmlDictionaryString itemNamespace, $CollectionDataContract collectionContract)
           Invoke(16707566,0): at System.Runtime.Serialization.XmlFormatCollectionReaderDelegate.Invoke($XmlReaderDelegator xmlReader, $XmlObjectSerializerReadContext context, $XmlD
  ictionaryString itemName, $XmlDictionaryString itemNamespace, $CollectionDataContract collectionContract)
           d:\OSS\corefx-1\corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonCollectionDataContract.cs(170,0): at System.Runtime.Serializ
  ation.Json.JsonCollectionDataContract.ReadJsonValueCore($XmlReaderDelegator jsonReader, $XmlObjectSerializerReadContextComplexJson context)
           d:\OSS\corefx-1\corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonDataContract.cs(80,0): at System.Runtime.Serialization.Json.
  JsonDataContract.ReadJsonValue($XmlReaderDelegator jsonReader, $XmlObjectSerializerReadContextComplexJson context)
           d:\OSS\corefx-1\corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlObjectSerializerReadContextComplexJson.cs(52,0): at System.Ru
  ntime.Serialization.Json.XmlObjectSerializerReadContextComplexJson.ReadDataContractValue($DataContract dataContract, $XmlReaderDelegator reader)
           d:\OSS\corefx-1\corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs(201,0): at System.Runtime.Serializa
  tion.XmlObjectSerializerReadContext.InternalDeserialize($XmlReaderDelegator reader, String name, String ns, $DataContract& dataContract)
           d:\OSS\corefx-1\corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs(127,0): at System.Runtime.Serializa
  tion.XmlObjectSerializerReadContext.InternalDeserialize($XmlReaderDelegator xmlReader, Type declaredType, $DataContract dataContract, String name, String ns)
           d:\OSS\corefx-1\corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContextComplex.cs(72,0): at System.Runtime.Ser
  ialization.XmlObjectSerializerReadContextComplex.InternalDeserialize($XmlReaderDelegator xmlReader, Type declaredType, $DataContract dataContract, String name, String ns)
           d:\OSS\corefx-1\corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\DataContractJsonSerializer.cs(861,0): at System.Runtime.Serializ
  ation.Json.DataContractJsonSerializerImpl.InternalReadObject($XmlReaderDelegator xmlReader, Boolean verifyObjectName)
           d:\OSS\corefx-1\corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializer.cs(261,0): at System.Runtime.Serialization.XmlObj
  ectSerializer.InternalReadObject($XmlReaderDelegator reader, Boolean verifyObjectName, $DataContractResolver dataContractResolver)
           d:\OSS\corefx-1\corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializer.cs(280,0): at System.Runtime.Serialization.XmlObj
  ectSerializer.ReadObjectHandleExceptions($XmlReaderDelegator reader, Boolean verifyObjectName, $DataContractResolver dataContractResolver)
           d:\OSS\corefx-1\corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\DataContractJsonSerializer.cs(684,0): at System.Runtime.Serializ
  ation.Json.DataContractJsonSerializerImpl.ReadObject($XmlDictionaryReader reader)
           d:\OSS\corefx-1\corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\DataContractJsonSerializer.cs(669,0): at System.Runtime.Serializ
  ation.Json.DataContractJsonSerializerImpl.ReadObject(Stream stream)
           d:\OSS\corefx-1\corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\DataContractJsonSerializer.cs(199,0): at System.Runtime.Serializ
  ation.Json.DataContractJsonSerializer.ReadObject(Stream stream)
           d:\OSS\corefx-1\corefx\src\System.Runtime.Serialization.Json\tests\DataContractJsonSerializer.cs(2865,0): at DataContractJsonSerializerTests.SerializeAndDeserialize<Syste
  m.__Canon>(__Canon value, String baseline, $DataContractJsonSerializerSettings settings, Func$1<$DataContractJsonSerializer> serializerFactory, Boolean skipStringCompare)
           d:\OSS\corefx-1\corefx\src\System.Runtime.Serialization.Json\tests\DataContractJsonSerializer.cs(2714,0): at DataContractJsonSerializerTests.DCJS_VerifyDictionaryFormat()
              at _$ILCT$.$ILT$ReflectionDynamicInvoke$.InvokeRetV(Object thisPtr, IntPtr methodToCall, ArgSetupState argSetupState, Boolean targetIsThisCall)
              at System.InvokeUtils.CalliIntrinsics.Call(IntPtr dynamicInvokeHelperMethod, Object thisPtr, IntPtr methodToCall, ArgSetupState argSetupState, Boolean isTargetThisCall
  )
           f:\dd\ndp\fxcore\CoreRT\src\System.Private.CoreLib\src\System\InvokeUtils.cs(400,0): at System.InvokeUtils.CallDynamicInvokeMethod(Object thisPtr, IntPtr methodToCall, Ob
  ject thisPtrDynamicInvokeMethod, IntPtr dynamicInvokeHelperMethod, IntPtr dynamicInvokeHelperGenericDictionary, Object targetMethodOrDelegate, Object[] parameters, BinderBundle bi
  nderBundle, Boolean invokeMethodHelperIsThisCall, Boolean methodToCallIsThisCall)```","Test DCJS_VerifyDictionaryFormat Failed on Uapaot Using Sg.exe  ```
     DataContractJsonSerializerTests.DCJS_VerifyDictionaryFormat [FAIL]
        System.Runtime.Serialization.SerializationException : The dictionary of type 'System.Collections.Generic.",21144,shmao,corefx
22311,ClientWebSocket.ReceiveAsync behavior difference between .NET Core and UWP,"There is a behavioral difference between the UAP and non-UAP implementations of ClientWebSocket.ReceiveAsync. Currently, the [WinRTWebSocket](https://github.com/dotnet/corefx/blob/master/src/System.Net.WebSockets.Client/src/System/Net/WebSockets/WinRTWebSocket.cs)'s OnMessageReceived is only triggered when an entire message has been received, which doesn't allow ClientWebSocket.ReceiveAsync to hand partial data back to the app on-the-fly.","ClientWebSocket.ReceiveAsync behavior difference between .NET Core and UWP  There is a behavioral difference between the UAP and non-UAP implementations of ClientWebSocket.ReceiveAsync. Currently, the [WinRTWebSocket](https://github.com/dotnet/corefx/blob",21138,Diego-Perez-Botero,corefx
21315,"Desktop: System.IO.Tests.PathTests.GetFullPath_Windows_Wildcards and System.IO.Tests.PathTests.GetPathRoot_Windows_UncAndExtended failed with ""Xunit.Sdk.EqualException""","System.IO.Tests.PathTests.GetFullPath_Windows_Wildcards [FAIL]
MESSAGE:
~~~
Assert.Equal() Failure
    Expected: path
    Actual: (null)
~~~
STACK TRACE:
~~~
at System.AssertExtensions.Throws[T](String paramName, Func`1 testCode) 
in D:\j\workspace\outerloop_net---903ddde6\src\Common\tests\System\AssertExtensions.cs:line 49 
at System.IO.Tests.PathTests.GetFullPath_Windows_Wildcards(Char wildcard) 
in D:\j\workspace\outerloop_net---903ddde6\src\System.Runtime.Extensions\tests\System\IO\PathTests.cs:line 708
~~~
Detail: https://ci.dot.net/job/dotnet_corefx/job/master/job/outerloop_netfx_windows_nt_debug/29/testReport/System.IO.Tests/PathTests/GetFullPath_Windows_Wildcards_wildcard______/

System.IO.Tests.PathTests.GetPathRoot_Windows_UncAndExtended [FAIL]
MESSAGE:
~~~
Assert.Equal() Failure
     ↓ (pos 7)
    Expected: \\\\?\\UNC\\test\\unc
    Actual: \\\\?\\UNC
     ↑ (pos 7)
~~~
STACK TRACE:
~~~
at System.IO.Tests.PathTests.GetPathRoot_Windows_UncAndExtended(String value, String expected) 
in D:\j\workspace\outerloop_net---903ddde6\src\System.Runtime.Extensions\tests\System\IO\PathTests.cs:line 203
~~~
Detail: https://ci.dot.net/job/dotnet_corefx/job/master/job/outerloop_netfx_windows_nt_debug/29/testReport/System.IO.Tests/PathTests/GetPathRoot_Windows_UncAndExtended_value_________________UNC____test____unc____path____to____something____expected_________________UNC____test____unc___/","Desktop: System.IO.Tests.PathTests.GetFullPath_Windows_Wildcards and System.IO.Tests.PathTests.GetPathRoot_Windows_UncAndExtended failed with ""Xunit.Sdk.EqualException""  System.IO.Tests.PathTests.GetFullPath_Windows_Wildcards [FAIL]
MESSAGE:
~~~
Assert",19012,safern,corefx
21290,"Desktop: System.IO.Tests.PathTests.GetFullPath_Windows_ValidExtendedPaths failed with ""System.ArgumentException""","Failed test: System.IO.Tests.PathTests.GetFullPath_Windows_ValidExtendedPaths

Detail: https://ci.dot.net/job/dotnet_corefx/job/master/job/outerloop_netfx_windows_nt_debug/29/testReport/System.IO.Tests/PathTests/GetFullPath_Windows_ValidExtendedPaths_path_________________UNC____server6____share_________/

Configuration: outerloop_netfx_windows_nt_debug

MESSAGE:
~~~
System.ArgumentException : Illegal characters in path.
~~~
STACK TRACE:
~~~
at System.IO.Path.CheckInvalidPathChars(String path, Boolean checkAdditional) 
at System.Security.Permissions.FileIOPermission.QuickDemand(FileIOPermissionAccess access, String fullPath, Boolean checkForDuplicates, Boolean needFullPath) 
at System.IO.Path.GetFullPath(String path) 
at System.IO.Tests.PathTests.GetFullPath_Windows_ValidExtendedPaths(String path) 
in D:\j\workspace\outerloop_net---903ddde6\src\System.Runtime.Extensions\tests\System\IO\PathTests.cs:line 606
~~~","Desktop: System.IO.Tests.PathTests.GetFullPath_Windows_ValidExtendedPaths failed with ""System.ArgumentException""  Failed test: System.IO.Tests.PathTests.GetFullPath_Windows_ValidExtendedPaths

Detail: https://ci.dot.net/job/dotnet_corefx/job/master/job/",19012,safern,corefx
21251,"Test: System.IO.Tests.PathTests/GetFullPath_Windows_UNC_Valid failed with ""Xunit.Sdk.EqualException""","Opened on behalf of @Jiayili1

The test `System.IO.Tests.PathTests/GetFullPath_Windows_UNC_Valid(expected: \""\\\\\\\\.\\\\UNC\\\\LOCALHOST\\\\share\\\\\"", input: \""\\\\\\\\.\\\\UNC\\\\LOCALHOST\\\\share\\\\. \"")` has failed.
```
Assert.Equal() Failure\r
                                     ? (pos 23)\r
    Expected: ···\\UNC\\LOCALHOST\\share\\\r
    Actual:   ···\\UNC\\LOCALHOST\\share\r
                                     ? (pos 23)

        Stack Trace:

           at System.IO.Tests.PathTests.GetFullPath_Windows_UNC_Valid(String expected, String input) in E:\A\_work\81\s\corefx\src\System.Runtime.Extensions\tests\System\IO\PathTests.cs:line 642
```
Build : Master - 20170420.02 (Full Framework Tests)
Failing configurations:
- Windows.10.Amd64
  - x64-Debug
  - x86-Release
  - x64-Release
  - x86-Debug

Detail: 
https://mc.dot.net/#/product/netcore/master/source/official~2Fcorefx~2Fmaster~2F/type/test~2Ffunctional~2Fdesktop~2Fcli~2F/build/20170420.02/workItem/System.Runtime.Extensions.Tests/analysis/xunit/System.IO.Tests.PathTests~2FGetFullPath_Windows_UNC_Valid(expected:%20%5C%22%5C%5C%5C%5C%5C%5C%5C%5C.%5C%5C%5C%5CUNC%5C%5C%5C%5CLOCALHOST%5C%5C%5C%5Cshare%5C%5C%5C%5C%5C%22,%20input:%20%5C%22%5C%5C%5C%5C%5C%5C%5C%5C.%5C%5C%5C%5CUNC%5C%5C%5C%5CLOCALHOST%5C%5C%5C%5Cshare%5C%5C%5C%5C.%20%5C%22)","Test: System.IO.Tests.PathTests/GetFullPath_Windows_UNC_Valid failed with ""Xunit.Sdk.EqualException""  Opened on behalf of @Jiayili1

The test `System.IO.Tests.PathTests/GetFullPath_Windows_UNC_Valid(expected: \""\\\\\\\\.\\\\UNC\\\\LOCALHOST\\\\share\\\\",19012,safern,corefx
21344,IO tests need conditionalized for new behavior to run correctly on desktop,"Tests need split up and results need conditionalized on the relevant new behavior being enabled.

I already wrote a [helper](https://github.com/dotnet/corefx/blob/master/src/System.IO.FileSystem/tests/PathFeatures.cs#L38) for this. It needs moved to common.

Creating this issue to tag the various tests against.","IO tests need conditionalized for new behavior to run correctly on desktop  Tests need split up and results need conditionalized on the relevant new behavior being enabled.

I already wrote a [helper](https://github.com/dotnet/corefx/blob/master/src/Sys",19012,safern,corefx
21292,"Desktop: DataContractJsonSerializerTests.DCJS_VerifyDateTimeForFormatStringDCJsonSerSettings failed with ""Xunit.Sdk.TrueException""","Failed test: DataContractJsonSerializerTests.DCJS_VerifyDateTimeForFormatStringDCJsonSerSettings

Detail: https://ci.dot.net/job/dotnet_corefx/job/master/job/outerloop_netfx_windows_nt_debug/29/testReport/(root)/DataContractJsonSerializerTests/DCJS_VerifyDateTimeForFormatStringDCJsonSerSettings/

Configuration: outerloop_netfx_windows_nt_debug

MESSAGE:
~~~
Assert.True() Failure
   Expected: True
   Actual: False
~~~
STACK TRACE:
at DataContractJsonSerializerTests.DCJS_VerifyDateTimeForFormatStringDCJsonSerSettings() 
in D:\j\workspace\outerloop_net---903ddde6\src\System.Runtime.Serialization.Json\tests\DataContractJsonSerializer.cs:line 2547","Desktop: DataContractJsonSerializerTests.DCJS_VerifyDateTimeForFormatStringDCJsonSerSettings failed with ""Xunit.Sdk.TrueException""  Failed test: DataContractJsonSerializerTests.DCJS_VerifyDateTimeForFormatStringDCJsonSerSettings

Detail: https://ci.dot.",18958,shmao,corefx
21163,DCJS_VerifyDateTimeForDateTimeFormat Fails on Unix.,"DCJS_VerifyDateTimeForDateTimeFormat fails on Unix as the following method call serializes the object into different payloads,
```
SerializeAndDeserialize(new DateTime(1, 1, 1, 3, 58, 32), value, dcjsSettings);
```
On windows: baseline: `""\""03:58:32.00 a.m.\""""`
On unix: actual output: `""\""03:58:32.00 a. m.\""""`","DCJS_VerifyDateTimeForDateTimeFormat Fails on Unix.  DCJS_VerifyDateTimeForDateTimeFormat fails on Unix as the following method call serializes the object into different payloads,
```
SerializeAndDeserialize(new DateTime(1, 1, 1, 3, 58, 32), value, dcjs",18958,shmao,corefx
21157,CookieParser doesn't parse cookies separated by ';',"```cs
public static IEnumerable<object[]> Cookies_TestData()
{
    // Returns 2 objects in .NET Core.
    // Returns 3 objects in .NET Full framework and on Unix.
    yield return new object[]
    {
        ""cookie: name1=value1,name2=value2;name3=value3"", new CookieCollection()
        {
            new Cookie(""name1"", ""value1""),
            new Cookie(""name2"", ""value2""),
            new Cookie(""name3"", ""value3"")
        }
    };
}

[Theory]//[ConditionalTheory(nameof(PlatformDetection) + ""."" + nameof(PlatformDetection.IsNotOneCoreUAP))]
[MemberData(nameof(Cookies_TestData))]
public async Task Cookies_Get_ReturnsExpected(string cookieString, CookieCollection expected)
{
    await GetRequest(""POST"", null, new[] { cookieString }, (_, request) =>
    {
        Assert.Equal(expected.Count, request.Cookies.Count);
        for (int i = 0; i < expected.Count; i++)
        {
            Assert.Equal(expected[i].Name, request.Cookies[i].Name);
            Assert.Equal(expected[i].Value, request.Cookies[i].Value);
        }
    });
}

private async Task GetRequest(string requestType, string query, string[] headers, Action<Socket, HttpListenerRequest> requestAction, bool sendContent = true)
{
    using (HttpListenerFactory factory = new HttpListenerFactory())
    using (Socket client = factory.GetConnectedSocket())
    {
        client.Send(factory.GetContent(requestType, query, sendContent ? ""Text"" : """", headers, true));

        HttpListener listener = factory.GetListener();
        HttpListenerContext context = await listener.GetContextAsync();

        HttpListenerRequest request = context.Request;
        requestAction(client, request);
    }
}`
```","CookieParser doesn't parse cookies separated by ';'  ```cs
public static IEnumerable<object[]> Cookies_TestData()
{
    // Returns 2 objects in .NET Core.
    // Returns 3 objects in .NET Full framework and on Unix.
    yield return new object[]",18904,hughbe,corefx
21154,"Porting bug: HttpListenerRequest.Cookies throws a CookieException for invalid cookies, NETFX doesn't throw","```cs

        public static async Task GetClientCertificate_NoCertificate_ReturnsNull()
        {
            await GetRequest(new[] { ""cookie: name=value; domain=.domain.com"" }, (_, request) =>
            {
                Assert.Empty(request.Cookies);
            });
        }

        private static async Task GetRequest(string[] headers, Action<Socket, HttpListenerRequest> requestAction)
        {
            using (HttpListenerFactory factory = new HttpListenerFactory())
            using (Socket client = factory.GetConnectedSocket())
            {
                client.Send(factory.GetContent(""POST"", ""text"", headers, true));

                HttpListener listener = factory.GetListener();
                HttpListenerContext context = await listener.GetContextAsync();

                HttpListenerRequest request = context.Request;
                requestAction(client, request);
            }
        }
```

Netfx doesn't throw; any cookie with a non-empty name is added.
Netcoreapp does throw

/cc @davidsh @Priya91","Porting bug: HttpListenerRequest.Cookies throws a CookieException for invalid cookies, NETFX doesn't throw  ```cs

        public static async Task GetClientCertificate_NoCertificate_ReturnsNull()
        {
            await GetRequest(new[] { ""cookie",18904,hughbe,corefx
20997,Fix managed implementation of HttpListener to match Windows implementation,"In dotnet/corefx#17999 some tests are disabled on Unix due to different implementations of HttpListener. Most of these are argument validation, and can easily be corrected. Some may need further investigation and may be by-design due to inherent platform differences.

I'm grabbing this one, once dotnet/corefx#17999 is merged","Fix managed implementation of HttpListener to match Windows implementation  In dotnet/corefx#17999 some tests are disabled on Unix due to different implementations of HttpListener. Most of these are argument validation, and can easily be corrected. Some m",18904,hughbe,corefx
21338,Missing parameter validation for CredentialCache.Add method,"While investigating dotnet/runtime#20829, discovered that CredentialCache is not doing proper validation with the 'Add' method.

On .NET Core, it allows for DefaultCredentials to be added for auth types such as 'Basic'. On .NET Framework, it throws:

>System.ArgumentException : Default credentials cannot be supplied for the Basic authentication scheme.
Parameter name: authType
Stack Trace:
at System.Net.CredentialCache.Add(Uri uriPrefix, String authType, NetworkCredential cred)","Missing parameter validation for CredentialCache.Add method  While investigating dotnet/runtime#20829, discovered that CredentialCache is not doing proper validation with the 'Add' method.

On .NET Core, it allows for DefaultCredentials to be added for",18875,davidsh,corefx
20829,Desktop and Core behavior differences in System.Net.Http,"There are some differences in behavior between Desktop and core which are causing tests like this one fail on Desktop:

https://github.com/dotnet/corefx/blob/master/src/System.Net.Http/tests/FunctionalTests/HttpClientHandlerTest.cs#L281

cc: @davidsh","Desktop and Core behavior differences in System.Net.Http  There are some differences in behavior between Desktop and core which are causing tests like this one fail on Desktop:

https://github.com/dotnet/corefx/blob/master/src/System.Net.Http/tests/Func",18875,davidsh,corefx
20199,"OuterLoop_Win7_debug: tests under ""Legacy.SerialStream.WriteTimeout_Property"" failed with ""Xunit.Sdk.ThrowsException""","Detail: https://ci.dot.net/job/dotnet_corefx/job/master/job/outerloop_win7_debug/95/consoleText

Configuration: OuterLoop_Windows7_debug (build#95)

Message:
~~~
Assert.Throws() Failure
        Expected: typeof(System.TimeoutException)
        Actual:   (No exception was thrown)
~~~

Stack Trace:
~~~
D:\j\workspace\outerloop_win---b280fd23\src\System.IO.Ports\tests\Legacy\SerialStream\WriteTimeout.cs(265,0): at Legacy.SerialStream.WriteTimeout_Property.SuccessiveWriteTimeoutNoData_WriteByte()
~~~

Failed tests:
WriteTimeout_Property/SuccessiveWriteTimeoutNoData_WriteByte 
WriteTimeout_Property/SuccessiveWriteTimeoutNoData_Write_byte_int_int","OuterLoop_Win7_debug: tests under ""Legacy.SerialStream.WriteTimeout_Property"" failed with ""Xunit.Sdk.ThrowsException""  Detail: https://ci.dot.net/job/dotnet_corefx/job/master/job/outerloop_win7_debug/95/consoleText

Configuration: OuterLoop_Windows7_deb",16102,willdean,corefx
20198,"OuterLoop_Win7_debug: Test under ""Legacy.SerialStream"" failed with ""Xunit.Sdk.EqualException""","Detail: https://ci.dot.net/job/dotnet_corefx/job/master/job/outerloop_win7_debug/95/consoleText

Configuration: OuterLoop_Windows7_debug (build#95)

Message:
~~~
Legacy.SerialStream.WriteByte_Generic.SuccessiveReadTimeout [FAIL]
        ERROR!!!: The write method timedout in 0 expected 1054 percentage difference: 1
        Expected: True
        Actual:   False
~~~

Stack Trace:
~~~
D:\j\workspace\outerloop_win---b280fd23\src\System.IO.Ports\tests\Legacy\Support\PortsTest.cs(24,0): at System.IO.PortsTests.PortsTest.Fail(String format, Object[] args)
           D:\j\workspace\outerloop_win---b280fd23\src\System.IO.Ports\tests\Legacy\SerialStream\WriteByte_Generic.cs(452,0): at Legacy.SerialStream.WriteByte_Generic.VerifyTimeout(SerialPort com)
           D:\j\workspace\outerloop_win---b280fd23\src\System.IO.Ports\tests\Legacy\SerialStream\WriteByte_Generic.cs(117,0): at Legacy.SerialStream.WriteByte_Generic.SuccessiveReadTimeout()
~~~

Failed tests:
WriteByte_Generic/SuccessiveReadTimeout
WriteByte_Generic/BytesToWriteSuccessive
WriteTimeout_Property/WriteTimeout_750_WriteByte  
WriteTimeout_Property/WriteTimeout_750_Write_byte_int_int 
Write_byte_int_int_Generic/BytesToWriteSuccessive
Write_byte_int_int_Generic/SuccessiveWriteTimeout","OuterLoop_Win7_debug: Test under ""Legacy.SerialStream"" failed with ""Xunit.Sdk.EqualException""  Detail: https://ci.dot.net/job/dotnet_corefx/job/master/job/outerloop_win7_debug/95/consoleText

Configuration: OuterLoop_Windows7_debug (build#95)

Message",16102,willdean,corefx
20149,SerialPort timeout tests are slow and flaky,"They don't play well with CI builds and take some time.

We need to:

1. Pick some more generous thresholds for validation 
2. Try to make tests faster where possible
3. Move the slowest tests to the outer loop

dotnet/runtime#20091","SerialPort timeout tests are slow and flaky  They don't play well with CI builds and take some time.

We need to:

1. Pick some more generous thresholds for validation 
2. Try to make tests faster where possible
3. Move the slowest tests to the oute",16102,willdean,corefx
20194,MemberInitExpression.Reduce returns block with undeclared variable,"Calling `Reduce` method on `MemberInitExpression` result in invalid expression tree (at least can't be compiled), because it uses a temporary variable without declaring it:

Calling `Reduce` on tree
```
.New DotVVM.Framework.Tests.Binding.TestViewModel(){
    EnumProperty = .Constant<DotVVM.Framework.Tests.Binding.TestEnum>(B)
}
```
results in:
```
.Block() {
    $var1 = .New DotVVM.Framework.Tests.Binding.TestViewModel();
    $var1.EnumProperty = .Constant<DotVVM.Framework.Tests.Binding.TestEnum>(B);
    $var1
}
```
which can't be compiled, because `$var1` is not declared. Or do I miss something? IMHO it can be fixed by adding a `, new [] { objVar }` to https://github.com/dotnet/corefx/blob/master/src/System.Linq.Expressions/src/System/Linq/Expressions/MemberInitExpression.cs#L82 and https://github.com/dotnet/corefx/blob/master/src/System.Linq.Expressions/src/System/Linq/Expressions/MemberInitExpression.cs#L97","MemberInitExpression.Reduce returns block with undeclared variable  Calling `Reduce` method on `MemberInitExpression` result in invalid expression tree (at least can't be compiled), because it uses a temporary variable without declaring it:

Calling `Re",16091,JonHanna,corefx
3686,Use optimized N-ary BlockExpression nodes from all Block factories,"This addresses issue #3297 by using Block2-Block5 types when applicable, regardless of the factory method used to create the BlockExpression.","Use optimized N-ary BlockExpression nodes from all Block factories  This addresses issue #3297 by using Block2-Block5 types when applicable, regardless of the factory method used to create the BlockExpression.",16091,JonHanna,corefx
15943,Remove two iterators from Concat,"Was part of https://github.com/dotnet/corefx/pull/15389 but moved to another PR. Fixes https://github.com/dotnet/corefx/issues/15942

Changes:

- Remove 2 iterators from `Concat` that specialize for ICollections. Instead of having different iterators, set a flag on the iterator if all inputs so far have been ICollections. This allows us to determine in constant time whether we can get the count cheaply and preallocate for ToArray/ToList.

- This allows us to move the source enumerables into linked list nodes that are of uniform type, `ConcatNIterator<TSource>`. Previously, we had to typecast every time we crossed a node.

- Implement `GetCount` and `ToArray` in the derived classes rather than the base to avoid virtual calls and improve time complexity.
  - Avoid walking the linked list quadratically for `GetCount`, since we don't need to sum the counts in order.
  - Remove unnecessary virtual calls to `GetEnumerable` for 1 Concat followed by `ToArray`.
  - Make 1 Concat followed by `Count` cheap if the both of the concatees' counts can be gotten cheaply.

- Add a `ReserveOrAdd` method to `SparseArrayBuilder` which either reserves space for the enumerable if its count can be predetermined, or eagerly adds it otherwise. This saves quite a few lines of code.

**Performance tests:** <s>[memory leak reduction](https://gist.github.com/jamesqo/c8ccc43c2e9a7b8bb35c6cc6bebeb9ec) / [regressions from this change](https://gist.github.com/jamesqo/bde594c796e2c07117f77e88239a2c40)</s> Need to be updated.

/cc @JonHanna @stephentoub @VSadov","Remove two iterators from Concat  Was part of https://github.com/dotnet/corefx/pull/15389 but moved to another PR. Fixes https://github.com/dotnet/corefx/issues/15942

Changes:

- Remove 2 iterators from `Concat` that specialize for ICollections. Inst",16073,jamesqo,corefx
20143,[Bug] Double-evaluation of selector in SelectMany,"I found out my changes from https://github.com/dotnet/corefx/pull/14675 introduced a double-evaluation of a selector in `SelectMany.ToArray`: https://github.com/dotnet/corefx/blob/master/src/System.Linq/src/System/Linq/SelectMany.cs#L245 This will be fixed shortly in an upcoming PR, but I am opening a tracking issue just in case I forget or that PR gets closed.",[Bug] Double-evaluation of selector in SelectMany  I found out my changes from https://github.com/dotnet/corefx/pull/14675 introduced a double-evaluation of a selector in `SelectMany.ToArray`: https://github.com/dotnet/corefx/blob/master/src/System.Linq/s,16073,jamesqo,corefx
20185,Tests failing in new SerialStream tests,Placeholder for ActiveIssue - there's an intermittent CI test failure caused by something in the new SerialStream tests,Tests failing in new SerialStream tests  Placeholder for ActiveIssue - there's an intermittent CI test failure caused by something in the new SerialStream tests,16056,willdean,corefx
16051,"Update CoreClr, ProjectNTfs, Standard to beta-25010-03, beta-25010-00, beta-25010-01, respectively","","Update CoreClr, ProjectNTfs, Standard to beta-25010-03, beta-25010-00, beta-25010-01, respectively  ",16056,willdean,corefx
15807,Retain Scale Information in decimal ConstantExpression compilation,"Don't optimise IL generated when the scale of a decimal constant is other than zero, so that scale information isn't lost.

Fixes #15806

Improve the optimisations for those cases they can cover:

**Lighter IL for known decimal values**

Use `ldsfld` instead of `newobj` for decimals in decimal's static fields.

Lighter IL and no constructor cost.

**Lighter IL integral decimal constants (`int.MaxValue`, `uint.MaxValue`]**

Load 32-bit value instead of 64.

**Lighter IL integral decimal constants (`long.MaxValue`, `ulong.MaxValue`]**

Use constructor that takes `ulong` instead of components.","Retain Scale Information in decimal ConstantExpression compilation  Don't optimise IL generated when the scale of a decimal constant is other than zero, so that scale information isn't lost.

Fixes #15806

Improve the optimisations for those cases the",16052,JonHanna,corefx
15946,Reuse more IL locals in S.L.Expressions,"Cache more `LocalBuilder`s after use, reducing the number of locals emitted in produced methods, and reducing allocations in creating them.

Cache the `LocalBuilder`s in a `Stack` rather than a `Queue`, increasing chance of same local being used in quick succession, in turn increasing chance of same real storage location being used in quick succession.","Reuse more IL locals in S.L.Expressions  Cache more `LocalBuilder`s after use, reducing the number of locals emitted in produced methods, and reducing allocations in creating them.

Cache the `LocalBuilder`s in a `Stack` rather than a `Queue`, increasin",16052,JonHanna,corefx
16035,Have S.L.Expressions compiler test and add constants in a single pass.,"Currently this is a two-step operation of `CanEmitConstant` followed by `EmitConstant`.

Instead have a `TryEmitConstant` that reports on success, so the same checks aren't repeated.","Have S.L.Expressions compiler test and add constants in a single pass.  Currently this is a two-step operation of `CanEmitConstant` followed by `EmitConstant`.

Instead have a `TryEmitConstant` that reports on success, so the same checks aren't repeated",16052,JonHanna,corefx
15885,Marking code as unchecked (pt 2),"Marking code that may intentionally lead to over or underflows with
unchecked in preparation of turning on CheckForOverflowUnderflow for
all projects (issue #3140)","Marking code as unchecked (pt 2)  Marking code that may intentionally lead to over or underflows with
unchecked in preparation of turning on CheckForOverflowUnderflow for
all projects (issue #3140)",16032,JonHanna,corefx
15797,Optimise S.L.Expressions compilation of primitive constants.,"Most types use `conv` instructions but when the value is known to be in the types range (as these are ipso facto being typed as such) this has no effect. Just use `EmitInt` for all values < 32bit size.

Since `EmitInt` is now a bit of a misnomer, rename all such methods to `EmitPrimitive`.

Use shorter `ldc*` instructions for 64-bit constants when the value will fit within 32 bits, as either a signed or unsigned value.",Optimise S.L.Expressions compilation of primitive constants.  Most types use `conv` instructions but when the value is known to be in the types range (as these are ipso facto being typed as such) this has no effect. Just use `EmitInt` for all values < 32b,16032,JonHanna,corefx
20160,S.L.Expression Casts of Boolean Enums Incomplete,"dotnet/runtime#19312 raised and dotnet/corefx#13518 closed the issue of casting from bool to bool-based enums using `Convert`. It did not though cover the inverse cast or the use of `ConvertChecked`. The inverse cast isn't accepted, and `ConvertChecked` fails on both interpreter and compiler.",S.L.Expression Casts of Boolean Enums Incomplete  dotnet/runtime#19312 raised and dotnet/corefx#13518 closed the issue of casting from bool to bool-based enums using `Convert`. It did not though cover the inverse cast or the use of `ConvertChecked`. The i,15992,JonHanna,corefx
13518,Expression casts tests and fix boolean-enum casts,"Fix bug in cast test where result wasn't correctly verified.

Tests for casting reference type to enum for all underlying types.

Remove always-true branching on .GetTypeInfo().IsEnum (Already asserted in constructor).

Replace if (from == null) case with assertion. Add assertion in instruction emit backing this up.

Remove unreachable case for enum base.

Add tests for casting to enum types from underlying types.

Fix compiler and interpreter for bool → bool-backed-enum. Fixes #13516

Remove unreachable case in CastToEnumInstruction.Run() and simplify test from method call and multiple-branched switch to null-check.

Test cast tests on DateTime as they are specialised (should they be?)","Expression casts tests and fix boolean-enum casts  Fix bug in cast test where result wasn't correctly verified.

Tests for casting reference type to enum for all underlying types.

Remove always-true branching on .GetTypeInfo().IsEnum (Already asserte",15992,JonHanna,corefx
15154,Remove references to TaskAPMExtensions in System.Net tests,"Remove Common\tests\System.Net\TaskAPMExtensions.cs and rewrite tests using TPL instead.","Remove references to TaskAPMExtensions in System.Net tests  Remove Common\tests\System.Net\TaskAPMExtensions.cs and rewrite tests using TPL instead.",15952,ianhays,corefx
17216,Expose Stream.Begin/EndRead/Write in System.IO contract,"We really want devs to use Stream.Read/WriteAsync, but not having these Begin/End methods exposed breaks portability scenarios, e.g. where a stream in the full framework wraps another stream (e.g. SslStream) and the wrapper's async implementation wraps the Begin/End methods on the underlying Stream.  Without these Begin/End members in the contract, it's impossible for a portable Stream implementation to plug in to that wrapper correctly.

The core work here (for RTM) is to:
- Expose the Begin/EndRead/Write virtual methods in the contract
- Fix all of our Stream implementations in corefx to override these.  In some cases, the methods already exist and we just need to change them from internal methods to public overrides.  In other cases, we need to implement them and can do so easily on top of the Read/WriteAsync implementations.

After that, we can optionally consider:
- Changing the base Stream.Begin/EndRead/Write implementation to check if ReadAsync/WriteAsync are overridden, and if they are, delegating to those instead of queueing a work item that invokes the synchronous Read/Write.  There are potential issues here, though, e.g. if a Stream overrides ReadAsync/WriteAsync to delegate to Begin/End which it doesn't override, at which point they'll end up in an infinite redirection loop.  There may be ways to mitigate that.  If we added that, we need a similar change (under a quirk) in the full framework.

cc: @weshaggard, @terrajobst, @KrzysztofCwalina, @davidfowl, @benaadams ","Expose Stream.Begin/EndRead/Write in System.IO contract  We really want devs to use Stream.Read/WriteAsync, but not having these Begin/End methods exposed breaks portability scenarios, e.g. where a stream in the full framework wraps another stream (e.g. S",15952,ianhays,corefx
17012,Kerberos to ntlm fallback is not happening with the ntlmssp plugin when passed valid ntlm creds.,"There is a bug in ntlmssp package .If we try spnego with valid ntlm creds, it first tries Kerberos and since the creds are not present in Kerberos database it should fallback to ntlm. Which is not happening in the current verison. 
The issue is discussed with ntlmssp plugin developer (simo sorce) .He will look into this. ","Kerberos to ntlm fallback is not happening with the ntlmssp plugin when passed valid ntlm creds.  There is a bug in ntlmssp package .If we try spnego with valid ntlm creds, it first tries Kerberos and since the creds are not present in Kerberos database i",15952,ianhays,corefx
18320,ServerAsyncAuthenticate_MismatchProtocols_Fails failing in CI,"```
System.Net.Security.Tests.ServerAsyncAuthenticateTest.ServerAsyncAuthenticate_MismatchProtocols_Fails(serverProtocol: Tls, clientProtocol: Tls11, expectedException: typeof(System.Security.Authentication.AuthenticationException)) [FAIL]
        Assert.Throws() Failure
        Expected: typeof(System.Security.Authentication.AuthenticationException)
        Actual:   typeof(System.TimeoutException): The operation has timed out.
        Stack Trace:
              at System.Threading.Tasks.TaskTimeoutExtensions.<TimeoutAfter>d__0.MoveNext()
           --- End of stack trace from previous location where exception was thrown ---
              at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
              at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
              at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
              at System.Net.Security.Tests.ServerAsyncAuthenticateTest.<ServerAsyncSslHelper>d__11.MoveNext()
           --- End of stack trace from previous location where exception was thrown ---
              at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
              at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
```","ServerAsyncAuthenticate_MismatchProtocols_Fails failing in CI  ```
System.Net.Security.Tests.ServerAsyncAuthenticateTest.ServerAsyncAuthenticate_MismatchProtocols_Fails(serverProtocol: Tls, clientProtocol: Tls11, expectedException: typeof(System.Security",15952,ianhays,corefx
18406,Re-enable more networking tests for innerloop,"PR dotnet/corefx#11341 moved the majority of networking tests to outerloop due to infrastructure issues. This issue will track putting back tests as we strengthen the test infrastructure to allow more networking tests to run as innerloop.",Re-enable more networking tests for innerloop  PR dotnet/corefx#11341 moved the majority of networking tests to outerloop due to infrastructure issues. This issue will track putting back tests as we strengthen the test infrastructure to allow more network,15952,ianhays,corefx
18722,kdc-setup.sh failed on Ubuntu 16.10,"In some of the outerloop runs of Ubuntu 16.10, the [setup-kdc.sh script](https://github.com/dotnet/corefx/blob/master/src/System.Net.Security/tests/Scripts/Unix/setup-kdc.sh) is failing during `apt-get` with a 404 error. This appears to be intermittent because some runs have succeeded or at least not failed on these particular tests.

Here is an example failure log:
http://dotnet-ci.cloudapp.net/job/dotnet_corefx/job/master/job/outerloop_ubuntu16.10_debug/13/consoleText
Search for `Installing krb5-kdc..`

This whole process seems fragile to me, is there anything we could do to improve this? An option would be to require this package to be installed on a machine before the test is permitted to run, and just skip them if it is not. For our official outerloop runs, we could require that they run, and thus require that the package be pre-installed (like all our other dependencies).","kdc-setup.sh failed on Ubuntu 16.10  In some of the outerloop runs of Ubuntu 16.10, the [setup-kdc.sh script](https://github.com/dotnet/corefx/blob/master/src/System.Net.Security/tests/Scripts/Unix/setup-kdc.sh) is failing during `apt-get` with a 404 erro",15952,ianhays,corefx
17510,System.Net.Security: Authentication failed because the remote party has closed the transport stream.,"In dotnet/corefx#9115:

On a `Standard_D3_v2` Azure machine:

Windows_NT Debug Build and Test failed because:

```
System.Net.Security.Tests.ServerNoEncryptionTest.ServerNoEncryption_ClientAllowNoEncryption_ConnectWithNoEncryption [FAIL] failed.

MESSAGE:
System.IO.IOException : Authentication failed because the remote party has closed the transport stream.
+++++++++++++++++++
STACK TRACE:
at System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest) in D:\j\workspace\windows_nt_de---494cfe0d\src\System.Net.Security\src\System\Net\SecureProtocols\SslState.cs:line 870 
at System.Net.Security.SslState.PartialFrameCallback(AsyncProtocolRequest asyncRequest) in D:\j\workspace\windows_nt_de---494cfe0d\src\System.Net.Security\src\System\Net\SecureProtocols\SslState.cs:line 1098 --- End of stack trace from previous location where exception was thrown --- 
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() 
at System.Net.Security.SslState.InternalEndProcessAuthentication(LazyAsyncResult lazyResult) in D:\j\workspace\windows_nt_de---494cfe0d\src\System.Net.Security\src\System\Net\SecureProtocols\SslState.cs:line 740 
at System.Net.Security.SslState.EndProcessAuthentication(IAsyncResult result) in D:\j\workspace\windows_nt_de---494cfe0d\src\System.Net.Security\src\System\Net\SecureProtocols\SslState.cs:line 710 
at System.Net.Security.SslStream.EndAuthenticateAsClient(IAsyncResult asyncResult) in D:\j\workspace\windows_nt_de---494cfe0d\src\System.Net.Security\src\System\Net\SecureProtocols\SslStream.cs:line 125 
at System.Threading.Tasks.TaskFactory`1.FromAsyncCoreLogic(IAsyncResult iar, Func`2 endFunction, Action`1 endAction, Task`1 promise, Boolean requiresSynchronization) --- End of stack trace from previous location where exception was thrown --- 
at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) 
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) 
at System.Runtime.CompilerServices.TaskAwaiter.GetResult() 
at System.Net.Security.Tests.ServerNoEncryptionTest.<ServerNoEncryption_ClientAllowNoEncryption_ConnectWithNoEncryption>d__4.MoveNext() in D:\j\workspace\windows_nt_de---494cfe0d\src\System.Net.Security\tests\FunctionalTests\ServerNoEncryptionTest.cs:line 63 --- End of stack trace from previous location where exception was thrown --- 
at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) 
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) --- End of stack trace from previous location where exception was thrown --- 
at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) 
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) --- End of stack trace from previous location where exception was thrown --- 
at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) 
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
```","System.Net.Security: Authentication failed because the remote party has closed the transport stream.  In dotnet/corefx#9115:

On a `Standard_D3_v2` Azure machine:

Windows_NT Debug Build and Test failed because:

```
System.Net.Security.Tests.Serve",15952,ianhays,corefx
18191,"Test failure: System.Net.Security.Tests.ClientAsyncAuthenticateTest/ClientAsyncAuthenticate_EachClientUnsupportedProtocol_Fail with ""System.IO.IOException""","Opened on behalf of @Jiayili1

The test `System.Net.Security.Tests.ClientAsyncAuthenticateTest/ClientAsyncAuthenticate_EachClientUnsupportedProtocol_Fail` has failed.

```
Assert.Throws() Failure\r
Expected: typeof(System.NotSupportedException)\r
Actual:   typeof(System.IO.IOException): Authentication failed because the remote party has closed the transport stream.
```

Stack Trace:

```
   at System.Net.Security.SslState.InternalEndProcessAuthentication(LazyAsyncResult lazyResult)
   at System.Net.Security.SslState.EndProcessAuthentication(IAsyncResult result)
   at System.Threading.Tasks.TaskFactory`1.FromAsyncCoreLogic(IAsyncResult iar, Func`2 endFunction, Action`1 endAction, Task`1 promise, Boolean requiresSynchronization)
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Threading.Tasks.TaskTimeoutExtensions.<TimeoutAfter>d__0.MoveNext() in D:\A\_work\4\s\src\Common\tests\System\Threading\Tasks\TaskTimeoutExtensions.cs:line 19
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Net.Security.Tests.ClientAsyncAuthenticateTest.<ClientAsyncSslHelper>d__14.MoveNext() in D:\A\_work\4\s\src\System.Net.Security\tests\FunctionalTests\ClientAsyncAuthenticateTest.cs:line 142
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
```

Failing configurations:
- Windows.10.Amd64
  - AnyCPU-Release
  - AnyCPU-Debug

link: https://mc.dot.net/#/product/netcore/master/source/official~2Fcorefx~2Fmaster/type/test~2Ffunctional~2Fdesktop~2Fcli~2F/build/20160816.08/workItem/System.Net.Security.Tests/analysis/xunit/System.Net.Security.Tests.ClientAsyncAuthenticateTest~2FClientAsyncAuthenticate_EachClientUnsupportedProtocol_Fail

Failed tests:
ClientAsyncAuthenticate_EachClientUnsupportedProtocol_Fail
ClientAsyncAuthenticate_UnsuportedAllClient_Fail","Test failure: System.Net.Security.Tests.ClientAsyncAuthenticateTest/ClientAsyncAuthenticate_EachClientUnsupportedProtocol_Fail with ""System.IO.IOException""  Opened on behalf of @Jiayili1

The test `System.Net.Security.Tests.ClientAsyncAuthenticateTest/C",15952,ianhays,corefx
18518,Test failure: System.Net.Security.Tests.ServerNoEncryptionTest/ServerNoEncryption_ClientNoEncryption_ConnectWithNoEncryption,"Opened on behalf of @jiangzeng

The test `System.Net.Security.Tests.ServerNoEncryptionTest/ServerNoEncryption_ClientNoEncryption_ConnectWithNoEncryption` has failed.

```
Assert.Throws() Failure
Expected: typeof(System.Security.Authentication.AuthenticationException)
Actual:   (No exception was thrown)
```

Stack Trace:

```
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Net.Security.Tests.ServerNoEncryptionTest.<ServerNoEncryption_ClientNoEncryption_ConnectWithNoEncryption>d__5.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
```

Failing configurations:
- OSX.1011.Amd64
  - AnyCPU-Release

Details:
https://mc.dot.net/#/product/netcore/master/source/official~2Fcorefx~2Fmaster/type/test~2Ffunctional~2Fcli~2F/build/20160910.01/workItem/System.Net.Security.Tests/analysis/xunit/System.Net.Security.Tests.ServerNoEncryptionTest~2FServerNoEncryption_ClientNoEncryption_ConnectWithNoEncryption","Test failure: System.Net.Security.Tests.ServerNoEncryptionTest/ServerNoEncryption_ClientNoEncryption_ConnectWithNoEncryption  Opened on behalf of @jiangzeng

The test `System.Net.Security.Tests.ServerNoEncryptionTest/ServerNoEncryption_ClientNoEncryptio",15952,ianhays,corefx
19545,Failure in ClientAsyncAuthenticate_AllServerAllClient_Success in CI,"```
     System.Net.Security.Tests.ClientAsyncAuthenticateTest.ClientAsyncAuthenticate_AllServerAllClient_Success [FAIL]
        System.IO.IOException : Authentication failed because the remote party has closed the transport stream.
        Stack Trace:
           D:\j\workspace\outerloop_win---7ad0ce03\src\System.Net.Security\src\System\Net\Security\SslState.cs(884,0): at System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
           D:\j\workspace\outerloop_win---7ad0ce03\src\System.Net.Security\src\System\Net\Security\SslState.cs(1094,0): at System.Net.Security.SslState.PartialFrameCallback(AsyncProtocolRequest asyncRequest)
           --- End of stack trace from previous location where exception was thrown ---
              at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
           D:\j\workspace\outerloop_win---7ad0ce03\src\System.Net.Security\src\System\Net\Security\SslState.cs(752,0): at System.Net.Security.SslState.InternalEndProcessAuthentication(LazyAsyncResult lazyResult)
           D:\j\workspace\outerloop_win---7ad0ce03\src\System.Net.Security\src\System\Net\Security\SslState.cs(722,0): at System.Net.Security.SslState.EndProcessAuthentication(IAsyncResult result)
           D:\j\workspace\outerloop_win---7ad0ce03\src\System.Net.Security\src\System\Net\Security\SslStream.cs(132,0): at System.Net.Security.SslStream.EndAuthenticateAsClient(IAsyncResult asyncResult)
              at System.Threading.Tasks.TaskFactory`1.FromAsyncCoreLogic(IAsyncResult iar, Func`2 endFunction, Action`1 endAction, Task`1 promise, Boolean requiresSynchronization)
           --- End of stack trace from previous location where exception was thrown ---
              at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
              at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
              at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
           D:\j\workspace\outerloop_win---7ad0ce03\src\Common\tests\System\Threading\Tasks\TaskTimeoutExtensions.cs(19,0): at System.Threading.Tasks.TaskTimeoutExtensions.<TimeoutAfter>d__0.MoveNext()
           --- End of stack trace from previous location where exception was thrown ---
              at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
              at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
              at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
           D:\j\workspace\outerloop_win---7ad0ce03\src\System.Net.Security\tests\FunctionalTests\ClientAsyncAuthenticateTest.cs(151,0): at System.Net.Security.Tests.ClientAsyncAuthenticateTest.<ClientAsyncSslHelper>d__14.MoveNext()
           --- End of stack trace from previous location where exception was thrown ---
              at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
              at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
              at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
           D:\j\workspace\outerloop_win---7ad0ce03\src\System.Net.Security\tests\FunctionalTests\ClientAsyncAuthenticateTest.cs(75,0): at System.Net.Security.Tests.ClientAsyncAuthenticateTest.<ClientAsyncAuthenticate_AllServerAllClient_Success>d__7.MoveNext()
           --- End of stack trace from previous location where exception was thrown ---
              at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
              at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
           --- End of stack trace from previous location where exception was thrown ---
              at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
              at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
           --- End of stack trace from previous location where exception was thrown ---
              at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
              at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
  Using D:\j\workspace\outerloop_win---7ad0ce03\packages\ as folder for resolving package dependencies.
  Executing in D:\j\workspace\outerloop_win---7ad0ce03\bin\tests\AnyOS.AnyCPU.Debug\System.Threading.Performance.Tests\default.netcoreapp1.1\ 
  Hard linking dependent files... 
  Finished:    System.Net.Security.Tests
```
Does not seem related to the PR https://github.com/dotnet/corefx/pull/14158 
Similar to https://github.com/dotnet/corefx/issues/10909

@davidsh @CIPop","Failure in ClientAsyncAuthenticate_AllServerAllClient_Success in CI  ```
     System.Net.Security.Tests.ClientAsyncAuthenticateTest.ClientAsyncAuthenticate_AllServerAllClient_Success [FAIL]
        System.IO.IOException : Authentication failed because t",15952,ianhays,corefx
19680,Test failure: System.Threading.Tasks.Dataflow.Tests.ActionBlockTests/TestFaulting,"Opened on behalf of @jiangzeng

The test `System.Threading.Tasks.Dataflow.Tests.ActionBlockTests/TestFaulting` has failed.

Assert.Equal() Failure
    Expected: 0
    Actual:   1

        Stack Trace:

           at System.Threading.Tasks.Dataflow.Tests.ActionBlockTests.<TestFaulting>d__14.MoveNext()
    --- End of stack trace from previous location where exception was thrown ---
       at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
       at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
    --- End of stack trace from previous location where exception was thrown ---
       at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
       at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
    --- End of stack trace from previous location where exception was thrown ---
       at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
       at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
Build : Master - 20161214.01 (Core Tests)
Failing configurations:
- Suse.132.Amd64
  - AnyCPU-Release

Details:
https://mc.dot.net/#/product/netcore/master/source/official~2Fcorefx~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20161214.01/workItem/System.Threading.Tasks.Dataflow.Tests/analysis/xunit/System.Threading.Tasks.Dataflow.Tests.ActionBlockTests~2FTestFaulting","Test failure: System.Threading.Tasks.Dataflow.Tests.ActionBlockTests/TestFaulting  Opened on behalf of @jiangzeng

The test `System.Threading.Tasks.Dataflow.Tests.ActionBlockTests/TestFaulting` has failed.

Assert.Equal() Failure
    Expected: 0",15952,ianhays,corefx
17364,failure in ServerAsyncAuthenticate_AllClientVsIndividualServerSupportedProtocols_Success,"Details in http://dotnet-ci.cloudapp.net/job/dotnet_corefx/job/master/job/windows_nt_release_prtest/1552/console  
on a [PR](https://github.com/dotnet/corefx/pull/8707) that could not possibly cause the issue
 System.Net.Security.Tests.ServerAsyncAuthenticateTest.ServerAsyncAuthenticate_AllClientVsIndividualServerSupportedProtocols_Success(serverProtocol: Tls11) [FAIL]
        System.ComponentModel.Win32Exception : The credentials supplied to the package were not recognized
        Stack Trace:
           D:\j\workspace\windows_nt_re---37265eab\src\Common\src\Interop\Windows\sspicli\SSPIWrapper.cs(232,0): at System.Net.SSPIWrapper.AcquireCredentialsHandle(SSPIInterface secModule, String package, CredentialUse intent, SecureCredential scc)
           D:\j\workspace\windows_nt_re---37265eab\src\System.Net.Security\src\System\Net\SslStreamPal.Windows.cs(330,0): at System.Net.SslStreamPal.AcquireCredentialsHandle(CredentialUse credUsage, SecureCredential secureCredential)
           D:\j\workspace\windows_nt_re---37265eab\src\System.Net.Security\src\System\Net\SslStreamPal.Windows.cs(126,0): at System.Net.SslStreamPal.AcquireCredentialsHandle(X509Certificate certificate, SslProtocols protocols, EncryptionPolicy policy, Boolean isServer)
           D:\j\workspace\windows_nt_re---37265eab\src\System.Net.Security\src\System\Net\SecureChannel.cs(769,0): at System.Net.Security.SecureChannel.AcquireServerCredentials(Byte[]& thumbPrint)
           D:\j\workspace\windows_nt_re---37265eab\src\System.Net.Security\src\System\Net\SecureChannel.cs(901,0): at System.Net.Security.SecureChannel.GenerateToken(Byte[] input, Int32 offset, Int32 count, Byte[]& output)
           D:\j\workspace\windows_nt_re---37265eab\src\System.Net.Security\src\System\Net\SecureChannel.cs(805,0): at System.Net.Security.SecureChannel.NextMessage(Byte[] incoming, Int32 offset, Int32 count)
           D:\j\workspace\windows_nt_re---37265eab\src\System.Net.Security\src\System\Net\SecureProtocols\SslState.cs(749,0): at System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest)
           D:\j\workspace\windows_nt_re---37265eab\src\System.Net.Security\src\System\Net\SecureProtocols\SslState.cs(955,0): at System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
           D:\j\workspace\windows_nt_re---37265eab\src\System.Net.Security\src\System\Net\SecureProtocols\SslState.cs(1131,0): at System.Net.Security.SslState.ReadFrameCallback(AsyncProtocolRequest asyncRequest)
           --- End of stack trace from previous location where exception was thrown ---
           D:\j\workspace\windows_nt_re---37265eab\src\System.Net.Security\src\System\Net\SecureProtocols\SslState.cs(742,0): at System.Net.Security.SslState.InternalEndProcessAuthentication(LazyAsyncResult lazyResult)
           D:\j\workspace\windows_nt_re---37265eab\src\System.Net.Security\src\System\Net\SecureProtocols\SslState.cs(710,0): at System.Net.Security.SslState.EndProcessAuthentication(IAsyncResult result)
              at System.Threading.Tasks.TaskFactory`1.FromAsyncCoreLogic(IAsyncResult iar, Func`2 endFunction, Action`1 endAction, Task`1 promise, Boolean requiresSynchronization)
           --- End of stack trace from previous location where exception was thrown ---","failure in ServerAsyncAuthenticate_AllClientVsIndividualServerSupportedProtocols_Success  Details in http://dotnet-ci.cloudapp.net/job/dotnet_corefx/job/master/job/windows_nt_release_prtest/1552/console  
on a [PR](https://github.com/dotnet/corefx/pull/8",15952,ianhays,corefx
18974,SslStreamAlertsTest failure in CI,"https://ci.dot.net/job/dotnet_corefx/job/master/job/windows_nt_release_prtest/1647/consoleText

```
System.Net.Security.Tests.SslStreamAlertsTest.SslStream_StreamToStream_ServerInitiatedCloseNotify_Ok [FAIL]
        System.ComponentModel.Win32Exception : The credentials supplied to the package were not recognized
        Stack Trace:
              at System.Net.SSPIWrapper.AcquireCredentialsHandle(SSPIInterface secModule, String package, CredentialUse intent, SCHANNEL_CRED scc)
  Finished running tests.  End time= 1:45:19.12, Exit code = 0
  Finished:    System.Reflection.TypeExtensions.Tests
              at System.Net.Security.SslStreamPal.AcquireCredentialsHandle(CredentialUse credUsage, SCHANNEL_CRED secureCredential)
              at System.Net.Security.SslStreamPal.AcquireCredentialsHandle(X509Certificate certificate, SslProtocols protocols, EncryptionPolicy policy, Boolean isServer)

              at System.Net.Security.SecureChannel.AcquireServerCredentials(Byte[]& thumbPrint)
              at System.Net.Security.SecureChannel.GenerateToken(Byte[] input, Int32 offset, Int32 count, Byte[]& output)
              at System.Net.Security.SecureChannel.NextMessage(Byte[] incoming, Int32 offset, Int32 count)
              at System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest)
              at System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
              at System.Net.Security.SslState.ReadFrameCallback(AsyncProtocolRequest asyncRequest)
           --- End of stack trace from previous location where exception was thrown ---
              at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
              at System.Net.Security.SslState.EndProcessAuthentication(IAsyncResult result)
              at System.Threading.Tasks.TaskFactory`1.FromAsyncCoreLogic(IAsyncResult iar, Func`2 endFunction, Action`1 endAction, Task`1 promise, Boolean requiresSynchronization)
           --- End of stack trace from previous location where exception was thrown ---
              at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
              at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
           D:\j\workspace\windows_nt_re---37265eab\src\Common\tests\System\Threading\Tasks\TaskTimeoutExtensions.cs(19,0): at System.Threading.Tasks.TaskTimeoutExtensions.<TimeoutAfter>d__0.MoveNext()
           --- End of stack trace from previous location where exception was thrown ---
              at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
              at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
           D:\j\workspace\windows_nt_re---37265eab\src\System.Net.Security\tests\FunctionalTests\SslStreamAlertsTest.cs(76,0): at System.Net.Security.Tests.SslStreamAlertsTest.<SslStream_StreamToStream_ServerInitiatedCloseNotify_Ok>d__3.MoveNext()
           --- End of stack trace from previous location where exception was thrown ---
              at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
              at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
           --- End of stack trace from previous location where exception was thrown ---
              at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
              at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
           --- End of stack trace from previous location where exception was thrown ---
              at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
              at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
```","SslStreamAlertsTest failure in CI  https://ci.dot.net/job/dotnet_corefx/job/master/job/windows_nt_release_prtest/1647/consoleText

```
System.Net.Security.Tests.SslStreamAlertsTest.SslStream_StreamToStream_ServerInitiatedCloseNotify_Ok [FAIL]",15952,ianhays,corefx
18981,Flaky test : SslStream_StreamToStream_DataAfterShutdown_Fail,"`https://ci.dot.net/job/dotnet_corefx/job/master/job/windows_nt_release_prtest/1676/testReport/junit/System.Net.Security.Tests/SslStreamAlertsTest/SslStream_StreamToStream_DataAfterShutdown_Fail/`

```
MESSAGE:
System.ComponentModel.Win32Exception : The credentials supplied to the package were not recognized
+++++++++++++++++++
STACK TRACE:
at System.Net.SSPIWrapper.AcquireCredentialsHandle(SSPIInterface secModule, String package, CredentialUse intent, SCHANNEL_CRED scc) at System.Net.Security.SslStreamPal.AcquireCredentialsHandle(CredentialUse credUsage, SCHANNEL_CRED secureCredential) at System.Net.Security.SslStreamPal.AcquireCredentialsHandle(X509Certificate certificate, SslProtocols protocols, EncryptionPolicy policy, Boolean isServer) at System.Net.Security.SecureChannel.AcquireServerCredentials(Byte[]& thumbPrint) at System.Net.Security.SecureChannel.GenerateToken(Byte[] input, Int32 offset, Int32 count, Byte[]& output) at System.Net.Security.SecureChannel.NextMessage(Byte[] incoming, Int32 offset, Int32 count) at System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest) at System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest) at System.Net.Security.SslState.ReadFrameCallback(AsyncProtocolRequest asyncRequest) --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Net.Security.SslState.EndProcessAuthentication(IAsyncResult result) at System.Threading.Tasks.TaskFactory`1.FromAsyncCoreLogic(IAsyncResult iar, Func`2 endFunction, Action`1 endAction, Task`1 promise, Boolean requiresSynchronization) --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at System.Threading.Tasks.TaskTimeoutExtensions.<TimeoutAfter>d__0.MoveNext() in D:\j\workspace\windows_nt_re---37265eab\src\Common\tests\System\Threading\Tasks\TaskTimeoutExtensions.cs:line 19 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at System.Net.Security.Tests.SslStreamAlertsTest.<SslStream_StreamToStream_DataAfterShutdown_Fail>d__5.MoveNext() in D:\j\workspace\windows_nt_re---37265eab\src\System.Net.Security\tests\FunctionalTests\SslStreamAlertsTest.cs:line 143 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
```",Flaky test : SslStream_StreamToStream_DataAfterShutdown_Fail  `https://ci.dot.net/job/dotnet_corefx/job/master/job/windows_nt_release_prtest/1676/testReport/junit/System.Net.Security.Tests/SslStreamAlertsTest/SslStream_StreamToStream_DataAfterShutdown_Fai,15952,ianhays,corefx
12728,Disable SslStream_StreamToStream_DataAfterShutdown_Fail test failing in CI,"https://github.com/dotnet/corefx/issues/12706
cc: @CIPop ","Disable SslStream_StreamToStream_DataAfterShutdown_Fail test failing in CI  https://github.com/dotnet/corefx/issues/12706
cc: @CIPop ",15952,ianhays,corefx
19449,HttpWebRequest and HttpWebResonse - expose missing members,"Implement + expose + test these methods:
```
P:System.Net.HttpWebRequest.Connection
P:System.Net.HttpWebRequest.ContentLength
P:System.Net.HttpWebRequest.DefaultCachePolicy
P:System.Net.HttpWebRequest.PreAuthenticate
P:System.Net.HttpWebRequest.Proxy
P:System.Net.HttpWebRequest.Timeout
M:System.Net.HttpWebRequest.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
M:System.Net.HttpWebRequest.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
M:System.Net.HttpWebRequest.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)

P:System.Net.HttpWebResponse.IsMutuallyAuthenticated
M:System.Net.HttpWebResponse.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
M:System.Net.HttpWebResponse.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
M:System.Net.HttpWebResponse.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
```","HttpWebRequest and HttpWebResonse - expose missing members  Implement + expose + test these methods:
```
P:System.Net.HttpWebRequest.Connection
P:System.Net.HttpWebRequest.ContentLength
P:System.Net.HttpWebRequest.DefaultCachePolicy
P:System.Net.Http",14069,CIPop,corefx
13441,Expose additional methods from HttpWebRequest and Response,Contributes to https://github.com/dotnet/corefx/issues/13372,Expose additional methods from HttpWebRequest and Response  Contributes to https://github.com/dotnet/corefx/issues/13372,14069,CIPop,corefx
19487,Interpreter doesn't correctly validate jumps to undefined labels,"An attempt to jump to a label that does not exist within an expression does not raise an `InvalidOperationException`, but instead throws an assertion error. In release I imagine it would hit an index-out-of-range when executed but I haven't confirmed (certainly it would do something not good).

Previously building an interpreted lambda had included building a mapping of targets and branches which was then stored and never used, so this code was removed. Unfortunately since building this mapping had involved looking at ever label the opportunity to validate them was taken at that point, and that validation was also removed.","Interpreter doesn't correctly validate jumps to undefined labels  An attempt to jump to a label that does not exist within an expression does not raise an `InvalidOperationException`, but instead throws an assertion error. In release I imagine it would hi",14034,JonHanna,corefx
19488,Interpreter doesn't validate against jumping into an inner block with a value,"Such an expression is accepted, though elsewhere code in the compiler expressly forbids it.

The relevant validation in `Compiler.LabelInfo.ValidateJump` has never been present in `Interpreter.LabelInfo.ValidateJump`.

Perhaps it could be made to be allowed in both, but it should certainly be consistent.","Interpreter doesn't validate against jumping into an inner block with a value  Such an expression is accepted, though elsewhere code in the compiler expressly forbids it.

The relevant validation in `Compiler.LabelInfo.ValidateJump` has never been prese",14034,JonHanna,corefx
14006,[WIP] [no merge] Support limiting the buffer size in LargeArrayBuilder.,"There are certain Linq methods, such as `Where` and `Take`, where we cannot pinpoint the exact number of elements the iterator will contain, but we can establish an upper bound on how many elements there are. For example, `list.Where(p)` can have at most `list.Count` elements, and `e.Take(5)` can have at most 5 elements.

Currently, when we call `ToArray` on any of these iterators, the resizing pattern will be to allocate 4, then 8, then 16, etc. size buffers. This can be wasteful because e.g. if the source enumerable in `Where` contains 100 elements, we allocate space for 128 elements even though those last 28 slots will never be used.

This PR adds support to `LargeArrayBuilder<T>` to limit how many elements we allocate, so there is no extra space wasted. It should help drive down allocations in `Where`, `Where.Select`, & `Take` when the maximum count is far from the next power of 2.

Waiting on: #12703, #13628","[WIP] [no merge] Support limiting the buffer size in LargeArrayBuilder.  There are certain Linq methods, such as `Where` and `Take`, where we cannot pinpoint the exact number of elements the iterator will contain, but we can establish an upper bound on ho",14020,jamesqo,corefx
12703,"Optimize Where{.Select}.To{Array,List} & Count.","Changes:

- Refactor `Count` such that the part that checks for internal Linq interfaces is segregated from the part that checks for the rest of the interfaces.
  - The internal `Count` method is probably only going to be used by Linq, so I put this in a new file & made `EnumerableHelpers` partial, so other assemblies using that class don't have to drag in extra IL.
  - Put a chunk of `Count` in a non-generic method, so we save generating a substantial chunk of code for every different generic instantation of the method.
- Implement `IIListProvider` on all of the `Where` / `Where.Select` iterators, substantially speeding up all `ToArray` / `ToList` operations by avoiding virtual calls / field stores.
- Remove an `int` field from some `Where` iterators by reusing `_state - 1` as the index.

@stephentoub, @VSadov ","Optimize Where{.Select}.To{Array,List} & Count.  Changes:

- Refactor `Count` such that the part that checks for internal Linq interfaces is segregated from the part that checks for the rest of the interfaces.
  - The internal `Count` method is probabl",14020,jamesqo,corefx
13628,Recognize Skip/Take chains on lazy sequences.,"I added a new `EnumerablePartition<TSource>` class that lets us now recognize patterns like `Take.Skip`, or vice versa, for lazy sequences. We also remove a layer of indirection from some common operations following these methods, e.g. `Take.ToArray`, `Skip.ToArray`, etc.

Perf results can be found [here](https://gist.github.com/jamesqo/07eb6b38d69431d7270900e3a7519c32); test code [here](https://github.com/jamesqo/Dotnet/blob/502e3c302575d04824e7337bec4d635abc8dc548/Program.cs). There is a ~20% speedup that results from removing an indirection layer from the chain.

cc @JonHanna, @VSadov, @stephentoub","Recognize Skip/Take chains on lazy sequences.  I added a new `EnumerablePartition<TSource>` class that lets us now recognize patterns like `Take.Skip`, or vice versa, for lazy sequences. We also remove a layer of indirection from some common operations fo",14020,jamesqo,corefx
19228,Once the Marshal class exposes SecureString overrloads implement the SecureStringMarsal class and re-enable tests.,"","Once the Marshal class exposes SecureString overrloads implement the SecureStringMarsal class and re-enable tests.  ",13509,stephentoub,corefx
19292,Three X509Certificates / SecureString tests failing,"```
System.Security.Cryptography.X509Certificates.Tests.PfxTests.TestConstructor_SecureString(keyStorageFlags: DefaultKeySet) [FAIL]
        Internal.Cryptography.CryptoThrowHelper+WindowsCryptographicException : The specified network password is not correct
        Stack Trace:
              at Internal.Cryptography.Pal.CertificatePal.FilterPFXStore(Byte[] rawData, SafePasswordHandle password, PfxCertStoreFlags pfxCertStoreFlags)
              at Internal.Cryptography.Pal.CertificatePal.FromBlobOrFile(Byte[] rawData, String fileName, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags)
              at Internal.Cryptography.Pal.CertificatePal.FromBlob(Byte[] rawData, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags)
              at System.Security.Cryptography.X509Certificates.X509Certificate..ctor(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags)
              at System.Security.Cryptography.X509Certificates.X509Certificate2..ctor(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags)
           D:\j\workspace\windows_nt_de---4526f5ff\src\System.Security.Cryptography.X509Certificates\tests\PfxTests.cs(48,0): at System.Security.Cryptography.X509Certificates.Tests.PfxTests.TestConstructor_SecureString(X509KeyStorageFlags keyStorageFlags)
     System.Security.Cryptography.X509Certificates.Tests.PfxTests.TestConstructor_SecureString(keyStorageFlags: EphemeralKeySet) [FAIL]
        Internal.Cryptography.CryptoThrowHelper+WindowsCryptographicException : The specified network password is not correct
        Stack Trace:
              at Internal.Cryptography.Pal.CertificatePal.FilterPFXStore(Byte[] rawData, SafePasswordHandle password, PfxCertStoreFlags pfxCertStoreFlags)
              at Internal.Cryptography.Pal.CertificatePal.FromBlobOrFile(Byte[] rawData, String fileName, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags)
              at Internal.Cryptography.Pal.CertificatePal.FromBlob(Byte[] rawData, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags)
              at System.Security.Cryptography.X509Certificates.X509Certificate..ctor(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags)
              at System.Security.Cryptography.X509Certificates.X509Certificate2..ctor(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags)
           D:\j\workspace\windows_nt_de---4526f5ff\src\System.Security.Cryptography.X509Certificates\tests\PfxTests.cs(48,0): at System.Security.Cryptography.X509Certificates.Tests.PfxTests.TestConstructor_SecureString(X509KeyStorageFlags keyStorageFlags)
     System.Security.Cryptography.X509Certificates.Tests.CollectionTests.ExportCert_SecureString [FAIL]
        Internal.Cryptography.CryptoThrowHelper+WindowsCryptographicException : The specified network password is not correct
        Stack Trace:
              at Internal.Cryptography.Pal.CertificatePal.FilterPFXStore(Byte[] rawData, SafePasswordHandle password, PfxCertStoreFlags pfxCertStoreFlags)
              at Internal.Cryptography.Pal.CertificatePal.FromBlobOrFile(Byte[] rawData, String fileName, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags)
              at Internal.Cryptography.Pal.CertificatePal.FromBlob(Byte[] rawData, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags)
              at System.Security.Cryptography.X509Certificates.X509Certificate..ctor(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags)
              at System.Security.Cryptography.X509Certificates.X509Certificate2..ctor(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags)
           D:\j\workspace\windows_nt_de---4526f5ff\src\System.Security.Cryptography.X509Certificates\tests\CollectionTests.cs(1393,0): at System.Security.Cryptography.X509Certificates.Tests.CollectionTests.TestExportSingleCert_SecureStringPassword(X509ContentType ct)
           D:\j\workspace\windows_nt_de---4526f5ff\src\System.Security.Cryptography.X509Certificates\tests\CollectionTests.cs(647,0): at System.Security.Cryptography.X509Certificates.Tests.CollectionTests.ExportCert_SecureString()
```","Three X509Certificates / SecureString tests failing  ```
System.Security.Cryptography.X509Certificates.Tests.PfxTests.TestConstructor_SecureString(keyStorageFlags: DefaultKeySet) [FAIL]
        Internal.Cryptography.CryptoThrowHelper+WindowsCryptographi",13509,stephentoub,corefx
15440,Expression interpreter - Remove dead code,"There's some unused code in a variety of places of the expression interpreter that can be removed to reduce code size.","Expression interpreter - Remove dead code  There's some unused code in a variety of places of the expression interpreter that can be removed to reduce code size.",13467,JonHanna,corefx
14370,Improve code coverage for System.Linq.Expressions,"According to the current code coverage report, this library is only at ~40%. Our general goal is closer to 90%, though this will depend on the library. We should investigate to see whether the current coverage level is appropriate, and if not, improve our test suites to provide better coverage.","Improve code coverage for System.Linq.Expressions  According to the current code coverage report, this library is only at ~40%. Our general goal is closer to 90%, though this will depend on the library. We should investigate to see whether the current cov",13467,JonHanna,corefx
19287,Test Failure: System.Net.Requests.Tests,"In Ubuntu 14.04 (x86_64), ``System.Net.Requests.Tests`` failed as follows:
```
   System.Net.Tests.HttpRequestCachePolicyTest.Ctor_ExpectedPropertyValues(p: Level:Default, level: Default, maxAge: 10675199.02:48:05.4775807, maxStale: -10675199.02:48:05.4775808, minFresh: -10675199.02:48:05.4775808, cacheSyncDate: 0001-01-01T00:00:00.0000042) [FAIL]
      Assert.Equal() Failure
      Expected: 0001-01-01T00:00:00.0000042
      Actual:   0001-01-01T00:00:00.0000000Z
      Stack Trace:
         /home/parjong/projects/dotnet/corefx/src/System.Net.Requests/tests/HttpRequestCachePolicyTest.cs(38,0): at System.Net.Tests.HttpRequestCachePolicyTest
```","Test Failure: System.Net.Requests.Tests  In Ubuntu 14.04 (x86_64), ``System.Net.Requests.Tests`` failed as follows:
```
   System.Net.Tests.HttpRequestCachePolicyTest.Ctor_ExpectedPropertyValues(p: Level:Default, level: Default, maxAge: 10675199.02:48:0",13463,parjong,corefx
19265,Tuple.IStructuralComparable/Equatable throws NRE,"The following tests demonstrates this.
```
[Fact]
public void IStructuralEquatable_Equals_NullEqualityComparer_ThrowsNullReferenceException()
{
    IStructuralEquatable structuralEquatable = Tuple.Create(1);
    Assert.Throws<NullReferenceException>(() => structuralEquatable.Equals(Tuple.Create(1), null));
}

[Fact]
public void IStructuralEquatable_GetHashCode_NullEqualityComparer_ThrowsNullReferenceException()
{
    IStructuralEquatable structuralEquatable = Tuple.Create(1);
    Assert.Throws<NullReferenceException>(() => structuralEquatable.GetHashCode(null));
}

[Fact]
public void IStructuralComparable_CompareTo_NullEqualityComparer_ThrowsNullReferenceException()
{
    IStructuralComparable structuralComparable = Tuple.Create(1);
    Assert.Throws<NullReferenceException>(() => structuralComparable.CompareTo(Tuple.Create(1), null));
}
```

I can send in a PR fixing this to throw ArgumentNullException, but there might be breaking change so I'll let you guys approve it before I go wasting my time ;)","Tuple.IStructuralComparable/Equatable throws NRE  The following tests demonstrates this.
```
[Fact]
public void IStructuralEquatable_Equals_NullEqualityComparer_ThrowsNullReferenceException()
{
    IStructuralEquatable structuralEquatable = Tuple.Cre",13436,hughbe,corefx
19275,ValueTuple.IStructuralComparable/Equatable throws NRE instead of ArgumentNullException,"The following tests demonstrates this.
```
[Fact]
public void IStructuralEquatable_Equals_NullEqualityComparer_ThrowsNullReferenceException()
{
    IStructuralEquatable structuralEquatable = ValueTuple.Create(1);
    Assert.Throws<NullReferenceException>(() => structuralEquatable.Equals(Tuple.Create(1), null));
}

[Fact]
public void IStructuralEquatable_GetHashCode_NullEqualityComparer_ThrowsNullReferenceException()
{
    IStructuralEquatable structuralEquatable = ValueTuple.Create(1);
    Assert.Throws<NullReferenceException>(() => structuralEquatable.GetHashCode(null));
}

[Fact]
public void IStructuralComparable_CompareTo_NullEqualityComparer_ThrowsNullReferenceException()
{
    IStructuralComparable structuralComparable = ValueTuple.Create(1);
    Assert.Throws<NullReferenceException>(() => structuralComparable.CompareTo(Tuple.Create(1), null));
}
```

Spun off from dotnet/runtime#19265

/cc @karelz (who can help triage this :) )","ValueTuple.IStructuralComparable/Equatable throws NRE instead of ArgumentNullException  The following tests demonstrates this.
```
[Fact]
public void IStructuralEquatable_Equals_NullEqualityComparer_ThrowsNullReferenceException()
{
    IStructuralEqu",13436,hughbe,corefx
19212,Possible bug in BufferedStream.FlushAsync for read-only Streams,"There is [this code](https://github.com/dotnet/corefx/blob/master/src/System.IO/src/System/IO/BufferedStream.cs#L272-L290) in the synchronous `BufferedStream.Flush`:

```cs
            if (_readPos < _readLen)
            {
                // If the underlying stream is not seekable AND we have something in the read buffer, then FlushRead would throw.
                // We can either throw away the buffer resulting in data loss (!) or ignore the Flush.
                // (We cannot throw because it would be a breaking change.) We opt into ignoring the Flush in that situation.
                if (!_stream.CanSeek)
                    return;

                FlushRead();

                // User streams may have opted to throw from Flush if CanWrite is false (although the abstract Stream does not do so).
                // However, if we do not forward the Flush to the underlying stream, we may have problems when chaining several streams.
                // Let us make a best effort attempt:
                if (_stream.CanWrite)
                    _stream.Flush();

                Debug.Assert(_writePos == 0 && _readPos == 0 && _readLen == 0);
                return;
            }
```

Here is the [corresponding code](https://github.com/dotnet/corefx/blob/master/src/System.IO/src/System/IO/BufferedStream.cs#L324-L342) in the async version:

```cs
                if (_readPos < _readLen)
                {
                    // If the underlying stream is not seekable AND we have something in the read buffer, then FlushRead would throw.
                    // We can either throw away the buffer resulting in date loss (!) or ignore the Flush. (We cannot throw because it
                    // would be a breaking change.) We opt into ignoring the Flush in that situation.
                    if (!_stream.CanSeek)
                        return;

                    FlushRead();  // not async; it uses Seek, but there's no SeekAsync

                    // User streams may have opted to throw from Flush if CanWrite is false (although the abstract Stream does not do so).
                    // However, if we do not forward the Flush to the underlying stream, we may have problems when chaining several streams.
                    // Let us make a best effort attempt:
                    if (_stream.CanRead)
                        await _stream.FlushAsync(cancellationToken).ConfigureAwait(false);

                    Debug.Assert(_writePos == 0 && _readPos == 0 && _readLen == 0);
                    return;
                }
```

Note how in the first version, we check if the stream is writable before calling `Flush` while in the second `FlushAsync` is called if the stream is readable. It looks like this is a typo, and the second version should have checked `_stream.CanWrite`.","Possible bug in BufferedStream.FlushAsync for read-only Streams  There is [this code](https://github.com/dotnet/corefx/blob/master/src/System.IO/src/System/IO/BufferedStream.cs#L272-L290) in the synchronous `BufferedStream.Flush`:

```cs
            if",13379,jamesqo,corefx
19069,TestFailure: System.Net.Mail.Functional.Tests,"I encountered the following test failure while running `System.Net.Mail.Functional.Tests` unittest:

```
xUnit.net console test runner (32-bit .NET Core)
Copyright (C) 2014 Outercurve Foundation.
Discovering: System.Net.Mail.Functional.Tests
Discovered:  System.Net.Mail.Functional.Tests
Starting:    System.Net.Mail.Functional.Tests
   System.Net.Mime.Tests.ContentDispositionTest.GetViaDateTimeProperty_WithUniversalTime_ShouldSetDateTimeKindAppropriately [FAIL]
      System.ArgumentOutOfRangeException : Hour, Minute, and Second parameters describe an un-representable DateTime.
      Stack Trace:
            at System.DateTime.TimeToTicks(Int32 hour, Int32 minute, Int32 second)
         /home/parjong/projects/dotnet/corefx/src/System.Net.Mail/tests/Functional/ContentDispositionTest.cs(255,0): at System.Net.Mime.Tests.ContentDispositionTest.GetViaDateTimeProperty_WithUniversalTime_ShouldSetDateTimeKindAppropriately()
   System.Net.Mime.Tests.ContentDispositionTest.SetDispositionViaConstructor_ShouldSetCorrectly_AndRespectCustomValues [FAIL]
      System.ArgumentOutOfRangeException : Hour, Minute, and Second parameters describe an un-representable DateTime.
      Stack Trace:
            at System.DateTime.TimeToTicks(Int32 hour, Int32 minute, Int32 second)
         /home/parjong/projects/dotnet/corefx/src/System.Net.Mail/tests/Functional/ContentDispositionTest.cs(323,0): at System.Net.Mime.Tests.ContentDispositionTest.SetDispositionViaConstructor_ShouldSetCorrectly_AndRespectCustomValues()
   System.Net.Mime.Tests.ContentDispositionTest.SetDateViaConstructor_ShouldPersistToPropertyAndPersistToParametersCollection [FAIL]
      System.ArgumentOutOfRangeException : Hour, Minute, and Second parameters describe an un-representable DateTime.
      Stack Trace:
            at System.DateTime.TimeToTicks(Int32 hour, Int32 minute, Int32 second)
         /home/parjong/projects/dotnet/corefx/src/System.Net.Mail/tests/Functional/ContentDispositionTest.cs(230,0): at System.Net.Mime.Tests.ContentDispositionTest.SetDateViaConstructor_ShouldPersistToPropertyAndPersistToParametersCollection()
Finished:    System.Net.Mail.Functional.Tests
=== TEST EXECUTION SUMMARY ===
   System.Net.Mail.Functional.Tests  Total: 158, Errors: 0, Failed: 3, Skipped: 0, Time: 6.288s
```","TestFailure: System.Net.Mail.Functional.Tests  I encountered the following test failure while running `System.Net.Mail.Functional.Tests` unittest:

```
xUnit.net console test runner (32-bit .NET Core)
Copyright (C) 2014 Outercurve Foundation.
Discove",12945,parjong,corefx
12783,System.Globalization.Extensions cleanup,"Clean up some tests for System.Globalization.Extensions
Some tests were tightened to better reflect current behavior.","System.Globalization.Extensions cleanup  Clean up some tests for System.Globalization.Extensions
Some tests were tightened to better reflect current behavior.",12933,Clockwork-Muse,corefx
12865,"Revert ""System.Globalization.Extensions cleanup""","Reverts dotnet/corefx#12783","Revert ""System.Globalization.Extensions cleanup""  Reverts dotnet/corefx#12783",12933,Clockwork-Muse,corefx
12800,Make derived types of SymmetricAlgorithm use field assignment in ctors.,"Aes and TripleDES both did assignments via virtual property setters in their ctor,
which were field assignments in .NET Framework.  3rd party implementations
may have written properties which assumed that the ctor had run to completion,
and they are broken by that behavioral change.

This change makes the ctors look like they do in net462, aside from when
net462 sets fields which don't exist.

It also makes the tests fail if virtual setter dispatch was utilized (for any currently
defined property, at least).

This addresses  #12079 in master, a porting change may follow for release/1.1.0.
cc: @steveharter","Make derived types of SymmetricAlgorithm use field assignment in ctors.  Aes and TripleDES both did assignments via virtual property setters in their ctor,
which were field assignments in .NET Framework.  3rd party implementations
may have written prope",12869,bartonjs,corefx
18713,Don't invoke virtual property setters inside the base constructor.,"This is related to the following issue which does not appear to have been fully addressed:
https://github.com/dotnet/corefx/pull/6829

We are still seeing the issue in the AuthenticatedAes class. Here is a partial call stack. Feel free to request additional information.

0000004b9864d960 00007ffce4a131e3 Security.Cryptography.AuthenticatedAesCng.set_Mode(System.Security.Cryptography.CipherMode)
0000004b9864d9a0 00007ffce4a1316a System.Security.Cryptography.SymmetricAlgorithm..ctor() [f:\dd\ndp\fxcore\Open\src\System.Security.Cryptography.Primitives\src\System\Security\Cryptography\SymmetricAlgorithm.cs @ 14]
0000004b9864d9d0 00007ffce4a1312b Security.Cryptography.AuthenticatedSymmetricAlgorithm..ctor()
0000004b9864da00 00007ffce4a130ab Security.Cryptography.AuthenticatedAes..ctor()
0000004b9864da30 00007ffce4a12eca Security.Cryptography.AuthenticatedAesCng..ctor(System.Security.Cryptography.CngProvider)
0000004b9864daf0 00007ffce4a12532 Microsoft.Windows.KpsCore.Crypto.Cng.AuthenticatedAes..ctor(Microsoft.Windows.KpsCore.Crypto.AuthenticatedAesMode, System.String)","Don't invoke virtual property setters inside the base constructor.  This is related to the following issue which does not appear to have been fully addressed:
https://github.com/dotnet/corefx/pull/6829

We are still seeing the issue in the Authenticate",12869,bartonjs,corefx
11492,Specialize Enumerable.Concat when all items are ICollections.,"If all of the inputs to `Enumerable.Concat` are ICollections, (which is common, at least in code I've written) then we can optimize much better if it is called `ToArray` or `Count` on. This change introduces 2 new iterators for Concat, `Concat2CollectionIterator` and `ConcatNCollectionIterator`, and renames the existing ones to `Concat{2,N}EnumerableIterator`.

The main difference with these iterators is:
- It has a better implementation for `ToArray`. Previously we just called `EnumerableHelpers.ToArray` if a `Concat` iterator was returned `ToArray` on. However, if we know that all of the enumerables are ICollections, we can sum their counts to allocate an array of exactly the right size, and then call `CopyTo` on each of them to fill the array. (This is a bit tricky in `ConcatNCollectionIterator` since we hold a reference to the most recently `Concat`'d collection, so we have to `CopyTo` the collections in reverse order.)
- We no longer pessimize `GetCount(true)`, since we assuming that accessing the `Count` property of the collections will be cheap (at least, cheaper than manually enumerating them), and we just sum the count of all of them.

Any input that implements `ICollection` will use these iterators. However, as soon as we see a non-ICollection, we fallback to using a regular `ConcatNIterator`.
## Benchmarks

Results/test are [here](https://gist.github.com/jamesqo/0164d1d8229a010e07d225d2d4d8af34).

Quite amazingly, there is a 5x reduction in gen0 collections and 40x speedup with the new implementation, at least for length 100 collections. Even for length 3 ones, it's still 4x faster and the # of collections go from 89 => 15 (presumably since we're no longer allocating enumerators).

/cc: @JonHanna, @stephentoub, @VSadov ","Specialize Enumerable.Concat when all items are ICollections.  If all of the inputs to `Enumerable.Concat` are ICollections, (which is common, at least in code I've written) then we can optimize much better if it is called `ToArray` or `Count` on. This ch",11525,jamesqo,corefx
11265,WIP: Adding new SslStream API,"@ericstj @weshaggard @davidsh @bartonjs PTAL 

Creating a new, simplified PR only for the API addition based on master.

The current error is:

```
""S:\c1\src\System.Net.Security\ref\System.Net.Security.csproj"" (rebuild target) (1) ->
(ValidatePackageTargetFramework target) ->
  S:\c1\Tools\PackageLibs.targets(213,5): error : Expected version 4.1.0.0 for referenced assembly S:\c1\packages\System.Security
.Cryptography.Algorithms\4.2.0\ref\netstandard1.6\System.Security.Cryptography.Algorithms.dll but found 4.2.0.0 [S:\c1\src\System
.Net.Security\ref\System.Net.Security.csproj]
```

The error is probably because of the switch to netstandard1.6 which includes UWP.
What are the strings (I couldn't find documentation) to make System.Net.Security 4.1.0.0 a net463 contract _only_ (no netstandard) while keeping 4.0.0.0 part of netstandard1.3?","WIP: Adding new SslStream API  @ericstj @weshaggard @davidsh @bartonjs PTAL 

Creating a new, simplified PR only for the API addition based on master.

The current error is:

```
""S:\c1\src\System.Net.Security\ref\System.Net.Security.csproj"" (rebui",11489,CIPop,corefx
17389,SslStream should handle handshake and close_notify alerts,"At least until 2014, there was a problem with SslStream, where it didn't terminate the connection properly. There is a solution for the problem described on [Stack Overflow: .NET SslStream doesn't close TLS connection properly](http://stackoverflow.com/questions/237807/net-sslstream-doesnt-close-tls-connection-properly). This solution (obviously) doesn't work any more with .NET Core. Is this problem fixed, or do we still need some kind of workaround?","SslStream should handle handshake and close_notify alerts  At least until 2014, there was a problem with SslStream, where it didn't terminate the connection properly. There is a solution for the problem described on [Stack Overflow: .NET SslStream doesn't",11489,CIPop,corefx
15141,Tracking items for System.Net.Security,"This issue is tracking TODOs and Shims removal for PR dotnet/corefx#3113:
- [ ] Replace Interop.Secur32 names with OS names from the SDK (sspi.h and schannel.h)
- [X] Replace the X509Certificate ctor shim as soon as it is available.
- [X] Move _SSPIWrapper.cs OS specific classes to Interop.SSPI
- [ ] Remove StreamAsyncHelper references and implement FixedSizeReader and SslState using TPL instead of APM.
- [ ] _SslState.cs:1299: Within FinishWrite() the callback is called under `lock (this)`. We need to investigate if there is any chance of a deadlock. 
- [X] Remove SSLv2 support from SslStream.
- [ ] Add new Cypher and Hashing algorithms to enums within the contract.
- [ ] Split _SecuritySafeHandles.Windows.cs
- [ ] In NativeSSPI:   Unit/Functional test required to understand the intent and pin behavior between Desktop and CoreFX.

> Decrypt checked qop != SECQOP_WRAP_NO_ENCRYPT. Sign used it. Verify just ignores it?
- [ ] Replace all usage of ArrayList, Hashtable with appropriate modern collections.
- [ ] Behavior impacting: check client certs for the client EKU within `private bool AcquireClientCredentials(ref byte[] thumbPrint)`
- [ ] Replace the implementation of SpnDictionary with `Dictionary<>` or `ConcurrentDictionary<>`.
- [X] Provide TPL Stream overrides for SslStream. (By dotnet/corefx#5541.)
- [ ] Investigate ways to bring back the NetworkStream specific optimizations (`BeginMultipleWrite`, etc)
- [ ] Move public parameter checks within their respective public methods. (See comments in dotnet/corefx#5541)
- [ ] In `CompleteAuthToken` and `ApplyControlToken`: remove the extra allocation of a `CredHandle`; refactor the code to avoid duplication; remove the `AddRef` if the `refContext` was previously `null`. (See dotnet/corefx#11489) ","Tracking items for System.Net.Security  This issue is tracking TODOs and Shims removal for PR dotnet/corefx#3113:
- [ ] Replace Interop.Secur32 names with OS names from the SDK (sspi.h and schannel.h)
- [X] Replace the X509Certificate ctor shim as soon",11489,CIPop,corefx
18440,HttpClient throws WinHttpException if the WWW-Authenticate header contains an unknown scheme,"If a webserver returns a `401` status code and a `WWW-Authenticate` header with an unknown scheme, an exception is thrown.

For example this code:

``` csharp
var handler = new HttpClientHandler()
{
    Credentials = new NetworkCredential(""foo"",""bar"")
};

using (var client = new HttpClient(handler))
    client.GetAsync(""http://greenbytes.de/tech/tc/httpauth/unknown.asis"")
        .GetAwaiter().GetResult();
```

returns a header `WWW-Authenticate: Newauth realm=""newauth""` which causes the following exception:

```
System.Net.Http.WinHttpException: The operation identifier is not valid
   at System.Net.Http.WinHttpException.ThrowExceptionUsingLastError()
   at System.Net.Http.WinHttpAuthHelper.CheckResponseForAuthentication(WinHttpRequestState state, UInt32& proxyAuthScheme, UInt32& serverAuthScheme)
   at System.Net.Http.WinHttpHandler.<StartRequest>d__105.MoveNext()
```

This exception is thrown before the `ICredential.GetCredential(Uri, string)` method is called, so the end user cannot specify their own credentials for that scheme.","HttpClient throws WinHttpException if the WWW-Authenticate header contains an unknown scheme  If a webserver returns a `401` status code and a `WWW-Authenticate` header with an unknown scheme, an exception is thrown.

For example this code:

``` cshar",11481,davidsh,corefx
18444,HttpClient throws an exception if the WWW-Authenticate header is missing,"If the server returns a 401 response but does not supply a `WWW-Authenticate` header (in contravention to the RFC requirement), and exception is thrown just as in dotnet/runtime#18440, and this could be a special case of an unknown scheme.

HttpClient on .NET Framework does handle this scenario but returning the 401 to the caller, so I suggest the .NET Core implementation also handles it despite the server doing the wrong thing.","HttpClient throws an exception if the WWW-Authenticate header is missing  If the server returns a 401 response but does not supply a `WWW-Authenticate` header (in contravention to the RFC requirement), and exception is thrown just as in dotnet/runtime#184",11481,davidsh,corefx
18426,Unhandled convert error raised from ILGen for Coalesce expression with decimal type,"Repro:

``` csharp
using System;
using System.Linq.Expressions;

class Program
{
    static void Main()
    {
        var x = Expression.Coalesce(Expression.Constant(null, typeof(int?)), Expression.Constant(49.95m, typeof(decimal)));
        Expression.Lambda<Func<decimal>>(x).Compile()();
    }
}
```

Stack trace:

```
Unhandled Exception: System.ArgumentException: Unhandled convert: System.Decimal
   at System.Linq.Expressions.Compiler.ILGen.EmitNumericConversion(ILGenerator il, Type typeFrom, Type typeTo, Boolean isChecked)
   at System.Linq.Expressions.Compiler.LambdaCompiler.EmitNullableCoalesce(BinaryExpression b)
   at System.Linq.Expressions.Compiler.LambdaCompiler.EmitExpression(Expression node, CompilationFlags flags)
   at System.Linq.Expressions.Compiler.LambdaCompiler.EmitLambdaBody(CompilerScope parent, Boolean inlined, CompilationFlags flags)
   at System.Linq.Expressions.Compiler.LambdaCompiler.Compile(LambdaExpression lambda, DebugInfoGenerator debugInfoGenerator)
   at System.Linq.Expressions.Expression`1.Compile()
   at Program.Main()
```

The problem seems that `IsImplicitNumericConversion` allows implicit conversions (without the use of an `op_Implicit` method) to the `decimal` type while `EmitNumericConversion` only deals with built-in `conv` IL instructions.

Given that the expression factory allows this and builds a tree with a `Conversion` lambda, it'd be a breaking change to either reject it or implicitly construct a `Conversion` lambda. The right fix is likely in the `LambdaCompiler` to deal with this case and resolve the `op_Implicit` overload on `System.Decimal` to use for the conversion.

Note that the expression emitted by the C# compiler supplies a lambda for the `conversion` parameter of the `Coalesce` factory, i.e. the following does _not_ crash:

``` csharp
Expression<Func<int?, decimal>> e = x => x ?? 49.95m;
Func<int?, decimal> f = e.Compile();
f(42);
```

This issue was uncovered through https://github.com/dotnet/corefx/issues/11409.","Unhandled convert error raised from ILGen for Coalesce expression with decimal type  Repro:

``` csharp
using System;
using System.Linq.Expressions;

class Program
{
    static void Main()
    {
        var x = Expression.Coalesce(Expression.Con",11424,bartdesmet,corefx
18427,Expression interpreter doesn't handle implicit numeric conversions in Coalesce nodes,"Repro:

``` csharp
using System;
using System.Linq.Expressions;

class Program
{
    static void Main()
    {
        var x = Expression.Coalesce(Expression.Constant(42, typeof(int?)), Expression.Constant(42L, typeof(long)));
        Expression.Lambda<Func<long>>(x).Compile(true)();
    }
}
```

Output:

```
System.InvalidCastException : Unable to cast object of type 'System.Int32' to type 'System.Int64'.
Stack Trace:
    at Thunk(Func`2 )
```

It looks like `CompileCoalesceBinaryExpression` omits logic for the case where `Conversion` is `null` but the `Left` and `Right` types are not assignment compatible as-is. As a result, the result of running the interpreter, i.e. what's left in `frame.Data[0]`, is a boxed value of type `Int32` but the generated thunk emits an `unbox.any` instruction based on the expected (static) return type obtained from the lambda. This is what throws the `InvalidCastException`.

This issue was uncovered through This issue was uncovered through https://github.com/dotnet/corefx/issues/11409..","Expression interpreter doesn't handle implicit numeric conversions in Coalesce nodes  Repro:

``` csharp
using System;
using System.Linq.Expressions;

class Program
{
    static void Main()
    {
        var x = Expression.Coalesce(Expression.Co",11424,bartdesmet,corefx
9942,Make Stack<T>.Enumerator.Current inlineable by the JIT,"Previously `Stack<T>.Enumerator.get_Current` wasn't being inlined by the JIT, due to some exception throwing logic in the method that shouldn't happen on the main codepath. I've trivially separated it out into a new method, so now it can be inlined.
### Performance data
- [Old assembly generated for foreach](https://gist.github.com/jamesqo/bc90b5ccf61e2556a6dec6722056023c)
- [New assembly generated for foreach](https://gist.github.com/jamesqo/83916949f86aaac9238701d3f321854c) (doing a Ctrl+F and searching for `get_Current` will turn up 0 matches)
- There is about a 10-20% speedup when iterating through the stack. (Less than I expected, probably due to the fact that it's a struct so `call` is emitted and no null checking is necessary)
  - [Old results](https://gist.github.com/jamesqo/193ff8246e4257574df6046ac0219203)
  - [New results](https://gist.github.com/jamesqo/bbe8e7282403c2b9d70647a4931cd702)
  - [Perf test source code](https://gist.github.com/jamesqo/078248988715fb85fa3e6b77982654c1)

cc @ianhays, @stephentoub, @omariom 

Contributes to #9843 ","Make Stack<T>.Enumerator.Current inlineable by the JIT  Previously `Stack<T>.Enumerator.get_Current` wasn't being inlined by the JIT, due to some exception throwing logic in the method that shouldn't happen on the main codepath. I've trivially separated i",9951,jamesqo,corefx
17769,MoveNext and Current for Stack/Queue.Enumerator aren't being inlined,"Currently the `MoveNext`/`get_Current` methods for the `Stack/Queue.Enumerator` structs aren't being inlined, which means two method calls for every iteration of a foreach. We should look at making their method sizes smaller (e.g. moving [the exception throwing code](https://github.com/dotnet/corefx/blob/master/src/System.Collections/src/System/Collections/Generic/Queue.cs#L419-L422) into a new method and marking with `NoInlining`) to facilitate inlining of the normal code path by the JIT.","MoveNext and Current for Stack/Queue.Enumerator aren't being inlined  Currently the `MoveNext`/`get_Current` methods for the `Stack/Queue.Enumerator` structs aren't being inlined, which means two method calls for every iteration of a foreach. We should lo",9951,jamesqo,corefx
17761,Move Environment from coreclr to corefx,"Some of the Environment class needs to access runtime functionality, e.g. HasShutdownStarted, but a lot of it can be implemented in corefx, and doing so helps to avoid a) duplicating functionality/code with elsewhere in corefx, and b) duplicating implementations between CoreCLR and CoreRT.  We can reimplement the bulk of Environment, including the remainder of the surface area that's missing, in corefx, calling into a special class exposed from the runtime(s) just for the core pieces we need.","Move Environment from coreclr to corefx  Some of the Environment class needs to access runtime functionality, e.g. HasShutdownStarted, but a lot of it can be implemented in corefx, and doing so helps to avoid a) duplicating functionality/code with elsewhe",9851,stephentoub,corefx
16108,Expose rest of System.Environment.* members to .NET Core Surface area.,"cc @weshaggard ","Expose rest of System.Environment.* members to .NET Core Surface area.  cc @weshaggard ",9851,stephentoub,corefx
15824,Add back Environment.OSVersion,"Whatever the current Windows-related philosophy is about version numbers, the non-Windows world does use version numbers as a way of indicating when features become available, version information is consumable via functions like uname, etc.  

I've heard concerns about our not exposing it because we're concerned about developers misusing it, but developers often need this information and, if we don't expose it, developers will end up finding other ways to get at it, parsing things that shouldn't be parsed, doing their own P/Invokes in a non-portable fashion, and so on, resulting in a worse situation than if we'd just made it easy in the first place.

We should add Environment.OSVersion back to the System.Runtime.Extensions contract so that folks can rely on it.","Add back Environment.OSVersion  Whatever the current Windows-related philosophy is about version numbers, the non-Windows world does use version numbers as a way of indicating when features become available, version information is consumable via functions",9851,stephentoub,corefx
15329,Perf: Environment.GetEnvironmentVariable 4x slower on Linux,"Perf test:

```
[Benchmark]
public void GetEnvironmentVariable()
{
    PerfUtils utils = new PerfUtils();
    string env = utils.CreateString(15);
    try
    {
        // setup the environment variable so we can read it
        Environment.SetEnvironmentVariable(env, ""value"");

        // read the valid environment variable for the test
        foreach (var iteration in Benchmark.Iterations)
            using (iteration.StartMeasurement())
                for (int i = 0; i < 40000; i++)
                {
                    Environment.GetEnvironmentVariable(env); Environment.GetEnvironmentVariable(env); Environment.GetEnvironmentVariable(env);
                    Environment.GetEnvironmentVariable(env); Environment.GetEnvironmentVariable(env); Environment.GetEnvironmentVariable(env);
                    Environment.GetEnvironmentVariable(env); Environment.GetEnvironmentVariable(env); Environment.GetEnvironmentVariable(env);
                }
    }
    finally
    {
        // clear the variable that we set
        Environment.SetEnvironmentVariable(env, null);
    }
}
```

Linux results:

```
        <performance runid=""System.Runtime.Extensions.Tests.Perf_Environment.GetEnvironmentVariable-Linux"" etl=""/home/ianha/uptonogood/results/System.Runtime.Extensions.Tests.Perf_Environment.GetEnvironmentVariable-Linux.csv"">
          <metrics>
            <Duration displayName=""Duration"" unit=""msec"" />
          </metrics>
          <iterations>
            <iteration index=""0"" Duration=""241.97100000083447"" />
            <iteration index=""1"" Duration=""276.93550001084805"" />
            <iteration index=""2"" Duration=""239.42939999699593"" />
            <iteration index=""3"" Duration=""276.91189999878407"" />
            <iteration index=""4"" Duration=""244.32189999520779"" />
          </iterations>
        </performance>
```

Windows results:

```
        <performance runid=""System.Runtime.Extensions.Tests.Perf_Environment.GetEnvironmentVariable-WindowsCore"" etl=""D:\git\corefx\bin\tests\Windows_NT.AnyCPU.Release\System.Runtime.Extensions.Tests\dnxcore50\System.Runtime.Extensions.Tests.Perf_Environment.GetEnvironmentVariable-WindowsCore.etl"">
          <metrics>
            <Duration displayName=""Duration"" unit=""msec"" />
          </metrics>
          <iterations>
            <iteration index=""0"" Duration=""89.133545507185886"" />
            <iteration index=""1"" Duration=""85.199405502664149"" />
            <iteration index=""2"" Duration=""87.913018413964778"" />
            <iteration index=""3"" Duration=""88.31273319665479"" />
            <iteration index=""4"" Duration=""82.133119848005663"" />
            <iteration index=""5"" Duration=""78.0110967894235"" />
            <iteration index=""6"" Duration=""83.5999761653668"" />
            <iteration index=""7"" Duration=""88.5912790901557"" />
            <iteration index=""8"" Duration=""88.403966242632578"" />
            <iteration index=""9"" Duration=""87.94067343102688"" />
            <iteration index=""10"" Duration=""94.431049342537563"" />
            <iteration index=""11"" Duration=""83.27296271619025"" />
            <iteration index=""12"" Duration=""86.30560618514437"" />
          </iterations>
        </performance>
```","Perf: Environment.GetEnvironmentVariable 4x slower on Linux  Perf test:

```
[Benchmark]
public void GetEnvironmentVariable()
{
    PerfUtils utils = new PerfUtils();
    string env = utils.CreateString(15);
    try
    {
        // setup the en",9851,stephentoub,corefx
16798,xUnit console runner crashes when writing invalid characters to the XML file,"Separating this out from dotnet/corefx#7042 (where the bug was discovered) so we have a separate issue to keep track of it.

Currently, the xUnit console runner will crash if certain invalid characters, like standalone surrogates, U+FFFE or U+FFFF are written to the XML file. For example, this would fail:

``` csharp
public static IEnumerable<object[]> Equal_TestData()
{
    yield return new object[] { ""\uD800"", ""\uD800"" };
}

[Theory]
[MemberData(nameof(Equal_TestData))]
public void Equal(string expected, string actual)
{
    Assert.Equal(expected, actual);
}
```

The fix is to alter [this](https://github.com/dotnet/buildtools/blob/37d1d57167d2d112b26f94135f3281fe2601ab65/src/common/XmlTestExecutionVisitor.cs#L269) method of `XmlTestExecutionVisitor` in the buildtools repo to handle these invalid chars, in addition to C0 controls. See the fix I've made upstream here: xunit/xunit#804

I'll be submitting a PR shortly to buildtools to fix this.","xUnit console runner crashes when writing invalid characters to the XML file  Separating this out from dotnet/corefx#7042 (where the bug was discovered) so we have a separate issue to keep track of it.

Currently, the xUnit console runner will crash if",9821,hughbe,corefx
17759,Invalid high surrogate failure in System.Reflection.Emit tests,"http://dotnet-ci.cloudapp.net/job/dotnet_corefx/job/master/job/centos7.1_release_prtest/659/consoleText

```
System.Reflection.Emit.Tests  Total: 975, Errors: 0, Failed: 0, Skipped: 0, Time: 1.793s
EXEC : warning : Invalid high surrogate character (0xDF36). A high surrogate character must have a value from range (0xD800 - 0xDBFF). [/mnt/resource/j/workspace/dotnet_corefx/master/centos7.1_release_prtest/src/System.Reflection.Emit/tests/System.Reflection.Emit.Tests.csproj]
  Finished running tests. End time=05:41:02. Return value was 1
/mnt/resource/j/workspace/dotnet_corefx/master/centos7.1_release_prtest/Tools/tests.targets(217,5): warning MSB3073: The command ""/mnt/resource/j/workspace/dotnet_corefx/master/centos7.1_release_prtest/bin/tests/AnyOS.AnyCPU.Release/System.Reflection.Emit.Tests/netcoreapp1.0/RunTests.sh /mnt/resource/j/workspace/dotnet_corefx/master/centos7.1_release_prtest/packages/"" exited with code 1. [/mnt/resource/j/workspace/dotnet_corefx/master/centos7.1_release_prtest/src/System.Reflection.Emit/tests/System.Reflection.Emit.Tests.csproj]
/mnt/resource/j/workspace/dotnet_corefx/master/centos7.1_release_prtest/Tools/tests.targets(226,5): error : One or more tests failed while running tests from 'System.Reflection.Emit.Tests' please check log for details! [/mnt/resource/j/workspace/dotnet_corefx/master/centos7.1_release_prtest/src/System.Reflection.Emit/tests/System.Reflection.Emit.Tests.csproj]
```","Invalid high surrogate failure in System.Reflection.Emit tests  http://dotnet-ci.cloudapp.net/job/dotnet_corefx/job/master/job/centos7.1_release_prtest/659/consoleText

```
System.Reflection.Emit.Tests  Total: 975, Errors: 0, Failed: 0, Skipped: 0, Tim",9821,hughbe,corefx
17583,[release/1.0.0] Many networking tests fail with ---- System.ComponentModel.Win32Exception : Unable to load DLL 'System.Net.Security.Native': The specified module could not be found.,"One example failure:

```
Starting KDC..
   System.Net.Security.Tests.NegotiateStreamTest.NegotiateStream_EchoServer_ClientWriteRead_Successive_Async_Success [FAIL]
      System.Security.Authentication.AuthenticationException : A call to SSPI failed, see inner exception.
      ---- System.ComponentModel.Win32Exception : Unable to load DLL 'System.Net.Security.Native': The specified module could not be found.
       (Exception from HRESULT: 0x8007007E)
      Stack Trace:
            at System.Net.Security.NegoState.ValidateCreateContext(String package, Boolean isServer, NetworkCredential credential, String servicePrincipalName, ChannelBinding channelBinding, ProtectionLevel protectionLevel, TokenImpersonationLevel impersonationLevel)
            at System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(NetworkCredential credential, ChannelBinding binding, String targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback asyncCallback, Object asyncState)
            at System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(NetworkCredential credential, String targetName, AsyncCallback asyncCallback, Object asyncState)
            at System.Threading.Tasks.TaskFactory`1.FromAsyncImpl[TArg1,TArg2](Func`5 beginMethod, Func`2 endFunction, Action`1 endAction, TArg1 arg1, TArg2 arg2, Object state, TaskCreationOptions creationOptions)
            at System.Threading.Tasks.TaskFactory.FromAsync[TArg1,TArg2](Func`5 beginMethod, Action`1 endMethod, TArg1 arg1, TArg2 arg2, Object state)
            at System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(NetworkCredential credential, String targetName)
            at System.Net.Security.Tests.NegotiateStreamTest.NegotiateStream_EchoServer_ClientWriteRead_Successive_Async_Success()
         ----- Inner Stack Trace -----
            at System.Net.Security.NegotiateStreamPal.AcquireCredentialsHandle(String package, Boolean isServer, NetworkCredential credential)
            at System.Net.NTAuthentication.Initialize(Boolean isServer, String package, NetworkCredential credential, String spn, ContextFlagsPal requestedContextFlags, ChannelBinding channelBinding)
            at System.Net.NTAuthentication..ctor(Boolean isServer, String package, NetworkCredential credential, String spn, ContextFlagsPal requestedContextFlags, ChannelBinding channelBinding)
            at System.Net.Security.NegoState.ValidateCreateContext(String package, Boolean isServer, NetworkCredential credential, String servicePrincipalName, ChannelBinding channelBinding, ProtectionLevel protectionLevel, TokenImpersonationLevel impersonationLevel)
```","[release/1.0.0] Many networking tests fail with ---- System.ComponentModel.Win32Exception : Unable to load DLL 'System.Net.Security.Native': The specified module could not be found.  One example failure:

```
Starting KDC..
   System.Net.Security.Test",9351,bartonjs,corefx
9346,Include package reference to System.Net.Security,"Without an explicit package reference in the test project's project.json,
the native shim will not be included when producing the test output
folder, since the P2P reference between the test project and product
project does not imply that the native shim needs to come along for the
ride.

Fixes #9337","Include package reference to System.Net.Security  Without an explicit package reference in the test project's project.json,
the native shim will not be included when producing the test output
folder, since the P2P reference between the test project and",9351,bartonjs,corefx
9287,[release/1.0.0] Disable X509FilesystemTests on Fedora23,"The innerloop debug, innerloop release, and outerloop debug runs on Fedora23 in Jenkins fail in the X509FilesystemTests with a directory permissions error. Since this does not seem to be endemic to Fedora23 itself, but our machine configuration, we're disabling these tests to switch the overall status to passing.  The other distros will still guard for regressions.

This also marks the X509Store_AddAfterDispose test as OuterLoop, which it always should have been.  With all the store-creating tests marked as OuterLoop any other such machine state problem won't foul up the inner loop test results.

Fixes #9248.  This is a release-branch-only test-only change.
cc: @ellismg @joshfree @stephentoub","[release/1.0.0] Disable X509FilesystemTests on Fedora23  The innerloop debug, innerloop release, and outerloop debug runs on Fedora23 in Jenkins fail in the X509FilesystemTests with a directory permissions error. Since this does not seem to be endemic to",9309,bartonjs,corefx
9233,Remove keepallprojectreferences from system.net.http and system.net.security tests,"Private testing has shown that the surface area discrepancy between Windows / Linux has been resolved, per @stephentoub 's suspicion.  This changes removes the property which keeps tests from compiling against packages for these test libraries.

Fixes issue https://github.com/dotnet/corefx/issues/8482

/cc @stephentoub @weshaggard ","Remove keepallprojectreferences from system.net.http and system.net.security tests  Private testing has shown that the surface area discrepancy between Windows / Linux has been resolved, per @stephentoub 's suspicion.  This changes removes the property wh",9309,bartonjs,corefx
17459,"Proposal: debug information SymbolReader for Portable PDB, Linux","To support setting breakpoints on managed code by source file + line number on Linux (see dotnet/coreclr#4798 ) we need a reader of the source line information form Portable PDB. This reader should be private to SOS. We propose a managed assembly with the interface close to existing SymbolReader class in SOS (strike.cpp).

``` c#
namespace System.Diagnostics.Debug
{

    public class SymbolReader
    {

        /// <summary>
        /// Checks availability of debugging information for given assembly.
        /// </summary>
        /// <param name=""assemblyName"">file name of the assembly</param>
        /// <returns>true if debugging information is available</returns>
        public static bool LoadSymbolsForModule(string assemblyName)
        {
        }

        /// <summary>
        /// Returns method token and IL offset for given source line number.
        /// </summary>
        /// <param name=""assemblyName"">file name of the assembly</param>
        /// <param name=""fileName"">source file name</param>
        /// <param name=""lineNumber"">source line number</param>
        /// <param name=""methToken"">method token return</param>
        /// <param name=""ilOffset"">IL offset return</param>
        public static void ResolveSequencePoint(string assemblyName, string fileName, int lineNumber, out int methToken, out int ilOffset)
        {
        }
    }
}
```

We also consider implementation using basically the same technique as in symbol support helper class for mscorlib's StackTrace (see dotnet/corefx#8670)
cc @seanshpark @mikem8361 @lucenticus","Proposal: debug information SymbolReader for Portable PDB, Linux  To support setting breakpoints on managed code by source file + line number on Linux (see dotnet/coreclr#4798 ) we need a reader of the source line information form Portable PDB. This reade",9281,Dmitri-Botcharnikov,corefx
15845,Evaluate the need to shim native calls on OSX,"We have a few OSX-specific native calls that don't use shims.  From my understanding this was deemed acceptable because OSX already has a stable Application Binary Interface (ABI).

However, looking through some of these calls, I'm not completely sure this is true.  For example https://github.com/dotnet/corefx/blob/master/src/Common/src/Interop/OSX/Interop.CoreFoundation.cs#L72-L77 has :

``` C#
private static extern SafeCreateHandle CFArrayCreate(
            IntPtr allocator,
            [MarshalAs(UnmanagedType.LPArray)]
            IntPtr[] values,
            ulong numValues,
            IntPtr callbacks); 
```

Which on my Mac appears to be defined as:

``` C++
CFArrayRef CFArrayCreate(
    CFAllocatorRef allocator,
    const void **values,
    CFIndex numValues,
    const CFArrayCallbacks *callbacks);
```

And where `CFIndex` is defined as:

``` C++
#if __LLP64__
typedef signed long long CFIndex;
#else
typedef signed long CFIndex;
#endif
```

Are we guaranteed that CFIndex will always be an 8-byte integer?  What if we were on a 32-bit OSX?

We should analyze all our non-shimmed native calls on OSX and be 100% sure we will always have ABI stability, no matter the OSX system we are running on.","Evaluate the need to shim native calls on OSX  We have a few OSX-specific native calls that don't use shims.  From my understanding this was deemed acceptable because OSX already has a stable Application Binary Interface (ABI).

However, looking through",9281,Dmitri-Botcharnikov,corefx
16264,XmlElementAttributes.Remove doesn't throw on missing element,"On Desktop this method is provided by CollectionBase, which throws when it can't find the element to remove: http://referencesource.microsoft.com/#mscorlib/system/collections/collectionbase.cs,147.

The implementation in CoreFx defers to ArrayList, which does not exhibit the same exception pattern on Remove.","XmlElementAttributes.Remove doesn't throw on missing element  On Desktop this method is provided by CollectionBase, which throws when it can't find the element to remove: http://referencesource.microsoft.com/#mscorlib/system/collections/collectionbase.cs,",8328,khdang,corefx
17018,Consider XmlAnyElementAttributes to implement typed list instead of IList,"https://github.com/dotnet/corefx/pull/7765/files#r59948232","Consider XmlAnyElementAttributes to implement typed list instead of IList  https://github.com/dotnet/corefx/pull/7765/files#r59948232",8328,khdang,corefx
17190,Inconsistencies in IdnMapping on Unix and Windows,"Originally, some of these were found in dotnet/runtime#17066 and I found more inconsistencies in dotnet/corefx#8224 so its worth creating a new issue and closing the old one that diagnosed the problems as with Uri.GetComponents.
## GetAscii - uppercase ASCII chars (e.g. `A, B, C`)
- Windows behaviour: returns the uppercase chars
- Unix behaviour: returns the lowercase chars
## GetAscii - single dash (e.g. `-`)
- Windows behaviour: returns the original string
- Unix behaviour: throws an `ArgumentException`
## GetAscii - single full stop (e.g. `.`)
- Windows behaviour: throws an `ArgumentException`
- Mac OSX behaviour: throws an `ArgumentException`
- Unix behaviour: returns the original string
## GetUnicode - invalid punycode (e.g. `xn--\u1234pck`)
- Windows behaviour: returns the original string
- Unix behaviour: returns `ఽూ`

/cc @ellismg @tarekgh ","Inconsistencies in IdnMapping on Unix and Windows  Originally, some of these were found in dotnet/runtime#17066 and I found more inconsistencies in dotnet/corefx#8224 so its worth creating a new issue and closing the old one that diagnosed the problems as",8276,ericeil,corefx
17066,Uri GetComponents test fails with invalid punycode on Unix,"```
     System.Tests.UriMethodTests.GetComponents(uri: http://xn--ሴpck.com/, components: NormalizedHost, expected: ""xn--ሴpck.com"") [FAIL]
        Assert.Equal() Failure
                  ↓ (pos 0)
        Expected: xn--ሴpck.com
        Actual:   ఽూ.com
                  ↑ (pos 0)
        Stack Trace:
              at System.Tests.UriMethodTests.GetComponents(Uri uri, UriComponents components, UriFormat format, String expected)
              at System.Tests.UriMethodTests.GetComponents(Uri uri, UriComponents components, String expected)
```","Uri GetComponents test fails with invalid punycode on Unix  ```
     System.Tests.UriMethodTests.GetComponents(uri: http://xn--ሴpck.com/, components: NormalizedHost, expected: ""xn--ሴpck.com"") [FAIL]
        Assert.Equal() Failure
                  ↓ (p",8276,ericeil,corefx
17121,Expressions can be typed as open generic types,"The likes of `Expression.Default(typeof(List<>))`, `Expression.Constant(null, typeof(Dictionary<,>))` and some other expressions (though often other rules will get in the way) are allowed.

Since these represent a value of an open generic type, they aren't really meaningful.

They can have a value of null which can be used as long as it is converted to `object` and both compilation types accept `Expression.Lambda<Func‎<object>>(Expression.Default(typeof(List<>)))` as an expression that can be compiled into a delegate that returns null.

While they can be pressed into service, it seems more appropriate to prohibit them.

Factory methods that have at least one overload that takes `Type` arguments directly. Will check these off when they're either found to already prohibit such types, or fixed to do so (PRs just adding tests of already-correct behaviour marked immediately, PRs fixing behaviour upon acceptance):

- [x] `Block` (entailed in check that type is reference-assignable from type of last child expression).
- [x] `Break`
- [x] `Call` dotnet/corefx#17333
- [x] `Catch`
- [x] `Condition`
- [x] `Constant`
- [x] `Continue`
- [x] `Convert`
- [x] `ConvertChecked`
- [x] `Default`
- [x] `Dynamic` (Entailed in check that arguments match delegate method).
- [x] `Field` dotnet/corefx#16231
- [x] `GetActionType` (Exception: Has practical use here)
- [x] `GetDelegateType` (Exception: Has practical use here)
- [x] `GetFuncType` (Exception: Has practical use here)
- [x] `Goto`
- [x] `Label` dotnet/corefx#16140
- [x] `Lambda` dotnet/corefx#16233
- [x] `MakeCatchBlock`
- [x] `MakeDynamic` (Entailed in check that arguments match delegate method).
- [x] `MakeGoto`
- [x] `MakeTry` (entailed by check that type is void or that body and catch types are reference-assignable)
- [x] `MakeUnary` Waiting on dotnet/corefx#16141
- [x] `New`
- [x] `NewArrayBounds`
- [x] `NewArrayInit`
- [x] `Parameter` (byref types allowed)
- [x] `Property` dotnet/corefx#16231
- [x] `Rethrow` dotnet/corefx#16141
- [x] `Return`
- [x] `Switch` (Entailed by check that type is void or default and case types are reference-assignable)
- [x] `Throw` dotnet/corefx#16141
- [x] `TryGetActionType` (Exception: Has practical use here)
- [x] `TryGetFuncType` (Exception: Has practical use here)
- [x] `TypeAs`
- [x] `TypeEqual` dotnet/corefx#16150 (pointer types allowed; always results in `false`)
- [x] `TypeIs` dotnet/corefx#16150 (pointer types allowed; always results in `false`)
- [x] `Unbox` dotnet/corefx#16186
- [x] `Variable`

Also the following have overrides that take `MemberInfo`, which could be generic and/or be related to an open generic type. Most will block this with restrictions they place on those `MemberInfo` arguments relating to other types, but they need to be checked.

- [x] `Add` dotnet/corefx#16142
- [x] `AddAsign` dotnet/corefx#16142
- [x] `AddAsignChecked` dotnet/corefx#16142
- [x] `AddChecked` dotnet/corefx#16142
- [x] `And` dotnet/corefx#16142
- [x] `AndAlso` dotnet/corefx#16142
- [x] `AndAssign` dotnet/corefx#16142
- [ ] `Bind` dotnet/corefx#18610
- [x] `Call`
- [x] `Convert` dotnet/corefx#16437
- [x] `ConvertChecked` dotnet/corefx#16437
- [x] `Decrement` dotnet/corefx#16437
- [x] `Divide` dotnet/corefx#16142
- [x] `DivideAssign` dotnet/corefx#16142
- [x] `ElementInit`
- [x] `Equal` dotnet/corefx#16142
- [x] `ExclusiveOr` dotnet/corefx#16142
- [x] `ExclusiveOrAssign` dotnet/corefx#16142
- [x] `Field` dotnet/corefx#16231
- [x] `GreaterThan` dotnet/corefx#16142
- [x] `GreaterThanOrEqual` dotnet/corefx#16142
- [x] `Increment` dotnet/corefx#16437
- [x] `IsFalse` dotnet/corefx#16437
- [x] `IsTrue` dotnet/corefx#16437
- [x] `LeftShift` dotnet/corefx#16142
- [x] `LeftShiftAssign` dotnet/corefx#16142
- [x] `LessThan` dotnet/corefx#16142
- [x] `LessThanOrEqual` dotnet/corefx#16142
- [x] `ListBind` dotnet/corefx#18011
- [x] `ListInit` dotnet/corefx#16624
- [x] `MakeBinary` dotnet/corefx#16142
- [x] `MakeIndex`
- [x] `MakeMemberAccess`
- [x] `MakeUnary` dotnet/corefx#16437
- [x] `MemberBind` (Covered by validation added in  dotnet/corefx#18011 but also entailed by need of type to match).
- [x] `Modulo` dotnet/corefx#16142
- [x] `ModuloAssign` dotnet/corefx#16142
- [x] `Multiply` dotnet/corefx#16142
- [x] `MultiplyAssign` dotnet/corefx#16142
- [x] `MultiplyAssignChecked` dotnet/corefx#16142
- [x] `MultiplyChecked` dotnet/corefx#16142
- [x] `Negate` dotnet/corefx#16437
- [x] `NegateChecked` dotnet/corefx#16437
- [x] `New`
- [x] `Not` dotnet/corefx#16437
- [x] `NotEqual` dotnet/corefx#16142
- [x] `OnesComplement` dotnet/corefx#16437
- [x] `Or` dotnet/corefx#16142
- [x] `OrAssign` dotnet/corefx#16142
- [x] `OrElse` dotnet/corefx#16142
- [x] `PostDecrementAssign` dotnet/corefx#16437
- [x] `PostIncrementAssign` dotnet/corefx#16437
- [x] `Power` dotnet/corefx#16142
- [x] `PowerAssign` dotnet/corefx#16142
- [x] `PreDecrementAssign` dotnet/corefx#16437
- [x] `PreIncrementAssign` dotnet/corefx#16437
- [x] `Property` dotnet/corefx#16231
- [x] `RightShift` dotnet/corefx#16142
- [x] `RightShiftAssign` dotnet/corefx#16142
- [x] `Subtract` dotnet/corefx#16142
- [x] `SubtractAssign` dotnet/corefx#16142
- [x] `SubtractAssignChecked` dotnet/corefx#16142
- [x] `SubtractChecked` dotnet/corefx#16142
- [x] `Switch` dotnet/corefx#16344
- [x] `UnaryPlus` dotnet/corefx#16437","Expressions can be typed as open generic types  The likes of `Expression.Default(typeof(List<>))`, `Expression.Constant(null, typeof(Dictionary<,>))` and some other expressions (though often other rules will get in the way) are allowed.

Since these rep",8256,JonHanna,corefx
14361,FileSystemWatcher_InternalBufferSize_File test failed in CI,"FileSystemWatcher_4000_Tests.FileSystemWatcher_InternalBufferSize_File [FAIL]
        Should not observe a error event
        Stack Trace:
           d:\j\workspace\dotnet_corefx_windows_debug_prtest\src\System.IO.FileSystem.Watcher\tests\Utility\Utility.cs(100,0): at Utility.ExpectNoEvent(WaitHandle eventOccured, String eventName, Int32 timeout)
           d:\j\workspace\dotnet_corefx_windows_debug_prtest\src\System.IO.FileSystem.Watcher\tests\FileSystemWatcher.InternalBufferSize.cs(53,0): at FileSystemWatcher_4000_Tests.FileSystemWatcher_InternalBufferSize_File()
  Finished:    System.IO.FileSystem.Watcher.Tests","FileSystemWatcher_InternalBufferSize_File test failed in CI  FileSystemWatcher_4000_Tests.FileSystemWatcher_InternalBufferSize_File [FAIL]
        Should not observe a error event
        Stack Trace:
           d:\j\workspace\dotnet_corefx_windows_deb",8231,ianhays,corefx
14554,FileSystemWatcher_4000_Tests.FileSystemWatcher_IncludeSubDirectories test failing in CI,"This test has failed multiple times in the last few days:

```
MESSAGE:
Didn't observe a created event within 500ms
+++++++++++++++++++
STACK TRACE:
at Utility.ExpectEvent(WaitHandle eventOccured, String eventName, Int32 timeout) in d:\j\workspace\dotnet_corefx_windows_release\src\System.IO.FileSystem.Watcher\tests\Utility\Utility.cs:line 94 at FileSystemWatcher_4000_Tests.FileSystemWatcher_IncludeSubDirectories_Directory() in d:\j\workspace\dotnet_corefx_windows_release\src\System.IO.FileSystem.Watcher\tests\FileSystemWatcher.IncludeSubDirectories.cs:line 67
```","FileSystemWatcher_4000_Tests.FileSystemWatcher_IncludeSubDirectories test failing in CI  This test has failed multiple times in the last few days:

```
MESSAGE:
Didn't observe a created event within 500ms
+++++++++++++++++++
STACK TRACE:
at Utility",8231,ianhays,corefx
14705,Several FileSystemWatcher tests are failing on OSX,"Expected events are not being raised for at least:
- FileSystemWatcher_Changed_LastWrite_File
- FileSystemWatcher_Changed_LastWrite_Directory
- FileSystemWatcher_Created_MoveDirectory

A Debug.Assert in FindRenameChangePairedChange is also firing for the MoveDirectory test:","Several FileSystemWatcher tests are failing on OSX  Expected events are not being raised for at least:
- FileSystemWatcher_Changed_LastWrite_File
- FileSystemWatcher_Changed_LastWrite_Directory
- FileSystemWatcher_Created_MoveDirectory

A Debug.Asser",8231,ianhays,corefx
14986,FSW tests don't verify path information,"The tests are only checking that events are occurring, but not that they're for the right/expected paths.","FSW tests don't verify path information  The tests are only checking that events are occurring, but not that they're for the right/expected paths.",8231,ianhays,corefx
15190,Two FileSystemWatcher tests failing on OS X,"```
09:22:39    CreatedTests.FileSystemWatcher_Created_WatcherDoesntFollowSymLinkToFile [FAIL]
09:22:39       Didn't observe a symlink created event within 30000ms
09:22:39       Expected: True
09:22:39       Actual:   False
09:22:39       Stack Trace:
09:22:39             at Utility.ExpectEvent(WaitHandle eventOccured, String eventName, Int32 timeout)
09:22:39             at CreatedTests.FileSystemWatcher_Created_WatcherDoesntFollowSymLinkToFile()
09:22:44    MoveFileTests.Unix_File_Move_In_Nested_Directory_Triggers_Event(eventType: Changed, moveRaisesEvent: False) [FAIL]
09:22:44       Should not observe a Changed event within 500ms
09:22:44       Expected: False
09:22:44       Actual:   True
09:22:44       Stack Trace:
09:22:44             at Utility.ExpectNoEvent(WaitHandle eventOccured, String eventName, Int32 timeout)
09:22:44             at MoveFileTests.<>c__DisplayClass1.<MoveAndCheck_NestedDirectory>b__0(AutoResetEvent eventOccured, TemporaryTestDirectory ttd)
09:22:44             at Utility.TestNestedDirectoriesHelper(WatcherChangeTypes change, Action`2 action, NotifyFilters changeFilers)
09:22:44             at MoveFileTests.MoveAndCheck_NestedDirectory(WatcherChangeTypes eventType, Boolean moveRaisesEvent)
09:22:44             at MoveFileTests.Unix_File_Move_In_Nested_Directory_Triggers_Event(WatcherChangeTypes eventType, Boolean moveRaisesEvent)
```

cc: @sokket","Two FileSystemWatcher tests failing on OS X  ```
09:22:39    CreatedTests.FileSystemWatcher_Created_WatcherDoesntFollowSymLinkToFile [FAIL]
09:22:39       Didn't observe a symlink created event within 30000ms
09:22:39       Expected: True
09:22:39",8231,ianhays,corefx
15358,RenamedTests.FileSystemWatcher_Moved_NestedDirectoryRoot failed in CI,"http://dotnet-ci.cloudapp.net/job/dotnet_corefx_windows_release_prtest/4559/console

```
RenamedTests.FileSystemWatcher_Moved_NestedDirectoryRoot [FAIL]
        System.UnauthorizedAccessException : Access to the path '\\?\d:\j\workspace\dotnet_corefx_windows_release_prtest\bin\tests\Windows_NT.AnyCPU.Release\System.IO.FileSystem.Watcher.Tests\dnxcore50\FileSystemWatcher_Moved_NestedDirectoryRoot\test_root' is denied.
        Stack Trace:
              at System.IO.Win32FileSystem.RemoveDirectoryHelper(String fullPath, Boolean recursive, Boolean throwOnTopLevelDirectoryNotFound)
              at System.IO.Win32FileSystem.RemoveDirectory(String fullPath, Boolean recursive)
           d:\j\workspace\dotnet_corefx_windows_release_prtest\src\System.IO.FileSystem.Watcher\tests\Utility\TemporaryTestDirectory.cs(32,0): at TemporaryTestDirectory.Dispose()
           d:\j\workspace\dotnet_corefx_windows_release_prtest\src\System.IO.FileSystem.Watcher\tests\FileSystemWatcher.Renamed.cs(122,0): at RenamedTests.FileSystemWatcher_Moved_NestedDirectoryRoot()
```","RenamedTests.FileSystemWatcher_Moved_NestedDirectoryRoot failed in CI  http://dotnet-ci.cloudapp.net/job/dotnet_corefx_windows_release_prtest/4559/console

```
RenamedTests.FileSystemWatcher_Moved_NestedDirectoryRoot [FAIL]
        System.Unauthorized",8231,ianhays,corefx
15900,FileSystemWatcher_Changed_FileInNestedDirectory failed in CI on OpenSUSE,"http://dotnet-ci.cloudapp.net/job/dotnet_corefx/job/opensuse13.2_debug_tst_prtest/126/console

```
15:21:12    ChangedTests.FileSystemWatcher_Changed_FileInNestedDirectory [FAIL]
15:21:12       Didn't observe a nested created event within 30000ms
15:21:12       Expected: True
15:21:12       Actual:   False
15:21:12       Stack Trace:
15:21:13             at Utility.ExpectEvent(WaitHandle eventOccurred, String eventName, Int32 timeout)
15:21:13             at Utility.TestNestedDirectoriesHelper(WatcherChangeTypes change, Action`2 action, NotifyFilters changeFilers)
15:21:13             at ChangedTests.FileSystemWatcher_Changed_FileInNestedDirectory()
```","FileSystemWatcher_Changed_FileInNestedDirectory failed in CI on OpenSUSE  http://dotnet-ci.cloudapp.net/job/dotnet_corefx/job/opensuse13.2_debug_tst_prtest/126/console

```
15:21:12    ChangedTests.FileSystemWatcher_Changed_FileInNestedDirectory [FAIL]",8231,ianhays,corefx
16071,FileSystemWatcher_Moved_NestedDirectoryRootWithoutSubdirectoriesFlag failed with UnauthorizedAccessException on Windows,"http://dotnet-ci.cloudapp.net/job/dotnet_corefx/job/windows_nt_release/222/consoleFull

```
08:50:59      RenamedTests.FileSystemWatcher_Moved_NestedDirectoryRootWithoutSubdirectoriesFlag [FAIL]
08:50:59         System.UnauthorizedAccessException : Access to the path '\\?\d:\j\workspace\dotnet_corefx\windows_nt_release\bin\tests\Windows_NT.AnyCPU.Release\System.IO.FileSystem.Watcher.Tests\dnxcore50\FileSystemWatcher_Moved_NestedDirectoryRootWithoutSubdirectoriesFlag\test_root' is denied.
08:50:59         Stack Trace:
08:51:00            d:\j\workspace\dotnet_corefx\windows_nt_release\src\System.IO.FileSystem\src\System\IO\Win32FileSystem.cs(627,0): at System.IO.Win32FileSystem.RemoveDirectoryHelper(String fullPath, Boolean recursive, Boolean throwOnTopLevelDirectoryNotFound)
08:51:00            d:\j\workspace\dotnet_corefx\windows_nt_release\src\System.IO.FileSystem\src\System\IO\Win32FileSystem.cs(493,0): at System.IO.Win32FileSystem.RemoveDirectory(String fullPath, Boolean recursive)
08:51:00            d:\j\workspace\dotnet_corefx\windows_nt_release\src\System.IO.FileSystem.Watcher\tests\Utility\TemporaryTestDirectory.cs(32,0): at TemporaryTestDirectory.Dispose()
08:51:00            d:\j\workspace\dotnet_corefx\windows_nt_release\src\System.IO.FileSystem.Watcher\tests\FileSystemWatcher.Renamed.cs(166,0): at RenamedTests.FileSystemWatcher_Moved_NestedDirectoryRootWithoutSubdirectoriesFlag()
```","FileSystemWatcher_Moved_NestedDirectoryRootWithoutSubdirectoriesFlag failed with UnauthorizedAccessException on Windows  http://dotnet-ci.cloudapp.net/job/dotnet_corefx/job/windows_nt_release/222/consoleFull

```
08:50:59      RenamedTests.FileSystemWa",8231,ianhays,corefx
16417,DeletedTests.FileSystemWatcher_Deleted_Negative failed in CI,"http://dotnet-ci.cloudapp.net/job/dotnet_corefx/job/osx_release_tst_prtest/1011/console

```
13:40:44    DeletedTests.FileSystemWatcher_Deleted_Negative [FAIL]
13:40:44       Should not observe a deleted event within 500ms
13:40:44       Expected: False
13:40:44       Actual:   True
13:40:44       Stack Trace:
13:40:44             at Utility.ExpectNoEvent(WaitHandle eventOccurred, String eventName, Int32 timeout)
13:40:44             at DeletedTests.FileSystemWatcher_Deleted_Negative()
```","DeletedTests.FileSystemWatcher_Deleted_Negative failed in CI  http://dotnet-ci.cloudapp.net/job/dotnet_corefx/job/osx_release_tst_prtest/1011/console

```
13:40:44    DeletedTests.FileSystemWatcher_Deleted_Negative [FAIL]
13:40:44       Should not obs",8231,ianhays,corefx
16423,FileSystemWatcher_Created_WatcherDoesntFollowSymLinkToFolder failed on OS X and Win10,"http://dotnet-ci.cloudapp.net/job/dotnet_corefx/job/osx_release_tst_prtest/1052/console

```
23:01:41    CreatedTests.FileSystemWatcher_Created_WatcherDoesntFollowSymLinkToFolder [FAIL]
23:01:41       Didn't observe a symlink created event within 30000ms
23:01:41       Expected: True
23:01:41       Actual:   False
23:01:41       Stack Trace:
23:01:42             at Utility.ExpectEvent(WaitHandle eventOccurred, String eventName, Int32 timeout)
23:01:42             at CreatedTests.FileSystemWatcher_Created_WatcherDoesntFollowSymLinkToFolder()
```","FileSystemWatcher_Created_WatcherDoesntFollowSymLinkToFolder failed on OS X and Win10  http://dotnet-ci.cloudapp.net/job/dotnet_corefx/job/osx_release_tst_prtest/1052/console

```
23:01:41    CreatedTests.FileSystemWatcher_Created_WatcherDoesntFollowSy",8231,ianhays,corefx
16632,ChangedTests.FileSystemWatcher_Changed_PreSeededNestedStructure(includeSubdirectories: False)  fails on windows,"The ChangedTests.FileSystemWatcher_Changed_PreSeededNestedStructure(includeSubdirectories: False) test failed on Windows with System.UnauthorizedAccessException.

http://dotnet-ci.cloudapp.net/job/dotnet_corefx/job/windows_nt_release_prtest/3194/testReport/junit/(root)/ChangedTests/FileSystemWatcher_Changed_PreSeededNestedStructure_includeSubdirectories__False_/",ChangedTests.FileSystemWatcher_Changed_PreSeededNestedStructure(includeSubdirectories: False)  fails on windows  The ChangedTests.FileSystemWatcher_Changed_PreSeededNestedStructure(includeSubdirectories: False) test failed on Windows with System.Unauthori,8231,ianhays,corefx
16741,FileSystemWatcher_Changed_PreSeededNestedStructure failed in CI,"http://dotnet-ci.cloudapp.net/job/dotnet_corefx/job/windows_nt_debug_prtest/3639/consoleFull

```
13:15:04      ChangedTests.FileSystemWatcher_Changed_PreSeededNestedStructure(includeSubdirectories: False) [FAIL]
13:15:05         System.UnauthorizedAccessException : Access to the path '\\?\d:\j\workspace\windows_nt_de---06b7984d\bin\tests\Windows_NT.AnyCPU.Debug\System.IO.FileSystem.Watcher.Tests\dnxcore50\FileSystemWatcher_Changed_PreSeededNestedStructure' is denied.
13:15:05         Stack Trace:
13:15:05               at System.IO.Win32FileSystem.RemoveDirectoryHelper(String fullPath, Boolean recursive, Boolean throwOnTopLevelDirectoryNotFound)
13:15:05               at System.IO.Win32FileSystem.RemoveDirectory(String fullPath, Boolean recursive)
13:15:05            d:\j\workspace\windows_nt_de---06b7984d\src\System.IO.FileSystem.Watcher\tests\Utility\Utility.cs(60,0): at Utility.EnsureDelete(String path)
13:15:05            d:\j\workspace\windows_nt_de---06b7984d\src\System.IO.FileSystem.Watcher\tests\Utility\TemporaryTestDirectory.cs(40,0): at TemporaryTestDirectory.Dispose(Boolean disposing)
13:15:05            d:\j\workspace\windows_nt_de---06b7984d\src\System.IO.FileSystem.Watcher\tests\Utility\TemporaryTestDirectory.cs(32,0): at TemporaryTestDirectory.Dispose()
13:15:05            d:\j\workspace\windows_nt_de---06b7984d\src\System.IO.FileSystem.Watcher\tests\FileSystemWatcher.Changed.cs(192,0): at ChangedTests.FileSystemWatcher_Changed_PreSeededNestedStructure(Boolean includeSubdirectories)
```","FileSystemWatcher_Changed_PreSeededNestedStructure failed in CI  http://dotnet-ci.cloudapp.net/job/dotnet_corefx/job/windows_nt_debug_prtest/3639/consoleFull

```
13:15:04      ChangedTests.FileSystemWatcher_Changed_PreSeededNestedStructure(includeSubd",8231,ianhays,corefx
17094,FileSystemWatcher_Deleted_FileDeletedInNestedDirectory failed on Ubuntu in CI,"http://dotnet-ci.cloudapp.net/job/dotnet_corefx/job/master/job/ubuntu14.04_release_prtest/279/consoleText

```
System.IO.Tests.DeletedTests.FileSystemWatcher_Deleted_FileDeletedInNestedDirectory [FAIL]
        Didn't observe a deleted event within 30000ms
        Expected: True
        Actual:   False
        Stack Trace:
  Discovering: System.Net.Ping.Functional.Tests
              at System.IO.Tests.FileSystemWatcherTest.ExpectEvent(WaitHandle eventOccurred, String eventName, Int32 timeout)
              at System.IO.Tests.DeletedTests.FileSystemWatcher_Deleted_FileDeletedInNestedDirectory()
```","FileSystemWatcher_Deleted_FileDeletedInNestedDirectory failed on Ubuntu in CI  http://dotnet-ci.cloudapp.net/job/dotnet_corefx/job/master/job/ubuntu14.04_release_prtest/279/consoleText

```
System.IO.Tests.DeletedTests.FileSystemWatcher_Deleted_FileDel",8231,ianhays,corefx
17095,Two MoveFileTests failing on Windows OuterLoop,"> System.IO.Tests.MoveFileTests.Windows_File_Move_To_Different_Directory_Triggers_Event(eventType: Deleted, moveRaisesEvent: False)
> System.IO.Tests.MoveFileTests.Windows_File_Move_To_Different_Directory_Triggers_Event(eventType: Renamed, moveRaisesEvent: True)

http://dotnet-ci.cloudapp.net/job/dotnet_corefx/job/master/job/outerloop_windows_nt_release_prtest/1/
http://dotnet-ci.cloudapp.net/job/dotnet_corefx/job/master/job/outerloop_windows_nt_debug_prtest/3/","Two MoveFileTests failing on Windows OuterLoop  > System.IO.Tests.MoveFileTests.Windows_File_Move_To_Different_Directory_Triggers_Event(eventType: Deleted, moveRaisesEvent: False)
> System.IO.Tests.MoveFileTests.Windows_File_Move_To_Different_Directory_T",8231,ianhays,corefx
17151,System.IO.Tests.CreatedTests.FileSystemWatcher_Created_Negative is failing on OSX,"This has been failing periodically in some runs that I have looked at. For example:

http://dotnet-ci.cloudapp.net/job/dotnet_corefx/job/master/job/osx_debug_prtest/463/consoleFull
http://dotnet-ci.cloudapp.net/job/dotnet_corefx/job/master/job/osx_debug_prtest/457/testReport/junit/System.IO.Tests/CreatedTests/FileSystemWatcher_Created_Negative/
http://dotnet-ci.cloudapp.net/job/dotnet_corefx/job/master/job/osx_debug_prtest/455/testReport/junit/System.IO.Tests/CreatedTests/FileSystemWatcher_Created_Negative/","System.IO.Tests.CreatedTests.FileSystemWatcher_Created_Negative is failing on OSX  This has been failing periodically in some runs that I have looked at. For example:

http://dotnet-ci.cloudapp.net/job/dotnet_corefx/job/master/job/osx_debug_prtest/463/c",8231,ianhays,corefx
17066,Uri GetComponents test fails with invalid punycode on Unix,"```
     System.Tests.UriMethodTests.GetComponents(uri: http://xn--ሴpck.com/, components: NormalizedHost, expected: ""xn--ሴpck.com"") [FAIL]
        Assert.Equal() Failure
                  ↓ (pos 0)
        Expected: xn--ሴpck.com
        Actual:   ఽూ.com
                  ↑ (pos 0)
        Stack Trace:
              at System.Tests.UriMethodTests.GetComponents(Uri uri, UriComponents components, UriFormat format, String expected)
              at System.Tests.UriMethodTests.GetComponents(Uri uri, UriComponents components, String expected)
```","Uri GetComponents test fails with invalid punycode on Unix  ```
     System.Tests.UriMethodTests.GetComponents(uri: http://xn--ሴpck.com/, components: NormalizedHost, expected: ""xn--ሴpck.com"") [FAIL]
        Assert.Equal() Failure
                  ↓ (p",8224,hughbe,corefx
17190,Inconsistencies in IdnMapping on Unix and Windows,"Originally, some of these were found in dotnet/runtime#17066 and I found more inconsistencies in dotnet/corefx#8224 so its worth creating a new issue and closing the old one that diagnosed the problems as with Uri.GetComponents.
## GetAscii - uppercase ASCII chars (e.g. `A, B, C`)
- Windows behaviour: returns the uppercase chars
- Unix behaviour: returns the lowercase chars
## GetAscii - single dash (e.g. `-`)
- Windows behaviour: returns the original string
- Unix behaviour: throws an `ArgumentException`
## GetAscii - single full stop (e.g. `.`)
- Windows behaviour: throws an `ArgumentException`
- Mac OSX behaviour: throws an `ArgumentException`
- Unix behaviour: returns the original string
## GetUnicode - invalid punycode (e.g. `xn--\u1234pck`)
- Windows behaviour: returns the original string
- Unix behaviour: returns `ఽూ`

/cc @ellismg @tarekgh ","Inconsistencies in IdnMapping on Unix and Windows  Originally, some of these were found in dotnet/runtime#17066 and I found more inconsistencies in dotnet/corefx#8224 so its worth creating a new issue and closing the old one that diagnosed the problems as",8224,hughbe,corefx
18520,"Port some missing threading types/members (Thread, etc.)","```
M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)
M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)
M:System.Threading.Thread.AllocateDataSlot
M:System.Threading.Thread.AllocateNamedDataSlot(System.String)
P:System.Threading.Thread.ApartmentState
M:System.Threading.Thread.BeginCriticalRegion
M:System.Threading.Thread.BeginThreadAffinity
P:System.Threading.Thread.CurrentCulture
P:System.Threading.Thread.CurrentPrincipal
P:System.Threading.Thread.CurrentUICulture
M:System.Threading.Thread.EndCriticalRegion
M:System.Threading.Thread.EndThreadAffinity
P:System.Threading.Thread.ExecutionContext
M:System.Threading.Thread.FreeNamedDataSlot(System.String)
M:System.Threading.Thread.get_ApartmentState
M:System.Threading.Thread.get_CurrentCulture
M:System.Threading.Thread.get_CurrentPrincipal
M:System.Threading.Thread.get_CurrentUICulture
M:System.Threading.Thread.get_ExecutionContext
M:System.Threading.Thread.get_IsThreadPoolThread
M:System.Threading.Thread.get_Priority
M:System.Threading.Thread.GetApartmentState
M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)
M:System.Threading.Thread.GetDomain
M:System.Threading.Thread.GetDomainID
M:System.Threading.Thread.GetHashCode
M:System.Threading.Thread.GetNamedDataSlot(System.String)
P:System.Threading.Thread.IsThreadPoolThread
M:System.Threading.Thread.Join(System.TimeSpan)
M:System.Threading.Thread.MemoryBarrier
P:System.Threading.Thread.Priority
M:System.Threading.Thread.set_ApartmentState(System.Threading.ApartmentState)
M:System.Threading.Thread.set_CurrentCulture(System.Globalization.CultureInfo)
M:System.Threading.Thread.set_CurrentPrincipal(System.Security.Principal.IPrincipal)
M:System.Threading.Thread.set_CurrentUICulture(System.Globalization.CultureInfo)
M:System.Threading.Thread.set_Priority(System.Threading.ThreadPriority)
M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)
M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)
M:System.Threading.Thread.SpinWait(System.Int32)
M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)
M:System.Threading.Thread.VolatileRead(System.Byte@)
M:System.Threading.Thread.VolatileRead(System.Double@)
M:System.Threading.Thread.VolatileRead(System.Int16@)
M:System.Threading.Thread.VolatileRead(System.Int32@)
M:System.Threading.Thread.VolatileRead(System.Int64@)
M:System.Threading.Thread.VolatileRead(System.IntPtr@)
M:System.Threading.Thread.VolatileRead(System.Object@)
M:System.Threading.Thread.VolatileRead(System.SByte@)
M:System.Threading.Thread.VolatileRead(System.Single@)
M:System.Threading.Thread.VolatileRead(System.UInt16@)
M:System.Threading.Thread.VolatileRead(System.UInt32@)
M:System.Threading.Thread.VolatileRead(System.UInt64@)
M:System.Threading.Thread.VolatileRead(System.UIntPtr@)
M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)
M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)
M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)
M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)
M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)
M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)
M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)
M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)
M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)
M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)
M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)
M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)
M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)
M:System.Threading.Thread.Yield

T:System.LocalDataStoreSlot
T:System.Threading.ApartmentState
F:System.Threading.ApartmentState.MTA
F:System.Threading.ApartmentState.STA
F:System.Threading.ApartmentState.Unknown
F:System.Threading.ApartmentState.value__
T:System.Threading.ThreadPriority
F:System.Threading.ThreadPriority.AboveNormal
F:System.Threading.ThreadPriority.BelowNormal
F:System.Threading.ThreadPriority.Highest
F:System.Threading.ThreadPriority.Lowest
F:System.Threading.ThreadPriority.Normal
F:System.Threading.ThreadPriority.value__
```","Port some missing threading types/members (Thread, etc.)  ```
M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)
M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)
M:System.Threading.Thread.A",12827,kouvel,corefx
18526,"Port some missing threading types/members (Thread abort/interrupt/suspend, etc.)","```
M:System.Threading.Thread.Abort
M:System.Threading.Thread.Abort(System.Object)
M:System.Threading.Thread.DisableComObjectEagerCleanup
M:System.Threading.Thread.Interrupt
M:System.Threading.Thread.ResetAbort
M:System.Threading.Thread.Suspend
M:System.Threading.Thread.Resume
```

```
namespace System.Runtime.InteropServices {
    public static class Marshal {
        public static void CleanupUnusedObjectsInCurrentContext();
    }
}
```","Port some missing threading types/members (Thread abort/interrupt/suspend, etc.)  ```
M:System.Threading.Thread.Abort
M:System.Threading.Thread.Abort(System.Object)
M:System.Threading.Thread.DisableComObjectEagerCleanup
M:System.Threading.Thread.Inter",12827,kouvel,corefx
18292,Port T:System.Security.Cryptography.RC2xx,"Port these as they're significantly used but apply [EditorBrowsable(Never)] to discourage new use.

```
T:System.Security.Cryptography.RC2
T:System.Security.Cryptography.RC2CryptoServiceProvider
```

Usage is ~1% of tier 1.","Port T:System.Security.Cryptography.RC2xx  Port these as they're significantly used but apply [EditorBrowsable(Never)] to discourage new use.

```
T:System.Security.Cryptography.RC2
T:System.Security.Cryptography.RC2CryptoServiceProvider
```

Usage",12744,steveharter,corefx
18291,Port T:System.Security.Cryptography.DESxx,"Okayed by the crypto board as it's so heavily used but it must be [EditorBrowsable(Never)] to strongly discourage its use.

```
T:System.Security.Cryptography.DES
T:System.Security.Cryptography.DESCryptoServiceProvider
```

Usage is up to 6% of the tier 1.","Port T:System.Security.Cryptography.DESxx  Okayed by the crypto board as it's so heavily used but it must be [EditorBrowsable(Never)] to strongly discourage its use.

```
T:System.Security.Cryptography.DES
T:System.Security.Cryptography.DESCryptoServi",12744,steveharter,corefx
18834,Port System.Security.Cryptography.CipherMode.CFB and .OFB,"Add the CFB and OFB enum values to CipherMode enum. Add [BrowsableNever]. Throw NotSupportedException (or PNSE)

```
public enum CipherMode
{ 
    CBC = 1,
    ECB = 2,
    OFB = 3,
    CFB = 4,
    CTS = 5
}
```","Port System.Security.Cryptography.CipherMode.CFB and .OFB  Add the CFB and OFB enum values to CipherMode enum. Add [BrowsableNever]. Throw NotSupportedException (or PNSE)

```
public enum CipherMode
{ 
    CBC = 1,
    ECB = 2,
    OFB = 3,
    CF",12744,steveharter,corefx
14318,Add leaveOpen constructor overload for CryptoStream,"A CryptoStream always closes the wrapped stream when it is disposed. This not ideal when using a MemoryStream or when another action needs to be taken on the result.

The workarounds are manually calling `FlushFinalBlock()` and then getting the MemoryStream bytes before disposing the CryptoStream, or using a custom stream that ignores the dispose call from CryptoStream. Neither are ideal and can be avoided with a ""leaveOpen"" option.

Implementation would be the same as DeflateStream, on `Dispose()` check if leaveOpen is true and don't close the internal stream.

```
public CryptoStream(Stream stream, ICryptoTransform transform, CryptoStreamMode mode, bool leaveOpen)
```

I'm happy to do the change when System.Security.Cryptography.Encryption arrives.","Add leaveOpen constructor overload for CryptoStream  A CryptoStream always closes the wrapped stream when it is disposed. This not ideal when using a MemoryStream or when another action needs to be taken on the result.

The workarounds are manually call",12718,bartonjs,corefx
11587,LeaveOpen ctor for CryptoStream,"Resolves https://github.com/dotnet/corefx/issues/1079

cc @bartonjs ","LeaveOpen ctor for CryptoStream  Resolves https://github.com/dotnet/corefx/issues/1079

cc @bartonjs ",12718,bartonjs,corefx
18490,Investigate overriding NetworkStream.CopyToAsync,"NetworkStream doesn't override CopyToAsync, instead inheriting the base implementation that calls ReadAsync/WriteAsync in a loop.  Each ReadAsync operation in turn creates a task that wraps the internal Socket APM implementation of Receive.  Since a CopyToAsync will typically involve many receives, we should investigate overriding it to use SocketAsyncEventArgs, in order to avoid a bunch of the per iteration costs.","Investigate overriding NetworkStream.CopyToAsync  NetworkStream doesn't override CopyToAsync, instead inheriting the base implementation that calls ReadAsync/WriteAsync in a loop.  Each ReadAsync operation in turn creates a task that wraps the internal So",12664,stephentoub,corefx
18963,SocketAsyncEventArgs allocates unnecessary SafeHandles,"Every operation on a SocketAsyncEventArgs ends up allocating a SafeNativeOverlapped SafeHandle:
https://github.com/dotnet/corefx/blob/2117bae3a6c9736033e6d1659821ff3a1069920b/src/System.Net.Sockets/src/System/Net/Sockets/SocketAsyncEventArgs.Windows.cs#L160

This is adding a significant amount of overhead to networking operations that are trying to be optimized via SocketAsyncEventArgs, e.g. in a benchmark that downloads from a localhost server 100MB via ReceiveAsync calls on a SocketAsyncEventArgs instance, we end up allocating almost 20K SafeNativeOverlapped instances for over 800KB of memory!

These SafeHandles are just being stored into a field on the SocketAsyncEventArgs.  Rather than allocating a SafeHandle for each, there are a variety of options, such as making the SocketAsyncEventArgs itself finalizable, or reusing the same SafeHandle and just replacing the pointer it guards.

cc: @davidsh, @cipop, @ericeil","SocketAsyncEventArgs allocates unnecessary SafeHandles  Every operation on a SocketAsyncEventArgs ends up allocating a SafeNativeOverlapped SafeHandle:
https://github.com/dotnet/corefx/blob/2117bae3a6c9736033e6d1659821ff3a1069920b/src/System.Net.Sockets/",12664,stephentoub,corefx
