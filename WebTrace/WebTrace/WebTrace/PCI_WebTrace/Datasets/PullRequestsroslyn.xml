<PullRequests>
  <PullRequest>
    <IssueID>41847</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Features/local function attributes</Title>
    <Description>Related to #38801

All commits in this PR have been reviewed. Everything is done except:
- dotnet/csharplang#3198 has not been merged yet
- #24135 has not been fixed yet (SpeculativeSemanticModel gives attribute class instead of attribute constructor on attributes inside a method body).

I wasn't able to determine a scenario where the IDE experience was significantly harmed by the speculative GetSymbolInfo returning the attribute class rather than the attribute constructor, and it's been difficult to figure out what needs to change in order to get the right behavior, so I'd like to punt on it until after merge.</Description>
    <CreatedDate>21/02/2020</CreatedDate>
    <ClosedDate>21/02/2020</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>41847</PullRequestID>
        <IssueID>38801</IssueID>
        <Title>Test plan for "local function attributes"</Title>
        <Description>Championed issue: dotnet/csharplang#1888

- [ ] Specification checked in to `csharplang`.
- [x] attribute on declaration
- [x] attributes on declaration are emitted
- [x] attribute on return type
- [x] attributes on return type are emitted
- [x] attribute on type parameters
- [x] attributes on type parameters are emitted
- [x] attribute on parameters
- [x] attributes on parameters are emitted
- [x] Correctness of `AttributeUsage`
  - [x] On declaration and return](https://github.com/dotnet/roslyn/blob/features/local-function-attributes/src/Compilers/CSharp/Test/Semantic/Semantics/LocalFunctionTests.cs#L631)
  - [x] On parameters and type parameters
- [x] interaction with potentially ambiguous syntax?
- [ ] speculative semantic model #24135
- [x] semantic model on attribute arguments for method/return/param/type param attributes
- [x] ~~expected diagnostics when binding a local function statement in speculative semantic model~~
  - Speculative semantic models don't give diagnostics
- [x] Scrub references (skipped tests and such) referencing this issue
- [x] test `Obsolete` attribute (and related)
  - [x] Diagnostics about attributes occur in local function locations
- [x] test `Conditional` attribute
  - [x] test `Conditional` with bad target method (non-void returning)
- [x] test various nullability attributes
- [x] test `[EnumeratorCancellation]` attribute on parameter of async-iterator local function #40959
- [x] MethodImplAttribute
- [x] DllImportAttribute
- [x] `static extern` local functions
- [x] local functions with no body
- [x] ExcludeFromCodeCoverageAttribute #41129 
- [x] MarshalAsAttribute #41299
- [x] SkipLocalsInitAttribute #41183
- [x] test restricted attributes such as IsReadOnlyAttribute, IsUnmanaged, ExtensionAttribute, etc.
- [x] Caller...Attribute #41299
- [x] LanguageVersion (tests added in #38808)
  - [x] Including in parameters
- [x] Scoping inside full syntax (See LookupTests.cs)
  - [x] Scoping for attribute lists on incomplete statements https://github.com/dotnet/roslyn/pull/41379#issuecomment-585453870
- [x] Can't use locals inside attribute creation, e.g. calling other local functions, using captured variables
  - [x] Local constants should probably be valid
  - [x] Attribute argument with declaration pattern
  - [x] Attribute argument with call containing 'out var'
  - [x] Attribute constructor with `out` parameter (disallowed)
     - [x] Out to a local
     - [x] Out var
- [x] Referencing local function with ConditionalAttribute only in a "dead" condition `#if` should not produce unused warning
- [x] ConditionalAttribute should be disallowed on non-static local functions #41333

IDE:
- [x] Test interactive typing
- [x] Start with an attribute
- [x] Completion
- [x] Keyword recommendation (`extern`)

Before merge:

- [x] ConditionalAttribute disallowed on non-static local functions #41333
- [x] IDE interactive testing
- [x] [AttributeUsage](https://github.com/dotnet/roslyn/blob/features/local-function-attributes/src/Compilers/CSharp/Test/Semantic/Semantics/LocalFunctionTests.cs#L631)
- [x] Prevent regressing EndToEndTests
- [ ] Draft spec checked into proposals, awaiting validation by Neal</Description>
        <CreatedDate>23/09/2019</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>41847</PullRequestID>
        <IssueID>3198</IssueID>
        <Title>Ensure SemanticModel reports node as a default instance access rather than as a type reference, when the type reference is reclassified as such.</Title>
        <Description>Addresses DevDiv 1169533.

@VSadov, @gafter, @agocke, @jaredpar, @khyperia Please review.
</Description>
        <CreatedDate>31/05/2015</CreatedDate>
        <ClosedDate>01/06/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>41847</PullRequestID>
        <IssueID>24135</IssueID>
        <Title>Speculative semantic model produces different behavior for local functions </Title>
        <Description>See the behavior in this test:

```csharp
        [Fact]
        public void LocalFunctionAttribute()
        {
            const string text = @"
using System;
class A : Attribute {}

class C
{
    static void M()
    {
        void local&lt;[A]T&gt;() {}
    }
}";
            var tree = SyntaxFactory.ParseSyntaxTree(text);
            var comp = CreateStandardCompilation(tree);
            var model = comp.GetSemanticModel(tree);
            var a = tree.GetRoot().DescendantNodes()
                .OfType&lt;IdentifierNameSyntax&gt;().ElementAt(2);
            Assert.Equal("A", a.Identifier.Text);
            var attrInfo = model.GetSymbolInfo(a);
            var attrType = comp.GlobalNamespace.GetTypeMember("A");
            var attrCtor = attrType.GetMember(".ctor");
            Assert.Equal(attrCtor, attrInfo.Symbol);

            // Assert that this is also true for the speculative semantic model
            var newTree = SyntaxFactory.ParseSyntaxTree(text + " ");
            var m = newTree.GetRoot()
                .DescendantNodes().OfType&lt;MethodDeclarationSyntax&gt;().Single();

            Assert.True(model.TryGetSpeculativeSemanticModelForMethodBody(m.Body.SpanStart, m, out model));

            a = newTree.GetRoot().DescendantNodes().OfType&lt;IdentifierNameSyntax&gt;().ElementAt(2);
            Assert.Equal("A", a.Identifier.Text);

            // If we aren't using the right binder here, the compiler crashes going through the binder factory
            var info = model.GetSymbolInfo(a);
            Assert.Equal(attrType, info.Symbol);
        }
```

When using the regular semantic model, the symbol returned by GetSymbolInfo is the attribute constructor. When using the speculative semantic model, the type is returned instead.

The root cause of this seems to be that `TryGetSpeculativeSemanticModelForMethodBody` directly returns a MethodBody semantic model, which bypasses the `GetMemberModel` call which may be needed to retrieve a more specific model (like an Attribute or InitializerSemanticModel) that may be needed to bind pieces of local functions.</Description>
        <CreatedDate>10/01/2018</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>41847</PullRequestID>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Statements.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/BoundLocalFunctionStatement.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/UnboundLambda.cs</File>
      <File>src/Compilers/CSharp/Portable/Compiler/MethodCompiler.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/ErrorCode.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/MessageID.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/NullableWalker.cs</File>
      <File>src/Compilers/CSharp/Portable/Generated/Syntax.xml.Internal.Generated.cs</File>
      <File>src/Compilers/CSharp/Portable/Generated/Syntax.xml.Main.Generated.cs</File>
      <File>src/Compilers/CSharp/Portable/Generated/Syntax.xml.Syntax.Generated.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/AsyncRewriter/AsyncRewriter.AsyncIteratorRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/Instrumentation/DynamicAnalysisInjector.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/LambdaRewriter.Analysis.Tree.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/LambdaRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/SynthesizedClosureMethod.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/SynthesizedMethodBaseSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/LanguageParser.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/MethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/LambdaSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/LocalFunctionSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceMemberMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceMethodSymbolWithAttributes.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceOrdinaryMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/SubstitutedTypeParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/SymbolExtensions.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedIntrinsicOperatorSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedSubstitutedTypeParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Wrapped/WrappedTypeParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/BlockSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/BreakStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/CheckedStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/ContinueStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/DoStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/EmptyStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/ExpressionStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/FixedStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/ForEachStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/ForEachVariableStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/ForStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/GotoStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/IfStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/LabeledStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/LocalDeclarationStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/LocalFunctionStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/LockStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/ReturnStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/StackAllocArrayCreationExpressionSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/SwitchStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/SyntaxFactory.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/ThrowStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/TryStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/UnsafeStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/UsingStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/WhileStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/YieldStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Attributes/AttributeTests_CallerInfoAttributes.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Attributes/AttributeTests_Experimental.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Attributes/AttributeTests_MarshalAs.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Attributes/AttributeTests_Security.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Attributes/AttributeTests_Synthesized.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Attributes/AttributeTests_WellKnownAttributes.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenAsyncIteratorTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenLocalFunctionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Emit/DynamicAnalysis/DynamicInstrumentationTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/LocalFunctionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/LookupTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/NullableReferenceTypesTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/OutVarTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/DefaultInterfaceImplementationTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/Source/EventTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/Source/NullablePublicAPITests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/SymbolErrorTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Generated/Syntax.Test.xml.Generated.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/IncrementalParsing/IncrementalParsingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/LocalFunctionParsingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/ParserErrorMessageTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/RoundTrippingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/StatementAttributeParsingTests.cs</File>
      <File>src/Compilers/Core/Portable/PEWriter/MetadataWriter.cs</File>
      <File>src/Compilers/Test/Utilities/CSharp/CSharpTestBase.cs</File>
      <File>src/EditorFeatures/CSharpTest2/Recommendations/AsyncKeywordRecommenderTests.cs</File>
      <File>src/EditorFeatures/CSharpTest2/Recommendations/ExternKeywordRecommenderTests.cs</File>
      <File>src/EditorFeatures/CSharpTest2/Recommendations/IntKeywordRecommenderTests.cs</File>
      <File>src/EditorFeatures/CSharpTest2/Recommendations/ReturnKeywordRecommenderTests.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Source/ExpressionCompiler/SyntaxHelpers.cs</File>
      <File>src/Features/CSharp/Portable/Completion/KeywordRecommenders/AsyncKeywordRecommender.cs</File>
      <File>src/Features/CSharp/Portable/Completion/KeywordRecommenders/ExternKeywordRecommender.cs</File>
      <File>src/Features/CSharp/Portable/Completion/KeywordRecommenders/ReturnKeywordRecommender.cs</File>
      <File>src/Features/CSharp/Portable/Completion/KeywordRecommenders/StaticKeywordRecommender.cs</File>
      <File>src/Features/CSharp/Portable/Completion/KeywordRecommenders/UnsafeKeywordRecommender.cs</File>
      <File>src/Features/CSharp/Portable/Completion/KeywordRecommenders/VoidKeywordRecommender.cs</File>
      <File>src/Test/Utilities/Portable/Traits/CompilerFeature.cs</File>
      <File>src/Tools/Source/CompilerGeneratorTools/Source/CSharpSyntaxGenerator/SourceWriter.cs</File>
      <File>src/Workspaces/CSharp/Portable/CodeGeneration/CSharpSyntaxGenerator.cs</File>
      <File>src/Workspaces/SharedUtilitiesAndExtensions/Workspace/CSharp/Extensions/ContextQuery/CSharpSyntaxContext.cs</File>
      <File>src/Workspaces/SharedUtilitiesAndExtensions/Workspace/CSharp/Extensions/ContextQuery/SyntaxTokenExtensions.cs</File>
      <File>src/Workspaces/SharedUtilitiesAndExtensions/Workspace/CSharp/Extensions/ContextQuery/SyntaxTreeExtensions.cs</File>
      <File>src/Workspaces/SharedUtilitiesAndExtensions/Workspace/CSharp/Utilities/SyntaxKindSet.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>41845</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>No, your other left</Title>
    <Description>Fixes #41826
Fixes #40066

Fixes the bug reported very kindly by @martinstenhoff at https://github.com/dotnet/roslyn/issues/40066#issuecomment-588979537.

Fixes #41826, same bug

It would be nice to fast-track this so that we aren't corrupting folks' code. I feel this particularly because I wrote the original tests for the feature. üòÅ

/cc @CyrusNajmabadi </Description>
    <CreatedDate>21/02/2020</CreatedDate>
    <ClosedDate>25/02/2020</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>41845</PullRequestID>
        <IssueID>41826</IssueID>
        <Title>Simplify interpolation does the wrong thing 16.5.0 preview 2</Title>
        <Description>_This issue has been moved from [a ticket on Developer Community](https://developercommunity.visualstudio.com/content/problem/919342/simplify-interpolation-does-the-wrong-thing-1650-p.html)._

---
Looking at https://docs.microsoft.com/en-us/visualstudio/releases/2019/release-notes-preview#16.5.0-pre.2.0

"You can now simplify string interpolations when possible. Place your cursor on the string interpolation. Press (Ctrl+.) to trigger the Quick Actions and Refactorings menu. Select Simplify interpolation."

The example given is:
D d = new D();
var s = $"... {0.ToString("bar"). PadLeft(3)}...";
To be refactored to:
var s = $"... {0,-3:bar}...";

So Visual Studio Simply Refactoring is changing the PadLeft to a PadRight???

$"... {0.ToString("bar"). PadLeft(5)}..." =&gt; ...  bar...
$"... {0,-5:bar}..." =&gt; ... bar  ...

(Why one would use Int32.ToString(IFormatProvider) to get the string "bar" is another question)

---
### Original Comments

#### Visual Studio Feedback System on 2/16/2020, 04:17 PM: 

&lt;p&gt;We have directed your feedback to the appropriate engineering team for further evaluation. The team will review the feedback and notify you about the next steps.&lt;/p&gt;


---
### Original Solutions
(no solutions)</Description>
        <CreatedDate>20/02/2020</CreatedDate>
        <ClosedDate>25/02/2020</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>41845</PullRequestID>
        <IssueID>40066</IssueID>
        <Title>Suggestion to replace ToString at end of interpolation expression with colon and format code</Title>
        <Description>I see this now and then:

```cs
_ = $"...{foo.ToString("bar")}...";
```

The `.ToString("` and `")` spans (or maybe just the `ToString` token?) should be faded and a code fix should be available inside `.ToString("bar")` to convert to:

```cs
_ = $"...{foo:bar}...";
```

The degenerate case `.ToString()` could also have the same treatment with a code fix to entirely remove.</Description>
        <CreatedDate>29/11/2019</CreatedDate>
        <ClosedDate>18/12/2019</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>41845</PullRequestID>
        <IssueID>41826</IssueID>
        <Title>Simplify interpolation does the wrong thing 16.5.0 preview 2</Title>
        <Description>_This issue has been moved from [a ticket on Developer Community](https://developercommunity.visualstudio.com/content/problem/919342/simplify-interpolation-does-the-wrong-thing-1650-p.html)._

---
Looking at https://docs.microsoft.com/en-us/visualstudio/releases/2019/release-notes-preview#16.5.0-pre.2.0

"You can now simplify string interpolations when possible. Place your cursor on the string interpolation. Press (Ctrl+.) to trigger the Quick Actions and Refactorings menu. Select Simplify interpolation."

The example given is:
D d = new D();
var s = $"... {0.ToString("bar"). PadLeft(3)}...";
To be refactored to:
var s = $"... {0,-3:bar}...";

So Visual Studio Simply Refactoring is changing the PadLeft to a PadRight???

$"... {0.ToString("bar"). PadLeft(5)}..." =&gt; ...  bar...
$"... {0,-5:bar}..." =&gt; ... bar  ...

(Why one would use Int32.ToString(IFormatProvider) to get the string "bar" is another question)

---
### Original Comments

#### Visual Studio Feedback System on 2/16/2020, 04:17 PM: 

&lt;p&gt;We have directed your feedback to the appropriate engineering team for further evaluation. The team will review the feedback and notify you about the next steps.&lt;/p&gt;


---
### Original Solutions
(no solutions)</Description>
        <CreatedDate>20/02/2020</CreatedDate>
        <ClosedDate>25/02/2020</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>41845</PullRequestID>
      <File>src/EditorFeatures/CSharpTest/SimplifyInterpolation/SimplifyInterpolationTests.cs</File>
      <File>src/Features/Core/Portable/SimplifyInterpolation/Helpers.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>41775</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Add shared resx files to our shared projects</Title>
    <Description>Extracted from #41363
Third follow-up item from #41462

Apart from adding resx files, changes also include:
1. Moving resource strings duplicated across Workspaces and CodeStyle layer into the shared resx files
2. Source file changes to use the resource strings from the shared resx.

We should no longer require use of `#if CODE_STYLE` in the shared layer for the purpose of resource strings.</Description>
    <CreatedDate>19/02/2020</CreatedDate>
    <ClosedDate>19/02/2020</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>41775</PullRequestID>
        <IssueID>41363</IssueID>
        <Title>Port few IDE analyzers/fixers to shared layer to be enabled in CodeStyle NuGet package</Title>
        <Description>**NOTE: More than half the changed files in this PR are xlf files and majority of source file changes are just using resources from a shared resx file. Strongly recommend reviewing with GitHub filter feature to collapse all xlf file changes: [Review Link](https://github.com/dotnet/roslyn/pull/41363/files?file-filters%5B%5D=.cs&amp;file-filters%5B%5D=.csproj&amp;file-filters%5B%5D=.json&amp;file-filters%5B%5D=.projitems&amp;file-filters%5B%5D=.sln&amp;file-filters%5B%5D=.targets&amp;file-filters%5B%5D=.txt&amp;file-filters%5B%5D=.vb&amp;file-filters%5B%5D=.vbproj)**

Following analyzers/fixers have been ported to the shared layer and will get enabled in CodeStyle NuGet package:
1. **Remove unused private members (IDE0051)**: An analyzer without options.
2. **C# make struct fields writable (IDE0064)**: Another simple analyzer without options.
3. **C# convert switch statement to expression (IDE0066)**: An analyzer with a C# code style option. Also includes refactoring of options infrastructure and test framework code to support option based analyzers and corresponding unit tests.
4. **C# use implicit or explicit type style analyzers (IDE0007 and IDE0008)**: Typical code style analyzers with bunch of utility types.
5. **Remove unnecessary usings/imports (IDE0005)**: Analyzer which used some language services, and is very commonly requested analyzer for CI enforcement.
_NOTE: This analyzer works on command line only if XML document comments are enabled for the project._ This seems to be a compiler bug (https://github.com/dotnet/roslyn/issues/41640): https://github.com/dotnet/roslyn/blob/41bc8954aa449ee96a0858de5f614f8a61fa2cad/src/Compilers/CSharp/Portable/Compilation/CSharpCompilation.cs#L2116-L2118

![CodeStyleAnalyzers](https://user-images.githubusercontent.com/10605811/74381230-ed06b500-4d9f-11ea-8c6c-4b9db762d2c6.png)

https://github.com/dotnet/roslyn/issues/41462 tracks follow-up items once this PR goes in.</Description>
        <CreatedDate>03/02/2020</CreatedDate>
        <ClosedDate>20/02/2020</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>41775</PullRequestID>
        <IssueID>41462</IssueID>
        <Title>Follow up items after PR 41363</Title>
        <Description>During the design meeting discussion on https://github.com/dotnet/roslyn/pull/41363, we decided to go ahead with the current approach in the PR with the following follow-up items:

- [ ] De-dupe analyzers and code fixes in IDE Features layer and Code Style layer inside the diagnostic analyzer and code fix engines. Currently, both the copies execute and we also see duplicate diagnostics being reported.
- [ ] Remove MEF based discovery of language services. Replace it with an explicit mapping from each language service to the type implementing it. We also need to design how external clients, similar to CodeStyle, can be supported, which means we may not be able to explicitly hardcode the assembly/types that implement the language services.
- [ ] Remove duplicated resources from CodeStyle and Workspaces/Features layer with a shared resource file. Need to wait on @tmat's change that simplifies resource generation in Roslyn.sln.
- [ ] Revert changes required to get existing IDE analyzer/fixer tests working in CodeStyle layer once all the tests are switched to `Microsoft.CodeAnalysis.Testing`:
  - [ ] Test framework files linked into CodeStyle.UnitTests projects
  - [ ] IVTs added from Roslyn test utilities and Workspaces to CodeStyle.UnitTests projects
- [ ] Move all our analyzers and fixers to work completely based on `AnalyzerConfigOptions` instead of `OptionSet`. This involves adding support for creating and passing a fallback .editorconfig/AnalyzerConfigOptions from Tools Options settings into analysis context.
- [ ] Remove use of `GetDocumentOptionSetAsync` API in the shared layer, which is currently used to get fallback Workspace options. Likely the work in prior bullet item will automatically take care of this, but adding an explicit cleanup item here so we validate that.
- [ ] Remove the TODOs added for code moved to shared layer which uses very recently added compiler APIs, which are not yet available in CodeStyle layer. For example, see [this](https://github.com/dotnet/roslyn/pull/41363/files?file-filters%5B%5D=.cs&amp;file-filters%5B%5D=.csproj&amp;file-filters%5B%5D=.targets&amp;file-filters%5B%5D=.txt&amp;file-filters%5B%5D=.vb#r376532640) comment.
- [ ] Remove all the `#if CODE_STYLE` from the shared projects. All of them should be possible to remove trivially, except the ones related to public Options related types (OptionSet, IOption, CodeStyleOption, CodeStyleOptions, NotificationOptions, etc.), which are public APIs in Workspaces layer but also need by the CodeStyle analyzers which do not have access to Workspaces.
- [ ] We have lot more scope of refactoring the existing extension methods and utilities in Workspaces layer and move them down into the shared layers. There is scope even to move lot of code in WorkspaceExtensions layer that is currently used by code fixes, but not specific to Workspaces itself, to be moved down to CompilerExtensions layer. This will likely be a continuous refactoring work item.
- [ ] `CodeAction.DocumentChangeAction` is used in IDE code fixes, and was replaced with a new type `CustomCodeActions` in shared layer. Do we want to get rid of the CustomCodeActions types completely? Do we want to avoid them just in CodeStyle layer but still use them for analyzers linked into Features? Latter will introduce `#if CODE_STYLE` clutter in each code fix file, which seems undesirable.
- [ ] Cleanup the API signature for `SytnaxEditorBasedCodeFixProvider.IncludeDiagnosticDuringFixAll` as per https://github.com/dotnet/roslyn/pull/41510#discussion_r377391657
- [ ] Remove `AbstractRemoveUnnecessaryImportsDiagnosticAnalyzer.IsRegularCommentOrDocComment` and directly call into syntax facts service once it is available in shared analyzer layer.
- [ ] Consider deleting `IGeneratedCodeRecognitionService.IsGeneratedCode` and moving all existing callers to `IGeneratedCodeRecognitionService.IsGeneratedCodeAsync` 
- [ ] Rationalize use of `SyntaxGenerator.GetGenerator(document)` versus `document.GetRequiredLanguageService&lt;SyntaxGenerator&gt;()` in our code base.</Description>
        <CreatedDate>06/02/2020</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>41775</PullRequestID>
      <File>src/Workspaces/Core/Portable/CodeFixes/CodeFixContext.cs</File>
      <File>src/Workspaces/Core/Portable/CodeStyle/CodeStyleOptions.cs</File>
      <File>src/Workspaces/Core/Portable/Shared/Extensions/ISolutionExtensions.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/Solution/SolutionState.cs</File>
      <File>src/Workspaces/SharedUtilitiesAndExtensions/Compiler/CSharp/CodeStyle/CSharpCodeStyleOptions.cs</File>
      <File>src/Workspaces/SharedUtilitiesAndExtensions/Compiler/Core/Utilities/CompilerUtilities/CompilerPathUtilities.cs</File>
      <File>src/Workspaces/SharedUtilitiesAndExtensions/Compiler/Core/Utilities/CompilerUtilities/ImmutableHashMap.cs</File>
      <File>src/Workspaces/SharedUtilitiesAndExtensions/Workspace/CSharp/Extensions/SyntaxTreeExtensions.cs</File>
      <File>src/Workspaces/SharedUtilitiesAndExtensions/Workspace/Core/CodeFixes/FixAll/FixAllState.cs</File>
      <File>src/Workspaces/SharedUtilitiesAndExtensions/Workspace/Core/CodeFixes/FixAllContextHelper.cs</File>
      <File>src/Workspaces/SharedUtilitiesAndExtensions/Workspace/Core/Extensions/DocumentExtensions.cs</File>
      <File>src/Workspaces/SharedUtilitiesAndExtensions/Workspace/Core/Extensions/ISolutionExtensions.cs</File>
      <File>src/Workspaces/SharedUtilitiesAndExtensions/Workspace/Core/Extensions/ProjectExtensions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>40469</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Fixed IDE0009 suggestion in property pattern.</Title>
    <Description>Fixes #40242
Fixes #40331
`AbstractQualifyMemberAccessDiagnosticAnalyzer` doesn't correctly handle property pattern.</Description>
    <CreatedDate>18/12/2019</CreatedDate>
    <ClosedDate>14/01/2020</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>40469</PullRequestID>
        <IssueID>40242</IssueID>
        <Title>CSharpQualifyMemberAccessCodeFixProvider encountered an error</Title>
        <Description>Repro code:

```cs
protected override void OnStartup(StartupEventArgs? e)
{
               ‚Üì ctrl + . here 
    if (e is { Args: { Length: 1 } args })
    {
        var window = args[0];
        this.StartupUri = new Uri($"Windows/{window}.xaml", UriKind.Relative);
    }

    base.OnStartup(e);
}
```



```
System.InvalidCastException : Unable to cast object of type 'Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax' to type 'Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax'.
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitNameColon(NameColonSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.SyntaxReplacer.Replacer`1.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitSubpattern(SubpatternSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.SubpatternSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.SyntaxReplacer.Replacer`1.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SeparatedSyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitPropertyPatternClause(PropertyPatternClauseSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.PropertyPatternClauseSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.SyntaxReplacer.Replacer`1.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitRecursivePattern(RecursivePatternSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.RecursivePatternSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.SyntaxReplacer.Replacer`1.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitIsPatternExpression(IsPatternExpressionSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.IsPatternExpressionSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.SyntaxReplacer.Replacer`1.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitIfStatement(IfStatementSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.SyntaxReplacer.Replacer`1.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitBlock(BlockSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.SyntaxReplacer.Replacer`1.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitMethodDeclaration(MethodDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.SyntaxReplacer.Replacer`1.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitClassDeclaration(ClassDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.SyntaxReplacer.Replacer`1.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.SyntaxReplacer.Replacer`1.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitCompilationUnit(CompilationUnitSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.SyntaxReplacer.Replacer`1.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.SyntaxReplacer.Replace[TNode](SyntaxNode root,IEnumerable`1 nodes,Func`3 computeReplacementNode,IEnumerable`1 tokens,Func`3 computeReplacementToken,IEnumerable`1 trivia,Func`3 computeReplacementTrivia)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.ReplaceCore[TNode](IEnumerable`1 nodes,Func`3 computeReplacementNode,IEnumerable`1 tokens,Func`3 computeReplacementToken,IEnumerable`1 trivia,Func`3 computeReplacementTrivia)
   at Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode[TRoot](TRoot root,SyntaxNode oldNode,SyntaxNode newNode)
   at Microsoft.CodeAnalysis.CSharp.CodeGeneration.CSharpSyntaxGenerator.ReplaceNode(SyntaxNode root,SyntaxNode declaration,SyntaxNode newDeclaration)
   at Microsoft.CodeAnalysis.Editing.SyntaxEditor.ReplaceChange.Apply(SyntaxNode root,SyntaxGenerator generator)
   at Microsoft.CodeAnalysis.Editing.SyntaxEditor.GetChangedRoot()
   at async Microsoft.CodeAnalysis.CodeFixes.SyntaxEditorBasedCodeFixProvider.FixAllWithEditorAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeActions.CodeAction.GetChangedSolutionAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeActions.CodeAction.ComputeOperationsAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeActions.CodeAction.GetPreviewOperationsAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.Editor.Implementation.Suggestions.SuggestedAction.GetPreviewResultAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.Editor.Implementation.Suggestions.SuggestedActionWithNestedFlavors.&lt;&gt;c__DisplayClass11_0.&lt;GetPreviewAsync&gt;b__0(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.Extensions.IExtensionManagerExtensions.PerformFunctionAsync[T](&lt;Unknown Parameters&gt;)
   at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject)
```</Description>
        <CreatedDate>08/12/2019</CreatedDate>
        <ClosedDate>14/01/2020</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>40469</PullRequestID>
        <IssueID>40331</IssueID>
        <Title>IDE0009 mis-fires on pattern matching</Title>
        <Description>**Version Used**: 29610.145.master

**Steps to Reproduce**:

Set up a project where IDE0009 (require `this.` qualifier) is active. Then add this file:

```cs
using System;

public class C
{
    public void AdvanceTo(SequencePosition position)
    {
        if (position.GetObject() is byte[] { Length: 0 })
        {
        }
    }
}
```

[SharpLab](https://sharplab.io/#v2:EYLgHgbALANALiAlgGwD4AEBMBGAsAKAPQGYACLUgYVIG8DSHyzEA7OUgGQFMWBzOABa1SvLnADcpAL71GshiXJRSAQQAmANwCGLAMZcAKgHsAFAGUuARwCuPfQAUjAZ0RxERlqQAOz1+5YAlLTyjAyIAGakJj4ubh4AdADiYgDywABWXLpwJkGITqTAAJ5wXADaALrC3HyCIKQADNIBIaF0+KGhMh2M3VJAA===) does not effectively repro the problem because IDE0009 isn't active in SharpLab and I don't know how to turn such rules on in that environment.

**Expected Behavior**:

No warning on `Length: 0`.

**Actual Behavior**:

IDE0009 claims I need to add `this.` in front of the reference to the `Length` property on the `byte[]` object.

While playing this this, I also noticed a this infobar in VS:

&gt; 'CSharpQualifyMemberAccessCodeFixProvider' encountered an error and has been disabled.

```
System.InvalidCastException : Unable to cast object of type 'Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax' to type 'Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax'.
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitNameColon(NameColonSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.SyntaxReplacer.Replacer`1.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitSubpattern(SubpatternSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.SubpatternSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.SyntaxReplacer.Replacer`1.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SeparatedSyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitPropertyPatternClause(PropertyPatternClauseSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.PropertyPatternClauseSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.SyntaxReplacer.Replacer`1.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitRecursivePattern(RecursivePatternSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.RecursivePatternSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.SyntaxReplacer.Replacer`1.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitIsPatternExpression(IsPatternExpressionSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.IsPatternExpressionSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.SyntaxReplacer.Replacer`1.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitBinaryExpression(BinaryExpressionSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.SyntaxReplacer.Replacer`1.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitBinaryExpression(BinaryExpressionSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.SyntaxReplacer.Replacer`1.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitIfStatement(IfStatementSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.SyntaxReplacer.Replacer`1.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitBlock(BlockSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.SyntaxReplacer.Replacer`1.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitMethodDeclaration(MethodDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.SyntaxReplacer.Replacer`1.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitClassDeclaration(ClassDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.SyntaxReplacer.Replacer`1.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.SyntaxReplacer.Replacer`1.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitCompilationUnit(CompilationUnitSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.SyntaxReplacer.Replacer`1.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.SyntaxReplacer.Replace[TNode](SyntaxNode root,IEnumerable`1 nodes,Func`3 computeReplacementNode,IEnumerable`1 tokens,Func`3 computeReplacementToken,IEnumerable`1 trivia,Func`3 computeReplacementTrivia)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.ReplaceCore[TNode](IEnumerable`1 nodes,Func`3 computeReplacementNode,IEnumerable`1 tokens,Func`3 computeReplacementToken,IEnumerable`1 trivia,Func`3 computeReplacementTrivia)
   at Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode[TRoot](TRoot root,SyntaxNode oldNode,SyntaxNode newNode)
   at Microsoft.CodeAnalysis.CSharp.CodeGeneration.CSharpSyntaxGenerator.ReplaceNode(SyntaxNode root,SyntaxNode declaration,SyntaxNode newDeclaration)
   at Microsoft.CodeAnalysis.Editing.SyntaxEditor.ReplaceChange.Apply(SyntaxNode root,SyntaxGenerator generator)
   at Microsoft.CodeAnalysis.Editing.SyntaxEditor.GetChangedRoot()
   at async Microsoft.CodeAnalysis.CodeFixes.SyntaxEditorBasedCodeFixProvider.FixAllWithEditorAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeActions.CodeAction.GetChangedSolutionAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeActions.CodeAction.ComputeOperationsAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeActions.CodeAction.GetPreviewOperationsAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.Editor.Implementation.Suggestions.SuggestedAction.GetPreviewResultAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.Editor.Implementation.Suggestions.SuggestedActionWithNestedFlavors.&lt;&gt;c__DisplayClass11_0.&lt;GetPreviewAsync&gt;b__0(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.Extensions.IExtensionManagerExtensions.PerformFunctionAsync[T](&lt;Unknown Parameters&gt;)
   at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject)
```</Description>
        <CreatedDate>12/12/2019</CreatedDate>
        <ClosedDate>14/01/2020</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>40469</PullRequestID>
      <File>src/EditorFeatures/CSharpTest/QualifyMemberAccess/QualifyMemberAccessTests.cs</File>
      <File>src/Features/Core/Portable/QualifyMemberAccess/AbstractQualifyMemberAccessDiagnosticAnalyzer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>40441</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Fix for introduce local variable bugs</Title>
    <Description>Fixes #40374 and fixes #40381 and adds applicable tests.</Description>
    <CreatedDate>17/12/2019</CreatedDate>
    <ClosedDate>30/12/2019</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>40441</PullRequestID>
        <IssueID>40374</IssueID>
        <Title>Introduce local can introduce local in wrong place with local functions</Title>
        <Description>Steps to reproduce:
1. Original code:
```C#
    class Bug
    {
        void M(int i)
        {
            Local();
            var x = Foo();

            void Local()
            {
                var y = Foo();
            }
        }

        private static object Foo()
        {
            throw new NotImplementedException();
        }
    }
```

2. Highlight 'Foo()' within local function and apply code action to introduce local for all occurrences of 'Foo()'

3. Expected:
```C#
    class Bug
    {
        void M(int i)
        {
            object v = Foo();
            Local();
            var x = v;

            void Local()
            {
                var y = v;
            }
        }

        private static object Foo()
        {
            throw new NotImplementedException();
        }
    }
```
Actual:
```C#
    class Bug
    {
        void M(int i)
        {
            Local();
            object v = Foo();
            var x = v;

            void Local()
            {
                var y = v;
            }
        }

        private static object Foo()
        {
            throw new NotImplementedException();
        }
    }
```
The actual output is invalid code.

Furthermore, the following code also fails:
```C# void M()
{
    // Must put it up here, above Local()
    void Local()
    {
        int x = Foo();
    }

    // Can't put it here, even though it's before all calls to Local()
    int y = Foo();
    Local();
}
```

In short, there should be two conditions on where to place the new local declaration:
1) Before all calls to local functions that use the variable.
2) Before the local function itself.

(Thanks to @dpoeschl for originally catching this and for outlining the two conditions!)</Description>
        <CreatedDate>13/12/2019</CreatedDate>
        <ClosedDate>30/12/2019</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>40441</PullRequestID>
        <IssueID>40381</IssueID>
        <Title>Introduce local tries to introduce across static local functions</Title>
        <Description>Steps to reproduce:
1) With the following code, highlight ```Foo()``` of ``` var x = Foo();``` and apply code action to introduce local across all occurrences:

```C#
    class Bug
    {
        void M(int i)
        {
            Local();
            static void Local()
            {
                var y = Foo();
            }

            var x = Foo();
        }

        private static object Foo()
        {
            throw new NotImplementedException();
        }
    }
```
2) Expected:
```C#
    class Bug
    {
        void M(int i)
        {
            Local();
            static void Local()
            {
                var y = Foo();
            }

            var v = Foo();
            var x = v;
        }
```
3) Actual:
```C#
    class Bug
    {
        void M(int i)
        {
            Local();
            var v = Foo();

            static void Local()
            {
                var y = v;
            }

            var x = v;
        }
```
</Description>
        <CreatedDate>13/12/2019</CreatedDate>
        <ClosedDate>30/12/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>40441</PullRequestID>
      <File>src/EditorFeatures/CSharpTest/CodeActions/IntroduceVariable/IntroduceVariableTests.cs</File>
      <File>src/Features/CSharp/Portable/IntroduceVariable/CSharpIntroduceVariableService.cs</File>
      <File>src/Features/CSharp/Portable/IntroduceVariable/CSharpIntroduceVariableService_IntroduceLocal.cs</File>
      <File>src/Features/Core/Portable/IntroduceVariable/AbstractIntroduceVariableService.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>40193</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Fix a false positive in IDE0059 in presence of try/finally</Title>
    <Description>We were aggressively trimming down tracked locals when encountering a branch that leaves a try/finally region. The fix makes us more conservative for such cases.

Fixes #39344
Fixes #39755

Verified that both the added unit tests fail before the product fix.</Description>
    <CreatedDate>06/12/2019</CreatedDate>
    <ClosedDate>12/12/2019</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>40193</PullRequestID>
        <IssueID>39344</IssueID>
        <Title>IDE0059 "Remove redundant assignment" can break code logic</Title>
        <Description>**Version Used**: Version 16.4.0 Preview 3.0 [29416.158.master]

**Steps to Reproduce**:

```c#
void M(int i)
{
    bool b = false;
    try
    {
        if (i == 0)
        {
            b = true; // IDE0059 Unnecessary assignment of a value
        }
    }
    finally
    {
        if (!b)
        {
            Console.WriteLine("Exception");
        }
    }
}
```

**Expected Behavior**:

Does not remove assignment to `b`.

**Actual Behavior**:

Removes assignment to `b`.</Description>
        <CreatedDate>17/10/2019</CreatedDate>
        <ClosedDate>12/12/2019</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>40193</PullRequestID>
        <IssueID>39755</IssueID>
        <Title>Regression: false positive IDE0059 in 16.4</Title>
        <Description>**Version Used**: 
Visual Studio 16.3.8, 16.4 Preview 4.0

**Steps to Reproduce**:
```csharp
        void M()
        {
            IntPtr a = (IntPtr)1;
            try
            {
                var b = a;

                if(Some(a))
                    a = IntPtr.Zero; // here
            }
            finally
            {
                if (a != IntPtr.Zero)
                {

                }
            }
        }

        bool Some(IntPtr a) =&gt; true;
```

**Expected Behavior**:
No IDE0059 reported, in 16.3.

**Actual Behavior**:
False positive IDE0059 redundant assignment reported, in 16.4.

Only regresses when the consumptions of `b` and `if(Some(a))` are all present.</Description>
        <CreatedDate>11/11/2019</CreatedDate>
        <ClosedDate>12/12/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>40193</PullRequestID>
      <File>src/EditorFeatures/CSharpTest/RemoveUnusedParametersAndValues/RemoveUnusedValueAssignmentTests.cs</File>
      <File>src/Workspaces/Core/Portable/FlowAnalysis/SymbolUsageAnalysis/SymbolUsageAnalysis.DataFlowAnalyzer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>39450</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Enable logging of informational telemetry for analyzers/fixers/refact‚Ä¶</Title>
    <Description>‚Ä¶orings executed during Ctrl + .

If user enables informational RoslynEventSource telemetry following the steps at https://aka.ms/reportPerf, we log the execution times for each analyzer/fixer/refactorings when computing the code fixes and refactorings to show in the light bulb. This will help us identify slow analyzers/fixers/refactorings that lead to UI delays with "Gathering suggestions" dialog.



**Customer and scenario info**
**Who is impacted by this bug?**
Users seeing UI delays on Ctrl + . to bring up the light bulb cannot provide actionable performance traces.

**Bugs fixed**
Additional telemetry to help diagnose VSO [#944957](https://devdiv.visualstudio.com/DevDiv/_workitems/edit/944957) in future

**What is the customer scenario and impact of the bug?**
We are seeing UI delays in Ctrl + . code path, where users see prolonged "Gathering suggestions" dialog. This delay can be caused by any IDE or third party extension (analyzer/fixer/refactoring) that run on this code path. Currently, we do not log telemetry to aid identifying the slow extension. This change allows users to provide actionable performance data for this code path.

**What is the workaround?**
N/A

**How was the bug found?**
UI delay VSO [#944957](https://devdiv.visualstudio.com/DevDiv/_workitems/edit/944957)

**If this fix is for a regression - what had regressed, when was the regression introduced, and why was the regression originally missed?**
This is a new top UI delay for 16.3. We are adding additional telemetry to help us investigate this better in future.

**Testing**
Verified the new telemetry is indeed logged.</Description>
    <CreatedDate>22/10/2019</CreatedDate>
    <ClosedDate>25/10/2019</ClosedDate>
    <Issues />
    <Files>
      <PullRequestID>39450</PullRequestID>
      <File>src/EditorFeatures/Core/Implementation/CodeFixes/CodeFixService.cs</File>
      <File>src/Features/Core/Portable/CodeRefactorings/CodeRefactoringService.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/EngineV2/DiagnosticIncrementalAnalyzer_GetDiagnosticsForSpan.cs</File>
      <File>src/Workspaces/Core/Portable/Log/EtwLogger.cs</File>
      <File>src/Workspaces/Core/Portable/Log/FunctionId.cs</File>
      <File>src/Workspaces/Core/Portable/Log/RoslynEventSource.LogBlock.cs</File>
      <File>src/Workspaces/Core/Portable/Log/RoslynEventSource.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/Host/SyntaxTreeFactory/AbstractSyntaxTreeFactoryService.AbstractRecoverableSyntaxRoot.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>39393</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Fix switch expression conversion creates broken code due to unspecific var return</Title>
    <Description>Fixes #38771, fixes #39363 and fixes #39171

Also changed the result of an existing test that seems to result in a compiler error.</Description>
    <CreatedDate>18/10/2019</CreatedDate>
    <ClosedDate>31/12/2019</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>39393</PullRequestID>
        <IssueID>38771</IssueID>
        <Title>Switch expression conversion creates broken code due to unspecific var return</Title>
        <Description>_This issue has been moved from [a ticket on Developer Community](https://developercommunity.visualstudio.com/content/problem/725942/switch-expression-conversion-creates-broken-code-d.html)._

---
Hence the following code:

```cs
using System;

namespace ConsoleApp1
{
    interface IFruit { }
    class Apple : IFruit { }
    class Banana : IFruit { }

class Program
    {
        static void Main(string[] args)
        {
            IFruit fruit;
            switch (args[0])
            {
                case &amp;quot;apple&amp;quot;:
                    fruit = new Apple();
                    break;
                case &amp;quot;banana&amp;quot;:
                    fruit = new Banana();
                    break;
                default:
                    throw new InvalidOperationException(&amp;quot;Unknown fruit.&amp;quot;);
            }
            Console.WriteLine(fruit. ToString());
        }
    }
}
```

The switch expression conversion suggests creating the following code:
```
var fruit = (args[0]) switch // C8506 No best type was found for the switch expression.
{
    &amp;quot;apple&amp;quot; =&amp;gt; new Apple(),
    &amp;quot;banana&amp;quot; =&amp;gt; new Banana(),
    _ =&amp;gt; throw new InvalidOperationException(&amp;quot;Unknown fruit.&amp;quot;),
};
```

However, the use of `var` causes the error `No best type was found for the switch expression.` which should be `IFruit`. There is no helper to change `var` explicitly to `IFruit`. If the conversion would've taken the original declaration of `IFruit` or the nearest compatible type, there would have been no problem.
```cs
IFruit fruit = (args[0]) switch
{
    &amp;quot;apple&amp;quot; =&amp;gt; new Apple(),
    &amp;quot;banana&amp;quot; =&amp;gt; new Banana(),
    _ =&amp;gt; throw new InvalidOperationException(&amp;quot;Unknown fruit.&amp;quot;),
};
```

I don't expect helpers to create broken code; and it would be nice to have this fixed :-)

---
### Original Comments

#### Visual Studio Feedback System on 9/9/2019, 01:17 AM: 

&lt;p&gt;We have directed your feedback to the appropriate engineering team for further evaluation. The team will review the feedback and notify you about the next steps.&lt;/p&gt;


---
### Original Solutions
(no solutions)</Description>
        <CreatedDate>19/09/2019</CreatedDate>
        <ClosedDate>31/12/2019</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>39393</PullRequestID>
        <IssueID>39363</IssueID>
        <Title>IDE0047 Remove unnecessary parentheses fails to appear for switch expressions</Title>
        <Description>**Version Used**: 16.4.0 P1

**Steps to Reproduce**:
1. Have a switch expression that contains unnecessary parentheses.
2. Pull up code fixes menu.

![switchbug](https://user-images.githubusercontent.com/16968319/67036612-c88c1c00-f0d0-11e9-8f15-333bcb19aabc.png)

![switchbug2](https://user-images.githubusercontent.com/16968319/67036734-fcffd800-f0d0-11e9-80df-067aaa6700e7.png)

**Expected Behavior**: Code fix option IDE0047 appears to remove unnecessary parentheses.

**Actual Behavior**: No code fix shown. IDE0047 does appear for the local variable declaration on line 16, so this seems to be an issue specific to switch expressions.
</Description>
        <CreatedDate>17/10/2019</CreatedDate>
        <ClosedDate>31/12/2019</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>39393</PullRequestID>
        <IssueID>39171</IssueID>
        <Title>switch expression "no best type found" conflicts with IDE0007 C# use 'var' instead of explicit type</Title>
        <Description>_This issue has been moved from [a ticket on Developer Community](https://developercommunity.visualstudio.com/content/problem/759620/switch-expression-no-best-type-found-conflicts-wit.html)._

---
First of all I have a switch expression that returns instances of classes that all have a common superclass, so I would expect the switch expression to return the common superclass type instead of having a &amp;quot;no best type found&amp;quot; error.

Secondly, if I manually specify the type of the variable to put the result of the switch expression in, I get the IDE0007 suggestion.  If I follow the suggestion I'm back at the &amp;quot;no best type found&amp;quot; error.

---
### Original Comments

#### Visual Studio Feedback System on 10/7/2019, 02:19 AM: 

&lt;p&gt;We have directed your feedback to the appropriate engineering team for further evaluation. The team will review the feedback and notify you about the next steps.&lt;/p&gt;


---
### Original Solutions
(no solutions)</Description>
        <CreatedDate>09/10/2019</CreatedDate>
        <ClosedDate>31/12/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>39393</PullRequestID>
      <File>src/EditorFeatures/CSharpTest/ConvertSwitchStatementToExpression/ConvertSwitchStatementToExpressionTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/UseImplicitOrExplicitType/UseImplicitTypeTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/RemoveUnnecessaryParentheses/RemoveUnnecessaryParenthesesTests.cs</File>
      <File>src/Features/CSharp/Portable/ConvertSwitchStatementToExpression/ConvertSwitchStatementToExpressionCodeFixProvider.Rewriter.cs</File>
      <File>src/Features/CSharp/Portable/ConvertSwitchStatementToExpression/ConvertSwitchStatementToExpressionCodeFixProvider.cs</File>
      <File>src/Workspaces/CSharp/Portable/Extensions/ParenthesizedExpressionSyntaxExtensions.cs</File>
      <File>src/Workspaces/CSharp/Portable/Utilities/CSharpUseImplicitTypeHelper.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>39365</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Add test for #34921</Title>
    <Description>Adds a missing test to cover #34921 

Fixes #34921</Description>
    <CreatedDate>17/10/2019</CreatedDate>
    <ClosedDate>17/10/2019</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>39365</PullRequestID>
        <IssueID>34921</IssueID>
        <Title>Populate nullable state for struct members of interfaces and classes</Title>
        <Description>Consider the following:

```csharp
#nullable enable

interface I&lt;T&gt;
{
    T P { get; }
}

class C&lt;T&gt;
{
    internal T F = default!;
}

class Program
{
    static void F1&lt;T&gt;(I&lt;(T, T)&gt; i) where T : class?
    {
        var t = i.P;
        t.Item1.ToString(); // should warn
    }

    static void F2&lt;T&gt;(C&lt;(T, T)&gt; c) where T : class?
    {
        var t = c.F;
        t.Item1.ToString();// should warn
    }
}
```
We don't currently warn for either case.

A second repro is available here: https://sharplab.io/#v2:EYLgtghgzgLgpgJwDQBMQGoA+ABADAAmwEYBuAWACg9CiAWcigYgDsBXAG3YmHbnzmbdelStgDMhAEz4AwpQDelfMvxKVxAGyFa+AGJEAPABUAfAApiYg2aNJ8RgJQn+RB/gDuAC0R8j+EFIA/GrKihQqEfgAbhAI+BD4ALwuAHQA4nAwAKJsYIgQMAD2CGYODJEqMXHASfEpMqwICAIw5RXRsfgAxrXAKQCS8GBEKUaFAMowCACWzADmpW0qAL4hymua2nqSxuaW1rb2Ti5uXj72/kFrYe0dcQnJcCMZ2bn5RSVlaxFV+DXJEHqjWazBgAyGpG+lU6PWSfTGkxm80W31WFGWQA=

</Description>
        <CreatedDate>10/04/2019</CreatedDate>
        <ClosedDate>17/10/2019</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>39365</PullRequestID>
        <IssueID>34921</IssueID>
        <Title>Populate nullable state for struct members of interfaces and classes</Title>
        <Description>Consider the following:

```csharp
#nullable enable

interface I&lt;T&gt;
{
    T P { get; }
}

class C&lt;T&gt;
{
    internal T F = default!;
}

class Program
{
    static void F1&lt;T&gt;(I&lt;(T, T)&gt; i) where T : class?
    {
        var t = i.P;
        t.Item1.ToString(); // should warn
    }

    static void F2&lt;T&gt;(C&lt;(T, T)&gt; c) where T : class?
    {
        var t = c.F;
        t.Item1.ToString();// should warn
    }
}
```
We don't currently warn for either case.

A second repro is available here: https://sharplab.io/#v2:EYLgtghgzgLgpgJwDQBMQGoA+ABADAAmwEYBuAWACg9CiAWcigYgDsBXAG3YmHbnzmbdelStgDMhAEz4AwpQDelfMvxKVxAGyFa+AGJEAPABUAfAApiYg2aNJ8RgJQn+RB/gDuAC0R8j+EFIA/GrKihQqEfgAbhAI+BD4ALwuAHQA4nAwAKJsYIgQMAD2CGYODJEqMXHASfEpMqwICAIw5RXRsfgAxrXAKQCS8GBEKUaFAMowCACWzADmpW0qAL4hymua2nqSxuaW1rb2Ti5uXj72/kFrYe0dcQnJcCMZ2bn5RSVlaxFV+DXJEHqjWazBgAyGpG+lU6PWSfTGkxm80W31WFGWQA=

</Description>
        <CreatedDate>10/04/2019</CreatedDate>
        <ClosedDate>17/10/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>39365</PullRequestID>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/NullableReferenceTypesTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>39301</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Address issues with nullable flow analysis slot container types and changing types during inference</Title>
    <Description>Fixes #39220
Fixes #39297
Fixes #33428</Description>
    <CreatedDate>15/10/2019</CreatedDate>
    <ClosedDate>24/02/2020</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>39301</PullRequestID>
        <IssueID>39220</IssueID>
        <Title>Roslyn doesn't handle inferred nullability in the presence of `goto`.</Title>
        <Description>**Version Used**: 
```
Branch master (23 Sep 2019)
Latest commit 89b4f60 by Charles Stoner:
Allow conversion of collection initializer Add extension method this arg (#38732)
```

**Steps to Reproduce**:

Compile and run the following code:
```cs
#nullable enable
class C&lt;T&gt;
{
  public C(T t) =&gt; Property = t;
  public T Property { get; }
}

class Program
{
  static void Main()
  {
    Test("");
  }
  
  static void Test(string? s)
  {
    if (s == null) return;
    
    hell:
    var c = GetC(s);
    switch (c)
    {
      case { Property: var prop }:
        prop.ToString();
        break;
    }
    
    s = null;
    goto hell;
  }
  
  public static C&lt;T&gt; GetC&lt;T&gt;(T t) =&gt; new C&lt;T&gt;(t);
}
```

**Expected Behavior**:
`warning CS8602: Dereference of a possibly null reference.` reported for `prop.ToString()`

**Actual Behavior**:
No warnings are reported for the program above. The program crashes at runtime with a `NullReferenceException`

**Notes**
If you specify the type of `c` explicitly i.e. `C&lt;string?&gt; c = GetC(s);` you'll get the correct warning.</Description>
        <CreatedDate>10/10/2019</CreatedDate>
        <ClosedDate>24/02/2020</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>39301</PullRequestID>
        <IssueID>39297</IssueID>
        <Title>NullableWalker violates invariants of slot and slot parents</Title>
        <Description>I tried adding the following assertion

``` c#
                HashSet&lt;DiagnosticInfo&gt; discardedUseSiteDiagnostics = null;
                Debug.Assert(
                    symbol.Kind != SymbolKind.Field || // we only check fields, but the NullableWalker also works with properties
                    containingSlot == 0 &amp;&amp; !symbol.RequiresInstanceReceiver() ||
                    symbol.ContainingType.Equals(variableBySlot[containingSlot].Symbol.GetTypeOrReturnType().Type, TypeCompareKind.AllIgnoreOptions) ||
                    compilation.Conversions.IsBaseClass(variableBySlot[containingSlot].Symbol.GetTypeOrReturnType().Type, symbol.ContainingType, ref discardedUseSiteDiagnostics));
```

before the following line in `LocalDataFlowPass.cs`

``` c#
                variableBySlot[slot] = identifier;
```

but there are a number of failures (of this assertion) in `NullableWalker`.  It is possible that some of these are symptoms of https://github.com/dotnet/roslyn/issues/20648 but I believe at least the failure in `NullableReferenceTypesTests.Conversions_TupleConversions_03` and two other tests is a deeper problem.  I am skipping those tests to make progress on https://github.com/dotnet/roslyn/issues/39220, and I removing the assertion for now.  The assertion should be readded after https://github.com/dotnet/roslyn/issues/20648 has been fixed and any issues causing the assertion to fail should be reevaluated.

</Description>
        <CreatedDate>15/10/2019</CreatedDate>
        <ClosedDate>24/02/2020</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>39301</PullRequestID>
        <IssueID>33428</IssueID>
        <Title>Ensure NullableWalker.InheritNullableStateOfMember is not copying state for invalid members</Title>
        <Description>`NullableWalker.InheritNullableStateOfMember` should assert the member is valid for value and target.</Description>
        <CreatedDate>15/02/2019</CreatedDate>
        <ClosedDate>24/02/2020</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>39301</PullRequestID>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Expressions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Statements.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/DecisionDagBuilder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/Conversions/ConversionsBase.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/BoundDagEvaluation.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/CSharpCompilation.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/DefiniteAssignment.VariableIdentifier.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/LocalDataFlowPass.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/NullableWalker.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/NullableWalker_Patterns.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_Patterns.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/PatternTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/BindingAsyncTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/NameCollisionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/NullableReferenceTypesTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/OutVarTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests_Scope.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/SemanticErrorTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/SpanStackSafetyTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/TargetTypedDefaultTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>39258</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Fix SourceText.GetChanges exception on merging certain changes</Title>
    <Description>Closes #22289
Closes #26305

See #22289 for full details on the bug.

#### Summary
After certain `WithChanges` calls, `SourceText.GetChanges` is no longer able to handle the `SourceText` state and throws `ArgumentOutOfRangeException` when called.

#### Notes
- Three of the new tests are failing without my change, other tests added just in case.
- I didn't follow "Hello World" pattern in tests, sorry. I found it a bit hard to remember the offsets when using actual words.
- Not fully confident in the change even though the tests pass. The flow is quite complicated and I feel the current coverage might be insufficient.</Description>
    <CreatedDate>13/10/2019</CreatedDate>
    <ClosedDate>20/10/2019</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>39258</PullRequestID>
        <IssueID>22289</IssueID>
        <Title>ArgumentOutOfRangeException in CompletionService.GetCompletionsAsync</Title>
        <Description>**Version Used**: 
2.3.2

**Steps to Reproduce**:
Unfortunately I don't know how to isolate this. This is something I see in logs of my Roslyn-based project, and I wasn't able to reproduce it locally (however I consistently see it in logs).

I hope you might be able to guess something from the stack trace, or suggest a way to get more information about this.

Stack trace (cleaned up from Application Insights):
```
System.AggregateException: One or more errors occurred.
Microsoft.CodeAnalysis.DocumentState+&lt;GetSyntaxTreeAsync&gt;d__41.MoveNext
Microsoft.CodeAnalysis.CSharp.Completion.Providers.AttributeNamedParameterCompletionProvider+&lt;ProvideCompletionsAsync&gt;d__5.MoveNext
Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders+&lt;GetContextAsync&gt;d__31.MoveNext
Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders+&lt;ComputeNonEmptyCompletionContextsAsync&gt;d__24.MoveNext
Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders+&lt;GetCompletionsAsync&gt;d__22.MoveNext

System.AggregateException: One or more errors occurred.
Microsoft.CodeAnalysis.DocumentState+&lt;IncrementallyParseTreeAsync&gt;d__15.MoveNext

System.ArgumentOutOfRangeException: Specified argument was out of the range of valid values.
 Parameter name: start
Microsoft.CodeAnalysis.Text.TextSpan..ctor
Microsoft.CodeAnalysis.Text.ChangedText.Merge
Microsoft.CodeAnalysis.Text.ChangedText.Merge
Microsoft.CodeAnalysis.Text.ChangedText.GetChangeRanges
Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.WithChangedText
Microsoft.CodeAnalysis.DocumentState.IncrementallyParse
Microsoft.CodeAnalysis.DocumentState+&lt;IncrementallyParseTreeAsync&gt;d__15.MoveNext
```

**Expected Behavior**:
There are no exceptions from `CompletionService`.</Description>
        <CreatedDate>22/09/2017</CreatedDate>
        <ClosedDate>20/10/2019</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>39258</PullRequestID>
        <IssueID>26305</IssueID>
        <Title>ChangedText.GetTextChanges should not assert</Title>
        <Description>```csharp
[Fact]
        public void ChangedTextTests()
        {
            var text0 = SourceText.From(@"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleApp22
{
    class Class1
    {
        void Method()
        {
            Console

     
        }

    }
}");

            var text1 = text0.WithChanges(new TextChange(TextSpan.FromBounds(221, 228), ""));
            var text2 = text1.WithChanges(new TextChange(TextSpan.FromBounds(228, 229), ""));
            var text3 = text2.WithChanges(new TextChange(TextSpan.FromBounds(228, 228), "."));
            var text4 = text3.WithChanges(new TextChange(TextSpan.FromBounds(229, 229), "w"));
            var text5 = text4.WithChanges(new TextChange(TextSpan.FromBounds(230, 230), "R"));
            var text6 = text5.WithChanges(new TextChange(TextSpan.FromBounds(231, 231), "I"));
            var text7 = text6.WithChanges(new TextChange(TextSpan.FromBounds(232, 232), "T"));
            var text8 = text7.WithChanges(new TextChange(TextSpan.FromBounds(233, 233), "E"));
            var text9 = text7.WithChanges(new TextChange(TextSpan.FromBounds(231, 232), ""));

            var changes = text9.GetTextChanges(text1).ToList();
        }
```

add this test and run. then, this will assert
http://source.roslyn.io/#Microsoft.CodeAnalysis/Text/ChangedText.cs,375

this should return full file content as changed if it can't figure out text changes between 2 given SourceText.

our SourceText doesn't have concept of before or after text like editor's ITextImage (there is no prevous or next pointer in SourceText or versioning). ChangedText implementation of SourceText internally seems have that info, but that shouldn't leak out to outside.</Description>
        <CreatedDate>21/04/2018</CreatedDate>
        <ClosedDate>20/10/2019</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>39258</PullRequestID>
        <IssueID>22289</IssueID>
        <Title>ArgumentOutOfRangeException in CompletionService.GetCompletionsAsync</Title>
        <Description>**Version Used**: 
2.3.2

**Steps to Reproduce**:
Unfortunately I don't know how to isolate this. This is something I see in logs of my Roslyn-based project, and I wasn't able to reproduce it locally (however I consistently see it in logs).

I hope you might be able to guess something from the stack trace, or suggest a way to get more information about this.

Stack trace (cleaned up from Application Insights):
```
System.AggregateException: One or more errors occurred.
Microsoft.CodeAnalysis.DocumentState+&lt;GetSyntaxTreeAsync&gt;d__41.MoveNext
Microsoft.CodeAnalysis.CSharp.Completion.Providers.AttributeNamedParameterCompletionProvider+&lt;ProvideCompletionsAsync&gt;d__5.MoveNext
Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders+&lt;GetContextAsync&gt;d__31.MoveNext
Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders+&lt;ComputeNonEmptyCompletionContextsAsync&gt;d__24.MoveNext
Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders+&lt;GetCompletionsAsync&gt;d__22.MoveNext

System.AggregateException: One or more errors occurred.
Microsoft.CodeAnalysis.DocumentState+&lt;IncrementallyParseTreeAsync&gt;d__15.MoveNext

System.ArgumentOutOfRangeException: Specified argument was out of the range of valid values.
 Parameter name: start
Microsoft.CodeAnalysis.Text.TextSpan..ctor
Microsoft.CodeAnalysis.Text.ChangedText.Merge
Microsoft.CodeAnalysis.Text.ChangedText.Merge
Microsoft.CodeAnalysis.Text.ChangedText.GetChangeRanges
Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.WithChangedText
Microsoft.CodeAnalysis.DocumentState.IncrementallyParse
Microsoft.CodeAnalysis.DocumentState+&lt;IncrementallyParseTreeAsync&gt;d__15.MoveNext
```

**Expected Behavior**:
There are no exceptions from `CompletionService`.</Description>
        <CreatedDate>22/09/2017</CreatedDate>
        <ClosedDate>20/10/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>39258</PullRequestID>
      <File>src/Compilers/Core/CodeAnalysisTest/Text/TextChangeTests.cs</File>
      <File>src/Compilers/Core/Portable/Text/ChangedText.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>39249</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Generate proper nullability annotation for IEquatable.Equals</Title>
    <Description>Fixes #39243, fixes #38069

If you take the first commit (adding tests) without the second commit (implementation change), you will actually get a debug assertion failure when the name simplifier tries to simplify the generated `[AllowNull]` name:

https://github.com/dotnet/roslyn/blob/97b75fcb5807881b0e768357b82c1a3476a3ec2c/src/Compilers/CSharp/Portable/Compilation/MemberSemanticModel.cs#L157-L162

I don't know how important this is.

Since `[AllowNull]` is no longer generated when generating the Equals method, it isn't interfering with this PR.

Stack trace:

&lt;details&gt;

```
   at System.Diagnostics.Debug.Assert(Boolean condition)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetRemappedSymbols() in C:\Users\Joseph\Source\Repos\roslyn\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs:line 160
   at Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.CreateSpeculativeAttributeSemanticModel(Int32 position, AttributeSyntax attribute, Binder binder, AliasSymbol aliasOpt, NamedTypeSymbol attributeType) in C:\Users\Joseph\Source\Repos\roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs:line 746
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.TryGetSpeculativeSemanticModel(Int32 position, AttributeSyntax attribute, SemanticModel&amp; speculativeModel) in C:\Users\Joseph\Source\Repos\roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs:line 2554
   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(SemanticModel semanticModel, Int32 position, AttributeSyntax attribute, SemanticModel&amp; speculativeModel) in C:\Users\Joseph\Source\Repos\roslyn\src\Compilers\CSharp\Portable\CSharpExtensions.cs:line 1136
   at Microsoft.CodeAnalysis.CSharp.Utilities.SpeculationAnalyzer.CreateSpeculativeSemanticModelForNode(SyntaxNode nodeToSpeculate, SemanticModel semanticModel, Int32 position, Boolean isInNamespaceOrTypeContext) in C:\Users\Joseph\Source\Repos\roslyn\src\Workspaces\CSharp\Portable\Utilities\SpeculationAnalyzer.cs:line 142
   at Microsoft.CodeAnalysis.CSharp.Utilities.SpeculationAnalyzer.CreateSpeculativeSemanticModelForNode(SyntaxNode originalNode, SyntaxNode nodeToSpeculate, SemanticModel semanticModel) in C:\Users\Joseph\Source\Repos\roslyn\src\Workspaces\CSharp\Portable\Utilities\SpeculationAnalyzer.cs:line 103
   at Microsoft.CodeAnalysis.CSharp.Utilities.SpeculationAnalyzer.CreateSpeculativeSemanticModel(SyntaxNode originalNode, SyntaxNode nodeToSpeculate, SemanticModel semanticModel) in C:\Users\Joseph\Source\Repos\roslyn\src\Workspaces\CSharp\Portable\Utilities\SpeculationAnalyzer.cs:line 96
   at Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.EnsureSpeculativeSemanticModel() in C:\Users\Joseph\Source\Repos\roslyn\src\Workspaces\Core\Portable\Utilities\AbstractSpeculationAnalyzer.cs:line 185
   at Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.get_SpeculativeSemanticModel() in C:\Users\Joseph\Source\Repos\roslyn\src\Workspaces\Core\Portable\Utilities\AbstractSpeculationAnalyzer.cs:line 149
   at Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.ReplacementChangesSemantics(SyntaxNode currentOriginalNode, SyntaxNode currentReplacedNode, SyntaxNode originalRoot, Boolean skipVerificationForCurrentNode) in C:\Users\Joseph\Source\Repos\roslyn\src\Workspaces\Core\Portable\Utilities\AbstractSpeculationAnalyzer.cs:line 419
   at Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.ReplacementChangesSemantics() in C:\Users\Joseph\Source\Repos\roslyn\src\Workspaces\Core\Portable\Utilities\AbstractSpeculationAnalyzer.cs:line 408
   at Microsoft.CodeAnalysis.CSharp.Extensions.ExpressionSyntaxExtensions.CanReplaceWithReducedName(NameSyntax name, TypeSyntax reducedName, SemanticModel semanticModel, CancellationToken cancellationToken) in C:\Users\Joseph\Source\Repos\roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs:line 2218
   at Microsoft.CodeAnalysis.CSharp.Extensions.ExpressionSyntaxExtensions.TryReduce(NameSyntax name, SemanticModel semanticModel, TypeSyntax&amp; replacementNode, TextSpan&amp; issueSpan, OptionSet optionSet, CancellationToken cancellationToken) in C:\Users\Joseph\Source\Repos\roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs:line 1774
   at Microsoft.CodeAnalysis.CSharp.Extensions.ExpressionSyntaxExtensions.TryReduceExplicitName(ExpressionSyntax expression, SemanticModel semanticModel, TypeSyntax&amp; replacementNode, TextSpan&amp; issueSpan, OptionSet optionSet, CancellationToken cancellationToken) in C:\Users\Joseph\Source\Repos\roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs:line 809
   at Microsoft.CodeAnalysis.CSharp.Extensions.ExpressionSyntaxExtensions.TryReduceOrSimplifyExplicitName(ExpressionSyntax expression, SemanticModel semanticModel, ExpressionSyntax&amp; replacementNode, TextSpan&amp; issueSpan, OptionSet optionSet, CancellationToken cancellationToken) in C:\Users\Joseph\Source\Repos\roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs:line 767
   at Microsoft.CodeAnalysis.CSharp.Simplification.CSharpNameReducer.SimplifyName(SyntaxNode node, SemanticModel semanticModel, OptionSet optionSet, CancellationToken cancellationToken) in C:\Users\Joseph\Source\Repos\roslyn\src\Workspaces\CSharp\Portable\Simplification\Reducers\CSharpNameReducer.cs:line 48
   at Microsoft.CodeAnalysis.CSharp.Simplification.AbstractCSharpReducer.AbstractReductionRewriter.SimplifyNode[TNode](TNode node, SyntaxNode newNode, SyntaxNode parentNode, Func`5 simplifier) in C:\Users\Joseph\Source\Repos\roslyn\src\Workspaces\CSharp\Portable\Simplification\Reducers\AbstractCSharpReducer.AbstractReductionRewriter.cs:line 125
   at Microsoft.CodeAnalysis.CSharp.Simplification.AbstractCSharpReducer.AbstractReductionRewriter.SimplifyExpression[TExpression](TExpression expression, SyntaxNode newNode, Func`5 simplifier) in C:\Users\Joseph\Source\Repos\roslyn\src\Workspaces\CSharp\Portable\Simplification\Reducers\AbstractCSharpReducer.AbstractReductionRewriter.cs:line 149
   at Microsoft.CodeAnalysis.CSharp.Simplification.CSharpNameReducer.Rewriter.VisitAliasQualifiedName(AliasQualifiedNameSyntax node) in C:\Users\Joseph\Source\Repos\roslyn\src\Workspaces\CSharp\Portable\Simplification\Reducers\CSharpNameReducer.Rewriter.cs:line 47
   at Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor) in C:\Users\Joseph\Source\Repos\roslyn\src\Compilers\CSharp\Portable\Generated\Syntax.xml.Syntax.Generated.cs:line 429
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node) in C:\Users\Joseph\Source\Repos\roslyn\src\Compilers\CSharp\Portable\Syntax\CSharpSyntaxRewriter.cs:line 39
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitQualifiedName(QualifiedNameSyntax node) in C:\Users\Joseph\Source\Repos\roslyn\src\Compilers\CSharp\Portable\Generated\Syntax.xml.Main.Generated.cs:line 2615
   at Microsoft.CodeAnalysis.CSharp.Simplification.CSharpNameReducer.Rewriter.VisitQualifiedName(QualifiedNameSyntax node) in C:\Users\Joseph\Source\Repos\roslyn\src\Workspaces\CSharp\Portable\Simplification\Reducers\CSharpNameReducer.Rewriter.cs:line 65
   at Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor) in C:\Users\Joseph\Source\Repos\roslyn\src\Compilers\CSharp\Portable\Generated\Syntax.xml.Syntax.Generated.cs:line 155
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node) in C:\Users\Joseph\Source\Repos\roslyn\src\Compilers\CSharp\Portable\Syntax\CSharpSyntaxRewriter.cs:line 39
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitQualifiedName(QualifiedNameSyntax node) in C:\Users\Joseph\Source\Repos\roslyn\src\Compilers\CSharp\Portable\Generated\Syntax.xml.Main.Generated.cs:line 2615
   at Microsoft.CodeAnalysis.CSharp.Simplification.CSharpNameReducer.Rewriter.VisitQualifiedName(QualifiedNameSyntax node) in C:\Users\Joseph\Source\Repos\roslyn\src\Workspaces\CSharp\Portable\Simplification\Reducers\CSharpNameReducer.Rewriter.cs:line 65
   at Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor) in C:\Users\Joseph\Source\Repos\roslyn\src\Compilers\CSharp\Portable\Generated\Syntax.xml.Syntax.Generated.cs:line 155
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node) in C:\Users\Joseph\Source\Repos\roslyn\src\Compilers\CSharp\Portable\Syntax\CSharpSyntaxRewriter.cs:line 39
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitQualifiedName(QualifiedNameSyntax node) in C:\Users\Joseph\Source\Repos\roslyn\src\Compilers\CSharp\Portable\Generated\Syntax.xml.Main.Generated.cs:line 2615
   at Microsoft.CodeAnalysis.CSharp.Simplification.CSharpNameReducer.Rewriter.VisitQualifiedName(QualifiedNameSyntax node) in C:\Users\Joseph\Source\Repos\roslyn\src\Workspaces\CSharp\Portable\Simplification\Reducers\CSharpNameReducer.Rewriter.cs:line 65
   at Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor) in C:\Users\Joseph\Source\Repos\roslyn\src\Compilers\CSharp\Portable\Generated\Syntax.xml.Syntax.Generated.cs:line 155
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node) in C:\Users\Joseph\Source\Repos\roslyn\src\Compilers\CSharp\Portable\Syntax\CSharpSyntaxRewriter.cs:line 39
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitAttribute(AttributeSyntax node) in C:\Users\Joseph\Source\Repos\roslyn\src\Compilers\CSharp\Portable\Generated\Syntax.xml.Main.Generated.cs:line 3734
   at Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor) in C:\Users\Joseph\Source\Repos\roslyn\src\Compilers\CSharp\Portable\Generated\Syntax.xml.Syntax.Generated.cs:line 13507
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node) in C:\Users\Joseph\Source\Repos\roslyn\src\Compilers\CSharp\Portable\Syntax\CSharpSyntaxRewriter.cs:line 39
   at Microsoft.CodeAnalysis.CSharp.Simplification.AbstractCSharpReducer.AbstractReductionRewriter.VisitNodeOrToken(SyntaxNodeOrToken nodeOrToken, SemanticModel semanticModel, Boolean simplifyAllDescendants) in C:\Users\Joseph\Source\Repos\roslyn\src\Workspaces\CSharp\Portable\Simplification\Reducers\AbstractCSharpReducer.AbstractReductionRewriter.cs:line 188
   at Microsoft.CodeAnalysis.Simplification.AbstractSimplificationService`3.&lt;&gt;c__DisplayClass10_1.&lt;&lt;ReduceAsync&gt;b__0&gt;d.MoveNext() in C:\Users\Joseph\Source\Repos\roslyn\src\Workspaces\Core\Portable\Simplification\AbstractSimplificationService.cs:line 248
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter.GetResult()
   at Microsoft.CodeAnalysis.Simplification.AbstractSimplificationService`3.&lt;ReduceAsyncInternal&gt;d__9.MoveNext() in C:\Users\Joseph\Source\Repos\roslyn\src\Workspaces\Core\Portable\Simplification\AbstractSimplificationService.cs:line 137
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult()
   at Microsoft.CodeAnalysis.Simplification.AbstractSimplificationService`3.&lt;ReduceAsync&gt;d__8.MoveNext() in C:\Users\Joseph\Source\Repos\roslyn\src\Workspaces\Core\Portable\Simplification\AbstractSimplificationService.cs:line 76
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult()
   at Microsoft.CodeAnalysis.Simplification.Simplifier.&lt;ReduceAsync&gt;d__14.MoveNext() in C:\Users\Joseph\Source\Repos\roslyn\src\Workspaces\Core\Portable\Simplification\Simplifier.cs:line 165
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult()
   at Microsoft.CodeAnalysis.CodeActions.CodeAction.&lt;CleanupDocumentAsync&gt;d__29.MoveNext() in C:\Users\Joseph\Source\Repos\roslyn\src\Workspaces\Core\Portable\CodeActions\CodeAction.cs:line 274
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult()
   at Microsoft.CodeAnalysis.CodeActions.CodeAction.&lt;PostProcessChangesAsync&gt;d__27.MoveNext() in C:\Users\Joseph\Source\Repos\roslyn\src\Workspaces\Core\Portable\CodeActions\CodeAction.cs:line 234
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult()
   at Microsoft.CodeAnalysis.CodeActions.CodeAction.&lt;PostProcessAsync&gt;d__26.MoveNext() in C:\Users\Joseph\Source\Repos\roslyn\src\Workspaces\Core\Portable\CodeActions\CodeAction.cs:line 203
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult()
   at Microsoft.CodeAnalysis.CodeActions.CodeAction.&lt;GetOperationsCoreAsync&gt;d__16.MoveNext() in C:\Users\Joseph\Source\Repos\roslyn\src\Workspaces\Core\Portable\CodeActions\CodeAction.cs:line 89
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult()
   at Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.GenerateEqualsAndGetHashCodeFromMembersCodeRefactoringProvider.GenerateEqualsAndGetHashCodeWithDialogCodeAction.&lt;ComputeOperationsAsync&gt;d__10.MoveNext() in C:\Users\Joseph\Source\Repos\roslyn\src\Features\Core\Portable\GenerateEqualsAndGetHashCodeFromMembers\GenerateEqualsAndHashWithDialogCodeAction.cs:line 90
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult()
   at Microsoft.CodeAnalysis.CodeActions.CodeActionWithOptions.&lt;GetOperationsAsync&gt;d__1.MoveNext() in C:\Users\Joseph\Source\Repos\roslyn\src\Workspaces\Core\Portable\CodeActions\CodeActionWithOptions.cs:line 37
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult()
   at Microsoft.CodeAnalysis.CodeActions.CodeActionWithOptions.&lt;GetOperationsCoreAsync&gt;d__2.MoveNext() in C:\Users\Joseph\Source\Repos\roslyn\src\Workspaces\Core\Portable\CodeActions\CodeActionWithOptions.cs:line 51
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter`1.GetResult()
   at Microsoft.CodeAnalysis.Editor.UnitTests.CodeActions.AbstractCodeActionOrUserDiagnosticTest.&lt;VerifyActionAndGetOperationsAsync&gt;d__31.MoveNext() in C:\Users\Joseph\Source\Repos\roslyn\src\EditorFeatures\TestUtilities\CodeActions\AbstractCodeActionOrUserDiagnosticTest.cs:line 565
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter`1.GetResult()
   at Microsoft.CodeAnalysis.Editor.UnitTests.CodeActions.AbstractCodeActionOrUserDiagnosticTest.&lt;TestActionAsync&gt;d__27.MoveNext() in C:\Users\Joseph\Source\Repos\roslyn\src\EditorFeatures\TestUtilities\CodeActions\AbstractCodeActionOrUserDiagnosticTest.cs:line 404
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter`1.GetResult()
   at Microsoft.CodeAnalysis.Editor.UnitTests.CodeActions.AbstractCodeActionOrUserDiagnosticTest.&lt;TestAsync&gt;d__26.MoveNext() in C:\Users\Joseph\Source\Repos\roslyn\src\EditorFeatures\TestUtilities\CodeActions\AbstractCodeActionOrUserDiagnosticTest.cs:line 388
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
   at Microsoft.CodeAnalysis.Editor.UnitTests.CodeActions.AbstractCodeActionOrUserDiagnosticTest.&lt;TestInRegularAndScript1Async&gt;d__24.MoveNext() in C:\Users\Joseph\Source\Repos\roslyn\src\EditorFeatures\TestUtilities\CodeActions\AbstractCodeActionOrUserDiagnosticTest.cs:line 351
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
   at Microsoft.CodeAnalysis.Editor.CSharp.UnitTests.GenerateEqualsAndGetHashCodeFromMembers.GenerateEqualsAndGetHashCodeFromMembersTests.&lt;TestImplementIEquatableOnClassInNullableContextWithAnnotatedMetadata&gt;d__53.MoveNext() in C:\Users\Joseph\Source\Repos\roslyn\src\EditorFeatures\CSharpTest\GenerateFromMembers\GenerateEqualsAndGetHashCodeFromMembers\GenerateEqualsAndGetHashCodeFromMembersTests.cs:line 1762
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
```

&lt;/details&gt;</Description>
    <CreatedDate>12/10/2019</CreatedDate>
    <ClosedDate>08/11/2019</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>39249</PullRequestID>
        <IssueID>39243</IssueID>
        <Title>'Generate Equals' does not annotate Equals(T) to allow nulls and causes CS8604</Title>
        <Description>**Version Used**: 16.4p1

In .NET Core 3.0, `IEquatable.Equals` is annotated to accept a nullable parameter:

```cs
    public interface IEquatable&lt;T&gt;
    {
        bool Equals([AllowNull] T other);
    }
```

https://github.com/dotnet/coreclr/blob/v3.0.0/src/System.Private.CoreLib/shared/System/IEquatable.cs#L11

But on earlier versions of .NET Core, on .NET Standard, and on .NET Framework, in a project where NRTs are enabled, `IEquatable&lt;&gt;.Equals` does not have this attribute. The generated code in this situation is overly restrictive (**actual**):

```cs
#nullable enable

class Foo : IEquatable&lt;Foo&gt;
{
    public int Bar { get; }

    public override bool Equals(object? obj)
    {
        // CS8604 Possible null reference argument for parameter 'other' in 'bool Foo.Equals(
        // Foo other)'.
        //            ‚Üì
        return Equals(obj as Foo);
    }

    public bool Equals(Foo other)
    {
        return other != null &amp;&amp;
               Bar == other.Bar;
    }
}
```

This code should be generated for all targets:

```cs
#nullable enable

class Foo : IEquatable&lt;Foo&gt;
{
    public int Bar { get; }

    public override bool Equals(object? obj)
    {
        return Equals(obj as Foo);
    }

    public bool Equals(Foo? other)
    {
        return other != null &amp;&amp;
               Bar == other.Bar;
    }
}
```</Description>
        <CreatedDate>11/10/2019</CreatedDate>
        <ClosedDate>08/11/2019</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>39249</PullRequestID>
        <IssueID>38069</IssueID>
        <Title>Generated Equals(T) method has pointless [AllowNull] when T is a value type</Title>
        <Description>**Version Used**: Visual Studio 16.2.2

Generate equality members for:

```cs
struct Foo
{
    public int Bar { get; }
}
```

Result:

```cs
    public bool Equals([AllowNull] Foo other)
    {
        return Bar == other.Bar;
    }
```

Expected behavior: `[AllowNull]` should not be added for value types.
</Description>
        <CreatedDate>17/08/2019</CreatedDate>
        <ClosedDate>08/11/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>39249</PullRequestID>
      <File>src/EditorFeatures/CSharpTest/GenerateFromMembers/GenerateEqualsAndGetHashCodeFromMembers/GenerateEqualsAndGetHashCodeFromMembersTests.cs</File>
      <File>src/Features/Core/Portable/GenerateEqualsAndGetHashCodeFromMembers/AbstractGenerateEqualsAndGetHashCodeService.cs</File>
      <File>src/Features/Core/Portable/GenerateEqualsAndGetHashCodeFromMembers/GenerateEqualsAndGetHashCodeAction.cs</File>
      <File>src/Features/Core/Portable/GenerateEqualsAndGetHashCodeFromMembers/GenerateEqualsAndGetHashCodeFromMembersCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/GenerateEqualsAndGetHashCodeFromMembers/GenerateEqualsAndHashWithDialogCodeAction.cs</File>
      <File>src/Features/Core/Portable/GenerateEqualsAndGetHashCodeFromMembers/IGenerateEqualsAndGetHashCodeService.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/CodeGenerationSymbolFactory.cs</File>
      <File>src/Workspaces/Core/Portable/Shared/Extensions/SyntaxGeneratorExtensions_CreateEqualsMethod.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>37303</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Analyzer driver performance fixes for IDE open file analysis</Title>
    <Description>IDE analyzer host invokes [CompilationWithAnalyzers.GetAnalyzerSemanticDiagnosticsAsync](http://source.roslyn.io/#q=CompilationWithAnalyzers.GetAnalyzerSemanticDiagnosticsAsync) APIs to compute open file semantic diagnostics. This PR performs the following optimizations on this code path:
1. `AnalysisState.PerAnalyzerState`: Delay allocations of per-symbol dictionary values stored in `_pendingDeclarations` map until we actually start analyzing the first declaration for the symbol. This avoids unncessary allocation overhead on the dictionary pool from which these dictionaries are allocated.
2. `CompilationWithAnalyzers` and `AnalyzerDriver`: Ensure that we force complete partial type trees only for symbol start analyzer(s) in the original analysis scope for which diagnostics were requested. Our current logic force completed partial tree diagnostics for all analyzers if at least one of the analyzer is a symbol start analyzer, which is always true as IDE already has few symbol start analyzers.

Addresses VS Feedback performance issues [#922802](https://dev.azure.com/devdiv/DevDiv/_workitems/edit/922802) and [#922837](https://dev.azure.com/devdiv/DevDiv/_workitems/edit/922837)

**NOTE:** ~~This PR currently targets master branch, but we need to decide if this meets the current 16.3 bar as the code changes are in the compiler layer, even though the affected code path/APIs are only ever invoked during IDE open file analysis.~~ Retargeted to `features/compilerNext` based on offline discussion.</Description>
    <CreatedDate>17/07/2019</CreatedDate>
    <ClosedDate>25/07/2019</ClosedDate>
    <Issues />
    <Files>
      <PullRequestID>37303</PullRequestID>
      <File>src/Compilers/CSharp/Test/Semantic/Diagnostics/DiagnosticAnalyzerTests.cs</File>
      <File>src/Compilers/Core/Portable/DiagnosticAnalyzer/AnalysisState.PerAnalyzerState.cs</File>
      <File>src/Compilers/Core/Portable/DiagnosticAnalyzer/AnalyzerDriver.cs</File>
      <File>src/Compilers/Core/Portable/DiagnosticAnalyzer/CompilationWithAnalyzers.cs</File>
      <File>src/Test/Utilities/Portable/Diagnostics/CommonDiagnosticAnalyzers.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>37290</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Fully qualify unimported type name when in import directive</Title>
    <Description>Fix #37038
Fix #37523</Description>
    <CreatedDate>17/07/2019</CreatedDate>
    <ClosedDate>31/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>37290</PullRequestID>
        <IssueID>37038</IssueID>
        <Title>Completion for "Show items from unimported namespaces" within a using alias results in unbuildable code</Title>
        <Description>Using aliases need to full specify types used as generic arguments. "Show items from unimported namespaces" is unaware of that and attempts to add a using directive, which still results in a build error.

**Steps to Reproduce**:

``` C#
using System;

using CollectionOfStringBuilders = System.Collections.Generic.List&lt;StringBui&gt;
```

**Expected Behavior**:
``` C#
using System;

using CollectionOfStringBuilders = System.Collections.Generic.List&lt;System.Text.StringBuilder&gt;
```

**Actual Behavior**:
``` C#
using System;
using System.Text;
using CollectionOfStringBuilders = System.Collections.Generic.List&lt;StringBuilder&gt;
```

```
Severity	Code	Description	Project	File	Line	Suppression State
Error	CS0246	The type or namespace name 'StringBuilder' could not be found (are you missing a using directive or an assembly reference?)	ConsoleApp5	C:\Users\davkean\source\repos\ConsoleApp5\ConsoleApp5\Program.cs	3	Active
```

tag @genlu </Description>
        <CreatedDate>08/07/2019</CreatedDate>
        <ClosedDate>31/07/2019</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>37290</PullRequestID>
        <IssueID>37523</IssueID>
        <Title>Intellisense for using static adds an import rather than a full qualification</Title>
        <Description>**Version Used**: VS 16.3 preview 1

**Steps to Reproduce**:

![usingStatic](https://user-images.githubusercontent.com/29174528/62006252-19c1ea80-b136-11e9-814d-cd33a63ecd22.gif)

Make sure "Show Items From Unimported Namespaces" is switched on in `Tools-&gt;options-&gt;Text Editor-&gt;C#-&gt;Intellisense`

at the top of a file start typing `using static &lt;SomeType&gt;`
When intellisense shows up for `&lt;SomeType&gt;` press enter.

**Expected Behavior**:

The file now shows 
```csharp
using static &lt;SomeNamespace&gt;.&lt;SomeType&gt;
```

**Actual Behavior**:

The file now shows 
```csharp
using &lt;SomeNamespace&gt;;
using &lt;SomeType&gt;;
```
</Description>
        <CreatedDate>28/07/2019</CreatedDate>
        <ClosedDate>31/07/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>37290</PullRequestID>
      <File>src/EditorFeatures/CSharpTest/Completion/CompletionProviders/TypeImportCompletionProviderTests.cs</File>
      <File>src/Features/CSharp/Portable/Completion/CompletionProviders/ImportCompletion/TypeImportCompletionProvider.cs</File>
      <File>src/Features/CSharp/Portable/Completion/CompletionProviders/SymbolCompletionProvider.cs</File>
      <File>src/Features/Core/Portable/Completion/CompletionServiceOptions.cs</File>
      <File>src/Features/Core/Portable/Completion/Providers/ImportCompletionProvider/AbstractTypeImportCompletionProvider.cs</File>
      <File>src/Workspaces/CSharp/Portable/Extensions/ContextQuery/CSharpSyntaxContext.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>37272</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Move some ComputeRefactoringsAsync to common helpers 4/n</Title>
    <Description>Work for: #35525 and #35180

Based on (previous) PRs: #37236 (and thus subsequently on #37196)</Description>
    <CreatedDate>16/07/2019</CreatedDate>
    <ClosedDate>19/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>37272</PullRequestID>
        <IssueID>35525</IssueID>
        <Title>Improve discoverability of code refactorings</Title>
        <Description>A bunch of recent customer surveys done by @kendrahavens identified that quite a few customers find our refactorings to be not discoverable. The refactorings that they requested were already implemented by us, but they needed Kendra to point out where to put the cursor or how to change the selection span for these to show up in the light bulb menu. The same concern does not apply to code fixes due to visual cue from the squiggle/suggestion dots in the UI, and pressing Ctrl + dot anywhere on the line shows up the fix, ordering being based on the distance from the diagnostic span. Note that the primary reason why we don't show up all the refactorings available on a given line are to avoid overloading the light bulb menu, which is already quite noisy. We need to fine tune the experience here to find a balance between discoverability of actions and overloading the light bulb menu.

We have talked about adding 2 different discoverability enhancements to address these concerns:

1. **Show additional actions in light bulb menu**
Improve the discoverability of the refactorings in the light bulb, by showing additional, but likely less relevant actions, that are applicable for positions _near_ the current cursor or selection span. Most relevant refactorings would still be show at the top of the menu and these additional actions will either be shown at the bottom of the menu or nested within a separate menu towards the bottom. Internal discussions have led to bunch of different implementation suggestions on how to achieve this (discussed below), but the primary conclusion being that we need to somehow _associate a fix span/ideal span with each registered code action within a refactoring, so the engine can prioritize the ordering and/or nesting of these refactorings based on promixity of this span with current cursor position or selection span_.
Possible implementation approaches that came out:
   1. **Implementation 1**: Convert all the IDE refactorings that are not selection based into a pair of diagnostic analyzer reporting hidden diagnostics + code fix. The diagnostic span would be the ideal span for the code actions.

      PROS:
         1. All refactorings available on any position in a line show up in the light bulb, solving the discoverability concerns. 
         2. We get other useful analyzer/fixer features for free: fix all, ability to bump up the severity to see squiggles/error list entries across a wider scope, etc.

      CONS:
         1. Likely to overload the light bulb menu with lot more actions now showing up. If so, one option might be to move all the code actions registered for hidden diagnostics whose span does not intersect with current position into a nested menu near the bottom of the light bulb menu.
         2. This approach adds quite a bit of implementation cost as we need to refactor code in each code refactoring into a pair of diagnostic analyzer/code fix.

   2. **Implementation 2**: Currently, the refactoring service executes naively for identifying available actions for current cursor position or span. It passes in the entire line span or selection span into each refactoring, and then treats all registered refactorings to be on par with each other. This forces our refactorings to then be implemented in a restrictive manner, so they are not offered everywhere on the line and do not overload the light bulb menu. This whole setup relies on the assumption that users are already aware about where to put their cursor or what span to select to get the relevant refactorings, which does not seem to be true as mentioned at the start of this post. This proposal tries to remove this assumption by making the following changes:
      1. Change the code refactoring service to perform multiple passes instead of just one. It first identifies the current token/node at the position or selection span and identifies available actions. These would be the most relevant refactorings that get offered at the top level of the light bulb menu. Then the service walks up the parent node and asks available actions for the parent and siblings of previous token/node. These actions would automatically be assigned a lower priority and will be shown under a nested menu near the bottom. These additional nearby actions would serve as a discoverability point for beginner users, while also not polluting the menu for advanced users.
      2. Change all the refactorings so they only register an action if the input text span exactly matches the token/node that is most relevant to it.

     PROS:
         1. We do not alter the existing light bulb menu significantly for advanced/experienced users, while adding a new discoverability point for beginner users to discover new potential actions in nearby locations.
         2. The implementation for each refactoring is greatly simplified and unified as they only work when input span exactly matches it's fixed span.

      CONS: 
         1. We might end up with a perf hit due to the code refactoring service doing multiple passes. We would need perf measurements to identify if this indeed a concern as most refactorings would just bail out upfront. 
         2. We need to experiment/decide if a nested menu is indeed a good discoverability point as beginner users might not know that they need to dive into a nested menu at the bottom.

   3. **Implementation 3**: Allow refactorings to specify a span in [RegisterRefactoring](http://source.roslyn.io/#Microsoft.CodeAnalysis.Workspaces/CodeRefactorings/CodeRefactoringContext.cs,51) callback. This would serve as the virtual diagnostic span for the code action. We would need to change all the refactorings to then operate on all the nodes/tokens of interest in the input context span and register refactorings for each node/token with their span. The code refactoring service would be changed to prioritize refactorings whose registered span is a close match to current position/span, and show the rest of refactorings in a nested menu or towards the bottom of the menu.

     PROS: Get the similar user experience as prior approaches, with potentially lesser implementation cost then approach i. and avoid multiple passes that are needed in approach ii.

     CONS: Adds implementation complexity in each refactoring of identifying multiple nodes/tokens of interest and then register each action with a span.

   4. **Implementation 4**: Enforce common [helpers](https://github.com/dotnet/roslyn/blob/master/src/Features/Core/Portable/CodeRefactoringHelpers.cs) that each code refactoring ought to use to determine it's applicability span and bail out if that is not the case. We need to ensure we polish and/or extend the existing helpers, make them public as appropriate and audit all existing or just the problematic refactorings to ensure they are using these helpers.

2. **New UI for viewing available actions in a broader scope**: Create a separate tool window to show available code actions within a given scope (document/project/solution, with document being the default). Few open questions:
   1. Should the refactorings shown in this window be opt-in to avoid polluting it with common refactorings that show up everywhere?
   2. Should the tool window automatically be opened and brought to focus when user invokes light bulb and/or applies a code action? If not, how would we make this UI discoverable for users?
   3. Should the actions list in the window be ordered such that the actions closer to current cursor are near the top?
   We would potentially start with a simple UI, that only works for document scope to start with, and iterate on improving it to work with broader scopes.
</Description>
        <CreatedDate>06/05/2019</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>37272</PullRequestID>
        <IssueID>35180</IssueID>
        <Title>Offer codefixes on selections</Title>
        <Description>## Scenario
Codefixes often don't show if code is selected as opposed to only having your cursor placed within a word.
*  **5 out of the 11 users struggled with this in user studies.** 
* One user **only** ever double-clicked when clicking around the editor. This means he saw fewer codefixes since double clicking always selects the word and we don't show available codefixes in the context. Some users are used to double-clicking around their codebase.

## Proposal
Enable the same codefixes to appear if a block is selected as would appear if the cursor was placed inside a specific name. If this improves discoverability of codefixes we can enable this on a case-by-case basis per refactoring. My study observed more issues with the 'pull members up to base type' refactoring than others though general struggling was observed with many refactorings.

**Example: Pull members up**
Codefix offered when cursor is in the name:
![image](https://user-images.githubusercontent.com/8293542/56520118-8bb3e380-64f8-11e9-94fa-b79c60ed7ddb.png)

Codefix not offered if full line is selected:
![image](https://user-images.githubusercontent.com/8293542/56520215-bf8f0900-64f8-11e9-9022-7a5ebd464553.png)

**Example: Convert local function to method**
Offered if cursor is in name
![image](https://user-images.githubusercontent.com/8293542/56520344-0d0b7600-64f9-11e9-8fb9-6ac6d7b8de69.png)

Not offered when entire local function is selected
![image](https://user-images.githubusercontent.com/8293542/56520368-1ac0fb80-64f9-11e9-92a4-49037caea806.png)

**Example: LINQ to Foreach conversions**
![image](https://user-images.githubusercontent.com/8293542/56521136-1517e580-64fa-11e9-828a-a23aa22d8ce2.png)

If semi-colon is included in selection the conversion does not appear:
![image](https://user-images.githubusercontent.com/8293542/56521033-00d3e880-64fa-11e9-849f-2cc7a675f3ff.png)







</Description>
        <CreatedDate>22/04/2019</CreatedDate>
        <ClosedDate>06/09/2019</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>37272</PullRequestID>
        <IssueID>37236</IssueID>
        <Title>Syntax kinds service cleanup</Title>
        <Description>Based on #37196 (only last commit is new).
</Description>
        <CreatedDate>15/07/2019</CreatedDate>
        <ClosedDate>18/07/2019</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>37272</PullRequestID>
        <IssueID>37196</IssueID>
        <Title>Move some ComputeRefactoringsAsync to common helpers 3/n</Title>
        <Description>Continuation of work on #35525 and #35180</Description>
        <CreatedDate>12/07/2019</CreatedDate>
        <ClosedDate>17/07/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>37272</PullRequestID>
      <File>src/EditorFeatures/CSharpTest/ConvertForEachToFor/ConvertForEachToForTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/ConvertForToForEach/ConvertForToForEachTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/InvertIf/InvertIfTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/MoveDeclarationNearReference/MoveDeclarationNearReferenceTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/RefactoringHelpers/RefactoringHelpersTests.cs</File>
      <File>src/Features/CSharp/Portable/ConvertForEachToFor/CSharpConvertForEachToForCodeRefactoringProvider.cs</File>
      <File>src/Features/CSharp/Portable/ConvertForToForEach/CSharpConvertForToForEachCodeRefactoringProvider.cs</File>
      <File>src/Features/CSharp/Portable/InvertIf/CSharpInvertIfCodeRefactoringProvider.cs</File>
      <File>src/Features/CSharp/Portable/MoveDeclarationNearReference/CSharpMoveDeclarationNearReferenceCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/CodeRefactorings/AbstractRefactoringHelpersService.cs</File>
      <File>src/Features/Core/Portable/ConvertForEachToFor/AbstractConvertForEachToForCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/ConvertForToForEach/AbstractConvertForToForEachCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/ConvertIfToSwitch/AbstractConvertIfToSwitchCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/InvertIf/AbstractInvertIfCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/MoveDeclarationNearReference/AbstractMoveDeclarationNearReferenceCodeRefactoringProvider.cs</File>
      <File>src/Workspaces/CSharp/Portable/LanguageServices/CSharpSyntaxFactsService.cs</File>
      <File>src/Workspaces/CSharp/Portable/LanguageServices/CSharpSyntaxKindsService.cs</File>
      <File>src/Workspaces/Core/Portable/LanguageServices/SyntaxFactsService/AbstractSyntaxFactsService.cs</File>
      <File>src/Workspaces/Core/Portable/LanguageServices/SyntaxFactsService/ISyntaxFactsService.cs</File>
      <File>src/Workspaces/Core/Portable/LanguageServices/SyntaxFactsService/ISyntaxKindsService.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>37250</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Move to latest FlowAnalysis Utilities assembly</Title>
    <Description>Fixes #36643
Fixes #37065</Description>
    <CreatedDate>15/07/2019</CreatedDate>
    <ClosedDate>16/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>37250</PullRequestID>
        <IssueID>36643</IssueID>
        <Title>Questionable IDE0067 when awaiting class-member Task containing IDisposable</Title>
        <Description>**Version Used**: 
16.2.0 Preview 2.0

**Steps to Reproduce**:

```csharp
using System.IO;
using System.Threading.Tasks;

public class C
{
    private readonly Task&lt;FileStream&gt; fileStreamTask;
    public C() =&gt; fileStreamTask = Task.Run(() =&gt; File.OpenRead("")); // async resource initialization

    public async Task M()
    {
        var stream = await fileStreamTask; // IDE0067
        await stream.FlushAsync(); // more code using `stream`
    }
    // Dispose[Async]
}
```

**Expected Behavior**:
The Task holding the `IDisposable` has class scope. Disposing the contents breaks successive calls to M(). IDE0067 should not be reported.

**Actual Behavior**:
IDE0067 and a code fix that breaks the semantics.

On a side note: The cursor positions that show the code fix doesn't match the indicator: The smudge is placed under the letters `aw` of `await`, while the code fix is only available before and after the `=` and before the `a`.</Description>
        <CreatedDate>21/06/2019</CreatedDate>
        <ClosedDate>16/07/2019</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>37250</PullRequestID>
        <IssueID>37065</IssueID>
        <Title>IDE0068 Triggers invalidly for awaited disposables already in a using</Title>
        <Description>**Version Used**: VS 16.2 Preview 3

**Steps to Reproduce**:
This code will trigger IDE0068:
```c#
using (var conn = await GetConnectionAsync())
{
    return await conn.ExecuteAsync("DBCC FREEPROCCACHE (@planHandle);", new { planHandle });
}
```
Where `GetConnectionAsync()` is a `Task&lt;DbConnection&gt;`, like so:
```c#
protected Task&lt;DbConnection&gt; GetConnectionAsync() =&gt;
  Connection.GetOpenAsync(ConnectionString);
```
And at the base (simplified):
```c#
public static async Task&lt;DbConnection&gt; GetOpenAsync(string connectionString) { }
```
Inside, this opens and returns a SQL connection via `.OpenAsync()`.

**Expected Behavior**: No warning when the usage *is* disposed, at least in the first `using` case. The 2 base methods: yeah okay, we can attribute them.

**Actual Behavior**: IDE0068 is issued for all 3 methods above.

100% of the cases we're seeing this is in with `await`. I tried to minimally repro this but could not, so I reverted my suppressions and made a repro available in Opserver. If you pull [this commit](https://github.com/opserver/Opserver/commit/c859a2d61226c9e9a475eac4d3d93f5006d25e08) it should give a slew of IDE0068 warnings that haven't been refactored around yet, most around paths in the connection bits mentioned above.

Getting a connection (asynchronously) and using it elsewhere is a *very* common pattern. Can we please handle the `await` case, or perhaps disable IDE0068 for the 16.2 GA release if it can't be resolved in time?</Description>
        <CreatedDate>09/07/2019</CreatedDate>
        <ClosedDate>16/07/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>37250</PullRequestID>
      <File>src/EditorFeatures/CSharpTest/DisposeAnalysis/DisposeObjectsBeforeLosingScopeTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>37247</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Symbol equality comparer</Title>
    <Description>Implements Symbol equality with comparers:
- Adds a SymbolEqualityComparer that implements IEqualityComparer&lt;ISymbol&gt;
- Adds an overload to ISymbol that takes a comparer
- Implements various static comparers, exposing two of them as public
- Uses comparers internally to ensure dictionaries and hashsets etc work correctly
- Updates the bound tree generator to use comparers rather than equals for all symbols

This is probably easiest reviewed commit by commit. In order commited:

1. Add the overload and make TypeSymbol implement it
2. Remove internal type comparers and use symbol comparers instead
3. Fixup internal comparisons
4. Make SubstitutedMethodSmbol type compare aware
5. Make some new hashset/dictionary pools to restore potentially lost perf

---

This PR was made by flipping the default rules back to `IgnoreNullability`, and initially running tests to see what broke. I then implemented the default equals call to call with both `IgnoreNullability` and `ConsiderEverything` and added an assert for when we got a different result (we might consider a mode in the future that we can do this for debugging equality bugs).

Each usage where the default and everything rules diverged was replaced with an explicit comparison to include everything.

This PR does not include a complete change to every usage of compare (tracked in #37382), just the minimum changes required to restore compatibility without breaking any internal comparisons. Nor does it completely fix equality for all symbols that could be affected by nullability (tracked in #37383). 

Because we're restoring the code to the original, C#7.3 behavior, the only things we can break are new code targeting C# 8.0 with nullability enabled, and any analyzers that opt in to consider nullability. While not ideal, we're already shipping with nullable bugs, so it is more desirable to be bug free in the back compat case and add bugs to the new feature than the other way around.


</Description>
    <CreatedDate>15/07/2019</CreatedDate>
    <ClosedDate>24/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>37247</PullRequestID>
        <IssueID>37382</IssueID>
        <Title>Symbol Comparisons should not use default Equals</Title>
        <Description>As part of #37247 we changed the default equals to ignore nullability. 

We changed everywhere that change broke to be explicit comparisons, but in reality we should change all of the usages in our code base and obsolete `Symbol.Equals(ISymbol)` and `Symbol operator ==` to ensure every comparison is valid

Proposal was to create an analyzer and code fixer to mechanically switch all the instances over, and prevent future breaks.</Description>
        <CreatedDate>19/07/2019</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>37247</PullRequestID>
        <IssueID>37383</IssueID>
        <Title>Substituted symbols should override Equals(ISymbol, TypeComparisonKind)</Title>
        <Description>In #37247 we updated `TypeSymbol` and `SubstituedMethodSymbol` to consider the compare kind when comparing for equality.

We should additionally light up other symbol types that can change depending on their nullability, to ensure analyzers can correctly determine symbol equality.</Description>
        <CreatedDate>19/07/2019</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>37247</PullRequestID>
        <IssueID>7</IssueID>
        <Title>Feature: Parameter Name Aliasing</Title>
        <Description>The human meaning of parameters may vary from method caller's perspective.

It would be useful if the language provides an ability to assign aliases to the parameters.

``` C#
[Alias({second: [secondAndHalf, quarterToThree], first: [Initial]})] 
public static void Member1(string first, string second) { 
  // Here the user will always use the given names: first and second.
  // which means the user cannot use the param by its nickname
  // inside the method scope.
}

private static void Caller1() {
  Member1(secondAndHalf: "secondly, this is not a bad idea after all",
          Initial: "Initially it sounded moot... :)  ");
}

private static void Caller2() {
  Member1(first: "1st",
          quarterToThree: "almost there");
}

private static void Caller3() {
  Member1("one", "two");
}
```

vs. this current approach:

``` c#
public static void Member1(string first, string second) {  }

public static void Member1(string first, string secondAndHalf, string devNull = null) { 
  Member1(first, secondAndHalf);
}
```

Note: the parameter `devNull` may violate [CA1026](http://msdn.microsoft.com/en-us/library/ms182135.aspx), in case of `overridden` methods. On the flip side, setting `devNull` as non-default parameter would yield "unused parameter".

Related / Real world example: https://github.com/madskristensen/WebEssentials2013/pull/380#issuecomment-31402391
</Description>
        <CreatedDate>15/01/2015</CreatedDate>
        <ClosedDate>26/08/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>37247</PullRequestID>
      <File>src/Compilers/CSharp/Portable/Binder/Imports.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/SwitchExpressionBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/BoundDecisionDag.cs</File>
      <File>src/Compilers/CSharp/Portable/Compiler/ClsComplianceChecker.cs</File>
      <File>src/Compilers/CSharp/Portable/Emitter/Model/SymbolAdapter.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/DefiniteAssignment.VariableIdentifier.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/EmptyStructTypeCache.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/NullableWalker.PlaceholderLocal.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/NullableWalker.cs</File>
      <File>src/Compilers/CSharp/Portable/Generated/BoundNodes.xml.Generated.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/AliasSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/AnonymousTypes/SynthesizedSymbols/AnonymousType.PropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ArrayTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/DiscardSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/EventSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/MemberSignatureComparer.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/MissingAssemblySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/MissingModuleSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/MissingNamespaceSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/NamedTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/PreprocessingSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/PropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/RangeVariableSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ReducedExtensionMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/SignatureOnlyParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/LambdaSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/LocalFunctionSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceLabelSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceLocalSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceNamedTypeSymbol_Bases.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceParameterSymbolBase.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/SubstitutedFieldSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/SubstitutedMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/SubstitutedParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Symbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedIntrinsicOperatorSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/SynthesizedNamespaceSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Tuples/TupleErrorFieldSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Tuples/TupleEventSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Tuples/TupleFieldSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Tuples/TupleMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Tuples/TupleParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Tuples/TuplePropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/TypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/TypeSymbolExtensions.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTupleTest.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/NullableReferenceTypesTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/SymbolDisplay/SymbolDisplayTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/SymbolEqualityTests.cs</File>
      <File>src/Compilers/Core/Portable/InternalUtilities/MultiDictionary.cs</File>
      <File>src/Compilers/Core/Portable/InternalUtilities/SpecializedCollections.Symbol.cs</File>
      <File>src/Compilers/Core/Portable/MetadataReader/MetadataDecoder.cs</File>
      <File>src/Compilers/Core/Portable/Symbols/ISymbol.cs</File>
      <File>src/Compilers/Core/Portable/Symbols/ISymbolInternal.cs</File>
      <File>src/Compilers/Core/Portable/Symbols/SymbolEqualityComparer.cs</File>
      <File>src/Dependencies/PooledObjects/PooledDictionary.cs</File>
      <File>src/Dependencies/PooledObjects/PooledHashSet.cs</File>
      <File>src/Features/Core/Portable/MetadataAsSource/AbstractMetadataAsSourceService.AbstractWrappedSymbol.cs</File>
      <File>src/Tools/Source/CompilerGeneratorTools/Source/BoundTreeGenerator/BoundNodeClassWriter.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/Symbols/CodeGenerationSymbol.cs</File>
      <File>src/Workspaces/Core/Portable/Utilities/NullableHelpers/TypeSymbolWithNullableAnnotation.cs</File>
      <File>src/Workspaces/CoreTest/ReferencedSymbolTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>37196</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Move some ComputeRefactoringsAsync to common helpers 3/n</Title>
    <Description>Continuation of work on #35525 and #35180</Description>
    <CreatedDate>12/07/2019</CreatedDate>
    <ClosedDate>17/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>37196</PullRequestID>
        <IssueID>35525</IssueID>
        <Title>Improve discoverability of code refactorings</Title>
        <Description>A bunch of recent customer surveys done by @kendrahavens identified that quite a few customers find our refactorings to be not discoverable. The refactorings that they requested were already implemented by us, but they needed Kendra to point out where to put the cursor or how to change the selection span for these to show up in the light bulb menu. The same concern does not apply to code fixes due to visual cue from the squiggle/suggestion dots in the UI, and pressing Ctrl + dot anywhere on the line shows up the fix, ordering being based on the distance from the diagnostic span. Note that the primary reason why we don't show up all the refactorings available on a given line are to avoid overloading the light bulb menu, which is already quite noisy. We need to fine tune the experience here to find a balance between discoverability of actions and overloading the light bulb menu.

We have talked about adding 2 different discoverability enhancements to address these concerns:

1. **Show additional actions in light bulb menu**
Improve the discoverability of the refactorings in the light bulb, by showing additional, but likely less relevant actions, that are applicable for positions _near_ the current cursor or selection span. Most relevant refactorings would still be show at the top of the menu and these additional actions will either be shown at the bottom of the menu or nested within a separate menu towards the bottom. Internal discussions have led to bunch of different implementation suggestions on how to achieve this (discussed below), but the primary conclusion being that we need to somehow _associate a fix span/ideal span with each registered code action within a refactoring, so the engine can prioritize the ordering and/or nesting of these refactorings based on promixity of this span with current cursor position or selection span_.
Possible implementation approaches that came out:
   1. **Implementation 1**: Convert all the IDE refactorings that are not selection based into a pair of diagnostic analyzer reporting hidden diagnostics + code fix. The diagnostic span would be the ideal span for the code actions.

      PROS:
         1. All refactorings available on any position in a line show up in the light bulb, solving the discoverability concerns. 
         2. We get other useful analyzer/fixer features for free: fix all, ability to bump up the severity to see squiggles/error list entries across a wider scope, etc.

      CONS:
         1. Likely to overload the light bulb menu with lot more actions now showing up. If so, one option might be to move all the code actions registered for hidden diagnostics whose span does not intersect with current position into a nested menu near the bottom of the light bulb menu.
         2. This approach adds quite a bit of implementation cost as we need to refactor code in each code refactoring into a pair of diagnostic analyzer/code fix.

   2. **Implementation 2**: Currently, the refactoring service executes naively for identifying available actions for current cursor position or span. It passes in the entire line span or selection span into each refactoring, and then treats all registered refactorings to be on par with each other. This forces our refactorings to then be implemented in a restrictive manner, so they are not offered everywhere on the line and do not overload the light bulb menu. This whole setup relies on the assumption that users are already aware about where to put their cursor or what span to select to get the relevant refactorings, which does not seem to be true as mentioned at the start of this post. This proposal tries to remove this assumption by making the following changes:
      1. Change the code refactoring service to perform multiple passes instead of just one. It first identifies the current token/node at the position or selection span and identifies available actions. These would be the most relevant refactorings that get offered at the top level of the light bulb menu. Then the service walks up the parent node and asks available actions for the parent and siblings of previous token/node. These actions would automatically be assigned a lower priority and will be shown under a nested menu near the bottom. These additional nearby actions would serve as a discoverability point for beginner users, while also not polluting the menu for advanced users.
      2. Change all the refactorings so they only register an action if the input text span exactly matches the token/node that is most relevant to it.

     PROS:
         1. We do not alter the existing light bulb menu significantly for advanced/experienced users, while adding a new discoverability point for beginner users to discover new potential actions in nearby locations.
         2. The implementation for each refactoring is greatly simplified and unified as they only work when input span exactly matches it's fixed span.

      CONS: 
         1. We might end up with a perf hit due to the code refactoring service doing multiple passes. We would need perf measurements to identify if this indeed a concern as most refactorings would just bail out upfront. 
         2. We need to experiment/decide if a nested menu is indeed a good discoverability point as beginner users might not know that they need to dive into a nested menu at the bottom.

   3. **Implementation 3**: Allow refactorings to specify a span in [RegisterRefactoring](http://source.roslyn.io/#Microsoft.CodeAnalysis.Workspaces/CodeRefactorings/CodeRefactoringContext.cs,51) callback. This would serve as the virtual diagnostic span for the code action. We would need to change all the refactorings to then operate on all the nodes/tokens of interest in the input context span and register refactorings for each node/token with their span. The code refactoring service would be changed to prioritize refactorings whose registered span is a close match to current position/span, and show the rest of refactorings in a nested menu or towards the bottom of the menu.

     PROS: Get the similar user experience as prior approaches, with potentially lesser implementation cost then approach i. and avoid multiple passes that are needed in approach ii.

     CONS: Adds implementation complexity in each refactoring of identifying multiple nodes/tokens of interest and then register each action with a span.

   4. **Implementation 4**: Enforce common [helpers](https://github.com/dotnet/roslyn/blob/master/src/Features/Core/Portable/CodeRefactoringHelpers.cs) that each code refactoring ought to use to determine it's applicability span and bail out if that is not the case. We need to ensure we polish and/or extend the existing helpers, make them public as appropriate and audit all existing or just the problematic refactorings to ensure they are using these helpers.

2. **New UI for viewing available actions in a broader scope**: Create a separate tool window to show available code actions within a given scope (document/project/solution, with document being the default). Few open questions:
   1. Should the refactorings shown in this window be opt-in to avoid polluting it with common refactorings that show up everywhere?
   2. Should the tool window automatically be opened and brought to focus when user invokes light bulb and/or applies a code action? If not, how would we make this UI discoverable for users?
   3. Should the actions list in the window be ordered such that the actions closer to current cursor are near the top?
   We would potentially start with a simple UI, that only works for document scope to start with, and iterate on improving it to work with broader scopes.
</Description>
        <CreatedDate>06/05/2019</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>37196</PullRequestID>
        <IssueID>35180</IssueID>
        <Title>Offer codefixes on selections</Title>
        <Description>## Scenario
Codefixes often don't show if code is selected as opposed to only having your cursor placed within a word.
*  **5 out of the 11 users struggled with this in user studies.** 
* One user **only** ever double-clicked when clicking around the editor. This means he saw fewer codefixes since double clicking always selects the word and we don't show available codefixes in the context. Some users are used to double-clicking around their codebase.

## Proposal
Enable the same codefixes to appear if a block is selected as would appear if the cursor was placed inside a specific name. If this improves discoverability of codefixes we can enable this on a case-by-case basis per refactoring. My study observed more issues with the 'pull members up to base type' refactoring than others though general struggling was observed with many refactorings.

**Example: Pull members up**
Codefix offered when cursor is in the name:
![image](https://user-images.githubusercontent.com/8293542/56520118-8bb3e380-64f8-11e9-94fa-b79c60ed7ddb.png)

Codefix not offered if full line is selected:
![image](https://user-images.githubusercontent.com/8293542/56520215-bf8f0900-64f8-11e9-9022-7a5ebd464553.png)

**Example: Convert local function to method**
Offered if cursor is in name
![image](https://user-images.githubusercontent.com/8293542/56520344-0d0b7600-64f9-11e9-8fb9-6ac6d7b8de69.png)

Not offered when entire local function is selected
![image](https://user-images.githubusercontent.com/8293542/56520368-1ac0fb80-64f9-11e9-92a4-49037caea806.png)

**Example: LINQ to Foreach conversions**
![image](https://user-images.githubusercontent.com/8293542/56521136-1517e580-64fa-11e9-828a-a23aa22d8ce2.png)

If semi-colon is included in selection the conversion does not appear:
![image](https://user-images.githubusercontent.com/8293542/56521033-00d3e880-64fa-11e9-849f-2cc7a675f3ff.png)







</Description>
        <CreatedDate>22/04/2019</CreatedDate>
        <ClosedDate>06/09/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>37196</PullRequestID>
      <File>src/EditorFeatures/CSharpTest/GenerateOverrides/GenerateOverridesTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/RefactoringHelpers/RefactoringHelpersTests.cs</File>
      <File>src/Features/CSharp/Portable/CodeRefactorings/CSharpRefactoringHelpersService.cs</File>
      <File>src/Features/CSharp/Portable/GenerateMember/GenerateDefaultConstructors/CSharpGenerateDefaultConstructorsService.cs</File>
      <File>src/Features/Core/Portable/CodeRefactorings/AbstractRefactoringHelpersService.cs</File>
      <File>src/Features/Core/Portable/CodeRefactorings/IRefactoringHelpersService.cs</File>
      <File>src/Features/Core/Portable/CodeRefactorings/MoveType/AbstractMoveTypeService.cs</File>
      <File>src/Features/Core/Portable/GenerateConstructorFromMembers/GenerateConstructorFromMembersCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/GenerateEqualsAndGetHashCodeFromMembers/GenerateEqualsAndGetHashCodeFromMembersCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/GenerateOverrides/GenerateOverridesCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/IntroduceUsingStatement/AbstractIntroduceUsingStatementCodeRefactoringProvider.cs</File>
      <File>src/Workspaces/CSharp/Portable/LanguageServices/CSharpSyntaxFactsService.cs</File>
      <File>src/Workspaces/CSharp/Portable/LanguageServices/CSharpSyntaxKindsService.cs</File>
      <File>src/Workspaces/Core/Portable/LanguageServices/SyntaxFactsService/AbstractSyntaxFactsService.cs</File>
      <File>src/Workspaces/Core/Portable/LanguageServices/SyntaxFactsService/ISyntaxFactsService.cs</File>
      <File>src/Workspaces/Core/Portable/LanguageServices/SyntaxFactsService/ISyntaxKindsService.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>37117</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Remove reflection based workaround for IRecursivePatternOperation</Title>
    <Description>The API was made public in #36709, so we don't need a reflection based workaround

Fixes #36866

NOTE: We already have unit tests verifying the affected code path.</Description>
    <CreatedDate>10/07/2019</CreatedDate>
    <ClosedDate>10/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>37117</PullRequestID>
        <IssueID>36709</IssueID>
        <Title>Make IRecursivePatternOperation public</Title>
        <Description>Fixes #35843
</Description>
        <CreatedDate>24/06/2019</CreatedDate>
        <ClosedDate>01/07/2019</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>37117</PullRequestID>
        <IssueID>36866</IssueID>
        <Title>Remove reflection now that IRecursivePatternOperation is public</Title>
        <Description>See https://github.com/dotnet/roslyn/pull/36709#discussion_r296939885

We should remove this IDE reflection based hack that was added for this API: http://source.roslyn.io/#Microsoft.CodeAnalysis.Workspaces/Extensions/OperationExtensions.cs,64

`case IOperation iop when iop.GetType().GetInterfaces().Any(i =&gt; i.Name == "IRecursivePatternOperation"):`

/cc @mavasani 
</Description>
        <CreatedDate>28/06/2019</CreatedDate>
        <ClosedDate>10/07/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>37117</PullRequestID>
      <File>src/Workspaces/Core/Portable/Extensions/OperationExtensions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>37072</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Move some ComputeRefactoringsAsync to common helpers 2/n</Title>
    <Description>Continuation of work on #35525 and #35180</Description>
    <CreatedDate>09/07/2019</CreatedDate>
    <ClosedDate>12/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>37072</PullRequestID>
        <IssueID>35525</IssueID>
        <Title>Improve discoverability of code refactorings</Title>
        <Description>A bunch of recent customer surveys done by @kendrahavens identified that quite a few customers find our refactorings to be not discoverable. The refactorings that they requested were already implemented by us, but they needed Kendra to point out where to put the cursor or how to change the selection span for these to show up in the light bulb menu. The same concern does not apply to code fixes due to visual cue from the squiggle/suggestion dots in the UI, and pressing Ctrl + dot anywhere on the line shows up the fix, ordering being based on the distance from the diagnostic span. Note that the primary reason why we don't show up all the refactorings available on a given line are to avoid overloading the light bulb menu, which is already quite noisy. We need to fine tune the experience here to find a balance between discoverability of actions and overloading the light bulb menu.

We have talked about adding 2 different discoverability enhancements to address these concerns:

1. **Show additional actions in light bulb menu**
Improve the discoverability of the refactorings in the light bulb, by showing additional, but likely less relevant actions, that are applicable for positions _near_ the current cursor or selection span. Most relevant refactorings would still be show at the top of the menu and these additional actions will either be shown at the bottom of the menu or nested within a separate menu towards the bottom. Internal discussions have led to bunch of different implementation suggestions on how to achieve this (discussed below), but the primary conclusion being that we need to somehow _associate a fix span/ideal span with each registered code action within a refactoring, so the engine can prioritize the ordering and/or nesting of these refactorings based on promixity of this span with current cursor position or selection span_.
Possible implementation approaches that came out:
   1. **Implementation 1**: Convert all the IDE refactorings that are not selection based into a pair of diagnostic analyzer reporting hidden diagnostics + code fix. The diagnostic span would be the ideal span for the code actions.

      PROS:
         1. All refactorings available on any position in a line show up in the light bulb, solving the discoverability concerns. 
         2. We get other useful analyzer/fixer features for free: fix all, ability to bump up the severity to see squiggles/error list entries across a wider scope, etc.

      CONS:
         1. Likely to overload the light bulb menu with lot more actions now showing up. If so, one option might be to move all the code actions registered for hidden diagnostics whose span does not intersect with current position into a nested menu near the bottom of the light bulb menu.
         2. This approach adds quite a bit of implementation cost as we need to refactor code in each code refactoring into a pair of diagnostic analyzer/code fix.

   2. **Implementation 2**: Currently, the refactoring service executes naively for identifying available actions for current cursor position or span. It passes in the entire line span or selection span into each refactoring, and then treats all registered refactorings to be on par with each other. This forces our refactorings to then be implemented in a restrictive manner, so they are not offered everywhere on the line and do not overload the light bulb menu. This whole setup relies on the assumption that users are already aware about where to put their cursor or what span to select to get the relevant refactorings, which does not seem to be true as mentioned at the start of this post. This proposal tries to remove this assumption by making the following changes:
      1. Change the code refactoring service to perform multiple passes instead of just one. It first identifies the current token/node at the position or selection span and identifies available actions. These would be the most relevant refactorings that get offered at the top level of the light bulb menu. Then the service walks up the parent node and asks available actions for the parent and siblings of previous token/node. These actions would automatically be assigned a lower priority and will be shown under a nested menu near the bottom. These additional nearby actions would serve as a discoverability point for beginner users, while also not polluting the menu for advanced users.
      2. Change all the refactorings so they only register an action if the input text span exactly matches the token/node that is most relevant to it.

     PROS:
         1. We do not alter the existing light bulb menu significantly for advanced/experienced users, while adding a new discoverability point for beginner users to discover new potential actions in nearby locations.
         2. The implementation for each refactoring is greatly simplified and unified as they only work when input span exactly matches it's fixed span.

      CONS: 
         1. We might end up with a perf hit due to the code refactoring service doing multiple passes. We would need perf measurements to identify if this indeed a concern as most refactorings would just bail out upfront. 
         2. We need to experiment/decide if a nested menu is indeed a good discoverability point as beginner users might not know that they need to dive into a nested menu at the bottom.

   3. **Implementation 3**: Allow refactorings to specify a span in [RegisterRefactoring](http://source.roslyn.io/#Microsoft.CodeAnalysis.Workspaces/CodeRefactorings/CodeRefactoringContext.cs,51) callback. This would serve as the virtual diagnostic span for the code action. We would need to change all the refactorings to then operate on all the nodes/tokens of interest in the input context span and register refactorings for each node/token with their span. The code refactoring service would be changed to prioritize refactorings whose registered span is a close match to current position/span, and show the rest of refactorings in a nested menu or towards the bottom of the menu.

     PROS: Get the similar user experience as prior approaches, with potentially lesser implementation cost then approach i. and avoid multiple passes that are needed in approach ii.

     CONS: Adds implementation complexity in each refactoring of identifying multiple nodes/tokens of interest and then register each action with a span.

   4. **Implementation 4**: Enforce common [helpers](https://github.com/dotnet/roslyn/blob/master/src/Features/Core/Portable/CodeRefactoringHelpers.cs) that each code refactoring ought to use to determine it's applicability span and bail out if that is not the case. We need to ensure we polish and/or extend the existing helpers, make them public as appropriate and audit all existing or just the problematic refactorings to ensure they are using these helpers.

2. **New UI for viewing available actions in a broader scope**: Create a separate tool window to show available code actions within a given scope (document/project/solution, with document being the default). Few open questions:
   1. Should the refactorings shown in this window be opt-in to avoid polluting it with common refactorings that show up everywhere?
   2. Should the tool window automatically be opened and brought to focus when user invokes light bulb and/or applies a code action? If not, how would we make this UI discoverable for users?
   3. Should the actions list in the window be ordered such that the actions closer to current cursor are near the top?
   We would potentially start with a simple UI, that only works for document scope to start with, and iterate on improving it to work with broader scopes.
</Description>
        <CreatedDate>06/05/2019</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>37072</PullRequestID>
        <IssueID>35180</IssueID>
        <Title>Offer codefixes on selections</Title>
        <Description>## Scenario
Codefixes often don't show if code is selected as opposed to only having your cursor placed within a word.
*  **5 out of the 11 users struggled with this in user studies.** 
* One user **only** ever double-clicked when clicking around the editor. This means he saw fewer codefixes since double clicking always selects the word and we don't show available codefixes in the context. Some users are used to double-clicking around their codebase.

## Proposal
Enable the same codefixes to appear if a block is selected as would appear if the cursor was placed inside a specific name. If this improves discoverability of codefixes we can enable this on a case-by-case basis per refactoring. My study observed more issues with the 'pull members up to base type' refactoring than others though general struggling was observed with many refactorings.

**Example: Pull members up**
Codefix offered when cursor is in the name:
![image](https://user-images.githubusercontent.com/8293542/56520118-8bb3e380-64f8-11e9-94fa-b79c60ed7ddb.png)

Codefix not offered if full line is selected:
![image](https://user-images.githubusercontent.com/8293542/56520215-bf8f0900-64f8-11e9-9022-7a5ebd464553.png)

**Example: Convert local function to method**
Offered if cursor is in name
![image](https://user-images.githubusercontent.com/8293542/56520344-0d0b7600-64f9-11e9-8fb9-6ac6d7b8de69.png)

Not offered when entire local function is selected
![image](https://user-images.githubusercontent.com/8293542/56520368-1ac0fb80-64f9-11e9-92a4-49037caea806.png)

**Example: LINQ to Foreach conversions**
![image](https://user-images.githubusercontent.com/8293542/56521136-1517e580-64fa-11e9-828a-a23aa22d8ce2.png)

If semi-colon is included in selection the conversion does not appear:
![image](https://user-images.githubusercontent.com/8293542/56521033-00d3e880-64fa-11e9-849f-2cc7a675f3ff.png)







</Description>
        <CreatedDate>22/04/2019</CreatedDate>
        <ClosedDate>06/09/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>37072</PullRequestID>
      <File>src/EditorFeatures/CSharpTest/CodeActions/ConvertLocalFunctionToMethod/ConvertLocalFunctionToMethodTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/CodeActions/InlineTemporary/InlineTemporaryTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/PullMemberUp/CSharpPullMemberUpTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/RefactoringHelpers/RefactoringHelpersTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseNamedArguments/UseNamedArgumentsTests.cs</File>
      <File>src/Features/CSharp/Portable/CodeRefactorings/CSharpRefactoringHelpersService.cs</File>
      <File>src/Features/CSharp/Portable/CodeRefactorings/InlineTemporary/InlineTemporaryCodeRefactoringProvider.cs</File>
      <File>src/Features/CSharp/Portable/ConvertNumericLiteral/CSharpConvertNumericLiteralCodeRefactoringProvider.cs</File>
      <File>src/Features/CSharp/Portable/ReplaceMethodWithProperty/CSharpReplaceMethodWithPropertyService.cs</File>
      <File>src/Features/CSharp/Portable/ReplacePropertyWithMethods/CSharpReplacePropertyWithMethodsService.cs</File>
      <File>src/Features/Core/Portable/CodeRefactorings/AbstractRefactoringHelpersService.cs</File>
      <File>src/Features/Core/Portable/ConvertNumericLiteral/AbstractConvertNumericLiteralCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/InitializeParameter/AbstractInitializeParameterCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/ReplaceMethodWithProperty/AbstractReplaceMethodWithPropertyService.cs</File>
      <File>src/Features/Core/Portable/ReplaceMethodWithProperty/IReplaceMethodWithPropertyService.cs</File>
      <File>src/Features/Core/Portable/ReplaceMethodWithProperty/ReplaceMethodWithPropertyCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/ReplacePropertyWithMethods/AbstractReplacePropertyWithMethodsService.cs</File>
      <File>src/Features/Core/Portable/ReplacePropertyWithMethods/IReplacePropertyWithMethodsService.cs</File>
      <File>src/Features/Core/Portable/ReplacePropertyWithMethods/ReplacePropertyWithMethodsCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/UseNamedArguments/AbstractUseNamedArgumentsCodeRefactoringProvider.cs</File>
      <File>src/Features/LanguageServer/ProtocolUnitTests/CodeActions/CodeActionsTests.cs</File>
      <File>src/Workspaces/CSharp/Portable/LanguageServices/CSharpSyntaxFactsService.cs</File>
      <File>src/Workspaces/Core/Portable/LanguageServices/SyntaxFactsService/AbstractSyntaxFactsService.cs</File>
      <File>src/Workspaces/Core/Portable/LanguageServices/SyntaxFactsService/ISyntaxFactsService.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>35094</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Add unit-tests for fixed issues.</Title>
    <Description>Closes #33276.
Closes #31676.</Description>
    <CreatedDate>18/04/2019</CreatedDate>
    <ClosedDate>18/04/2019</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>35094</PullRequestID>
        <IssueID>33276</IssueID>
        <Title>Nullability check; Ignoring inherited type constraints from types in another assembly</Title>
        <Description>**Version Used**:  VS 2019 Preview 2.2

**Steps to Reproduce**:
This issue was quite hard to isolate, here it is: 
1. in BaseAssembly.dll
```CS
    public class MyEntity
    {
    }

    public abstract class BaseController&lt;T&gt;
        where T : MyEntity
    {
        public abstract void SomeMethod&lt;R&gt;(R? lite)
            where R : MyEntity;
    }
```

in DerivedAssembly.dll

```CS
        class DerivedController&lt;T&gt; : BaseController&lt;T&gt;
            where T : MyEntity
        {
            Table&lt;T&gt; table = null!;
            public override void SomeMethod&lt;R&gt;(R? lite) /*where R : MyEntity produces CS460*/
            {
/*error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.*/
                   table.OtherMethod(lite);
            }
        }

        class Table&lt;T&gt;
            where T : MyEntity
        {
            public void OtherMethod&lt;R&gt;(R? lite) where R : MyEntity
            {
                lite?.ToString();
            }
        }
```
Both assemblies have   `&lt;NullableContextOptions&gt;enable&lt;/NullableContextOptions&gt;`

**Expected Behavior**:
Compiles succesfully

**Actual Behavior**:
error CS8627

</Description>
        <CreatedDate>10/02/2019</CreatedDate>
        <ClosedDate>18/04/2019</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>35094</PullRequestID>
        <IssueID>31676</IssueID>
        <Title>Regression with Nullable&lt;T&gt; and a generic type constraint on base</Title>
        <Description>With the attached solution, we (the EF team) are getting the following errors:

&gt; error CS8320: Feature 'nullable reference types' is not available in C# 7.0. Please use language version 8.0 or greater.
&gt; error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
&gt; error CS0115: 'QueryAsserter&lt;TContext&gt;.AssertQueryScalar&lt;TItem1, TResult&gt;(Func&lt;IQueryable&lt;TItem1&gt;, IQueryable&lt;TResult?&gt;&gt;)': no suitable method found to override
&gt; error CS0534: 'QueryAsserter&lt;TContext&gt;' does not implement inherited abstract member 'QueryAsserterBase.AssertQueryScalar&lt;TItem1, TResult&gt;(Func&lt;IQueryable&lt;TItem1&gt;, IQueryable&lt;TResult?&gt;&gt;)'

The base type looks like this. (Our actual codebase uses `TResult?` here too but it reproed more consistently with `Nullable&lt;TResult&gt;`)

``` csharp
public abstract class QueryAsserterBase
{
    public abstract void AssertQueryScalar&lt;TItem1, TResult&gt;(
        Func&lt;IQueryable&lt;TItem1&gt;, IQueryable&lt;Nullable&lt;TResult&gt;&gt;&gt; actualQuery)
        where TResult : struct;
}
```

The derived type looks like this.

``` csharp
public class QueryAsserter&lt;TContext&gt; : QueryAsserterBase
{
    public override void AssertQueryScalar&lt;TItem1, TResult&gt;(
        Func&lt;IQueryable&lt;TItem1&gt;, IQueryable&lt;TResult?&gt;&gt; actualQuery)
    {          
    }
}
```

Putting the classes in the same file makes the issue go away as do other seemingly unrelated changes. Possibly an ordering issue or a race condition. Only repros on later versions of Roslyn (VS 2019 and .NET Core SDK 3.0).

cc @maumar @ajcvickers @Eilon

[Repro.zip](https://github.com/dotnet/roslyn/files/2664844/Repro.zip)
</Description>
        <CreatedDate>10/12/2018</CreatedDate>
        <ClosedDate>18/04/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>35094</PullRequestID>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/NullableReferenceTypesTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>35048</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Implement `where T: class` and `where T: struct` for overrides and explicit interface implementations.</Title>
    <Description>Closes #34798.
Closes #29847.</Description>
    <CreatedDate>17/04/2019</CreatedDate>
    <ClosedDate>17/04/2019</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>35048</PullRequestID>
        <IssueID>34798</IssueID>
        <Title>Implement `where T: class` and `where T: struct` for overrides and implementations</Title>
        <Description>See https://github.com/dotnet/csharplang/issues/2378#issuecomment-479634969

The LDM has specified that an override method or an explicit implementation method may specify the `struct` or `class` constraint on type parameters, and that such constraints are checked that they are implied by the constraints on the method being implemented or overridden.

When the `class` constraint is used, a nullable annotation on that type parameter `T?` does not mean `Nullable&lt;T&gt;` but rather it is a nullable reference type.

This needs to be implemented.</Description>
        <CreatedDate>05/04/2019</CreatedDate>
        <ClosedDate>17/04/2019</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>35048</PullRequestID>
        <IssueID>29847</IssueID>
        <Title>Overridden method lookup is order dependent</Title>
        <Description>```
        [Fact]
        public void Overriding_05()
        {
            var source = @"
class A
{
    public virtual void M1&lt;T&gt;(T? x) where T : struct 
    { 
    }

    public virtual void M1&lt;T&gt;(T? x) where T : class 
    { 
    }
}

class B : A
{
    public override void M1&lt;T&gt;(T? x)
    {
    }
} 

class C
{
    public virtual void M2&lt;T&gt;(T? x) where T : class 
    { 
    }

    public virtual void M2&lt;T&gt;(T? x) where T : struct 
    { 
    }
}

class D : C
{
    public override void M2&lt;T&gt;(T? x)
    {
    }
} 
";
            var compilation = CreateCompilation(new[] { source, NonNullTypesTrue, NonNullTypesAttributesDefinition });

            // PROTOTYPE(NullableReferenceTypes): The overriding is ambiguous.
            // We simply matched the first candidate. Should this be an error?
            compilation.VerifyDiagnostics();

            var b = compilation.GetTypeByMetadataName("B");
            var m1 = b.GetMember&lt;MethodSymbol&gt;("M1");
            Assert.True(m1.Parameters[0].Type.IsNullableType());
            Assert.True(m1.OverriddenMethod.Parameters[0].Type.IsNullableType());

            var d = compilation.GetTypeByMetadataName("D");
            var m2 = d.GetMember&lt;MethodSymbol&gt;("M2");
            Assert.False(m2.Parameters[0].Type.IsNullableType());
            Assert.False(m2.OverriddenMethod.Parameters[0].Type.IsNullableType());
        }
```</Description>
        <CreatedDate>13/09/2018</CreatedDate>
        <ClosedDate>17/04/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>35048</PullRequestID>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Constraints.cs</File>
      <File>src/Compilers/CSharp/Portable/CSharpResources.Designer.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/ErrorCode.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/MessageID.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceOrdinaryMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/TypeWithAnnotations.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/GenericConstraintsTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/InheritanceBindingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/NullableReferenceTypesTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/ParserErrorMessageTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>35030</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Lambdas in array initializers checked in nullable walker</Title>
    <Description>Also fixes a corresponding issue in the switch expression
Fixes #34299
See also #35029</Description>
    <CreatedDate>17/04/2019</CreatedDate>
    <ClosedDate>29/04/2019</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>35030</PullRequestID>
        <IssueID>34299</IssueID>
        <Title>Lambdas in array initializers not checked in nullable walker</Title>
        <Description>The following proposed test fails.  The second warning is not produced.

``` c#
        [Fact, WorkItem(34299, "https://github.com/dotnet/roslyn/issues/34299")]
        public void CheckLambdaInArrayInitializer()
        {
            var source =
@"using System;

class C
{
    static void G(object? o)
    {
        Func&lt;object&gt; f = () =&gt; o; // possible null reference return
        var fa3 = new[] {
            f, // this defines the array element type as Func&lt;object&gt;
            () =&gt; o, // possible null reference return
            };
        fa3[0]().ToString();
    }
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,32): warning CS8603: Possible null reference return.
                //         Func&lt;object&gt; f = () =&gt; o; // possible null reference return
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "o").WithLocation(7, 32),
                // (11,19): warning CS8603: Possible null reference return.
                //            () =&gt; o, // possible null reference return
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "o").WithLocation(11, 19));
        }
```
</Description>
        <CreatedDate>20/03/2019</CreatedDate>
        <ClosedDate>29/04/2019</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>35030</PullRequestID>
        <IssueID>35029</IssueID>
        <Title>Unexpected inference for conditional expression</Title>
        <Description>The following test demonstrates the behavior I would expect for the `?:` expression when only one side of the `:` "has a type".  But this isn't how the compiler behaves.  It is inferring an oblivious result rather than taking the type from the only operand that has a type and reporting a warning on the conversion.  Silently inferring an oblivious result undermines the safety of the nullable feature.

``` c#
        [Fact]
        public void CheckLambdaInConditional()
        {
            var source =
@"using System;

class C
{
    static Func&lt;T&gt; M&lt;T&gt;(Func&lt;T&gt; f) =&gt; f;
    static void G(int i, object? o, string? s)
    {
        if (o == null) return;
        var f = M(() =&gt; o) /*T:System.Func&lt;object!&gt;!*/;
        f().ToString();
        var f2 = (i == 0) ? f : (() =&gt; s); // 1
        _ = f2 /*T:System.Func&lt;object!&gt;!*/;
        f2().ToString();
        var f3 = (i == 0) ? f : (() =&gt; { return s; }); // 2
        _ = f3 /*T:System.Func&lt;object!&gt;!*/;
        f3().ToString();
    }
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (12,42): warning CS8603: Possible null reference return.
                //        var f2 = (i == 0) ? f : (() =&gt; s); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "s").WithLocation(12, 42),
                // (14,32): warning CS8603: Possible null reference return.
                //        var f3 = (i == 0) ? f : (() =&gt; { return s; }); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "s").WithLocation(14, 32));
        }
```
</Description>
        <CreatedDate>17/04/2019</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>35030</PullRequestID>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/NullableWalker.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/NullableWalker_Patterns.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/NullableReferenceTypesTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>35024</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Fix complete statement's semicolon placement to better handle incomplete code</Title>
    <Description>Fix for #34983 and #35126</Description>
    <CreatedDate>16/04/2019</CreatedDate>
    <ClosedDate>22/04/2019</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>35024</PullRequestID>
        <IssueID>34983</IssueID>
        <Title>Complete Statement on incomplete code places semicolon in incorrect location</Title>
        <Description>When Complete Statement is invoked in the following case, the incomplete code is mistakenly considered an ElementAccessExpression that includes `[Test]`.  The semicolon is then placed after the attribute instead of after the field declaration. 

```csharp
using System;
internal class TestMethodAttribute : Attribute
{
    readonly int i = Foo(3,4$$)

    [Test]
}
```

Expected:
semicolon to be placed after `Foo(3,4)`

Actual:
semicolon is placed after `[Test]`

![image](https://user-images.githubusercontent.com/25776963/56096145-3002ae00-5e99-11e9-8a94-83ca3092e66e.png)
</Description>
        <CreatedDate>15/04/2019</CreatedDate>
        <ClosedDate>23/04/2019</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>35024</PullRequestID>
        <IssueID>35126</IssueID>
        <Title>Don't complete statement when typing semicolon in char literal that is in delimiter</Title>
        <Description>**Version Used**: 

**Steps to Reproduce**:

1.  In the editor, insert the following code and type a semicolon where the $$ is
`void Main(string[]args)
    {
        Method('$$')
    }`
 
**Expected Behavior**:
`Method(';$$')`

**Actual Behavior**:
`Method('');$$`
</Description>
        <CreatedDate>18/04/2019</CreatedDate>
        <ClosedDate>23/04/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>35024</PullRequestID>
      <File>src/EditorFeatures/CSharp/CompleteStatement/CompleteStatementCommandHandler.cs</File>
      <File>src/EditorFeatures/CSharpTest/CompleteStatement/CSharpCompleteStatementCommandHandlerTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>35014</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Fix regression for switching on a constant value</Title>
    <Description>We made a change in #32818 to restore compatibility with C# 7.x
in rejecting certain switch statements even when we could prove
completeness with the new switch analysis. It looks like that
change just went a little too far, as we could do the analysis
if the argument to the switch expression was a constant. This
change removes the compat clause for switches with constant
values

Fixes #35011</Description>
    <CreatedDate>16/04/2019</CreatedDate>
    <ClosedDate>17/04/2019</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>35014</PullRequestID>
        <IssueID>32818</IssueID>
        <Title>Simulate the C# 7 compiler's behavior on traditional switch statements with old language versions</Title>
        <Description>Fixes #32806
This was a "forward compatibility" bug, where new compilers would accept code in old language versions that the older compilers would not have accepted.</Description>
        <CreatedDate>26/01/2019</CreatedDate>
        <ClosedDate>29/01/2019</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>35014</PullRequestID>
        <IssueID>35011</IssueID>
        <Title>switch case without default no longer compiles in visual studio 2019 [c#]</Title>
        <Description>VSF_TYPE_MARKDOWNThe following code compiles fine in Visual Studio 2017, but not in Visual Studio 2019. Is there a default compiler option that has changed which can resolve this?

    using System;
    
    namespace NoDefaultCase
    {
        public static class Program
        {
            public const string Database = &amp;quot;MongoDB&amp;quot;;
    
            public static string GetDb()
            {
                switch (Database)
                {
                    case &amp;quot;MongoDB&amp;quot;:
                        return Database;
                }
            }
    
            public static void Main(string[] args)
            {
                Console.WriteLine($&amp;quot;The value returned is \&amp;quot;{GetDb()}\&amp;quot;.&amp;quot;);
                Console.WriteLine(&amp;quot;Press a key to exit&amp;quot;);
                Console.ReadKey();
            }
        }
    }

There is also a Stack Overflow ticket for this item:
https://stackoverflow.com/questions/55541269/why-does-a-switch-case-statement-on-a-string-constant-require-a-default-in-visua

_This issue has been moved from https://developercommunity.visualstudio.com/content/problem/520522/switch-case-without-default-no-longer-compiles-in.html
VSTS ticketId: 841662_
_These are the original issue comments:_

Martin Eyles on 4/6/2019, 05:37 AM (10 days ago): &lt;p&gt;In Visual Studio 2017, the output of the build is:&lt;br&gt;&lt;br&gt;    1&amp;gt;------ Rebuild All started: Project: NoDefaultCase, Configuration: Debug Any CPU ------&lt;br&gt;    1&amp;gt;  NoDefaultCase -&amp;gt; C:\Users\MartinEyles\source\repos\NoDefaultCase\NoDefaultCase\bin\Debug\NoDefaultCase.exe&lt;br&gt;    ========== Rebuild All: 1 succeeded, 0 failed, 0 skipped ==========&lt;br&gt;&lt;br&gt;In Visual Studio 2019, the output of the build is:&lt;br&gt;&lt;br&gt;    1&amp;gt;------ Rebuild All started: Project: NoDefaultCase, Configuration: Debug Any CPU ------&lt;br&gt;    1&amp;gt;C:\Users\MartinEyles\source\repos\NoDefaultCase\NoDefaultCase\Program.cs(9,30,9,35): error CS0161: 'Program.GetDb()': not all code paths return a value&lt;br&gt;    ========== Rebuild All: 0 succeeded, 1 failed, 0 skipped ==========&lt;/p&gt;

Visual Studio Feedback System on 4/8/2019, 02:55 AM (8 days ago): &lt;p&gt;We have directed your feedback to the appropriate engineering team for further evaluation. The team will review the feedback and notify you about the next steps.&lt;/p&gt;

Martin Eyles on 4/8/2019, 03:07 AM (8 days ago): &lt;p&gt;A github repository containing the example solution can be found at &lt;a target='_blank' href="https://github.com/martineyles/NoDefaultCase"&gt;https://github.com/martineyles/NoDefaultCase&lt;/a&gt; This includes an archive of the example solution in the state before it was added to github (NoDefaultCase - Before Github.zip).&lt;/p&gt;

Martin Eyles on 4/8/2019, 05:59 AM (8 days ago): &lt;p&gt;I experience this issue in &lt;/p&gt;&lt;p&gt;Microsoft Visual Studio Enterprise 2019 &lt;br&gt;Version 16.0.0&lt;br&gt;VisualStudio.16.Release/16.0.0+28729.10&lt;br&gt;Microsoft .NET Framework Version 4.7.03056'&lt;/p&gt;&lt;p&gt;It has been suggested by others in the Stack Overflow community that a preview version of Visual Studio 2019 behaves the same way as Visual Studio 2017&lt;/p&gt;

Martin Eyles on 4/12/2019, 05:24 AM (4 days ago): &lt;p&gt;The issue is still present in:&lt;br&gt;&lt;br&gt;Microsoft Visual Studio Enterprise 2019&lt;br&gt;Version 16.0.1&lt;br&gt;VisualStudio.16.Release/16.0.1+28803.156&lt;br&gt;Microsoft .NET Framework Version 4.7.03056&lt;/p&gt;

Martin Eyles on 4/12/2019, 05:26 AM (4 days ago): &lt;p&gt;Stack overflow users has suggested that this does not meet the C#  specification, and is likely to be either a bug or a change in the  specification that hasn't yet been documented.&lt;/p&gt;

Martin Eyles on 4/12/2019, 05:29 AM (4 days ago): &lt;p&gt;To quote a user with very good reputation on stack overflow:&lt;/p&gt;&lt;p&gt;The &lt;a target='_blank' href="https://www.ecma-international.org/publications/standards/Ecma-334.htm"&gt;ECMA C# 5 standard&lt;/a&gt; section 13.8.3 describes the reachability of the end of a switch statement:&lt;/p&gt;&lt;p&gt;  
&lt;/p&gt;&lt;blockquote&gt;   
&lt;p&gt;The end point of a switch statement is reachable if at least one of the following is true:&lt;/p&gt;&lt;p&gt;      
&lt;/p&gt;&lt;ul&gt;&lt;li&gt;The switch statement contains a reachable break statement that exits the switch statement.&lt;/li&gt;&lt;li&gt;The switch statement is reachable, the switch expression is a non-constant value, and no default label is present.&lt;/li&gt;&lt;li&gt;The switch statement is reachable, the switch expression is a  constant value that doesn‚Äôt match any case label, and no default label  is present.&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;p&gt;  
&lt;/p&gt;&lt;p&gt;None of these seem to be the case in your example:&lt;/p&gt;&lt;p&gt;  
&lt;/p&gt;&lt;ul&gt;&lt;li&gt;There are no break statements&lt;/li&gt;&lt;li&gt;The switch expression is a constant value&lt;/li&gt;&lt;li&gt;The constant value &lt;em&gt;does&lt;/em&gt; match a case label&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;  
&lt;/p&gt;&lt;p&gt;So with C# 5 rules, the end point of this switch statement is &lt;em&gt;not&lt;/em&gt; reachable, and it should compile with no problems. The &lt;a target='_blank' href="https://github.com/dotnet/csharplang/blob/master/spec/statements.md"&gt;draft specification in GitHub&lt;/a&gt; has the same text, so it doesn't look like it's changed there yet...&lt;/p&gt;

_These are the original issue solutions:_
(no solutions)</Description>
        <CreatedDate>16/04/2019</CreatedDate>
        <ClosedDate>19/04/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>35014</PullRequestID>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/AbstractFlowPass_Switch.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/FlowAnalysis/FlowTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>35006</IssueID>
    <RepoID>roslyn</RepoID>
    <Title> Avoid boxing in string concatenation </Title>
    <Description>This changes the order of evaluation for string concatenation to follow
the C# specification. See #522.

Previously, when the compiler lowered a string concatenation containing
any objects which were not strings (or implicitly convertible to
strings), it would generate a call to an appropriate overload of
`string.Concat` taking `objects`. This meant that all expressions being
concatenated were evaluated, then `string.Concat` called, which called
`.ToString()` on all of them.

E.g.

    "x" + y + z

got compiled to :

    string.Concat("x", y, z)

Here, `y` and `z` are evaluated to `object` (boxing them if necessary),
and then they have `.ToString()` called on them by `string.Concat`.

This is technically against the C# specification, which defines string
concatenation as a sequence of left-associative calls to one of:

    string operator +(string x, string y);
    string operator +(string x, object y);
    string operator +(object x, string y);

So the above expression should conceptually be compiled to:

    op_Addition(op_Addition("x", y), z)

That is, `y` is evaluated to `object` and concatenated with `"x"`
before `z` is evaluated to `object`.

The decision was made to change this behaviour in #522.

This change brings a very important advantage: we can now fully evaluate
`y` to a string before we evaluate `z`, which means we're allowed to
compile the above to:

    string.Concat("x", y.ToString(), z.ToString())

This means that:

 - We don't box `y` and `z` if they're value types
 - We don't call `ToString()` on `"x"` (which is harmless but pointless)

This commit implements this change.

Calls are no longer emitted to overloads of `string.Concat` which take
`object` - instead, all parameters are evaluated to a string, and then
an appropriate overload of `string.Concat` which takes `strings` is
called.

Care is taken to deal with different types of expressions in different
ways:

 - Strings or types which are implicitly convertible to string never have
   .ToString called on them
 - Reference types (and unconstrained generics) have ?.ToString() called
   on them
 - A copy is made of non-readonly non-constant value types (and
   unconstrained generics), before.ToString() is called on the copy. This
   is to preserve the previous behaviour where value types were boxed, and
   so any side-effects of ToString() weren't reflected in the original.
 - A copy isn't made of readonly value types, as we know that ToString()
   can't have side-effects.

We emit `call` to special struct types, as we know these have their own
ToString implementation which won't be removed. For other value types,
we emit a constrained virtual call. This follows the precedent set in

For unary concatenation (e.g. `thing + ""`) we now emit
`thing?.ToString() ?? ""` instead of `string.Concat(thing) ?? ""`.

This does increase the size of generated code. My impression is that the
unit tests which were affected by this changed increased in size by
about 10%. This is somewhat offset by the fact that we can now call

    string.Concat(string, string, string, string)

instead of

    string.Concat(object[])

(since there is no overload of string.Concat which takes 4 objects),
which reduces the size of some methods significantly.

I haven't removed the SpecialMember versions of `string.Concat` which take object - let me know if you want me to.
</Description>
    <CreatedDate>16/04/2019</CreatedDate>
    <ClosedDate>15/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>35006</PullRequestID>
        <IssueID>522</IssueID>
        <Title>[Proposal] Change order of evaluation for string concatenation to follow C# specification</Title>
        <Description>During evaluation for #415, a situation was identified where the C# compiler does not strictly adhere to the C# language specification. I am proposing altering the behavior of the Roslyn C# compiler in this area to instead follow the C# specification. It is not clear to me when the bug was originally introduced; it may go back all the way to the C# 1.0 compiler.
## Affected source code

The behavior under consideration here is string concatenation which meets both of the following conditions:
1. The string concatenation operation involves the concatenation of three or more expressions.
2. The static type of at least one of the terms in the concatenation expression is not implicitly convertible to `string`.
## Description of deviation from specification

The C# specification describes the behavior of string concatenation in terms of a left-associative sequence of calls to the following methods:

``` csharp
string operator +(string x, string y);
string operator +(string x, object y);
string operator +(object x, string y);
```

For example, in the underlying bytecode, the expression `"x" + y + z` should appear as the following:

``` csharp
// semantics according to specification:
op_Addition(op_Addition("x", y), z)
```

Based on the defined order of evaluation for calls to methods in C# and semantics for string concatenation, it is clear that the expression `y` above is evaluated all the way to the final `string` result prior to any evaluation of `z`. This order of evaluation is:
1. `"x"` is evaluated to a `string`
2. `y` is evaluated to an `object`
3. If the result of (2) is not `null`, its `ToString` method is called
4. `z` is evaluated to an `object`
5. If the result of (4) is not `null`, its `ToString` method is called

The C# compiler currently deviates from this behavior. Rather than making two calls to `op_Addition`, the generated bytecode contains a single call to `string.Concat`:

``` csharp
// semantics according to compiler:
string.Concat("x", y, z)
```

It is critical to note that the C# compiler does _not_ call `ToString` on `y` or `z` prior to passing them as arguments to `Concat`. The semantics are now:
1. `"x"` is evaluated to a `string`
2. `y` is evaluated to an `object`
3. `z` is evaluated to an `object`
4. If the result of (2) is not `null`, its `ToString` method is called
5. If the result of (3) is not `null`, its `ToString` method is called

The deviation from the specification lies in the reordering of the expression evaluation and the calls to `ToString`. This reordering can produce observable behavior that does not adhere to the C# specification in the following situations (ordered from highest to lowest likelihood of incidence, based on nothing but my opinion):
1. The evaluation of `ToString` on the result of evaluating `y` throws an exception, and the evaluation of `z` produces side effects (i.e. the evaluation of `z` shouldn't have occurred, but it does occur here due to the reordering).
2. The evaluation of expression `z` has side effects that affect the `ToString` operation in step 4 (e.g. evaluation of `z` changes the current culture, which affects the `ToString` operation).
3. The evaluation of `ToString` on the result of evaluating `y` has side effects which affect the evaluation of `z` (i.e. the side effects should have occurred prior to evaluating `z`, but instead they occur afterwards).
## Argument against altering the current behavior

Especially due to the amount of time this bug has been present in the compiler, it is possible that real-world code exists which relies (intentionally or unintentionally) on the current behavior.
## Argument in favor of altering the behavior
- The semantics defined by the C# specification allow the compiler to avoid boxing and certain other memory allocations at runtime (see #415). These boxing operations have already been identified in several key code paths in the .NET Core and Roslyn projects, and providing functionality in the compiler to avoid the boxing will provide an automatic performance benefit to many .NET applications.
- The behavior change is certainly less likely to manifest itself in real code that other accepted changes like avoiding placing certain local variables in the state machines generated for iterators and async methods.
- The "most likely situation" identified above is not likely to appear in the "correct" execution path of a program, due to throwing an exception. Furthermore, even in this case it's unlikely that a program would rely on the side effect(s) of evaluating `z`.
</Description>
        <CreatedDate>15/02/2015</CreatedDate>
        <ClosedDate>15/07/2019</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>35006</PullRequestID>
        <IssueID>522</IssueID>
        <Title>[Proposal] Change order of evaluation for string concatenation to follow C# specification</Title>
        <Description>During evaluation for #415, a situation was identified where the C# compiler does not strictly adhere to the C# language specification. I am proposing altering the behavior of the Roslyn C# compiler in this area to instead follow the C# specification. It is not clear to me when the bug was originally introduced; it may go back all the way to the C# 1.0 compiler.
## Affected source code

The behavior under consideration here is string concatenation which meets both of the following conditions:
1. The string concatenation operation involves the concatenation of three or more expressions.
2. The static type of at least one of the terms in the concatenation expression is not implicitly convertible to `string`.
## Description of deviation from specification

The C# specification describes the behavior of string concatenation in terms of a left-associative sequence of calls to the following methods:

``` csharp
string operator +(string x, string y);
string operator +(string x, object y);
string operator +(object x, string y);
```

For example, in the underlying bytecode, the expression `"x" + y + z` should appear as the following:

``` csharp
// semantics according to specification:
op_Addition(op_Addition("x", y), z)
```

Based on the defined order of evaluation for calls to methods in C# and semantics for string concatenation, it is clear that the expression `y` above is evaluated all the way to the final `string` result prior to any evaluation of `z`. This order of evaluation is:
1. `"x"` is evaluated to a `string`
2. `y` is evaluated to an `object`
3. If the result of (2) is not `null`, its `ToString` method is called
4. `z` is evaluated to an `object`
5. If the result of (4) is not `null`, its `ToString` method is called

The C# compiler currently deviates from this behavior. Rather than making two calls to `op_Addition`, the generated bytecode contains a single call to `string.Concat`:

``` csharp
// semantics according to compiler:
string.Concat("x", y, z)
```

It is critical to note that the C# compiler does _not_ call `ToString` on `y` or `z` prior to passing them as arguments to `Concat`. The semantics are now:
1. `"x"` is evaluated to a `string`
2. `y` is evaluated to an `object`
3. `z` is evaluated to an `object`
4. If the result of (2) is not `null`, its `ToString` method is called
5. If the result of (3) is not `null`, its `ToString` method is called

The deviation from the specification lies in the reordering of the expression evaluation and the calls to `ToString`. This reordering can produce observable behavior that does not adhere to the C# specification in the following situations (ordered from highest to lowest likelihood of incidence, based on nothing but my opinion):
1. The evaluation of `ToString` on the result of evaluating `y` throws an exception, and the evaluation of `z` produces side effects (i.e. the evaluation of `z` shouldn't have occurred, but it does occur here due to the reordering).
2. The evaluation of expression `z` has side effects that affect the `ToString` operation in step 4 (e.g. evaluation of `z` changes the current culture, which affects the `ToString` operation).
3. The evaluation of `ToString` on the result of evaluating `y` has side effects which affect the evaluation of `z` (i.e. the side effects should have occurred prior to evaluating `z`, but instead they occur afterwards).
## Argument against altering the current behavior

Especially due to the amount of time this bug has been present in the compiler, it is possible that real-world code exists which relies (intentionally or unintentionally) on the current behavior.
## Argument in favor of altering the behavior
- The semantics defined by the C# specification allow the compiler to avoid boxing and certain other memory allocations at runtime (see #415). These boxing operations have already been identified in several key code paths in the .NET Core and Roslyn projects, and providing functionality in the compiler to avoid the boxing will provide an automatic performance benefit to many .NET applications.
- The behavior change is certainly less likely to manifest itself in real code that other accepted changes like avoiding placing certain local variables in the state machines generated for iterators and async methods.
- The "most likely situation" identified above is not likely to appear in the "correct" execution path of a program, due to throwing an exception. Furthermore, even in this case it's unlikely that a program would rely on the side effect(s) of evaluating `z`.
</Description>
        <CreatedDate>15/02/2015</CreatedDate>
        <ClosedDate>15/07/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>35006</PullRequestID>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_FixedStatement.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_StringConcat.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenDeconstructTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenStringConcat.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTryFinally.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/SwitchTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/OutVarTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/MissingSpecialMember.cs</File>
      <File>src/Compilers/CSharp/Test/WinRT/CodeGen/WinRTCollectionTests.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Test/ExpressionCompiler/LocalsTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>34916</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Remove the temporary mechanism for "external" nullable annotations.</Title>
    <Description>Relates to #29821
Fixes #34409
</Description>
    <CreatedDate>10/04/2019</CreatedDate>
    <ClosedDate>15/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>34916</PullRequestID>
        <IssueID>29821</IssueID>
        <Title>Need mechanism for injecting annotations</Title>
        <Description>This is a follow-up workitem to replace a number of PROTOTYPE markers.

Design issues:
- Right now extra annotations always win (even if we're loading a modern assembly). Is this what we want?

FYI @AlekseyTs </Description>
        <CreatedDate>13/09/2018</CreatedDate>
        <ClosedDate>04/05/2019</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>34916</PullRequestID>
        <IssueID>34409</IssueID>
        <Title>Remove hard-coded nullable annotations in compiler before C# 8.0 RTM</Title>
        <Description>
        </Description>
        <CreatedDate>25/03/2019</CreatedDate>
        <ClosedDate>15/07/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>34916</PullRequestID>
      <File>src/Compilers/CSharp/Portable/BoundTree/NullabilityRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ExtraAnnotations.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/NullableTypeDecoder.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PEMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PEParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PEPropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PETypeParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceComplexParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceSimpleParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/NullableReferenceTypesTests.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/Solution/SolutionState.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>34468</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Readonly members prototype cleanup</Title>
    <Description>Related to #32911 

This PR has several minor fixes and adds coverage for some new scenarios.

- Addresses and removes prototype comments (except for the public API ones in #34514)
- Updates `ThisParameterSymbol.RefKind` API to use RefKind.In when containingMethod.IsEffectivelyReadOnly
- Updates compiler test plan to mention readonly members
- Tests codegen of ReadOnlyMethod_OverrideBaseMethod
- Tests `readonly partial` methods: both signatures must contain `readonly`. Is this what we want?
  - Resolution: either both signatures or neither signature must contain 'readonly'.
- Tests readonly explicit interface implementations. These are allowed. Do we want that?
  - Resolution: 'readonly' explicit interface implementations are allowed.

The last few items might need to be hashed out in review and the speclet should probably be updated to be clear about the expected behavior. (done)</Description>
    <CreatedDate>26/03/2019</CreatedDate>
    <ClosedDate>29/03/2019</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>34468</PullRequestID>
        <IssueID>32911</IssueID>
        <Title>Test plan for "readonly members"</Title>
        <Description>Proposal: dotnet/csharplang#1710

This issue is a place to collect test ideas and track their validation. Use the [compiler test plan](
https://github.com/dotnet/roslyn/blob/master/docs/contributing/Compiler%20Test%20Plan.md) as a tool for brainstorming.

- [x] write speclet
- [x] update compiler test plan
- [x] validate with LangVersion 7.3

### Methods
- [x] struct instance methods
- [x] struct static methods (should error)
- [x] class/interface static/instance methods (should error)
- [x] ref/ref readonly returning methods
- [x] Inherited object members should be considered readonly
- [x] 'readonly partial' methods
- [x] 'readonly partial' where one of declaration or implementation is missing keyword (error)
- [x] `readonly` on `new ToString()`

### Properties
- [x] struct readonly getters
- [x] struct readonly setters (not auto-implemented)
- [x] struct static properties with readonly accessors (should error)
- [x] class/interface properties with readonly accessors (should error)
- [x] expression bodied properties `int P readonly =&gt; 42;` (should error)
- [x] indexers (allow)
- [x] readonly getter in a readonly property? (should be disallowed)
- [x] readonly on `int P { readonly get; set; }` allowed
- [x] getter implicitly readonly for all auto-props
- [x] `int P { readonly get; }` not allowed -&gt; `readonly int P { get; }`


### Misc
- [x] Constructors (disallow)
- [x] Operators (disallow)
- [x] Delegates (disallow)
- [x] Field-like events (disallow)
- [x] Manually implemented events (allow)
- [x] lambdas/local functions (error)
- [x] explicit interface implementations (should allow)
~~- [ ] SymbolDisplay on methods and property/indexer/event accessors~~ #34650
~~- [ ] IsDeclaredReadonly on ISymbol or IPropertySymbol/IMethodSymbol~~ #34213

### Semantic

- [x] Calling readonly methods from readonly methods
- [x] Calling non-readonly struct methods from readonly methods
- [x] Calling a non-readonly method on a reference type field from a readonly method
- [x] Variants of these which use different combinations of properties and methods
- [x] Assignment to `this`
- [x] Reference to instance fields in readonly member
    - [x] Assignment is an error
    - [x] Invocation w/ instance field as receiver causes copy when type is non-readonly struct
- [x] Invocation of non-readonly method or getter on `this` inside a `readonly` member causes copy and a warning. Non-readonly setter access on `this` or a value typed field is an error.
- [x] Unary increment/decrement operators on fields are errors
- [x] Compound assignment on fields is an error
- [x] Round-tripping through metadata
- [x] Error to take `ref` to `this` in `readonly` member
- [x] Property assignment:
  - [x] Disallow on non-readonly instance properties on `this` or value-typed fields
  - [x] Allow on static or readonly properties, or properties on reference-typed fields
  - [x] Compound assignment behavior should be consistent with a getter-then-setter access
https://sharplab.io/#v2:EYLgZgpghgLgrgJwgZwLRKgEwPYDsA2AnqgLYQnAQLIA0MIAlvjZiANQA+AAgAwAEXAIwBuALAAoDDgKE+yGAjgBjGHwDKEgN4S+uvg1yqACn018A5hFVmuAdj49hAXzlXTfF0517vurgBY+AFkACgN1OQBKX1MYvT4YAAsGZAA6EwBePn8AJjFxePi0zOy8mK8Cn3EKiXlFFXUcrRiDY3dLawF7RxdkNzNPGJipPCIBQNDwtRy5HOjK3W0FwoB6FaSU9L4s3PzCvTXkHK2dsuX4gH1thOTivf2bzZM2LLP4iviJJyA=

### IDE
~~- [ ] Extracting a method from a `readonly` method should produce a `readonly` method~~ #34647
~~- [ ] Suggestion to make a member `readonly` when it is called on a `ref readonly` receiver~~ #34648
~~- [ ] WRN_ImplicitCopyInReadOnlyMember should have a suggestion to make the callee `readonly` if possible~~ #34649
~~- [ ] WRN_ImplicitCopyInReadOnlyMember should have a suggestion to make an explicit copy of the receiver~~ 
- [x] Offered in completion in existing member
~~- [ ] Metadata as source~~ #34650

### Major sections of work (ideally PRs will not cover more than one of these)
- [x] Parsing of `readonly` method and property syntax (mostly just testing)
- [x] IsReadOnly API on MethodSymbol
  - In the case of properties, is `prop.GetMethod.IsReadOnly` acceptable design, or is it confusing to have `prop.IsReadOnly` potentially return a different value than `prop.GetMethod.IsReadOnly`?
- [x] Flow analysis to prevent mutation of `this` in `readonly` member implementation
  - maybe the analysis used for `in` params or `readonly struct` can just be reused?
- [x] Error on invalid usage of `readonly`
  - Any method or property without a `this` parameter (i.e. statics)
  - Any member inside a non-struct declaration (i.e. class, interface)
- [x] Emit tests to demonstrate that expected metadata (IsReadOnly, modopt, modreq) and optimizations (reduced value copying) are present in IL

~~- [ ] Should some synthesized methods be marked as readonly? ([discussion](https://github.com/dotnet/roslyn/pull/34260#issuecomment-474994280))~~ #36587
- [x] Should we disallow readonly members on readonly structs, since redundant? Or maybe we create an IDE fixer?
  - Resolution: Should be allowed, based on the principle that changing `struct` to `readonly struct` on a type where all members are marked readonly shouldn't result in a compile error. </Description>
        <CreatedDate>29/01/2019</CreatedDate>
        <ClosedDate>19/06/2019</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>34468</PullRequestID>
        <IssueID>34514</IssueID>
        <Title>Add IMethodSymbol.IsReadOnly to public API</Title>
        <Description>This proposes adding the following public API to `IMethodSymbol`:

```cs
/// &lt;summary&gt;
/// Indicates whether the method is readonly, i.e.
/// whether 'this' is 'ref readonly' in the scope of the method.
/// &lt;/summary&gt;
bool IsReadOnly { get; }
```

Note that once the last prototype comments are addressed, the check `methodSymbol.IsReadOnly` will be basically equivalent to `methodSymbol.ThisParameter.RefKind == RefKind.In`.</Description>
        <CreatedDate>27/03/2019</CreatedDate>
        <ClosedDate>03/04/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>34468</PullRequestID>
      <File>src/Compilers/CSharp/Portable/CSharpResources.Designer.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/ErrorCode.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceOrdinaryMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/ThisParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenReadonlyStructTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/ReadOnlyStructsTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>34440</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Export additional code styles in .editorconfig generation</Title>
    <Description>~~Builds on #33946~~
Possibly supersedes #34122 

* Export using directives styles when generating .editorconfig (Fixes #33766)
* Export naming styles when generating .editorconfig (Fixes #30086)</Description>
    <CreatedDate>26/03/2019</CreatedDate>
    <ClosedDate>19/04/2019</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>34440</PullRequestID>
        <IssueID>33946</IssueID>
        <Title>Add AssertEx.EqualOrDiff</Title>
        <Description>Based on work by @AArnott in dotnet/roslyn-sdk#240.
</Description>
        <CreatedDate>07/03/2019</CreatedDate>
        <ClosedDate>08/04/2019</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>34440</PullRequestID>
        <IssueID>34122</IssueID>
        <Title>[WIP]Bugfix: Settings for using-directives not exported to .editorconfig</Title>
        <Description>Fixes https://github.com/dotnet/roslyn/issues/33766

At the moment both `dotnet_sort_system_directives_first` and `dotnet_separate_import_directive_groups` rules are not exported when exporting overridden code style from Visual Studio to editorconfig. This PR will ensure both are exported.

EditorConfig-rules: https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference?view=vs-2017#net-formatting-settings</Description>
        <CreatedDate>14/03/2019</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>34440</PullRequestID>
        <IssueID>33766</IssueID>
        <Title>Settings for using directives not exported to .editorconfig</Title>
        <Description>**Version Used**: VS2019 dogfood

**Steps to Reproduce**:

1. Open Tools -&gt; Options
2. Configure settings on Text Editor -&gt; C# -&gt; Advanced for how to style using directives
    * Place 'System' directives first when sorting usings
    * Separate using directive groups
3. Switch to Code Style options and export .editorconfig settings

**Expected Behavior**:
These options for using directives should be exported (dotnet_sort_system_directives_first and dotnet_separate_import_directive_groups respectively)

**Actual Behavior**:
They are not exported to the .editorconfig file</Description>
        <CreatedDate>28/02/2019</CreatedDate>
        <ClosedDate>19/04/2019</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>34440</PullRequestID>
        <IssueID>30086</IssueID>
        <Title>Add support for generating current naming rules/options in the editorconfig generator</Title>
        <Description>See the discussion here: https://github.com/dotnet/roslyn/pull/30043#discussion_r219246165. Current editorconfig file generation only handles formatting and code style options, but we should extend it to generate entries for naming rules as well.</Description>
        <CreatedDate>20/09/2018</CreatedDate>
        <ClosedDate>19/04/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>34440</PullRequestID>
      <File>src/VisualStudio/Core/Impl/Options/GridOptionPreviewControl.xaml.cs</File>
      <File>src/Workspaces/Core/Portable/Diagnostics/Extensions.cs</File>
      <File>src/Workspaces/Core/Portable/Editing/GenerationOptions.cs</File>
      <File>src/Workspaces/Core/Portable/NamingStyles/EditorConfig/EditorConfigNamingStyleParser_NamingStyle.cs</File>
      <File>src/Workspaces/Core/Portable/NamingStyles/EditorConfig/EditorConfigNamingStyleParser_SymbolSpec.cs</File>
      <File>src/Workspaces/Core/Portable/Options/EditorConfig/EditorConfigFileGenerator.cs</File>
      <File>src/Workspaces/Core/Portable/WorkspacesResources.Designer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>33300</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Bad code for consecutive interface type tests with a when clause in a switch (dev16.0)</Title>
    <Description>Fixes #32774

This was previously reviewed and approved by reviewers at #32808

See also https://devdiv.visualstudio.com/DevDiv/_workitems/edit/792969 for shiproom purposes.

/cc @jaredpar </Description>
    <CreatedDate>11/02/2019</CreatedDate>
    <ClosedDate>15/02/2019</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>33300</PullRequestID>
        <IssueID>32774</IssueID>
        <Title>Visual Studio 2019 Preview 2 breaks Switch Case with when Statements</Title>
        <Description>**Version Used**: 
Visual Studio 2019 Preview 2

**Steps to Reproduce**:
Certain switch case statements including a when clause stopped working since updating to VS 2019 Preview 2.

The following statement will fail for every case that is not matched before the when clause:

        switch (someObject)
         {
            case string x:
               return true;
            case int x:
               return true;
            case IObject x when x.SubObject != null:
               return true;
            case IOtherObject x:
               return true;
            case double x:
               return true;
            default:
               return false;
         }

The following exception is thrown:  
_System.InvalidCastException: Unable to cast object of type 'System.Double' to type 'IOtherObject'._

However if you have an additional case just after the when where check without a condition it works fine:  

         switch (someObject)
         {
            case string x:
               return true;
            case int x:
               return true;
            case IObject x when x.SubObject != null:
               return true;
            case IObject x:
               return true;
            case IOtherObject x:
               return true;
            case double x:
               return true;
            default:
               return false;
         }

I uploaded a demo project to github that includes both cases and respective tests to showcase the problem:
https://github.com/huserben/VS19_SwitchCaseWhen

You can run the tests in VS 19 Preview 1 and one will fail, while both succeed if run from VS 2017

**Expected Behavior**:
Switch Case works in any of the cases
</Description>
        <CreatedDate>25/01/2019</CreatedDate>
        <ClosedDate>09/02/2019</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>33300</PullRequestID>
        <IssueID>32808</IssueID>
        <Title>Bad code for consecutive interface type tests with a when clause in a switch</Title>
        <Description>Fixes #32774

@dotnet/roslyn-compiler May I please have a couple of reviews for this bad code fix targeting preview 3?
</Description>
        <CreatedDate>25/01/2019</CreatedDate>
        <ClosedDate>09/02/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>33300</PullRequestID>
      <File>src/Compilers/CSharp/Portable/Binder/SwitchBinder_Patterns.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_BasePatternSwitchLocalRewriter.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/PatternTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>33291</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Reduce allocations in the formatter</Title>
    <Description>Builds on #33170 

This change reduces allocations in `AbstractFormatEngine.Format` by 70% (numbers before this change exceeded 10GiB while compiling Roslyn.sln).

| Item | Allocation fraction |
| --- | --- |
| Dictionary in TryGetEditorConfigOption | 39.6% |
| GetAdjustNewLinesOperation | 15.7% |
| ApplyTriviaOperations | 6.8% |
| TryGetOption | 4.4% |
| GetTrailingColonTrivia | 1.7% |
| ColonTriviaFollowedByLineContinuation (#33170) | 1.6% |
| PartOfMultilineLambdaFooter | 0.9% |</Description>
    <CreatedDate>11/02/2019</CreatedDate>
    <ClosedDate>12/02/2019</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>33291</PullRequestID>
        <IssueID>33170</IssueID>
        <Title>Remove dead code</Title>
        <Description>Closes #32964

I was not able to find a case where the IDE clearly misbehaves over this. Of particular relevance:

1. The use of `:_` at the end of a line produces a compiler error that `_` must be followed by a whitespace
2. Formatting a document containing `: _` at the end of a line results in both characters getting removed</Description>
        <CreatedDate>06/02/2019</CreatedDate>
        <ClosedDate>11/02/2019</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>33291</PullRequestID>
        <IssueID>33170</IssueID>
        <Title>Remove dead code</Title>
        <Description>Closes #32964

I was not able to find a case where the IDE clearly misbehaves over this. Of particular relevance:

1. The use of `:_` at the end of a line produces a compiler error that `_` must be followed by a whitespace
2. Formatting a document containing `: _` at the end of a line results in both characters getting removed</Description>
        <CreatedDate>06/02/2019</CreatedDate>
        <ClosedDate>11/02/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>33291</PullRequestID>
      <File>src/CodeStyle/Core/Analyzers/Options/AnalyzerConfigOptionsExtensions.cs</File>
      <File>src/Compilers/Core/Portable/InternalUtilities/PerformanceSensitiveAttribute.cs</File>
      <File>src/Workspaces/CSharp/Portable/Formatting/Engine/Trivia/TriviaDataFactory.ComplexTrivia.cs</File>
      <File>src/Workspaces/CSharp/Portable/Formatting/Engine/Trivia/TriviaDataFactory.FormattedComplexTrivia.cs</File>
      <File>src/Workspaces/CSharp/Portable/Formatting/Engine/Trivia/TriviaDataFactory.ModifiedComplexTrivia.cs</File>
      <File>src/Workspaces/Core/Portable/Formatting/Engine/AbstractFormatEngine.OperationApplier.cs</File>
      <File>src/Workspaces/Core/Portable/Formatting/Engine/AbstractFormatEngine.Partitioner.cs</File>
      <File>src/Workspaces/Core/Portable/Formatting/Engine/AbstractFormatEngine.cs</File>
      <File>src/Workspaces/Core/Portable/Formatting/Engine/AbstractTriviaDataFactory.FormattedWhitespace.cs</File>
      <File>src/Workspaces/Core/Portable/Formatting/Engine/AbstractTriviaDataFactory.ModifiedWhitespace.cs</File>
      <File>src/Workspaces/Core/Portable/Formatting/Engine/AbstractTriviaDataFactory.Whitespace.cs</File>
      <File>src/Workspaces/Core/Portable/Formatting/Engine/TriviaData.cs</File>
      <File>src/Workspaces/Core/Portable/Options/EditorConfig/EditorConfigStorageLocation`1.cs</File>
      <File>src/Workspaces/Core/Portable/Shared/Extensions/SyntaxTriviaListExtensions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>33279</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Fix parsing regression of expressions involving parens when used as a case expression or a constant pattern.</Title>
    <Description>- Fix parsing regression of expressions involving parens when used as a case expression or a constant pattern.
Fixes #33054
Fixes #33208
- Incidentally also correct and test the precedence of the switch expression
See https://github.com/dotnet/csharplang/blob/master/proposals/patterns.md#switch-expression for the spec.
- Fix terminology to match the spec - "conditional expression" rather than "ternary expression".

See also https://devdiv.visualstudio.com/DevDiv/_workitems/edit/792975 for shiproom purposes.

@dotnet/roslyn-compiler May I please have a couple of reviews of this parsing regression?
</Description>
    <CreatedDate>11/02/2019</CreatedDate>
    <ClosedDate>15/02/2019</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>33279</PullRequestID>
        <IssueID>33054</IssueID>
        <Title>[x64](3.0.100-preview-010184) Switch expression bug</Title>
        <Description>Hi

Looks like the new pattern matching feature broke old style switch expression

https://github.com/rds1983/StbImageSharp/blob/master/src/StbImageSharp/PngDecoder.cs#L714

Doesn't compile anymore 

```
  PngDecoder.cs(714, 38): [CS1003] Syntax error, ':' expected
  PngDecoder.cs(714, 70): [CS1002] ; expected
  PngDecoder.cs(714, 70): [CS1513] } expected
  PngDecoder.cs(718, 39): [CS1003] Syntax error, ',' expected
  PngDecoder.cs(774, 39): [CS1003] Syntax error, ',' expected
  PngDecoder.cs(793, 39): [CS1003] Syntax error, ',' expected
  PngDecoder.cs(842, 39): [CS1003] Syntax error, ',' expected
  PngDecoder.cs(878, 39): [CS1003] Syntax error, ',' expected
```</Description>
        <CreatedDate>01/02/2019</CreatedDate>
        <ClosedDate>15/02/2019</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>33279</PullRequestID>
        <IssueID>33208</IssueID>
        <Title>Breaking: case no longer works with constant expressions</Title>
        <Description>**Version Used**: VisualStudio.16.Preview/16.0.0-pre.2.1+28529.54

**Steps to Reproduce**:
Switching on an integer variable:
`case ((2) + (2)):` and `case ((2 + 2) - 2):`
```
(3,10): error CS8370: Feature 'recursive patterns' is not available in C# 7.3. Please use language version 8.0 or greater.
(3,15): error CS1003: Chyba syntaxe; oƒçek√°v√°na hodnota: ,
```

`case (2) | (2):` or `case ((2 &lt;&lt; 2) | 2):`
```
(3,20): error CS1026: Oƒçek√°v√° se ).
(3,20): error CS1003: Chyba syntaxe; oƒçek√°v√°na hodnota: :
(3,20): error CS1525: Neplatn√Ω v√Ωraz |
(3,23): error CS1002: Oƒçek√°val se st≈ôedn√≠k (;).
(3,23): error CS1513: Oƒçek√°val se znak }.
```

All cases above work in VS 2017.

(Sorry for non-English exceptions which is probably unrelated regression in VS2019.)</Description>
        <CreatedDate>07/02/2019</CreatedDate>
        <ClosedDate>15/02/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>33279</PullRequestID>
      <File>src/Compilers/CSharp/Portable/Binder/Binder.ValueChecks.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Operators.cs</File>
      <File>src/Compilers/CSharp/Portable/CSharpResources.Designer.cs</File>
      <File>src/Compilers/CSharp/Portable/CodeGen/EmitExpression.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/ErrorCode.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/NullableWalker.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_ConditionalAccess.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/LanguageParser.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/LanguageParser_Patterns.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/PatternParsingTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>33262</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Ensure that MSBuildWorkspace deals with duplicate ProjectReferences</Title>
    <Description>The workspace isn't supposed to allow duplicate ProjectReferences, but currently due to #12101 it does. This dedups (correctly) at the surface and also adds a test to ensure this isn't broken.

Fixes #31390. Further work will address #12101, but no matter how we address that it's good to have tests at the MSBuildWorkspace layer to make sure some additional bugs don't creep in there in it's processing.

Special thanks to @alexbuyn for #32557 that helped alert to the root cause here, and @aolszowka for also chiming in with a bit of details about their scenario to confirm this should help fix it.

&lt;details&gt;&lt;summary&gt;Ask Mode template&lt;/summary&gt;

### Customer scenario

Customer uses a tool built atop MSBuildWorkspace, and they have a project with duplicate ProjectReferences where the exact same project is being referenced twice in the exact same way. This tool will probably crash when ran on this solution.

### Bugs this fixes

#31390

### Workarounds, if any

Fix the duplicate project reference. Unfortunately the crash is deep within the CompilationTracker, which won't really hint to the user that anything is wrong.

### Risk

Very low, the actual core fix is just replacing an ImmutableArray with an ImmutableHashSet. This API is not used in Visual Studio and thus does not pose a risk there.

### Performance impact

None.

### Is this a regression from a previous update?

Not clear. The underlying Workspace bug is positively ancient.

### Root cause analysis

We didn't have any tests, and it wasn't obvious the underlying Workspace bug would actual result in crashes.

### How was the bug found?

Customer reports.

&lt;/details&gt;</Description>
    <CreatedDate>08/02/2019</CreatedDate>
    <ClosedDate>15/02/2019</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>33262</PullRequestID>
        <IssueID>12101</IssueID>
        <Title>Project.WithProjectReferences and friends allows you to give duplicate references</Title>
        <Description>We guard against duplicate references being created in Project.AddProjectReferences and similar APIs, but no similar guarding is done if you call WithProjectReferences. It seems the checks should be added there instead.
</Description>
        <CreatedDate>20/06/2016</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>33262</PullRequestID>
        <IssueID>31390</IssueID>
        <Title>System.ArgumentException in SolutionState.CompilationTracker.cs</Title>
        <Description>**Version Used**: Latest roslyn master sources

**Steps to Reproduce**:

1. Sync to latest roslyn master, assuming repo root here is `C:\roslyn`.
2. Build Roslyn.sln in Debug configuration
3. Build [AnalyzerRunner.csproj](https://github.com/dotnet/roslyn/blob/master/src/Tools/AnalyzerRunner/AnalyzerRunner.csproj)
4. Execute all IDE analyzers on Roslyn.sln using the following command from an admin command prompt: `C:\roslyn\Binaries\Debug\Exes\AnalyzerRunner\AnalyzerRunner.exe C:\roslyn\Binaries\Debug\Exes\AnalyzerRunner c:\roslyn\Roslyn.sln /concurrent`

**Expected Behavior**:
No exceptions

**Actual Behavior**:
`System.ArgumentException: An item with the same key has already been added.`
Also note that you might see assert from https://github.com/dotnet/roslyn/issues/31388

`.Add` invocation below seems to be throwing [here](http://source.roslyn.io/#Microsoft.CodeAnalysis.Workspaces/Workspace/Solution/SolutionState.CompilationTracker.cs,638) when processing `src\NuGet\VisualStudio\VS.ExternalAPIs.Roslyn.Package.csproj`:
```
                                var metadataReference = await solution.GetMetadataReferenceAsync(
                                    projectReference, this.ProjectState, cancellationToken).ConfigureAwait(false);
 
                                // A reference can fail to be created if a skeleton assembly could not be constructed.
                                if (metadataReference != null)
                                {
                                    newReferences.Add(metadataReference);
                                    metadataReferenceToProjectId.Add(metadataReference, projectReference.ProjectId);
                                }
                                else
                                {
                                    hasSuccessfullyLoaded = false;
                                }
```

**Call stack:**
```
Failed to analyze VS.ExternalAPIs.Roslyn.Package with System.ArgumentException: An item with the same key has already been added.
   at System.ThrowHelper.ThrowArgumentException(ExceptionResource resource)
   at System.Collections.Generic.Dictionary`2.Insert(TKey key, TValue value, Boolean add)
   at Microsoft.CodeAnalysis.SolutionState.CompilationTracker.&lt;FinalizeCompilationAsync&gt;d__30.MoveNext() in C:\roslyn_2\src\Workspaces\Core\Portable\Workspace\Solution\SolutionState.CompilationTracker.cs:line 638
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult()
   at Microsoft.CodeAnalysis.SolutionState.CompilationTracker.&lt;BuildCompilationInfoFromScratchAsync&gt;d__24.MoveNext() in C:\roslyn_2\src\Workspaces\Core\Portable\Workspace\Solution\SolutionState.CompilationTracker.cs:line 478
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult()
   at Microsoft.CodeAnalysis.SolutionState.CompilationTracker.&lt;GetOrBuildCompilationInfoAsync&gt;d__22.MoveNext() in C:\roslyn_2\src\Workspaces\Core\Portable\Workspace\Solution\SolutionState.CompilationTracker.cs:line 407
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult()
   at Microsoft.CodeAnalysis.SolutionState.CompilationTracker.&lt;GetCompilationSlowAsync&gt;d__19.MoveNext() in C:\roslyn_2\src\Workspaces\Core\Portable\Workspace\Solution\SolutionState.CompilationTracker.cs:line 316
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult()
   at AnalyzerRunner.Program.&lt;GetProjectAnalysisResultAsync&gt;d__10.MoveNext() in C:\roslyn_2\src\Tools\AnalyzerRunner\Program.cs:line 437
```</Description>
        <CreatedDate>27/11/2018</CreatedDate>
        <ClosedDate>15/02/2019</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>33262</PullRequestID>
        <IssueID>12101</IssueID>
        <Title>Project.WithProjectReferences and friends allows you to give duplicate references</Title>
        <Description>We guard against duplicate references being created in Project.AddProjectReferences and similar APIs, but no similar guarding is done if you call WithProjectReferences. It seems the checks should be added there instead.
</Description>
        <CreatedDate>20/06/2016</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>33262</PullRequestID>
        <IssueID>32557</IssueID>
        <Title>fix of the issue #24991</Title>
        <Description>Issue #24991 fix.
Avoid duplicates being added to the reference dictionary in SolutionState.CompilationTracker.cs

I'd like to discuss if proposed solution is acceptable. 
The other option is to throw exception with the meaningful error. In this case I think the code can continue to work without trouble, so its not neccessary to throw here. I may be wrong.

Also, the class is private and I can't really add unit tests to it easily. Any suggestions here will be appreciated.

tagging @DustinCampbell here as the one who was involved in the discussion of the issue.</Description>
        <CreatedDate>17/01/2019</CreatedDate>
        <ClosedDate>11/02/2019</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>33262</PullRequestID>
        <IssueID>31390</IssueID>
        <Title>System.ArgumentException in SolutionState.CompilationTracker.cs</Title>
        <Description>**Version Used**: Latest roslyn master sources

**Steps to Reproduce**:

1. Sync to latest roslyn master, assuming repo root here is `C:\roslyn`.
2. Build Roslyn.sln in Debug configuration
3. Build [AnalyzerRunner.csproj](https://github.com/dotnet/roslyn/blob/master/src/Tools/AnalyzerRunner/AnalyzerRunner.csproj)
4. Execute all IDE analyzers on Roslyn.sln using the following command from an admin command prompt: `C:\roslyn\Binaries\Debug\Exes\AnalyzerRunner\AnalyzerRunner.exe C:\roslyn\Binaries\Debug\Exes\AnalyzerRunner c:\roslyn\Roslyn.sln /concurrent`

**Expected Behavior**:
No exceptions

**Actual Behavior**:
`System.ArgumentException: An item with the same key has already been added.`
Also note that you might see assert from https://github.com/dotnet/roslyn/issues/31388

`.Add` invocation below seems to be throwing [here](http://source.roslyn.io/#Microsoft.CodeAnalysis.Workspaces/Workspace/Solution/SolutionState.CompilationTracker.cs,638) when processing `src\NuGet\VisualStudio\VS.ExternalAPIs.Roslyn.Package.csproj`:
```
                                var metadataReference = await solution.GetMetadataReferenceAsync(
                                    projectReference, this.ProjectState, cancellationToken).ConfigureAwait(false);
 
                                // A reference can fail to be created if a skeleton assembly could not be constructed.
                                if (metadataReference != null)
                                {
                                    newReferences.Add(metadataReference);
                                    metadataReferenceToProjectId.Add(metadataReference, projectReference.ProjectId);
                                }
                                else
                                {
                                    hasSuccessfullyLoaded = false;
                                }
```

**Call stack:**
```
Failed to analyze VS.ExternalAPIs.Roslyn.Package with System.ArgumentException: An item with the same key has already been added.
   at System.ThrowHelper.ThrowArgumentException(ExceptionResource resource)
   at System.Collections.Generic.Dictionary`2.Insert(TKey key, TValue value, Boolean add)
   at Microsoft.CodeAnalysis.SolutionState.CompilationTracker.&lt;FinalizeCompilationAsync&gt;d__30.MoveNext() in C:\roslyn_2\src\Workspaces\Core\Portable\Workspace\Solution\SolutionState.CompilationTracker.cs:line 638
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult()
   at Microsoft.CodeAnalysis.SolutionState.CompilationTracker.&lt;BuildCompilationInfoFromScratchAsync&gt;d__24.MoveNext() in C:\roslyn_2\src\Workspaces\Core\Portable\Workspace\Solution\SolutionState.CompilationTracker.cs:line 478
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult()
   at Microsoft.CodeAnalysis.SolutionState.CompilationTracker.&lt;GetOrBuildCompilationInfoAsync&gt;d__22.MoveNext() in C:\roslyn_2\src\Workspaces\Core\Portable\Workspace\Solution\SolutionState.CompilationTracker.cs:line 407
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult()
   at Microsoft.CodeAnalysis.SolutionState.CompilationTracker.&lt;GetCompilationSlowAsync&gt;d__19.MoveNext() in C:\roslyn_2\src\Workspaces\Core\Portable\Workspace\Solution\SolutionState.CompilationTracker.cs:line 316
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult()
   at AnalyzerRunner.Program.&lt;GetProjectAnalysisResultAsync&gt;d__10.MoveNext() in C:\roslyn_2\src\Tools\AnalyzerRunner\Program.cs:line 437
```</Description>
        <CreatedDate>27/11/2018</CreatedDate>
        <ClosedDate>15/02/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>33262</PullRequestID>
      <File>src/Workspaces/Core/MSBuild/MSBuild/MSBuildProjectLoader.Worker_ResolveReferences.cs</File>
      <File>src/Workspaces/CoreTest/SolutionTests/SolutionTests.cs</File>
      <File>src/Workspaces/CoreTest/WorkspaceTests/AdhocWorkspaceTests.cs</File>
      <File>src/Workspaces/CoreTest/WorkspaceTests/GeneralWorkspaceTests.cs</File>
      <File>src/Workspaces/DesktopTest/CommandLineProjectWorkspaceTests.cs</File>
      <File>src/Workspaces/MSBuildTest/FileSet.cs</File>
      <File>src/Workspaces/MSBuildTest/MSBuildWorkspaceTests.cs</File>
      <File>src/Workspaces/MSBuildTest/Resources/Issue30174/InspectedLibrary/InspectedClass.cs</File>
      <File>src/Workspaces/MSBuildTest/Resources/Issue30174/ReferencedLibrary/SomeMetadataAttribute.cs</File>
      <File>src/Workspaces/MSBuildTest/Resources/NetCoreApp2/Program.cs</File>
      <File>src/Workspaces/MSBuildTest/Resources/NetCoreApp2AndLibrary/Class1.cs</File>
      <File>src/Workspaces/MSBuildTest/Resources/NetCoreApp2AndLibrary/Program.cs</File>
      <File>src/Workspaces/MSBuildTest/Resources/NetCoreApp2AndTwoLibraries/Class1.cs</File>
      <File>src/Workspaces/MSBuildTest/Resources/NetCoreApp2AndTwoLibraries/Class2.cs</File>
      <File>src/Workspaces/MSBuildTest/Resources/NetCoreApp2AndTwoLibraries/Program.cs</File>
      <File>src/Workspaces/MSBuildTest/Resources/NetCoreMultiTFM/Program.cs</File>
      <File>src/Workspaces/MSBuildTest/Resources/NetCoreMultiTFM_ProjectReference/Class1.cs</File>
      <File>src/Workspaces/MSBuildTest/Resources/NetCoreMultiTFM_ProjectReference/Program.cs</File>
      <File>src/Workspaces/MSBuildTest/Resources/NetCoreMultiTFM_ProjectReferenceToFSharp/csharplib/Class1.cs</File>
      <File>src/Workspaces/MSBuildTest/Resources/NetCoreMultiTFM_ProjectReferenceWithReversedTFMs/Class1.cs</File>
      <File>src/Workspaces/MSBuildTest/Resources/NetCoreMultiTFM_ProjectReferenceWithReversedTFMs/Program.cs</File>
      <File>src/Workspaces/MSBuildTest/Resources/SourceFiles/CSharp/App.xaml.cs</File>
      <File>src/Workspaces/MSBuildTest/Resources/SourceFiles/CSharp/AssemblyInfo.cs</File>
      <File>src/Workspaces/MSBuildTest/Resources/SourceFiles/CSharp/CSharpClass.cs</File>
      <File>src/Workspaces/MSBuildTest/Resources/SourceFiles/CSharp/CSharpClass_WithConditionalAttributes.cs</File>
      <File>src/Workspaces/MSBuildTest/Resources/SourceFiles/CSharp/CSharpConsole.cs</File>
      <File>src/Workspaces/MSBuildTest/Resources/SourceFiles/CSharp/CSharpExternAlias.cs</File>
      <File>src/Workspaces/MSBuildTest/Resources/SourceFiles/CSharp/MainWindow.xaml.cs</File>
      <File>src/Workspaces/MSBuildTest/Resources/SourceFiles/CSharp/OtherStuff_Foo.cs</File>
      <File>src/Workspaces/MSBuildTest/TestFiles/Resources.cs</File>
      <File>src/Workspaces/MSBuildTest/WorkspaceTestBase.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>33221</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Call ProjectCodeModel.OnSourceFileRemoved when we remove files </Title>
    <Description>**REVIEW NOTE:** commit-at-a-time is highly recommended here.

In the project system refactoring to support free-threaded initialization, I lost this call which was causing removing and readding files to do bad things. This fixes it. The fix is more complicated than just adding the call back in, because we now allow document removal to happen on a background thread which we didn't allow before, and so bit of work that must happen on the UI thread must now be deferred until a later cleanup point.

Fixes #33080.

&lt;details&gt;&lt;summary&gt;Ask Mode template&lt;/summary&gt;

### Customer scenario

Customer deletes a Windows Form from a project, and then adds a new one with the same name. Rather than opening the designer again, the designer fails to load.

### Bugs this fixes

#33080

### Workarounds, if any

After you get into this state, restart Visual Studio.

### Risk

Moderate; the area we're touching (CodeModel object lifetimes) is always tricky, but since it's an API that many features are built on a lot of not obvious things might be broken.

### Performance impact

None.

### Is this a regression from a previous update?

Yes, this was broken in our big project system refactoring to improve performance in Preview 1.

### Root cause analysis

We didn't have any tests that tested CodeModel object life times. We've added functional tests to test that.

### How was the bug found?

Customer report.

&lt;/details&gt;</Description>
    <CreatedDate>07/02/2019</CreatedDate>
    <ClosedDate>15/02/2019</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>33221</PullRequestID>
        <IssueID>33080</IssueID>
        <Title>Error opening form designer of deleted and re-created form in VS 2019 Preview 2.1</Title>
        <Description>**Version Used**: Visual Studio 2019 Preview 2.1

**Steps to Reproduce**:

1. Create Windows Form VB.NET (or C#) project. Form1.vb file is created and its designer window is opened correctly
2. Delete Form1.vb in Solution Explorer
3. Right-click the project and select Add &gt; Windows Form... menu
4. Type Form1.vb as the name (same name than deleted form)

**Expected Behavior**:
The designer window of Form1.vb should be opened without errors, like the time when it was created by default.

**Actual Behavior**:
The designer window shows the error "Error HRESULT E_FAIL has been returned from a call to a COM component.". See attached image. The call stack of that error shows:

at System.Runtime.InteropServices.Marshal.ThrowExceptionForHRInternal(Int32 errorCode, IntPtr errorInfo) at Microsoft.VisualStudio.LanguageServices.Implementation.Utilities.Exceptions.ThrowEFail() at Microsoft.VisualStudio.LanguageServices.Implementation.CodeModel.FileCodeModel.GetDocument() at Microsoft.VisualStudio.LanguageServices.Implementation.CodeModel.FileCodeModel.GetSyntaxRoot() at Microsoft.VisualStudio.LanguageServices.Implementation.CodeModel.Collections.NamespaceCollection.LookupNode() at Microsoft.VisualStudio.LanguageServices.Implementation.CodeModel.Collections.NamespaceCollection.CreateSnapshot() at Microsoft.VisualStudio.LanguageServices.Implementation.CodeModel.Collections.AbstractCodeElementCollection.GetEnumerator() at EnvDTE.CodeElements.GetEnumerator() at Microsoft.VisualStudio.Design.Serialization.CodeDom.VSCodeDomParser.Parse(TextReader codeStream) at Microsoft.VisualStudio.Design.Serialization.CodeDom.MergedCodeDomParser.System.CodeDom.Compiler.ICodeParser.Parse(TextReader stream) at System.CodeDom.Compiler.CodeDomProvider.Parse(TextReader codeStream) at Microsoft.VisualStudio.Shell.Design.Serialization.CodeDom.CodeDomDocDataAdapter.get_CompileUnit() at Microsoft.VisualStudio.Design.Serialization.CodeDom.VSCodeDomDesignerLoader.PerformLoad(IDesignerSerializationManager serializationManager) at Microsoft.VisualStudio.Design.Serialization.CodeDom.VSCodeDomDesignerLoader.DeferredLoadHandler.Microsoft.VisualStudio.TextManager.Interop.IVsTextBufferDataEvents.OnLoadCompleted(Int32 fReload)

![error](https://user-images.githubusercontent.com/10756684/52179124-99e64380-27d6-11e9-90b4-9c6fb5aea358.png)
</Description>
        <CreatedDate>03/02/2019</CreatedDate>
        <ClosedDate>15/02/2019</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>33221</PullRequestID>
        <IssueID>33080</IssueID>
        <Title>Error opening form designer of deleted and re-created form in VS 2019 Preview 2.1</Title>
        <Description>**Version Used**: Visual Studio 2019 Preview 2.1

**Steps to Reproduce**:

1. Create Windows Form VB.NET (or C#) project. Form1.vb file is created and its designer window is opened correctly
2. Delete Form1.vb in Solution Explorer
3. Right-click the project and select Add &gt; Windows Form... menu
4. Type Form1.vb as the name (same name than deleted form)

**Expected Behavior**:
The designer window of Form1.vb should be opened without errors, like the time when it was created by default.

**Actual Behavior**:
The designer window shows the error "Error HRESULT E_FAIL has been returned from a call to a COM component.". See attached image. The call stack of that error shows:

at System.Runtime.InteropServices.Marshal.ThrowExceptionForHRInternal(Int32 errorCode, IntPtr errorInfo) at Microsoft.VisualStudio.LanguageServices.Implementation.Utilities.Exceptions.ThrowEFail() at Microsoft.VisualStudio.LanguageServices.Implementation.CodeModel.FileCodeModel.GetDocument() at Microsoft.VisualStudio.LanguageServices.Implementation.CodeModel.FileCodeModel.GetSyntaxRoot() at Microsoft.VisualStudio.LanguageServices.Implementation.CodeModel.Collections.NamespaceCollection.LookupNode() at Microsoft.VisualStudio.LanguageServices.Implementation.CodeModel.Collections.NamespaceCollection.CreateSnapshot() at Microsoft.VisualStudio.LanguageServices.Implementation.CodeModel.Collections.AbstractCodeElementCollection.GetEnumerator() at EnvDTE.CodeElements.GetEnumerator() at Microsoft.VisualStudio.Design.Serialization.CodeDom.VSCodeDomParser.Parse(TextReader codeStream) at Microsoft.VisualStudio.Design.Serialization.CodeDom.MergedCodeDomParser.System.CodeDom.Compiler.ICodeParser.Parse(TextReader stream) at System.CodeDom.Compiler.CodeDomProvider.Parse(TextReader codeStream) at Microsoft.VisualStudio.Shell.Design.Serialization.CodeDom.CodeDomDocDataAdapter.get_CompileUnit() at Microsoft.VisualStudio.Design.Serialization.CodeDom.VSCodeDomDesignerLoader.PerformLoad(IDesignerSerializationManager serializationManager) at Microsoft.VisualStudio.Design.Serialization.CodeDom.VSCodeDomDesignerLoader.DeferredLoadHandler.Microsoft.VisualStudio.TextManager.Interop.IVsTextBufferDataEvents.OnLoadCompleted(Int32 fReload)

![error](https://user-images.githubusercontent.com/10756684/52179124-99e64380-27d6-11e9-90b4-9c6fb5aea358.png)
</Description>
        <CreatedDate>03/02/2019</CreatedDate>
        <ClosedDate>15/02/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>33221</PullRequestID>
      <File>src/VisualStudio/Core/Def/Implementation/CodeModel/IProjectCodeModel.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/CodeModel/IProjectCodeModelFactory.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/InvisibleEditor.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/Legacy/AbstractLegacyProject.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/VisualStudioWorkspaceImpl.cs</File>
      <File>src/VisualStudio/Core/Impl/CodeModel/AbstractCodeModelObject.cs</File>
      <File>src/VisualStudio/Core/Impl/CodeModel/CodeModelProjectCache.cs</File>
      <File>src/VisualStudio/Core/Impl/CodeModel/FileCodeModel.cs</File>
      <File>src/VisualStudio/Core/Impl/CodeModel/ProjectCodeModel.cs</File>
      <File>src/VisualStudio/Core/Impl/CodeModel/ProjectCodeModelFactory.cs</File>
      <File>src/VisualStudio/Core/Impl/ProjectSystem/CPS/CPSProject_IWorkspaceProjectContext.cs</File>
      <File>src/VisualStudio/Core/Impl/RoslynVisualStudioWorkspace.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>31065</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Handle errors in Inline Rename</Title>
    <Description>Extracted from #30733

This prevents the IDE from crashing when an Inline Rename operation triggers the problem described in #31074.</Description>
    <CreatedDate>09/11/2018</CreatedDate>
    <ClosedDate>09/11/2018</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>31065</PullRequestID>
        <IssueID>30733</IssueID>
        <Title>Added a way to inject dynamic file to workspace for component like ra‚Ä¶</Title>
        <Description>‚Ä¶zor.

through IDynamicFileInfoProvider and etc, external component such as razor should be able to provide us dynamic file (such as generated c# content for cshtml file) on the fly and let us know update on the content.

renamed Column to Character since Column should be only used when it accounts "tab". and count "tab" as tab size rather than just 1 char.

moved FAR to work on top of new set of APIs. it should now show things on html correctly

added support for code lens. but found 1 issue. without changing VS side, I can't fix filename. and without fixing filename, navigation won't work properly

...

need to add unit tests and etc. doens't work without project system and razor side changes yet.

![image](https://user-images.githubusercontent.com/1333179/47454003-e86d5600-d782-11e8-8c12-4b8b20b7cc80.png)
</Description>
        <CreatedDate>24/10/2018</CreatedDate>
        <ClosedDate>12/11/2018</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>31065</PullRequestID>
        <IssueID>31074</IssueID>
        <Title>Workspace.TryApplyChanges throwing not supported exception</Title>
        <Description>we have this in Workspace.TryApplyChanges
http://source.roslyn.io/#Microsoft.CodeAnalysis.Workspaces/Workspace/Workspace.cs,1168

that can throw if new solution contains changes the host can't support.

but, it doesn't looks like we actually handle the exception in Roslyn or host.

due to that, when such situation happens, we sometimes show infobar, or generic VS exception mesasge box or crash.

probably need to figure out how to handle it in VS.</Description>
        <CreatedDate>09/11/2018</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>31065</PullRequestID>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/Dashboard/Dashboard.xaml.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>31056</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Pattern-matching fixes for ITuple, short tuple patterns, and nulls</Title>
    <Description>* Implement LDM disambiguation rules for Deconstruct vs ITuple
* Permit 0-element and 1-element tuple patterns
Fixes #30962
Replaces #31027

* Handle null and nullable input for a var pattern with a tuple designation
Fixes #30906
Replaces #30935

* Don't report missing Deconstruct when there is more than one applicable Deconstruct
Fixes #31031
</Description>
    <CreatedDate>09/11/2018</CreatedDate>
    <ClosedDate>29/11/2018</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>31056</PullRequestID>
        <IssueID>30962</IssueID>
        <Title>Pattern-matching changes for short tuples</Title>
        <Description>Adjust the implementation of pattern-matching to reflect LDM [resolutions from 2018-11-05](https://github.com/dotnet/csharplang/issues/1054#issuecomment-436025050).  The last point will be included in the changes for https://github.com/dotnet/roslyn/issues/20648.

## Deconstruction vs ITuple

### **Proposed:**

1. If the type is a tuple type (any arity &gt;=0; see below), then use the tuple semantics
2. if the type has no accessible instance `Deconstruct`, and satisfies the `ITuple` deconstruct constraints, use `ITuple` semantics
3. Otherwise attempt `Deconstruct` semantics (instance or extension)

Alternative
1. If the type is a tuple type (any arity &gt;= 0; see below), then use the tuple semantics
2. If "binding" a Deconstruct invocation would finds one or more applicable methods, use Deconstruct.
3. if the satisfies the `ITuple` deconstruct constraints, use `ITuple` semantics

In both cases, 4. Error

***Decision***: Alternative

### Proposed:

1. Permit pattern-matching tuple patterns with 0 and 1 elements (appropriately disambiguated as previously decided)

``` c#
if (e is ()) ...

if (e is (1) _) ...
if (e is (x: 1)) ...

if (e is (1, 2)) ...
```

***Conclusion***: Approved


### Proposed:

As part of this, I propose that we consider `System.ValueTuple&lt;T&gt;` instantitations to be considered tuple types.  I do not propose any syntax changes related to this.

As part of this, I propose that we consider `System.ValueTuple` to be considered a tuple type.  I do not propose any syntax changes related to this.

***Conclusion***: Approved
</Description>
        <CreatedDate>05/11/2018</CreatedDate>
        <ClosedDate>30/11/2018</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>31056</PullRequestID>
        <IssueID>31027</IssueID>
        <Title>Support 0-element and 1-element tuple patterns</Title>
        <Description>Fixes #30962
Unfortunately we cannot test binding `var ()` and `var (x)` until #30935 has been integrated
</Description>
        <CreatedDate>07/11/2018</CreatedDate>
        <ClosedDate>08/11/2018</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>31056</PullRequestID>
        <IssueID>30906</IssueID>
        <Title>Matching nullables with var pattern</Title>
        <Description>**Version Used**: features/recursive-patterns

**Steps to Reproduce**:

```cs
using System;
class C {
    extern static (int, int)? Get();   

    static void Test() {
        if (Get() is var (x, y)) {
            Console.Write(x);   
            Console.Write(y);   
        }
    }
}
```


**Expected Behavior**: Should check for HasValue and deconstruct.

**Actual Behavior**: Error.

Note: should work for any deconstructible, not just tuples.
Note: in effect, this should be equivalent to the `(var x, var y)` pattern.

</Description>
        <CreatedDate>01/11/2018</CreatedDate>
        <ClosedDate>29/11/2018</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>31056</PullRequestID>
        <IssueID>30935</IssueID>
        <Title>Handle null and nullable input for a var pattern with a tuple designation</Title>
        <Description>Fixes #30906</Description>
        <CreatedDate>02/11/2018</CreatedDate>
        <ClosedDate>08/11/2018</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>31056</PullRequestID>
        <IssueID>31031</IssueID>
        <Title>"No suitable Deconstruct instance or extension method was found" is incorrect</Title>
        <Description>Compiling the following reports (among other things) that `CS8129 No suitable Deconstruct instance or extension method was found for type 'IA', with 2 out parameters and a void return type.`

``` c#
using System;

class Program
{
    static void Main()
    {
        IA a = new A();
        (var x, var y) = a;
    }
}
interface I1
{
    void Deconstruct(out int X, out int Y);
}
interface I2
{
    void Deconstruct(out int X, out int Y);
}
interface IA : I1, I2 { }
class A : IA, I1, I2
{
    void I1.Deconstruct(out int X, out int Y) =&gt; (X, Y) = (3, 4);
    void I2.Deconstruct(out int X, out int Y) =&gt; (X, Y) = (7, 8);
}
```

However, there are indeed suitable `Deconstruct` instance methods for type `IA`. In fact there are too many of them. This diagnostic is simply incorrect.
</Description>
        <CreatedDate>07/11/2018</CreatedDate>
        <ClosedDate>29/11/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>31056</PullRequestID>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Deconstruct.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Expressions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Invocation.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Patterns.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Statements.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/DecisionDagBuilder.cs</File>
      <File>src/Compilers/CSharp/Portable/CSharpResources.Designer.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/ErrorCode.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/LanguageParser.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/LanguageParser_Patterns.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/BetterCandidates.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/DeconstructionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests2.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests4.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/RefEscapingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/PatternParsingTests.cs</File>
      <File>src/Workspaces/CSharpTest/EmbeddedLanguages/VirtualChars/CSharpVirtualCharServiceTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>31046</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Fixing inferred type for yield return in async iterator methods</Title>
    <Description>Towards #24037:
&gt; ## Productivity (code fixers/refactorings/etc):
&gt;  Review TypeInferrer #30211 (comment)

The fix is just to return the type argument, not matter what the type is. I think that's actually good for error recovery, in case someone is just missing a `using`.

Tagging @jcouv</Description>
    <CreatedDate>08/11/2018</CreatedDate>
    <ClosedDate>28/11/2018</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>31046</PullRequestID>
        <IssueID>24037</IssueID>
        <Title>[Umbrella] Work items and test plan for async streams</Title>
        <Description>Proposal: https://github.com/dotnet/csharplang/blob/master/proposals/csharp-8.0/async-streams.md


## FAQ and known issues
- "missing ManualResetValueTaskSourceLogic": 
The preview1 compiler is looking for that type, but .NET Core 3 preview 1 contains `ManualResetValueTaskSourceCore`. The solution is to include this [code snippet](https://github.com/dotnet/coreclr/issues/21379#issuecomment-444473061) in your program. This will be fixed in preview2.
- enumerator disposed too early (`yield return` in construct with `finally`) (see issue https://github.com/dotnet/roslyn/issues/31268)
- `NullableReferenceTypes` project property doesn't take full effect in legacy projects yet (https://github.com/dotnet/project-system/issues/4058) 

----


## Async-iterator methods
- [x] EnC
  - [x] ~~block~~
  - [x] enable (issue https://github.com/dotnet/roslyn/issues/32266, issue https://github.com/dotnet/roslyn/issues/32589 for `await using` declarations)
- [x] making cancellation token available to producers (PRs https://github.com/dotnet/roslyn/pull/35121 and https://github.com/dotnet/roslyn/pull/35326, API proposal https://github.com/dotnet/corefx/issues/37012)
- [ ] Consider optimizing handling of `yield return` when directly following another `yield return` (to reduce cost in `ManualResetValueTaskSourceCore.SetResult`) (issue https://github.com/dotnet/roslyn/issues/31248, needs LDM)
- [ ] Factor the implementation of `GetStatus` and `OnCompleted` for implementing `IValueTaskSource` and `IValueTaskSource&lt;bool&gt;` https://github.com/dotnet/roslyn/issues/31517
- [ ] Test `goto`, `continue`, `break`
- [ ] Consider optimizing stack consumption https://github.com/dotnet/roslyn/issues/26567
- [ ] Improve message when missing `async` https://github.com/dotnet/roslyn/issues/31113
- [ ] test async method returning a custom type that derives from `IAsyncEnumerable&lt;T&gt;` and `IAsyncEnumerator&lt;T&gt;`.
- [x] BCL design
    - [x] ~~factor some code into a base type?~~ (no)
    - [x] ~~introduce new exception type?~~ (not needed at the moment)
    - [x] Any work needed for mono support? (issue https://github.com/mono/mono/issues/12019, PR https://github.com/mono/mono/pull/12674, `EnumeratorCancellation` issue https://github.com/mono/mono/issues/14454)
- [x] test spilling (maybe need to integrate with Neal's changes in patterns branch)
- [x] Get more test ideas from async method and iterator method tests
- [x] Debugging experience (issue https://github.com/dotnet/roslyn/issues/32246, fixed in preview3)
- [x] Consider adding a guard in `DisposeAsync()`: if state is `-1`, then throw. PR https://github.com/dotnet/roslyn/pull/31764
- [x] Optimize value returned from `MoveNextAsync()` if possible (issue https://github.com/dotnet/roslyn/issues/31246, PR https://github.com/dotnet/roslyn/pull/31645)
- [x] Add optional token to `GetAsyncEnumerator` API (PR https://github.com/dotnet/roslyn/pull/31624)
- [x] Should we add some guards for API mis-use? https://github.com/dotnet/roslyn/issues/30109
- [x] Generate token checks (answer: no)
- [x] Dispose on async-iterator with `finally` issue https://github.com/dotnet/roslyn/issues/30260, PR https://github.com/dotnet/roslyn/pull/31527
- [x] Confirm desired behavior for `DisposeAsync()`. it is ok to dispose before enumerating, and then you start enumerating?
- [x] Consider optimizing disposeModeField away when it isn't needed (answer: the optimization is not worth the loss of regularity)
- [x] Emit `AsyncIteratorStateMachineAttribute` PR https://github.com/dotnet/roslyn/pull/31553
- [x] Test scenario that uses `AwaitOnCompleted` instead of `AwaitUnsafeOnCompleted`
- [x] Adopt new BCL APIs (`AsyncIteratorMethodBuilder`, `ManualResetValueTaskSourceCore`, remove `IStrongBox&lt;T&gt;`) PR https://github.com/dotnet/roslyn/pull/31330
- [x] Returning `IAsyncEnumerator&lt;T&gt;` https://github.com/dotnet/roslyn/issues/31057, PR https://github.com/dotnet/roslyn/pull/31114
- [x] What do exception stack traces look like? Does the stack trace simplifier need to be updated?
- [x] Confirm `threadID` design (see https://github.com/dotnet/corefx/issues/3481)
- [x] `GetAsyncEnumerator()` method should make a new instance in some cases https://github.com/dotnet/roslyn/issues/30275, PR https://github.com/dotnet/roslyn/pull/31105
- [x] `IOperation` and `CFG` should not crash https://github.com/dotnet/roslyn/pull/30363
- [x] Update `IAsyncEnumerable` API https://github.com/dotnet/roslyn/pull/30280
- [x] hand-crafted prototype (https://github.com/jcouv/async-iterators/blob/master/src/Program.cs)
- [x] lowering implementation (https://github.com/dotnet/roslyn/pull/28218)
- [x] CoreCLR testing issue https://github.com/dotnet/coreclr/issues/20032
- [x] support generic methods
- [x] manual testing in IDE (setting up project references, typing, debugging)

## Async using and foreach
- [x] Design and fix IOperation and CFG support https://github.com/dotnet/roslyn/issues/30362
- [ ] test with ref struct iterator (issue https://github.com/dotnet/roslyn/issues/32794)
- [ ] pattern-based disposal should not even consider extensions (issue https://github.com/dotnet/roslyn/issues/32767)
- [ ] add test with pattern-based GetAsyncEnumerator with a Caller attribute on optional parameter (check LINQ behavior)
- [ ] Allow extension methods to contribute to pattern-based binding (issue https://github.com/dotnet/roslyn/issues/32289)
- [ ] Tweak message for `ERR_AwaitForEachMissingMemberWrongAsync`
- [ ] Implement semantic model API similar to `GetAwaitExpressionInfo`
- [ ] Test scripting
- [ ] Test subtleties of `SatisfiesForEachPattern` (special method of looking up `Current`)
- [ ] Test type that is both `IEnumerable&lt;T&gt;` and `IAsyncEnumerable&lt;T&gt;`.
- [ ] Test type that is both `IDisposable` and `IAsyncDisposable`.
- [x] Allow pattern-based disposal in `await foreach` and `await using` (issue https://github.com/dotnet/roslyn/issues/32316)
- [x] Async-enumerable returned by `ConfigureAwait`/`WithCancellation` not recognized by `await foreach` (issue https://github.com/dotnet/roslyn/issues/31609, PR https://github.com/dotnet/roslyn/pull/32233)
- [x] Pattern-based lookup should pass no argument for `CancellationToken` (issue https://github.com/dotnet/roslyn/issues/32111, PR https://github.com/dotnet/roslyn/pull/32184)
- [x] Integration with "enhanced using and foreach" feature https://github.com/dotnet/roslyn/issues/28588
- [x] Test/block expression trees (N/A because they are statements)
- [x] `IOperation` and `CFG` should not crash https://github.com/dotnet/roslyn/pull/30363
- [x] Use `await using` and `await foreach` syntax https://github.com/dotnet/roslyn/pull/30525
- [x] Update `IAsyncEnumerable` API https://github.com/dotnet/roslyn/pull/30280
- [x] Do we prefer pattern-based over interface-based? (I assume perf is better)
- [x] ~~Only convert/deconstruct when `TryGetNext` succeeded https://github.com/dotnet/roslyn/issues/30258~~
- [x] async using (PR https://github.com/dotnet/roslyn/pull/23961)
- [x] async foreach (PR https://github.com/dotnet/roslyn/pull/24750)
- [x] Update `IAsyncEnumerator.WaitForNextAsync` to return a `ValueTask&lt;bool&gt;`.
- [x] Pattern-based foreach should recognize task-like return from `WaitForNextAsync`
- [x] Verify debugging and sequence points
- [x] Handle `foreach await (ref x in ...) ...` (error, ` TestWithPattern_Ref`)
- [x] Test with missing well-known members, if not already covered
- [x] Pattern-based async-foreach should recognized `WaitForNextAsync` that returns a task-like.

## Productivity (code fixers/refactorings/etc):
- [x] ~~ExtractMethod doesn't work on parts of or entire async-iterator method body~~ (that's expected)
- [x] FindAllReferences (moved all FAR issues into https://github.com/dotnet/roslyn/issues/28228)
    - [x] it should find implicit references to `GetAwaiter` from an async-foreach or async-dispose. 
     - [x] it should find implicit references to `DisposeAsync` from an async-foreach or async-dispose. 
- [x] Verify FAR on `AsyncDispose` method
- [x] ~~decompilation feature in IDE~~ (we'll let ILSpy library fix this)
- [ ] Verify proper warnings if any involved member is obsolete (implicit conversions and such)
- [x] Code fixers: 
    - [x] fix `foreach` (by adding/removing `await`) depending on the collection type. (PR https://github.com/dotnet/roslyn/pull/33463)
    - [x] fix `using` (by adding/removing `await`) depending on resource type. (PR https://github.com/dotnet/roslyn/pull/33463)
    - [x] fix method declaration depending on presence/absence of `yield` or `await` (MakeMethodAsync PR https://github.com/dotnet/roslyn/pull/31846)
    - [x] using `foreach await` in non-async method should offer to convert the method to `async` https://github.com/dotnet/roslyn/pull/26632
- [x] IDE logic probably needs to be adjusted for completion inside `await using` and `await foreach`. For instance, see `IsLocalVariableDeclarationContext`.
- [x] Review TypeInferrer https://github.com/dotnet/roslyn/pull/30211#discussion_r221462807 (PR https://github.com/dotnet/roslyn/pull/31046)
- [x] parsing (PR https://github.com/dotnet/roslyn/pull/23866)
- [x] IDE completion and colorizing (https://github.com/dotnet/roslyn/pull/23960)
- [x] Verify highlighting for `async` and `await` (see https://github.com/dotnet/roslyn/pull/25037, PR https://github.com/dotnet/roslyn/pull/25056) (verified manually on method and local function)
- [x] Test with `ConvertForeachToFor` refactoring (verified manually, not triggered)

## LDM open issues:

- [ ] async LINQ
    - [ ] Parsing issue with `return from e in async-collection select await e + 1; // await isn't a keyword`
    - [ ] how does above scenario and `return from e in async-collection select e + 1;` lower into LINQ APIs? (the one with `await` involves `Task&lt;int&gt;` and the other one involves `int` directly) How many overloads of `Select` do we need?
- [ ] Should there be some helper method to convert from IEnumerable to IAsyncEnumerable, or from Task&lt;T&gt; to IAsyncEnumerable?
- [x] Should the generate token checks be in `GetAsyncEnumerator` or in `MoveNextAsync`? (if we do, we need to store the token and maybe dispose it too) (answer: no)
- [x] Revisit blocking off a word (either in parameter list, like `params`, or for variable name, like `value`) for token (answer: we're not going to use a keyword)
- [x] pattern-based `await using` should recognize a `DisposeAsync` method that returns a task-like (or only `ValueTask`)? (not applicable because no ref structs in async methods)
- [x] Should pattern-based `foreach` recognize `... GetAsyncEnumerator()` (without `CancellationToken`)? (yes, LDM 1/9)
- [x] What attributes should be emitted on async-iterator state machines? (answer: `AsyncIteratorStateMachineAttribute`)
- [x] cancellation of async-streams (both as consumer and producer) (see LDM 11/28)
- [x] confirm syntax for async foreach
- [x] Should we disallow `struct` async enumerator? (no, same as regular async, see ` TestWithPattern_WithStruct_MoveNextAsyncReturnsTask`)
- [x] Should `DisposeAsync` return a non-generic `ValueTask`, since there is now one? Or stick with `Task`?
- [x] Extension methods for `GetAsyncEnumerator`, `WaitForNextAsync`, and `TryGetNext` do not contribute. This mirrors behavior for regular `foreach`. But I'd like to confirm. (answer: this is probably something we want to support. Let's queue that for later in the implementation)
- [x] Should the pattern for async enumerators also recognize when a task-like is returned instead of `Task&lt;bool&gt;`? (answer: yes)
- [x] I think we'll need to block `dynamic` since there is no async counterpart to the non-generic `IEnumerable` that would convert `dynamic` to. (answer: seems ok)
- [x] Do we need `async` keyword on async iterator methods? I assume yes.
- [x] Since not enumerable lambdas, I assume the same for async-enumerable. (answer: correct. No async iterator lambda)
- [x] async-iterator without `yield` or `await`, should warn? (answer: without `yield` it's not recognized as an iterator, warn when no `await`)
- [x] I suspect we'll need to declare the loop variable differently: calling `TryGetNext` first, then checking `success` and only then dealing with conversions and deconstructions.

Championed issue: https://github.com/dotnet/csharplang/issues/43 (includes LDM notes)

## Test ideas for async foreach:
- [x] Verify that async-dispose doesn't have a similar bug with struct resource

## Test ideas for async using:
- [ ] Look up Lippert's blog on using with struct or generic type T
- [ ] Does the pattern or the interface get picked up first? Is it observable? (maybe if the pattern allows task-like returning method)

## Test ideas for async iterators:
- [ ] From Andy: we should have at least one test that runs using a non-trivial sync context. 
- [ ] From Andy: would it be useful to emit asserts for invalid/unexpected states for at least a little while? We could do it only for debug codegen.
- [x] Test with yield or await in try/catch/finally
- [ ] More tests with exception thrown in async-iterator
- [ ] There is a case in `GetIteratorElementType` with `IsDirectlyInIterator` that relates to speculation, needs testing
- [ ] yield break disallowed in finally and top-level script (see `BindYieldBreakStatement`); same for yield return (see `BindYieldReturnStatement`)
- [ ] binding for yield return (`BindYieldReturnStatement`) validates escape rules, needs testing
- [x] test yield in async lambda (still error)
- [ ] test with `IAsyncEnumerable&lt;dynamic&gt;`
- [ ] other tests with `dynamic`?
- [x] test should cover both case with `AwaitOnCompleted` and `AwaitUnsafeOnCompleted`
- [ ] test `async IAsyncEnumerable&lt;int&gt; M() { return TaskLike(); }`
- [ ] Can we avoid making `IAsyncEnumerable&lt;T&gt;` special from the start? Making mark it with an attribute like we did for task-like?
- [ ] Do some manual validation on debugging scenarios, including with exceptions (thrown after yield and after await).
- [ ] Test with one or both or the threadID APIs missing.


----
## BCL (Core)
- Add `DefaultCancellationAttribute` type: https://github.com/dotnet/corefx/issues/37012
- Design IAsyncEnumerable and supporting types to BCL: https://github.com/dotnet/corefx/issues/32640 
- Design IAsyncDisposable in BCL: https://github.com/dotnet/corefx/issues/32665
- Design for CancellationToken in IAsyncEnumerable: https://github.com/dotnet/corefx/issues/33338
PRs https://github.com/dotnet/coreclr/pull/20442 and https://github.com/dotnet/corefx/pull/33104
- Stack pretty printing https://github.com/dotnet/coreclr/pull/21103
- Add optional token to `GetAsyncEnumerator` API
- Add extension method `WithCancellation(...)` to call `GetAsyncEnumerator` and wrap the result into an `IAsyncEnumerable`
- AsyncIteratorStateMachineAttribute https://github.com/dotnet/corefx/issues/33770, PR https://github.com/dotnet/coreclr/pull/21313 (and using it https://github.com/dotnet/coreclr/pull/21396)
- Add `CancellationToken` to `GetAsyncEnumerator()` PR https://github.com/dotnet/coreclr/pull/21397, documentation https://github.com/dotnet/corefx/issues/33338#issuecomment-444728011
- Add `WithCancellation` design https://github.com/dotnet/corefx/issues/33909
- Add `IAsyncDisposable.ConfigureAwait` (PRs https://github.com/dotnet/coreclr/pull/22160 and https://github.com/dotnet/corefx/pull/34783)

## BCL (mono)
- Port types to mono (https://github.com/mono/mono/issues/12019)

## BCL (package)
- Add `EnumeratorCancellationAttribute` (PR https://github.com/dotnet/corefx/pull/37719)

-----
## References:
- [ValueTask](https://github.com/dotnet/corefx/blob/master/src/Common/src/CoreLib/System/Threading/Tasks/ValueTask.cs#L60)
- [IValueTaskSource](https://github.com/dotnet/corefx/blob/master/src/Common/src/CoreLib/System/Threading/Tasks/Sources/IValueTaskSource.cs) </Description>
        <CreatedDate>04/01/2018</CreatedDate>
        <ClosedDate>19/09/2019</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>31046</PullRequestID>
        <IssueID>30211</IssueID>
        <Title>Fixing bugs in C# TypeInferrer</Title>
        <Description>This PR simplifies the C# TypeInferrer and fixes 3 bugs along the way. The vast majority of additions are new tests. Can be reviewed commit by commit to see more granular changes and each of the 3 fixes individually.

Fixes #30232
Fixes #30235
Fixes #27647</Description>
        <CreatedDate>28/09/2018</CreatedDate>
        <ClosedDate>17/10/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>31046</PullRequestID>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/GenerateMethod/GenerateMethodTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/GenerateVariable/GenerateVariableTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/TypeInferrer/TypeInferrerTests.cs</File>
      <File>src/Workspaces/CSharp/Portable/LanguageServices/CSharpTypeInferenceService.TypeInferrer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>31036</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Add bunch of exclusions to dead code analysis for special methods</Title>
    <Description>Fixes #30886: Bail out on special serialization constructors and methods with certain special attributes indicating special usage.

Fixes #30887: Bail out on ShouldSerializeXXX and ResetXXX pattern that was also excluded from legacy FxCop implementation and seems to be common in real world code.

Fixes #30377 : Bail out on methods with signature matching event handlers, which are very common in Web apps.</Description>
    <CreatedDate>08/11/2018</CreatedDate>
    <ClosedDate>08/11/2018</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>31036</PullRequestID>
        <IssueID>30886</IssueID>
        <Title>"Private members are unused" fires on serialization constructors</Title>
        <Description>

#### Repro steps

``` VB
    Public Class ProjectReloadedException
        Inherits Exception

        Public Sub New()
            MyBase.New(My.Resources.Designer.PPG_ProjectReloadedSomePropertiesMayNotHaveBeenSet)
        End Sub

        ''' &lt;summary&gt;
        ''' Deserialization constructor.  Required for serialization/remotability support
        '''   (not that we expect this to be needed).
        ''' &lt;/summary&gt;
        ''' &lt;param name="Info"&gt;&lt;/param&gt;
        ''' &lt;param name="Context"&gt;&lt;/param&gt;
        ''' &lt;remarks&gt;
        '''See .NET Framework Developer's Guide, "Custom Serialization" for more information
        ''' &lt;/remarks&gt;
        Private Sub New(Info As SerializationInfo, Context As StreamingContext)
            MyBase.New(Info, Context)
        End Sub

    End Class
```

#### Expected behavior
Severity	Code	Description	Project	Project Rank	File	Line	Category	Suppression State	Tool
Message	IDE0051	Private member 'ProjectReloadedException..ctor' is unused.	Microsoft.VisualStudio.AppDesigner	2	E:\project-system2\src\Microsoft.VisualStudio.AppDesigner\PropPages\ProjectReloadedException.vb	32	Code Quality	Active	Compiler


#### Actual behavior
Should not fire</Description>
        <CreatedDate>31/10/2018</CreatedDate>
        <ClosedDate>08/11/2018</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>31036</PullRequestID>
        <IssueID>30887</IssueID>
        <Title>"Private members is unused" fires on ShouldSerializeXXX pattern</Title>
        <Description>#### Repro steps

``` VB
        &lt;VBDescription(My.Resources.Microsoft_VisualStudio_Editors_Designer.ConstantResourceIDs.PPG_WebReferenceNameDescription)&gt;
        &lt;MergableProperty(False)&gt;
        &lt;HelpKeyword("Folder Properties.FileName")&gt;
        Public Property Name() As String
            Get
                Try
                    Return _projectItem.Name
                Catch ex As Exception When Common.ReportWithoutCrash(ex, NameOf(Name), NameOf(WebReferenceComponent))
                    Return String.Empty
                End Try
            End Get
            Set(value As String)
                _projectItem.Name = value
                _page.OnWebReferencePropertyChanged(Me)
            End Set
        End Property

        ' Prevent using Bold Font in the property grid (the same style as other reference)
        Private Function ShouldSerializeName() As Boolean
            Return False
        End Function
```
#### Expected behavior
No warning on ShouldSerializeName()


#### Actual behavior
Severity	Code	Description	Project	File	Line	Suppression State
Message	IDE0051	Private member 'WebReferenceComponent.ShouldSerializeName' is unused.	Microsoft.VisualStudio.Editors	E:\project-system2\src\Microsoft.VisualStudio.Editors\PropPages\WebReferenceComponent.vb	41	Active


ShouldSerializeXXX is a pattern used by controls &amp; things that show up in the property grid that determines whether they are written to InitializeComponent for a WinForms component. The associated FxCop original rule has an exclusion for this.
</Description>
        <CreatedDate>30/10/2018</CreatedDate>
        <ClosedDate>08/11/2018</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>31036</PullRequestID>
        <IssueID>30377</IssueID>
        <Title>IDE0051 should not be reported for certain methods</Title>
        <Description>In ASP.NET web app `Application_Start` is marked as unused:

![image](https://user-images.githubusercontent.com/41759/46624509-d4b8c300-cae5-11e8-8c0a-4b1df4d2bec3.png)
</Description>
        <CreatedDate>08/10/2018</CreatedDate>
        <ClosedDate>08/11/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>31036</PullRequestID>
      <File>src/EditorFeatures/CSharpTest/RemoveUnusedMembers/RemoveUnusedMembersTests.cs</File>
      <File>src/Features/Core/Portable/RemoveUnusedMembers/AbstractRemoveUnusedMembersDiagnosticAnalyzer.cs</File>
      <File>src/Workspaces/Core/Portable/Shared/Extensions/ICompilationExtensions.cs</File>
      <File>src/Workspaces/Core/Portable/Shared/Extensions/IMethodSymbolExtensions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>31025</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Add CFG based dataflow analysis framework to the Workspaces layer</Title>
    <Description>This PR extracts out the flow-analysis component from #30777 for easier code review.

Support added in this PR:
1. Core dataflow walker to walk the control flow graph and compute/track custom analysis data (CustomDataFlowAnalysis).
2. Internal API (DataFlowAnalyzer) to implement custom dataflow analysis on top of the above walker.
3. Implementation of a SymbolUsageAnalysis dataflow analyzer to compute read/write usages for local and parameter symbols
4. Implementation of a test-only BasicBlockReachabilityDataFlowAnalyzer to compute and validate basic block reachability on all CFGs generated in compiler's flow analysis unit tests.

Please refer to #30777 for the unit tests for SymbolUsageAnalysis. This PR is targeting a feature branch, which will get unit tests from #30777 before it gets merged into master or dev16.0-preview2 branch.</Description>
    <CreatedDate>07/11/2018</CreatedDate>
    <ClosedDate>16/11/2018</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>31025</PullRequestID>
        <IssueID>30777</IssueID>
        <Title>Dataflow analysis based analyzer/fixer to identify unused expression values and parameters</Title>
        <Description>1. **Analyzer** to report unused expression values and parameters. It flags the following cases:
    1. **Expression statements that drop computed value**, for example, `Computation();`. These should either be removed (redundant computation) or should be replaced with explicit assignment to discard variable OR an unused local variable, i.e. `_ = Computation();` or `var unused = Computation();`
    2. **Value assignments to locals/parameters that are never used on any control flow path**. For example, value assigned to 'x' in first statement below is unused and will be flagged:
    ```
        x = Computation();
        if (...)
            x = Computation2();
        else
            Computation3(out x);
        ... = x;
    ```
    Just as for case 1 above, these should either be removed (redundant computation) or should be replaced with explicit assignment to discard variable OR an unused local i.e. `_ = Computation();` or `var unused = Computation();`

     3. **Redundant/unused parameters** that fall into one of the following two categories:
         1. Have no references in the executable code block(s) for it's containing method symbol.
         2. Have one or more references but it's initial value at start of code block is never used. For example, if 'x' in the example for case 2. above was a parameter symbol with `RefKind.None` and `x = Computation();` is the first statement in the method body, then it's initial value is never used. Such a parameter should be removed and 'x' should be converted into a local.
       We provide additional information in the diagnostic message to clarify the above two categories and also detect and mention about potential breaking change if the containing method is a public API. Currently, we do not provide any code fix for removing unused parameters as it needs fixing the call sites and any automated fix can lead to subtle overload resolution differences, though this may change in future.

2. **Code fixer** for unused expression value diagnostics reported by this analyzer providing following code fixes:
    1. If the unused value assigned to a local/parameter has no side-effects, we **recommend removing the assignment**. We consider an expression value to have no side effects if one of the following is true:
        1. Value is a compile time constant.
        2. Value is a local or parameter reference.
        3. Value is a field reference with no or implicit this instance.
    2. Otherwise, if user preference is set to Discard Variable, and project's language version supports discard variable, we **recommend assigning the value to discard**.
    3. Otherwise, we **recommend assigning the value to a new unused local variable which has no reads**.

3. **Implementation details:**
    1. Refactor and generalize the currently implemented reachability dataflow analysis in the compiler layer that works on internal CFG builder data types so that it works with custom data and public BasicBlock and ControlFlowBranch types.
    2. Move the above analysis into separate files that can be linked into both the Compiler and Workspaces layer to enable writing custom dataflow analysis in the IDE layer.
    3. The two primary (internal) types for implementing custom dataflow analysis are:
         1. `IDataFlowAnalyzer`: The dataflow analyzer type defines the custom data being tracked per basic block, the transfer and merge functions for dataflow across blocks and AnalyzeBlock and AnalyzerXXXBranch functions for analyzing dataflow within basic blocks and control flow branches.
         2. `CustomDataFlowAnalysis`: This types exposes a static method that runs dataflow analysis on the given control flow graph using the given dataflow analyzer, until fix point is reached and returns the analysis data at the end of the Exit block.
    4. Use the above dataflow framework to implement a custom reaching definition dataflow analysis to compute the set of reaching definitions (value writes) for local/parameter symbols in a method body, along with a boolean indicating whether or not each definition may be read on at least one possible control flow path, false indicating an unused/redundant definition that is flagged by the analyzer.
    
**TODO:** Finalize the editorconfig options for the analyzer/code fix and implement the Tools/Options UI for the same.</Description>
        <CreatedDate>26/10/2018</CreatedDate>
        <ClosedDate>27/11/2018</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>31025</PullRequestID>
        <IssueID>30777</IssueID>
        <Title>Dataflow analysis based analyzer/fixer to identify unused expression values and parameters</Title>
        <Description>1. **Analyzer** to report unused expression values and parameters. It flags the following cases:
    1. **Expression statements that drop computed value**, for example, `Computation();`. These should either be removed (redundant computation) or should be replaced with explicit assignment to discard variable OR an unused local variable, i.e. `_ = Computation();` or `var unused = Computation();`
    2. **Value assignments to locals/parameters that are never used on any control flow path**. For example, value assigned to 'x' in first statement below is unused and will be flagged:
    ```
        x = Computation();
        if (...)
            x = Computation2();
        else
            Computation3(out x);
        ... = x;
    ```
    Just as for case 1 above, these should either be removed (redundant computation) or should be replaced with explicit assignment to discard variable OR an unused local i.e. `_ = Computation();` or `var unused = Computation();`

     3. **Redundant/unused parameters** that fall into one of the following two categories:
         1. Have no references in the executable code block(s) for it's containing method symbol.
         2. Have one or more references but it's initial value at start of code block is never used. For example, if 'x' in the example for case 2. above was a parameter symbol with `RefKind.None` and `x = Computation();` is the first statement in the method body, then it's initial value is never used. Such a parameter should be removed and 'x' should be converted into a local.
       We provide additional information in the diagnostic message to clarify the above two categories and also detect and mention about potential breaking change if the containing method is a public API. Currently, we do not provide any code fix for removing unused parameters as it needs fixing the call sites and any automated fix can lead to subtle overload resolution differences, though this may change in future.

2. **Code fixer** for unused expression value diagnostics reported by this analyzer providing following code fixes:
    1. If the unused value assigned to a local/parameter has no side-effects, we **recommend removing the assignment**. We consider an expression value to have no side effects if one of the following is true:
        1. Value is a compile time constant.
        2. Value is a local or parameter reference.
        3. Value is a field reference with no or implicit this instance.
    2. Otherwise, if user preference is set to Discard Variable, and project's language version supports discard variable, we **recommend assigning the value to discard**.
    3. Otherwise, we **recommend assigning the value to a new unused local variable which has no reads**.

3. **Implementation details:**
    1. Refactor and generalize the currently implemented reachability dataflow analysis in the compiler layer that works on internal CFG builder data types so that it works with custom data and public BasicBlock and ControlFlowBranch types.
    2. Move the above analysis into separate files that can be linked into both the Compiler and Workspaces layer to enable writing custom dataflow analysis in the IDE layer.
    3. The two primary (internal) types for implementing custom dataflow analysis are:
         1. `IDataFlowAnalyzer`: The dataflow analyzer type defines the custom data being tracked per basic block, the transfer and merge functions for dataflow across blocks and AnalyzeBlock and AnalyzerXXXBranch functions for analyzing dataflow within basic blocks and control flow branches.
         2. `CustomDataFlowAnalysis`: This types exposes a static method that runs dataflow analysis on the given control flow graph using the given dataflow analyzer, until fix point is reached and returns the analysis data at the end of the Exit block.
    4. Use the above dataflow framework to implement a custom reaching definition dataflow analysis to compute the set of reaching definitions (value writes) for local/parameter symbols in a method body, along with a boolean indicating whether or not each definition may be read on at least one possible control flow path, false indicating an unused/redundant definition that is flagged by the analyzer.
    
**TODO:** Finalize the editorconfig options for the analyzer/code fix and implement the Tools/Options UI for the same.</Description>
        <CreatedDate>26/10/2018</CreatedDate>
        <ClosedDate>27/11/2018</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>31025</PullRequestID>
        <IssueID>30777</IssueID>
        <Title>Dataflow analysis based analyzer/fixer to identify unused expression values and parameters</Title>
        <Description>1. **Analyzer** to report unused expression values and parameters. It flags the following cases:
    1. **Expression statements that drop computed value**, for example, `Computation();`. These should either be removed (redundant computation) or should be replaced with explicit assignment to discard variable OR an unused local variable, i.e. `_ = Computation();` or `var unused = Computation();`
    2. **Value assignments to locals/parameters that are never used on any control flow path**. For example, value assigned to 'x' in first statement below is unused and will be flagged:
    ```
        x = Computation();
        if (...)
            x = Computation2();
        else
            Computation3(out x);
        ... = x;
    ```
    Just as for case 1 above, these should either be removed (redundant computation) or should be replaced with explicit assignment to discard variable OR an unused local i.e. `_ = Computation();` or `var unused = Computation();`

     3. **Redundant/unused parameters** that fall into one of the following two categories:
         1. Have no references in the executable code block(s) for it's containing method symbol.
         2. Have one or more references but it's initial value at start of code block is never used. For example, if 'x' in the example for case 2. above was a parameter symbol with `RefKind.None` and `x = Computation();` is the first statement in the method body, then it's initial value is never used. Such a parameter should be removed and 'x' should be converted into a local.
       We provide additional information in the diagnostic message to clarify the above two categories and also detect and mention about potential breaking change if the containing method is a public API. Currently, we do not provide any code fix for removing unused parameters as it needs fixing the call sites and any automated fix can lead to subtle overload resolution differences, though this may change in future.

2. **Code fixer** for unused expression value diagnostics reported by this analyzer providing following code fixes:
    1. If the unused value assigned to a local/parameter has no side-effects, we **recommend removing the assignment**. We consider an expression value to have no side effects if one of the following is true:
        1. Value is a compile time constant.
        2. Value is a local or parameter reference.
        3. Value is a field reference with no or implicit this instance.
    2. Otherwise, if user preference is set to Discard Variable, and project's language version supports discard variable, we **recommend assigning the value to discard**.
    3. Otherwise, we **recommend assigning the value to a new unused local variable which has no reads**.

3. **Implementation details:**
    1. Refactor and generalize the currently implemented reachability dataflow analysis in the compiler layer that works on internal CFG builder data types so that it works with custom data and public BasicBlock and ControlFlowBranch types.
    2. Move the above analysis into separate files that can be linked into both the Compiler and Workspaces layer to enable writing custom dataflow analysis in the IDE layer.
    3. The two primary (internal) types for implementing custom dataflow analysis are:
         1. `IDataFlowAnalyzer`: The dataflow analyzer type defines the custom data being tracked per basic block, the transfer and merge functions for dataflow across blocks and AnalyzeBlock and AnalyzerXXXBranch functions for analyzing dataflow within basic blocks and control flow branches.
         2. `CustomDataFlowAnalysis`: This types exposes a static method that runs dataflow analysis on the given control flow graph using the given dataflow analyzer, until fix point is reached and returns the analysis data at the end of the Exit block.
    4. Use the above dataflow framework to implement a custom reaching definition dataflow analysis to compute the set of reaching definitions (value writes) for local/parameter symbols in a method body, along with a boolean indicating whether or not each definition may be read on at least one possible control flow path, false indicating an unused/redundant definition that is flagged by the analyzer.
    
**TODO:** Finalize the editorconfig options for the analyzer/code fix and implement the Tools/Options UI for the same.</Description>
        <CreatedDate>26/10/2018</CreatedDate>
        <ClosedDate>27/11/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>31025</PullRequestID>
      <File>src/Compilers/Core/Portable/Operations/ControlFlowGraphBuilder.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/ControlFlowGraphVerifier.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/FlowAnalysis/BasicBlockReachabilityDataFlowAnalyzer.cs</File>
      <File>src/Workspaces/Core/Portable/Extensions/BasicBlockExtensions.cs</File>
      <File>src/Workspaces/Core/Portable/Extensions/ControlFlowGraphExtensions.cs</File>
      <File>src/Workspaces/Core/Portable/Extensions/ControlFlowRegionExtensions.cs</File>
      <File>src/Workspaces/Core/Portable/Extensions/OperationExtensions.cs</File>
      <File>src/Workspaces/Core/Portable/FlowAnalysis/CustomDataFlowAnalysis.cs</File>
      <File>src/Workspaces/Core/Portable/FlowAnalysis/DataFlowAnalyzer.cs</File>
      <File>src/Workspaces/Core/Portable/FlowAnalysis/LValueFlowCaptureProvider.cs</File>
      <File>src/Workspaces/Core/Portable/FlowAnalysis/SymbolUsageAnalysis/SymbolUsageAnalysis.AnalysisData.cs</File>
      <File>src/Workspaces/Core/Portable/FlowAnalysis/SymbolUsageAnalysis/SymbolUsageAnalysis.BasicBlockAnalysisData.cs</File>
      <File>src/Workspaces/Core/Portable/FlowAnalysis/SymbolUsageAnalysis/SymbolUsageAnalysis.DataFlowAnalyzer.FlowGraphAnalysisData.cs</File>
      <File>src/Workspaces/Core/Portable/FlowAnalysis/SymbolUsageAnalysis/SymbolUsageAnalysis.DataFlowAnalyzer.cs</File>
      <File>src/Workspaces/Core/Portable/FlowAnalysis/SymbolUsageAnalysis/SymbolUsageAnalysis.OperationTreeAnalysisData.cs</File>
      <File>src/Workspaces/Core/Portable/FlowAnalysis/SymbolUsageAnalysis/SymbolUsageAnalysis.Walker.cs</File>
      <File>src/Workspaces/Core/Portable/FlowAnalysis/SymbolUsageAnalysis/SymbolUsageAnalysis.cs</File>
      <File>src/Workspaces/Core/Portable/FlowAnalysis/SymbolUsageAnalysis/SymbolUsageResult.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>30980</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Workaround in RemoveUnusedMembersDiagnosticAnalyzer for VB handles cl‚Ä¶</Title>
    <Description>‚Ä¶ause

Fixes #30895

This analyzer does not function correctly in presence of VB handles clause due to IOperation bugs #30978 and #30979. This change adds a temporary workaround to the analyzer to handle this case specially.

~~TODO: File a bug to track reverting the temporary workaround once #30978 and #30979 are fixed.~~ Filed https://github.com/dotnet/roslyn/issues/30981</Description>
    <CreatedDate>06/11/2018</CreatedDate>
    <ClosedDate>08/11/2018</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>30980</PullRequestID>
        <IssueID>30895</IssueID>
        <Title>IDE0052 fires on WithEvents that are used by Handles</Title>
        <Description>``` VB
Private WithEvents _buildEvents As EnvDTE.BuildEvents
[...]

Private Sub BuildBegin(scope As EnvDTE.vsBuildScope, action As EnvDTE.vsBuildAction) Handles _buildEvents.OnBuildBegin

End Sub

```

Expected: No warning
Actual:

```
Severity	Code	Description	Project	Project Rank	File	Line	Category	Suppression State	Tool
Message	IDE0052	Private member 'ResourceEditorRootDesigner._buildEvents' can be removed as the value assigned to it is never read.	Microsoft.VisualStudio.Editors	3	E:\project-system2\src\Microsoft.VisualStudio.Editors\ResourceEditor\ResourceEditorRootDesigner.vb	70	Code Quality	Active	Compiler
```</Description>
        <CreatedDate>01/11/2018</CreatedDate>
        <ClosedDate>08/11/2018</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>30980</PullRequestID>
        <IssueID>30978</IssueID>
        <Title>SemanticModel.GetOperation fails for any node within the VB handles clause sub-tree</Title>
        <Description>Invoking `SemanticModel.GetOperation` on any node within the `HandlesClauseSyntax` returns null. For example, consider the below code:

```
Public Interface I
    Event M()
End Interface

Public Class C
    Private WithEvents _field1 As I

    Private Sub M() Handles _field1.M
    End Sub
End Class
```

![image](https://user-images.githubusercontent.com/10605811/48068201-0ffeee00-e187-11e8-99d2-f7c7096004f1.png)

This leads to no `IMemberReferenceOperation` generated for references to members within the handles clause, causing incorrect functioning for IOperation analyzers analyzing references to members. For example, see https://github.com/dotnet/roslyn/issues/30895

Investigating further, I found that this is due to the fact VB uses a special binder to [bind the handles clause](http://source.roslyn.io/#Microsoft.CodeAnalysis.VisualBasic/Symbols/Source/SourceMemberMethodSymbol.vb,584), which is not part of the binder chain, and there is no corresponding member semantic model for positions within the handles clause.</Description>
        <CreatedDate>06/11/2018</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>30980</PullRequestID>
        <IssueID>30979</IssueID>
        <Title>AnalyzerDriver does should add executable code blocks for VB handles clause</Title>
        <Description>There are couple of compiler/analyzer issues related to IOperations in regards to VB handles clause:

1. https://github.com/dotnet/roslyn/issues/30978: Core bug in `GetOperation` causing the compiler to never return operations within VB handles clause.
2. `VisualBasicDeclarationComputer.vb` never marks nodes within VB handles clause as executable code, which leads to the analyzer driver never attempting to invoke GetOperation within these nodes, and hence never making analyzer callbacks for operations within handles clause. https://github.com/mavasani/roslyn/commit/8e3e8e83751f2118c27bd866b4785b1f347d7658 fixes this issue, but needs to go in after https://github.com/dotnet/roslyn/issues/30978 has been fixed.

This bug tracks issue 2. above in the VB declaration computer.</Description>
        <CreatedDate>06/11/2018</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>30980</PullRequestID>
        <IssueID>30978</IssueID>
        <Title>SemanticModel.GetOperation fails for any node within the VB handles clause sub-tree</Title>
        <Description>Invoking `SemanticModel.GetOperation` on any node within the `HandlesClauseSyntax` returns null. For example, consider the below code:

```
Public Interface I
    Event M()
End Interface

Public Class C
    Private WithEvents _field1 As I

    Private Sub M() Handles _field1.M
    End Sub
End Class
```

![image](https://user-images.githubusercontent.com/10605811/48068201-0ffeee00-e187-11e8-99d2-f7c7096004f1.png)

This leads to no `IMemberReferenceOperation` generated for references to members within the handles clause, causing incorrect functioning for IOperation analyzers analyzing references to members. For example, see https://github.com/dotnet/roslyn/issues/30895

Investigating further, I found that this is due to the fact VB uses a special binder to [bind the handles clause](http://source.roslyn.io/#Microsoft.CodeAnalysis.VisualBasic/Symbols/Source/SourceMemberMethodSymbol.vb,584), which is not part of the binder chain, and there is no corresponding member semantic model for positions within the handles clause.</Description>
        <CreatedDate>06/11/2018</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>30980</PullRequestID>
        <IssueID>30979</IssueID>
        <Title>AnalyzerDriver does should add executable code blocks for VB handles clause</Title>
        <Description>There are couple of compiler/analyzer issues related to IOperations in regards to VB handles clause:

1. https://github.com/dotnet/roslyn/issues/30978: Core bug in `GetOperation` causing the compiler to never return operations within VB handles clause.
2. `VisualBasicDeclarationComputer.vb` never marks nodes within VB handles clause as executable code, which leads to the analyzer driver never attempting to invoke GetOperation within these nodes, and hence never making analyzer callbacks for operations within handles clause. https://github.com/mavasani/roslyn/commit/8e3e8e83751f2118c27bd866b4785b1f347d7658 fixes this issue, but needs to go in after https://github.com/dotnet/roslyn/issues/30978 has been fixed.

This bug tracks issue 2. above in the VB declaration computer.</Description>
        <CreatedDate>06/11/2018</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>30980</PullRequestID>
      <File>src/Features/Core/Portable/RemoveUnusedMembers/AbstractRemoveUnusedMembersDiagnosticAnalyzer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>30969</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Add regression test for attribute with async delegate parameter</Title>
    <Description>Resolves #30833 

This test should prevent the error described in #30833 from recurring. It **passes on master** but on the **15.9 branch** it produces the following error:

```
Microsoft.CodeAnalysis.CSharp.UnitTests.AttributeTests.AttributeWithTaskDelegateParameter [FAIL]
    System.AggregateException : One or more errors occurred.
    ---- System.AggregateException : One or more errors occurred.
    -------- System.NullReferenceException : Object reference not set to an instance of an object.
    Stack Trace:
        at System.Threading.Tasks.Task.ThrowIfExceptional(Boolean includeTaskCanceledExceptions)
        at System.Threading.Tasks.Task.Wait(Int32 millisecondsTimeout, CancellationToken cancellationToken)
        at System.Threading.Tasks.Parallel.ForWorker[TLocal](Int32 fromInclusive, Int32 toExclusive, ParallelOptions parallelOptions, Action`1 body, Action`2 bodyWithState, Func`4 bodyWithLocal, Func`1 localInit, Action`1 localFinally)
        at System.Threading.Tasks.Parallel.For(Int32 fromInclusive, Int32 toExclusive, ParallelOptions parallelOptions, Action`1 body)
    src\Compilers\CSharp\Portable\Symbols\Source\SourceNamespaceSymbol_Completion.cs(53,0): at Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamespaceSymbol.ForceComplete(SourceLocation locationOpt, CancellationToken cancellationToken)
    src\Compilers\CSharp\Portable\Symbols\Source\SourceModuleSymbol.cs(258,0): at Microsoft.CodeAnalysis.CSharp.Symbols.SourceModuleSymbol.ForceComplete(SourceLocation locationOpt, CancellationToken cancellationToken)
    src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs(908,0): at Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol.ForceComplete(SourceLocation locationOpt, CancellationToken cancellationToken)
    src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs(2308,0): at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetSourceDeclarationDiagnostics(SyntaxTree syntaxTree, Nullable`1 filterSpanWithinTree, Func`4 locationFilterOpt, CancellationToken cancellationToken)
    src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs(2195,0): at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnostics(CompilationStage stage, Boolean includeEarlierStages, DiagnosticBag diagnostics, CancellationToken cancellationToken)
    src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs(2131,0): at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnostics(CompilationStage stage, Boolean includeEarlierStages, CancellationToken cancellationToken)
    src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs(2125,0): at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnostics(CancellationToken cancellationToken)
    src\Test\Utilities\Portable\Diagnostics\DiagnosticExtensions.cs(98,0): at Microsoft.CodeAnalysis.DiagnosticExtensions.VerifyDiagnostics[TCompilation](TCompilation c, DiagnosticDescription[] expected)
    src\Compilers\CSharp\Test\Emit\Attributes\AttributeTests.cs(8948,0): at Microsoft.CodeAnalysis.CSharp.UnitTests.AttributeTests.AttributeWithTaskDelegateParameter()
    ----- Inner Stack Trace -----
        at System.Threading.Tasks.Task.ThrowIfExceptional(Boolean includeTaskCanceledExceptions)
        at System.Threading.Tasks.Task.Wait(Int32 millisecondsTimeout, CancellationToken cancellationToken)
        at System.Threading.Tasks.Parallel.ForWorker[TLocal](Int32 fromInclusive, Int32 toExclusive, ParallelOptions parallelOptions, Action`1 body, Action`2 bodyWithState, Func`4 bodyWithLocal, Func`1 localInit, Action`1 localFinally)
        at System.Threading.Tasks.Parallel.For(Int32 fromInclusive, Int32 toExclusive, ParallelOptions parallelOptions, Action`1 body)
    src\Compilers\CSharp\Portable\Symbols\Source\SourceNamespaceSymbol_Completion.cs(53,0): at Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamespaceSymbol.ForceComplete(SourceLocation locationOpt, CancellationToken cancellationToken)
    src\Compilers\CSharp\Portable\Symbols\Symbol.cs(712,0): at Microsoft.CodeAnalysis.CSharp.Symbol.ForceCompleteMemberByLocation(SourceLocation locationOpt, Symbol member, CancellationToken cancellationToken)
    src\Compilers\CSharp\Portable\Symbols\Source\SourceNamespaceSymbol_Completion.cs(56,0): at Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamespaceSymbol.&lt;&gt;c__DisplayClass47_1.&lt;ForceComplete&gt;b__0(Int32 i)
    src\Compilers\Core\Portable\InternalUtilities\UICultureUtilities.cs(166,0): at Roslyn.Utilities.UICultureUtilities.&lt;&gt;c__DisplayClass6_0`1.&lt;WithCurrentUICulture&gt;b__0(T param)
        at System.Threading.Tasks.Parallel.&lt;&gt;c__DisplayClass17_0`1.&lt;ForWorker&gt;b__1()
        at System.Threading.Tasks.Task.InnerInvokeWithArg(Task childTask)
        at System.Threading.Tasks.Task.&lt;&gt;c__DisplayClass176_0.&lt;ExecuteSelfReplicating&gt;b__0(Object )
    ----- Inner Stack Trace -----
    src\Compilers\CSharp\Portable\Symbols\Source\SourceOrdinaryMethodSymbol.cs(686,0): at Microsoft.CodeAnalysis.CSharp.Symbols.SourceOrdinaryMethodSymbol.get_ReturnTypeCustomModifiers()
    src\Compilers\CSharp\Portable\Symbols\SymbolExtensions.cs(381,0): at Microsoft.CodeAnalysis.CSharp.Symbols.SymbolExtensions.GetTypeOrReturnType(Symbol symbol, RefKind&amp; refKind, TypeSymbol&amp; returnType, ImmutableArray`1&amp; returnTypeCustomModifiers, ImmutableArray`1&amp; refCustomModifiers)
    src\Compilers\CSharp\Portable\Symbols\SymbolExtensions.cs(360,0): at Microsoft.CodeAnalysis.CSharp.Symbols.SymbolExtensions.GetTypeOrReturnType(Symbol symbol)
    src\Compilers\CSharp\Portable\Binder\Binder_Conversions.cs(653,0): at Microsoft.CodeAnalysis.CSharp.Binder.MemberGroupFinalValidationAccessibilityChecks(BoundExpression receiverOpt, Symbol memberSymbol, SyntaxNode node, DiagnosticBag diagnostics, Boolean invokedAsExtensionMethod)
    src\Compilers\CSharp\Portable\Binder\Binder_Conversions.cs(499,0): at Microsoft.CodeAnalysis.CSharp.Binder.MemberGroupFinalValidation(BoundExpression receiverOpt, MethodSymbol methodSymbol, SyntaxNode node, DiagnosticBag diagnostics, Boolean invokedAsExtensionMethod)
    src\Compilers\CSharp\Portable\Binder\Binder_Conversions.cs(812,0): at Microsoft.CodeAnalysis.CSharp.Binder.MethodGroupConversionHasErrors(SyntaxNode syntax, Conversion conversion, BoundExpression receiverOpt, Boolean isExtensionMethod, NamedTypeSymbol delegateType, DiagnosticBag diagnostics)
    src\Compilers\CSharp\Portable\Binder\Binder_Conversions.cs(314,0): at Microsoft.CodeAnalysis.CSharp.Binder.CreateMethodGroupConversion(SyntaxNode syntax, BoundExpression source, Conversion conversion, Boolean isCast, TypeSymbol destination, DiagnosticBag diagnostics)
    src\Compilers\CSharp\Portable\Binder\Binder_Conversions.cs(90,0): at Microsoft.CodeAnalysis.CSharp.Binder.CreateConversion(SyntaxNode syntax, BoundExpression source, Conversion conversion, Boolean isCast, Boolean wasCompilerGenerated, TypeSymbol destination, DiagnosticBag diagnostics)
    src\Compilers\CSharp\Portable\Binder\Binder_Conversions.cs(46,0): at Microsoft.CodeAnalysis.CSharp.Binder.CreateConversion(SyntaxNode syntax, BoundExpression source, Conversion conversion, Boolean isCast, TypeSymbol destination, DiagnosticBag diagnostics)
    src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs(2539,0): at Microsoft.CodeAnalysis.CSharp.Binder.CoerceArguments[TMember](MemberResolutionResult`1 methodResult, ArrayBuilder`1 arguments, DiagnosticBag diagnostics)
    src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs(4983,0): at Microsoft.CodeAnalysis.CSharp.Binder.TryPerformConstructorOverloadResolution(NamedTypeSymbol typeContainingConstructors, AnalyzedArguments analyzedArguments, String errorName, Location errorLocation, Boolean suppressResultDiagnostics, DiagnosticBag diagnostics, MemberResolutionResult`1&amp; memberResolutionResult, ImmutableArray`1&amp; candidateConstructors, Boolean allowProtectedConstructorsOfBaseType)
    src\Compilers\CSharp\Portable\Binder\Binder_Attributes.cs(498,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindAttributeConstructor(AttributeSyntax node, NamedTypeSymbol attributeType, AnalyzedArguments boundConstructorArguments, DiagnosticBag diagnostics, LookupResultKind&amp; resultKind, Boolean suppressErrors, HashSet`1&amp; useSiteDiagnostics)
    src\Compilers\CSharp\Portable\Binder\Binder_Attributes.cs(152,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindAttributeCore(AttributeSyntax node, NamedTypeSymbol attributeType, DiagnosticBag diagnostics)
    src\Compilers\CSharp\Portable\Binder\Binder_Attributes.cs(105,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindAttribute(AttributeSyntax node, NamedTypeSymbol attributeType, DiagnosticBag diagnostics)
    src\Compilers\CSharp\Portable\Binder\Binder_Attributes.cs(98,0): at Microsoft.CodeAnalysis.CSharp.Binder.GetAttribute(AttributeSyntax node, NamedTypeSymbol boundAttributeType, DiagnosticBag diagnostics)
    src\Compilers\CSharp\Portable\Binder\Binder_Attributes.cs(74,0): at Microsoft.CodeAnalysis.CSharp.Binder.GetAttributes(ImmutableArray`1 binders, ImmutableArray`1 attributesToBind, ImmutableArray`1 boundAttributeTypes, CSharpAttributeData[] attributesBuilder, DiagnosticBag diagnostics)
    src\Compilers\CSharp\Portable\Symbols\Symbol_Attributes.cs(317,0): at Microsoft.CodeAnalysis.CSharp.Symbol.LoadAndValidateAttributes(OneOrMany`1 attributesSyntaxLists, CustomAttributesBag`1&amp; lazyCustomAttributesBag, AttributeLocation symbolPart, Boolean earlyDecodingOnly, Binder binderOpt, Func`2 attributeMatchesOpt)
    src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs(1010,0): at Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberMethodSymbol.GetAttributesBag(CustomAttributesBag`1&amp; lazyCustomAttributesBag, Boolean forReturnType)
    src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs(968,0): at Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberMethodSymbol.GetAttributesBag()
    src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs(931,0): at Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberMethodSymbol.GetDecodedWellKnownAttributeData()
    src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs(1597,0): at Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberMethodSymbol.get_ImplementationAttributes()
    src\Compilers\CSharp\Portable\Symbols\Source\SourceOrdinaryMethodSymbol.cs(434,0): at Microsoft.CodeAnalysis.CSharp.Symbols.SourceOrdinaryMethodSymbol.LazyAsyncMethodChecks(CancellationToken cancellationToken)
    src\Compilers\CSharp\Portable\Symbols\Source\SourceOrdinaryMethodSymbol.cs(292,0): at Microsoft.CodeAnalysis.CSharp.Symbols.SourceOrdinaryMethodSymbol.MethodChecks(MethodDeclarationSyntax syntax, Binder withTypeParamsBinder, DiagnosticBag diagnostics)
    src\Compilers\CSharp\Portable\Symbols\Source\SourceOrdinaryMethodSymbol.cs(472,0): at Microsoft.CodeAnalysis.CSharp.Symbols.SourceOrdinaryMethodSymbol.MethodChecks(DiagnosticBag diagnostics)
    src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs(293,0): at Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberMethodSymbol.LazyMethodChecks()
    src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs(743,0): at Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberMethodSymbol.get_OverriddenOrHiddenMembers()
    src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol_ImplementationChecks.cs(392,0): at Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.CheckMembersAgainstBaseType(DiagnosticBag diagnostics, CancellationToken cancellationToken)
    src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol_ImplementationChecks.cs(31,0): at Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.GetSynthesizedExplicitImplementations(CancellationToken cancellationToken)
    src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs(499,0): at Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.ForceComplete(SourceLocation locationOpt, CancellationToken cancellationToken)
    src\Compilers\CSharp\Portable\Symbols\Symbol.cs(712,0): at Microsoft.CodeAnalysis.CSharp.Symbol.ForceCompleteMemberByLocation(SourceLocation locationOpt, Symbol member, CancellationToken cancellationToken)
    src\Compilers\CSharp\Portable\Symbols\Source\SourceNamespaceSymbol_Completion.cs(56,0): at Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamespaceSymbol.&lt;&gt;c__DisplayClass47_1.&lt;ForceComplete&gt;b__0(Int32 i)
    src\Compilers\Core\Portable\InternalUtilities\UICultureUtilities.cs(166,0): at Roslyn.Utilities.UICultureUtilities.&lt;&gt;c__DisplayClass6_0`1.&lt;WithCurrentUICulture&gt;b__0(T param)
        at System.Threading.Tasks.Parallel.&lt;&gt;c__DisplayClass17_0`1.&lt;ForWorker&gt;b__1()
        at System.Threading.Tasks.Task.InnerInvokeWithArg(Task childTask)
        at System.Threading.Tasks.Task.&lt;&gt;c__DisplayClass176_0.&lt;ExecuteSelfReplicating&gt;b__0(Object )
```

Note that this doesn't actually test emit because attributes can't actually take delegate arguments. This is kind of an attribute test, though, and it seems independent from the GetSymbolInfo API. Where should this actually go?</Description>
    <CreatedDate>05/11/2018</CreatedDate>
    <ClosedDate>06/11/2018</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>30969</PullRequestID>
        <IssueID>30833</IssueID>
        <Title>VS crash with specifically crafted attributes</Title>
        <Description>**Version Used**: VS 15.7.1 

**Steps to Reproduce**:

Paste this into Visual Studio and let it analyze it
```
using System;
using System.Collections.Generic;
using System.Text;

namespace a
{
    class Class1
    {
		[AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]
		class CommandAttribute : Attribute
		{
			public delegate Task FxCommand();

			public CommandAttribute(FxCommand Fx)
			{
				this.Fx = Fx;
			}

			public FxCommand Fx { get; set; }
		}
		
		[Command(UserInfo)]
		public static async Task UserInfo()
		{
			
		}
	}
}
```

**Expected Behavior**:

Error or something

**Actual Behavior**:

Visual studio crashes</Description>
        <CreatedDate>29/10/2018</CreatedDate>
        <ClosedDate>06/11/2018</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>30969</PullRequestID>
        <IssueID>30833</IssueID>
        <Title>VS crash with specifically crafted attributes</Title>
        <Description>**Version Used**: VS 15.7.1 

**Steps to Reproduce**:

Paste this into Visual Studio and let it analyze it
```
using System;
using System.Collections.Generic;
using System.Text;

namespace a
{
    class Class1
    {
		[AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]
		class CommandAttribute : Attribute
		{
			public delegate Task FxCommand();

			public CommandAttribute(FxCommand Fx)
			{
				this.Fx = Fx;
			}

			public FxCommand Fx { get; set; }
		}
		
		[Command(UserInfo)]
		public static async Task UserInfo()
		{
			
		}
	}
}
```

**Expected Behavior**:

Error or something

**Actual Behavior**:

Visual studio crashes</Description>
        <CreatedDate>29/10/2018</CreatedDate>
        <ClosedDate>06/11/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>30969</PullRequestID>
      <File>src/Compilers/CSharp/Test/Emit/Attributes/AttributeTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>30961</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Ensure PinnedRemotableDataScope is disposed</Title>
    <Description>Fixes #30271

### Customer scenario

Under unknown situations, the IDE crashes due to a failure to clean up a database resource.

### Bugs this fixes

#30271 
https://devdiv.visualstudio.com/DevDiv/_workitems/edit/671157

### Workarounds, if any

None.

### Risk

Low. This pull request cannot alter execution behavior except on a code path which was certain to crash the IDE.

### Performance impact

N/A

### Is this a regression from a previous update?

No.

### Root cause analysis

Found by Watson. The steps to reproduce this issue are unknown.

### How was the bug found?

Watson.

### Test documentation updated?

N/A

</Description>
    <CreatedDate>05/11/2018</CreatedDate>
    <ClosedDate>06/11/2018</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>30961</PullRequestID>
        <IssueID>30271</IssueID>
        <Title>Fix failure to dispose 'scope' after failure to dispose 'connection'</Title>
        <Description>In the following code, an exception during the call to `connection.Dispose` will result in `scope` not getting disposed. This eventually leads to an exception in the finalizer of `PinnedRemotableDataScope`.

https://github.com/dotnet/roslyn/blob/1f082e40860963edcd81d1567069aae924d9369f/src/Workspaces/Core/Portable/Remote/RemoteHostSessionHelpers.cs#L43-L46

:link: https://devdiv.visualstudio.com/DevDiv/_workitems/edit/671157</Description>
        <CreatedDate>02/10/2018</CreatedDate>
        <ClosedDate>08/11/2018</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>30961</PullRequestID>
        <IssueID>30271</IssueID>
        <Title>Fix failure to dispose 'scope' after failure to dispose 'connection'</Title>
        <Description>In the following code, an exception during the call to `connection.Dispose` will result in `scope` not getting disposed. This eventually leads to an exception in the finalizer of `PinnedRemotableDataScope`.

https://github.com/dotnet/roslyn/blob/1f082e40860963edcd81d1567069aae924d9369f/src/Workspaces/Core/Portable/Remote/RemoteHostSessionHelpers.cs#L43-L46

:link: https://devdiv.visualstudio.com/DevDiv/_workitems/edit/671157</Description>
        <CreatedDate>02/10/2018</CreatedDate>
        <ClosedDate>08/11/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>30961</PullRequestID>
      <File>src/Workspaces/Core/Portable/Remote/RemoteHostSessionHelpers.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>30916</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Allow VisualStudioExperimentationService to initialize on a background thread</Title>
    <Description>Fixes #30892 

### Customer scenario

When the first Roslyn document opened in the editor is opened via the Navigate To feature, the Roslyn package fails to load and its IDE features are missing substantial functionality.

### Bugs this fixes

#30892
https://devdiv.visualstudio.com/DevDiv/_workitems/edit/725190

### Workarounds, if any

Open a source document before using Navigate To.

### Risk

Low. In the event other initialization code has bugs (fails to follow required threading rules of the host application), the IDE could hang (deadlock) during the test scenario. However, this is unlikely to result in loss of data because changes cannot be made to most source documents prior to opening the first source document.

### Performance impact

Code paths are not altered outside of the broken scenario.

### Is this a regression from a previous update?

Unknown.

### Root cause analysis

Manual testing scenarios should be updated to cover this case.

### How was the bug found?

Internal report.

### Test documentation updated?

Not yet.
</Description>
    <CreatedDate>01/11/2018</CreatedDate>
    <ClosedDate>08/11/2018</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>30916</PullRequestID>
        <IssueID>30892</IssueID>
        <Title>Package load failure when trying to lauch Navigate To after opening a solution</Title>
        <Description>**Version Used**: VS 16.0 P1 build 28231.51.d16.0

**Steps to Reproduce**:

1. Open a solution in VS without any files open in the editor
2. Ctrl + , to launch Navigate To
3. Search for some type

Note: Problem does not repro if you already had some files from the solution open in the editor at the point where Navigate To was launched.

**Expected Behavior**: Should succeed

**Actual Behavior**: Following package load failure error -

![image](https://user-images.githubusercontent.com/10579684/47826323-7d002700-dd34-11e8-874d-0213e1d24703.png)

On debugging the underlying issue appears to be that `AbstractNavigateToSearchService` is trying to instantiate `VisualStudioExperimentationService` from the background thread resulting in an `InvalidOperationException` from the following `Contract.ThrowIfFalse()` call.

**Dump file**: Available at `\\&lt;internalshare&gt;\\&lt;myfolder&gt;\Dumps\RoslynPackageLoad`

```
      Microsoft.CodeAnalysis.Workspaces.dll!Roslyn.Utilities.Contract.ThrowIfFalse(bool condition, string message) Line 32  C#
Microsoft.CodeAnalysis.EditorFeatures.dll!Microsoft.CodeAnalysis.Editor.Shared.Utilities.ForegroundThreadAffinitizedObject.AssertIsForeground() Line 56   C#
Microsoft.CodeAnalysis.EditorFeatures.dll!Microsoft.CodeAnalysis.Editor.Shared.Utilities.ForegroundThreadAffinitizedObject.ForegroundThreadAffinitizedObject(Microsoft.CodeAnalysis.Editor.Shared.Utilities.IThreadingContext threadingContext, bool assertIsForeground) Line 34   C#
&gt; Microsoft.VisualStudio.LanguageServices.dll!Microsoft.VisualStudio.LanguageServices.Experimentation.VisualStudioExperimentationService.VisualStudioExperimentationService(Microsoft.CodeAnalysis.Editor.Shared.Utilities.IThreadingContext threadingContext, Microsoft.VisualStudio.Shell.SVsServiceProvider serviceProvider) Line 27   C#
              [Native to Managed Transition]      
              [Managed to Native Transition]      
Microsoft.VisualStudio.Composition.dll!Microsoft.VisualStudio.Composition.ReflectionHelpers.Instantiate(System.Reflection.MethodBase ctorOrFactoryMethod, object[] arguments) Line 595  C#
Microsoft.VisualStudio.Composition.dll!Microsoft.VisualStudio.Composition.RuntimeExportProviderFactory.RuntimeExportProvider.RuntimePartLifecycleTracker.CreateValue() Line 517 C#
Microsoft.VisualStudio.Composition.dll!Microsoft.VisualStudio.Composition.ExportProvider.PartLifecycleTracker.Create() Line 1160             C#
Microsoft.VisualStudio.Composition.dll!Microsoft.VisualStudio.Composition.ExportProvider.PartLifecycleTracker.MoveNext(Microsoft.VisualStudio.Composition.ExportProvider.PartLifecycleState nextState) Line 1255          C#
Microsoft.VisualStudio.Composition.dll!Microsoft.VisualStudio.Composition.ExportProvider.PartLifecycleTracker.MoveToState(Microsoft.VisualStudio.Composition.ExportProvider.PartLifecycleState requiredState) Line 1336   C#
Microsoft.VisualStudio.Composition.dll!Microsoft.VisualStudio.Composition.ExportProvider.PartLifecycleTracker.GetValueReadyToExpose() Line 1061             C#
Microsoft.VisualStudio.Composition.dll!Microsoft.VisualStudio.Composition.ExportProvider.CreateExport.AnonymousMethod__0() Line 461 C#
              mscorlib.dll!System.Lazy&lt;object&gt;.CreateValue() Line 437         C#
              mscorlib.dll!System.Lazy&lt;object&gt;.LazyInitValue() Line 388       C#
              mscorlib.dll!System.Lazy&lt;object&gt;.Value.get() Line 339             C#
Microsoft.VisualStudio.Composition.dll!Microsoft.VisualStudio.Composition.NetFxAdapters.MefV1ExportProvider.UnwrapExport.AnonymousMethod__1() Line 246 C#
System.ComponentModel.Composition.dll!System.ComponentModel.Composition.Primitives.Export.GetExportedValueCore() Line 247 C#
System.ComponentModel.Composition.dll!System.ComponentModel.Composition.Primitives.Export.Value.get() Line 207 C#
System.ComponentModel.Composition.dll!System.ComponentModel.Composition.ExportServices.GetCastedExportedValue&lt;Microsoft.CodeAnalysis.Host.IWorkspaceService&gt;(System.ComponentModel.Composition.Primitives.Export export) Line 135  C#
System.ComponentModel.Composition.dll!System.ComponentModel.Composition.ExportServices.CreateStronglyTypedLazyOfTM.AnonymousMethod__1() Line 88   C#
mscorlib.dll!System.Lazy&lt;Microsoft.CodeAnalysis.Host.IWorkspaceService&gt;.CreateValue() Line 437 C#
mscorlib.dll!System.Lazy&lt;Microsoft.CodeAnalysis.Host.IWorkspaceService&gt;.LazyInitValue() Line 359 C#
mscorlib.dll!System.Lazy&lt;Microsoft.CodeAnalysis.Host.IWorkspaceService&gt;.Value.get() Line 339 C#
Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Host.Mef.MefWorkspaceServices.GetService&lt;Microsoft.CodeAnalysis.Experiments.IExperimentationService&gt;() Line 49   C#
Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Remote.RemoteHostClientExtensions.IsOutOfProcessEnabled(Microsoft.CodeAnalysis.Workspace workspace, Microsoft.CodeAnalysis.Options.Option&lt;bool&gt; featureOption) Line 129              C#
Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Remote.RemoteHostClientExtensions.TryGetRemoteHostClientAsync(Microsoft.CodeAnalysis.Workspace workspace, Microsoft.CodeAnalysis.Options.Option&lt;bool&gt; featureOption, System.Threading.CancellationToken cancellationToken) Line 135         C#
Microsoft.CodeAnalysis.Features.dll!Microsoft.CodeAnalysis.NavigateTo.AbstractNavigateToSearchService.TryGetRemoteHostClientAsync(Microsoft.CodeAnalysis.Project project, System.Threading.CancellationToken cancellationToken) Line 47           C#
Microsoft.CodeAnalysis.Features.dll!Microsoft.CodeAnalysis.NavigateTo.AbstractNavigateToSearchService.SearchProjectAsync(Microsoft.CodeAnalysis.Project project, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Document&gt; priorityDocuments, string searchPattern, System.Collections.Immutable.IImmutableSet&lt;string&gt; kinds, System.Threading.CancellationToken cancellationToken)        C#
Microsoft.CodeAnalysis.EditorFeatures.Wpf.dll!Microsoft.CodeAnalysis.Editor.Implementation.NavigateTo.NavigateToItemProvider.Searcher.SearchAsyncWorker(Microsoft.CodeAnalysis.Project project, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Document&gt; priorityDocuments) Line 189           C#
Microsoft.CodeAnalysis.EditorFeatures.Wpf.dll!Microsoft.CodeAnalysis.Editor.Implementation.NavigateTo.NavigateToItemProvider.Searcher.SearchAsync(Microsoft.CodeAnalysis.Project project, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Document&gt; priorityDocuments)           C#
Microsoft.CodeAnalysis.EditorFeatures.Wpf.dll!Microsoft.CodeAnalysis.Editor.Implementation.NavigateTo.NavigateToItemProvider.Searcher.SearchProjectsInPriorityOrder.AnonymousMethod__5() Line 146 C#
mscorlib.dll!System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;.InnerInvoke() Line 680 C#
              mscorlib.dll!System.Threading.Tasks.Task.Execute() Line 2498 C#
              mscorlib.dll!System.Threading.Tasks.Task.ExecutionContextCallback(object obj) Line 2861      C#
mscorlib.dll!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state, bool preserveSyncCtx) Line 954 C#
mscorlib.dll!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state, bool preserveSyncCtx) Line 902 C#
              mscorlib.dll!System.Threading.Tasks.Task.ExecuteWithThreadLocal(ref System.Threading.Tasks.Task currentTaskSlot) Line 2827         C#
              mscorlib.dll!System.Threading.Tasks.Task.ExecuteEntry(bool bPreventDoubleExecution) Line 2756            C#
mscorlib.dll!System.Threading.Tasks.Task.System.Threading.IThreadPoolWorkItem.ExecuteWorkItem() Line 2704             C#
              mscorlib.dll!System.Threading.ThreadPoolWorkQueue.Dispatch() Line 820              C#
           mscorlib.dll!System.Threading._ThreadPoolWaitCallback.PerformWaitCallback() Line 1161             C#
```</Description>
        <CreatedDate>01/11/2018</CreatedDate>
        <ClosedDate>09/11/2018</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>30916</PullRequestID>
        <IssueID>30892</IssueID>
        <Title>Package load failure when trying to lauch Navigate To after opening a solution</Title>
        <Description>**Version Used**: VS 16.0 P1 build 28231.51.d16.0

**Steps to Reproduce**:

1. Open a solution in VS without any files open in the editor
2. Ctrl + , to launch Navigate To
3. Search for some type

Note: Problem does not repro if you already had some files from the solution open in the editor at the point where Navigate To was launched.

**Expected Behavior**: Should succeed

**Actual Behavior**: Following package load failure error -

![image](https://user-images.githubusercontent.com/10579684/47826323-7d002700-dd34-11e8-874d-0213e1d24703.png)

On debugging the underlying issue appears to be that `AbstractNavigateToSearchService` is trying to instantiate `VisualStudioExperimentationService` from the background thread resulting in an `InvalidOperationException` from the following `Contract.ThrowIfFalse()` call.

**Dump file**: Available at `\\&lt;internalshare&gt;\\&lt;myfolder&gt;\Dumps\RoslynPackageLoad`

```
      Microsoft.CodeAnalysis.Workspaces.dll!Roslyn.Utilities.Contract.ThrowIfFalse(bool condition, string message) Line 32  C#
Microsoft.CodeAnalysis.EditorFeatures.dll!Microsoft.CodeAnalysis.Editor.Shared.Utilities.ForegroundThreadAffinitizedObject.AssertIsForeground() Line 56   C#
Microsoft.CodeAnalysis.EditorFeatures.dll!Microsoft.CodeAnalysis.Editor.Shared.Utilities.ForegroundThreadAffinitizedObject.ForegroundThreadAffinitizedObject(Microsoft.CodeAnalysis.Editor.Shared.Utilities.IThreadingContext threadingContext, bool assertIsForeground) Line 34   C#
&gt; Microsoft.VisualStudio.LanguageServices.dll!Microsoft.VisualStudio.LanguageServices.Experimentation.VisualStudioExperimentationService.VisualStudioExperimentationService(Microsoft.CodeAnalysis.Editor.Shared.Utilities.IThreadingContext threadingContext, Microsoft.VisualStudio.Shell.SVsServiceProvider serviceProvider) Line 27   C#
              [Native to Managed Transition]      
              [Managed to Native Transition]      
Microsoft.VisualStudio.Composition.dll!Microsoft.VisualStudio.Composition.ReflectionHelpers.Instantiate(System.Reflection.MethodBase ctorOrFactoryMethod, object[] arguments) Line 595  C#
Microsoft.VisualStudio.Composition.dll!Microsoft.VisualStudio.Composition.RuntimeExportProviderFactory.RuntimeExportProvider.RuntimePartLifecycleTracker.CreateValue() Line 517 C#
Microsoft.VisualStudio.Composition.dll!Microsoft.VisualStudio.Composition.ExportProvider.PartLifecycleTracker.Create() Line 1160             C#
Microsoft.VisualStudio.Composition.dll!Microsoft.VisualStudio.Composition.ExportProvider.PartLifecycleTracker.MoveNext(Microsoft.VisualStudio.Composition.ExportProvider.PartLifecycleState nextState) Line 1255          C#
Microsoft.VisualStudio.Composition.dll!Microsoft.VisualStudio.Composition.ExportProvider.PartLifecycleTracker.MoveToState(Microsoft.VisualStudio.Composition.ExportProvider.PartLifecycleState requiredState) Line 1336   C#
Microsoft.VisualStudio.Composition.dll!Microsoft.VisualStudio.Composition.ExportProvider.PartLifecycleTracker.GetValueReadyToExpose() Line 1061             C#
Microsoft.VisualStudio.Composition.dll!Microsoft.VisualStudio.Composition.ExportProvider.CreateExport.AnonymousMethod__0() Line 461 C#
              mscorlib.dll!System.Lazy&lt;object&gt;.CreateValue() Line 437         C#
              mscorlib.dll!System.Lazy&lt;object&gt;.LazyInitValue() Line 388       C#
              mscorlib.dll!System.Lazy&lt;object&gt;.Value.get() Line 339             C#
Microsoft.VisualStudio.Composition.dll!Microsoft.VisualStudio.Composition.NetFxAdapters.MefV1ExportProvider.UnwrapExport.AnonymousMethod__1() Line 246 C#
System.ComponentModel.Composition.dll!System.ComponentModel.Composition.Primitives.Export.GetExportedValueCore() Line 247 C#
System.ComponentModel.Composition.dll!System.ComponentModel.Composition.Primitives.Export.Value.get() Line 207 C#
System.ComponentModel.Composition.dll!System.ComponentModel.Composition.ExportServices.GetCastedExportedValue&lt;Microsoft.CodeAnalysis.Host.IWorkspaceService&gt;(System.ComponentModel.Composition.Primitives.Export export) Line 135  C#
System.ComponentModel.Composition.dll!System.ComponentModel.Composition.ExportServices.CreateStronglyTypedLazyOfTM.AnonymousMethod__1() Line 88   C#
mscorlib.dll!System.Lazy&lt;Microsoft.CodeAnalysis.Host.IWorkspaceService&gt;.CreateValue() Line 437 C#
mscorlib.dll!System.Lazy&lt;Microsoft.CodeAnalysis.Host.IWorkspaceService&gt;.LazyInitValue() Line 359 C#
mscorlib.dll!System.Lazy&lt;Microsoft.CodeAnalysis.Host.IWorkspaceService&gt;.Value.get() Line 339 C#
Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Host.Mef.MefWorkspaceServices.GetService&lt;Microsoft.CodeAnalysis.Experiments.IExperimentationService&gt;() Line 49   C#
Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Remote.RemoteHostClientExtensions.IsOutOfProcessEnabled(Microsoft.CodeAnalysis.Workspace workspace, Microsoft.CodeAnalysis.Options.Option&lt;bool&gt; featureOption) Line 129              C#
Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Remote.RemoteHostClientExtensions.TryGetRemoteHostClientAsync(Microsoft.CodeAnalysis.Workspace workspace, Microsoft.CodeAnalysis.Options.Option&lt;bool&gt; featureOption, System.Threading.CancellationToken cancellationToken) Line 135         C#
Microsoft.CodeAnalysis.Features.dll!Microsoft.CodeAnalysis.NavigateTo.AbstractNavigateToSearchService.TryGetRemoteHostClientAsync(Microsoft.CodeAnalysis.Project project, System.Threading.CancellationToken cancellationToken) Line 47           C#
Microsoft.CodeAnalysis.Features.dll!Microsoft.CodeAnalysis.NavigateTo.AbstractNavigateToSearchService.SearchProjectAsync(Microsoft.CodeAnalysis.Project project, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Document&gt; priorityDocuments, string searchPattern, System.Collections.Immutable.IImmutableSet&lt;string&gt; kinds, System.Threading.CancellationToken cancellationToken)        C#
Microsoft.CodeAnalysis.EditorFeatures.Wpf.dll!Microsoft.CodeAnalysis.Editor.Implementation.NavigateTo.NavigateToItemProvider.Searcher.SearchAsyncWorker(Microsoft.CodeAnalysis.Project project, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Document&gt; priorityDocuments) Line 189           C#
Microsoft.CodeAnalysis.EditorFeatures.Wpf.dll!Microsoft.CodeAnalysis.Editor.Implementation.NavigateTo.NavigateToItemProvider.Searcher.SearchAsync(Microsoft.CodeAnalysis.Project project, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Document&gt; priorityDocuments)           C#
Microsoft.CodeAnalysis.EditorFeatures.Wpf.dll!Microsoft.CodeAnalysis.Editor.Implementation.NavigateTo.NavigateToItemProvider.Searcher.SearchProjectsInPriorityOrder.AnonymousMethod__5() Line 146 C#
mscorlib.dll!System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;.InnerInvoke() Line 680 C#
              mscorlib.dll!System.Threading.Tasks.Task.Execute() Line 2498 C#
              mscorlib.dll!System.Threading.Tasks.Task.ExecutionContextCallback(object obj) Line 2861      C#
mscorlib.dll!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state, bool preserveSyncCtx) Line 954 C#
mscorlib.dll!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state, bool preserveSyncCtx) Line 902 C#
              mscorlib.dll!System.Threading.Tasks.Task.ExecuteWithThreadLocal(ref System.Threading.Tasks.Task currentTaskSlot) Line 2827         C#
              mscorlib.dll!System.Threading.Tasks.Task.ExecuteEntry(bool bPreventDoubleExecution) Line 2756            C#
mscorlib.dll!System.Threading.Tasks.Task.System.Threading.IThreadPoolWorkItem.ExecuteWorkItem() Line 2704             C#
              mscorlib.dll!System.Threading.ThreadPoolWorkQueue.Dispatch() Line 820              C#
           mscorlib.dll!System.Threading._ThreadPoolWaitCallback.PerformWaitCallback() Line 1161             C#
```</Description>
        <CreatedDate>01/11/2018</CreatedDate>
        <ClosedDate>09/11/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>30916</PullRequestID>
      <File>src/VisualStudio/Core/Def/Experimentation/VisualStudioExperimentationService.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>30914</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Target NetStandard 2.0 and .NET Framework 4.7.2</Title>
    <Description>Retargets Roslyn projects to netstandard2.0 and net472.

Moves most code from Workspaces.Desktop to Workspaces, except for MEF V1 implementation.
Removes dependencies on Workspaces.Desktop.
Removes Workspaces.Desktop from Micrososft.CodeAnalysis.Workspaces.Common package.

Removes PortableFacades.vsix.

Enables more scripting tests on Core.

Fixes #29292 (Cleanup Microsoft.CodeAnalysis.Workspaces packages)
Fixes #18479 (Scripting Tuples test has broken references between desktop/coreclr tests)

Implements IBC optimization data embedding.

</Description>
    <CreatedDate>01/11/2018</CreatedDate>
    <ClosedDate>01/11/2018</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>30914</PullRequestID>
        <IssueID>29292</IssueID>
        <Title>Cleanup Microsoft.CodeAnalysis.Workspaces packages</Title>
        <Description>We package Microsoft.CodeAnalysis.Workspaces and Microsoft.CodeAnalysis.Workspaces.Desktop in the same package, which is an unusal pattern that's not supported by NuGet Pack and needs a custom NuSpec file. Remove the custom NuSpec once we target netstandard2.0 and merge these two assemblies. 

When referencing Microsoft.CodeAnalysis.Workspaces.Desktop.csproj from other project that produce packages we need to do so with `PrivateAssets="all"` since the actual Microsoft.CodeAnalysis.Workspaces.Common package reference is added via reference to Microsoft.CodeAnalysis.Workspaces.csproj.</Description>
        <CreatedDate>14/08/2018</CreatedDate>
        <ClosedDate>05/04/2019</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>30914</PullRequestID>
        <IssueID>18479</IssueID>
        <Title>Scripting Tuples test has broken references between desktop/coreclr tests</Title>
        <Description>The test is Microsoft.CodeAnalysis.CSharp.Scripting.UnitTests.CommandLineRunnerTests.Tuples

On CoreCLR System.ValueTuple is in the runtime corlib, meaning that if System.ValueTuple is passed to the scripting compilation, compilations fail due to duplicate tuple types.

On the other hand, if the reference is removed, compilations fail on Desktop since the current corlib does not have System.ValueTuple.</Description>
        <CreatedDate>05/04/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>30914</PullRequestID>
      <File>src/Compilers/CSharp/Test/CommandLine/CommandLineTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Attributes/EmitTestStrongNameProvider.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Attributes/InternalsVisibleToAndStrongNameTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTupleTest.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Emit/CompilationEmitTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Emit/DesktopStrongNameProviderTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Emit/EditAndContinue/EditAndContinueTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Emit/NoPiaEmbedTypes.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/PDB/PDBUsingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/PrivateProtected.cs</File>
      <File>src/Compilers/CSharp/csc/Program.cs</File>
      <File>src/Compilers/Core/CodeAnalysisTest/AnalyzerFileReferenceTests.cs</File>
      <File>src/Compilers/Core/CodeAnalysisTest/DesktopAnalyzerAssemblyLoaderTests.cs</File>
      <File>src/Compilers/Core/CodeAnalysisTest/MetadataReferences/AssemblyIdentityComparerTests.cs</File>
      <File>src/Compilers/Core/CodeAnalysisTest/MetadataReferences/AssemblyIdentityDisplayNameTests.cs</File>
      <File>src/Compilers/Core/CodeAnalysisTest/MetadataReferences/AssemblyIdentityTests.cs</File>
      <File>src/Compilers/Core/CodeAnalysisTest/MetadataReferences/AssemblyPortabilityPolicyTests.cs</File>
      <File>src/Compilers/Core/CodeAnalysisTest/MetadataReferences/FusionAssemblyIdentityTests.cs</File>
      <File>src/Compilers/Core/CodeAnalysisTest/MetadataReferences/MetadataReferenceTests.cs</File>
      <File>src/Compilers/Core/CodeAnalysisTest/MetadataReferences/ModuleMetadataTests.cs</File>
      <File>src/Compilers/Core/Portable/FileSystem/FileUtilities.cs</File>
      <File>src/Compilers/Extension/AssemblyRedirects.cs</File>
      <File>src/Compilers/Server/VBCSCompiler/NamedPipeClientConnection.cs</File>
      <File>src/Compilers/Server/VBCSCompiler/VBCSCompiler.cs</File>
      <File>src/Compilers/Server/VBCSCompilerTests/CompilerServerTests.cs</File>
      <File>src/Compilers/Server/VBCSCompilerTests/DesktopBuildClientTests.cs</File>
      <File>src/Compilers/Shared/BuildClient.cs</File>
      <File>src/Compilers/Shared/BuildServerConnection.cs</File>
      <File>src/Compilers/Shared/DesktopAnalyzerAssemblyLoader.cs</File>
      <File>src/Compilers/Shared/GlobalAssemblyCacheHelpers/ClrGlobalAssemblyCache.cs</File>
      <File>src/Compilers/Shared/GlobalAssemblyCacheHelpers/FusionAssemblyIdentity.cs</File>
      <File>src/Compilers/Shared/ShadowCopyAnalyzerAssemblyLoader.cs</File>
      <File>src/Compilers/Test/Resources/Core/TestKeys.cs</File>
      <File>src/Compilers/VisualBasic/vbc/Program.cs</File>
      <File>src/EditorFeatures/CSharpTest/ConvertForEachToFor/ConvertForEachToForTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/RemoveUnusedVariable/RemoveUnusedVariableTests.cs</File>
      <File>src/EditorFeatures/Core/EditorFeaturesResources.Designer.cs</File>
      <File>src/EditorFeatures/Test/CodeGeneration/AbstractCodeGenerationTests.cs</File>
      <File>src/EditorFeatures/Test/Diagnostics/DiagnosticAnalyzerServiceTests.cs</File>
      <File>src/EditorFeatures/Test/Preview/PreviewWorkspaceTests.cs</File>
      <File>src/EditorFeatures/TestUtilities/Workspaces/TestWorkspace.cs</File>
      <File>src/Scripting/CSharp/Hosting/ObjectFormatter/CSharpObjectFormatterImpl.cs</File>
      <File>src/Scripting/CSharpTest/CommandLineRunnerTests.cs</File>
      <File>src/Scripting/CSharpTest/ScriptTests.cs</File>
      <File>src/Scripting/Core/Hosting/ObjectFormatter/CommonObjectFormatter.cs</File>
      <File>src/Scripting/Core/ScriptOptions.cs</File>
      <File>src/Scripting/CoreTest/ScriptOptionsTests.cs</File>
      <File>src/Setup/DevDivPackages/Debugger/Program.cs</File>
      <File>src/Test/Utilities/Portable/Assert/UseCultureAttribute.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/RuntimeUtilities.cs</File>
      <File>src/Test/Utilities/Portable/CompilationVerifier.cs</File>
      <File>src/Test/Utilities/Portable/FX/EnsureEnglishUICulture.cs</File>
      <File>src/Test/Utilities/Portable/FX/EnsureInvariantCulture.cs</File>
      <File>src/Test/Utilities/Portable/Mocks/TestReferences.cs</File>
      <File>src/Test/Utilities/Portable/Platform/Custom/MetadataSignatureHelper.cs</File>
      <File>src/Test/Utilities/Portable/Platform/Custom/OSVersion.cs</File>
      <File>src/Test/Utilities/Portable/Platform/Custom/SigningTestHelpers.cs</File>
      <File>src/Test/Utilities/Portable/Platform/Desktop/AppDomainAssemblyCache.cs</File>
      <File>src/Test/Utilities/Portable/Platform/Desktop/AppDomainUtils.cs</File>
      <File>src/Test/Utilities/Portable/Platform/Desktop/CLRHelpers.cs</File>
      <File>src/Test/Utilities/Portable/Platform/Desktop/ConditionalFactAttribute.cs</File>
      <File>src/Test/Utilities/Portable/Platform/Desktop/DesktopRuntimeEnvironment.cs</File>
      <File>src/Test/Utilities/Portable/Platform/Desktop/DesktopRuntimeEnvironmentFactory.cs</File>
      <File>src/Test/Utilities/Portable/Platform/Desktop/DesktopRuntimeUtil.cs</File>
      <File>src/Test/Utilities/Portable/Platform/Desktop/ErrorDiagnostics.cs</File>
      <File>src/Test/Utilities/Portable/Platform/Desktop/Exceptions.cs</File>
      <File>src/Test/Utilities/Portable/Platform/Desktop/Extensions.cs</File>
      <File>src/Test/Utilities/Portable/Platform/Desktop/RuntimeAssemblyManager.cs</File>
      <File>src/Test/Utilities/Portable/Platform/Desktop/RuntimeModuleData.cs</File>
      <File>src/Test/Utilities/Portable/Platform/Desktop/TestHelpers.cs</File>
      <File>src/Tools/BuildBoss/CompilerNuGetCheckerUtil.cs</File>
      <File>src/Tools/BuildBoss/ProjectCheckerUtil.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/GenerateType/GenerateTypeDialogViewModel.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/MetadataReferences/VisualStudioMetadataReferenceManager.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/MiscellaneousFilesWorkspace.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/VisualStudioMefHostServices.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/VisualStudioWorkspaceImpl.cs</File>
      <File>src/VisualStudio/Core/Impl/Options/AbstractOptionPreviewViewModel.cs</File>
      <File>src/VisualStudio/Core/Impl/RoslynVisualStudioWorkspace.cs</File>
      <File>src/VisualStudio/Core/Test.Next/Mocks/TestHostServices.cs</File>
      <File>src/VisualStudio/Setup.Dependencies/AssemblyRedirects.cs</File>
      <File>src/VisualStudio/Setup/AssemblyRedirects.cs</File>
      <File>src/Workspaces/Core/Desktop/Utilities/ReferencePathUtilities_Desktop.cs</File>
      <File>src/Workspaces/Core/Desktop/Workspace/CommandLineProject.cs</File>
      <File>src/Workspaces/Core/Desktop/Workspace/Host/Mef/DesktopMefHostServices.cs</File>
      <File>src/Workspaces/Core/Desktop/Workspace/Host/Mef/MefV1HostServices.cs</File>
      <File>src/Workspaces/Core/Desktop/WorkspaceDesktopResources.Designer.cs</File>
      <File>src/Workspaces/Core/MSBuild/Host/SimpleAnalyzerAssemblyLoaderService.cs</File>
      <File>src/Workspaces/Core/Portable/Execution/Desktop/DesktopReferenceSerializationServiceFactory.cs</File>
      <File>src/Workspaces/Core/Portable/Execution/Desktop/SerializationAnalyzerAssemblyLoader.cs</File>
      <File>src/Workspaces/Core/Portable/Execution/Desktop/SimpleAnalyzerAssemblyLoaderService.cs</File>
      <File>src/Workspaces/Core/Portable/Log/EtwLogger.cs</File>
      <File>src/Workspaces/Core/Portable/Log/RoslynEventSource.cs</File>
      <File>src/Workspaces/Core/Portable/Log/TraceLogger.cs</File>
      <File>src/Workspaces/Core/Portable/SolutionSize/ISolutionSizeTracker.cs</File>
      <File>src/Workspaces/Core/Portable/SolutionSize/SolutionSizeTracker.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/AbstractPersistentStorageService.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/PersistenceStorageServiceFactory.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/SQLite/Interop/OpenFlags.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/SQLite/Interop/ResettableSqlStatement.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/SQLite/Interop/Result.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/SQLite/Interop/SqlConnection.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/SQLite/Interop/SqlException.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/SQLite/Interop/SqlStatement.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/SQLite/PooledConnection.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/SQLite/SQLitePersistentStorage.Accessor.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/SQLite/SQLitePersistentStorage.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/SQLite/SQLitePersistentStorageService.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/SQLite/SQLitePersistentStorage_BulkPopulateIds.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/SQLite/SQLitePersistentStorage_DocumentIds.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/SQLite/SQLitePersistentStorage_DocumentSerialization.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/SQLite/SQLitePersistentStorage_Helpers.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/SQLite/SQLitePersistentStorage_ProjectIds.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/SQLite/SQLitePersistentStorage_ProjectSerialization.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/SQLite/SQLitePersistentStorage_SolutionSerialization.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/SQLite/SQLitePersistentStorage_StringIds.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/SQLite/SQLitePersistentStorage_WriteBatching.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/StorageDatabase.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/StorageDatabaseLogger.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/StorageOptions.cs</File>
      <File>src/Workspaces/Core/Portable/TemporaryStorage/TemporaryStorageServiceFactory.MemoryMappedInfo.cs</File>
      <File>src/Workspaces/Core/Portable/TemporaryStorage/TemporaryStorageServiceFactory.cs</File>
      <File>src/Workspaces/CoreTest/SolutionTests/SolutionTests.cs</File>
      <File>src/Workspaces/CoreTest/WorkspaceTests/AdhocWorkspaceTests.cs</File>
      <File>src/Workspaces/CoreTestUtilities/MEF/ExportProviderCache.cs</File>
      <File>src/Workspaces/CoreTestUtilities/MEF/UseExportProviderAttribute.cs</File>
      <File>src/Workspaces/DesktopTest/CommandLineProjectTests.cs</File>
      <File>src/Workspaces/DesktopTest/CommandLineProjectWorkspaceTests.cs</File>
      <File>src/Workspaces/DesktopTest/UseMefV1ExportProviderAttribute.cs</File>
      <File>src/Workspaces/MSBuildTest/MSBuildWorkspaceTestBase.cs</File>
      <File>src/Workspaces/MSBuildTest/MSBuildWorkspaceTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>29516</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Explore options to allow users to add all missing imports</Title>
    <Description>Exploring different options to allow users to add missing imports
to code that they copied into their solution (#10272). When multiple fixes are
found for the same diagnostic no action is taken. Allowing the user to
sort out ambiguity.

1) From the light bulb menu the user can now specify fix all for missing
using statements (#23528). 

![fix all missing imports solution](https://user-images.githubusercontent.com/611219/45244322-2b936880-b2ac-11e8-9630-013d9ba8fa83.gif)

This is an odd UX. In the light bulb menu the fix will have a name such as,
`using System.Collections.Generic;`. The user will then choose a fix all
scope from a preview of the fix. The fix all preview will show many other
using statements to be added. 

There is also odd behavior around solutions with a mix of C# and VB
project. For instance, if fixing all in the Solution scope only the 
projects of the same language as the file that the fix was invoked 
in will be considered. This is due to AddImportFixProvider being
per language and not sharing diagnostic ids.

2) When invoking the Remove and Sort Using command missing imports will
be added.

![add imports during organize](https://user-images.githubusercontent.com/611219/45244309-20d8d380-b2ac-11e8-8cf4-013522abb461.gif)

This could be confusing since the current behavior is simply to remove and sort. 


Things to explore:
- [ ] Create a new fixer for missing imports that is separate from the AddImport fixer.
- [ ] Create a separate command from Remove and Sort Imports for Add Missing Imports
- [ ] Need to bring attention to the diagnostics that have multiple fixes.
</Description>
    <CreatedDate>24/08/2018</CreatedDate>
    <ClosedDate>12/10/2018</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>29516</PullRequestID>
        <IssueID>10272</IssueID>
        <Title>Offer code fix to add usings for pasted code snippets</Title>
        <Description>Filed on behalf of a customer from interviews
</Description>
        <CreatedDate>01/04/2016</CreatedDate>
        <ClosedDate>15/10/2018</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>29516</PullRequestID>
        <IssueID>23528</IssueID>
        <Title>Missing FixAll support for bunch of IDE CodeFixProviders</Title>
        <Description>**Version Used**: Roslyn master

**Steps to Reproduce**:

1. Move Roslyn to latest analyzers: https://www.nuget.org/packages/Microsoft.Net.RoslynDiagnostics/2.6.0-beta1 by changing `MicrosoftNetRoslynDiagnosticsVersion` over [here](https://github.com/dotnet/roslyn/blob/master/build/Targets/Packages.props#L54) to `2.6.0-beta1`. If this value is already greater than equals `2.6.0-beta1`, then search for source suppressions for RS1016.
2. Build solution

**Expected Behavior**:
No RS1016 diagnostics (CodeFixProviders should override GetFixAllProvider).

**Actual Behavior**:
```
Severity	Code	Description	Project	File	Line	Suppression State	Detail Description
Warning	RS1016	'GenerateEndConstructCodeFixProvider' registers one or more code fixes, but does not override the method 'CodeFixProvider.GetFixAllProvider'. Override this method and provide a non-null FixAllProvider for FixAll support, potentially 'WellKnownFixAllProviders.BatchFixer', or 'null' to explicitly disable FixAll support.	BasicFeatures	c:\roslyn\src\Features\VisualBasic\Portable\CodeFixes\GenerateEndConstruct\GenerateEndConstructCodeFixProvider.vb	16	Active
Warning	RS1016	'GenerateEventCodeFixProvider' registers one or more code fixes, but does not override the method 'CodeFixProvider.GetFixAllProvider'. Override this method and provide a non-null FixAllProvider for FixAll support, potentially 'WellKnownFixAllProviders.BatchFixer', or 'null' to explicitly disable FixAll support.	BasicFeatures	c:\roslyn\src\Features\VisualBasic\Portable\CodeFixes\GenerateEvent\GenerateEventCodeFixProvider.CodeAction.vb	8	Active	A CodeFixProvider should provide FixAll support to enable users to fix multiple instances of the underlying diagnostic with a single code fix. See documenation at https://github.com/dotnet/roslyn/blob/master/docs/analyzers/FixAllProvider.md for further details.
Warning	RS1016	'HideBaseCodeFixProvider' registers one or more code fixes, but does not override the method 'CodeFixProvider.GetFixAllProvider'. Override this method and provide a non-null FixAllProvider for FixAll support, potentially 'WellKnownFixAllProviders.BatchFixer', or 'null' to explicitly disable FixAll support.	CSharpFeatures	c:\roslyn\src\Features\CSharp\Portable\CodeFixes\HideBase\HideBaseCodeFixProvider.AddNewKeywordAction.cs	12	Active
Warning	RS1016	'AbstractAddImportCodeFixProvider' registers one or more code fixes, but does not override the method 'CodeFixProvider.GetFixAllProvider'. Override this method and provide a non-null FixAllProvider for FixAll support, potentially 'WellKnownFixAllProviders.BatchFixer', or 'null' to explicitly disable FixAll support.	Features	c:\roslyn\src\Features\Core\Portable\AddImport\CodeActions\AssemblyReferenceCodeAction.cs	13	Active
Warning	RS1016	'AbstractAddPackageCodeFixProvider' registers one or more code fixes, but does not override the method 'CodeFixProvider.GetFixAllProvider'. Override this method and provide a non-null FixAllProvider for FixAll support, potentially 'WellKnownFixAllProviders.BatchFixer', or 'null' to explicitly disable FixAll support.	Features	c:\roslyn\src\Features\Core\Portable\AddPackage\AbstractAddPackageCodeFixProvider.cs	16	Active
Warning	RS1016	'AbstractAddParameterCodeFixProvider' registers one or more code fixes, but does not override the method 'CodeFixProvider.GetFixAllProvider'. Override this method and provide a non-null FixAllProvider for FixAll support, potentially 'WellKnownFixAllProviders.BatchFixer', or 'null' to explicitly disable FixAll support.	Features	c:\roslyn\src\Features\Core\Portable\AddParameter\AbstractAddParameterCodeFixProvider.cs	22	Active
Warning	RS1016	'AbstractGenerateMemberCodeFixProvider' registers one or more code fixes, but does not override the method 'CodeFixProvider.GetFixAllProvider'. Override this method and provide a non-null FixAllProvider for FixAll support, potentially 'WellKnownFixAllProviders.BatchFixer', or 'null' to explicitly disable FixAll support.	Features	c:\roslyn\src\Features\Core\Portable\CodeFixes\GenerateMember\AbstractGenerateMemberCodeFixProvider.cs	15	Active
Warning	RS1016	'AbstractIteratorCodeFixProvider' registers one or more code fixes, but does not override the method 'CodeFixProvider.GetFixAllProvider'. Override this method and provide a non-null FixAllProvider for FixAll support, potentially 'WellKnownFixAllProviders.BatchFixer', or 'null' to explicitly disable FixAll support.	Features	c:\roslyn\src\Features\Core\Portable\CodeFixes\Iterator\AbstractIteratorCodeFixProvider.cs	12	Active
Warning	RS1016	'NamingStyleCodeFixProvider' registers one or more code fixes, but does not override the method 'CodeFixProvider.GetFixAllProvider'. Override this method and provide a non-null FixAllProvider for FixAll support, potentially 'WellKnownFixAllProviders.BatchFixer', or 'null' to explicitly disable FixAll support.	Features	c:\roslyn\src\Features\Core\Portable\CodeFixes\NamingStyle\AbstractNamingStyleCodeFixProvider.cs	22	Active
Warning	RS1016	'AbstractResolveConflictMarkerCodeFixProvider' registers one or more code fixes, but does not override the method 'CodeFixProvider.GetFixAllProvider'. Override this method and provide a non-null FixAllProvider for FixAll support, potentially 'WellKnownFixAllProviders.BatchFixer', or 'null' to explicitly disable FixAll support.	Features	c:\roslyn\src\Features\Core\Portable\ConflictMarkerResolution\AbstractConflictMarkerCodeFixProvider.cs	14	Active
Warning	RS1016	'AbstractFullyQualifyCodeFixProvider' registers one or more code fixes, but does not override the method 'CodeFixProvider.GetFixAllProvider'. Override this method and provide a non-null FixAllProvider for FixAll support, potentially 'WellKnownFixAllProviders.BatchFixer', or 'null' to explicitly disable FixAll support.	Features	c:\roslyn\src\Features\Core\Portable\FullyQualify\AbstractFullyQualifyCodeFixProvider.cs	18	Active
Warning	RS1016	'AbstractSpellCheckCodeFixProvider' registers one or more code fixes, but does not override the method 'CodeFixProvider.GetFixAllProvider'. Override this method and provide a non-null FixAllProvider for FixAll support, potentially 'WellKnownFixAllProviders.BatchFixer', or 'null' to explicitly disable FixAll support.	Features	c:\roslyn\src\Features\Core\Portable\SpellCheck\AbstractSpellCheckCodeFixProvider.cs	15	Active
Warning	RS1016	'AbstractUpgradeProjectCodeFixProvider' registers one or more code fixes, but does not override the method 'CodeFixProvider.GetFixAllProvider'. Override this method and provide a non-null FixAllProvider for FixAll support, potentially 'WellKnownFixAllProviders.BatchFixer', or 'null' to explicitly disable FixAll support.	Features	c:\roslyn\src\Features\Core\Portable\UpgradeProject\AbstractUpgradeProjectCodeFixProvider.cs	15	Active
```</Description>
        <CreatedDate>02/12/2017</CreatedDate>
        <ClosedDate>17/04/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>29516</PullRequestID>
      <File>src/EditorFeatures/CSharpTest/CodeRefactorings/AddMissingImports/CSharpAddMissingImportsRefactoringProviderTests.cs</File>
      <File>src/EditorFeatures/Core/EditorFeaturesResources.Designer.cs</File>
      <File>src/EditorFeatures/Core/Extensibility/Commands/PredefinedCommandHandlerNames.cs</File>
      <File>src/EditorFeatures/Core/Implementation/PasteTracking/PasteTrackingPasteCommandHandlercs.cs</File>
      <File>src/EditorFeatures/Core/Implementation/PasteTracking/PasteTrackingService.cs</File>
      <File>src/EditorFeatures/Core/Implementation/TextDiffing/EditorTextDifferencingService.cs</File>
      <File>src/Features/CSharp/Portable/AddImport/CSharpAddMissingImportsFeatureService.cs</File>
      <File>src/Features/CSharp/Portable/CSharpFeaturesResources.Designer.cs</File>
      <File>src/Features/CSharp/Portable/CodeRefactorings/AddMissingImports/CSharpAddMissingImportsRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/AddImport/AbstractAddImportCodeFixProvider.cs</File>
      <File>src/Features/Core/Portable/AddImport/AbstractAddImportFeatureService.cs</File>
      <File>src/Features/Core/Portable/AddImport/CodeActions/AddImportCodeAction.cs</File>
      <File>src/Features/Core/Portable/AddImport/CodeActions/AssemblyReferenceCodeAction.cs</File>
      <File>src/Features/Core/Portable/AddImport/CodeActions/InstallPackageAndAddImportCodeAction.cs</File>
      <File>src/Features/Core/Portable/AddImport/CodeActions/InstallWithPackageManagerCodeAction.cs</File>
      <File>src/Features/Core/Portable/AddImport/CodeActions/MetadataSymbolReferenceCodeAction.cs</File>
      <File>src/Features/Core/Portable/AddImport/CodeActions/ParentInstallPackageCodeAction.cs</File>
      <File>src/Features/Core/Portable/AddImport/CodeActions/ProjectSymbolReferenceCodeAction.cs</File>
      <File>src/Features/Core/Portable/AddImport/CodeActions/SymbolReference.SymbolReferenceCodeAction.cs</File>
      <File>src/Features/Core/Portable/AddImport/IAddImportFeatureService.cs</File>
      <File>src/Features/Core/Portable/AddImport/Remote/IRemoteAddImportFeatureService.cs</File>
      <File>src/Features/Core/Portable/CodeRefactorings/AddMissingImports/AbstractAddMissingImportsFeatureService.cs</File>
      <File>src/Features/Core/Portable/CodeRefactorings/AddMissingImports/AbstractAddMissingImportsRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/CodeRefactorings/AddMissingImports/IAddMissingImportsFeatureService.cs</File>
      <File>src/Features/Core/Portable/CodeRefactorings/PredefinedCodeRefactoringProviderNames.cs</File>
      <File>src/Features/Core/Portable/PasteTracking/IPasteTrackingService.cs</File>
      <File>src/Test/Utilities/Portable/Traits/Traits.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Preview/ReferenceChange.cs</File>
      <File>src/Workspaces/Core/Portable/LinkedFileDiffMerging/DefaultDocumentTextDifferencingService.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/Solution/IDocumentTextDifferencingService.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/Solution/TextDifferenceTypes.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Services/CodeAnalysisService_AddImport.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>29405</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Fix #29390, add space after tuple type and identifier</Title>
    <Description>Fix for #29390

But I don't know what to do with this:
```csharp
var a = new(string a, int b)[10];
```

From my point of view it should have space:
```csharp
var a = new (string a, int b)[10];
```

Completely similar to:
```csharp
var a = new string[10];
var b = new Lazy&lt;int&gt;[10];
// etc.
```

We don't have spaces only in 2 cases:
```csharp
class Foo&lt;T&gt;
    where T : new() // case #1
{
    public Foo()
    {
        var a = new[2] { 1, 2 }; // case #2
    }
}
```

In both cases we don't specify any type here, so skip space looks natural.
But for tuple from my point of view it is unnatural, because tuple - is just a type, and for types we have extract space.

I've found a few discussions:
from @jcouv: https://github.com/dotnet/csharplang/issues/100#issuecomment-350823105
and @sharwell : https://github.com/dotnet/roslyn/pull/23686#discussion_r156090382

But I can't find final decision

Right now I'll leave test code commented. And will not add whitespace before tuple in `new` expression. I need your input on this.</Description>
    <CreatedDate>20/08/2018</CreatedDate>
    <ClosedDate>29/09/2018</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>29405</PullRequestID>
        <IssueID>29390</IssueID>
        <Title>NormalizeWhitespace do not add space after tuple type in parameter and in return</Title>
        <Description>**Version Used**: 
The same behavior on *2.8.2*, *2.9.0*

**Steps to Reproduce**:

1. Create method declaration:
```csharp
static void Main(string[] args)
{
    var methodDeclaration = SyntaxFactory.MethodDeclaration(
        new SyntaxList&lt;AttributeListSyntax&gt;(),
        SyntaxFactory.TokenList(SyntaxFactory.Token(SyntaxKind.PublicKeyword)),
        SyntaxFactory.ParseTypeName("(string prefix, string uri)"),
        null,
        SyntaxFactory.Identifier("XmlPoke"),
        null,
        SyntaxFactory.ParameterList(
            SyntaxFactory.SeparatedList(new[]
            {
                SyntaxFactory.Parameter(
                    new SyntaxList&lt;AttributeListSyntax&gt;(),
                    SyntaxFactory.TokenList(),
                    SyntaxFactory.ParseTypeName("(string prefix, string uri)"),
                    SyntaxFactory.Identifier("ns"),
                    null)
            })),
        SyntaxFactory.List(new List&lt;TypeParameterConstraintClauseSyntax&gt;()),
        null,
        null
    );

    Console.WriteLine(methodDeclaration);
    Console.WriteLine(methodDeclaration.NormalizeWhitespace());
}
```

2. Run it

**Expected Behavior**:
Add whitespace between name and tuple type in return statement and in parameter definition:
```csharp
public (string prefix, string uri) XmlPoke((string prefix, string uri) ns)
```

**Actual Behavior**:
There are missed whitespaces (github even can't highlight this code correctly).
```csharp
public (string prefix, string uri)XmlPoke((string prefix, string uri)ns)
```

I don't think that anyone expect such behavior.
If we replace `tuple` with array of tuple that everything will be correct:

```csharp
public (string prefix, string uri)[] XmlPoke((string prefix, string uri)[] ns)
```
</Description>
        <CreatedDate>19/08/2018</CreatedDate>
        <ClosedDate>29/09/2018</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>29405</PullRequestID>
        <IssueID>1</IssueID>
        <Title>Initial port and addition of README.md</Title>
        <Description>This is a port of the readme from CodePlex.  Some of the links have been updated to point to locations on GitHub, but many of the links still point back to CodePlex as comparable GitHub locations are currently absent.
</Description>
        <CreatedDate>14/01/2015</CreatedDate>
        <ClosedDate>14/01/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>29405</PullRequestID>
        <IssueID>2</IssueID>
        <Title>Update links in README.md with ported wiki content</Title>
        <Description>
        </Description>
        <CreatedDate>14/01/2015</CreatedDate>
        <ClosedDate>14/01/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>29405</PullRequestID>
      <File>src/Compilers/CSharp/Portable/Syntax/SyntaxNormalizer.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Syntax/SyntaxNormalizerTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>28929</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Don't fire IDE0009 incorrectly in List initializers</Title>
    <Description>When analyzing Invocation expressions, don't check `InstanceReferenceKind.ImplicitReceiver` as it shouldn't be qualified.
Because it's an invocation expression when it's used to determine which qualifier setting to use it tries to use the setting for methods.

Added test cases that I believe covers the relevant scenarios for the future.
See #28509, and this also solves #28091</Description>
    <CreatedDate>28/07/2018</CreatedDate>
    <ClosedDate>16/08/2018</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>28929</PullRequestID>
        <IssueID>28509</IssueID>
        <Title>IDE0009 Add 'this' or 'Me' qualification incorrectly reported</Title>
        <Description>Starting with Visual Studio 15.8.0 Preview 3, Visual Studio has started incorrectly reporting that a variable should be prefixes with `this.` when `dotnet_style_qualification_for_method` is set to true and you are using the variable in curly braces.

For example, the following shows up with errors in my IDE for `value` and `foo` inside of the curly braces due to them not being prefix'ed with `this.` which would cause this code to be invalid.

```csharp
public List&lt;String&gt; Foo(String value)
{
    var foo = "foo";
    return new List&lt;string&gt; { value, foo };
}
```

_This issue has been moved from https://developercommunity.visualstudio.com/content/problem/288604/ide0009-add-this-or-me-qualification-incorrectly-r-1.html
VSTS ticketId: 644505_
_These are the original issue comments:_
(no comments)
_These are the original issue solutions:_
(no solutions)</Description>
        <CreatedDate>13/07/2018</CreatedDate>
        <ClosedDate>16/08/2018</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>28929</PullRequestID>
        <IssueID>28091</IssueID>
        <Title>IDE0009 misfires when using dictionary initializer syntax within LINQ expression</Title>
        <Description>Similar to #23381, except related to dictionary initializer instead of object initializer.

**Version Used**: VS 15.8.0 Preview 3 (27821.2.d15.8)

**Steps to Reproduce**:

```cmd
git clone https://github.com/AArnott/Nerdbank.GitVersioning.git
cd Nerdbank.GitVersioning
src\Nerdbank.GitVersioning.sln
```

Open the Nerdbank.GitVersioning.Tasks/SetCloudBuildVariables.cs file and check out the error list.

**Expected Behavior**:

No warnings.

**Actual Behavior**:

![image](https://user-images.githubusercontent.com/3548/41822764-b70121e8-77a9-11e8-9d87-c6d49c1bfbce.png)

https://github.com/AArnott/Nerdbank.GitVersioning/blob/e0ccd4cf350a11df24d73dd3a06c225f17eb9474/src/Nerdbank.GitVersioning.Tasks/SetCloudBuildVariables.cs#L57-L59
</Description>
        <CreatedDate>24/06/2018</CreatedDate>
        <ClosedDate>16/08/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>28929</PullRequestID>
      <File>src/EditorFeatures/CSharpTest/QualifyMemberAccess/QualifyMemberAccessTests.cs</File>
      <File>src/Features/Core/Portable/QualifyMemberAccess/AbstractQualifyMemberAccessDiagnosticAnalyzer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>28849</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Use explicit date format provider to avoid tests breaking in different locales</Title>
    <Description>When running the test `TestDuplicateConstantAttributesMetadata` for VB it fails when the system locale is set to Swedish. See issue #28830 for more details.

It would also be possible solve this by removing the explicit `ToString()` call in the VB test to match the C# test that passes. I feel this is the wrong way to go as it still leaves things to chance, better to be explicit.
&lt;details&gt;&lt;summary&gt;Ask Mode template not completed&lt;/summary&gt;

&lt;!-- This template is not always required. If you aren't sure about whether it's needed or want help filling out the sections,
submit the pull request and then ask us for help. :) --&gt;

### Customer scenario

What does the customer do to get into this situation, and why do we think this
is common enough to address for this release.  (Granted, sometimes this will be
obvious "Open project, VS crashes" but in general, I need to understand how
common a scenario is)

### Bugs this fixes
#28830 
(either VSO or GitHub links)

### Workarounds, if any

Also, why we think they are insufficient for RC vs. RC2, RC3, or RTW

### Risk
Low or none, only affects tests
This is generally a measure our how central the affected code is to adjacent
scenarios and thus how likely your fix is to destabilize a broader area of code

### Performance impact
Low or none, only affects tests
(with a brief justification for that assessment (e.g. "Low perf impact because no extra allocations/no complexity changes" vs. "Low")

### Is this a regression from a previous update?

### Root cause analysis

How did we miss it?  What tests are we adding to guard against it in the future?

### How was the bug found?
Found when working on another issue and running the test suite.
(E.g. customer reported it vs. ad hoc testing)

### Test documentation updated?

If this is a new non-compiler feature or a significant improvement to an existing feature, update https://github.com/dotnet/roslyn/wiki/Manual-Testing once you know which release it is targeting.

&lt;/details&gt;
</Description>
    <CreatedDate>26/07/2018</CreatedDate>
    <ClosedDate>27/07/2018</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>28849</PullRequestID>
        <IssueID>28830</IssueID>
        <Title>VB version of TestDuplicateConstantAttributesMetadata is locale dependent</Title>
        <Description>**Version Used**: Master

**Steps to Reproduce**:

1. Set Windows to use Swedish locale for date/time and number settings
2. restore.cmd
3. build.cmd
4. test.cmd
Alternatively
2. restore.cmd
3. build in VS
4. Run the VB test `TestDuplicateConstantAttributesMetadata` only

**Expected Behavior**:
Test should pass like the C# version does.
**Actual Behavior**:
 Test fails with the following
```
Test Name:	Microsoft.CodeAnalysis.VisualBasic.UnitTests.Emit.OptionalArgumentsTests.TestDuplicateConstantAttributesMetadata
Test FullName:	Microsoft.CodeAnalysis.VisualBasic.UnitTests.Emit.OptionalArgumentsTests.TestDuplicateConstantAttributesMetadata
Test Source:	C:\code\roslyn\src\Compilers\VisualBasic\Test\Emit\Emit\OptionalArgumentsTests.vb : line 735
Test Outcome:	Failed
Test Duration:	0:00:03,188

Result StackTrace:	
at Roslyn.Test.Utilities.Desktop.DesktopRuntimeEnvironment.Execute(String moduleName, String[] args, String expectedOutput) in C:\code\roslyn\src\Test\Utilities\Portable\Platform\Desktop\DesktopRuntimeEnvironment.cs:line 245
   at Microsoft.CodeAnalysis.Test.Utilities.CompilationVerifier.Emit(String expectedOutput, Nullable`1 expectedReturnCode, String[] args, IEnumerable`1 manifestResources, EmitOptions emitOptions, Verification peVerify, SignatureDescription[] expectedSignatures) in C:\code\roslyn\src\Test\Utilities\Portable\CompilationVerifier.cs:line 114
   at Microsoft.CodeAnalysis.Test.Utilities.CommonTestBase.Emit(Compilation compilation, IEnumerable`1 dependencies, IEnumerable`1 manifestResources, SignatureDescription[] expectedSignatures, String expectedOutput, Nullable`1 expectedReturnCode, String[] args, Action`1 assemblyValidator, Action`1 symbolValidator, EmitOptions emitOptions, Verification verify) in C:\code\roslyn\src\Test\Utilities\Portable\CommonTestBase.cs:line 154
   at Microsoft.CodeAnalysis.Test.Utilities.CommonTestBase.CompileAndVerifyCommon(Compilation compilation, IEnumerable`1 manifestResources, IEnumerable`1 dependencies, Action`1 sourceSymbolValidator, Action`1 assemblyValidator, Action`1 symbolValidator, SignatureDescription[] expectedSignatures, String expectedOutput, Nullable`1 expectedReturnCode, String[] args, EmitOptions emitOptions, Verification verify) in C:\code\roslyn\src\Test\Utilities\Portable\CommonTestBase.cs:line 68
   at Microsoft.CodeAnalysis.VisualBasic.UnitTests.BasicTestBase.CompileAndVerify(Compilation compilation, IEnumerable`1 manifestResources, IEnumerable`1 dependencies, Action`1 sourceSymbolValidator, Action`1 validator, Action`1 symbolValidator, SignatureDescription[] expectedSignatures, String expectedOutput, Nullable`1 expectedReturnCode, String[] args, EmitOptions emitOptions, Verification verify) in C:\code\roslyn\src\Compilers\Test\Utilities\VisualBasic\BasicTestBase.vb:line 73
   at Microsoft.CodeAnalysis.VisualBasic.UnitTests.BasicTestBase.CompileAndVerify(Compilation compilation, XCData expectedOutput, String[] args, IEnumerable`1 manifestResources, IEnumerable`1 dependencies, Action`1 sourceSymbolValidator, Action`1 validator, Action`1 symbolValidator, SignatureDescription[] expectedSignatures, EmitOptions emitOptions, Verification verify) in C:\code\roslyn\src\Compilers\Test\Utilities\VisualBasic\BasicTestBase.vb:line 101
   at Microsoft.CodeAnalysis.VisualBasic.UnitTests.Emit.OptionalArgumentsTests.TestDuplicateConstantAttributesMetadata() in C:\code\roslyn\src\Compilers\VisualBasic\Test\Emit\Emit\OptionalArgumentsTests.vb:line 826
Result Message:	
Roslyn.Test.Utilities.ExecutionException : 
Execution failed for assembly 'C:\Users\Perbj\AppData\Local\Temp\RoslynTests'.
Expected: 
System.Reflection.Missing: System.Reflection.Missing
System.DateTime: 01/01/0001 00:00:00
System.DateTime: 01/01/0001 00:00:00
System.DateTime: 01/01/0001 00:00:00
System.Int32: 0
System.Int64: 3
System.Decimal: 3

Actual:   System.Reflection.Missing: System.Reflection.Missing
System.DateTime: 01-01-0001 00:00:00
System.DateTime: 01-01-0001 00:00:00
System.DateTime: 01-01-0001 00:00:00
System.Int32: 0
System.Int64: 3
System.Decimal: 3
```
Notice the different separators used in the date format.
</Description>
        <CreatedDate>25/07/2018</CreatedDate>
        <ClosedDate>09/09/2019</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>28849</PullRequestID>
        <IssueID>28830</IssueID>
        <Title>VB version of TestDuplicateConstantAttributesMetadata is locale dependent</Title>
        <Description>**Version Used**: Master

**Steps to Reproduce**:

1. Set Windows to use Swedish locale for date/time and number settings
2. restore.cmd
3. build.cmd
4. test.cmd
Alternatively
2. restore.cmd
3. build in VS
4. Run the VB test `TestDuplicateConstantAttributesMetadata` only

**Expected Behavior**:
Test should pass like the C# version does.
**Actual Behavior**:
 Test fails with the following
```
Test Name:	Microsoft.CodeAnalysis.VisualBasic.UnitTests.Emit.OptionalArgumentsTests.TestDuplicateConstantAttributesMetadata
Test FullName:	Microsoft.CodeAnalysis.VisualBasic.UnitTests.Emit.OptionalArgumentsTests.TestDuplicateConstantAttributesMetadata
Test Source:	C:\code\roslyn\src\Compilers\VisualBasic\Test\Emit\Emit\OptionalArgumentsTests.vb : line 735
Test Outcome:	Failed
Test Duration:	0:00:03,188

Result StackTrace:	
at Roslyn.Test.Utilities.Desktop.DesktopRuntimeEnvironment.Execute(String moduleName, String[] args, String expectedOutput) in C:\code\roslyn\src\Test\Utilities\Portable\Platform\Desktop\DesktopRuntimeEnvironment.cs:line 245
   at Microsoft.CodeAnalysis.Test.Utilities.CompilationVerifier.Emit(String expectedOutput, Nullable`1 expectedReturnCode, String[] args, IEnumerable`1 manifestResources, EmitOptions emitOptions, Verification peVerify, SignatureDescription[] expectedSignatures) in C:\code\roslyn\src\Test\Utilities\Portable\CompilationVerifier.cs:line 114
   at Microsoft.CodeAnalysis.Test.Utilities.CommonTestBase.Emit(Compilation compilation, IEnumerable`1 dependencies, IEnumerable`1 manifestResources, SignatureDescription[] expectedSignatures, String expectedOutput, Nullable`1 expectedReturnCode, String[] args, Action`1 assemblyValidator, Action`1 symbolValidator, EmitOptions emitOptions, Verification verify) in C:\code\roslyn\src\Test\Utilities\Portable\CommonTestBase.cs:line 154
   at Microsoft.CodeAnalysis.Test.Utilities.CommonTestBase.CompileAndVerifyCommon(Compilation compilation, IEnumerable`1 manifestResources, IEnumerable`1 dependencies, Action`1 sourceSymbolValidator, Action`1 assemblyValidator, Action`1 symbolValidator, SignatureDescription[] expectedSignatures, String expectedOutput, Nullable`1 expectedReturnCode, String[] args, EmitOptions emitOptions, Verification verify) in C:\code\roslyn\src\Test\Utilities\Portable\CommonTestBase.cs:line 68
   at Microsoft.CodeAnalysis.VisualBasic.UnitTests.BasicTestBase.CompileAndVerify(Compilation compilation, IEnumerable`1 manifestResources, IEnumerable`1 dependencies, Action`1 sourceSymbolValidator, Action`1 validator, Action`1 symbolValidator, SignatureDescription[] expectedSignatures, String expectedOutput, Nullable`1 expectedReturnCode, String[] args, EmitOptions emitOptions, Verification verify) in C:\code\roslyn\src\Compilers\Test\Utilities\VisualBasic\BasicTestBase.vb:line 73
   at Microsoft.CodeAnalysis.VisualBasic.UnitTests.BasicTestBase.CompileAndVerify(Compilation compilation, XCData expectedOutput, String[] args, IEnumerable`1 manifestResources, IEnumerable`1 dependencies, Action`1 sourceSymbolValidator, Action`1 validator, Action`1 symbolValidator, SignatureDescription[] expectedSignatures, EmitOptions emitOptions, Verification verify) in C:\code\roslyn\src\Compilers\Test\Utilities\VisualBasic\BasicTestBase.vb:line 101
   at Microsoft.CodeAnalysis.VisualBasic.UnitTests.Emit.OptionalArgumentsTests.TestDuplicateConstantAttributesMetadata() in C:\code\roslyn\src\Compilers\VisualBasic\Test\Emit\Emit\OptionalArgumentsTests.vb:line 826
Result Message:	
Roslyn.Test.Utilities.ExecutionException : 
Execution failed for assembly 'C:\Users\Perbj\AppData\Local\Temp\RoslynTests'.
Expected: 
System.Reflection.Missing: System.Reflection.Missing
System.DateTime: 01/01/0001 00:00:00
System.DateTime: 01/01/0001 00:00:00
System.DateTime: 01/01/0001 00:00:00
System.Int32: 0
System.Int64: 3
System.Decimal: 3

Actual:   System.Reflection.Missing: System.Reflection.Missing
System.DateTime: 01-01-0001 00:00:00
System.DateTime: 01-01-0001 00:00:00
System.DateTime: 01-01-0001 00:00:00
System.Int32: 0
System.Int64: 3
System.Decimal: 3
```
Notice the different separators used in the date format.
</Description>
        <CreatedDate>25/07/2018</CreatedDate>
        <ClosedDate>09/09/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>28849</PullRequestID>
      <File>src/Compilers/CSharp/Test/Emit/Emit/OptionalArgumentsTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>28781</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Migrate to Microsoft.VisualStudio.Threading</Title>
    <Description>This change implements the first step towards Roslyn working in applications using vs-threading with reduced risk of concurrency bugs. Recommend reviewing by commit after looking at the full list to get an idea for the overall direction.

Most of the work in this change involves internal propagation of the `IThreadingContext` instance, which provides access to the `JoinableTaskFactory` used in Roslyn code.

Following this pull request, several diagnostics remain disabled.

* VSTHRD002 (Avoid problematic synchronous waits): Many of the violations reported by this can be fixed by a code fix, but the code fix is a bit buggy and I'm waiting for Microsoft/vs-threading#338 so it's easier to prepare the fixes.
* VSTHRD103 (Call async methods when in an async method): This will be sent as a follow-up pull request. The analysis will be improved by Microsoft/vs-threading#331, but I didn't see any reason why it would block our use of the analyzer.
* VSTHRD110 (Observe result of async calls): We need to establish the "Roslyn desired practice for `FileAndForget`" before enabling this diagnostic.
* VSTHRD200 (Use "Async" suffix for async methods): Will send a follow-up PR to enable this and fix all cases that aren't exposed (public API and/or IVT). It affected too many files to include here.
* VSTHRD010 (Invoke single-threaded types on Main thread): This diagnostic is enabled, but its accuracy relies heavily on configuration files provided separately. The configuration for VSSDK types ships with the VSSDK analyzers, which are not yet enabled for the full Roslyn build.

Known follow-up issues (GitHub issues will be linked here once they are available):

* Enable VSTHRD002 (see above)
* Enable VSTHRD103 (see above)
* Enable VSTHRD110 (see above)
* Enable VSTHRD200 (see above)
* Configure `WaitAndGetResult` and `WaitAndGetResult_CanCallOnBackground` as problematic synchronous waits (blocked on Microsoft/vs-threading#344)
* Review code for additional methods to consider legacy thread switching APIs (blocked on Microsoft/vs-threading#332)
* Update VSSDK analyzers to enable VSTHRD010 (see above)
* Eliminate `ForegroundThreadDataKind`, and gut or eliminate `ForegroundThreadAffinitizedObject` https://github.com/dotnet/roslyn/pull/28781#discussion_r208386101
* Consider making `JoinableTaskContext` a required import for `ThreadingContext` https://github.com/dotnet/roslyn/pull/28781#discussion_r208386283
* Eliminate `JoinableTaskFactoryTaskScheduler`, or at least add it to the set of legacy thread switching types https://github.com/dotnet/roslyn/pull/28781#discussion_r208393493
* **PERF:** Improve **CPSProject_IWorkspaceProjectContext.cs** https://github.com/dotnet/roslyn/pull/28781#discussion_r208393997
* Design, implement, and uniformly use a main thread check/assert method https://github.com/dotnet/roslyn/pull/28781#discussion_r208405703
* **PERF:** Remove `AbstractPackage.ForegroundObject`, and its costly initialization https://github.com/dotnet/roslyn/pull/28781#discussion_r208391862
* Test devenv /build https://github.com/dotnet/roslyn/pull/28781#discussion_r208392896
* Audit uses of `ContinueWith`, `SafeContinueWith`, `StartNew`, `SafeStartNew`, and `Task.Run` to identify cases where simpler approaches are viable https://github.com/dotnet/roslyn/pull/28781#discussion_r208378244
* Inconsistent use of `TestWorkspace.GetService&lt;T&gt;` and `TestWorkspace.ExportProvider.GetExportedValue&lt;T&gt;` https://github.com/dotnet/roslyn/pull/28781#discussion_r208962835

### Customer scenario

This is an internal code change that allows dotnet/roslyn to be more easily incorporated into applications that involve user interfaces and leverage the Microsoft.VisualStudio.Threading library for deadlock and reentrancy mitigation and overall best practices.

### Bugs this fixes

N/A

### Workarounds, if any

Fixing bugs as they occur.

### Risk

This change has moderate risk, but I believe it's *relatively* low risk considering its scope since existing behaviors were preserved where possible. The primary points where I see risk are the following:

* Not all portions of code were updated to follow the [Three threading rules](https://github.com/Microsoft/vs-threading/blob/master/doc/threading_rules.md), and incremental adoption of vs-threading runs a risk of deadlocks when code does not follow these rules.
* While the documented precondition of `WaitAndGetResult` was weakened, the debug assertion it contained was strengthened substantially. This code does not affect release builds, but despite the work in this pull request it may continue to affect debug pull request builds.

### Performance impact

Performance should not change substantially as a direct result of this pull request. Over time, performance should improve by allowing more code to use asynchronous operations and more efficient task continuations.

### Is this a regression from a previous update?

N/A

### Root cause analysis

N/A

### How was the bug found?

N/A

### Test documentation updated?

N/A
</Description>
    <CreatedDate>23/07/2018</CreatedDate>
    <ClosedDate>13/08/2018</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>28781</PullRequestID>
        <IssueID>338</IssueID>
        <Title>Create new projects for System.Runtime.Analyzers</Title>
        <Description>This is the start of work to split up the FxCop analyzers into multiple packages that can ship with the APIs that they address.

Move rule CA1001 to this project. Rewrite the codefixer for it to be based on DocumentEditor and hence language agnostic.

Fix for CA1001 shouldn't generate a dispose method if there is already one in the type. Instead modify that method to make it the interface implementation. Adding some tests.
</Description>
        <CreatedDate>09/02/2015</CreatedDate>
        <ClosedDate>11/02/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>28781</PullRequestID>
        <IssueID>331</IssueID>
        <Title>Allow 'is' for static classes for compatibility</Title>
        <Description>but continue to report the diagnostic if "strict" mode is requested.
Fixes #324

&lt;!---
@huboard:{"order":324.25,"milestone_order":331,"custom_state":""}
--&gt;
</Description>
        <CreatedDate>09/02/2015</CreatedDate>
        <ClosedDate>10/02/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>28781</PullRequestID>
        <IssueID>344</IssueID>
        <Title>Roslyn (like the native compiler) allows default(StaticType), array of static type</Title>
        <Description>The following program shows that the Roslyn compiler (like the native compiler) allows `default(StaticType)` and allows you to create an array of a static type too. All of these break with things that the C# specification mandates. I don't think this could be fixed because that would be a breaking change, though if anyone is doing this accidentally they'd probably like to know about it.

``` cs
class Program
{
    static void Main(string[] args)
    {
        object o = default(C);
        object[] x = new [] { default(C) };
    }
}

static class C
{
}
```

&lt;!---
@huboard:{"order":3.28125,"milestone_order":344.0,"custom_state":""}
--&gt;
</Description>
        <CreatedDate>10/02/2015</CreatedDate>
        <ClosedDate>20/02/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>28781</PullRequestID>
        <IssueID>332</IssueID>
        <Title>Remove cancellation token from NavigateTo</Title>
        <Description>NavigateTo doesn't support cancellation when computing the display properties so the cancellation token is getting removed rather than having to manually handle an OperationCanceledException.
</Description>
        <CreatedDate>09/02/2015</CreatedDate>
        <ClosedDate>09/02/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>28781</PullRequestID>
      <File>src/EditorFeatures/CSharp/AutomaticCompletion/CSharpBraceCompletionSessionProvider.cs</File>
      <File>src/EditorFeatures/CSharp/FindUsages/CSharpFindUsagesService.cs</File>
      <File>src/EditorFeatures/CSharp/Formatting/CSharpEditorFormattingService.cs</File>
      <File>src/EditorFeatures/CSharp/Formatting/Indentation/SmartTokenFormatter.cs</File>
      <File>src/EditorFeatures/CSharp/GoToDefinition/CSharpGoToSymbolService.cs</File>
      <File>src/EditorFeatures/CSharpTest/Classification/SemanticClassifierTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Classification/SyntacticTaggerTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/CodeActions/Preview/PreviewExceptionTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/Suppression/SuppressionTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Formatting/Indentation/SmartTokenFormatterFormatRangeTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Interactive/BraceMatching/InteractiveBraceHighlightingTests.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Adornments/AbstractAdornmentManagerProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Adornments/AdornmentManager.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Completion/Presentation/CompletionPresenter.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Completion/Presentation/CompletionPresenterSession.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Completion/Presentation/CompletionSource.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Completion/Presentation/RoslynCompletionSet.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Completion/Presentation/ToolTipProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/IWpfDifferenceViewerExtensions.cs</File>
      <File>src/EditorFeatures/Core.Wpf/IWpfTextViewExtensions.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/InlineRenameService.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/InlineRenameSession.OpenTextBufferManager.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/InlineRenameSession.cs</File>
      <File>src/EditorFeatures/Core.Wpf/LineSeparators/LineSeparatorAdornmentManagerProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/LineSeparators/LineSeparatorTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/NavigateTo/NavigateToItemProvider.Searcher.cs</File>
      <File>src/EditorFeatures/Core.Wpf/NavigateTo/NavigateToItemProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Preview/PreviewFactoryService.cs</File>
      <File>src/EditorFeatures/Core.Wpf/QuickInfo/Converters/ProjectionBufferDeferredContentConverter.cs</File>
      <File>src/EditorFeatures/Core.Wpf/QuickInfo/Presentation/QuickInfoPresenter.QuickInfoPresenterSession.cs</File>
      <File>src/EditorFeatures/Core.Wpf/QuickInfo/Presentation/QuickInfoPresenter.QuickInfoSource.cs</File>
      <File>src/EditorFeatures/Core.Wpf/QuickInfo/Presentation/QuickInfoPresenter.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Structure/AbstractStructureTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Structure/BlockContextProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Structure/BlockTagState.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Structure/RoslynBlockTag.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Structure/RoslynOutliningRegionTag.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Structure/VisualStudio14StructureTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Structure/VisualStudio15StructureTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Suggestions/PreviewChanges/PreviewChangesSuggestedAction.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Suggestions/SuggestedActionWithNestedActions.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Suggestions/SuggestedActionWithNestedFlavors.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Suggestions/SuggestedActions/CodeFixSuggestedAction.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Suggestions/SuggestedActions/CodeRefactoringSuggestedAction.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Suggestions/SuggestedActions/FixAllSuggestedAction.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Suggestions/SuggestedActions/SuggestedAction.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Suggestions/SuggestedActionsSource.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Suggestions/SuggestedActionsSourceProvider.cs</File>
      <File>src/EditorFeatures/Core/CommandHandlers/AbstractCompletionCommandHandler.cs</File>
      <File>src/EditorFeatures/Core/CommandHandlers/CompletionCommandHandler.cs</File>
      <File>src/EditorFeatures/Core/CommandHandlers/QuickInfoCommandHandlerAndSourceProvider.cs</File>
      <File>src/EditorFeatures/Core/CommandHandlers/SignatureHelpCommandHandler.cs</File>
      <File>src/EditorFeatures/Core/FindReferences/FindReferencesCommandHandler.cs</File>
      <File>src/EditorFeatures/Core/FindUsages/AbstractFindUsagesService.ProgressAdapter.cs</File>
      <File>src/EditorFeatures/Core/FindUsages/AbstractFindUsagesService.cs</File>
      <File>src/EditorFeatures/Core/GoToDefinition/AbstractGoToSymbolService.cs</File>
      <File>src/EditorFeatures/Core/Implementation/AutomaticCompletion/AbstractEditorBraceCompletionSessionFactory.cs</File>
      <File>src/EditorFeatures/Core/Implementation/AutomaticCompletion/BraceCompletionSessionProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/BraceMatching/BraceHighlightingViewTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Classification/SemanticClassificationBufferTaggerProvider.Tagger.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Classification/SemanticClassificationBufferTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Classification/SemanticClassificationViewTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Classification/SyntacticClassificationTaggerProvider.TagComputer.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Classification/SyntacticClassificationTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/CodeActions/CodeActionEditHandlerService.cs</File>
      <File>src/EditorFeatures/Core/Implementation/CodeFixes/CodeFixService.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Diagnostics/AbstractDiagnosticsAdornmentTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Diagnostics/AbstractDiagnosticsTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Diagnostics/DiagnosticsClassificationTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Diagnostics/DiagnosticsSquiggleTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Diagnostics/DiagnosticsSuggestionTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/EditAndContinue/ActiveStatementTagger.cs</File>
      <File>src/EditorFeatures/Core/Implementation/EditAndContinue/ActiveStatementTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/EditAndContinue/ActiveStatementTrackingService.cs</File>
      <File>src/EditorFeatures/Core/Implementation/EditAndContinue/ReadOnlyDocumentTracker.cs</File>
      <File>src/EditorFeatures/Core/Implementation/ForegroundNotification/ForegroundNotificationService.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Formatting/FormatCommandHandler.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/AbstractController.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/Completion/AsyncCompletionService.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/Completion/Controller.Session_ComputeModel.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/Completion/Controller.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/Completion/Controller_CommitUniqueCompletionListItem.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/IDocumentProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/ModelComputation.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/QuickInfo/Controller.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/Session.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/SignatureHelp/Controller.Session.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/SignatureHelp/Controller.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/SignatureHelp/Presentation/SignatureHelpPresenter.SignatureHelpPresenterSession.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/SignatureHelp/Presentation/SignatureHelpPresenter.SignatureHelpSource.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/SignatureHelp/Presentation/SignatureHelpPresenter.cs</File>
      <File>src/EditorFeatures/Core/Implementation/KeywordHighlighting/HighlighterViewTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/NavigationBar/NavigationBarController.cs</File>
      <File>src/EditorFeatures/Core/Implementation/NavigationBar/NavigationBarControllerFactoryService.cs</File>
      <File>src/EditorFeatures/Core/Implementation/NavigationBar/NavigationBarController_ModelComputation.cs</File>
      <File>src/EditorFeatures/Core/Implementation/RenameTracking/RenameTrackingDiagnosticAnalyzer.cs</File>
      <File>src/EditorFeatures/Core/Implementation/RenameTracking/RenameTrackingTaggerProvider.RenameTrackingCommitter.cs</File>
      <File>src/EditorFeatures/Core/Implementation/RenameTracking/RenameTrackingTaggerProvider.StateMachine.cs</File>
      <File>src/EditorFeatures/Core/Implementation/RenameTracking/RenameTrackingTaggerProvider.TrackingSession.cs</File>
      <File>src/EditorFeatures/Core/Implementation/RenameTracking/RenameTrackingTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/SolutionPreviewResult.cs</File>
      <File>src/EditorFeatures/Core/ReferenceHighlighting/ReferenceHighlightingViewTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Shared/Preview/PreviewSolutionCrawlerRegistrationService.cs</File>
      <File>src/EditorFeatures/Core/Shared/Tagging/EventSources/TaggerEventSources.SemanticChangedEventSource.cs</File>
      <File>src/EditorFeatures/Core/Shared/Tagging/EventSources/TaggerEventSources.ViewSpanChangedEventSource.cs</File>
      <File>src/EditorFeatures/Core/Shared/Tagging/EventSources/TaggerEventSources.cs</File>
      <File>src/EditorFeatures/Core/Shared/Threading/AsynchronousSerialWorkQueue.cs</File>
      <File>src/EditorFeatures/Core/Shared/Utilities/ForegroundThreadAffinitizedObject.cs</File>
      <File>src/EditorFeatures/Core/Shared/Utilities/IThreadingContext.cs</File>
      <File>src/EditorFeatures/Core/Shared/Utilities/MainThreadAwaitableExtensions.cs</File>
      <File>src/EditorFeatures/Core/Shared/Utilities/ResettableDelay.cs</File>
      <File>src/EditorFeatures/Core/Shared/Utilities/ThreadingContext+DenyExecutionSynchronizationContext.cs</File>
      <File>src/EditorFeatures/Core/Shared/Utilities/ThreadingContext.cs</File>
      <File>src/EditorFeatures/Core/Tagging/AbstractAsynchronousTaggerProvider.BatchChangeNotifier.cs</File>
      <File>src/EditorFeatures/Core/Tagging/AbstractAsynchronousTaggerProvider.TagSource.cs</File>
      <File>src/EditorFeatures/Core/Tagging/AbstractAsynchronousTaggerProvider.Tagger.cs</File>
      <File>src/EditorFeatures/Core/Tagging/AbstractAsynchronousTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Tagging/AsynchronousTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Tagging/AsynchronousViewTaggerProvider.cs</File>
      <File>src/EditorFeatures/Test/CodeFixes/CodeFixServiceTests.cs</File>
      <File>src/EditorFeatures/Test/Diagnostics/DiagnosticsSquiggleTaggerProviderTests.cs</File>
      <File>src/EditorFeatures/Test/LineSeparators/AdornmentManagerTests.cs</File>
      <File>src/EditorFeatures/Test/Preview/PreviewWorkspaceTests.cs</File>
      <File>src/EditorFeatures/Test/RenameTracking/RenameTrackingTestState.cs</File>
      <File>src/EditorFeatures/Test/Structure/StructureTaggerTests.cs</File>
      <File>src/EditorFeatures/Test/Tagging/AsynchronousTaggerTests.cs</File>
      <File>src/EditorFeatures/Test/Threading/AsynchronousWorkerTests.cs</File>
      <File>src/EditorFeatures/Test/Threading/ForegroundNotificationServiceTests.cs</File>
      <File>src/EditorFeatures/TestUtilities/Async/WaitHelper.cs</File>
      <File>src/EditorFeatures/TestUtilities/AutomaticCompletion/AbstractAutomaticBraceCompletionTests.cs</File>
      <File>src/EditorFeatures/TestUtilities/BraceHighlighting/AbstractBraceHighlightingTests.cs</File>
      <File>src/EditorFeatures/TestUtilities/Diagnostics/DiagnosticTaggerWrapper.cs</File>
      <File>src/EditorFeatures/TestUtilities/EditorFactory.cs</File>
      <File>src/EditorFeatures/TestUtilities/MinimalTestExportProvider.cs</File>
      <File>src/EditorFeatures/TestUtilities/StubVsEditorAdaptersFactoryService.cs</File>
      <File>src/EditorFeatures/TestUtilities/TestExportJoinableTaskContext.cs</File>
      <File>src/EditorFeatures/TestUtilities/TestExportProvider.cs</File>
      <File>src/EditorFeatures/TestUtilities/Threading/SynchronizationContextTaskScheduler.cs</File>
      <File>src/EditorFeatures/TestUtilities/Threading/WpfTestRunner.cs</File>
      <File>src/EditorFeatures/TestUtilities/Workspaces/TestHostDocument.cs</File>
      <File>src/EditorFeatures/TestUtilities/Workspaces/TestWorkspace.cs</File>
      <File>src/Features/CSharp/Portable/ChangeSignature/CSharpChangeSignatureService.cs</File>
      <File>src/Features/Core/Portable/ChangeSignature/DelegateInvokeMethodReferenceFinder.cs</File>
      <File>src/Features/Core/Portable/Completion/Providers/AbstractMemberInsertingCompletionProvider.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/DiagnosticAnalyzerService_UpdateSource.cs</File>
      <File>src/Features/Core/Portable/ExtractInterface/AbstractExtractInterfaceService.cs</File>
      <File>src/Interactive/EditorFeatures/CSharp/Interactive/CSharpInteractiveEvaluator.cs</File>
      <File>src/Interactive/EditorFeatures/Core/CommandHandlers/InteractiveCompletionCommandHandler.cs</File>
      <File>src/Interactive/EditorFeatures/Core/Extensibility/Interactive/InteractiveEvaluator.cs</File>
      <File>src/Interactive/EditorFeatures/Core/Implementation/Completion/Presentation/CompletionPresenter.cs</File>
      <File>src/Interactive/Features/Interactive/Core/InteractiveHost.RemoteService.cs</File>
      <File>src/Scripting/CSharpTest/ScriptTests.cs</File>
      <File>src/Test/Diagnostics/TestingOnly_WaitingService.cs</File>
      <File>src/Test/Utilities/Portable/Diagnostics/CommonDiagnosticAnalyzers.cs</File>
      <File>src/VisualStudio/CSharp/Impl/EventHookup/EventHookupCommandHandler.cs</File>
      <File>src/VisualStudio/CSharp/Impl/EventHookup/EventHookupSessionManager.cs</File>
      <File>src/VisualStudio/CSharp/Impl/EventHookup/EventHookupSessionManager_EventHookupSession.cs</File>
      <File>src/VisualStudio/CSharp/Impl/LanguageService/CSharpOptionPageService.cs</File>
      <File>src/VisualStudio/CSharp/Impl/LanguageService/HACK_CSharpCreateServicesOnUIThread.cs</File>
      <File>src/VisualStudio/CSharp/Impl/ObjectBrowser/CSharpSyncClassViewCommandHandler.cs</File>
      <File>src/VisualStudio/CSharp/Impl/Progression/CSharpGraphProvider.cs</File>
      <File>src/VisualStudio/CSharp/Impl/ProjectSystemShim/CSharpProjectShim.cs</File>
      <File>src/VisualStudio/CSharp/Impl/Snippets/CSharpSnippetInfoService.cs</File>
      <File>src/VisualStudio/CSharp/Impl/Snippets/SnippetCommandHandler.cs</File>
      <File>src/VisualStudio/CSharp/Impl/Snippets/SnippetExpansionClient.cs</File>
      <File>src/VisualStudio/CSharp/Repl/CSharpVsInteractiveWindowProvider.cs</File>
      <File>src/VisualStudio/CSharp/Test/CodeModel/FileCodeModelTestHelpers.cs</File>
      <File>src/VisualStudio/CSharp/Test/EventHookup/EventHookupTestState.cs</File>
      <File>src/VisualStudio/Core/Def/Experimentation/VisualStudioExperimentationService.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/DesignerAttribute/DesignerAttributeIncrementalAnalyzer.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/DesignerAttribute/DesignerAttributeIncrementalAnalyzerProvider.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/EditAndContinue/VsENCRebuildableProjectImpl.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/EditAndContinue/VsReadOnlyDocumentTracker.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Experimentation/AnalyzerVsixSuggestedActionCallback.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Experimentation/KeybindingResetDetector.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/FindReferences/Entries/DocumentSpanEntry.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/FindReferences/StreamingFindUsagesPresenter.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/FindReferences/ToolTips/LazyToolTip.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/InfoBar/VisualStudioInfoBarService.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Interop/CleanableWeakComHandleTable.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/LanguageService/AbstractPackage.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/LanguageService/HACK_AbstractCreateServicesOnUiThread.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Library/ClassView/AbstractSyncClassViewCommandHandler.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Library/ObjectBrowser/AbstractObjectBrowserLibraryManager.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Options/LanguageSettingsPersister.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Options/LocalUserRegistryOptionPersister.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Options/RoamingVisualStudioProfileOptionPersister.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Preview/AbstractChange.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Preview/ChangeList.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Preview/PreviewEngine.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Preview/PreviewService.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Preview/PreviewUpdater.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/PreviewPane/PreviewPaneService.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Progression/GraphNavigatorExtension.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Progression/GraphProvider.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/AbstractProject.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/DocumentProvider.StandardTextDocument.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/DocumentProvider.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/Legacy/AbstractLegacyProject.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/LinkedFileUtilities.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/MetadataReferences/VisualStudioFrameworkAssemblyPathResolverFactory.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/MiscellaneousFilesWorkspace.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/VisualStudioProjectManagementService.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/VisualStudioProjectTracker.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/VisualStudioWorkspaceImpl.DeferredInitialization.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/VisualStudioWorkspaceImpl.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/VisualStudioWorkspaceImpl_IVsSolutionLoadEvents.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Remote/RemoteHostClientServiceFactory.RemoteHostClientService.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Remote/RemoteHostClientServiceFactory.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Snippets/AbstractSnippetCommandHandler.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Snippets/AbstractSnippetExpansionClient.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Snippets/AbstractSnippetInfoService.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Venus/ContainedDocument.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Venus/ContainedLanguage.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/VirtualMemoryNotificationListener.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/VsRefactorNotifyService.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Workspace/GlobalUndoServiceFactory.WorkspaceGlobalUndoTransaction.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Workspace/GlobalUndoServiceFactory.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Workspace/VisualStudioDocumentNavigationService.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Workspace/VisualStudioDocumentNavigationServiceFactory.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Workspace/VisualStudioSymbolNavigationService.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Workspace/VisualStudioTaskSchedulerFactory.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Workspace/WorkspaceFailureOutputPane.cs</File>
      <File>src/VisualStudio/Core/Def/Packaging/PackageInstallerServiceFactory.cs</File>
      <File>src/VisualStudio/Core/Def/RoslynPackage.cs</File>
      <File>src/VisualStudio/Core/Def/Shared/VisualStudioImageMonikerService.cs</File>
      <File>src/VisualStudio/Core/Def/Storage/VisualStudioPersistentStorageLocationService.cs</File>
      <File>src/VisualStudio/Core/Def/SymbolSearch/AbstractDelayStartedService.cs</File>
      <File>src/VisualStudio/Core/Def/SymbolSearch/VisualStudioSymbolSearchService.LogService.cs</File>
      <File>src/VisualStudio/Core/Def/SymbolSearch/VisualStudioSymbolSearchService.cs</File>
      <File>src/VisualStudio/Core/Impl/CodeModel/CodeModelProjectCache.cs</File>
      <File>src/VisualStudio/Core/Impl/CodeModel/CodeModelState.cs</File>
      <File>src/VisualStudio/Core/Impl/CodeModel/FileCodeModel.cs</File>
      <File>src/VisualStudio/Core/Impl/CodeModel/ProjectCodeModel.cs</File>
      <File>src/VisualStudio/Core/Impl/ProjectSystem/CPS/CPSProject.cs</File>
      <File>src/VisualStudio/Core/Impl/ProjectSystem/CPS/CPSProjectFactory.cs</File>
      <File>src/VisualStudio/Core/Impl/ProjectSystem/CPS/CPSProject_IWorkspaceProjectContext.cs</File>
      <File>src/VisualStudio/Core/Test.Next/Remote/RemoteHostClientServiceFactoryTests.cs</File>
      <File>src/VisualStudio/IntegrationTest/TestUtilities/InProcess/InProcComponent.cs</File>
      <File>src/Workspaces/Core/Portable/Formatting/Formatter.cs</File>
      <File>src/Workspaces/Core/Portable/Utilities/ForegroundThreadDataKind.cs</File>
      <File>src/Workspaces/Core/Portable/Utilities/TaskExtensions.cs</File>
      <File>src/Workspaces/CoreTestUtilities/DispatcherExtensions.cs</File>
      <File>src/Workspaces/CoreTestUtilities/TestExportJoinableTaskContext.cs</File>
      <File>src/Workspaces/CoreTestUtilities/UseExportProviderAttribute.cs</File>
      <File>src/Workspaces/MSBuildTest/MSBuildWorkspaceTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>28776</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Remove this recommendation for anonymous functions in static methods</Title>
    <Description>### Customer scenario

`this` keyword should not be offered as completion for anonymous functions in static methods

### Bugs this fixes

Fixes #27923 

### Workarounds, if any

Do not select `this` when offered for anonymous functions in static methods.

### Risk

Little risk.

### Performance impact

Low.

### Is this a regression from a previous update?

No.

### Root cause analysis

Missed this in [PR #27690](https://github.com/dotnet/roslyn/pull/27690).

### How was the bug found?

@Neme12 found this in [PR #27690](https://github.com/dotnet/roslyn/pull/27690)

### Test documentation updated?

Test documentation update is not needed for this PR.

&lt;/details&gt;
</Description>
    <CreatedDate>22/07/2018</CreatedDate>
    <ClosedDate>11/09/2018</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>28776</PullRequestID>
        <IssueID>27923</IssueID>
        <Title>Completion for `this` is always offered in anonymous functions</Title>
        <Description>```c#
using System;

class Foo
{
    static void M()
    {
        Action a = () =&gt;
        {
			$$
        };

        Action b = delegate
        {
            $$
        };
    }
}
```
In both places at `$$`, `this` keyword is offered even though the method is static.

Discovered here:
https://github.com/dotnet/roslyn/pull/27690#pullrequestreview-128730842

I believe the fix should be really easy - just modify `method.MethodKind == MethodKind.LocalFunction` to `method.MethodKind == MethodKind.LocalFunction || method.MethodKind == MethodKind.AnonymousFunction` and add appropriate tests including nested anonymous functions and possibly even cases with a lambda inside a local function and vice versa, if you want to be extra diligent :smile:</Description>
        <CreatedDate>15/06/2018</CreatedDate>
        <ClosedDate>11/09/2018</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>28776</PullRequestID>
        <IssueID>27690</IssueID>
        <Title>Recommend 'this' inside local functions</Title>
        <Description>### Customer scenario
Try to type `this` inside a local function that is inside an instance method. `this` should be offered as a completion.

### Bugs this fixes
Fixes https://github.com/dotnet/roslyn/issues/27028

### Workarounds, if any
Type `this` in full.

### Risk
### Performance impact
Low. The change only impacts the case of typing inside a local function.

### Is this a regression from a previous update?
No.

### Root cause analysis
The semantic model shows local functions as static (since that is how they are emitted).

### How was the bug found?
Internally.</Description>
        <CreatedDate>10/06/2018</CreatedDate>
        <ClosedDate>12/06/2018</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>28776</PullRequestID>
        <IssueID>27690</IssueID>
        <Title>Recommend 'this' inside local functions</Title>
        <Description>### Customer scenario
Try to type `this` inside a local function that is inside an instance method. `this` should be offered as a completion.

### Bugs this fixes
Fixes https://github.com/dotnet/roslyn/issues/27028

### Workarounds, if any
Type `this` in full.

### Risk
### Performance impact
Low. The change only impacts the case of typing inside a local function.

### Is this a regression from a previous update?
No.

### Root cause analysis
The semantic model shows local functions as static (since that is how they are emitted).

### How was the bug found?
Internally.</Description>
        <CreatedDate>10/06/2018</CreatedDate>
        <ClosedDate>12/06/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>28776</PullRequestID>
      <File>src/EditorFeatures/CSharpTest2/Recommendations/ThisKeywordRecommenderTests.cs</File>
      <File>src/Workspaces/CSharp/Portable/Extensions/ContextQuery/SyntaxTreeExtensions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>28217</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Enable refactorings which were unintentionally removed by 'none' severity</Title>
    <Description>### Customer scenario

A customer creates a .editorconfig file with `none` severity for rules they do not wish to enforce. After updating to Visual Studio 2017 version 15.8 Preview 3, some manual refactorings related to these rules stop working as well. The impacted refactorings are:

* Use implicit type
* Use explicit type
* Use expression body
* Use block body

### Bugs this fixes

N/A

### Workarounds, if any

Update the .editorconfig to specify `silent` instead of `none`.

### Risk

The risk is relatively low.

### Performance impact

None relative to 15.8 Preview 2 and earlier. The refactoring is now evaluated in the same manner and locations it was prior to the change in meaning of `none` severity in .editorconfig.

### Is this a regression from a previous update?

Yes, introduced by #27220.

### Root cause analysis

Currently we test the diagnostic analyzers separately from the refactorings, even when the two are operating on the same underlying feature in code. Each set of tests assumes behavior about the other in order to test the remaining cases. #27720 caused the analyzer to no longer operate under one of these scenarios where the refactoring tests continued to assume the diagnostic would provide a code fix.

The ideal fix is implementing a new test strategy that enables multiple analyzers and/or code fixes known to operate on the same body of code, and make assertions about the combined impact from the user's perspective. These assertions would more accurately reflect the behavior of the application in production, and detect two specific situations that are currently undetected by tests:

1. Tests would fail if the analyzer stopped providing a code fix and the refactoring was not updated to offer it (and vice versa)
2. Tests would fail if the analyzer started offering a code fix and the refactoring was not updated to exclude it (and vice versa)

I have filed #28216 to improve this situation in the future.

### How was the bug found?

Dogfooding.

### Test documentation updated?

No.
</Description>
    <CreatedDate>29/06/2018</CreatedDate>
    <ClosedDate>02/07/2018</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>28217</PullRequestID>
        <IssueID>27220</IssueID>
        <Title>Map 'none' in .editorconfig to ReportDiagnostic.Suppress</Title>
        <Description>Fixes #26972 

:memo: This is an intentionally constrained change.

* Each commit is a unit of work (single topic, complete, all tests passing). I **strongly encourage** reviewing each commit separately after a quick look to understand the overall direction.
* All *known* breaking (or possibly breaking) changes, except for those described in the design for #26972, are called out in comments.
* The inconsistent handling of `DiagnosticSeverity.Hidden` is preserved for all current diagnostics. Given the new ability to differentiate between `ReportDiagnostic.Hidden` and `ReportDiagnostic.Suppress`, we will likely want to revisit this behavior and make all diagnostics consistent.

&lt;details&gt;&lt;summary&gt;Ask Mode template not completed&lt;/summary&gt;

&lt;!-- This template is not always required. If you aren't sure about whether it's needed or want help filling out the sections,
submit the pull request and then ask us for help. :) --&gt;

### Customer scenario

What does the customer do to get into this situation, and why do we think this
is common enough to address for this release.  (Granted, sometimes this will be
obvious "Open project, VS crashes" but in general, I need to understand how
common a scenario is)

### Bugs this fixes

(either VSO or GitHub links)

### Workarounds, if any

Also, why we think they are insufficient for RC vs. RC2, RC3, or RTW

### Risk

This is generally a measure our how central the affected code is to adjacent
scenarios and thus how likely your fix is to destabilize a broader area of code

### Performance impact

(with a brief justification for that assessment (e.g. "Low perf impact because no extra allocations/no complexity changes" vs. "Low")

### Is this a regression from a previous update?

### Root cause analysis

How did we miss it?  What tests are we adding to guard against it in the future?

### How was the bug found?

(E.g. customer reported it vs. ad hoc testing)

### Test documentation updated?

If this is a new non-compiler feature or a significant improvement to an existing feature, update https://github.com/dotnet/roslyn/wiki/Manual-Testing once you know which release it is targeting.

&lt;/details&gt;
</Description>
        <CreatedDate>29/05/2018</CreatedDate>
        <ClosedDate>11/06/2018</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>28217</PullRequestID>
        <IssueID>27720</IssueID>
        <Title>build -pack does not work</Title>
        <Description>In master branch, in a clean repository, repro as follows:

``` none
cd Roslyn
restore
build -pack
```

![image](https://user-images.githubusercontent.com/3804346/41251846-0d794940-6d70-11e8-8674-fa170918645b.png)

This is blocking our attempt to diagnose #27523 

</Description>
        <CreatedDate>11/06/2018</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>28217</PullRequestID>
        <IssueID>28216</IssueID>
        <Title>Create combined tests for diagnostic/refactoring pairs</Title>
        <Description>Currently analyzers and refactorings are tested separately, which leaves the test suite unable to detect certain regressions. See the root cause analysis in #28217 for details.</Description>
        <CreatedDate>29/06/2018</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>28217</PullRequestID>
      <File>src/EditorFeatures/CSharpTest/CodeActions/UseExplicitType/UseExplicitTypeRefactoringTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/CodeActions/UseImplicitType/UseImplicitTypeRefactoringTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/CodeRefactorings/UseExplicitOrImplicitType/AbstractUseTypeRefactoringTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/CodeRefactorings/UseExplicitOrImplicitType/UseExplicitTypeRefactoringTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/CodeRefactorings/UseExplicitOrImplicitType/UseImplicitTypeRefactoringTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseExpressionBody/Refactoring/UseExpressionBodyForAccessorsRefactoringTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseExpressionBody/Refactoring/UseExpressionBodyForConstructorsRefactoringTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseExpressionBody/Refactoring/UseExpressionBodyForConversionOperatorsRefactoringTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseExpressionBody/Refactoring/UseExpressionBodyForIndexersRefactoringTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseExpressionBody/Refactoring/UseExpressionBodyForMethodsRefactoringTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseExpressionBody/Refactoring/UseExpressionBodyForOperatorsRefactoringTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseExpressionBody/Refactoring/UseExpressionBodyForPropertiesRefactoringTests.cs</File>
      <File>src/Features/CSharp/Portable/CodeRefactorings/UseExplicitOrImplicitType/AbstractUseTypeCodeRefactoringProvider.cs</File>
      <File>src/Features/CSharp/Portable/UseExpressionBody/Helpers/UseExpressionBodyHelper`1.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>28090</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Fix NRE when handling multiline documentation comments in C#</Title>
    <Description>Fixes #25746.  
Fixes #27223.

This is a small fix: the extension method that caused the exception/crash now returns `false` when the parameter is `null`.

Side note: I don't know whether the current behaviour (insert exterior trivia text on the next line in both cases) is the expected behaviour, but it's in line with VB's behaviour.

### Customer scenario

After pressing &lt;kbd&gt;Enter&lt;/kbd&gt; on a line starting with `///`, a gold bar (or error dialog) is shown alerting the user to a problem running an internal command.

### Bugs this fixes

Fixes #25746.  
Fixes #27223.

### Workarounds, if any

Enter the text using a different order.

### Risk

Low.

### Performance impact

None significant.

### Is this a regression from a previous update?

No.

### Root cause analysis

Two edge cases related to handling &lt;kbd&gt;Enter&lt;/kbd&gt; within documentation comments (or comments that *look* like documentation comments were identified. Tests were added to prevent regressing these cases in the future.

### How was the bug found?

Multiple but rare reports from internal and external customers.

### Test documentation updated?

No.
</Description>
    <CreatedDate>23/06/2018</CreatedDate>
    <ClosedDate>12/07/2018</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>28090</PullRequestID>
        <IssueID>25746</IssueID>
        <Title>NullReferenceException in DocumentationCommentExtensions.IsMultilineDocComment</Title>
        <Description>Originally posted by @Jehoel in DotNetAnalyzers/StyleCopAnalyzers#2648

&gt; While a editing C# Console project and typing "//////" on an empty line line inside my `void Main` I got a message informing me an Editor Extension had crashed.
&gt; 
&gt; Here's the message logged in `ActivityLog.xml`:
&gt; 
&gt; ```
&gt; System.NullReferenceException: Object reference not set to an instance of an object.
&gt;    at Microsoft.CodeAnalysis.CSharp.Extensions.DocumentationCommentExtensions.IsMultilineDocComment(DocumentationCommentTriviaSyntax documentationComment)
&gt;    at Microsoft.CodeAnalysis.Editor.CSharp.DocumentationComments.DocumentationCommentCommandHandler.IsMultilineDocComment(DocumentationCommentTriviaSyntax documentationComment)
&gt;    at Microsoft.CodeAnalysis.Editor.Implementation.DocumentationComments.AbstractDocumentationCommentCommandHandler`2.TryGenerateExteriorTriviaAfterEnter(SyntaxTree syntaxTree, SourceText text, Int32 position, Int32 originalPosition, ITextBuffer subjectBuffer, ITextView textView, DocumentOptionSet options, CancellationToken cancellationToken)
&gt;    at Microsoft.CodeAnalysis.Editor.Implementation.DocumentationComments.AbstractDocumentationCommentCommandHandler`2.InsertOnEnterTyped(SyntaxTree syntaxTree, SourceText text, Int32 position, Int32 originalPosition, ITextBuffer subjectBuffer, ITextView textView, DocumentOptionSet options, CancellationToken cancellationToken)
&gt;    at Microsoft.CodeAnalysis.Editor.Implementation.DocumentationComments.AbstractDocumentationCommentCommandHandler`2.CompleteComment(ITextBuffer subjectBuffer, ITextView textView, Int32 originalCaretPosition, Func`9 insertAction, CancellationToken cancellationToken)
&gt;    at Microsoft.CodeAnalysis.Editor.Implementation.DocumentationComments.AbstractDocumentationCommentCommandHandler`2.ExecuteCommand(ReturnKeyCommandArgs args, CommandExecutionContext context)
&gt;    at Microsoft.VisualStudio.Commanding.CommandHandlerExtensions.ExecuteCommand[T](ICommandHandler commandHandler, T args, Action nextCommandHandler, CommandExecutionContext executionContext)
&gt;    at Microsoft.VisualStudio.UI.Text.Commanding.Implementation.EditorCommandHandlerService.&lt;&gt;c__DisplayClass14_1`1.&lt;Execute&gt;b__1()
&gt;    at Microsoft.VisualStudio.Text.Utilities.GuardedOperations.CallExtensionPoint(Object errorSource, Action call)
&gt; --- End of stack trace from previous location where exception was thrown ---
&gt;    at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject)
&gt; ```
&gt; 
&gt; Repro steps:
&gt; 
&gt; 1. Open an existing C# console project in VS 2017 (15.6.4)
&gt; 2. On an empty line inside a method type "/////" (several forward-slashes)
&gt; 3. VS will display the extension crash warning dialog. The above stack-trace will be written to `ActivityLog.xml`.
</Description>
        <CreatedDate>27/03/2018</CreatedDate>
        <ClosedDate>12/07/2018</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>28090</PullRequestID>
        <IssueID>27223</IssueID>
        <Title>NRE from DocumentationCommentExtensions.IsMultilineDocComment</Title>
        <Description>[VS Feedback issue](https://developercommunity.visualstudio.com/content/problem/229613/nullreferenceexception-in-ismultilinedoccomment.html)

Repro:

Create a console app, place cursor in line 10 between `&lt;summary&gt;` and `&lt;/summary&gt;`, hit enter.

```C#
namespace ConsoleApp
{
    class Program
    {
        static void Main(string[] args)
        {
            const string code = @"
class Program
{
    /// &lt;summary&gt;&lt;/summary&gt;
    static void Main(string[] args)
    {
    }
}
";
        }
    }
}
```

Stack trace:

```
System.NullReferenceException: Object reference not set to an instance of an object.
 at Microsoft.CodeAnalysis.CSharp.Extensions.DocumentationCommentExtensions.IsMultilineDocComment(DocumentationCommentTriviaSyntax documentationComment)
 at Microsoft.CodeAnalysis.Editor.CSharp.DocumentationComments.DocumentationCommentCommandHandler.IsMultilineDocComment(DocumentationCommentTriviaSyntax documentationComment)
 at Microsoft.CodeAnalysis.Editor.Implementation.DocumentationComments.AbstractDocumentationCommentCommandHandler`2.TryGenerateExteriorTriviaAfterEnter(SyntaxTree syntaxTree, SourceText text, Int32 position, Int32 originalPosition, ITextBuffer subjectBuffer, ITextView textView, DocumentOptionSet options, CancellationToken cancellationToken)
 at Microsoft.CodeAnalysis.Editor.Implementation.DocumentationComments.AbstractDocumentationCommentCommandHandler`2.InsertOnEnterTyped(SyntaxTree syntaxTree, SourceText text, Int32 position, Int32 originalPosition, ITextBuffer subjectBuffer, ITextView textView, DocumentOptionSet options, CancellationToken cancellationToken)
 at Microsoft.CodeAnalysis.Editor.Implementation.DocumentationComments.AbstractDocumentationCommentCommandHandler`2.CompleteComment(ITextBuffer subjectBuffer, ITextView textView, Int32 originalCaretPosition, Func`9 insertAction, CancellationToken cancellationToken)
 at Microsoft.CodeAnalysis.Editor.Implementation.DocumentationComments.AbstractDocumentationCommentCommandHandler`2.ExecuteCommand(ReturnKeyCommandArgs args, CommandExecutionContext context)
 at Microsoft.VisualStudio.Commanding.CommandHandlerExtensions.ExecuteCommand[T](ICommandHandler commandHandler, T args, Action nextCommandHandler, CommandExecutionContext executionContext)
 at Microsoft.VisualStudio.UI.Text.Commanding.Implementation.EditorCommandHandlerService.&lt;&gt;c__DisplayClass14_1`1.&lt;Execute&gt;b__1()
 at Microsoft.VisualStudio.Text.Utilities.GuardedOperations.CallExtensionPoint(Object errorSource, Action call)
 --- End of stack trace from previous location where exception was thrown ---
 at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject) 
```</Description>
        <CreatedDate>29/05/2018</CreatedDate>
        <ClosedDate>12/07/2018</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>28090</PullRequestID>
        <IssueID>25746</IssueID>
        <Title>NullReferenceException in DocumentationCommentExtensions.IsMultilineDocComment</Title>
        <Description>Originally posted by @Jehoel in DotNetAnalyzers/StyleCopAnalyzers#2648

&gt; While a editing C# Console project and typing "//////" on an empty line line inside my `void Main` I got a message informing me an Editor Extension had crashed.
&gt; 
&gt; Here's the message logged in `ActivityLog.xml`:
&gt; 
&gt; ```
&gt; System.NullReferenceException: Object reference not set to an instance of an object.
&gt;    at Microsoft.CodeAnalysis.CSharp.Extensions.DocumentationCommentExtensions.IsMultilineDocComment(DocumentationCommentTriviaSyntax documentationComment)
&gt;    at Microsoft.CodeAnalysis.Editor.CSharp.DocumentationComments.DocumentationCommentCommandHandler.IsMultilineDocComment(DocumentationCommentTriviaSyntax documentationComment)
&gt;    at Microsoft.CodeAnalysis.Editor.Implementation.DocumentationComments.AbstractDocumentationCommentCommandHandler`2.TryGenerateExteriorTriviaAfterEnter(SyntaxTree syntaxTree, SourceText text, Int32 position, Int32 originalPosition, ITextBuffer subjectBuffer, ITextView textView, DocumentOptionSet options, CancellationToken cancellationToken)
&gt;    at Microsoft.CodeAnalysis.Editor.Implementation.DocumentationComments.AbstractDocumentationCommentCommandHandler`2.InsertOnEnterTyped(SyntaxTree syntaxTree, SourceText text, Int32 position, Int32 originalPosition, ITextBuffer subjectBuffer, ITextView textView, DocumentOptionSet options, CancellationToken cancellationToken)
&gt;    at Microsoft.CodeAnalysis.Editor.Implementation.DocumentationComments.AbstractDocumentationCommentCommandHandler`2.CompleteComment(ITextBuffer subjectBuffer, ITextView textView, Int32 originalCaretPosition, Func`9 insertAction, CancellationToken cancellationToken)
&gt;    at Microsoft.CodeAnalysis.Editor.Implementation.DocumentationComments.AbstractDocumentationCommentCommandHandler`2.ExecuteCommand(ReturnKeyCommandArgs args, CommandExecutionContext context)
&gt;    at Microsoft.VisualStudio.Commanding.CommandHandlerExtensions.ExecuteCommand[T](ICommandHandler commandHandler, T args, Action nextCommandHandler, CommandExecutionContext executionContext)
&gt;    at Microsoft.VisualStudio.UI.Text.Commanding.Implementation.EditorCommandHandlerService.&lt;&gt;c__DisplayClass14_1`1.&lt;Execute&gt;b__1()
&gt;    at Microsoft.VisualStudio.Text.Utilities.GuardedOperations.CallExtensionPoint(Object errorSource, Action call)
&gt; --- End of stack trace from previous location where exception was thrown ---
&gt;    at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject)
&gt; ```
&gt; 
&gt; Repro steps:
&gt; 
&gt; 1. Open an existing C# console project in VS 2017 (15.6.4)
&gt; 2. On an empty line inside a method type "/////" (several forward-slashes)
&gt; 3. VS will display the extension crash warning dialog. The above stack-trace will be written to `ActivityLog.xml`.
</Description>
        <CreatedDate>27/03/2018</CreatedDate>
        <ClosedDate>12/07/2018</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>28090</PullRequestID>
        <IssueID>27223</IssueID>
        <Title>NRE from DocumentationCommentExtensions.IsMultilineDocComment</Title>
        <Description>[VS Feedback issue](https://developercommunity.visualstudio.com/content/problem/229613/nullreferenceexception-in-ismultilinedoccomment.html)

Repro:

Create a console app, place cursor in line 10 between `&lt;summary&gt;` and `&lt;/summary&gt;`, hit enter.

```C#
namespace ConsoleApp
{
    class Program
    {
        static void Main(string[] args)
        {
            const string code = @"
class Program
{
    /// &lt;summary&gt;&lt;/summary&gt;
    static void Main(string[] args)
    {
    }
}
";
        }
    }
}
```

Stack trace:

```
System.NullReferenceException: Object reference not set to an instance of an object.
 at Microsoft.CodeAnalysis.CSharp.Extensions.DocumentationCommentExtensions.IsMultilineDocComment(DocumentationCommentTriviaSyntax documentationComment)
 at Microsoft.CodeAnalysis.Editor.CSharp.DocumentationComments.DocumentationCommentCommandHandler.IsMultilineDocComment(DocumentationCommentTriviaSyntax documentationComment)
 at Microsoft.CodeAnalysis.Editor.Implementation.DocumentationComments.AbstractDocumentationCommentCommandHandler`2.TryGenerateExteriorTriviaAfterEnter(SyntaxTree syntaxTree, SourceText text, Int32 position, Int32 originalPosition, ITextBuffer subjectBuffer, ITextView textView, DocumentOptionSet options, CancellationToken cancellationToken)
 at Microsoft.CodeAnalysis.Editor.Implementation.DocumentationComments.AbstractDocumentationCommentCommandHandler`2.InsertOnEnterTyped(SyntaxTree syntaxTree, SourceText text, Int32 position, Int32 originalPosition, ITextBuffer subjectBuffer, ITextView textView, DocumentOptionSet options, CancellationToken cancellationToken)
 at Microsoft.CodeAnalysis.Editor.Implementation.DocumentationComments.AbstractDocumentationCommentCommandHandler`2.CompleteComment(ITextBuffer subjectBuffer, ITextView textView, Int32 originalCaretPosition, Func`9 insertAction, CancellationToken cancellationToken)
 at Microsoft.CodeAnalysis.Editor.Implementation.DocumentationComments.AbstractDocumentationCommentCommandHandler`2.ExecuteCommand(ReturnKeyCommandArgs args, CommandExecutionContext context)
 at Microsoft.VisualStudio.Commanding.CommandHandlerExtensions.ExecuteCommand[T](ICommandHandler commandHandler, T args, Action nextCommandHandler, CommandExecutionContext executionContext)
 at Microsoft.VisualStudio.UI.Text.Commanding.Implementation.EditorCommandHandlerService.&lt;&gt;c__DisplayClass14_1`1.&lt;Execute&gt;b__1()
 at Microsoft.VisualStudio.Text.Utilities.GuardedOperations.CallExtensionPoint(Object errorSource, Action call)
 --- End of stack trace from previous location where exception was thrown ---
 at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject) 
```</Description>
        <CreatedDate>29/05/2018</CreatedDate>
        <ClosedDate>12/07/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>28090</PullRequestID>
      <File>src/EditorFeatures/CSharpTest/DocumentationComments/DocumentationCommentTests.cs</File>
      <File>src/Workspaces/CSharp/Portable/Extensions/DocumentationCommentExtensions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>27561</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Fix memory leak in EditorConfigDocumentOptionsProvider</Title>
    <Description>This pull request implements the memory leak fix from #26386.

### Customer scenario

A memory leak occurs if a solution is closed while documents are open.

### Bugs this fixes

This is an interim solution for #26377.

### Workarounds, if any

Either of the following:

* Close all documents before closing a solution
* Restart the IDE when opening a different solution or reopening the same solution

### Risk

Low. The code only impacts cases where a project or solution is getting closed, and takes the same actions that occur if we received the expected events for closing documents.

### Performance impact

Minor performance improvement in the impacted scenario.

### Is this a regression from a previous update?

No.

### Root cause analysis

The leak is minor (a few small object graphs) so it didn't show up in profiling reports.

### How was the bug found?

Found by @heejaechang the investigation for #15003.

### Test documentation updated?

N/A
</Description>
    <CreatedDate>07/06/2018</CreatedDate>
    <ClosedDate>11/06/2018</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>27561</PullRequestID>
        <IssueID>26386</IssueID>
        <Title>3 changes around editorconfig</Title>
        <Description>1. put open file editorconfig change tracking back
2. handle open file leaking when solution close with files opened case
3. don't share locks between editorconfig events and roslyn events

this is mitigate for this issue - https://github.com/dotnet/roslyn/issues/26377 - but the root cause should be fixed instead of this one listening workspace events. otherwise, we are leaking context and mess up all editorconfig.

&lt;details&gt;&lt;summary&gt;Ask Mode template not completed&lt;/summary&gt;

&lt;!-- This template is not always required. If you aren't sure about whether it's needed or want help filling out the sections,
submit the pull request and then ask us for help. :) --&gt;

### Customer scenario

What does the customer do to get into this situation, and why do we think this
is common enough to address for this release.  (Granted, sometimes this will be
obvious "Open project, VS crashes" but in general, I need to understand how
common a scenario is)

### Bugs this fixes

(either VSO or GitHub links)

### Workarounds, if any

Also, why we think they are insufficient for RC vs. RC2, RC3, or RTW

### Risk

This is generally a measure our how central the affected code is to adjacent
scenarios and thus how likely your fix is to destabilize a broader area of code

### Performance impact

(with a brief justification for that assessment (e.g. "Low perf impact because no extra allocations/no complexity changes" vs. "Low")

### Is this a regression from a previous update?

### Root cause analysis

How did we miss it?  What tests are we adding to guard against it in the future?

### How was the bug found?

(E.g. customer reported it vs. ad hoc testing)

### Test documentation updated?

If this is a new non-compiler feature or a significant improvement to an existing feature, update https://github.com/dotnet/roslyn/wiki/Manual-Testing once you know which release it is targeting.

&lt;/details&gt;
</Description>
        <CreatedDate>25/04/2018</CreatedDate>
        <ClosedDate>11/06/2018</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>27561</PullRequestID>
        <IssueID>26377</IssueID>
        <Title>open document doesn't get DocumentClosed events when solution is closed while file is open in editor</Title>
        <Description>this is happening since PushingChangesToWorkspace  set to false, before OnBeforeLastDocumentUnlock for open files gets all remaining locks to become 0.

basically that causes workspace to not raise DocumentClosed event and anything that expects Open/Close pair gets into unknown state.

I went through ones that subscribe to Workspace.DocumentClosed events and most of them seems can get into broken state. (index is broken now, can't link references) but most of them also do this stop bleed thing that if solution is closed, clear all states about open file except one (EditorConfigDocumentOptionsProvider)

for EditorConfigDocumentOptionsProvider, it will leak all those open files and its state that solution got closed before open file is closed.

not sure what is right fix for it.
</Description>
        <CreatedDate>25/04/2018</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>27561</PullRequestID>
        <IssueID>15003</IssueID>
        <Title>Newly added .editorconfig only applied after reloading files</Title>
        <Description>Create a new C# console app.
Open `program.cs`
Right click -&gt; add new item -&gt; text file.
Rename the file to `.editorconfig` 
Paste the following into the file and save
```
[*.cs]
indent_style = tab
indent_size = 10
```
Switch to the `program.cs` tab and invoke `Edit.FormatDocument`.

Expected:
The document is formatted to use tabs and a wider indent.
Actual: Nothing happens
After closing and reopening program.cs, `Edit.FormatDocument` applies the new formattnig settings.</Description>
        <CreatedDate>04/11/2016</CreatedDate>
        <ClosedDate>11/06/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>27561</PullRequestID>
      <File>src/EditorFeatures/Core.Wpf/Options/EditorConfigDocumentOptionsProvider.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23930</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Fix two bugs in async lifting analysis which results in unnecessarily lifted locals.</Title>
    <Description>The first issue is that we did not properly track the unreachable state in lifting analysis. I believe we did so to work around a bug that has since been fixed.
The second issue is that an assignment in a conditional branch condition was not treated as conditional.

Since VB does not have an assignment expression, I do not have a repro for user locals, but the fix results in some temps no longer being unnecessarily lifted (as shown by changes in existing tests)

### Customer scenario

Async methods have more IL for their bodies, and more locals lifted, than necessary.

### Bugs this fixes

Fixes #13759

### Workarounds, if any

None known.

### Risk

The fix is simple. On the other hand, flow analysis is subtle and the reasons that we tracked unreachable state the way we did is lost in prehistory.

### Performance impact

Changes are simple and local, so no performance impact expected.

### Is this a regression from a previous update?

No.

### Root cause analysis

We do not have extensive testing for which locals are lifted in async code under what circumstances. Too much lifting is generally only a performance (not correctness) problem, so we did not prioritize it.

### How was the bug found?

Customer reported.

### Test documentation updated?

It would be good to add supporting test infrastructure and tests for which locals are lifted for various uses of language constructs. Once that is in place, we could add it as an item to check off for testing new features. This suggestion is recorded in #23929.
</Description>
    <CreatedDate>26/12/2017</CreatedDate>
    <ClosedDate>09/01/2018</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>23930</PullRequestID>
        <IssueID>13759</IssueID>
        <Title>Unnecessarily lifted field in async state machine</Title>
        <Description>**Version Used**: 
2.0.0.60620

**Steps to Reproduce**:
Compile this code:

``` C#
using System.IO;
using System.Threading.Tasks;

class Program
{
    public static void Main() { }

    public static async Task Repro1(Stream source, Stream destination)
    {
        byte[] buffer = new byte[0x1000];
        int bytesRead;
        while ((bytesRead = await source.ReadAsync(buffer, 0, buffer.Length)) != 0)
        {
            await destination.WriteAsync(buffer, 0, bytesRead);
        }
    }

    public static async Task Repro2(Stream source, Stream destination)
    {
        byte[] buffer = new byte[0x1000];
        while (true)
        {
            int bytesRead = await source.ReadAsync(buffer, 0, buffer.Length);
            if (bytesRead == 0) break;
            await destination.WriteAsync(buffer, 0, bytesRead);
        }
    }
}
```

**Expected Behavior**:
The async state machine does not have a field for `bytesRead`.

**Actual Behavior**:
In Repro2, as expected, the async state machine does not lift `bytesRead` to the state machine.  But in Repro1, it does lift `bytesRead` to the state machine, even though the value of `bytesRead` doesn't need to be preserved across an await.
</Description>
        <CreatedDate>13/09/2016</CreatedDate>
        <ClosedDate>09/01/2018</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>23930</PullRequestID>
        <IssueID>23929</IssueID>
        <Title>Add tests for lifted variables in async/iterator code</Title>
        <Description>We do not have many tests that verify the set of variables lifted in async or iterator code. It would be good to add a bit of testing infrastructure to make that easy, and add tests. Also, this could be added to the checklist for new features.</Description>
        <CreatedDate>26/12/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>23930</PullRequestID>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/PreciseAbstractFlowPass.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/StateMachineRewriter/IteratorAndAsyncCaptureWalker.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenAsyncTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23794</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Do not allow source suppression for VS/host diagnostics</Title>
    <Description>This fixes the UI delay from force binding all assembly attributes during solution load.
Fixes #23775

&lt;details&gt;&lt;summary&gt;Ask Mode template&lt;/summary&gt;

### Customer scenario

Customer loads a solution that has more than one analyzer with conflicting dependency contents. This leads to analyzer conflict diagnostics getting reported during solution load. Reporting these diagnostic force completes binding of all assembly attributes in the compilation on the UI thread, causing a very large UI delay.

### Bugs this fixes

#23775

### Workarounds, if any

N/A

### Risk

Low. We are not executing a bunch of code that force completes the attributes to check for source suppressions. Users are recommended to suppress analyzer conflict diagnostics through compilation options.

### Performance impact

This should improve solution load performance in presence of analyzer dependency conflict diagnostics.

### Is this a regression from a previous update?

No.

### Root cause analysis

This was a known issue for a while, but we thought it was pretty rare, and something that would go away with us moving to new project system doing this work on a background thread.

### How was the bug found?

Dogfooding.

### Test documentation updated?

N/A

&lt;/details&gt;
</Description>
    <CreatedDate>14/12/2017</CreatedDate>
    <ClosedDate>15/12/2017</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>23794</PullRequestID>
        <IssueID>23775</IssueID>
        <Title>AnalyzerDependencyCheckingService.CheckForConflictsAsync results in 15 seconds of blocked UI opening Roslyn</Title>
        <Description>**Version Used**: 
Visual Studio 2017 version 15.5

**Steps to Reproduce**:
1. Open a large solution where there are analyzer diagnostics in a "leaf" project.

**Expected Behavior**:
Solution should open in a reasonable time

**Actual Behavior**:
It's very slow, because creating the diagnostic requires a full compilation to be built and then examined for source level suppressions, and this happens synchronously on the UI thread as part of solution load.


`microsoft.visualstudio.languageservices   &lt;&lt;microsoft.visualstudio.languageservices!Microsoft.VisualStudio.LanguageServices.Implementation.AnalyzerDependencyCheckingService+&lt;CheckForConflictsAsync&gt;d__14.MoveNext()&gt;&gt; | 11.2 | 9,363.414 | 4,087`



</Description>
        <CreatedDate>14/12/2017</CreatedDate>
        <ClosedDate>15/12/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>23794</PullRequestID>
        <IssueID>23775</IssueID>
        <Title>AnalyzerDependencyCheckingService.CheckForConflictsAsync results in 15 seconds of blocked UI opening Roslyn</Title>
        <Description>**Version Used**: 
Visual Studio 2017 version 15.5

**Steps to Reproduce**:
1. Open a large solution where there are analyzer diagnostics in a "leaf" project.

**Expected Behavior**:
Solution should open in a reasonable time

**Actual Behavior**:
It's very slow, because creating the diagnostic requires a full compilation to be built and then examined for source level suppressions, and this happens synchronously on the UI thread as part of solution load.


`microsoft.visualstudio.languageservices   &lt;&lt;microsoft.visualstudio.languageservices!Microsoft.VisualStudio.LanguageServices.Implementation.AnalyzerDependencyCheckingService+&lt;CheckForConflictsAsync&gt;d__14.MoveNext()&gt;&gt; | 11.2 | 9,363.414 | 4,087`



</Description>
        <CreatedDate>14/12/2017</CreatedDate>
        <ClosedDate>15/12/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>23794</PullRequestID>
      <File>src/Compilers/Core/Portable/Diagnostic/Diagnostic.cs</File>
      <File>src/Workspaces/Core/Portable/Diagnostics/DiagnosticData.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23458</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Perform a lightweight syntax check before getting document options</Title>
    <Description>### Customer scenario

A user has the Validate String Format analyzer enabled, and it uses more CPU than it needs to.

### Bugs this fixes

N/A

### Workarounds, if any

None needed.

### Risk

Low. The analysis conditions are not changed, but are simply reordered so a check that generally fails quickly executes before one that takes longer to complete.

### Performance impact

Improves performance. Times are in milliseconds running the analyzers on OrchardCMS/Orchard@941c6912ae2eaba60896758cc60f1dc54c142be4, and the compiler at 2b39919ba6eebb6b22524db11a537fe247ee8a79+#23087+#23457.

|  | Options first | Syntax first (this PR) |
| --- | --- | --- |
| **Non-concurrent** | 1262 | 1000 |
| **Concurrent** (#23423) | 1262 | 775 |

### Is this a regression from a previous update?

No.

### Root cause analysis

AnalyzerRunner was not available previously.

### How was the bug found?

AnalyzerRunner.

### Test documentation updated?

No.</Description>
    <CreatedDate>29/11/2017</CreatedDate>
    <ClosedDate>07/12/2017</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>23458</PullRequestID>
        <IssueID>23087</IssueID>
        <Title>Analyzer Runner tool</Title>
        <Description>This is a draft version of the analyzer runner tool which should be used for execution analyzers against a given solution and measuring their performance.

The code is based on [StyleCopAnalyzers](https://github.com/DotNetAnalyzers/StyleCopAnalyzers/)

Closes #23104</Description>
        <CreatedDate>09/11/2017</CreatedDate>
        <ClosedDate>19/05/2018</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>23458</PullRequestID>
        <IssueID>23457</IssueID>
        <Title>Avoid skewing analysis time when logging analyzer times</Title>
        <Description>### Customer scenario

A user attempts to run analyzers through the Roslyn API for performance testing. The measured performance overhead is significantly greater than the observed overhead for the analyzer in other cases.

### Bugs this fixes

N/A

### Workarounds, if any

None

### Risk

Low. The code was only intended to add stability to analyzer performance testing. After running the code through AnalyzerRunner, measurements indicated that the approach caused substantial performance overhead which obscured the true performance of the analyzers. The issue was most apparent during document edit testing (#23104).

### Performance impact

For applications like Visual Studio, no change in performance. For some applications using the Roslyn API, e.g. AnalyzerRunner, performance is either unchanged or improved.

### Is this a regression from a previous update?

No.

### Root cause analysis

Analyzer performance was only tested in limited scenarios previously.

### How was the bug found?

AnalyzerRunner

### Test documentation updated?

No.</Description>
        <CreatedDate>29/11/2017</CreatedDate>
        <ClosedDate>06/01/2018</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>23458</PullRequestID>
        <IssueID>23423</IssueID>
        <Title>Enable concurrent execution for all built-in C# analyzers</Title>
        <Description>Eliminates a large amount of unnecessary performance overhead due to serializing analyzers when running in the OOP host.

### Customer scenario

A user attempts to use a Fix All operation, and the initial analysis phase to find all diagnostics to fix is very slow. Alternately, a user turns on Full Solution Analysis, and the time taken to run the analyzers is very slow.

### Bugs this fixes

N/A

### Workarounds, if any

* Wait longer
* Leave Full Solution Analysis disabled

### Risk

Low:

1. All of our analyzers were designed to be stateless so concurrent analysis *could* be enabled.
2. The primary performance concern - overwhelming devenv.exe with analysis operations - is not likely to result in problems because the in-process analyzer driver never uses multiple threads.

### Performance impact

Improves performance by reducing monitor contention. The difference is most apparent on analyzers that are register callbacks for a large number of syntax nodes, but have an early return fast path that applies to the majority of cases. The performance improvement was measured at up to 30% for some lightweight analyzers.

Note that for some analysis situations, performance is not improved by this change in isolation. This tends to impact cases where large numbers of analyzers are used in a manner that causes substantial GC overhead. Profiling indicates that these are "downstream" issues and I would not consider them a contraindication for this change.

### Is this a regression from a previous update?

No.

### Root cause analysis

* No performance testing of analyzers at scale.
* No unit tests to ensure analyzers are registered as concurrent.

### How was the bug found?

Found with AnalyzerRunner, verified with profiling.

### Test documentation updated?

N/A
</Description>
        <CreatedDate>28/11/2017</CreatedDate>
        <ClosedDate>29/11/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>23458</PullRequestID>
      <File>src/Compilers/Core/Portable/InternalUtilities/PerformanceSensitiveAttribute.cs</File>
      <File>src/Features/Core/Portable/ValidateFormatString/AbstractValidateFormatStringDiagnosticAnalyzer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23448</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Simplify diagnostic tagging by making it use the standard tagging model.</Title>
    <Description>### Customer scenario

User is working on a big solution and switching between git branches multiple times or close and reopen solutions multiple times. and on some unfortunate cases, VS will crash with out of memory exception. 

### Bugs this fixes

Fixes #24055
Fixes [DevDiv 512757](https://devdiv.visualstudio.com/DevDiv/_workitems/edit/512757)

Supersedes #22920, #23377, #23409, #23411

### Workarounds, if any

after each git branch switching or solution open/close, give VS sometimes to process pending works enqueued by the operation.

### Risk

this simplify our diagnostic tagger dramatically. so there is a risk where behavior might not exactly same as before. but we believe this is right direction to go. 

### Performance impact

this should remove OOM due to too many pending UI work items completely. that is source of most of our OOM crash.

### Is this a regression from a previous update?

No

### Root cause analysis

previously, diagnostic service didn't support pull model for all diagnostics source. so, tagger used event (push model) to hold onto last reported diagnostics and later use that to report tags. and that made us to use custom logic for the tagger which ends up forcing us to use UI thread to synchronize many states to remove potential race. and that caused us to push too many work items to UI thread in certain case such as git branch switching.

now, diagnostic service fully supporting pull model for all sources, this moves diagnostic taggers to follow our tagger framework which doesn't require UI thread for state synchronization. removing the root cause of OOM from the picture completely.

### How was the bug found?

MemoryWatson

....

more dev detail.

From a conversation with @heejaechang https://github.com/dotnet/roslyn/pull/23409#issuecomment-347675771 

A while back the diagnostics subsystem had a limitation where you could only hear about some diagnostics if you explicitly listened for diagnostic events.  i.e. if you weren't listenting and capturing those events, you couldn't go back and ask for those diagnostics later.  This meant that we couldn't do diagnostic tagging (squiggles/fading/suggestions) like we did normal tagging. Normal tagging hears about events, pauses a bit, then goes and gets all the data necessary later to produce the tags.  Because that data wasn't available 'later', diagnostic tagging had to aggregate the info and contort things to fit into the tagging infrastructure.

This restriction from the diagnostics service no longer exists. THat means we can great simplify how we do our tagging computation.  </Description>
    <CreatedDate>28/11/2017</CreatedDate>
    <ClosedDate>16/01/2018</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>23448</PullRequestID>
        <IssueID>24055</IssueID>
        <Title>Microsoft CodeAnalysis OOM Exception </Title>
        <Description>Ported from https://github.com/dotnet/roslyn-analyzers/issues/1503

-----------------------------
@chillryan

I've reported this issue through the visual studio feedback tool [see link](https://developercommunity.visualstudio.com/content/problem/174842/visual-studio-155-crashes-when-switching-git-branc.html) but figured I'd try my chances posting here.

I'm using the Code Analysis 2017 extension for VS 2017 15.5. In looking at the stack trace, I can only assume that since the extension is running inside the devenv process, when its analysis a loaded solution, it hits the OOM. 

Since I've hit this situation a very frequent basis, I've disabled solution analysis for C# projects hoping that will help. I'll report back here if there are any changes or comment on the visual studio feedback link posted prior.
  </Description>
        <CreatedDate>04/01/2018</CreatedDate>
        <ClosedDate>16/01/2018</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>23448</PullRequestID>
        <IssueID>22920</IssueID>
        <Title>reduce diagnostic tagger's usages of UI thread for synchronization</Title>
        <Description>**Customer scenario**

Customer is working on a VS. doing code fix and watching previews, applying fix all and etc, and suddenly VS crash due to OOM.

**Bugs this fixes:**

https://devdiv.visualstudio.com/DevDiv/_workitems/edit/512757

**Workarounds, if any**

there is no easy workaround.

**Risk**

I don't see risk of crash, but since it is highly visible area (tagger), we probably want more dogfooding time for this.

**Performance impact**

it should move more work to background thread, and reduce need for UI thread. in turn, improving responsiveness and memory.

**Is this a regression from a previous update?**

Yes.

**Root cause analysis:**

this one is hard to pin point to 1 issue. but caused by several different fixes. 

first, we made all state management to happen on UI thread to remove any potential race. and that caused us to use more FG than before.

second, we merged preview only tagger with regular diagnostic tagger, making preview tagger to be as expansive as normal diagnostic tagger meaning it uses same amount of UI threads since it now has same states tracking as normal ones.

third, along with that, some filtering on BG got removed which was there to reduce work on FG since all those are changed to be done on FG. 

forth, diagnostic tagger didn't pass cancellation token all the way through, leaving already cancelled works in the UI work queue.

fifth, foreground work queue cleaned up cancelled works too lazily and let cancelled work to pile up.

..

this reduces demand for UI thread, but due to the fact that UI thread can be blocked (due to exclusive operation running such as Fix All, or model dialog box or Wait dialog box and more), we can't completely get rid of pending requests for UI threads. but with this change, we should have way less chance to hit 2.1 million pending UI requests.

**How was the bug found?**

MemoryWatson
</Description>
        <CreatedDate>31/10/2017</CreatedDate>
        <ClosedDate>29/11/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>23448</PullRequestID>
        <IssueID>23377</IssueID>
        <Title>Batch up and flatten diagnostic updates.</Title>
        <Description>In response to https://github.com/dotnet/roslyn/pull/22920#issuecomment-346950158

This is a tweak to the diagnostic taggers to improve how they respond to a flood of notifications from the underlying diagnostic services.  There are a few improvements as part of this PR.  

1. We batch up diagnostic notifications over a 50ms window and process them all at once, instead of enqueing and processing each notification on the UI thread individually.
2. Because we're batching, we can do a lot of preprocessing of the notifications to throw out information that has been superceded.  For example, if we get a notification that we're actually removing all the diagnostics for a provider, we can just ignore all previous diagnostic-creates that we haven't processed yet.  Also, any more diagnostic creations we hear about will supercede previous diagnostic creations for that provider.  
</Description>
        <CreatedDate>26/11/2017</CreatedDate>
        <ClosedDate>16/01/2018</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>23448</PullRequestID>
        <IssueID>23409</IssueID>
        <Title>Batch up and flatten diagnostic updates, second approach.</Title>
        <Description>This is a followup to https://github.com/dotnet/roslyn/pull/23377.  The primary difference between this PR and that one is that we also do filtering of diagnostic events on teh BG (acknowledging that this is racey, but just as racey as before).</Description>
        <CreatedDate>28/11/2017</CreatedDate>
        <ClosedDate>16/01/2018</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>23448</PullRequestID>
        <IssueID>23411</IssueID>
        <Title>Batch up and flatten diagnostic updates, third approach.</Title>
        <Description>Followup to https://github.com/dotnet/roslyn/pull/23409.

But with a simpler batching model where we only have to store the latest args for any id+doc pair.  </Description>
        <CreatedDate>28/11/2017</CreatedDate>
        <ClosedDate>16/01/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>23448</PullRequestID>
      <File>src/EditorFeatures/Core/Implementation/Diagnostics/AbstractDiagnosticsAdornmentTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Diagnostics/AbstractDiagnosticsTaggerProvider.AggregatingTagger.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Diagnostics/AbstractDiagnosticsTaggerProvider.TaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Diagnostics/AbstractDiagnosticsTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Diagnostics/DiagnosticsClassificationTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Diagnostics/DiagnosticsSquiggleTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Diagnostics/DiagnosticsSuggestionTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Tagging/TaggerContext.cs</File>
      <File>src/Workspaces/Core/Portable/Diagnostics/DiagnosticData.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23438</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Several small bug fixes related to readonly references.</Title>
    <Description>Fixes some bugs related to readonly references.

Fixes:#23422
Null-conditional operators should not be allowed with members that return restricted or ref-like types.
Similarly to unconstrained generics or pointers - these types cannot be used to form nullables.
Allowing such types result in crashes at run time or even at compile time, depending on scenario.

Fixes:#23338
Consider special members of `Nullable&lt;T&gt;` nonmutating. 
Example: Not doing defensive copies when invoking `GetValueOrDefault` on readonly variables.
Related to: https://github.com/dotnet/corefx/issues/24900

Fixes:#23166
Removes unused parameters in CheckFieldRefEscape and CheckEventRefEscape


### Customer scenario

- Customer uses null conditional operator `obj?.Member()` where `Member()` returns stack-only type such as `Span&lt;T&gt;` or `TypedReference`. The code should result in compiler error since it would lead to `Nullable&lt;Span&lt;T&gt;&gt;` or `Nullable&lt;TypedReference&gt;` and that is disallowed by JIT/CLR. 
Instead C# compiler crashes and VB compiler successfully compiles IL that fails to JIT.

- Customer uses code that performs some lifted operations with  `readonly` variable (like a field) that has `Nullable` type. 
In such scenario compiler frequently emits calls to special methods on `Nullable` such as `GetValueOrDefault`. The codegen of such calls is suboptimial. The calls are performed on copies, because compiler conservatively treat these helpers as potentially mutating the value.
We know for sure that these members are not mutating. That is required for their correctness and for soundness of `Nullable` operations. We do not need defensive copies.

- there are couple of redundant parameters found by an  "unused parameters" analyzer. 

### Bugs this fixes

Fixes:#23422
Fixes:#23338
Fixes:#23166

### Workarounds, if any

User must be careful to not use `?.` with stack-only types. 
No workaround for extra nullable copy.

### Risk

Very low. We are just adding some simple conditions to already existing functionality.

### Performance impact

Very low for the same reason.

### Is this a regression from a previous update?

No.

### Root cause analysis

The "?." crashing bug is actually fairly old. Now easier to expose with ref-like types such as `Span`

### How was the bug found?

Reported by external customers.

### Test documentation updated?

N/A</Description>
    <CreatedDate>28/11/2017</CreatedDate>
    <ClosedDate>05/12/2017</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>23438</PullRequestID>
        <IssueID>23422</IssueID>
        <Title>Unexpected value 'NullCoalescingOperator expression of System.Span&lt;byte&gt; type' of type 'System.String'</Title>
        <Description>**Version Used**: 
![image](https://user-images.githubusercontent.com/95136/33313758-71ffab54-d3e0-11e7-916d-b428514f369a.png)

**Steps to Reproduce**:

```C#
public class Foo
{
   public Span&lt;byte&gt; Span =&gt; Span&lt;byte&gt;.Empty;
}

public void Method()
{
   Foo foo = null;
   var span = foo?.Span ?? Span&lt;byte&gt;.Empty;
}

```

**Expected Behavior**:
No Crash

**Actual Behavior**:
Crash

```
Log Name:      Application
Source:        .NET Runtime
Date:          11/28/2017 2:01:22 AM
Event ID:      1025
Task Category: None
Level:         Error
Keywords:      Classic
User:          N/A
Description:
Application: devenv.exe
Framework Version: v4.0.30319
Description: The application requested process termination through System.Environment.FailFast(string message).
Message: System.InvalidOperationException: Unexpected value 'NullCoalescingOperator expression of System.Span&lt;byte&gt; type' of type 'System.String'
   at Microsoft.CodeAnalysis.CSharp.Binder.GetValEscape(BoundExpression expr, UInt32 scopeOfTheContainingExpression)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindVariableDeclaration(SourceLocalSymbol localSymbol, LocalDeclarationKind kind, Boolean isVar, VariableDeclaratorSyntax declarator, TypeSyntax typeSyntax, TypeSymbol declTypeOpt, AliasSymbol aliasOpt, DiagnosticBag diagnostics, CSharpSyntaxNode associatedSyntaxNode)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindDeclarationStatementParts(LocalDeclarationStatementSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.IncrementalBinder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLowerBoundNode(CSharpSyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node, CSharpSyntaxNode&amp; bindableNode, BoundNode&amp; lowestBoundNode, BoundNode&amp; highestBoundNode, BoundNode&amp; boundParent)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetSymbolInfoWorker(CSharpSyntaxNode node, SymbolInfoOptions options, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(ExpressionSyntax expression, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.ClassifyTypeSyntax(NameSyntax name, SemanticModel semanticModel, ArrayBuilder`1 result, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.AddClassifications(SyntaxNode syntax, SemanticModel semanticModel, ArrayBuilder`1 result, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.Worker.ClassifyNode(SyntaxNode syntax)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.Worker.ProcessNodes()
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.Worker.Classify(Workspace workspace, SemanticModel semanticModel, TextSpan textSpan, ArrayBuilder`1 list, Func`2 getNodeClassifiers, Func`2 getTokenClassifiers, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.&lt;AddSemanticClassificationsAsync&gt;d__5.MoveNext()
Stack:
   at System.Environment.FailFast(System.String, System.Exception)
   at Microsoft.CodeAnalysis.FailFast.OnFatalException(System.Exception)
   at Microsoft.CodeAnalysis.ErrorReporting.FatalError.Report(System.Exception, System.Action`1&lt;System.Exception&gt;)
   at Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportUnlessCanceled(System.Exception)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__5.MoveNext()
   at Microsoft.CodeAnalysis.CSharp.Binder.GetValEscape(Microsoft.CodeAnalysis.CSharp.BoundExpression, UInt32)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindVariableDeclaration(Microsoft.CodeAnalysis.CSharp.Symbols.SourceLocalSymbol, Microsoft.CodeAnalysis.CSharp.Symbols.LocalDeclarationKind, Boolean, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax, Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, Microsoft.CodeAnalysis.CSharp.Symbols.AliasSymbol, Microsoft.CodeAnalysis.DiagnosticBag, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindDeclarationStatementParts(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel+IncrementalBinder.BindStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Bind(Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.Bind(Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLowerBoundNode(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetSymbolInfoWorker(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, SymbolInfoOptions, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.ClassifyTypeSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax, Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.AddClassifications(Microsoft.CodeAnalysis.SyntaxNode, Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+Worker.ClassifyNode(Microsoft.CodeAnalysis.SyntaxNode)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+Worker.ProcessNodes()
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+Worker.Classify(Microsoft.CodeAnalysis.Workspace, Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.Text.TextSpan, Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__5.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__5, Microsoft.CodeAnalysis.Workspaces, Version=2.6.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;AddSemanticClassificationsAsync&gt;d__5 ByRef)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Document, Microsoft.CodeAnalysis.Text.TextSpan, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__2.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Classification.AbstractClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__2, Microsoft.CodeAnalysis.Workspaces, Version=2.6.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;AddSemanticClassificationsAsync&gt;d__2 ByRef)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Document, Microsoft.CodeAnalysis.Text.TextSpan, System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.WorkspaceClassificationDelegationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Classification.IClassificationService, Microsoft.CodeAnalysis.Document, Microsoft.CodeAnalysis.Text.TextSpan, System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ClassifySpansAsync&gt;d__2`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ClassifySpansAsync&gt;d__2`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Microsoft.CodeAnalysis.EditorFeatures, Version=2.6.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;ClassifySpansAsync&gt;d__2`1&lt;System.__Canon&gt; ByRef)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.ClassifySpansAsync[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IClassificationDelegationService`1&lt;System.__Canon&gt;, System.__Canon, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;TryClassifyContainingMemberSpan&gt;d__1`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].Start[[Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;TryClassifyContainingMemberSpan&gt;d__1`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Microsoft.CodeAnalysis.EditorFeatures, Version=2.6.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;TryClassifyContainingMemberSpan&gt;d__1`1&lt;System.__Canon&gt; ByRef)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.TryClassifyContainingMemberSpan[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IClassificationDelegationService`1&lt;System.__Canon&gt;, System.__Canon, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ProduceTagsAsync&gt;d__0`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ProduceTagsAsync&gt;d__0`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Microsoft.CodeAnalysis.EditorFeatures, Version=2.6.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;ProduceTagsAsync&gt;d__0`1&lt;System.__Canon&gt; ByRef)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.ProduceTagsAsync[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IClassificationDelegationService`1&lt;System.__Canon&gt;, System.__Canon, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationViewTaggerProvider.ProduceTagsAsync[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IClassificationDelegationService`1&lt;System.__Canon&gt;)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationViewTaggerProvider.ProduceTagsAsync(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;)
   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].ProduceTagsAsync(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;System.__Canon&gt;)
   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource+&lt;RecomputeTagsAsync&gt;d__73[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource+&lt;RecomputeTagsAsync&gt;d__73[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Microsoft.CodeAnalysis.EditorFeatures, Version=2.6.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;RecomputeTagsAsync&gt;d__73&lt;System.__Canon&gt; ByRef)
   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].RecomputeTagsAsync(System.Object, System.Nullable`1&lt;Microsoft.VisualStudio.Text.SnapshotPoint&gt;, System.Nullable`1&lt;Microsoft.CodeAnalysis.Text.TextChangeRange&gt;, System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan&gt;, System.Collections.Immutable.ImmutableDictionary`2&lt;Microsoft.VisualStudio.Text.ITextBuffer,Microsoft.CodeAnalysis.Editor.Shared.Tagging.TagSpanIntervalTree`1&lt;System.__Canon&gt;&gt;, Boolean, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource+&lt;&gt;c__DisplayClass63_0[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].&lt;RecomputeTagsForeground&gt;b__0(System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.Shared.Threading.AsynchronousSerialWorkQueue+&lt;&gt;c__DisplayClass11_0.&lt;EnqueueBackgroundTask&gt;b__0(System.Threading.Tasks.Task)
   at System.Threading.Tasks.ContinuationResultTaskFromTask`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].InnerInvoke()
   at System.Threading.Tasks.Task.Execute()
   at System.Threading.Tasks.Task.ExecutionContextCallback(System.Object)
   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)
   at System.Threading.Tasks.Task.ExecuteEntry(Boolean)
   at System.Threading.Tasks.Task.System.Threading.IThreadPoolWorkItem.ExecuteWorkItem()
   at System.Threading.ThreadPoolWorkQueue.Dispatch()
   at System.Threading._ThreadPoolWaitCallback.PerformWaitCallback()
```

/cc @VSadov </Description>
        <CreatedDate>28/11/2017</CreatedDate>
        <ClosedDate>05/12/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>23438</PullRequestID>
        <IssueID>23338</IssueID>
        <Title>Unnecessary defensive copy of an `in` parameter is created, whose type is nullable readonly struct</Title>
        <Description>**Version Used**: 

Version 15.5.0 Preview 4.0
VisualStudio.15.Preview/15.5.0-pre.4.0+27110.0

Visual C# 2017 00369-60000-00001-AA127
Microsoft Visual C# 2017

C# 7.2

**Steps to Reproduce**:

Compile and inspect IL:
```
using System;

readonly struct S
{
    readonly decimal d;

    public S(decimal d)
    {
        this.d = d;
    }
}

class P
{
    static void Foo(in S? x)
    {
        Console.WriteLine(x.GetValueOrDefault());
    }
    
    static void Main()
    {
        S? y = new S(5m);
        Foo(y);
    }
}
```
**Actual Behavior**:
The `in` parameter `x` in the method  `Foo` is copied to a compiler-generated local before `GetValueOrDefault()` is invoked.

**Expected Behavior**:
This copy is unnecessary and should be elided. No method or property of a nullable value type can mutate it if the underlying type is a readonly struct.</Description>
        <CreatedDate>21/11/2017</CreatedDate>
        <ClosedDate>05/12/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>23438</PullRequestID>
        <IssueID>23166</IssueID>
        <Title>Unused parameter in Microsoft.CodeAnalysis.CSharp.Binder.CheckFieldRefEscape (potential bug?)</Title>
        <Description>Enabling CA1801 (unused parameter rule) fires it for [CheckFieldRefEscape](http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Binder/Binder.ValueChecks.cs,a204c04b97fd2e6c) and [CheckFieldLikeEventRefEscape](http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Binder/Binder.ValueChecks.cs,09e0b3ce0e53064a) for parameter `checkingReceiver` being unused. We should either use this parameter or remove it from the signature.</Description>
        <CreatedDate>14/11/2017</CreatedDate>
        <ClosedDate>05/12/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>23438</PullRequestID>
        <IssueID>23422</IssueID>
        <Title>Unexpected value 'NullCoalescingOperator expression of System.Span&lt;byte&gt; type' of type 'System.String'</Title>
        <Description>**Version Used**: 
![image](https://user-images.githubusercontent.com/95136/33313758-71ffab54-d3e0-11e7-916d-b428514f369a.png)

**Steps to Reproduce**:

```C#
public class Foo
{
   public Span&lt;byte&gt; Span =&gt; Span&lt;byte&gt;.Empty;
}

public void Method()
{
   Foo foo = null;
   var span = foo?.Span ?? Span&lt;byte&gt;.Empty;
}

```

**Expected Behavior**:
No Crash

**Actual Behavior**:
Crash

```
Log Name:      Application
Source:        .NET Runtime
Date:          11/28/2017 2:01:22 AM
Event ID:      1025
Task Category: None
Level:         Error
Keywords:      Classic
User:          N/A
Description:
Application: devenv.exe
Framework Version: v4.0.30319
Description: The application requested process termination through System.Environment.FailFast(string message).
Message: System.InvalidOperationException: Unexpected value 'NullCoalescingOperator expression of System.Span&lt;byte&gt; type' of type 'System.String'
   at Microsoft.CodeAnalysis.CSharp.Binder.GetValEscape(BoundExpression expr, UInt32 scopeOfTheContainingExpression)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindVariableDeclaration(SourceLocalSymbol localSymbol, LocalDeclarationKind kind, Boolean isVar, VariableDeclaratorSyntax declarator, TypeSyntax typeSyntax, TypeSymbol declTypeOpt, AliasSymbol aliasOpt, DiagnosticBag diagnostics, CSharpSyntaxNode associatedSyntaxNode)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindDeclarationStatementParts(LocalDeclarationStatementSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.IncrementalBinder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLowerBoundNode(CSharpSyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node, CSharpSyntaxNode&amp; bindableNode, BoundNode&amp; lowestBoundNode, BoundNode&amp; highestBoundNode, BoundNode&amp; boundParent)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetSymbolInfoWorker(CSharpSyntaxNode node, SymbolInfoOptions options, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(ExpressionSyntax expression, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.ClassifyTypeSyntax(NameSyntax name, SemanticModel semanticModel, ArrayBuilder`1 result, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.AddClassifications(SyntaxNode syntax, SemanticModel semanticModel, ArrayBuilder`1 result, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.Worker.ClassifyNode(SyntaxNode syntax)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.Worker.ProcessNodes()
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.Worker.Classify(Workspace workspace, SemanticModel semanticModel, TextSpan textSpan, ArrayBuilder`1 list, Func`2 getNodeClassifiers, Func`2 getTokenClassifiers, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.&lt;AddSemanticClassificationsAsync&gt;d__5.MoveNext()
Stack:
   at System.Environment.FailFast(System.String, System.Exception)
   at Microsoft.CodeAnalysis.FailFast.OnFatalException(System.Exception)
   at Microsoft.CodeAnalysis.ErrorReporting.FatalError.Report(System.Exception, System.Action`1&lt;System.Exception&gt;)
   at Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportUnlessCanceled(System.Exception)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__5.MoveNext()
   at Microsoft.CodeAnalysis.CSharp.Binder.GetValEscape(Microsoft.CodeAnalysis.CSharp.BoundExpression, UInt32)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindVariableDeclaration(Microsoft.CodeAnalysis.CSharp.Symbols.SourceLocalSymbol, Microsoft.CodeAnalysis.CSharp.Symbols.LocalDeclarationKind, Boolean, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax, Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, Microsoft.CodeAnalysis.CSharp.Symbols.AliasSymbol, Microsoft.CodeAnalysis.DiagnosticBag, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindDeclarationStatementParts(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel+IncrementalBinder.BindStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Bind(Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.Bind(Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLowerBoundNode(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetSymbolInfoWorker(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, SymbolInfoOptions, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.ClassifyTypeSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax, Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.AddClassifications(Microsoft.CodeAnalysis.SyntaxNode, Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+Worker.ClassifyNode(Microsoft.CodeAnalysis.SyntaxNode)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+Worker.ProcessNodes()
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+Worker.Classify(Microsoft.CodeAnalysis.Workspace, Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.Text.TextSpan, Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__5.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__5, Microsoft.CodeAnalysis.Workspaces, Version=2.6.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;AddSemanticClassificationsAsync&gt;d__5 ByRef)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Document, Microsoft.CodeAnalysis.Text.TextSpan, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__2.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Classification.AbstractClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__2, Microsoft.CodeAnalysis.Workspaces, Version=2.6.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;AddSemanticClassificationsAsync&gt;d__2 ByRef)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Document, Microsoft.CodeAnalysis.Text.TextSpan, System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.WorkspaceClassificationDelegationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Classification.IClassificationService, Microsoft.CodeAnalysis.Document, Microsoft.CodeAnalysis.Text.TextSpan, System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ClassifySpansAsync&gt;d__2`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ClassifySpansAsync&gt;d__2`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Microsoft.CodeAnalysis.EditorFeatures, Version=2.6.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;ClassifySpansAsync&gt;d__2`1&lt;System.__Canon&gt; ByRef)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.ClassifySpansAsync[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IClassificationDelegationService`1&lt;System.__Canon&gt;, System.__Canon, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;TryClassifyContainingMemberSpan&gt;d__1`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].Start[[Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;TryClassifyContainingMemberSpan&gt;d__1`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Microsoft.CodeAnalysis.EditorFeatures, Version=2.6.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;TryClassifyContainingMemberSpan&gt;d__1`1&lt;System.__Canon&gt; ByRef)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.TryClassifyContainingMemberSpan[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IClassificationDelegationService`1&lt;System.__Canon&gt;, System.__Canon, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ProduceTagsAsync&gt;d__0`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ProduceTagsAsync&gt;d__0`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Microsoft.CodeAnalysis.EditorFeatures, Version=2.6.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;ProduceTagsAsync&gt;d__0`1&lt;System.__Canon&gt; ByRef)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.ProduceTagsAsync[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IClassificationDelegationService`1&lt;System.__Canon&gt;, System.__Canon, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationViewTaggerProvider.ProduceTagsAsync[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IClassificationDelegationService`1&lt;System.__Canon&gt;)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationViewTaggerProvider.ProduceTagsAsync(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;)
   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].ProduceTagsAsync(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;System.__Canon&gt;)
   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource+&lt;RecomputeTagsAsync&gt;d__73[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource+&lt;RecomputeTagsAsync&gt;d__73[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Microsoft.CodeAnalysis.EditorFeatures, Version=2.6.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;RecomputeTagsAsync&gt;d__73&lt;System.__Canon&gt; ByRef)
   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].RecomputeTagsAsync(System.Object, System.Nullable`1&lt;Microsoft.VisualStudio.Text.SnapshotPoint&gt;, System.Nullable`1&lt;Microsoft.CodeAnalysis.Text.TextChangeRange&gt;, System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan&gt;, System.Collections.Immutable.ImmutableDictionary`2&lt;Microsoft.VisualStudio.Text.ITextBuffer,Microsoft.CodeAnalysis.Editor.Shared.Tagging.TagSpanIntervalTree`1&lt;System.__Canon&gt;&gt;, Boolean, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource+&lt;&gt;c__DisplayClass63_0[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].&lt;RecomputeTagsForeground&gt;b__0(System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.Shared.Threading.AsynchronousSerialWorkQueue+&lt;&gt;c__DisplayClass11_0.&lt;EnqueueBackgroundTask&gt;b__0(System.Threading.Tasks.Task)
   at System.Threading.Tasks.ContinuationResultTaskFromTask`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].InnerInvoke()
   at System.Threading.Tasks.Task.Execute()
   at System.Threading.Tasks.Task.ExecutionContextCallback(System.Object)
   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)
   at System.Threading.Tasks.Task.ExecuteEntry(Boolean)
   at System.Threading.Tasks.Task.System.Threading.IThreadPoolWorkItem.ExecuteWorkItem()
   at System.Threading.ThreadPoolWorkQueue.Dispatch()
   at System.Threading._ThreadPoolWaitCallback.PerformWaitCallback()
```

/cc @VSadov </Description>
        <CreatedDate>28/11/2017</CreatedDate>
        <ClosedDate>05/12/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>23438</PullRequestID>
        <IssueID>23338</IssueID>
        <Title>Unnecessary defensive copy of an `in` parameter is created, whose type is nullable readonly struct</Title>
        <Description>**Version Used**: 

Version 15.5.0 Preview 4.0
VisualStudio.15.Preview/15.5.0-pre.4.0+27110.0

Visual C# 2017 00369-60000-00001-AA127
Microsoft Visual C# 2017

C# 7.2

**Steps to Reproduce**:

Compile and inspect IL:
```
using System;

readonly struct S
{
    readonly decimal d;

    public S(decimal d)
    {
        this.d = d;
    }
}

class P
{
    static void Foo(in S? x)
    {
        Console.WriteLine(x.GetValueOrDefault());
    }
    
    static void Main()
    {
        S? y = new S(5m);
        Foo(y);
    }
}
```
**Actual Behavior**:
The `in` parameter `x` in the method  `Foo` is copied to a compiler-generated local before `GetValueOrDefault()` is invoked.

**Expected Behavior**:
This copy is unnecessary and should be elided. No method or property of a nullable value type can mutate it if the underlying type is a readonly struct.</Description>
        <CreatedDate>21/11/2017</CreatedDate>
        <ClosedDate>05/12/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>23438</PullRequestID>
        <IssueID>23166</IssueID>
        <Title>Unused parameter in Microsoft.CodeAnalysis.CSharp.Binder.CheckFieldRefEscape (potential bug?)</Title>
        <Description>Enabling CA1801 (unused parameter rule) fires it for [CheckFieldRefEscape](http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Binder/Binder.ValueChecks.cs,a204c04b97fd2e6c) and [CheckFieldLikeEventRefEscape](http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Binder/Binder.ValueChecks.cs,09e0b3ce0e53064a) for parameter `checkingReceiver` being unused. We should either use this parameter or remove it from the signature.</Description>
        <CreatedDate>14/11/2017</CreatedDate>
        <ClosedDate>05/12/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>23438</PullRequestID>
      <File>src/Compilers/CSharp/Portable/Binder/Binder.ValueChecks.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Expressions.cs</File>
      <File>src/Compilers/CSharp/Portable/CodeGen/EmitExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenInParametersTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenShortCircuitOperatorTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/NullableTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/SemanticErrorTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23430</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Go To Disassembly</Title>
    <Description>I was asked by @sharwell to submit this as PR, I took most of the code from https://github.com/dotnet/roslyn/compare/master...rchande:go-to-disassembly and replaced the 2.x version of ICSharpCode.Decompiler with 3.0.0.3367-beta3.

Notes:

a) not sure if the template is needed, please help! ;-)
b) I had to manually add `ICSharpCode.Decompiler.dll` and `Mono.Cecil.dll` to `devenv.exe.config`, despite having added the following attributes to `\src\VisualStudio\Setup\AssemblyRedirects.cs`

```
[assembly: ProvideCodeBase(CodeBase = @"$PackageFolder$\Mono.Cecil.dll")]
[assembly: ProvideCodeBase(CodeBase = @"$PackageFolder$\ICSharpCode.Decompiler.dll")]
```

Could you help me with that?

c) the `Go To Disassembly` command is not implemented yet.

### Customer scenario

A customer uses **Go To Definition** on a symbol defined in metadata, and is taken to a file with stubs instead of the actual implementation.

### Bugs this fixes

Related to #16540
Related to icsharpcode/ILSpy#791

### Workarounds, if any

None.

### Risk

Low. The feature is behind a feature flag and a legal notice. The original code path is used by default during the experimental phase of this feature. The original code path is used if the new feature fails for any reason aside from a stack overflow.

### Performance impact

Non-deterministic, but only pay for play.

### Is this a regression from a previous update?

No.

### Root cause analysis

N/A (new feature)

### How was the bug found?

Customer request

### Test documentation updated?

No (left as a required item for moving this feature from experimental to stable).
</Description>
    <CreatedDate>28/11/2017</CreatedDate>
    <ClosedDate>08/12/2017</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>23430</PullRequestID>
        <IssueID>16540</IssueID>
        <Title>Public API for IMetadataAsSourceService</Title>
        <Description>I have just found [`IMetadataAsSourceService`](http://source.roslyn.io/#Microsoft.CodeAnalysis.Features/MetadataAsSource/IMetadataAsSourceService.cs,efa3025f7d523cd9) interface that enables me to replace default metadata view with decompiled code from ILSpy in about 50LOC - see https://github.com/icsharpcode/ILSpy/pull/791 It is sooo cool :), but the interface is internal so I had to hack it a bit. Would it be possible to make it an official extensibility point?
</Description>
        <CreatedDate>16/01/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>23430</PullRequestID>
        <IssueID>791</IssueID>
        <Title>VS crashes with ArgumentOutOfRangeException: "startIndex cannot be larger than length" for unclosed /* comment in C# source</Title>
        <Description>Ported from TFS WorkItem: **1108049**

---

**Repro Steps:**

Paste this C# code into ETA (or VS):
`/*`

System.ArgumentOutOfRangeException: startIndex cannot be larger than length of string.

&amp;nbsp; at string.Substring(int startIndex)

&amp;nbsp; at M.CA.Editor.CSharp.Outlining.CSharpOutliningHelpers.CreateCommentBannerTextWithPrefix(string text = "", string prefix = "/*")

&amp;nbsp;

The call stack is attached.

See the dump at [\mlangfs1\public\vladres\78c676647ef347a7917a0b954666544a](file://\mlangfs1publicvladres78c676647ef347a7917a0b954666544a)

---

**Revisions:**

1) Created By Vladimir Reshetnikov (1/14/2015 2:23:48 PM)

---

2) Edited By Kevin Pilch-Bisson (1/15/2015 10:26:03 AM)

Leaving in RTM, because it has to be a a file with less than 2 characters after the /*.

---
</Description>
        <CreatedDate>23/02/2015</CreatedDate>
        <ClosedDate>24/02/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>23430</PullRequestID>
      <File>src/EditorFeatures/Core/IMetadataAsSourceFileService.cs</File>
      <File>src/EditorFeatures/Core/Implementation/MetadataAsSource/MetadataAsSourceFileService.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Peek/DefinitionPeekableItem.cs</File>
      <File>src/EditorFeatures/Core/Shared/Options/FeatureOnOffOptions.cs</File>
      <File>src/EditorFeatures/Test/MetadataAsSource/AbstractMetadataAsSourceTests.TestContext.cs</File>
      <File>src/VisualStudio/CSharp/Impl/Options/AdvancedOptionPageControl.xaml.cs</File>
      <File>src/VisualStudio/CSharp/Impl/Options/AdvancedOptionPageStrings.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Workspace/VisualStudioSymbolNavigationService.cs</File>
      <File>src/VisualStudio/Core/Def/ServicesVSResources.Designer.cs</File>
      <File>src/VisualStudio/Setup/AssemblyRedirects.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23414</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Make anonymous type's GetHashCode not depend on compilation environment</Title>
    <Description>We stop calling string.GetHashCode() at compile time and placing the value in the
generated code because that is not deterministic. Instead we use FNV1a hash code.

For VB, which does not have this bug, we update the implementation to use a more
reliable case-mapping method (see #2116)

### Customer scenario

Compile source code in two different compilation environments, expecting the result to be the same. But the generated GetHashCode varies from one to another because it depends on string.GetHashCode in the compilation environment. When compiling in an environment with [randomized string hashing](https://docs.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element), the compiler will produce a different assembly nearly every time.

### Bugs this fixes

Fixes #23020

### Workarounds, if any

Don't compile in different environments and expect deterministic compiler output.

### Risk

Very low. Replaces one hash code computation with another.

### Performance impact

Very low for the same reason.

### Is this a regression from a previous update?

No.

### Root cause analysis

We've been improving our determinism since we started working on it a couple of years ago. This particular issue was detected and diagnosed by a customer.

### How was the bug found?

Customer reported.

### Test documentation updated?

N/A

@dotnet/roslyn-compiler Please review.</Description>
    <CreatedDate>28/11/2017</CreatedDate>
    <ClosedDate>30/11/2017</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>23414</PullRequestID>
        <IssueID>2116</IssueID>
        <Title>Change VB's case-mapping rules to use a more recent Unicode version</Title>
        <Description>VB's current case-mapping rules for identifier equivalence uses a pretty old version of the Unicode spec, and has bugs. Specifically we use the "invariant" locale, which because it is invariant will never change to be updated as the Unicode spec evolves.

We should instead use a "neutral" culture for the case-mapping, such as the "en" locale, which follows the Unicode case-mapping rules and has no locale-specific exceptions.

&lt;!---
@huboard:{"order":1968.0,"milestone_order":2116,"custom_state":""}
--&gt;
</Description>
        <CreatedDate>20/04/2015</CreatedDate>
        <ClosedDate>27/04/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>23414</PullRequestID>
        <IssueID>23020</IssueID>
        <Title>Generation of the GetHashCode method of anonymous types is not deterministic</Title>
        <Description>**Version Used**: 
Commit 72b8f88b0d

**Steps to Reproduce**:

1. Create the following .cs file:
```
class Program
{
    static void Main()
    {
        var a = new { a = 4 };
    }
}
```
2. Compile it with core MSBuild
3. Copy the output .dll elsewhere and compile it again
4. Alternatively, use csc and set the `deterministic` flag:
`dotnet csc.dll Program.cs /target:library /deterministic /noconfig /reference:"C:\Program Files\dotnet\sdk\NuGetFallbackFolder\microsoft.netcore.app\2.0.0\ref\netcoreapp2.0\System.Collections.dll" /reference:"C:\Program Files\dotnet\sdk\NuGetFallbackFolder\microsoft.netcore.app\2.0.0\ref\netcoreapp2.0\System.Runtime.dll"`

**Expected Behavior**:
The compiler should produce the exact same output both times.

**Actual Behavior**:
The compiler's output differs every time.
If the net46 csc build is used, the compiler produces the same output each time it is run.

**Reason**:
The difference comes from the GetHashCode method of the created anonymous type. Here's the IL from two separate compiles.
```
  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    // Code size       29 (0x1d)
    .maxstack  8
    IL_0000:  ldc.i4     0x1af3bd32
    IL_0005:  ldc.i4     0xa5555529
    IL_000a:  mul
```
```
.method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    // Code size       29 (0x1d)
    .maxstack  8
    IL_0000:  ldc.i4     0xc61810dc
    IL_0005:  ldc.i4     0xa5555529
    IL_000a:  mul
```

One of the constants used in the hash method changes every time. This is because Roslyn uses the hash codes of the backing fields of anonymous types to generate the above constant. ([Code here](https://github.com/dotnet/roslyn/blob/72b8f88b0daf42e1a8b1d6687cbfc9ccbb0cc21a/src/Compilers/CSharp/Portable/Compiler/AnonymousTypeMethodBodySynthesizer.cs#L190))

This isn't a problem in .NET Framework because [randomized string hashing](https://docs.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element) is disabled by default. However, it's enabled by default in coreclr, so identical strings will give different hash codes each time the process is run, creating non-deterministic IL code.</Description>
        <CreatedDate>06/11/2017</CreatedDate>
        <ClosedDate>30/11/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>23414</PullRequestID>
      <File>src/Compilers/CSharp/Portable/Compiler/AnonymousTypeMethodBodySynthesizer.cs</File>
      <File>src/Compilers/CSharp/Test/WinRT/AnonymousTypesSymbolTests.cs</File>
      <File>src/Compilers/Core/Portable/InternalUtilities/Hash.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23412</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Fix for #22690 NRE in GetAttributeSyntaxNodeOfToken</Title>
    <Description>:memo: This is a back-port of #22961 to **dev15.5.x**. The template below is copied from that issue.

**Customer scenario**

An NRE in AbstractInternalsVisibleToCompletionProvider causes a crash of VS. The NRE was not reproducible and seemed only to occur in the C# intermediate window. No tests are provided (see #22690 why).

**Bugs this fixes:**

Fixes #22690 
[DevDiv 525354](https://devdiv.visualstudio.com/DevDiv/_workitems/edit/525354)

**Workarounds, if any**

None.

**Risk**

Bug was not reproducible and therefore no tests are given. The fix is a best guess effort and is based on looking at possible NRE places in the stacktrace given by #22690:

* `IsStringLiteralExpression` is only called at on place in `AbstractInternalsVisibleToCompletionProvider.GetAttributeSyntaxNodeOfToken`
* `CSharpSyntaxFactsService.IsStringLiteralExpression`  is defined as `=&gt; node.Kind() == SyntaxKind.StringLiteralExpression;`
* `node.Kind()` causes the NRE most likely here: `var rawKind = node.RawKind;` if node is null.

If this analysis is not correct there might still be a bug that causes VS to crash.

**Performance impact**

None.

**Is this a regression from a previous update?**

No. New feature. Bug found in VS 15.5 Preview 1

**Root cause analysis:**

`var node = token.Parent;` returns `null` in some rare circumstances. This was discovered in VS 15.5 Preview 1.

**How was the bug found?**

Reported by @tmat in #22690.

**Test documentation updated?**

No.</Description>
    <CreatedDate>28/11/2017</CreatedDate>
    <ClosedDate>29/11/2017</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>23412</PullRequestID>
        <IssueID>22961</IssueID>
        <Title>Fix for #22690 NRE in GetAttributeSyntaxNodeOfToken in AbstractInternalsVisibleToCompletionProvider</Title>
        <Description>**Customer scenario**

An NRE in AbstractInternalsVisibleToCompletionProvider causes a crash of VS. The NRE was not reproducible and seemed only to occur in the C# intermediate window. No tests are provided (see #22690 why).

**Bugs this fixes:**

Fixes #22690 

**Workarounds, if any**

None.

**Risk**

Bug was not reproducible and therefore no tests are given. The fix is a best guess effort and is based on looking at possible NRE places in the stacktrace given by #22690:

* `IsStringLiteralExpression` is only called at on place in `AbstractInternalsVisibleToCompletionProvider.GetAttributeSyntaxNodeOfToken`
* `CSharpSyntaxFactsService.IsStringLiteralExpression`  is defined as `=&gt; node.Kind() == SyntaxKind.StringLiteralExpression;`
* `node.Kind()` causes the NRE most likely here: `var rawKind = node.RawKind;` if node is null.

If this analysis is not correct there might still be a bug that causes VS to crash.

**Performance impact**

None.

**Is this a regression from a previous update?**

No. New feature. Bug found in VS 15.5 Preview 1

**Root cause analysis:**

`var node = token.Parent;` returns `null` in some rare circumstances. This was discovered in VS 15.5 Preview 1.

**How was the bug found?**

Reported by @tmat in #22690.

**Test documentation updated?**

No.</Description>
        <CreatedDate>01/11/2017</CreatedDate>
        <ClosedDate>22/11/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>23412</PullRequestID>
        <IssueID>22690</IssueID>
        <Title>VS crash: AbstractInternalsVisibleToCompletionProvider.GetAttributeSyntaxNodeOfToken throws NRE</Title>
        <Description>```
   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(SyntaxNode node) in E:\A\_work\24\s\src\Compilers\CSharp\Portable\CSharpExtensions.cs:line 161
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxFactsService.IsStringLiteralExpression(SyntaxNode node) in E:\A\_work\24\s\src\Workspaces\CSharp\Portable\LanguageServices\CSharpSyntaxFactsService.cs:line 1314
   at Microsoft.CodeAnalysis.Completion.Providers.AbstractInternalsVisibleToCompletionProvider.GetAttributeSyntaxNodeOfToken(ISyntaxFactsService syntaxFactsService, SyntaxToken token) in E:\A\_work\24\s\src\Features\Core\Portable\Completion\Providers\AbstractInternalsVisibleToCompletionProvider.cs:line 78
   at Microsoft.CodeAnalysis.Completion.Providers.AbstractInternalsVisibleToCompletionProvider.&lt;ProvideCompletionsAsync&gt;d__4.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\Providers\AbstractInternalsVisibleToCompletionProvider.cs:line 55
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders.&lt;GetContextAsync&gt;d__31.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionServiceWithProviders.cs:line 449
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders.&lt;ComputeNonEmptyCompletionContextsAsync&gt;d__24.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionServiceWithProviders.cs:line 311
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders.&lt;GetCompletionsAsync&gt;d__22.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionServiceWithProviders.cs:line 241
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionService.&lt;GetCompletionsAndSetItemDocumentAsync&gt;d__11.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionService.cs:line 183
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Editor.Implementation.IntelliSense.Completion.Controller.Session.ModelComputer.&lt;DoInBackgroundAsync&gt;d__13.MoveNext() in E:\A\_work\24\s\src\EditorFeatures\Core\Implementation\IntelliSense\Completion\Controller.Session_ComputeModel.cs:line 103
```

Crash dump: %internal_share%\public\tomat\Bugs\22690

VS build: 15.5.0 P1 (26927.1)
</Description>
        <CreatedDate>13/10/2017</CreatedDate>
        <ClosedDate>22/11/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>23412</PullRequestID>
        <IssueID>22690</IssueID>
        <Title>VS crash: AbstractInternalsVisibleToCompletionProvider.GetAttributeSyntaxNodeOfToken throws NRE</Title>
        <Description>```
   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(SyntaxNode node) in E:\A\_work\24\s\src\Compilers\CSharp\Portable\CSharpExtensions.cs:line 161
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxFactsService.IsStringLiteralExpression(SyntaxNode node) in E:\A\_work\24\s\src\Workspaces\CSharp\Portable\LanguageServices\CSharpSyntaxFactsService.cs:line 1314
   at Microsoft.CodeAnalysis.Completion.Providers.AbstractInternalsVisibleToCompletionProvider.GetAttributeSyntaxNodeOfToken(ISyntaxFactsService syntaxFactsService, SyntaxToken token) in E:\A\_work\24\s\src\Features\Core\Portable\Completion\Providers\AbstractInternalsVisibleToCompletionProvider.cs:line 78
   at Microsoft.CodeAnalysis.Completion.Providers.AbstractInternalsVisibleToCompletionProvider.&lt;ProvideCompletionsAsync&gt;d__4.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\Providers\AbstractInternalsVisibleToCompletionProvider.cs:line 55
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders.&lt;GetContextAsync&gt;d__31.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionServiceWithProviders.cs:line 449
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders.&lt;ComputeNonEmptyCompletionContextsAsync&gt;d__24.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionServiceWithProviders.cs:line 311
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders.&lt;GetCompletionsAsync&gt;d__22.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionServiceWithProviders.cs:line 241
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionService.&lt;GetCompletionsAndSetItemDocumentAsync&gt;d__11.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionService.cs:line 183
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Editor.Implementation.IntelliSense.Completion.Controller.Session.ModelComputer.&lt;DoInBackgroundAsync&gt;d__13.MoveNext() in E:\A\_work\24\s\src\EditorFeatures\Core\Implementation\IntelliSense\Completion\Controller.Session_ComputeModel.cs:line 103
```

Crash dump: %internal_share%\public\tomat\Bugs\22690

VS build: 15.5.0 P1 (26927.1)
</Description>
        <CreatedDate>13/10/2017</CreatedDate>
        <ClosedDate>22/11/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>23412</PullRequestID>
        <IssueID>22690</IssueID>
        <Title>VS crash: AbstractInternalsVisibleToCompletionProvider.GetAttributeSyntaxNodeOfToken throws NRE</Title>
        <Description>```
   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(SyntaxNode node) in E:\A\_work\24\s\src\Compilers\CSharp\Portable\CSharpExtensions.cs:line 161
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxFactsService.IsStringLiteralExpression(SyntaxNode node) in E:\A\_work\24\s\src\Workspaces\CSharp\Portable\LanguageServices\CSharpSyntaxFactsService.cs:line 1314
   at Microsoft.CodeAnalysis.Completion.Providers.AbstractInternalsVisibleToCompletionProvider.GetAttributeSyntaxNodeOfToken(ISyntaxFactsService syntaxFactsService, SyntaxToken token) in E:\A\_work\24\s\src\Features\Core\Portable\Completion\Providers\AbstractInternalsVisibleToCompletionProvider.cs:line 78
   at Microsoft.CodeAnalysis.Completion.Providers.AbstractInternalsVisibleToCompletionProvider.&lt;ProvideCompletionsAsync&gt;d__4.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\Providers\AbstractInternalsVisibleToCompletionProvider.cs:line 55
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders.&lt;GetContextAsync&gt;d__31.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionServiceWithProviders.cs:line 449
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders.&lt;ComputeNonEmptyCompletionContextsAsync&gt;d__24.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionServiceWithProviders.cs:line 311
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders.&lt;GetCompletionsAsync&gt;d__22.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionServiceWithProviders.cs:line 241
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionService.&lt;GetCompletionsAndSetItemDocumentAsync&gt;d__11.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionService.cs:line 183
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Editor.Implementation.IntelliSense.Completion.Controller.Session.ModelComputer.&lt;DoInBackgroundAsync&gt;d__13.MoveNext() in E:\A\_work\24\s\src\EditorFeatures\Core\Implementation\IntelliSense\Completion\Controller.Session_ComputeModel.cs:line 103
```

Crash dump: %internal_share%\public\tomat\Bugs\22690

VS build: 15.5.0 P1 (26927.1)
</Description>
        <CreatedDate>13/10/2017</CreatedDate>
        <ClosedDate>22/11/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>23412</PullRequestID>
        <IssueID>22690</IssueID>
        <Title>VS crash: AbstractInternalsVisibleToCompletionProvider.GetAttributeSyntaxNodeOfToken throws NRE</Title>
        <Description>```
   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(SyntaxNode node) in E:\A\_work\24\s\src\Compilers\CSharp\Portable\CSharpExtensions.cs:line 161
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxFactsService.IsStringLiteralExpression(SyntaxNode node) in E:\A\_work\24\s\src\Workspaces\CSharp\Portable\LanguageServices\CSharpSyntaxFactsService.cs:line 1314
   at Microsoft.CodeAnalysis.Completion.Providers.AbstractInternalsVisibleToCompletionProvider.GetAttributeSyntaxNodeOfToken(ISyntaxFactsService syntaxFactsService, SyntaxToken token) in E:\A\_work\24\s\src\Features\Core\Portable\Completion\Providers\AbstractInternalsVisibleToCompletionProvider.cs:line 78
   at Microsoft.CodeAnalysis.Completion.Providers.AbstractInternalsVisibleToCompletionProvider.&lt;ProvideCompletionsAsync&gt;d__4.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\Providers\AbstractInternalsVisibleToCompletionProvider.cs:line 55
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders.&lt;GetContextAsync&gt;d__31.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionServiceWithProviders.cs:line 449
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders.&lt;ComputeNonEmptyCompletionContextsAsync&gt;d__24.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionServiceWithProviders.cs:line 311
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders.&lt;GetCompletionsAsync&gt;d__22.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionServiceWithProviders.cs:line 241
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionService.&lt;GetCompletionsAndSetItemDocumentAsync&gt;d__11.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionService.cs:line 183
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Editor.Implementation.IntelliSense.Completion.Controller.Session.ModelComputer.&lt;DoInBackgroundAsync&gt;d__13.MoveNext() in E:\A\_work\24\s\src\EditorFeatures\Core\Implementation\IntelliSense\Completion\Controller.Session_ComputeModel.cs:line 103
```

Crash dump: %internal_share%\public\tomat\Bugs\22690

VS build: 15.5.0 P1 (26927.1)
</Description>
        <CreatedDate>13/10/2017</CreatedDate>
        <ClosedDate>22/11/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>23412</PullRequestID>
      <File>src/Features/Core/Portable/Completion/Providers/AbstractInternalsVisibleToCompletionProvider.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23397</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Making sure that "in" matches exactly in method group conversions.</Title>
    <Description>It looks like method group conversions apply regular method overload resolution when resolving target method group.
However we know that in such scenario, unlike the regular argument passing, "byval" cannot match "in".

We should reject candidates with in/val mismatches when doing overload resolution for group conversion purposes. Otherwise we may encounter false ambiguity errors or even pick wrong candidates that crash at run time.

Fixes:#23319

### Customer scenario

Customer uses code that converts a method group with `in` parameters to a delegate that uses ordinary byval parameters in the same positions. 
It is expected that C# compiler rejects such assignment ans it is not permitted by CLR. (ref and val parameters are not compatible, during delegate creation).

Because of the bug, code compiles and crashes at run time.

### Bugs this fixes

Fixes:#23319

### Workarounds, if any

Not using the described scenario that results in broken code.

### Risk

Low. 
The change is mostly about propagating "isMethodConversion" further, so that conversion machinery could reject candidates with `in` --&gt; `byval` parameter match when performing resolution for the purpose of method group conversions. 

### Performance impact

Low.

### Is this a regression from a previous update?

No.

### Root cause analysis

Similar rules govern lambda conversions and were implemented and tested. The case with method group conversions goes on a different path (since it needs to do overload resolution form multiple candidates) and thus the scenario was missed.

### How was the bug found?

Reported by external customer.

### Test documentation updated?

N/A</Description>
    <CreatedDate>27/11/2017</CreatedDate>
    <ClosedDate>04/12/2017</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>23397</PullRequestID>
        <IssueID>23319</IssueID>
        <Title>C# compiler allows unsafe conversions from method groups to delegates with mismatching `in` modifier</Title>
        <Description>**Version Used**: 
Version 15.5.0 Preview 4.0
VisualStudio.15.Preview/15.5.0-pre.4.0+27110.0

Visual C# 2017   00369-60000-00001-AA127
Microsoft Visual C# 2017

C# 7.2

**Steps to Reproduce**:

Compile and run:

```
using System;

class Program
{
    static void F(in DateTime x)
    {
        Console.WriteLine(x);
    }

    static void Main()
    {
        Action&lt;DateTime&gt; a = F;
        a(DateTime.MaxValue);
    }
}
```

**Expected Behavior**:
A compile-time error.

**Actual Behavior**:
The program compiles successfully, but fails at runtime:
&gt; Unhandled Exception: System.AccessViolationException: Attempted to read or write protected memory. This is often an indication that other memory is corrupt.
   at Program.F(DateTime&amp; x) in Program.cs:line 7</Description>
        <CreatedDate>21/11/2017</CreatedDate>
        <ClosedDate>04/12/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>23397</PullRequestID>
        <IssueID>23319</IssueID>
        <Title>C# compiler allows unsafe conversions from method groups to delegates with mismatching `in` modifier</Title>
        <Description>**Version Used**: 
Version 15.5.0 Preview 4.0
VisualStudio.15.Preview/15.5.0-pre.4.0+27110.0

Visual C# 2017   00369-60000-00001-AA127
Microsoft Visual C# 2017

C# 7.2

**Steps to Reproduce**:

Compile and run:

```
using System;

class Program
{
    static void F(in DateTime x)
    {
        Console.WriteLine(x);
    }

    static void Main()
    {
        Action&lt;DateTime&gt; a = F;
        a(DateTime.MaxValue);
    }
}
```

**Expected Behavior**:
A compile-time error.

**Actual Behavior**:
The program compiles successfully, but fails at runtime:
&gt; Unhandled Exception: System.AccessViolationException: Attempted to read or write protected memory. This is often an indication that other memory is corrupt.
   at Program.F(DateTime&amp; x) in Program.cs:line 7</Description>
        <CreatedDate>21/11/2017</CreatedDate>
        <ClosedDate>04/12/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>23397</PullRequestID>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Conversions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/OverloadResolution/OverloadResolution.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/OverloadResolutionTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23390</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Fixed 'Qualify member access' analyzer for object initializer</Title>
    <Description>Fixes #22776
Fixes #23016

Regression from 15.4

VSO bug : [link](https://devdiv.visualstudio.com/DevDiv/NET%20Developer%20Experience%20Productivity/_workitems/edit/529870)</Description>
    <CreatedDate>27/11/2017</CreatedDate>
    <ClosedDate>28/11/2017</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>23390</PullRequestID>
        <IssueID>22776</IssueID>
        <Title>Incorrect "Add 'this.'" diagnostic for class initializers</Title>
        <Description>This is reported in a few Developer Community feedback items, I will link them as they're processed.
-  https://developercommunity.visualstudio.com/content/problem/131432/add-this-or-me-qualification-for-class-initializer.html
- https://developercommunity.visualstudio.com/content/problem/129705/incorrect-ide0009-in-object-initializer.html
- https://developercommunity.visualstudio.com/content/problem/161932/ide0009-add-this-or-me-qualification-incorrectly-r.html

I have not been able to reproduce this locally using the settings in the Tools | Options. Maybe it requires the editorconfig? That doesn't make much sense but I haven't been able to come up with anything else.</Description>
        <CreatedDate>19/10/2017</CreatedDate>
        <ClosedDate>21/12/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>23390</PullRequestID>
        <IssueID>23016</IssueID>
        <Title>Add this or me qualification rule triggered incorrectly in return statement</Title>
        <Description>Have the following code:

            return new UserSession
            {
                UserId = subject
            };

Where UserSession is a simple class with property UserId. I'm getting green squiggles under the UserId in that statement, suggesting I add this or me qualification.

_This issue has been moved from https://developercommunity.visualstudio.com/content/problem/126539/add-this-or-me-qualification-rule-triggered-incorr.html
VSTS ticketId: 505612_
_These are the original issue comments:_

David Poeschl [MSFT] on ‚Äé10‚Äé/‚Äé18‚Äé/‚Äé2017, 00:37 PM (17 days ago): &lt;p&gt;Thank you for your feedback! I've so far been unable to reproduce this problem. I tried with the following code:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;class C&lt;/p&gt;&lt;p&gt;\{&lt;/p&gt;&lt;p&gt;  static UserSession M()&lt;/p&gt;&lt;p&gt;  \{&lt;/p&gt;&lt;p&gt;    object subject = null;&lt;/p&gt;&lt;p&gt;    return new UserSession&lt;/p&gt;&lt;p&gt;    \{&lt;/p&gt;&lt;p&gt;      UserId = subject&lt;/p&gt;&lt;p&gt;    };&lt;/p&gt;&lt;p&gt;  }&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;internal class UserSession&lt;/p&gt;&lt;p&gt;\{&lt;/p&gt;&lt;p&gt;  public object UserId \{ get; set; }&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;And under &amp;quot;Text Editor | C# | Code Style | General | 'this.' preferences&amp;quot; I've set everything to &amp;quot;Prefer 'this.'&amp;quot; with &amp;quot;Warning&amp;quot; severity. Am I missing a step that you can tell? Thanks!&lt;/p&gt;

_These are the original issue solutions:_
(no solutions)</Description>
        <CreatedDate>05/11/2017</CreatedDate>
        <ClosedDate>09/01/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>23390</PullRequestID>
      <File>src/EditorFeatures/CSharpTest/QualifyMemberAccess/QualifyMemberAccessTests.cs</File>
      <File>src/Features/CSharp/Portable/QualifyMemberAccess/CSharpQualifyMemberAccessDiagnosticAnalyzer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23238</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Fix an InvalidCastException in IOperation factory for an ambiguous user-defined short-circuiting operator</Title>
    <Description>Fixes #23232.
Also fixes incorrect calculation of BinaryOperatorKind for the same node.

**Customer scenario**

Request IOperation tree for an ambiguous user-defined short-circuiting operator like the one below:
```
Option Strict Off

Imports System

Module Module1

    Class B2
        Public Shared Operator And(x As B3, y As B2) As B2
            Return Nothing
        End Operator

        Public Shared Operator Or(x As B3, y As B2) As B2
            Return Nothing
        End Operator
    End Class

    Class B3
        Public Shared Operator And(x As B3, y As B2) As B3
            Return Nothing
        End Operator

        Public Shared Operator Or(x As B3, y As B2) As B3
            Return Nothing
        End Operator
    End Class

    Sub Main()
        Dim x As Object

        x = New B3() AndAlso New B2() 'BIND1:"New B3() AndAlso New B2()"
    End Sub
End Module
```

An InvalidCastException is thrown by IOperation factory.

**Bugs this fixes:**

Fixes #23232.

**Workarounds, if any**

No

**Risk**

Low

**Performance impact**

Low perf impact because no extra allocations/no complexity changes

**Is this a regression from a previous update?**

No

**Root cause analysis:**

A test gap. Unit-tests are added.

**How was the bug found?**

Running existing compiler tests with IOperation validation test hook enabled.
</Description>
    <CreatedDate>17/11/2017</CreatedDate>
    <ClosedDate>17/11/2017</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>23238</PullRequestID>
        <IssueID>23232</IssueID>
        <Title>An InvalidCastException is thrown for an ambiguous user-defined short-circuiting operator</Title>
        <Description>```
        &lt;CompilerTrait(CompilerFeature.IOperation)&gt;
        &lt;Fact&gt;
        Public Sub ShortCircuiting5()
            Dim compilationDef =
&lt;compilation name="SimpleTest1"&gt;
    &lt;file name="a.vb"&gt;&lt;![CDATA[
Option Strict Off

Imports System

Module Module1

    Class B2
        Public Shared Operator And(x As B3, y As B2) As B2
            Return Nothing
        End Operator

        Public Shared Operator Or(x As B3, y As B2) As B2
            Return Nothing
        End Operator
    End Class

    Class B3
        Public Shared Operator And(x As B3, y As B2) As B3
            Return Nothing
        End Operator

        Public Shared Operator Or(x As B3, y As B2) As B3
            Return Nothing
        End Operator
    End Class

    Sub Main()
        Dim x As Object

        x = New B3() AndAlso New B2() 'BIND1:"New B3() AndAlso New B2()"
        x = New B3() OrElse New B2() 'BIND2:"New B3() OrElse New B2()"
    End Sub
End Module
    ]]&gt;&lt;/file&gt;
&lt;/compilation&gt;

            Dim compilation = CreateCompilationWithMscorlibAndVBRuntime(compilationDef)

            CompilationUtils.AssertTheseDiagnostics(compilation,
&lt;expected&gt;
BC30521: Overload resolution failed because no accessible 'And' is most specific for these arguments:
    'Public Shared Operator Module1.B3.And(x As Module1.B3, y As Module1.B2) As Module1.B3': Not most specific.
    'Public Shared Operator Module1.B2.And(x As Module1.B3, y As Module1.B2) As Module1.B2': Not most specific.
        x = New B3() AndAlso New B2() 'BIND1:"New B3() AndAlso New B2()"
            ~~~~~~~~~~~~~~~~~~~~~~~~~
BC30521: Overload resolution failed because no accessible 'Or' is most specific for these arguments:
    'Public Shared Operator Module1.B3.Or(x As Module1.B3, y As Module1.B2) As Module1.B3': Not most specific.
    'Public Shared Operator Module1.B2.Or(x As Module1.B3, y As Module1.B2) As Module1.B2': Not most specific.
        x = New B3() OrElse New B2() 'BIND2:"New B3() OrElse New B2()"
            ~~~~~~~~~~~~~~~~~~~~~~~~
&lt;/expected&gt;)
   
            compilation.VerifyOperationTree(CompilationUtils.FindBindingText(Of ExpressionSyntax)(compilation, "a.vb", 1), expectedOperationTree:=
            &lt;![CDATA[
]]&gt;.Value)

            compilation.VerifyOperationTree(CompilationUtils.FindBindingText(Of ExpressionSyntax)(compilation, "a.vb", 2), expectedOperationTree:=
            &lt;![CDATA[
]]&gt;.Value)
        End Sub
```

Observed:
```
Test 'Microsoft.CodeAnalysis.VisualBasic.UnitTests.Semantics.UserDefinedBinaryOperators.ShortCircuiting5' failed: Microsoft.CodeAnalysis.ThrowingTraceListener+DebugAssertFailureException : 
System.InvalidCastException: Unable to cast object of type 'Microsoft.CodeAnalysis.VisualBasic.BoundBadExpression' to type 'Microsoft.CodeAnalysis.VisualBasic.BoundCall'.
   at Microsoft.CodeAnalysis.VisualBasic.BoundUserDefinedBinaryOperator.get_Call()
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.CreateBoundUserDefinedShortCircuitingOperatorOperation(BoundUserDefinedShortCircuitingOperator boundUserDefinedShortCircuitingOperator)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.CreateInternal(BoundNode boundNode)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory._Lambda$__3-0(BoundNode n)
   at System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(TKey key, Func`2 valueFactory)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.Create(BoundNode boundNode)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory._Closure$__121-0._Lambda$__2()
   at System.Lazy`1.CreateValue()
   at System.Lazy`1.LazyInitValue()
   at System.Lazy`1.get_Value()
   at Microsoft.CodeAnalysis.VisualBasic.LazyVisualBasicConversionExpression.get_OperandImpl()
   at Microsoft.CodeAnalysis.Operations.BaseConversionExpression.get_Operand()
   at Microsoft.CodeAnalysis.Operations.BaseConversionExpression.&lt;get_Children&gt;d__14.MoveNext()
   at Microsoft.CodeAnalysis.Operations.OperationExtensions.&lt;Descendants&gt;d__3.MoveNext()
   at System.Linq.Enumerable.FirstOrDefault[TSource](IEnumerable`1 source, Func`2 predicate)
   at Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.GetOperationWorker(VisualBasicSyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.GetOperationWorker(VisualBasicSyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetOperationCore(SyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.SemanticModel.GetOperation(SyntaxNode node, CancellationToken cancellationToken)

	at Microsoft.CodeAnalysis.ThrowingTraceListener.Fail(String message, String detailMessage)
	at System.Diagnostics.TraceListener.Fail(String message)
	at System.Diagnostics.TraceInternal.Fail(String message)
	at System.Diagnostics.Debug.Assert(Boolean condition, String message)
	at Microsoft.CodeAnalysis.SemanticModel.GetOperation(SyntaxNode node, CancellationToken cancellationToken)
	at Microsoft.CodeAnalysis.Test.Utilities.CompilationExtensions.AppendOperationTree(SemanticModel model, SyntaxNode node, StringBuilder actualTextBuilder, Int32 initialIndent)
	at Microsoft.CodeAnalysis.Test.Utilities.CompilationExtensions.VerifyOperationTree(Compilation compilation, SyntaxNode node, String expectedOperationTree)
	F:\GitHub\roslyn\src\Compilers\VisualBasic\Test\Semantic\Semantics\UserDefinedBinaryOperators.vb(590,0): at Microsoft.CodeAnalysis.VisualBasic.UnitTests.Semantics.UserDefinedBinaryOperators.ShortCircuiting5()
```
</Description>
        <CreatedDate>17/11/2017</CreatedDate>
        <ClosedDate>20/11/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>23238</PullRequestID>
        <IssueID>23232</IssueID>
        <Title>An InvalidCastException is thrown for an ambiguous user-defined short-circuiting operator</Title>
        <Description>```
        &lt;CompilerTrait(CompilerFeature.IOperation)&gt;
        &lt;Fact&gt;
        Public Sub ShortCircuiting5()
            Dim compilationDef =
&lt;compilation name="SimpleTest1"&gt;
    &lt;file name="a.vb"&gt;&lt;![CDATA[
Option Strict Off

Imports System

Module Module1

    Class B2
        Public Shared Operator And(x As B3, y As B2) As B2
            Return Nothing
        End Operator

        Public Shared Operator Or(x As B3, y As B2) As B2
            Return Nothing
        End Operator
    End Class

    Class B3
        Public Shared Operator And(x As B3, y As B2) As B3
            Return Nothing
        End Operator

        Public Shared Operator Or(x As B3, y As B2) As B3
            Return Nothing
        End Operator
    End Class

    Sub Main()
        Dim x As Object

        x = New B3() AndAlso New B2() 'BIND1:"New B3() AndAlso New B2()"
        x = New B3() OrElse New B2() 'BIND2:"New B3() OrElse New B2()"
    End Sub
End Module
    ]]&gt;&lt;/file&gt;
&lt;/compilation&gt;

            Dim compilation = CreateCompilationWithMscorlibAndVBRuntime(compilationDef)

            CompilationUtils.AssertTheseDiagnostics(compilation,
&lt;expected&gt;
BC30521: Overload resolution failed because no accessible 'And' is most specific for these arguments:
    'Public Shared Operator Module1.B3.And(x As Module1.B3, y As Module1.B2) As Module1.B3': Not most specific.
    'Public Shared Operator Module1.B2.And(x As Module1.B3, y As Module1.B2) As Module1.B2': Not most specific.
        x = New B3() AndAlso New B2() 'BIND1:"New B3() AndAlso New B2()"
            ~~~~~~~~~~~~~~~~~~~~~~~~~
BC30521: Overload resolution failed because no accessible 'Or' is most specific for these arguments:
    'Public Shared Operator Module1.B3.Or(x As Module1.B3, y As Module1.B2) As Module1.B3': Not most specific.
    'Public Shared Operator Module1.B2.Or(x As Module1.B3, y As Module1.B2) As Module1.B2': Not most specific.
        x = New B3() OrElse New B2() 'BIND2:"New B3() OrElse New B2()"
            ~~~~~~~~~~~~~~~~~~~~~~~~
&lt;/expected&gt;)
   
            compilation.VerifyOperationTree(CompilationUtils.FindBindingText(Of ExpressionSyntax)(compilation, "a.vb", 1), expectedOperationTree:=
            &lt;![CDATA[
]]&gt;.Value)

            compilation.VerifyOperationTree(CompilationUtils.FindBindingText(Of ExpressionSyntax)(compilation, "a.vb", 2), expectedOperationTree:=
            &lt;![CDATA[
]]&gt;.Value)
        End Sub
```

Observed:
```
Test 'Microsoft.CodeAnalysis.VisualBasic.UnitTests.Semantics.UserDefinedBinaryOperators.ShortCircuiting5' failed: Microsoft.CodeAnalysis.ThrowingTraceListener+DebugAssertFailureException : 
System.InvalidCastException: Unable to cast object of type 'Microsoft.CodeAnalysis.VisualBasic.BoundBadExpression' to type 'Microsoft.CodeAnalysis.VisualBasic.BoundCall'.
   at Microsoft.CodeAnalysis.VisualBasic.BoundUserDefinedBinaryOperator.get_Call()
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.CreateBoundUserDefinedShortCircuitingOperatorOperation(BoundUserDefinedShortCircuitingOperator boundUserDefinedShortCircuitingOperator)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.CreateInternal(BoundNode boundNode)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory._Lambda$__3-0(BoundNode n)
   at System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(TKey key, Func`2 valueFactory)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.Create(BoundNode boundNode)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory._Closure$__121-0._Lambda$__2()
   at System.Lazy`1.CreateValue()
   at System.Lazy`1.LazyInitValue()
   at System.Lazy`1.get_Value()
   at Microsoft.CodeAnalysis.VisualBasic.LazyVisualBasicConversionExpression.get_OperandImpl()
   at Microsoft.CodeAnalysis.Operations.BaseConversionExpression.get_Operand()
   at Microsoft.CodeAnalysis.Operations.BaseConversionExpression.&lt;get_Children&gt;d__14.MoveNext()
   at Microsoft.CodeAnalysis.Operations.OperationExtensions.&lt;Descendants&gt;d__3.MoveNext()
   at System.Linq.Enumerable.FirstOrDefault[TSource](IEnumerable`1 source, Func`2 predicate)
   at Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.GetOperationWorker(VisualBasicSyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.GetOperationWorker(VisualBasicSyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetOperationCore(SyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.SemanticModel.GetOperation(SyntaxNode node, CancellationToken cancellationToken)

	at Microsoft.CodeAnalysis.ThrowingTraceListener.Fail(String message, String detailMessage)
	at System.Diagnostics.TraceListener.Fail(String message)
	at System.Diagnostics.TraceInternal.Fail(String message)
	at System.Diagnostics.Debug.Assert(Boolean condition, String message)
	at Microsoft.CodeAnalysis.SemanticModel.GetOperation(SyntaxNode node, CancellationToken cancellationToken)
	at Microsoft.CodeAnalysis.Test.Utilities.CompilationExtensions.AppendOperationTree(SemanticModel model, SyntaxNode node, StringBuilder actualTextBuilder, Int32 initialIndent)
	at Microsoft.CodeAnalysis.Test.Utilities.CompilationExtensions.VerifyOperationTree(Compilation compilation, SyntaxNode node, String expectedOperationTree)
	F:\GitHub\roslyn\src\Compilers\VisualBasic\Test\Semantic\Semantics\UserDefinedBinaryOperators.vb(590,0): at Microsoft.CodeAnalysis.VisualBasic.UnitTests.Semantics.UserDefinedBinaryOperators.ShortCircuiting5()
```
</Description>
        <CreatedDate>17/11/2017</CreatedDate>
        <ClosedDate>20/11/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>23238</PullRequestID>
      <File>src/Compilers/Core/Portable/Compilation/SemanticModel.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23237</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Change the 'Use auto property' code fixer to not be a 'compilation end' analyzer.</Title>
    <Description>Fixes #23216
Fixes #23215
Fixes #20855
Closes #23217

This PR changes the 'use auto property' code fixer to work as a Semantic-Model-Analyzer, instead of a Compilation-End analyzer.  Compilation-End-Analyzers are basically an unusable part of the analyzer API for code that wants to run in VS.  They are too expensive, and users can't interact with their results in a timely manner, like they can with normal analyzers.

As part of making this happen, I had to make a small change to the functionality of the feature.  Specifically, we used to determine if it was safe to make the change by analyzing all usages of a the field-to-remove in the project the feature was analyzing.  This was very expensive, but was necessary in case some code was using the field in an unexpected manner.  Now, we limit the feature to only private fields.  This means we can do that analysis in a timely manner, as we only have to examine the type it is contained in.  

This should have very little end user impact as the majority of user fields are private (esp. the ones that are paired with a property that you'd want ot make an auto prop out of).
</Description>
    <CreatedDate>17/11/2017</CreatedDate>
    <ClosedDate>20/11/2017</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>23237</PullRequestID>
        <IssueID>23216</IssueID>
        <Title>IDE0032 (Use Auto Property) Fix All does not work</Title>
        <Description>**Version Used**: 15.5 Preview 3

üîó Observed while investigating [this community report](https://developercommunity.visualstudio.com/content/problem/150002/ide0032-performs-less-than-ideal.html).

### Steps to Reproduce

1. Attempt to apply a Fix All operation to IDE0032 (Use Auto Property)

### Expected Behavior

Fix All, when available, fixes all instances of an issue within the specified context.

### Actual Behavior

Only one instance is fixed.

### Additional Details

* This behavior is observed even when Full Solution Analysis is enabled (see #23215)
* This behavior is observed even when IDE0032 is set to Warning severity</Description>
        <CreatedDate>16/11/2017</CreatedDate>
        <ClosedDate>20/11/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>23237</PullRequestID>
        <IssueID>23215</IssueID>
        <Title>IDE0032 (Use Auto Property) does not work when full solution analysis is disabled</Title>
        <Description>**Version Used**: 15.5 Preview 3

üîó Observed while investigating [this community report](https://developercommunity.visualstudio.com/content/problem/150002/ide0032-performs-less-than-ideal.html).

### Steps to Reproduce

1. Add a property:

    ```csharp
    private string _text;

    public string Text
    {
      get { return _text; }
      set { _text = value; }
    }
    ```

### Expected Behavior

The `_text` field is grayed (unnecessary code), and a code fix is provided to convert the field to an auto property.

### Actual Behavior

No suggestion is given.

### Additional details

If **Full Solution Analysis** is enabled, the feature works as expected. However, this feature is disabled both by default and by recommendation, with no plans to enable it. IDE analyzers cannot rely on this feature being enabled.</Description>
        <CreatedDate>16/11/2017</CreatedDate>
        <ClosedDate>20/11/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>23237</PullRequestID>
        <IssueID>20855</IssueID>
        <Title>IDE0032 Use Auto Property code fix mangles code in preexisting property with getter</Title>
        <Description>**Version Used**: d15rel 26711.00

**Steps to Reproduce**:

```
git clone https://github.com/microsoft/vs-threading.git
cd vs-threading
git checkout 0404d41776090ad54fd892081dcd1bd2b9165698
cd src
MSBuild /t:restore
.\Microsoft.VisualStudio.Threading.sln
```

1. Once in VS with the solution open, navigate to AsyncQueue.cs.
1. (I had netstandard1.1 selected as the language service context)
1. When the language service fades out the first field in the class (`syncObject`) activate the "Use Auto Property" code fix.

**Expected Behavior**:

No compile errors and no incorrect changes to code.

**Actual Behavior**:

The `SyncRoot` property which exposed the `syncObject` property is badly mangled. It was this:

```csharp
        protected object SyncRoot
        {
            get { return this.syncObject; }
        }
```

And was changed to this (including the comments, invalid syntax, etc.):

```csharp
        protected object SyncRoot {
/* Unmerged change from project 'Microsoft.VisualStudio.Threading(netstandard1.1)'
Before:
            get { return this.syncObject; }
After:
            get { return set; }
*/
 get; private this.SyncRoot; }
```

Note that there are absolutely no `#if` directives anywhere in the file. But this file is in a project that has 3 target frameworks.</Description>
        <CreatedDate>13/07/2017</CreatedDate>
        <ClosedDate>20/11/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>23237</PullRequestID>
        <IssueID>23217</IssueID>
        <Title>Disable IDE0032 until it works</Title>
        <Description>**Version Used**: 15.5 Preview 3

üîó Observed while investigating [this community report](https://developercommunity.visualstudio.com/content/problem/150002/ide0032-performs-less-than-ideal.html).

**Steps to Reproduce**:

1. Attempt to use the Use Auto Property diagnostic and code fix

**Expected Behavior**:

1. Code does not break
2. The code fix works
3. The fix all operation either work or is not provided

**Actual Behavior**:

I was unable to use this feature in any context and have it provide a meaningful result.

* The feature was not even visible without enabling a non-default (and not recommended) feature (#23215, #17857)
* The code was broken when the feature was used (#20855)
* The code fix didn't perform as expected (#23216)

This diagnostic needs to be disabled until it meets a reasonable quality bar.</Description>
        <CreatedDate>16/11/2017</CreatedDate>
        <ClosedDate>20/11/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>23237</PullRequestID>
      <File>src/EditorFeatures/CSharp/UseAutoProperty/UseAutoPropertyAnalyzer.cs</File>
      <File>src/EditorFeatures/CSharp/UseAutoProperty/UseAutoPropertyCodeFixProvider.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/UseAutoProperty/UseAutoPropertyTests.cs</File>
      <File>src/Features/Core/Portable/UseAutoProperty/AbstractUseAutoPropertyAnalyzer.cs</File>
      <File>src/Features/Core/Portable/UseAutoProperty/AbstractUseAutoPropertyCodeFixProvider.cs</File>
      <File>src/Workspaces/Core/Portable/Rename/Renamer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>21746</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Change stackalloc conversion to a converted bound node</Title>
    <Description>Follow up on comments from #21006 
Fixes #21887

cc @gafter @VSadov 
@dotnet/roslyn-compiler </Description>
    <CreatedDate>25/08/2017</CreatedDate>
    <ClosedDate>05/09/2017</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>21746</PullRequestID>
        <IssueID>21006</IssueID>
        <Title>Parser changes for stackalloc</Title>
        <Description>
        </Description>
        <CreatedDate>20/07/2017</CreatedDate>
        <ClosedDate>15/08/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>21746</PullRequestID>
        <IssueID>21887</IssueID>
        <Title>IDE crashes when editing code that involves stackalloc expressions</Title>
        <Description>When I am trying to edit stuff that involves stackalloc I frequently see a crash with the following stack.
It seems that semantic model is not robust against broken code when stackalloc is involved.

==============

Message: System.InvalidCastException: Unable to cast object of type 'Microsoft.CodeAnalysis.CSharp.BoundBadExpression' to type 'Microsoft.CodeAnalysis.CSharp.BoundConversion'.
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoForNode(BoundNode lowestBoundNode, BoundNode highestBoundNode, BoundNode boundNodeForSyntacticParent)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetTypeInfoWorker(CSharpSyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetTypeInfoWorker(CSharpSyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfo(ExpressionSyntax expression, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoFromNode(SyntaxNode node, CancellationToken cancellationToken)

</Description>
        <CreatedDate>01/09/2017</CreatedDate>
        <ClosedDate>06/09/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>21746</PullRequestID>
      <File>src/Compilers/CSharp/Portable/Binder/Binder.ValueChecks.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Conversions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Expressions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Operators.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Statements.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/Conversions/Conversion.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/BoundExpressionExtensions.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/Expression.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/Formatting.cs</File>
      <File>src/Compilers/CSharp/Portable/CSharpResources.Designer.cs</File>
      <File>src/Compilers/CSharp/Portable/CodeGen/EmitConversion.cs</File>
      <File>src/Compilers/CSharp/Portable/CodeGen/EmitExpression.cs</File>
      <File>src/Compilers/CSharp/Portable/CodeGen/Optimizer.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/CSharpSemanticModel.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/MemberSemanticModel.NodeMapBuilder.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/PreciseAbstractFlowPass.cs</File>
      <File>src/Compilers/CSharp/Portable/Generated/BoundNodes.xml.Generated.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_Conversion.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_StackAlloc.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/MethodToClassRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/SyntaxNodeExtensions.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/StackAllocSpanExpressionsTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/UnsafeTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>21711</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Add IOperation APIs for Dynamic invocations and indexer access</Title>
    <Description>Fixes #20114 and #20122</Description>
    <CreatedDate>23/08/2017</CreatedDate>
    <ClosedDate>15/09/2017</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>21711</PullRequestID>
        <IssueID>20114</IssueID>
        <Title>IOperation API support for BoundDynamicInvocation</Title>
        <Description>This bound node is very similar to BoundCall, except that we have a set of applicable methods instead of a single TargetMethod.

We have couple of choices for the API here:

1. Reuse `IInvocationExpression`, and set the `TargetMethod` to null. In future, when we expose the MethodGroup from IInvocationExpression, the applicable methods can be exposed through this API.
2. Create a new IDynamicInvocationExpression type:
```
    public interface IDynamicInvocationExpression : IHasArgumentsExpression
    {
        /// &lt;summary&gt;
        /// Applicable methods.
        /// &lt;/summary&gt;
        ImmutableArray&lt;IMethodSymbol&gt; ApplicableMethods { get; }
        /// &lt;summary&gt;
        /// 'This' or 'Me' instance to be supplied to the method, or null if the method is static.
        /// &lt;/summary&gt;
        IOperation Instance { get; }
        /// &lt;summary&gt;
        /// True if the invocation uses a virtual mechanism, and false otherwise.
        /// &lt;/summary&gt;
        bool IsVirtual { get; }
    }
```

(1) is similar to the approach we chose for Dynamic collection initializer, but it might be more error prone for analyzer authors as everyone might expect a non-null `IInvocationExpression.TargetMethod` method for an error free case.</Description>
        <CreatedDate>08/06/2017</CreatedDate>
        <ClosedDate>15/09/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>21711</PullRequestID>
        <IssueID>20122</IssueID>
        <Title>IOperation API shape for BoundDynamicIndexerAccess</Title>
        <Description>Same design issue as other BoundDynamicXXX nodes. We can either reuse IIndexedPropertyReferenceExpression or define a new IDynamicIndexedPropertyReferenceExpression with a set of applicable indexers.

```
    public interface IDynamicPropertyReferenceExpression : IMemberReferenceExpression
    {
        ImmutableArray&lt;IPropertySymbol&gt; ApplicableProperties { get; }
    }

    public interface IDynamicIndexedPropertyReferenceExpression : IDynamicPropertyReferenceExpression, IHasArgumentsExpression
    {
    }
```</Description>
        <CreatedDate>08/06/2017</CreatedDate>
        <ClosedDate>15/09/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>21711</PullRequestID>
      <File>src/Compilers/CSharp/Portable/Operations/CSharpOperationFactory.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IDynamicIndexerAccessExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IDynamicInvocationExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IDynamicMemberReferenceExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IDynamicObjectCreationExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IForLoopStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IIfStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IParameterReferenceExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IWhileUntilLoopStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/DynamicTests.cs</File>
      <File>src/Compilers/Core/CodeAnalysisTest/Diagnostics/OperationTests.cs</File>
      <File>src/Compilers/Core/Portable/Generated/Operations.xml.Generated.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IDynamicIndexerAccessExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IDynamicInvocationExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IDynamicObjectCreationExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IHasDynamicArgumentsExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationCloner.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationExtensions.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationKind.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationVisitor.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/OperationTreeVerifier.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/TestOperationWalker.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>21670</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Major MSBuildWorkspace update</Title>
    <Description>Fixes #5557
Fixes #5668
Fixes #15102

- [x] Remove dependency on old COM-based host objects.
- [x] Add support for SDK-style projects (including multi-TFM projects).
- [ ] Get general buy off on this source breaking change.
- [x] Add a Nuspec for the new Workspaces.MSBuild package.
- [x] Change API to account for the fact that a multi-TFM project will need to be loaded as multiple projects.
- [x] Add design-time batch build logic to improve performance.
- [ ] Document how MSBuildWorkspace can be used by clients.
- [ ] Create sample application that demonstrates how to use MSBuildWorkspace.</Description>
    <CreatedDate>22/08/2017</CreatedDate>
    <ClosedDate>05/04/2018</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>21670</PullRequestID>
        <IssueID>5557</IssueID>
        <Title>Roslyn.Services.UnitTests.dll has a failure in Standalone runs</Title>
        <Description>One unit test is failing inside of this suite. It's is expecting a 6 when receiving a 4. I'm not sure what the numbers refer to. I will be disabling this until we get the testcase fixed.

Failure:
   Microsoft.CodeAnalysis.UnitTests.MSBuildWorkspaceTests.TestOpenProject_WithXaml [FAIL]
      Assert.Equal() Failure\r\nExpected: 6\r\nActual:   4
      Stack Trace:
            at Microsoft.CodeAnalysis.UnitTests.MSBuildWorkspaceTests.TestOpenProject_WithXaml()
</Description>
        <CreatedDate>29/09/2015</CreatedDate>
        <ClosedDate>05/04/2018</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>21670</PullRequestID>
        <IssueID>5668</IssueID>
        <Title>[LOC] Roslyn.Services.UnitTests.dll has extra assert failure for JPN</Title>
        <Description>Run Roslyn.Services.UnitTests.dll on JPN OS, JPN VS, with VSUML installed.

Error is :
¬† ¬†Microsoft.CodeAnalysis.UnitTests.MSBuildWorkspaceTests.TestOpenProject_MetadataReferenceHasDocComments [FAIL]
¬† ¬† ¬† Assert.NotEqual() Failure
¬† ¬† ¬† Stack Trace:
¬† ¬† ¬† ¬† ¬† ¬† ¬è√™¬è≈† Xunit.Assert.NotEqual[T](T expected, T actual, IEqualityComparer`1 comparer)
¬† ¬† ¬† ¬† ¬† ¬† ¬è√™¬è≈† Microsoft.CodeAnalysis.UnitTests.MSBuildWorkspaceTests.TestOpenProject_MetadataReferenceHasDocCommen
</Description>
        <CreatedDate>02/10/2015</CreatedDate>
        <ClosedDate>05/04/2018</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>21670</PullRequestID>
        <IssueID>15102</IssueID>
        <Title>Some MSBuildWorkspaceTests fail after updating to Dev15 Preview5</Title>
        <Description>After updating our build to target Dev15 Preview5, and updating the `MSBuildWorkspace` to find the MSBuild 15.0 binaries based on the VS location, the following tests still fail:

* Microsoft.CodeAnalysis.UnitTests.MSBuildWorkspaceTests.TestCompilationOptions_VisualBasic_OptionStrict_On
* Microsoft.CodeAnalysis.UnitTests.MSBuildWorkspaceTests.TestOpenProject_MetadataReferenceHasDocComments
* Microsoft.CodeAnalysis.UnitTests.MSBuildWorkspaceTests.TestOpenProject_CSharp_WithoutPrefer32BitAndConsoleApplication
* Microsoft.CodeAnalysis.UnitTests.MSBuildWorkspaceTests.TestOpenProject_CSharp_WithPrefer32BitAndConsoleApplication
* Microsoft.CodeAnalysis.UnitTests.MSBuildWorkspaceTests.TestOpenProject_VisualBasic_WithoutPrefer32BitAndConsoleApplication
* Microsoft.CodeAnalysis.UnitTests.MSBuildWorkspaceTests.TestOpenProject_VisualBasic_WithPrefer32BitAndConsoleApplication
* Microsoft.CodeAnalysis.UnitTests.MSBuildWorkspaceTests.TestOpenProject_WithXaml

During at least some of these test runs we're getting an `InvalidProjectFileException` stating that "The "Csc" task could not be initialized with its input parameters". I'm not sure if that is relevant or not.
</Description>
        <CreatedDate>08/11/2016</CreatedDate>
        <ClosedDate>05/04/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>21670</PullRequestID>
      <File>src/Test/Utilities/Portable/Assert/AssertEx.cs</File>
      <File>src/Test/Utilities/Portable/Traits/Traits.cs</File>
      <File>src/Workspaces/Core/Desktop/TypeForwarders.cs</File>
      <File>src/Workspaces/Core/Desktop/Workspace/MSBuild/CSharp/CSharpProjectFileLoader.CSharpProjectFile.cs</File>
      <File>src/Workspaces/Core/Desktop/Workspace/MSBuild/MSBuildProjectLoader.cs</File>
      <File>src/Workspaces/Core/Desktop/Workspace/MSBuild/ProjectFile/ProjectFile.cs</File>
      <File>src/Workspaces/Core/Desktop/Workspace/MSBuild/ProjectFile/ProjectFileInfo.cs</File>
      <File>src/Workspaces/Core/Desktop/Workspace/MSBuild/ProjectFile/ProjectFileLoader.cs</File>
      <File>src/Workspaces/Core/Desktop/Workspace/MSBuild/ProjectFile/ProjectTypeGuidAttribute.cs</File>
      <File>src/Workspaces/Core/Desktop/Workspace/MSBuild/VisualBasic/VisualBasicProjectFileLoader.cs</File>
      <File>src/Workspaces/Core/Desktop/WorkspaceDesktopResources.Designer.cs</File>
      <File>src/Workspaces/Core/MSBuild/Host/Mef/MSBuildMefHostServices.cs</File>
      <File>src/Workspaces/Core/MSBuild/Host/SimpleAnalyzerAssemblyLoaderService.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/Build/ProjectBuildManager.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/CSharp/CSharpCommandLineArgumentReader.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/CSharp/CSharpProjectFile.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/CSharp/CSharpProjectFileLoader.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/CSharp/CSharpProjectFileLoaderFactory.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/Constants/ItemNames.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/Constants/MetadataNames.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/Constants/PropertyNames.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/Constants/PropertyValues.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/Constants/TargetNames.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/DiagnosticReporter.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/DiagnosticReportingMode.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/DiagnosticReportingOptions.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/Logging/DiagnosticLog.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/Logging/DiagnosticLogItem.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/Logging/MSBuildDiagnosticLogItem.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/Logging/MSBuildDiagnosticLogger.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/MSBuildProjectLoader.Worker.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/MSBuildProjectLoader.Worker_ResolveReferences.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/MSBuildProjectLoader.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/MSBuildWorkspace.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/PathResolver.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/ProjectFile/CommandLineArgumentReader.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/ProjectFile/Conversions.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/ProjectFile/DocumentFileInfo.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/ProjectFile/Extensions.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/ProjectFile/IProjectFile.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/ProjectFile/IProjectFileLoader.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/ProjectFile/ProjectFile.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/ProjectFile/ProjectFileExtensionAttribute.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/ProjectFile/ProjectFileInfo.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/ProjectFile/ProjectFileLoader.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/ProjectFile/ProjectFileLoaderRegistry.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/ProjectFile/ProjectFileReference.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/ProjectLoadOperation.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/ProjectLoadProgress.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/ProjectMap.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/VisualBasic/VisualBasicCommandLineArgumentReader.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/VisualBasic/VisualBasicProjectFile.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/VisualBasic/VisualBasicProjectFileLoader.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/VisualBasic/VisualBasicProjectFileLoaderFactory.cs</File>
      <File>src/Workspaces/Core/MSBuild/WorkspaceMSBuildResources.Designer.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/FileTextLoader.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/Host/Metadata/WorkspaceMetadataFileReferenceResolver.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/WorkspaceKind.cs</File>
      <File>src/Workspaces/CoreTest/SolutionTests/SolutionTests.cs</File>
      <File>src/Workspaces/CoreTest/WorkspaceTests/MSBuildWorkspaceTestBase.cs</File>
      <File>src/Workspaces/CoreTest/WorkspaceTests/MSBuildWorkspaceTests.cs</File>
      <File>src/Workspaces/CoreTestUtilities/DotNetHelper.cs</File>
      <File>src/Workspaces/CoreTestUtilities/FileSet.cs</File>
      <File>src/Workspaces/CoreTestUtilities/Resources/NetCoreApp2/Program.cs</File>
      <File>src/Workspaces/CoreTestUtilities/Resources/NetCoreApp2AndLibrary/Class1.cs</File>
      <File>src/Workspaces/CoreTestUtilities/Resources/NetCoreApp2AndLibrary/Program.cs</File>
      <File>src/Workspaces/CoreTestUtilities/Resources/NetCoreApp2AndTwoLibraries/Class1.cs</File>
      <File>src/Workspaces/CoreTestUtilities/Resources/NetCoreApp2AndTwoLibraries/Class2.cs</File>
      <File>src/Workspaces/CoreTestUtilities/Resources/NetCoreApp2AndTwoLibraries/Program.cs</File>
      <File>src/Workspaces/CoreTestUtilities/Resources/NetCoreMultiTFM/Program.cs</File>
      <File>src/Workspaces/CoreTestUtilities/Resources/NetCoreMultiTFM_ProjectReference/Class1.cs</File>
      <File>src/Workspaces/CoreTestUtilities/Resources/NetCoreMultiTFM_ProjectReference/Program.cs</File>
      <File>src/Workspaces/CoreTestUtilities/Resources/NetCoreMultiTFM_ProjectReferenceWithReversedTFMs/Class1.cs</File>
      <File>src/Workspaces/CoreTestUtilities/Resources/NetCoreMultiTFM_ProjectReferenceWithReversedTFMs/Program.cs</File>
      <File>src/Workspaces/CoreTestUtilities/Resources/SourceFiles/CSharp/App.xaml.cs</File>
      <File>src/Workspaces/CoreTestUtilities/Resources/SourceFiles/CSharp/AssemblyInfo.cs</File>
      <File>src/Workspaces/CoreTestUtilities/Resources/SourceFiles/CSharp/CSharpClass.cs</File>
      <File>src/Workspaces/CoreTestUtilities/Resources/SourceFiles/CSharp/CSharpClass_WithConditionalAttributes.cs</File>
      <File>src/Workspaces/CoreTestUtilities/Resources/SourceFiles/CSharp/CSharpConsole.cs</File>
      <File>src/Workspaces/CoreTestUtilities/Resources/SourceFiles/CSharp/CSharpExternAlias.cs</File>
      <File>src/Workspaces/CoreTestUtilities/Resources/SourceFiles/CSharp/MainWindow.xaml.cs</File>
      <File>src/Workspaces/CoreTestUtilities/Resources/SourceFiles/CSharp/OtherStuff_Foo.cs</File>
      <File>src/Workspaces/CoreTestUtilities/SolutionTestUtilities.cs</File>
      <File>src/Workspaces/CoreTestUtilities/TestFiles/Resources.cs</File>
      <File>src/Workspaces/CoreTestUtilities/WorkspaceExtensions.cs</File>
      <File>src/Workspaces/CoreTestUtilities/WorkspaceTestBase.cs</File>
      <File>src/Workspaces/MSBuildTest/Interop.cs</File>
      <File>src/Workspaces/MSBuildTest/MSBuildWorkspaceTestBase.cs</File>
      <File>src/Workspaces/MSBuildTest/MSBuildWorkspaceTests.cs</File>
      <File>src/Workspaces/MSBuildTest/NetCoreTests.cs</File>
      <File>src/Workspaces/MSBuildTest/SolutionGeneration.cs</File>
      <File>src/Workspaces/MSBuildTest/VisualStudioMSBuildInstalled.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>21553</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Use default tuple fields in conversion since fields from inferred names are marked not usable in C#7</Title>
    <Description>**Customer scenario**

Create an unnamed tuple with an implicit conversion to a named tuple in C#7.1 with the default language version (C#7.0). Or use deconstruction assignment where the RHS contains two or more tuple literals with different types and inferred names.

**Bugs this fixes:**

https://github.com/dotnet/roslyn/issues/21028
https://github.com/dotnet/roslyn/issues/21518

**Workarounds, if any**

Rewrite the expression to use explicit conversions or explicit tuple element names.

**Risk**

Low

**Performance impact**

None

**Is this a regression from a previous update?**

Regression from inferred tuple names.

**How was the bug found?**

Customer reported</Description>
    <CreatedDate>16/08/2017</CreatedDate>
    <ClosedDate>19/08/2017</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>21553</PullRequestID>
        <IssueID>7</IssueID>
        <Title>Feature: Parameter Name Aliasing</Title>
        <Description>The human meaning of parameters may vary from method caller's perspective.

It would be useful if the language provides an ability to assign aliases to the parameters.

``` C#
[Alias({second: [secondAndHalf, quarterToThree], first: [Initial]})] 
public static void Member1(string first, string second) { 
  // Here the user will always use the given names: first and second.
  // which means the user cannot use the param by its nickname
  // inside the method scope.
}

private static void Caller1() {
  Member1(secondAndHalf: "secondly, this is not a bad idea after all",
          Initial: "Initially it sounded moot... :)  ");
}

private static void Caller2() {
  Member1(first: "1st",
          quarterToThree: "almost there");
}

private static void Caller3() {
  Member1("one", "two");
}
```

vs. this current approach:

``` c#
public static void Member1(string first, string second) {  }

public static void Member1(string first, string secondAndHalf, string devNull = null) { 
  Member1(first, secondAndHalf);
}
```

Note: the parameter `devNull` may violate [CA1026](http://msdn.microsoft.com/en-us/library/ms182135.aspx), in case of `overridden` methods. On the flip side, setting `devNull` as non-default parameter would yield "unused parameter".

Related / Real world example: https://github.com/madskristensen/WebEssentials2013/pull/380#issuecomment-31402391
</Description>
        <CreatedDate>15/01/2015</CreatedDate>
        <ClosedDate>26/08/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>21553</PullRequestID>
        <IssueID>7</IssueID>
        <Title>Feature: Parameter Name Aliasing</Title>
        <Description>The human meaning of parameters may vary from method caller's perspective.

It would be useful if the language provides an ability to assign aliases to the parameters.

``` C#
[Alias({second: [secondAndHalf, quarterToThree], first: [Initial]})] 
public static void Member1(string first, string second) { 
  // Here the user will always use the given names: first and second.
  // which means the user cannot use the param by its nickname
  // inside the method scope.
}

private static void Caller1() {
  Member1(secondAndHalf: "secondly, this is not a bad idea after all",
          Initial: "Initially it sounded moot... :)  ");
}

private static void Caller2() {
  Member1(first: "1st",
          quarterToThree: "almost there");
}

private static void Caller3() {
  Member1("one", "two");
}
```

vs. this current approach:

``` c#
public static void Member1(string first, string second) {  }

public static void Member1(string first, string secondAndHalf, string devNull = null) { 
  Member1(first, secondAndHalf);
}
```

Note: the parameter `devNull` may violate [CA1026](http://msdn.microsoft.com/en-us/library/ms182135.aspx), in case of `overridden` methods. On the flip side, setting `devNull` as non-default parameter would yield "unused parameter".

Related / Real world example: https://github.com/madskristensen/WebEssentials2013/pull/380#issuecomment-31402391
</Description>
        <CreatedDate>15/01/2015</CreatedDate>
        <ClosedDate>26/08/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>21553</PullRequestID>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_Conversion.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_DeconstructionAssignmentOperator.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_Field.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenDeconstructTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTupleTest.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>20096</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Remove strong reference to AnalyzerOptions in the analyzer manager ex‚Ä¶</Title>
    <Description>‚Ä¶ecution context

Fixes #20065

**Customer scenario**

Performance: We are leaking solution instances in preview workspace (which is created every time we invoke a lightbulb preview). See https://github.com/dotnet/roslyn/issues/20065#issue-234071975 for details.

**Bugs this fixes:**

Fixes #20065 

**Workarounds, if any**

N/A

**Risk**

Low, as we are not changing any functionality here. Instead of having a `Dictionary&lt;AnalyzerOptions, ConditionalWeakTable&lt;Compilation, Task&lt;HostCompilationStartAnalysisScope&gt;&gt;&gt;` with strong reference to AnalyzerOptions, we now use a `ConditionalWeakTable&lt;Compilation, Dictionary&lt;AnalyzerOptions, Task&lt;HostCompilationStartAnalysisScope&gt;&gt;&gt;`, which has a weak reference and will let go AnalyzerOptions instance once the compilation is GC'ed.

**Performance impact**

This should improve performance as we are preventing a leak of solutions in preview workspace.

**Is this a regression from a previous update?**

Yes, we recently refactored the WorkspaceAnalyzerOptions to strongly hold onto the solution snapshot. This was needed to fix an IDE race. This in turn is causing the map in question here to leak these solution instances.

**Root cause analysis:**

We don't have tests to catch and prevent leaks. We are going to further improve the design in this area when we tackle #2830 in 15.6, so we prevent such regressions in future.

**How was the bug found?**

Dogfooding.</Description>
    <CreatedDate>08/06/2017</CreatedDate>
    <ClosedDate>09/06/2017</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>20096</PullRequestID>
        <IssueID>20065</IssueID>
        <Title>Previews for light bulbs leaks solutions</Title>
        <Description>**Version Used**: 400238e370ef760e178dd7a9db790e5feae7f3fb

**Steps to Reproduce**:

1. Create a new console app.
2. Invoke removed unused usings on the top.
3. Wait for the preview to appear.
4. Dismiss the preview.
5. GC.
6. Run !dumpheap -type PreviewWorkspace

**Expected Behavior**: There shouldn't be any.
**Actual Behavior**: There are two, because the solutions created to drive the preview are being leaked. The bad part of the GC root is I believe here:

            -&gt;  27343b70 Microsoft.CodeAnalysis.CSharp.UseCollectionInitializer.CSharpUseCollectionInitializerDiagnosticAnalyzer
            -&gt;  2733fea0 Microsoft.CodeAnalysis.Diagnostics.AnalyzerManager+AnalyzerExecutionContext (dependent handle)
            -&gt;  27381f58 System.Collections.Generic.Dictionary`2[[Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions, Microsoft.CodeAnalysis],[System.Runtime.CompilerServices.ConditionalWeakTable`2[[Microsoft.CodeAnalysis.Compilation, Microsoft.CodeAnalysis],[System.Threading.Tasks.Task`1[[Microsoft.CodeAnalysis.Diagnostics.HostCompilationStartAnalysisScope, Microsoft.CodeAnalysis]], mscorlib]], mscorlib]]
            -&gt;  27382050 System.Collections.Generic.Dictionary`2+Entry[[Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions, Microsoft.CodeAnalysis],[System.Runtime.CompilerServices.ConditionalWeakTable`2[[Microsoft.CodeAnalysis.Compilation, Microsoft.CodeAnalysis],[System.Threading.Tasks.Task`1[[Microsoft.CodeAnalysis.Diagnostics.HostCompilationStartAnalysisScope, Microsoft.CodeAnalysis]], mscorlib]], mscorlib]][]
            -&gt;  27644ef0 Microsoft.CodeAnalysis.Diagnostics.WorkspaceAnalyzerOptions
            -&gt;  275a6700 Microsoft.CodeAnalysis.Solution
</Description>
        <CreatedDate>07/06/2017</CreatedDate>
        <ClosedDate>09/06/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>20096</PullRequestID>
        <IssueID>20065</IssueID>
        <Title>Previews for light bulbs leaks solutions</Title>
        <Description>**Version Used**: 400238e370ef760e178dd7a9db790e5feae7f3fb

**Steps to Reproduce**:

1. Create a new console app.
2. Invoke removed unused usings on the top.
3. Wait for the preview to appear.
4. Dismiss the preview.
5. GC.
6. Run !dumpheap -type PreviewWorkspace

**Expected Behavior**: There shouldn't be any.
**Actual Behavior**: There are two, because the solutions created to drive the preview are being leaked. The bad part of the GC root is I believe here:

            -&gt;  27343b70 Microsoft.CodeAnalysis.CSharp.UseCollectionInitializer.CSharpUseCollectionInitializerDiagnosticAnalyzer
            -&gt;  2733fea0 Microsoft.CodeAnalysis.Diagnostics.AnalyzerManager+AnalyzerExecutionContext (dependent handle)
            -&gt;  27381f58 System.Collections.Generic.Dictionary`2[[Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions, Microsoft.CodeAnalysis],[System.Runtime.CompilerServices.ConditionalWeakTable`2[[Microsoft.CodeAnalysis.Compilation, Microsoft.CodeAnalysis],[System.Threading.Tasks.Task`1[[Microsoft.CodeAnalysis.Diagnostics.HostCompilationStartAnalysisScope, Microsoft.CodeAnalysis]], mscorlib]], mscorlib]]
            -&gt;  27382050 System.Collections.Generic.Dictionary`2+Entry[[Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions, Microsoft.CodeAnalysis],[System.Runtime.CompilerServices.ConditionalWeakTable`2[[Microsoft.CodeAnalysis.Compilation, Microsoft.CodeAnalysis],[System.Threading.Tasks.Task`1[[Microsoft.CodeAnalysis.Diagnostics.HostCompilationStartAnalysisScope, Microsoft.CodeAnalysis]], mscorlib]], mscorlib]][]
            -&gt;  27644ef0 Microsoft.CodeAnalysis.Diagnostics.WorkspaceAnalyzerOptions
            -&gt;  275a6700 Microsoft.CodeAnalysis.Solution
</Description>
        <CreatedDate>07/06/2017</CreatedDate>
        <ClosedDate>09/06/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>20096</PullRequestID>
        <IssueID>2830</IssueID>
        <Title>Make AnalyzerManager public and remove its static instance for analyzer state management</Title>
        <Description>AnalyzerManager has been a source of many recent memory leaks due to it holding onto analyzer state longer than required. The primary reason for this is that currently this type is internal and cannot be exposed publically until we can move the IDE analyzer driver to be completely based of public APIs from CodeAnalysis layer.

AnalyzerManager lies in the shared AnalyzerDriver project used between Features and CodeAnalysis projects and is based upon many internal types. 
Making AnalyzerManager public will allow public analyzer hosts (such as IDE diagnostic service and consumers of CompilationWithAnalyzers) to explicitly control the lifetime of the analyzer state manager. This is essential as only the host knows the lifetime of the analyzer instances it is based upon, and hence can dispose of analyzer state manager instance when it is done with all analyzer execution. This will prevent inadvertent memory leaks of analyzer state in hosts that don't clear the state as they are either unaware that they must do so OR they dont know when they should be doing it.

Once @JohnHamby finishes his refactoring work to migrate the IDE analyzer driver to be completely based of public APIs from CodeAnalysis layer, we should make AnalyzerManager public (and also probably rename it to AnalyzerStateManager), remove its static instance and require the host to explicit handle its lifetime.
</Description>
        <CreatedDate>16/05/2015</CreatedDate>
        <ClosedDate>14/06/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>20096</PullRequestID>
      <File>src/Compilers/Core/Portable/DiagnosticAnalyzer/AnalyzerManager.AnalyzerExecutionContext.cs</File>
      <File>src/Compilers/Core/Portable/DiagnosticAnalyzer/AnalyzerManager.cs</File>
      <File>src/EditorFeatures/Test/Preview/PreviewWorkspaceTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>20004</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Better exclude local functions from region analysis</Title>
    <Description>By design, when data flow analyzes local functions it does so devoid of
surrounding context and records possibly unassigned variables rather
than reporting a diagnostic. Thus, all captured variables are expected
to be marked unassigned during data flow analysis without reporting a
diagnostic.

However, reporting a diagnostic is not the only side effect of running
data flow analysis. By calling virtual methods data flow analysis
informs derived types of unassigned variables. While the diagnostic is
suppressed and recorded, currently the virtual method is still called.
This has negative consequences for region analysis, which considers
these calls as indications of variables flowing out of the given
region, which may not be the case for local functions.

This PR changes data flow analysis to only call the ReportUnassigned
virtual method if not inside a local function, excluding local functions
from all unassignment reporting.

Fixes #17165, #18347

**Customer scenario**

Extract method crashes when analyzing code that contains variables captured by
local functions.

**Bugs this fixes:**

Fixes #17165, #18347

**Workarounds, if any**

Don't ask for refactorings around these variables.

**Risk**

This is a code change to data flow analysis and could affect definite assignment for local functions,
but is mostly focused around code flow to region analysis, which is only used by extract method.

**Performance impact**

Low. No extra allocations, minimal extra logic.

**Is this a regression from a previous update?**

No.

**Root cause analysis:**

Local functions were a new feature in C# 7 and there are known issues around region analysis.

**How was the bug found?**

Customer reported.</Description>
    <CreatedDate>04/06/2017</CreatedDate>
    <ClosedDate>15/06/2017</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>20004</PullRequestID>
        <IssueID>17165</IssueID>
        <Title>ExtractMethodMatrix.GetVariableStyle Throws exception on code with errors</Title>
        <Description>**Version Used**: 
![image](https://cloud.githubusercontent.com/assets/9797472/22995888/8293500a-f381-11e6-923e-4d241adef2f9.png)

**Steps to Reproduce**:

1.  Use Alt+Arrow to move members into lambda that is an argument into a method that is missing semicolon

**Expected Behavior**:
No Crash

**Actual Behavior**:
```
System.InvalidOperationException : Unexpected false
   at Roslyn.Utilities.Contract.ThrowIfFalse(Boolean condition,String message)
   at Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodMatrix.GetVariableStyle(Boolean captured,Boolean dataFlowIn,Boolean dataFlowOut,Boolean alwaysAssigned,Boolean variableDeclared,Boolean readInside,Boolean writtenInside,Boolean readOutside,Boolean writtenOutside,Boolean unsafeAddressTaken)
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GetVariableStyle(Dictionary`2 symbolMap,ISymbol symbol,SemanticModel model,ITypeSymbol type,Boolean captured,Boolean dataFlowIn,Boolean dataFlowOut,Boolean alwaysAssigned,Boolean variableDeclared,Boolean readInside,Boolean writtenInside,Boolean readOutside,Boolean writtenOutside,Boolean unsafeAddressTaken)
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GenerateVariableInfoMap(SemanticModel model,DataFlowAnalysis dataFlowAnalysisData,Dictionary`2 symbolMap)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.AnalyzeAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.ExtractMethodAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.ExtractMethodAsync[TValidator,TExtractor,TResult](&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.GetCodeActionAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.ComputeRefactoringsAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringService.GetRefactoringFromProviderAsync(&lt;Unknown Parameters&gt;)
   at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject)
```

Also reported at https://developercommunity.visualstudio.com/content/problem/14869/extractmethodcoderefactoringprovider-encountered-a.html</Description>
        <CreatedDate>15/02/2017</CreatedDate>
        <ClosedDate>15/06/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>20004</PullRequestID>
        <IssueID>18347</IssueID>
        <Title>ExtractMethodCodeRefactoringProvider crashes on selecting a line that references an argument captured by a local method</Title>
        <Description>**Version Used**: 

Microsoft Visual Studio Community 2017
Version 15.0.26228.9

**Steps to Reproduce**:

```csharp
namespace ExtractMethodCrashRepro
{
	public static class SomeClass
	{
		private static void Repro( int arg )
		{
			int localValue = arg;

			int LocalCapture() =&gt; arg;
		}
	}
}
```

Select the line `int localValue = arg;`

**Expected Behavior**:
A lightbulb with available refactorings should appear.

**Actual Behavior**:
`ExtractMethodCodeRefactoringProvider` crashes with the following stack trace:

```
System.InvalidOperationException : Unexpected false
   at Roslyn.Utilities.Contract.ThrowIfFalse(Boolean condition,String message)
   at Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodMatrix.GetVariableStyle(Boolean captured,Boolean dataFlowIn,Boolean dataFlowOut,Boolean alwaysAssigned,Boolean variableDeclared,Boolean readInside,Boolean writtenInside,Boolean readOutside,Boolean writtenOutside,Boolean unsafeAddressTaken)
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GetVariableStyle(Dictionary`2 symbolMap,ISymbol symbol,SemanticModel model,ITypeSymbol type,Boolean captured,Boolean dataFlowIn,Boolean dataFlowOut,Boolean alwaysAssigned,Boolean variableDeclared,Boolean readInside,Boolean writtenInside,Boolean readOutside,Boolean writtenOutside,Boolean unsafeAddressTaken)
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GenerateVariableInfoMap(SemanticModel model,DataFlowAnalysis dataFlowAnalysisData,Dictionary`2 symbolMap)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.AnalyzeAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.ExtractMethodAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.ExtractMethodAsync[TValidator,TExtractor,TResult](&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.GetCodeActionAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.ComputeRefactoringsAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringService.GetRefactoringFromProviderAsync(&lt;Unknown Parameters&gt;)
   at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject)
```</Description>
        <CreatedDate>31/03/2017</CreatedDate>
        <ClosedDate>31/03/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>20004</PullRequestID>
        <IssueID>17165</IssueID>
        <Title>ExtractMethodMatrix.GetVariableStyle Throws exception on code with errors</Title>
        <Description>**Version Used**: 
![image](https://cloud.githubusercontent.com/assets/9797472/22995888/8293500a-f381-11e6-923e-4d241adef2f9.png)

**Steps to Reproduce**:

1.  Use Alt+Arrow to move members into lambda that is an argument into a method that is missing semicolon

**Expected Behavior**:
No Crash

**Actual Behavior**:
```
System.InvalidOperationException : Unexpected false
   at Roslyn.Utilities.Contract.ThrowIfFalse(Boolean condition,String message)
   at Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodMatrix.GetVariableStyle(Boolean captured,Boolean dataFlowIn,Boolean dataFlowOut,Boolean alwaysAssigned,Boolean variableDeclared,Boolean readInside,Boolean writtenInside,Boolean readOutside,Boolean writtenOutside,Boolean unsafeAddressTaken)
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GetVariableStyle(Dictionary`2 symbolMap,ISymbol symbol,SemanticModel model,ITypeSymbol type,Boolean captured,Boolean dataFlowIn,Boolean dataFlowOut,Boolean alwaysAssigned,Boolean variableDeclared,Boolean readInside,Boolean writtenInside,Boolean readOutside,Boolean writtenOutside,Boolean unsafeAddressTaken)
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GenerateVariableInfoMap(SemanticModel model,DataFlowAnalysis dataFlowAnalysisData,Dictionary`2 symbolMap)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.AnalyzeAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.ExtractMethodAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.ExtractMethodAsync[TValidator,TExtractor,TResult](&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.GetCodeActionAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.ComputeRefactoringsAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringService.GetRefactoringFromProviderAsync(&lt;Unknown Parameters&gt;)
   at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject)
```

Also reported at https://developercommunity.visualstudio.com/content/problem/14869/extractmethodcoderefactoringprovider-encountered-a.html</Description>
        <CreatedDate>15/02/2017</CreatedDate>
        <ClosedDate>15/06/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>20004</PullRequestID>
        <IssueID>18347</IssueID>
        <Title>ExtractMethodCodeRefactoringProvider crashes on selecting a line that references an argument captured by a local method</Title>
        <Description>**Version Used**: 

Microsoft Visual Studio Community 2017
Version 15.0.26228.9

**Steps to Reproduce**:

```csharp
namespace ExtractMethodCrashRepro
{
	public static class SomeClass
	{
		private static void Repro( int arg )
		{
			int localValue = arg;

			int LocalCapture() =&gt; arg;
		}
	}
}
```

Select the line `int localValue = arg;`

**Expected Behavior**:
A lightbulb with available refactorings should appear.

**Actual Behavior**:
`ExtractMethodCodeRefactoringProvider` crashes with the following stack trace:

```
System.InvalidOperationException : Unexpected false
   at Roslyn.Utilities.Contract.ThrowIfFalse(Boolean condition,String message)
   at Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodMatrix.GetVariableStyle(Boolean captured,Boolean dataFlowIn,Boolean dataFlowOut,Boolean alwaysAssigned,Boolean variableDeclared,Boolean readInside,Boolean writtenInside,Boolean readOutside,Boolean writtenOutside,Boolean unsafeAddressTaken)
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GetVariableStyle(Dictionary`2 symbolMap,ISymbol symbol,SemanticModel model,ITypeSymbol type,Boolean captured,Boolean dataFlowIn,Boolean dataFlowOut,Boolean alwaysAssigned,Boolean variableDeclared,Boolean readInside,Boolean writtenInside,Boolean readOutside,Boolean writtenOutside,Boolean unsafeAddressTaken)
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GenerateVariableInfoMap(SemanticModel model,DataFlowAnalysis dataFlowAnalysisData,Dictionary`2 symbolMap)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.AnalyzeAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.ExtractMethodAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.ExtractMethodAsync[TValidator,TExtractor,TResult](&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.GetCodeActionAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.ComputeRefactoringsAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringService.GetRefactoringFromProviderAsync(&lt;Unknown Parameters&gt;)
   at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject)
```</Description>
        <CreatedDate>31/03/2017</CreatedDate>
        <ClosedDate>31/03/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>20004</PullRequestID>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/DataFlowPass.LocalFunctions.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/DataFlowPass.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/DataFlowsInWalker.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/DataFlowsOutWalker.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/UnassignedAddressTakenVariablesWalker.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/UnassignedVariablesWalker.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/StateMachineRewriter/IteratorAndAsyncCaptureWalker.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTupleTest.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/FlowAnalysis/LocalFunctions.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/FlowAnalysis/RegionAnalysisTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/FlowAnalysis/StructTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/ExtractMethod/ExtractMethodTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>19945</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Fix Extract Method operations within an event accessor</Title>
    <Description>Fixes #17474
Closes #19136

## Ask Mode

**Customer scenario**

Uses the light bulb while a selection is present in certain code. A non-fatal exception occurs in the Extract Method refactoring and the gold bar appears.

**Bugs this fixes:**

Fixes #17474
Closes #19136 (the behavior is sub-optimal, but a proper solution can wait for #19958) 

**Workarounds, if any**

None

**Risk**

Low. The changed code paths only affect the failing scenario.

**Performance impact**

This change should not have any impact on performance.

**Is this a regression from a previous update?**

No.

**Root cause analysis:**

* Failure to test all code constructs
* Failure to account for erroneous code in testing

**How was the bug found?**

Internal customer report
</Description>
    <CreatedDate>01/06/2017</CreatedDate>
    <ClosedDate>02/06/2017</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>19945</PullRequestID>
        <IssueID>17474</IssueID>
        <Title>InvalidCastException at Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpSelectionResult.StatementResult.GetContainingScopeType</Title>
        <Description>**Version Used**: 
D15Rel 26226.0

**Steps to Reproduce**:
1. Restore, build and open Roslyn.sln
2. Open source file: `\src\EditorFeatures\Core\Implementation\Classification\SemanticClassificationBufferTaggerProvider.Tagger.cs` and enter the following code at end of the file:
  ```
namespace NewTaggerNamespace
{
    internal partial class NewTagger : IAccurateTagger&lt;IClassificationTag&gt;
    {
        public event EventHandler&lt;SnapshotSpanEventArgs&gt; TagsChanged;

        event EventHandler&lt;SnapshotSpanEventArgs&gt; ITagger&lt;IClassificationTag&gt;.TagsChanged
        {
            add
            {
                throw new NotImplementedException();
            }

            remove
            {
                throw new NotImplementedException();
            }
        }

        public IEnumerable&lt;ITagSpan&lt;IClassificationTag&gt;&gt; GetAllTags(NormalizedSnapshotSpanCollection spans, CancellationToken cancel)
        {
            throw new NotImplementedException();
        }

        IEnumerable&lt;ITagSpan&lt;IClassificationTag&gt;&gt; ITagger&lt;IClassificationTag&gt;.GetTags(NormalizedSnapshotSpanCollection spans)
        {
            throw new NotImplementedException();
        }
    }
}
  ```
3. Select text `throw new NotImplementedException();` in the add or remove handler.

Got the following exception in the info bar:

```
System.InvalidCastException : Unable to cast object of type 'Microsoft.CodeAnalysis.CSharp.Symbols.SourceCustomEventSymbol' to type 'Microsoft.CodeAnalysis.IPropertySymbol'.
   at Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpSelectionResult.StatementResult.GetContainingScopeType()
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.CodeGenerator`3.AddReturnIfUnreachable(IEnumerable`1 statements,CancellationToken cancellationToken)
   at async Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpMethodExtractor.CSharpCodeGenerator.CreateStatementsOrInitializerToInsertAtCallSiteAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpMethodExtractor.CSharpCodeGenerator.GenerateBodyForCallSiteContainerAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.CodeGenerator`3.GenerateAsync[TStatement,TExpression,TNodeUnderContainer](&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.ExtractMethodAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.ExtractMethodAsync[TValidator,TExtractor,TResult](&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.GetCodeActionAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.ComputeRefactoringsAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringService.GetRefactoringFromProviderAsync(&lt;Unknown Parameters&gt;)
   at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject)
```
</Description>
        <CreatedDate>28/02/2017</CreatedDate>
        <ClosedDate>02/06/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>19945</PullRequestID>
        <IssueID>19136</IssueID>
        <Title>ExtractMethodCodeRefactoringProvider crashed with InvalidOperationException</Title>
        <Description>VS Build: 26426.1 VSUWPT

Note same code that crashed: https://github.com/dotnet/roslyn/issues/19135.

``` C#
// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.

using System;
using Microsoft.VisualStudio.ProjectSystem.VS;

namespace Microsoft.VisualStudio.Shell.Interop
{
    internal static class IVsOutputWindowExtensions
    {
        public static void ActivatePane(this IVsOutputWindow outputWindow, Guid pane)
        {
            Requires.NotNull(outputWindow, nameof(outputWindow));
            Requires.NotEmpty(pane, nameof(pane));

            HResult hr = outputWindow.GetPane(ref $pane$, out IVsOutputWindowPane pane);
            if (!hr.IsOK) // Pane not found
                return;

            hr = pane.Activate();
            if (hr.Failed)
                throw hr.Exception;
        }
    }
}
```


```
System.InvalidOperationException : Unexpected false
   at Roslyn.Utilities.Contract.ThrowIfFalse(Boolean condition,String message)
   at Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodMatrix.GetVariableStyle(Boolean captured,Boolean dataFlowIn,Boolean dataFlowOut,Boolean alwaysAssigned,Boolean variableDeclared,Boolean readInside,Boolean writtenInside,Boolean readOutside,Boolean writtenOutside,Boolean unsafeAddressTaken)
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GetVariableStyle(Dictionary`2 symbolMap,ISymbol symbol,SemanticModel model,ITypeSymbol type,Boolean captured,Boolean dataFlowIn,Boolean dataFlowOut,Boolean alwaysAssigned,Boolean variableDeclared,Boolean readInside,Boolean writtenInside,Boolean readOutside,Boolean writtenOutside,Boolean unsafeAddressTaken)
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GenerateVariableInfoMap(SemanticModel model,DataFlowAnalysis dataFlowAnalysisData,Dictionary`2 symbolMap)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.AnalyzeAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.ExtractMethodAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.ExtractMethodAsync[TValidator,TExtractor,TResult](&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.GetCodeActionAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.ComputeRefactoringsAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringService.GetRefactoringFromProviderAsync(&lt;Unknown Parameters&gt;)
   at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject)
```</Description>
        <CreatedDate>01/05/2017</CreatedDate>
        <ClosedDate>02/06/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>19945</PullRequestID>
        <IssueID>17474</IssueID>
        <Title>InvalidCastException at Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpSelectionResult.StatementResult.GetContainingScopeType</Title>
        <Description>**Version Used**: 
D15Rel 26226.0

**Steps to Reproduce**:
1. Restore, build and open Roslyn.sln
2. Open source file: `\src\EditorFeatures\Core\Implementation\Classification\SemanticClassificationBufferTaggerProvider.Tagger.cs` and enter the following code at end of the file:
  ```
namespace NewTaggerNamespace
{
    internal partial class NewTagger : IAccurateTagger&lt;IClassificationTag&gt;
    {
        public event EventHandler&lt;SnapshotSpanEventArgs&gt; TagsChanged;

        event EventHandler&lt;SnapshotSpanEventArgs&gt; ITagger&lt;IClassificationTag&gt;.TagsChanged
        {
            add
            {
                throw new NotImplementedException();
            }

            remove
            {
                throw new NotImplementedException();
            }
        }

        public IEnumerable&lt;ITagSpan&lt;IClassificationTag&gt;&gt; GetAllTags(NormalizedSnapshotSpanCollection spans, CancellationToken cancel)
        {
            throw new NotImplementedException();
        }

        IEnumerable&lt;ITagSpan&lt;IClassificationTag&gt;&gt; ITagger&lt;IClassificationTag&gt;.GetTags(NormalizedSnapshotSpanCollection spans)
        {
            throw new NotImplementedException();
        }
    }
}
  ```
3. Select text `throw new NotImplementedException();` in the add or remove handler.

Got the following exception in the info bar:

```
System.InvalidCastException : Unable to cast object of type 'Microsoft.CodeAnalysis.CSharp.Symbols.SourceCustomEventSymbol' to type 'Microsoft.CodeAnalysis.IPropertySymbol'.
   at Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpSelectionResult.StatementResult.GetContainingScopeType()
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.CodeGenerator`3.AddReturnIfUnreachable(IEnumerable`1 statements,CancellationToken cancellationToken)
   at async Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpMethodExtractor.CSharpCodeGenerator.CreateStatementsOrInitializerToInsertAtCallSiteAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpMethodExtractor.CSharpCodeGenerator.GenerateBodyForCallSiteContainerAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.CodeGenerator`3.GenerateAsync[TStatement,TExpression,TNodeUnderContainer](&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.ExtractMethodAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.ExtractMethodAsync[TValidator,TExtractor,TResult](&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.GetCodeActionAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.ComputeRefactoringsAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringService.GetRefactoringFromProviderAsync(&lt;Unknown Parameters&gt;)
   at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject)
```
</Description>
        <CreatedDate>28/02/2017</CreatedDate>
        <ClosedDate>02/06/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>19945</PullRequestID>
        <IssueID>19136</IssueID>
        <Title>ExtractMethodCodeRefactoringProvider crashed with InvalidOperationException</Title>
        <Description>VS Build: 26426.1 VSUWPT

Note same code that crashed: https://github.com/dotnet/roslyn/issues/19135.

``` C#
// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.

using System;
using Microsoft.VisualStudio.ProjectSystem.VS;

namespace Microsoft.VisualStudio.Shell.Interop
{
    internal static class IVsOutputWindowExtensions
    {
        public static void ActivatePane(this IVsOutputWindow outputWindow, Guid pane)
        {
            Requires.NotNull(outputWindow, nameof(outputWindow));
            Requires.NotEmpty(pane, nameof(pane));

            HResult hr = outputWindow.GetPane(ref $pane$, out IVsOutputWindowPane pane);
            if (!hr.IsOK) // Pane not found
                return;

            hr = pane.Activate();
            if (hr.Failed)
                throw hr.Exception;
        }
    }
}
```


```
System.InvalidOperationException : Unexpected false
   at Roslyn.Utilities.Contract.ThrowIfFalse(Boolean condition,String message)
   at Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodMatrix.GetVariableStyle(Boolean captured,Boolean dataFlowIn,Boolean dataFlowOut,Boolean alwaysAssigned,Boolean variableDeclared,Boolean readInside,Boolean writtenInside,Boolean readOutside,Boolean writtenOutside,Boolean unsafeAddressTaken)
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GetVariableStyle(Dictionary`2 symbolMap,ISymbol symbol,SemanticModel model,ITypeSymbol type,Boolean captured,Boolean dataFlowIn,Boolean dataFlowOut,Boolean alwaysAssigned,Boolean variableDeclared,Boolean readInside,Boolean writtenInside,Boolean readOutside,Boolean writtenOutside,Boolean unsafeAddressTaken)
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GenerateVariableInfoMap(SemanticModel model,DataFlowAnalysis dataFlowAnalysisData,Dictionary`2 symbolMap)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.AnalyzeAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.ExtractMethodAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.ExtractMethodAsync[TValidator,TExtractor,TResult](&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.GetCodeActionAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.ComputeRefactoringsAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringService.GetRefactoringFromProviderAsync(&lt;Unknown Parameters&gt;)
   at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject)
```</Description>
        <CreatedDate>01/05/2017</CreatedDate>
        <ClosedDate>02/06/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>19945</PullRequestID>
        <IssueID>19958</IssueID>
        <Title>Extract method does not support by-ref pass-through</Title>
        <Description>**Version Used**: 15.3

This is an extension of #19136.

**Steps to Reproduce**:

Attempt to use the Extract Method refactoring on the following code:

```csharp
public static int OtherMethod(ref int x)
    =&gt; x;

public static void Method(ref int x)
    =&gt; Console.WriteLine(OtherMethod(ref $x$));
```

**Expected Behavior**:

```csharp
public static int OtherMethod(ref int x)
    =&gt; x;

public static void Method(ref int x)
    =&gt; Console.WriteLine(OtherMethod(ref NewMethod(ref x)));

public static ref int NewMethod(ref int x)
{
    return ref x;
}
```

**Actual Behavior**:

```csharp
public static int OtherMethod(ref int x)
    =&gt; x;

public static void Method(ref int x)
    =&gt; Console.WriteLine(NewMethod(ref x));

public static int NewMethod(ref int x)
{
    return OtherMethod(ref x);
}
```
</Description>
        <CreatedDate>01/06/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>19945</PullRequestID>
      <File>src/EditorFeatures/CSharpTest/ExtractMethod/ExtractMethodTests.cs</File>
      <File>src/Features/CSharp/Portable/ExtractMethod/CSharpSelectionResult.StatementResult.cs</File>
      <File>src/Features/Core/Portable/ExtractMethod/ExtractMethodMatrix.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>19919</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Pass a project when creating an invisible editor</Title>
    <Description>This change substantially reduces the amount of work required to locate a document within the solution (file path to hierarchy+itemid).

* Time to apply Fix All from #19895: 2:45 mins
* Time to apply Fix All after this change: 1:32 mins

## Ask Mode

**Customer scenario**

A customer applies a Fix All operation which affects many files in a large solution. (Not specific to any particular code fix.)

**Bugs this fixes:**

Derived from #19900 as the safe option for 15.3 (provides some but not all possible benefits).

**Workarounds, if any**

Wait longer.

**Risk**

Low. This feature adds a hint for a lookup, but valid information is not required in order for the underlying operation to succeed (falls back to slow case when information is not available).

**Performance impact**

This is a substantial performance improvement for Fix All operations.

**Is this a regression from a previous update?**

No.

**Root cause analysis:**

No performance tests covering large-scale operations (yet).

**How was the bug found?**

Internal testing.</Description>
    <CreatedDate>31/05/2017</CreatedDate>
    <ClosedDate>01/06/2017</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>19919</PullRequestID>
        <IssueID>19895</IssueID>
        <Title>Avoid re-verifying semantics of nodes that cannot influence each other</Title>
        <Description>I verified that the applied results on Roslyn.sln are identical before and after this change.

Time to fix all "Use default expression" in Roslyn.sln:

| Implementation | Time to open preview | Time to apply changes |
| --- | --- | --- |
| master branch (05480ee495766eaa198ec3d207867fad5adcc655) | 2:18 min | 2:52 min |
| This branch | 1:35 min | 2:43 min |

:bulb: I filed #19900 to address the time to apply changes.

## Ask Mode

**Customer scenario**

Apply the new **Use Default Literal** code fix to a codebase containing a large number of default expressions.

**Bugs this fixes:**

Closes #19817.

**Workarounds, if any**

Wait longer.

**Risk**

This is much lower risk than a implementation of #19817 as originally described would be, for both correctness and maintainability. This optimization leverages the following language aspects:

1. It assumes that the analyzer only reports diagnostics for cases where a conversion from `default(T)`&amp;rarr;`default` *in isolation* would not change the inferred type of the expression.
2. It assumes that all inference operations (type inference, overload resolution) cannot impact each other across certain boundaries, specifically the following:
    * Parameters
    * Statements
    * Variable declarators
    * Files

**Performance impact**

This change substantially improves performance of code helping users migrate to a specific new feature of C# 7.1.

**Is this a regression from a previous update?**

No.

**Root cause analysis:**

We were aware of the performance limitations and originally opted for the safest path forward. Follow-up investigation revealed an area of low-hanging fruit with relatively low risk.

**How was the bug found?**

Internal dogfooding.</Description>
        <CreatedDate>31/05/2017</CreatedDate>
        <ClosedDate>31/05/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>19919</PullRequestID>
        <IssueID>19900</IssueID>
        <Title>Avoid opening invisible editors for applying changes during Fix All</Title>
        <Description>**Version Used**: 15.3 preview 1

**Steps to Reproduce**:

1. Open a large solution (e.g. dotnet/roslyn@05480ee4)
2. Close all open documents except one that can be used to trigger a Fix All operation
3. Apply a Fix All operation that affects a large number of files (e.g. Use Default Literal)

**Expected Behavior**:

The Fix All application (the time it takes *after* hitting Apply on the preview window) completes in the amount of time it takes to save the affected files to disk.

**Actual Behavior**:

The Fix All application takes minutes.

**Notes**:

The dominant costs for this operation ***overwhelmingly*** stem from [opening an invisible editor](https://github.com/dotnet/roslyn/blob/master/src/VisualStudio/Core/Def/Implementation/ProjectSystem/DocumentProvider.StandardTextDocument.cs#L217) for the code fix application rather than operating at a lower level.

During an application of the Use Default Literal code fix for testing #19895, the invisible editor was responsible for 13+GiB of avoidable overhead on the garbage collector in devenv.exe (i.e. overhead unrelated to the actual application of the code fix). Substantial additional time was spent during marshalling for a large number of COM/CLR transitions in various places.</Description>
        <CreatedDate>31/05/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>19919</PullRequestID>
      <File>src/VisualStudio/Core/Def/Implementation/FindReferences/VisualStudioDefinitionsAndReferencesFactory.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/InvisibleEditor.cs</File>
      <File>src/VisualStudio/Core/Impl/CodeModel/TextManagerAdapter.cs</File>
      <File>src/VisualStudio/Core/Impl/RoslynVisualStudioWorkspace.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>19895</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Avoid re-verifying semantics of nodes that cannot influence each other</Title>
    <Description>I verified that the applied results on Roslyn.sln are identical before and after this change.

Time to fix all "Use default expression" in Roslyn.sln:

| Implementation | Time to open preview | Time to apply changes |
| --- | --- | --- |
| master branch (05480ee495766eaa198ec3d207867fad5adcc655) | 2:18 min | 2:52 min |
| This branch | 1:35 min | 2:43 min |

:bulb: I filed #19900 to address the time to apply changes.

## Ask Mode

**Customer scenario**

Apply the new **Use Default Literal** code fix to a codebase containing a large number of default expressions.

**Bugs this fixes:**

Closes #19817.

**Workarounds, if any**

Wait longer.

**Risk**

This is much lower risk than a implementation of #19817 as originally described would be, for both correctness and maintainability. This optimization leverages the following language aspects:

1. It assumes that the analyzer only reports diagnostics for cases where a conversion from `default(T)`&amp;rarr;`default` *in isolation* would not change the inferred type of the expression.
2. It assumes that all inference operations (type inference, overload resolution) cannot impact each other across certain boundaries, specifically the following:
    * Parameters
    * Statements
    * Variable declarators
    * Files

**Performance impact**

This change substantially improves performance of code helping users migrate to a specific new feature of C# 7.1.

**Is this a regression from a previous update?**

No.

**Root cause analysis:**

We were aware of the performance limitations and originally opted for the safest path forward. Follow-up investigation revealed an area of low-hanging fruit with relatively low risk.

**How was the bug found?**

Internal dogfooding.</Description>
    <CreatedDate>31/05/2017</CreatedDate>
    <ClosedDate>31/05/2017</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>19895</PullRequestID>
        <IssueID>19900</IssueID>
        <Title>Avoid opening invisible editors for applying changes during Fix All</Title>
        <Description>**Version Used**: 15.3 preview 1

**Steps to Reproduce**:

1. Open a large solution (e.g. dotnet/roslyn@05480ee4)
2. Close all open documents except one that can be used to trigger a Fix All operation
3. Apply a Fix All operation that affects a large number of files (e.g. Use Default Literal)

**Expected Behavior**:

The Fix All application (the time it takes *after* hitting Apply on the preview window) completes in the amount of time it takes to save the affected files to disk.

**Actual Behavior**:

The Fix All application takes minutes.

**Notes**:

The dominant costs for this operation ***overwhelmingly*** stem from [opening an invisible editor](https://github.com/dotnet/roslyn/blob/master/src/VisualStudio/Core/Def/Implementation/ProjectSystem/DocumentProvider.StandardTextDocument.cs#L217) for the code fix application rather than operating at a lower level.

During an application of the Use Default Literal code fix for testing #19895, the invisible editor was responsible for 13+GiB of avoidable overhead on the garbage collector in devenv.exe (i.e. overhead unrelated to the actual application of the code fix). Substantial additional time was spent during marshalling for a large number of COM/CLR transitions in various places.</Description>
        <CreatedDate>31/05/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>19895</PullRequestID>
        <IssueID>19817</IssueID>
        <Title>Fast-path additional cases in Use Default Literal analysis</Title>
        <Description>**Version Used**: 05480ee495766eaa198ec3d207867fad5adcc655

* Return statements, e.g. `return default(T);` from a method or local function which has a return value of type `T`
* Assignment expressions, where the right hand side is `default(T)` and the left hand side is an lvalue of type `T`
* `new[] { default(T), a... }` where one or more elements `a...` exist all have type `T`, and the expression evaluates to type `T[]`
* `new T[] { default(T) }` for any type `T`
* `[expression] ?? default(T)`, where [expression] evaluates to type `T?`
</Description>
        <CreatedDate>26/05/2017</CreatedDate>
        <ClosedDate>31/05/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>19895</PullRequestID>
        <IssueID>19817</IssueID>
        <Title>Fast-path additional cases in Use Default Literal analysis</Title>
        <Description>**Version Used**: 05480ee495766eaa198ec3d207867fad5adcc655

* Return statements, e.g. `return default(T);` from a method or local function which has a return value of type `T`
* Assignment expressions, where the right hand side is `default(T)` and the left hand side is an lvalue of type `T`
* `new[] { default(T), a... }` where one or more elements `a...` exist all have type `T`, and the expression evaluates to type `T[]`
* `new T[] { default(T) }` for any type `T`
* `[expression] ?? default(T)`, where [expression] evaluates to type `T?`
</Description>
        <CreatedDate>26/05/2017</CreatedDate>
        <ClosedDate>31/05/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>19895</PullRequestID>
      <File>src/Features/CSharp/Portable/UseDefaultLiteral/CSharpUseDefaultLiteralCodeFixProvider.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>18662</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>SemanticModel should cache synthesized bound statements in a separate cache in order to avoid ‚Äúpolluting‚Äù the regular cache.</Title>
    <Description>Fixes #10604.
Fixes #16306.

@dotnet/roslyn-compiler Please review.</Description>
    <CreatedDate>13/04/2017</CreatedDate>
    <ClosedDate>15/04/2017</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>18662</PullRequestID>
        <IssueID>10604</IssueID>
        <Title>Need to confirm how extra compiler generated blocks affect caching</Title>
        <Description>@AlekseyTs You added the following PROTOTYPE comment, but I'm not sure exactly what it means. Please rewrite this issue to describe it.

``` cs
            /// &lt;summary&gt;
            /// Decides whether to the add the bound node to the cache or not.
            /// &lt;/summary&gt;
            /// &lt;param name="currentBoundNode"&gt;The bound node.&lt;/param&gt;
            private bool ShouldAddNode(BoundNode currentBoundNode)
            {
                BoundBlock block;

                // PROTOTYPE(patterns): Need to confirm how extra compiler generated blocks affect caching.
                //                      Do we actually benefit from adding them to the cache, or effect is negative or neutral.

```
</Description>
        <CreatedDate>15/04/2016</CreatedDate>
        <ClosedDate>15/04/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>18662</PullRequestID>
        <IssueID>16306</IssueID>
        <Title>Inline Declaration refactoring on out parameter crashes IDE</Title>
        <Description>Start with the following code:

```c#
using System;
using System.Collections.Generic;

class C
{
    void Foo()
    {
        int rowCountMember;
        var item = "";
        int rowCount;
        foreach (var row in function1(item, out rowCount))
        {
            function2(row);
        }

        rowCountMember = rowCount;
    }

    private IEnumerable&lt;object&gt; function1(string item, out int rowCount)
    {
        throw new NotImplementedException();
    }

    private void function2(object row)
    {
        throw new NotImplementedException();
    }
}
```

Try to invoke 'inline declaration' on ```int rowCount```.  This crashes the IDE with this callstack:

```
&gt;	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetForEachStatementInfo(Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax node) Line 776	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetForEachStatementInfo(Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax node) Line 2117	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetForEachStatementInfo(Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax forEachStatement) Line 720	C#
 	Microsoft.CodeAnalysis.CSharp.Workspaces.dll!Microsoft.CodeAnalysis.CSharp.Utilities.SpeculationAnalyzer.GetForEachSymbols(Microsoft.CodeAnalysis.SemanticModel model, Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax forEach, out Microsoft.CodeAnalysis.IMethodSymbol getEnumeratorMethod, out Microsoft.CodeAnalysis.ITypeSymbol elementType) Line 714	C#
 	Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer&lt;Microsoft.CodeAnalysis.SyntaxNode, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax, Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Conversion&gt;.ReplacementBreaksForEachStatement(Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax forEachStatement, Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax newForEachStatement) Line 566	C#
 	Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer&lt;Microsoft.CodeAnalysis.SyntaxNode, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax, Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Conversion&gt;.ReplacementChangesSemanticsForNode(Microsoft.CodeAnalysis.SyntaxNode currentOriginalNode, Microsoft.CodeAnalysis.SyntaxNode currentReplacedNode, Microsoft.CodeAnalysis.SyntaxNode previousOriginalNode, Microsoft.CodeAnalysis.SyntaxNode previousReplacedNode) Line 496	C#
 	Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer&lt;Microsoft.CodeAnalysis.SyntaxNode, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax, Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Conversion&gt;.ReplacementChangesSemantics(Microsoft.CodeAnalysis.SyntaxNode currentOriginalNode, Microsoft.CodeAnalysis.SyntaxNode currentReplacedNode, Microsoft.CodeAnalysis.SyntaxNode originalRoot, bool skipVerificationForCurrentNode) Line 437	C#
 	Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer&lt;Microsoft.CodeAnalysis.SyntaxNode, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax, Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Conversion&gt;.ReplacementChangesSemantics() Line 416	C#
 	Microsoft.CodeAnalysis.CSharp.Workspaces.dll!Microsoft.CodeAnalysis.CSharp.Extensions.ExpressionSyntaxExtensions.CanReplaceWithReducedName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax reducedName, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken) Line 1955	C#
 	Microsoft.CodeAnalysis.CSharp.Workspaces.dll!Microsoft.CodeAnalysis.CSharp.Extensions.ExpressionSyntaxExtensions.TryReduce(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name, Microsoft.CodeAnalysis.SemanticModel semanticModel, out Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax replacementNode, out Microsoft.CodeAnalysis.Text.TextSpan issueSpan, Microsoft.CodeAnalysis.Options.OptionSet optionSet, System.Threading.CancellationToken cancellationToken) Line 1477	C#
 	Microsoft.CodeAnalysis.CSharp.Workspaces.dll!Microsoft.CodeAnalysis.CSharp.Extensions.ExpressionSyntaxExtensions.TryReduceExplicitName(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SemanticModel semanticModel, out Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax replacementNode, out Microsoft.CodeAnalysis.Text.TextSpan issueSpan, Microsoft.CodeAnalysis.Options.OptionSet optionSet, System.Threading.CancellationToken cancellationToken) Line 697	C#
 	Microsoft.CodeAnalysis.CSharp.Workspaces.dll!Microsoft.CodeAnalysis.CSharp.Extensions.ExpressionSyntaxExtensions.TryReduceOrSimplifyExplicitName(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SemanticModel semanticModel, out Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax replacementNode, out Microsoft.CodeAnalysis.Text.TextSpan issueSpan, Microsoft.CodeAnalysis.Options.OptionSet optionSet, System.Threading.CancellationToken cancellationToken) Line 664	C#
 	Microsoft.CodeAnalysis.CSharp.Workspaces.dll!Microsoft.CodeAnalysis.CSharp.Simplification.CSharpNameReducer.SimplifyName(Microsoft.CodeAnalysis.SyntaxNode node, Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.Options.OptionSet optionSet, System.Threading.CancellationToken cancellationToken) Line 42	C#
 	Microsoft.CodeAnalysis.CSharp.Workspaces.dll!Microsoft.CodeAnalysis.CSharp.Simplification.AbstractCSharpReducer.AbstractExpressionRewriter.SimplifyNode&lt;Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax&gt;(Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax node, Microsoft.CodeAnalysis.SyntaxNode newNode, Microsoft.CodeAnalysis.SyntaxNode parentNode, System.Func&lt;Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax, Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.Options.OptionSet, System.Threading.CancellationToken, Microsoft.CodeAnalysis.SyntaxNode&gt; simplifier) Line 104	C#
 	Microsoft.CodeAnalysis.CSharp.Workspaces.dll!Microsoft.CodeAnalysis.CSharp.Simplification.AbstractCSharpReducer.AbstractExpressionRewriter.SimplifyExpression&lt;Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax&gt;(Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax expression, Microsoft.CodeAnalysis.SyntaxNode newNode, System.Func&lt;Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax, Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.Options.OptionSet, System.Threading.CancellationToken, Microsoft.CodeAnalysis.SyntaxNode&gt; simplifier) Line 128	C#
 	Microsoft.CodeAnalysis.CSharp.Workspaces.dll!Microsoft.CodeAnalysis.CSharp.Simplification.CSharpNameReducer.Rewriter.VisitAliasQualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax node) Line 48	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax.Accept&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; visitor) Line 423	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(Microsoft.CodeAnalysis.SyntaxNode node) Line 37	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitQualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax node) Line 2481	C#
 	Microsoft.CodeAnalysis.CSharp.Workspaces.dll!Microsoft.CodeAnalysis.CSharp.Simplification.CSharpNameReducer.Rewriter.VisitQualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax node) Line 66	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax.Accept&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; visitor) Line 150	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(Microsoft.CodeAnalysis.SyntaxNode node) Line 37	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitDeclarationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationExpressionSyntax node) Line 2801	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationExpressionSyntax.Accept&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; visitor) Line 3836	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(Microsoft.CodeAnalysis.SyntaxNode node) Line 37	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitArgument(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax node) Line 2788	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax.Accept&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; visitor) Line 3672	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(Microsoft.CodeAnalysis.SyntaxNode node) Line 37	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement&lt;Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax&gt;(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax node) Line 163	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList&lt;Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax&gt;(Microsoft.CodeAnalysis.SeparatedSyntaxList&lt;Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax&gt; list) Line 216	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax node) Line 2771	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax.Accept&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; visitor) Line 3469	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(Microsoft.CodeAnalysis.SyntaxNode node) Line 37	C#
 	Microsoft.CodeAnalysis.CSharp.Workspaces.dll!Microsoft.CodeAnalysis.CSharp.Simplification.AbstractCSharpReducer.AbstractExpressionRewriter.VisitInvocationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax node) Line 161	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax.Accept&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; visitor) Line 3277	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(Microsoft.CodeAnalysis.SyntaxNode node) Line 37	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitForEachStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax node) Line 3278	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax.Accept&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; visitor) Line 9391	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(Microsoft.CodeAnalysis.SyntaxNode node) Line 37	C#
 	Microsoft.CodeAnalysis.CSharp.Workspaces.dll!Microsoft.CodeAnalysis.CSharp.Simplification.AbstractCSharpReducer.AbstractExpressionRewriter.VisitNodeOrToken(Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken, Microsoft.CodeAnalysis.SemanticModel semanticModel, bool simplifyAllDescendants) Line 176	C#
 	Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Simplification.AbstractSimplificationService&lt;Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax&gt;.ReduceAsync.AnonymousMethod__0() Line 246	C#
```

With an exception:

```
System.InvalidCastException: 'Unable to cast object of type 'Microsoft.CodeAnalysis.CSharp.BoundBlock' to type 'Microsoft.CodeAnalysis.CSharp.BoundForEachStatement'.'
```

</Description>
        <CreatedDate>06/01/2017</CreatedDate>
        <ClosedDate>15/04/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>18662</PullRequestID>
      <File>src/Compilers/CSharp/Portable/Compilation/MemberSemanticModel.NodeMapBuilder.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/MemberSemanticModel.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/OutVarTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/InlineDeclaration/CSharpInlineDeclarationTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>18605</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Disable currently broken VSI tests</Title>
    <Description>Disable the 3 failing vsi tests until #18602 and #18295 are fixed. @dotnet/roslyn-ide for review, FYI @jmarolf </Description>
    <CreatedDate>11/04/2017</CreatedDate>
    <ClosedDate>11/04/2017</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>18605</PullRequestID>
        <IssueID>18602</IssueID>
        <Title>Broken Tests: CSharp/VB DeleteControl</Title>
        <Description>Tests:
Roslyn.VisualStudio.IntegrationTests.CSharp.CSharpWinForms.DeleteControl
Stack:
```
    Roslyn.VisualStudio.IntegrationTests.CSharp.CSharpWinForms.DeleteControl
      System.NullReferenceException : Object reference not set to an instance of an object.
      Stack Trace:
        
        Server stack trace: 
           at Microsoft.VisualStudio.IntegrationTest.Utilities.InProcess.Editor_InProc.&lt;&gt;c__DisplayClass45_1.&lt;DeleteWinFormButton&gt;g__ComponentRemoved0(Object sender, ComponentEventArgs e)
           at System.ComponentModel.Design.ComponentEventHandler.Invoke(Object sender, ComponentEventArgs e)
           at System.ComponentModel.Design.DesignerHost.RemoveFromContainerPostProcess(IComponent component, IContainer container)
           at System.ComponentModel.Design.DesignerHost.Remove(IComponent component)
           at System.ComponentModel.Design.DesignerHost.System.ComponentModel.Design.IDesignerHost.DestroyComponent(IComponent component)
           at Microsoft.VisualStudio.IntegrationTest.Utilities.InProcess.Editor_InProc.&lt;&gt;c__DisplayClass45_2.&lt;DeleteWinFormButton&gt;b__1()
           at System.Windows.Threading.DispatcherOperation.InvokeDelegateCore()
           at System.Windows.Threading.DispatcherOperation.InvokeImpl()
        --- End of stack trace from previous location where exception was thrown ---
           at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
           at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
           at System.Windows.Threading.DispatcherOperation.Wait(TimeSpan timeout)
           at System.Windows.Threading.Dispatcher.InvokeImpl(DispatcherOperation operation, CancellationToken cancellationToken, TimeSpan timeout)
           at System.Windows.Threading.Dispatcher.Invoke(Action callback, DispatcherPriority priority, CancellationToken cancellationToken, TimeSpan timeout)
           at System.Windows.Threading.Dispatcher.Invoke(Action callback)
           at Microsoft.VisualStudio.IntegrationTest.Utilities.InProcess.InProcComponent.InvokeOnUIThread(Action action)
           at Microsoft.VisualStudio.IntegrationTest.Utilities.InProcess.Editor_InProc.DeleteWinFormButton(String buttonName)
           at System.Runtime.Remoting.Messaging.StackBuilderSink._PrivateProcessMessage(IntPtr md, Object[] args, Object server, Object[]&amp; outArgs)
           at System.Runtime.Remoting.Messaging.StackBuilderSink.SyncProcessMessage(IMessage msg)
        
        Exception rethrown at [0]: 
           at System.Runtime.Remoting.Proxies.RealProxy.HandleReturnMessage(IMessage reqMsg, IMessage retMsg)
           at System.Runtime.Remoting.Proxies.RealProxy.PrivateInvoke(MessageData&amp; msgData, Int32 type)
           at Microsoft.VisualStudio.IntegrationTest.Utilities.InProcess.Editor_InProc.DeleteWinFormButton(String buttonName)
           at Microsoft.VisualStudio.IntegrationTest.Utilities.OutOfProcess.Editor_OutOfProc.DeleteWinFormButton(String buttonName)
        q:\roslyn\src\VisualStudio\IntegrationTest\IntegrationTests\CSharp\CSharpWinForms.cs(160,0): at Roslyn.VisualStudio.IntegrationTests.CSharp.CSharpWinForms.DeleteControl()
```
Screenshot:
![image](https://cloud.githubusercontent.com/assets/2371880/24922376/eb01d58e-1ea2-11e7-9045-d87b018cf9a4.png)


Roslyn.VisualStudio.IntegrationTests.VisualBasic.BasicWinForms.DeleteControl
Stack:
```
    Roslyn.VisualStudio.IntegrationTests.VisualBasic.BasicWinForms.DeleteControl
      System.NullReferenceException : Object reference not set to an instance of an object.
      Stack Trace:
        
        Server stack trace: 
           at Microsoft.VisualStudio.IntegrationTest.Utilities.InProcess.Editor_InProc.&lt;&gt;c__DisplayClass45_1.&lt;DeleteWinFormButton&gt;g__ComponentRemoved0(Object sender, ComponentEventArgs e)
           at System.ComponentModel.Design.ComponentEventHandler.Invoke(Object sender, ComponentEventArgs e)
           at System.ComponentModel.Design.DesignerHost.RemoveFromContainerPostProcess(IComponent component, IContainer container)
           at System.ComponentModel.Design.DesignerHost.Remove(IComponent component)
           at System.ComponentModel.Design.DesignerHost.System.ComponentModel.Design.IDesignerHost.DestroyComponent(IComponent component)
           at Microsoft.VisualStudio.IntegrationTest.Utilities.InProcess.Editor_InProc.&lt;&gt;c__DisplayClass45_2.&lt;DeleteWinFormButton&gt;b__1()
           at System.Windows.Threading.DispatcherOperation.InvokeDelegateCore()
           at System.Windows.Threading.DispatcherOperation.InvokeImpl()
        --- End of stack trace from previous location where exception was thrown ---
           at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
           at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
           at System.Windows.Threading.DispatcherOperation.Wait(TimeSpan timeout)
           at System.Windows.Threading.Dispatcher.InvokeImpl(DispatcherOperation operation, CancellationToken cancellationToken, TimeSpan timeout)
           at System.Windows.Threading.Dispatcher.Invoke(Action callback, DispatcherPriority priority, CancellationToken cancellationToken, TimeSpan timeout)
           at System.Windows.Threading.Dispatcher.Invoke(Action callback)
           at Microsoft.VisualStudio.IntegrationTest.Utilities.InProcess.InProcComponent.InvokeOnUIThread(Action action)
           at Microsoft.VisualStudio.IntegrationTest.Utilities.InProcess.Editor_InProc.DeleteWinFormButton(String buttonName)
           at System.Runtime.Remoting.Messaging.StackBuilderSink._PrivateProcessMessage(IntPtr md, Object[] args, Object server, Object[]&amp; outArgs)
           at System.Runtime.Remoting.Messaging.StackBuilderSink.SyncProcessMessage(IMessage msg)
        
        Exception rethrown at [0]: 
           at System.Runtime.Remoting.Proxies.RealProxy.HandleReturnMessage(IMessage reqMsg, IMessage retMsg)
           at System.Runtime.Remoting.Proxies.RealProxy.PrivateInvoke(MessageData&amp; msgData, Int32 type)
           at Microsoft.VisualStudio.IntegrationTest.Utilities.InProcess.Editor_InProc.DeleteWinFormButton(String buttonName)
           at Microsoft.VisualStudio.IntegrationTest.Utilities.OutOfProcess.Editor_OutOfProc.DeleteWinFormButton(String buttonName)
        q:\roslyn\src\VisualStudio\IntegrationTest\IntegrationTests\VisualBasic\BasicWinForms.cs(188,0): at Roslyn.VisualStudio.IntegrationTests.VisualBasic.BasicWinForms.DeleteControl()
```
Screenshot:
![image](https://cloud.githubusercontent.com/assets/2371880/24922385/f1c68e46-1ea2-11e7-8f52-41935308f253.png)
</Description>
        <CreatedDate>11/04/2017</CreatedDate>
        <ClosedDate>13/04/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>18605</PullRequestID>
        <IssueID>18295</IssueID>
        <Title>[Flaky Test] Roslyn.VisualStudio.IntegrationTests.CSharp.CSharpCodeActions.GenerateMethodInClosedFile</Title>
        <Description>https://ci.dot.net/job/dotnet_roslyn/job/master/job/windows_release_vs-integration/633/testReport/junit/Roslyn.VisualStudio.IntegrationTests.CSharp/CSharpCodeActions/GenerateMethodInClosedFile/

```
Assert.Equal() Failure
 ‚Üì (pos 2)
Expected: \\r\\nusing System;\\r\\n\\r\\npublic class Foo\\r\\n{\\r\\n ¬∑¬∑¬∑
Actual:     \\r\\npublic class Foo\\r\\n{\\r\\n}\\r\\n
 ‚Üë (pos 2)
```</Description>
        <CreatedDate>29/03/2017</CreatedDate>
        <ClosedDate>18/04/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>18605</PullRequestID>
      <File>src/VisualStudio/IntegrationTest/IntegrationTests/CSharp/CSharpCodeActions.cs</File>
      <File>src/VisualStudio/IntegrationTest/IntegrationTests/CSharp/CSharpWinForms.cs</File>
      <File>src/VisualStudio/IntegrationTest/IntegrationTests/VisualBasic/BasicWinForms.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>18552</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Report use-site diagnostics if System.ValueTuple base type is an error type</Title>
    <Description>[Port b46690a07de68c5a094b084441de6dbad1d2b8f2 to dev15.2.x branch.]

VSO Bug https://devdiv.visualstudio.com/DefaultCollection/DevDiv/_workitems?id=406153&amp;fullScreen=false&amp;_a=edit

Report use-site diagnostics, if any, from `System.ValueTuple` base type rather than `"'ValueTuple' must be a struct"`.

This may result in a clearer error message for the user when an assembly is missing. More importantly, it allows the EE to recognize such cases at runtime so the EE can load the missing assembly explicitly.

**Customer scenario**
Expression evaluation in the debugger fails in frames containing tuples before `System.Runtime.dll` is loaded by the debugger.

**Bugs this fixes**
#16879.

**Workarounds, if any**
None

**Risk**
Low risk. The change is the error reported when the base type of `System.ValueTuple` is not found.

**Performance impact**
No change

**Is this a regression**
No, tuples are a new feature in VS2017.

**How was the bug found?**
Customer reported

- 4 customers reported via [github issue](https://github.com/dotnet/roslyn/issues/16879)
- 1 windows insider report on [github](https://github.com/dotnet/roslyn/issues/17157)
- 3 customers reported on stackoverflow ([here](http://stackoverflow.com/questions/42856319/how-can-i-remove-exception-predefined-type-valuetuple2-must-be-a-struct-whe), [here](http://stackoverflow.com/questions/43006178/vs2017-error-debugging-task-of-tuple/43006552#43006552) and [here](http://stackoverflow.com/questions/43006178/vs2017-error-debugging-task-of-tuple/43006552))
- [User Feedback](https://developercommunity.visualstudio.com/content/problem/24460/when-using-tuples-maybe-combined-in-method-in-meth.html)


</Description>
    <CreatedDate>08/04/2017</CreatedDate>
    <ClosedDate>10/04/2017</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>18552</PullRequestID>
        <IssueID>16879</IssueID>
        <Title>RC 26127.3: Debugger broken when using tuples</Title>
        <Description>**Version Used**: 26127.3

**Steps to Reproduce**:

1.  Place a breakpoint at the ending brace of the Main method bellow:
```
    class Program
    {
        static void Main(string[] args)
        {
            var a = 77;
            var b = (5, 6);
        }
    }
```
2. Run and wait for the breakpoint to hit. 
3. Hover over `a`. No info tooltip will appear.
4. Right-click `a` and select Quick Watch. The following error will be displayed:
```error CS8182: Predefined type 'ValueTuple`2' must be a struct```

The above behavior reproduces for any variable/field used in the method body, *except* for the tuple ones.
When removing the code that uses tuples, debugging works normally.</Description>
        <CreatedDate>01/02/2017</CreatedDate>
        <ClosedDate>08/02/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>18552</PullRequestID>
      <File>src/Compilers/CSharp/Portable/Emitter/Model/PEModuleBuilder.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTupleTest.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Test/ExpressionCompiler/MissingAssemblyTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>18494</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Interface change of IHasArgumentsExpression, IInvocationExpression and IArgument </Title>
    <Description>Based on the proposal in #8813. The goal of this PR is to make sure the interface change follows the proposed design, ~~and the implementation has correct behavior~~. Finalizing the implementation is not of the interest of this PR (for example, we want to leverage rewriter to derive arguments in C# later).

**Update:**
Talked with @AlekseyTs offline, we decided to remove all the implementation changes in C# side as they still doesn't cover all scenarios correctly and are going to be thrown away with the fix for #18549. In 228b604 I have rolled back all the changes, and the implementation for C#  `ArgumentsInEvaluationOrder` is basically the old ~~`ArgumentsInSourceOrder`~~`ArgumentsInParameterOrder`. As a result of this, **the contract for `IHasArgumentsExpression.ArgumentsInEvaluationOrder` is broken**, i.e. it doesn't return correct list of arguments, and we decided this is OK as long as it will be fixed in my next PR (supposedly very soon). 

Affected tests are disabled, because it makes no sense to "fix" them for incorrect behavior.

**Update2**
`GetArgumentMatchingParameter ` and `ArgumentsInParameterOrder`, which were downgraded to extension methods in this PR, now completely removed with intention to bring them back after the interface and implementation of `IHasArgumentsExpression` is finalized. Tracked by #18658

This also fixes #8781, and fixes the design part of #8786
Related: #18549, #18550, 

==========================

**Customer scenario**

Improved interfaces for `IHasArgumentsExpression` and `IArgument`. For example, `ArgumentsInEvaluationOrder` property is added to `IHasArgumentsExpression`, which provides a unified way to order arguments in execution order for both C# and VB. This replaced previous arguments ordering APIs for source order and parameter order, which are demoted from core interface to probably extension methods.

**Bugs this fixes:**
#8813, #8781 

**Workarounds, if any**
None.

**Risk**
Low. And this is still behind a feature flag.

**Performance impact**
Low.

**Is this a regression from a previous update?**
No.

**Root cause analysis:**
N/A

**How was the bug found?**
Not a bug, this is part of the IOperation cleanup work.</Description>
    <CreatedDate>06/04/2017</CreatedDate>
    <ClosedDate>18/04/2017</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>18494</PullRequestID>
        <IssueID>8813</IssueID>
        <Title>IOperation: A proposal to change design around IHasArgumentsExpression, IInvocationExpression and IArgument interfaces.</Title>
        <Description>**Exposing the set of arguments**

Currently we have two APIs that are supposed to expose arguments and every implementer has to implement both.
In IHasArgumentsExpression, which is IInvocationExpression inherits from:

```
        /// &lt;summary&gt;
        /// Arguments of the invocation, excluding the instance argument. Arguments are in parameter order,
        /// and params/ParamArray arguments have been collected into arrays. Default values are supplied for
        /// optional arguments missing in source.
        /// &lt;/summary&gt;
        ImmutableArray&lt;IArgument&gt; ArgumentsInParameterOrder { get; }
```

In IInvocationExpression 

```
        /// &lt;summary&gt;
        /// Arguments of the invocation, excluding the instance argument. Arguments are in the order specified in source,
        /// and params/ParamArray arguments have been collected into arrays. Arguments are not present
        /// unless supplied in source.
        /// &lt;/summary&gt;
        ImmutableArray&lt;IArgument&gt; ArgumentsInSourceOrder { get; }
```

I am not sure if having two these APIs provides much value. I believe that it would be much more useful to have a single API in IHasArgumentsExpression:

```
        /// &lt;summary&gt;
        /// Arguments of the invocation, excluding the instance argument. Arguments are in evaluation order,
        /// and params/ParamArray arguments have been collected into arrays. Default values are supplied for
        /// optional arguments missing in source.
        /// &lt;/summary&gt;
        ImmutableArray&lt;IArgument&gt; ArgumentsInEvaluationOrder { get; }
```

If we feel that sometimes consumers would want to traverse arguments in source or parameter order, we can provide helpers like this as extension methods for IHasArgumentsExpression interface because all the relevant information should be available from IArguments.

**IArgument, ArgumentKinds and param arrays**

It is not obvious what value do we get from distinguishing between Positional and Named arguments. I believe Analyzers will be more interested in the order, in which arguments are evaluated (ArgumentsInEvaluationOrder solves that). Knowing whether the argument was named doesn't look that important and can always be discovered from syntax. 

The requirement to create a separate IArgument of ParamArray kind for each element of param array

```
        /// &lt;summary&gt;
        /// Argument becomes an element of an array that matches a trailing C# params or VB ParamArray parameter.
        /// &lt;/summary&gt;
        ParamArray = 0x3,
```

means that we will create trees of different shape for situations when param array was created by the compilers and when the array was passed explicitly. Do Analyzers really care that much about param array that they will be willing to be prepared to deal with two different tree shapes for semantically equivalent code?

Another issue with the current design is that it looks like an empty param array created by compilers won't have any representation in the tree at all, because there is no ArgumentKind that could be used for such an argument.

To address all these issues, I propose to change the current set of ArgumentKinds as follows (note, the meaning of ParamArray kind is changed):

```
    /// &lt;summary&gt;
    /// Kinds of arguments.
    /// &lt;/summary&gt;
    public enum ArgumentKind
    {
        None = 0x0,

        /// &lt;summary&gt;
        /// Argument value is explicitly supplied.
        /// &lt;/summary&gt;
        Explicit = 0x1,

        /// &lt;summary&gt;
        /// Argument is a param array created by compilers for the matching C# params or VB ParamArray parameter. Note, the value is a an array creation expression that encapsulates all the elements, if any.
        /// &lt;/summary&gt;
        ParamArray = 0x2,

        /// &lt;summary&gt;
        /// Argument is a default value supplied automatically by the compilers.
        /// &lt;/summary&gt;
        DefaultValue = 0x3
    }
```

See related issues: #8805, #8786, #8781, #8773.
</Description>
        <CreatedDate>17/02/2016</CreatedDate>
        <ClosedDate>18/05/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>18494</PullRequestID>
        <IssueID>18549</IssueID>
        <Title>`IHasArgumentsExpression.ArgumentsInEvaluationOrder` in C# should not use private implementation</Title>
        <Description>Currently, there is a lot of logic duplicated in C#'s implementation and there is a lot of opportunities to deviate from what LocalRewriter is doing. I believe our goal should be to return result consistent with what LocalRewriter would produce. As such we should find a way to share that logic, IOperation should not have its own private implementation.

With this in mind, I have made the change for IHasArgumentsExpression interface in #18494 with minimal change in implementation, to avoid doing unnecessary throwaway work. As a result, **the contract for `IHasArgumentsExpression.ArgumentsInEvaluationOrder` is broken**, as current implementation is the old `ArgumentsInSourceOrder`, therefore missing all default arguments (including empty param array). This issue is intended to track this as well, as I believe getting rid of private implementation would also fix this.</Description>
        <CreatedDate>08/04/2017</CreatedDate>
        <ClosedDate>18/05/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>18494</PullRequestID>
        <IssueID>18658</IssueID>
        <Title>Implement GetArgumentMatchingParameter and ArgumentsInParameterOrder as extension methods</Title>
        <Description>Those are removed from core `IHasArgumentsExpression` interface, based on the latest interface design. Will likely bring them back as extension methods instead, once the core interface and implementation are finalized. This issue is created to track that.

Related to:
#8813 #8805</Description>
        <CreatedDate>12/04/2017</CreatedDate>
        <ClosedDate>23/06/2018</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>18494</PullRequestID>
        <IssueID>8781</IssueID>
        <Title>IOperation: VB - BoundCall.ByRefArgument always reported as positional</Title>
        <Description>The argument can be named as well.

```
            Public Overrides ReadOnly Property ArgumentKind As ArgumentKind
                Get
                    ' Do the VB bound trees encode named arguments?
                    Return ArgumentKind.Positional
                End Get
            End Property
```
</Description>
        <CreatedDate>17/02/2016</CreatedDate>
        <ClosedDate>18/04/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>18494</PullRequestID>
        <IssueID>8786</IssueID>
        <Title>IOperation: What is the value of ParamArray arguments?</Title>
        <Description>Given the following API definition:

```
    /// &lt;summary&gt;
    /// Kinds of arguments.
    /// &lt;/summary&gt;
    public enum ArgumentKind
    {
        None = 0x0,

        /// &lt;summary&gt;
        /// Argument is specified positionally and matches the parameter of the same ordinality.
        /// &lt;/summary&gt;
        Positional = 0x1,
        /// &lt;summary&gt;
        /// Argument is specified by name and matches the parameter of the same name.
        /// &lt;/summary&gt;
        Named = 0x2,
        /// &lt;summary&gt;
        /// Argument becomes an element of an array that matches a trailing C# params or VB ParamArray parameter.
        /// &lt;/summary&gt;
        ParamArray = 0x3,
        /// &lt;summary&gt;
        /// Argument was omitted in source but has a default value supplied automatically.
        /// &lt;/summary&gt;
        DefaultValue = 0x4
    }
```

It looks like the shape of the IOperation tree is going to depend on whether param array argument was crated by the compiler. Given this method definition:

```
static void Test(params string[] y)
```

The following call will have two ParamArray arguments, corresponding to `"a"` and `"b"`:

```
Test("a", "b");
```

But this call will have one Positional argument, corresponding to `new [] {"a", "b"}`:

```
Test(new [] {"a", "b"});
```

These two calls are semantically identical. Do we really want analyzers to be prepared to deal with this difference? 

What argument should be created for this scenario, where `"a"` is a named argument and a param array element at the same time?

```
    static void Main()
    {
        Test(y: "a", x:10);
    }

    static void Test(int x, params string[] y)
    {
        System.Console.WriteLine(y[0]);
    }
```
</Description>
        <CreatedDate>17/02/2016</CreatedDate>
        <ClosedDate>18/05/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>18494</PullRequestID>
        <IssueID>18549</IssueID>
        <Title>`IHasArgumentsExpression.ArgumentsInEvaluationOrder` in C# should not use private implementation</Title>
        <Description>Currently, there is a lot of logic duplicated in C#'s implementation and there is a lot of opportunities to deviate from what LocalRewriter is doing. I believe our goal should be to return result consistent with what LocalRewriter would produce. As such we should find a way to share that logic, IOperation should not have its own private implementation.

With this in mind, I have made the change for IHasArgumentsExpression interface in #18494 with minimal change in implementation, to avoid doing unnecessary throwaway work. As a result, **the contract for `IHasArgumentsExpression.ArgumentsInEvaluationOrder` is broken**, as current implementation is the old `ArgumentsInSourceOrder`, therefore missing all default arguments (including empty param array). This issue is intended to track this as well, as I believe getting rid of private implementation would also fix this.</Description>
        <CreatedDate>08/04/2017</CreatedDate>
        <ClosedDate>18/05/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>18494</PullRequestID>
        <IssueID>18550</IssueID>
        <Title>`WasCompilerGenerated` property on bound node is not a robust way to determine `ArgumentKind` in VB</Title>
        <Description>The implementation in VB bound tree provides a fully populated list of arguments, including arguments with default value and array that is generated by compiler as argument for `ParamArray` parameter for invocation of expanded form. However, we currently don't have definitive information on the bound node that tells us if 

1. it is a default value argument, or 
2. it is an array created by compiler because or it is an array provided explicitly by caller for the normal form of invocation. 

At the moment, we rely on checking `WasCompilerGenerated` property on the argument bound nodes, which might break in many cases. @AlekseyTs proposed a more robust approach, basically to create additional wrapper nodes, and during binding we wrap up argument nodes of default value and paramarray argument generated by compiler.
</Description>
        <CreatedDate>08/04/2017</CreatedDate>
        <ClosedDate>25/06/2018</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>18494</PullRequestID>
        <IssueID>8813</IssueID>
        <Title>IOperation: A proposal to change design around IHasArgumentsExpression, IInvocationExpression and IArgument interfaces.</Title>
        <Description>**Exposing the set of arguments**

Currently we have two APIs that are supposed to expose arguments and every implementer has to implement both.
In IHasArgumentsExpression, which is IInvocationExpression inherits from:

```
        /// &lt;summary&gt;
        /// Arguments of the invocation, excluding the instance argument. Arguments are in parameter order,
        /// and params/ParamArray arguments have been collected into arrays. Default values are supplied for
        /// optional arguments missing in source.
        /// &lt;/summary&gt;
        ImmutableArray&lt;IArgument&gt; ArgumentsInParameterOrder { get; }
```

In IInvocationExpression 

```
        /// &lt;summary&gt;
        /// Arguments of the invocation, excluding the instance argument. Arguments are in the order specified in source,
        /// and params/ParamArray arguments have been collected into arrays. Arguments are not present
        /// unless supplied in source.
        /// &lt;/summary&gt;
        ImmutableArray&lt;IArgument&gt; ArgumentsInSourceOrder { get; }
```

I am not sure if having two these APIs provides much value. I believe that it would be much more useful to have a single API in IHasArgumentsExpression:

```
        /// &lt;summary&gt;
        /// Arguments of the invocation, excluding the instance argument. Arguments are in evaluation order,
        /// and params/ParamArray arguments have been collected into arrays. Default values are supplied for
        /// optional arguments missing in source.
        /// &lt;/summary&gt;
        ImmutableArray&lt;IArgument&gt; ArgumentsInEvaluationOrder { get; }
```

If we feel that sometimes consumers would want to traverse arguments in source or parameter order, we can provide helpers like this as extension methods for IHasArgumentsExpression interface because all the relevant information should be available from IArguments.

**IArgument, ArgumentKinds and param arrays**

It is not obvious what value do we get from distinguishing between Positional and Named arguments. I believe Analyzers will be more interested in the order, in which arguments are evaluated (ArgumentsInEvaluationOrder solves that). Knowing whether the argument was named doesn't look that important and can always be discovered from syntax. 

The requirement to create a separate IArgument of ParamArray kind for each element of param array

```
        /// &lt;summary&gt;
        /// Argument becomes an element of an array that matches a trailing C# params or VB ParamArray parameter.
        /// &lt;/summary&gt;
        ParamArray = 0x3,
```

means that we will create trees of different shape for situations when param array was created by the compilers and when the array was passed explicitly. Do Analyzers really care that much about param array that they will be willing to be prepared to deal with two different tree shapes for semantically equivalent code?

Another issue with the current design is that it looks like an empty param array created by compilers won't have any representation in the tree at all, because there is no ArgumentKind that could be used for such an argument.

To address all these issues, I propose to change the current set of ArgumentKinds as follows (note, the meaning of ParamArray kind is changed):

```
    /// &lt;summary&gt;
    /// Kinds of arguments.
    /// &lt;/summary&gt;
    public enum ArgumentKind
    {
        None = 0x0,

        /// &lt;summary&gt;
        /// Argument value is explicitly supplied.
        /// &lt;/summary&gt;
        Explicit = 0x1,

        /// &lt;summary&gt;
        /// Argument is a param array created by compilers for the matching C# params or VB ParamArray parameter. Note, the value is a an array creation expression that encapsulates all the elements, if any.
        /// &lt;/summary&gt;
        ParamArray = 0x2,

        /// &lt;summary&gt;
        /// Argument is a default value supplied automatically by the compilers.
        /// &lt;/summary&gt;
        DefaultValue = 0x3
    }
```

See related issues: #8805, #8786, #8781, #8773.
</Description>
        <CreatedDate>17/02/2016</CreatedDate>
        <ClosedDate>18/05/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>18494</PullRequestID>
        <IssueID>8781</IssueID>
        <Title>IOperation: VB - BoundCall.ByRefArgument always reported as positional</Title>
        <Description>The argument can be named as well.

```
            Public Overrides ReadOnly Property ArgumentKind As ArgumentKind
                Get
                    ' Do the VB bound trees encode named arguments?
                    Return ArgumentKind.Positional
                End Get
            End Property
```
</Description>
        <CreatedDate>17/02/2016</CreatedDate>
        <ClosedDate>18/04/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>18494</PullRequestID>
      <File>src/Compilers/CSharp/Portable/BoundTree/Expression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Diagnostics/OperationAnalyzerTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IArgument.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IIfStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_ISymbolInitializer.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_InvalidExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/ArgumentKind.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IArgument.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IHasArgumentsExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IInvocationExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IndexedPropertyReferenceExpression_IHasArgumentsExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/InvocationExpression_IHasArgumentsExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/ObjectCreationExpression_IHasArgumentsExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationExtensions.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationWalker.cs</File>
      <File>src/Features/Core/Portable/InitializeParameter/AbstractAddParameterCheckCodeRefactoringProvider.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/OperationTreeVerifier.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/TestOperationWalker.cs</File>
      <File>src/Test/Utilities/Portable/Diagnostics/CouldHaveMoreSpecificTypeAnalyzer.cs</File>
      <File>src/Test/Utilities/Portable/Diagnostics/FieldCouldBeReadOnlyAnalyzer.cs</File>
      <File>src/Test/Utilities/Portable/Diagnostics/LocalCouldBeConstAnalyzer.cs</File>
      <File>src/Test/Utilities/Portable/Diagnostics/OperationTestAnalyzer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>18489</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Fixes #18311 - Incorrect quick info for ValueTuple&lt;T&gt;</Title>
    <Description>Fixes #18311 
Closes #15508

Hovering `var` will show `System.ValueTuple&lt;System.Int32&gt;`
Hovering `y` will show `(local variable) ValueTuple&lt;int&gt; y`</Description>
    <CreatedDate>06/04/2017</CreatedDate>
    <ClosedDate>07/04/2017</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>18489</PullRequestID>
        <IssueID>18311</IssueID>
        <Title>Incorrect quick info for ValueTuple&lt;T&gt;</Title>
        <Description>**Version Used**: VS 2017 (15.0.0+26228.9)

**Steps to Reproduce**:

1. Use the following code:

    ```csharp
    void Foo()
    {
        var y = ValueTuple.Create(1);
    }
    ```

2. Hover over `var`
3. Hover over `y`

**Expected Behavior**:

* In step 2, the result should be `struct System.ValueTuple&lt;T&gt;`, with `T is int`.
* In step 3, the result should be `ValueTuple&lt;int, int&gt; y`

**Actual Behavior**:

* In step 2, the result is `(System.Int32)`
* In step 3, the result is `(int) y`

Neither of these are valid tuple syntaxes in C#.
</Description>
        <CreatedDate>30/03/2017</CreatedDate>
        <ClosedDate>07/04/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>18489</PullRequestID>
        <IssueID>15508</IssueID>
        <Title>IDE extract method fails to handle some deconstruction scenarios.</Title>
        <Description>The IDE code is not resilient against arbitrary expressions appearing on the left-hand-side of a deconstruction. It tries to produce a zero-element tuple type, which causes an exception to be thrown.

This will be a problem after generalized deconstruction support is added to the compiler, even in error scenarios. I'll skip the two affected tests, `GenerateMethodTests.TestDeconstruction3` and `4`. The offending code is here, in `src\Workspaces\CSharp\Portable\LanguageServices\CSharpTypeInferenceService.TypeInferrer.cs`:

```cs
            private bool TryGetTupleTypesAndNames(
                SeparatedSyntaxList&lt;ArgumentSyntax&gt; arguments,
                out ImmutableArray&lt;ITypeSymbol&gt; elementTypes,
                out ImmutableArray&lt;string&gt; elementNames)
            {
                elementTypes = default(ImmutableArray&lt;ITypeSymbol&gt;);
                elementNames = default(ImmutableArray&lt;string&gt;);

                var elementTypesBuilder = ArrayBuilder&lt;ITypeSymbol&gt;.GetInstance();
                var elementNamesBuilder = ArrayBuilder&lt;string&gt;.GetInstance();
                try
                {
                    foreach (var arg in arguments)
                    {
                        var expr = arg.Expression;
                        if (expr.IsKind(SyntaxKind.DeclarationExpression))
                        {
                            AddTypeAndName((DeclarationExpressionSyntax)expr, elementTypesBuilder, elementNamesBuilder);
                        }
                        else if (expr.IsKind(SyntaxKind.TupleExpression))
                        {
                            AddTypeAndName((TupleExpressionSyntax)expr, elementTypesBuilder, elementNamesBuilder);
                        }
                    }

                    if (elementTypesBuilder.Contains(null))
                    {
                        return false;
                    }

                    elementTypes = elementTypesBuilder.ToImmutable();
                    elementNames = elementNamesBuilder.ToImmutable();
                    return true;
                }
                finally
                {
                    elementTypesBuilder.Free();
                    elementNamesBuilder.Free();
                }
            }
```

there appears to be an `else` missing when we test `expr.IsKind`. This causes the caller to attempt to produce a tuple type with an insufficient number of elements.</Description>
        <CreatedDate>24/11/2016</CreatedDate>
        <ClosedDate>07/04/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>18489</PullRequestID>
      <File>src/Compilers/CSharp/Portable/SymbolDisplay/SymbolDisplayVisitor.Types.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTupleTest.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/SymbolDisplay/SymbolDisplayTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/CodeActions/ExtractMethod/ExtractMethodTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/QuickInfo/SemanticQuickInfoSourceTests.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Test/ExpressionCompiler/TupleTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>18444</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Removes control type from NavBar's accessible names</Title>
    <Description>This fixes #18443 - Accessible name should not contain the type of the control.

Narrator automatically adds the control type, which means that with this fix in place, hitting Ctrl+F2 as described in #18443 will make Narrator say "Projects, WpfApp1, ComboBox"

Screenshot from AccEvent:
![image](https://cloud.githubusercontent.com/assets/1673956/24684004/cb86c96c-1957-11e7-83f5-4b0c6ac73c0c.png)
</Description>
    <CreatedDate>04/04/2017</CreatedDate>
    <ClosedDate>14/04/2017</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>18444</PullRequestID>
        <IssueID>18443</IssueID>
        <Title>Accessibility: Narrator says control type twice in the navigation bar </Title>
        <Description>Copied from [VSO tracker](https://devdiv.visualstudio.com/DevDiv/_workitems/edit/394818)

**Version Used**: master

**Steps to Reproduce**:

1. Launch Visual Studio
2. Create a New WPF Project
3. Tab to the editor that is present in the .cs file
4. Press CONTROL +F2 to navigate to the combo boxes.

**Expected Behavior**:
Name property should be appropriate and should not contain any localized control type

**Actual Behavior**:
Name property is 'Memberdropdown'
Narrator reads as 'Member drop down, &lt;name&gt;, Combo box'</Description>
        <CreatedDate>04/04/2017</CreatedDate>
        <ClosedDate>14/04/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>18444</PullRequestID>
        <IssueID>18443</IssueID>
        <Title>Accessibility: Narrator says control type twice in the navigation bar </Title>
        <Description>Copied from [VSO tracker](https://devdiv.visualstudio.com/DevDiv/_workitems/edit/394818)

**Version Used**: master

**Steps to Reproduce**:

1. Launch Visual Studio
2. Create a New WPF Project
3. Tab to the editor that is present in the .cs file
4. Press CONTROL +F2 to navigate to the combo boxes.

**Expected Behavior**:
Name property should be appropriate and should not contain any localized control type

**Actual Behavior**:
Name property is 'Memberdropdown'
Narrator reads as 'Member drop down, &lt;name&gt;, Combo box'</Description>
        <CreatedDate>04/04/2017</CreatedDate>
        <ClosedDate>14/04/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>18444</PullRequestID>
      <File>src/EditorFeatures/Core/Extensibility/NavigationBar/NavigationBarAutomationStrings.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>16597</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Don't emit casing-related naming violations when the violating character has no casing (making the feature noisy/unusable in other cultures)</Title>
    <Description>Fixes #15326, #15486

Escrow Template
================

**Customer scenario**: A Japanese user (for example) has the default Naming Styles applied but uses an identifier where the first character is neither upper-case nor lower-case. We currently flag this as a violation of that Naming Style. Note that this will be their default experience out-of-the-box.

**Bugs this fixes:** #15326, #15486

**Workarounds, if any:** They can manually turn off all Naming Rules.

**Risk**: Low. We just add a check to see if the character being inspected has casing at all to 4 different places. This is specific to the Naming Styles feature, and nothing else relies on this code.

**Performance impact**: For the more common naming styles, it can create an additional struct per symbol (the .ToUpper or .ToLower'd version of the first character). For the less common naming styles, it can create an additional struct per character in each symbol analyzed.

**Is this a regression from a previous update?** No.

**Root cause analysis:** It was missed as part of the original feature work. There are unit tests to validate and protect against regressions.

**How was the bug found?** Customer reports and dogfooding.</Description>
    <CreatedDate>18/01/2017</CreatedDate>
    <ClosedDate>20/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>16597</PullRequestID>
        <IssueID>15326</IssueID>
        <Title>Naming style "require uppercase" doesn't allow numerics or non-Latin characters</Title>
        <Description>From: https://developercommunity.visualstudio.com/content/problem/2440/uppercase-naming-with-number.html

```C#
internal enum ButtonState : uint
{
    FROM_LEFT_1ST_BUTTON_PRESSED = 0x01,
    RIGHTMOST_BUTTON_PRESSED = 0x02,
    FROM_LEFT_2ND_BUTTON_PRESSED = 0x04,
    FROM_LEFT_3RD_BUTTON_PRESSED = 0x08,
    FROM_LEFT_4TH_BUTTON_PRESSED = 0x10
}
```

All of the enums that contain a number 1,2,3,4 fail the naming convention of uppercase.  Is there anyway to configure naming to force uppercase and allow numbers?</Description>
        <CreatedDate>17/11/2016</CreatedDate>
        <ClosedDate>20/01/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>16597</PullRequestID>
        <IssueID>15486</IssueID>
        <Title>The naming rule violation is inadequate for non-Latin languages</Title>
        <Description>**Version Used**: 

Visual Studio 2017 RC

**Steps to Reproduce**:

1. Use Japanese characters for identifiers

**Expected Behavior**:

There is no message.

**Actual Behavior**:

The code analyzer says "Naming rule violation: These words must begin with upper case characters".

![image](https://cloud.githubusercontent.com/assets/3760955/20550074/54470168-b175-11e6-9e91-c85d06d6ccce.png)

However, Japanese characters don't have such a classification. There is no upper case in Japanese characters. This message may be inadequate for many non-Latin languages.

You should not simply use `char.IsLower`/`IsUpper` methods for this purpose.
https://github.com/dotnet/roslyn/blob/7a105a46a735d8c3b21a9c1990cecbe6ac4dde8c/src/Features/Core/Portable/Diagnostics/Analyzers/NamingStyles/Serialization/NamingStyle.cs#L136
</Description>
        <CreatedDate>23/11/2016</CreatedDate>
        <ClosedDate>31/12/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>16597</PullRequestID>
        <IssueID>15326</IssueID>
        <Title>Naming style "require uppercase" doesn't allow numerics or non-Latin characters</Title>
        <Description>From: https://developercommunity.visualstudio.com/content/problem/2440/uppercase-naming-with-number.html

```C#
internal enum ButtonState : uint
{
    FROM_LEFT_1ST_BUTTON_PRESSED = 0x01,
    RIGHTMOST_BUTTON_PRESSED = 0x02,
    FROM_LEFT_2ND_BUTTON_PRESSED = 0x04,
    FROM_LEFT_3RD_BUTTON_PRESSED = 0x08,
    FROM_LEFT_4TH_BUTTON_PRESSED = 0x10
}
```

All of the enums that contain a number 1,2,3,4 fail the naming convention of uppercase.  Is there anyway to configure naming to force uppercase and allow numbers?</Description>
        <CreatedDate>17/11/2016</CreatedDate>
        <ClosedDate>20/01/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>16597</PullRequestID>
        <IssueID>15486</IssueID>
        <Title>The naming rule violation is inadequate for non-Latin languages</Title>
        <Description>**Version Used**: 

Visual Studio 2017 RC

**Steps to Reproduce**:

1. Use Japanese characters for identifiers

**Expected Behavior**:

There is no message.

**Actual Behavior**:

The code analyzer says "Naming rule violation: These words must begin with upper case characters".

![image](https://cloud.githubusercontent.com/assets/3760955/20550074/54470168-b175-11e6-9e91-c85d06d6ccce.png)

However, Japanese characters don't have such a classification. There is no upper case in Japanese characters. This message may be inadequate for many non-Latin languages.

You should not simply use `char.IsLower`/`IsUpper` methods for this purpose.
https://github.com/dotnet/roslyn/blob/7a105a46a735d8c3b21a9c1990cecbe6ac4dde8c/src/Features/Core/Portable/Diagnostics/Analyzers/NamingStyles/Serialization/NamingStyle.cs#L136
</Description>
        <CreatedDate>23/11/2016</CreatedDate>
        <ClosedDate>31/12/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>16597</PullRequestID>
      <File>src/Workspaces/Core/Portable/NamingStyles/NamingStyle.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>16593</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Expand the lifetime of locals declared within CasePatternSwitchLabelSyntax to the entire switch body.</Title>
    <Description>**Customer scenario**
When a lambda or a local function references a local declared within CasePatternSwitchLabelSyntax, either compiler crashes or an application crashes at runtime because corresponding closure isn't properly initialized.  

**Bugs this fixes:** 
Fixes #15536. 
Fixes #16066. 
Tracked by VSO https://devdiv.visualstudio.com/DevDiv/_workitems?id=369824

**Workarounds, if any**
Avoid directly referencing such locals in a lambda or a local function. 

**Risk**
Low. The fix is a targeted change for a pattern switch feature, which is the only feature affected by this issue. 

**Performance impact**
Low. We allocate one additional bound tree node per switch section with locals.

**Is this a regression from a previous update?**
No. New feature.

**Root cause analysis:**
A test gap for a new feature. Tests added.

**How was the bug found?**
Customer reported.

@dotnet/roslyn-compiler, @gafter, @agocke Please review.  </Description>
    <CreatedDate>18/01/2017</CreatedDate>
    <ClosedDate>19/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>16593</PullRequestID>
        <IssueID>15536</IssueID>
        <Title>Bad codegen in call-forward to local function in different switch block</Title>
        <Description>From #15322:

```csharp
class Program
{
    static void Main(string[] args)
    {
        object o = null;
        switch (o)
        {
            case string x:
                Assign();
                Foo();
                break;
            case int x:
                void Assign() { x = 5; }
                void Foo() =&gt; System.Console.WriteLine(x);
                break;
        }
    }
}
```

The problem seems to be getting the information for the local in CodeGen. It's not clear if this is an issue </Description>
        <CreatedDate>26/11/2016</CreatedDate>
        <ClosedDate>19/01/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>16593</PullRequestID>
        <IssueID>16066</IssueID>
        <Title>Pattern matching crashes if lambda captures pattern variable</Title>
        <Description>**Version Used**: 
Microsoft Visual Studio Enterprise 2017 RC
Version 15.0.26014.0 D15REL
Microsoft .NET Framework
Version 4.6.01055

**Steps to Reproduce**:
Run the following app:

```
using System.Collections.Generic;
using System.Linq;

namespace ConsoleApp2017
{
    class Program
    {
        class A
        {
        }
        
        static void Main(string[] args)
        {                           
            var dummy = new List&lt;int&gt;();

            switch((object)new A())
            {
                case A a:
                    {
                        dummy.Any(x =&gt; a != null);
                    }
                    break;
            }
        }
    }
}
```
**Expected Behavior**:
App just runs, no output.

**Actual Behavior**:
Null-reference on the switch statement, when trying to initialize not created instance of a hidden class &lt;&gt;c__DisplayClass27_0 CS$&lt;&gt;8__locals0;

Unhandled Exception: System.NullReferenceException: Object reference not set to an instance of an object.
   at ConsoleApp2017.Program.Main(String[] args) in D:\Temp\ConsoleApp2017\ConsoleApp2017\Program.cs:line 16
</Description>
        <CreatedDate>22/12/2016</CreatedDate>
        <ClosedDate>19/01/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>16593</PullRequestID>
      <File>src/Compilers/CSharp/Portable/CodeGen/EmitStatement.cs</File>
      <File>src/Compilers/CSharp/Portable/CodeGen/Optimizer.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/PreciseAbstractFlowPass.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/LambdaCapturedVariable.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/LambdaRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_PatternSwitchStatement.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/MethodToClassRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/StateMachineRewriter/MethodToStateMachineRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/LocalSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceLocalSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedLocal.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/TypeSubstitutedLocalSymbol.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/PDB/PDBTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/LocalFunctionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternSwitchTests.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Source/ExpressionCompiler/Symbols/EELocalSymbolBase.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Test/ExpressionCompiler/LocalsTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>16592</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Change the order of operands to object.Equals() for constant pattern match</Title>
    <Description>**Customer scenario**

The semantics of pattern-matching against a constant are different between the `is` operator and the `switch` statement. They were intended to be the same, but the order of operands to `object.Equals` in the generated code is backwards for the `is` operator. We need to fix this today, before RTM, so that users do not come to depend on the incorrect behavior (now-or-never language change). See also #16513.

**Bugs this fixes:** 

Fixes #16513

**Workarounds, if any**

Avoid using the new `is` operator with a constant right-hand-side.

**Risk**

Tiny. The fix is a one-line change to place the operands in the correct order.

**Performance impact**

None, as we are still executing the same code as before, albeit in a different order. However, with the changed order it will be possible for us to generate much better code in the future.

**Is this a regression from a previous update?**

No, as the feature is new.

**Root cause analysis:**

A subtle oversight in code generation. This might have been caught earlier if the compiler team had followed through on its plan to assign a developer to perform adversarial testing of each new feature under development.

**How was the bug found?**

Customer reported.

@dotnet/roslyn-compiler Please review this teensy tiny RTM fix.
</Description>
    <CreatedDate>18/01/2017</CreatedDate>
    <ClosedDate>19/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>16592</PullRequestID>
        <IssueID>16513</IssueID>
        <Title>The semantic of constant pattern</Title>
        <Description>I propose to change the semantic of constant pattern match from current:
```c#
foo is 42 /* == */ object.Equals(foo, 42)
```
‚Ä¶to the opposite:
```c#
foo is 42 /* == */ object.Equals(42, foo)
```

And this is how `object.Equals(object, object)` is implemented:
```c#
public static bool Equals(Object objA, Object objB) {
  if (objA==objB) {
    return true;
  }
  if (objA==null || objB==null) {
    return false;
  }
  return objA.Equals(objB);
}
```

The reasons behind proposed change:
1. Currently the "constant patterns" are not that "constant": generated code involves the execution of arbitrary 'object.Equals(object)' implementation on `foo` instance (in the case it is not `null`), since `object.Equals(object, object)` invokes it on first argument.
2. The idiom `foo is null` do not actually means `((object) foo) == null` as most of users would expect. It is easy to define a type that would pass `foo is null` check while being not-`null` (how would this play with future non-nullable types and their dataflow analysis?).
3. You won't be able to get rid of suboptimal code for constant patterns of reference types #13247, since such optimizations would change the semantic of matching.
4. If the arguments of `object.Equals()` would be reversed, the nice property of `is` expression would be restored ‚Äî if right operand (type or pattern) has a type, the `is` expression only produce `true` if the left operand is of implicitly convertible type. Constant patterns do have types, literal expression do have types, `42` is of type `int`‚Ä¶ who would expect `(int) foo` after successful `foo is 42` check to throw `InvalidCastException`?

p.s. Maybe it's a good idea to behave like F#: literal patterns of type `int` are only allowed when pattern is matched against the value of `int` type (but that's because of ML's "no implicit conversions" rule, I think).

cc @gafter</Description>
        <CreatedDate>14/01/2017</CreatedDate>
        <ClosedDate>19/01/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>16592</PullRequestID>
        <IssueID>16513</IssueID>
        <Title>The semantic of constant pattern</Title>
        <Description>I propose to change the semantic of constant pattern match from current:
```c#
foo is 42 /* == */ object.Equals(foo, 42)
```
‚Ä¶to the opposite:
```c#
foo is 42 /* == */ object.Equals(42, foo)
```

And this is how `object.Equals(object, object)` is implemented:
```c#
public static bool Equals(Object objA, Object objB) {
  if (objA==objB) {
    return true;
  }
  if (objA==null || objB==null) {
    return false;
  }
  return objA.Equals(objB);
}
```

The reasons behind proposed change:
1. Currently the "constant patterns" are not that "constant": generated code involves the execution of arbitrary 'object.Equals(object)' implementation on `foo` instance (in the case it is not `null`), since `object.Equals(object, object)` invokes it on first argument.
2. The idiom `foo is null` do not actually means `((object) foo) == null` as most of users would expect. It is easy to define a type that would pass `foo is null` check while being not-`null` (how would this play with future non-nullable types and their dataflow analysis?).
3. You won't be able to get rid of suboptimal code for constant patterns of reference types #13247, since such optimizations would change the semantic of matching.
4. If the arguments of `object.Equals()` would be reversed, the nice property of `is` expression would be restored ‚Äî if right operand (type or pattern) has a type, the `is` expression only produce `true` if the left operand is of implicitly convertible type. Constant patterns do have types, literal expression do have types, `42` is of type `int`‚Ä¶ who would expect `(int) foo` after successful `foo is 42` check to throw `InvalidCastException`?

p.s. Maybe it's a good idea to behave like F#: literal patterns of type `int` are only allowed when pattern is matched against the value of `int` type (but that's because of ML's "no implicit conversions" rule, I think).

cc @gafter</Description>
        <CreatedDate>14/01/2017</CreatedDate>
        <ClosedDate>19/01/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>16592</PullRequestID>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_Patterns.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>16589</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Do not fail in the NamingStyleCodeFix when we cannot find the symbol (causes the failure InfoBar to be shown)</Title>
    <Description>Fixes #15788 


We should always be able to find the symbol that generated this
diagnostic, but this cannot always be done by simply asking for the
declared symbol on the node from the symbol's declaration location.
Issue #16588 is tracking a more complete fix for this that always
successfully finds the symbol.

Escrow Template
================

**Customer scenario**: In the known cases of this, the customer has an invalid declaration that we believe violates naming rules. We issue the naming violation diagnostic, but then the CodeFix for it fails and shows the infobar.

**Bugs this fixes:** #15788 

**Workarounds, if any:** It can be avoided in the first place by deleting all Naming Rules. Once the error has happened, the InfoBar shows and the user can disable Naming Rules for the rest of the VS session, or re-enable it.

**Risk**: Low. This just introduces a null check and does not provide a CodeFix if we cannot find the symbol with the offending name. Nothing sits on top of this code.

**Performance impact**: None. This is just a null check.

**Is this a regression from a previous update?**: No.

**Root cause analysis:** Not enough testing was initially done around the analysis and fixing of invalid identifiers.

**How was the bug found?** Dogfooding</Description>
    <CreatedDate>18/01/2017</CreatedDate>
    <ClosedDate>20/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>16589</PullRequestID>
        <IssueID>15788</IssueID>
        <Title>NamingStyleCodeFixProvider crashes on const readonly</Title>
        <Description>Obviously not a normal scenario, but for the moment that I had `const readonly`, the naming style code fix provider crashed. Possibly related rules (in precedence order):
(Private|Protected) Static Readonly (Property|Field) -&gt; PascalCase
(Internal|Private|Protected|Protected Internal) Static Field -&gt; s_ prefix.

Tested on d15rel/26008.00.

```
System.NullReferenceException : Object reference not set to an instance of an object.
   at async Microsoft.CodeAnalysis.CodeFixes.NamingStyles.NamingStyleCodeFixProvider.RegisterCodeFixesAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.Extensions.IExtensionManagerExtensions.PerformActionAsync(&lt;Unknown Parameters&gt;)
   at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject)
```</Description>
        <CreatedDate>08/12/2016</CreatedDate>
        <ClosedDate>20/01/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>16589</PullRequestID>
        <IssueID>16588</IssueID>
        <Title>NamingStyleCodeFixProvider should always be able to find the symbol that generated the diagnostic</Title>
        <Description>As an example of where it cannot, see https://github.com/dotnet/roslyn/issues/15788</Description>
        <CreatedDate>18/01/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>16589</PullRequestID>
        <IssueID>15788</IssueID>
        <Title>NamingStyleCodeFixProvider crashes on const readonly</Title>
        <Description>Obviously not a normal scenario, but for the moment that I had `const readonly`, the naming style code fix provider crashed. Possibly related rules (in precedence order):
(Private|Protected) Static Readonly (Property|Field) -&gt; PascalCase
(Internal|Private|Protected|Protected Internal) Static Field -&gt; s_ prefix.

Tested on d15rel/26008.00.

```
System.NullReferenceException : Object reference not set to an instance of an object.
   at async Microsoft.CodeAnalysis.CodeFixes.NamingStyles.NamingStyleCodeFixProvider.RegisterCodeFixesAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.Extensions.IExtensionManagerExtensions.PerformActionAsync(&lt;Unknown Parameters&gt;)
   at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject)
```</Description>
        <CreatedDate>08/12/2016</CreatedDate>
        <ClosedDate>20/01/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>16589</PullRequestID>
      <File>src/Features/Core/Portable/CodeFixes/NamingStyle/AbstractNamingStyleCodeFixProvider.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>16586</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Avoid GUID conflicts for Naming Styles Symbol Specifications (causes Naming Styles to not work and the Tools | Options page to not load)</Title>
    <Description>Fixes #16431

Escrow Template
================

**Customer scenario**: The user adds two Naming Styles Symbol Specifications in the same VS session, and the Naming Styles analyzer stops working altogether, and the Naming Styles Tools | Options page will no longer load if one of these symbol specifications are actually used in a rule.

**Bugs this fixes:** #16431

**Workarounds, if any**: The user can only add one Symbol Specification per VS session. Once two have been added, fixing it requires manual edits to your CurrentSettings.vssettings file.

**Risk**: Very low. This code is in the Naming Styles option pages code, and nothing sits on top of that layer. It's essentially the same code as before, we just create a new guid for each new Symbol Specification instead of accidentally caching the guid.

**Performance impact**: We make a new SymbolSpecification object each time the user adds a symbol specification, but that is extremely minor and is done extremely infrequently.

**Is this a regression from a previous update?** Yes, this is a regression from RC.2

**Root cause analysis:** I believe a refactoring was done as part of a larger effort which introduced the caching of the new Symbol Specification guid.

**How was the bug found?**: Ad-hoc testing</Description>
    <CreatedDate>18/01/2017</CreatedDate>
    <ClosedDate>20/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>16586</PullRequestID>
        <IssueID>16431</IssueID>
        <Title>Naming Styles can be completely broken by adding multiple specifications</Title>
        <Description>To the point where the option page won't even load.

Rough repro steps:
1. Add two symbol specifications
2. Create two rules, that use the two symbol specifications
3. Save the options. Try to reopen the option page. It'll fail to load.

It doesn't repro if you do the analogous thing with Styles instead of Specifications.</Description>
        <CreatedDate>11/01/2017</CreatedDate>
        <ClosedDate>20/01/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>16586</PullRequestID>
        <IssueID>16431</IssueID>
        <Title>Naming Styles can be completely broken by adding multiple specifications</Title>
        <Description>To the point where the option page won't even load.

Rough repro steps:
1. Add two symbol specifications
2. Create two rules, that use the two symbol specifications
3. Save the options. Try to reopen the option page. It'll fail to load.

It doesn't repro if you do the analogous thing with Styles instead of Specifications.</Description>
        <CreatedDate>11/01/2017</CreatedDate>
        <ClosedDate>20/01/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>16586</PullRequestID>
      <File>src/VisualStudio/Core/Impl/Options/Style/NamingPreferences/SymbolSpecification/SymbolSpecificationViewModel.cs</File>
      <File>src/Workspaces/Core/Portable/NamingStyles/Serialization/NamingStylePreferences.cs</File>
      <File>src/Workspaces/Core/Portable/NamingStyles/Serialization/SymbolSpecification.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>16569</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Harden pattern-matching binding in error cases.</Title>
    <Description>**Customer scenario**

Code using the new pattern-matching feature, and some erroneous code using the existing is-expression, can cause the compiler to crash.

**Bugs this fixes:** 

Fixes https://devdiv.visualstudio.com/DefaultCollection/DevDiv/_workitems?id=336030
Fixes https://devdiv.visualstudio.com/DefaultCollection/DevDiv/_workitems?id=294570
Fixes https://devdiv.visualstudio.com/DefaultCollection/DevDiv/_workitems?id=368942
Fixes https://devdiv.visualstudio.com/DefaultCollection/DevDiv/_workitems?id=363714
Fixes https://devdiv.visualstudio.com/DefaultCollection/DevDiv/_workitems?id=364165
Fixes #16296
Also adds test for #16559 

**Workarounds, if any**

Don't use the new features, and don't make any mistakes when using the is-operator.

**Risk**

Low; this is the addition of error-reporting and defensive code to handle error conditions.

**Performance impact**

Low; No additional allocations on normal code paths.

**Is this a regression from a previous update?**

Yes: the crash on erroneous use of the is-operator is a regression.

**Root cause analysis:**

Insufficient test coverage. Lack of dedicated testing team. Failure to follow through on our engineering test plan to pair a developer to "break" each feature under development.

**How was the bug found?**

These were all customer reported.
</Description>
    <CreatedDate>17/01/2017</CreatedDate>
    <ClosedDate>19/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>16569</PullRequestID>
        <IssueID>16296</IssueID>
        <Title>ArgumentNullException binding a pattern switch</Title>
        <Description>When running some custom static code analysis on Roslyn.sln, I get an "Unknown hard error". In the Windows EventViewer, I find the following error:
```
Application: csc.exe
Framework Version: v4.0.30319
Description: The application requested process termination through System.Environment.FailFast(string message).
Message: System.ArgumentNullException: Value cannot be null.
Parameter name: key
   at System.Collections.Generic.Dictionary`2.FindEntry(TKey key)
   at System.Collections.Generic.Dictionary`2.TryGetValue(TKey key, TValue&amp; value)
   at Microsoft.CodeAnalysis.CSharp.SubsumptionDiagnosticBuilder.CheckSubsumed(BoundPattern pattern, DecisionTree decisionTree, Boolean inputCouldBeNull)
   at Microsoft.CodeAnalysis.CSharp.SubsumptionDiagnosticBuilder.CheckSubsumed(BoundPattern pattern, DecisionTree decisionTree, Boolean inputCouldBeNull)
   at Microsoft.CodeAnalysis.CSharp.SubsumptionDiagnosticBuilder.AddLabel(BoundPatternSwitchLabel label, DiagnosticBag diagnostics, Boolean&amp; valueMatched)
   at Microsoft.CodeAnalysis.CSharp.PatternSwitchBinder.BindPatternSwitchSection(BoundExpression boundSwitchExpression, SwitchSectionSyntax node, Binder originalBinder, BoundPatternSwitchLabel&amp; defaultLabel, Boolean&amp; someValueMatched, SubsumptionDiagnosticBuilder subsumption, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.PatternSwitchBinder.BindPatternSwitchSections(BoundExpression boundSwitchExpression, SyntaxList`1 sections, Binder originalBinder, BoundPatternSwitchLabel&amp; defaultLabel, Boolean&amp; isComplete, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.PatternSwitchBinder.BindSwitchExpressionAndSections(SwitchStatementSyntax node, Binder originalBinder, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindBlockParts(BlockSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.ForLoopBinder.BindForParts(ForStatementSyntax node, Binder originalBinder, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindBlockParts(BlockSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.BindMethodBody(MethodSymbol method, TypeCompilationState compilationState, DiagnosticBag diagnostics, ImportChain&amp; importChain, Boolean&amp; originalBodyNested)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethod(MethodSymbol methodSymbol, Int32 methodOrdinal, ProcessedFieldInitializers&amp; processedInitializers, SynthesizedSubmissionFields previousSubmissionFields, TypeCompilationState compilationState)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(NamedTypeSymbol containingType)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.&lt;&gt;c__DisplayClass20_0.&lt;CompileNamedTypeAsTask&gt;b__0()
Stack:
   at System.Environment.FailFast(System.String, System.Exception)
   at Microsoft.CodeAnalysis.FatalError.Report(System.Exception, System.Action`1&lt;System.Exception&gt;)
   at Microsoft.CodeAnalysis.FatalError.ReportUnlessCanceled(System.Exception)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler+&lt;&gt;c__DisplayClass20_0.&lt;CompileNamedTypeAsTask&gt;b__0()
   at System.Collections.Generic.Dictionary`2[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089],[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].FindEntry(System.__Canon)
   at System.Collections.Generic.Dictionary`2[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089],[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].TryGetValue(System.__Canon, System.__Canon ByRef)
   at Microsoft.CodeAnalysis.CSharp.SubsumptionDiagnosticBuilder.CheckSubsumed(Microsoft.CodeAnalysis.CSharp.BoundPattern, Microsoft.CodeAnalysis.CSharp.DecisionTree, Boolean)
   at Microsoft.CodeAnalysis.CSharp.SubsumptionDiagnosticBuilder.CheckSubsumed(Microsoft.CodeAnalysis.CSharp.BoundPattern, Microsoft.CodeAnalysis.CSharp.DecisionTree, Boolean)
   at Microsoft.CodeAnalysis.CSharp.SubsumptionDiagnosticBuilder.AddLabel(Microsoft.CodeAnalysis.CSharp.BoundPatternSwitchLabel, Microsoft.CodeAnalysis.DiagnosticBag, Boolean ByRef)
   at Microsoft.CodeAnalysis.CSharp.PatternSwitchBinder.BindPatternSwitchSection(Microsoft.CodeAnalysis.CSharp.BoundExpression, Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax, Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.CSharp.BoundPatternSwitchLabel ByRef, Boolean ByRef, Microsoft.CodeAnalysis.CSharp.SubsumptionDiagnosticBuilder, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.PatternSwitchBinder.BindPatternSwitchSections(Microsoft.CodeAnalysis.CSharp.BoundExpression, Microsoft.CodeAnalysis.SyntaxList`1&lt;Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax&gt;, Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.CSharp.BoundPatternSwitchLabel ByRef, Boolean ByRef, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.PatternSwitchBinder.BindSwitchExpressionAndSections(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax, Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindBlockParts(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.ForLoopBinder.BindForParts(Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax, Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindBlockParts(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.BindMethodBody(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol, Microsoft.CodeAnalysis.CSharp.TypeCompilationState, Microsoft.CodeAnalysis.DiagnosticBag, Microsoft.CodeAnalysis.CSharp.ImportChain ByRef, Boolean ByRef)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethod(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol, Int32, ProcessedFieldInitializers ByRef, Microsoft.CodeAnalysis.CSharp.SynthesizedSubmissionFields, Microsoft.CodeAnalysis.CSharp.TypeCompilationState)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler+&lt;&gt;c__DisplayClass20_0.&lt;CompileNamedTypeAsTask&gt;b__0()
   at Roslyn.Utilities.UICultureUtilities+&lt;&gt;c__DisplayClass5_0.&lt;WithCurrentUICulture&gt;b__0()
   at System.Threading.Tasks.Task.Execute()
   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)
   at System.Threading.Tasks.Task.ExecuteEntry(Boolean)
   at System.Threading.Tasks.ThreadPoolTaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task, Boolean)
   at System.Threading.Tasks.TaskScheduler.TryRunInline(System.Threading.Tasks.Task, Boolean)
   at System.Threading.Tasks.Task.WrappedTryRunInline()
   at System.Threading.Tasks.Task.InternalWait(Int32, System.Threading.CancellationToken)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(System.Threading.Tasks.Task)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.WaitForWorkers()
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethodBodies(Microsoft.CodeAnalysis.CSharp.CSharpCompilation, Microsoft.CodeAnalysis.CSharp.Emit.PEModuleBuilder, Boolean, Boolean, Microsoft.CodeAnalysis.DiagnosticBag, System.Predicate`1&lt;Microsoft.CodeAnalysis.CSharp.Symbol&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnosticsForAllMethodBodies(Microsoft.CodeAnalysis.DiagnosticBag, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnostics(Microsoft.CodeAnalysis.CompilationStage, Boolean, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnostics(System.Threading.CancellationToken)
   at SonarAnalyzer.Rules.CSharp.PrivateFieldUsedAsLocalVariable.ExcludePrivateFieldsBasedOnCompilerErrors(System.Collections.Immutable.IImmutableDictionary`2&lt;Microsoft.CodeAnalysis.ISymbol,PrivateField&gt;, System.Collections.Generic.IDictionary`2&lt;Microsoft.CodeAnalysis.ISymbol,System.Collections.Generic.IDictionary`2&lt;Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.ISymbol&gt;&gt;, System.Collections.Immutable.IImmutableSet`1&lt;Microsoft.CodeAnalysis.ISymbol&gt;, Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax)
   at SonarAnalyzer.Rules.CSharp.PrivateFieldUsedAsLocalVariable+&lt;&gt;c.&lt;Initialize&gt;b__9_0(Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext)
   at SonarAnalyzer.Helpers.DiagnosticAnalyzerContextHelper+&lt;&gt;c__DisplayClass0_0`1[[Microsoft.CodeAnalysis.CSharp.SyntaxKind, Microsoft.CodeAnalysis.CSharp, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]].&lt;RegisterSyntaxNodeActionInNonGenerated&gt;b__0(Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext)
   at SonarAnalyzer.Helpers.SonarAnalysisContext+&lt;&gt;c__DisplayClass12_0`1[[Microsoft.CodeAnalysis.CSharp.SyntaxKind, Microsoft.CodeAnalysis.CSharp, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]].&lt;RegisterSyntaxNodeAction&gt;b__0(Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor+&lt;&gt;c__DisplayClass42_1`1[[Microsoft.CodeAnalysis.CSharp.SyntaxKind, Microsoft.CodeAnalysis.CSharp, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]].&lt;ExecuteSyntaxNodeAction&gt;b__1()
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.ExecuteAndCatchIfThrows_NoLock(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer, System.Action, System.Nullable`1&lt;Microsoft.CodeAnalysis.Diagnostics.AnalysisContextInfo&gt;)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.ExecuteAndCatchIfThrows(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer, System.Action, System.Nullable`1&lt;Microsoft.CodeAnalysis.Diagnostics.AnalysisContextInfo&gt;)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.ExecuteSyntaxNodeAction[[Microsoft.CodeAnalysis.CSharp.SyntaxKind, Microsoft.CodeAnalysis.CSharp, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalyzerAction`1&lt;Microsoft.CodeAnalysis.CSharp.SyntaxKind&gt;, Microsoft.CodeAnalysis.SyntaxNode, Microsoft.CodeAnalysis.ISymbol, Microsoft.CodeAnalysis.SemanticModel, System.Action`1&lt;Microsoft.CodeAnalysis.Diagnostic&gt;, SyntaxNodeAnalyzerStateData)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.ExecuteSyntaxNodeActions[[Microsoft.CodeAnalysis.CSharp.SyntaxKind, Microsoft.CodeAnalysis.CSharp, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](Microsoft.CodeAnalysis.SyntaxNode, System.Collections.Generic.IDictionary`2&lt;Microsoft.CodeAnalysis.CSharp.SyntaxKind,System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalyzerAction`1&lt;Microsoft.CodeAnalysis.CSharp.SyntaxKind&gt;&gt;&gt;, Microsoft.CodeAnalysis.ISymbol, Microsoft.CodeAnalysis.SemanticModel, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.SyntaxKind&gt;, System.Action`1&lt;Microsoft.CodeAnalysis.Diagnostic&gt;, SyntaxNodeAnalyzerStateData)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.ExecuteSyntaxNodeActions[[Microsoft.CodeAnalysis.CSharp.SyntaxKind, Microsoft.CodeAnalysis.CSharp, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](System.Collections.Generic.IEnumerable`1&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;, System.Collections.Generic.IDictionary`2&lt;Microsoft.CodeAnalysis.CSharp.SyntaxKind,System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalyzerAction`1&lt;Microsoft.CodeAnalysis.CSharp.SyntaxKind&gt;&gt;&gt;, Microsoft.CodeAnalysis.ISymbol, Microsoft.CodeAnalysis.SemanticModel, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.SyntaxKind&gt;, System.Action`1&lt;Microsoft.CodeAnalysis.Diagnostic&gt;, SyntaxNodeAnalyzerStateData)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.ExecuteSyntaxNodeActionsCore[[Microsoft.CodeAnalysis.CSharp.SyntaxKind, Microsoft.CodeAnalysis.CSharp, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](System.Collections.Generic.IEnumerable`1&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;, System.Collections.Generic.IDictionary`2&lt;Microsoft.CodeAnalysis.CSharp.SyntaxKind,System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalyzerAction`1&lt;Microsoft.CodeAnalysis.CSharp.SyntaxKind&gt;&gt;&gt;, Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer, Microsoft.CodeAnalysis.ISymbol, Microsoft.CodeAnalysis.SemanticModel, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.SyntaxKind&gt;, Microsoft.CodeAnalysis.Text.TextSpan, SyntaxNodeAnalyzerStateData, Boolean)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.TryExecuteSyntaxNodeActions[[Microsoft.CodeAnalysis.CSharp.SyntaxKind, Microsoft.CodeAnalysis.CSharp, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](System.Collections.Generic.IEnumerable`1&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;, System.Collections.Generic.IDictionary`2&lt;Microsoft.CodeAnalysis.CSharp.SyntaxKind,System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalyzerAction`1&lt;Microsoft.CodeAnalysis.CSharp.SyntaxKind&gt;&gt;&gt;, Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer, Microsoft.CodeAnalysis.SemanticModel, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.SyntaxKind&gt;, Microsoft.CodeAnalysis.Text.TextSpan, Microsoft.CodeAnalysis.SyntaxReference, Int32, Microsoft.CodeAnalysis.ISymbol, Microsoft.CodeAnalysis.Diagnostics.AnalysisScope, Microsoft.CodeAnalysis.Diagnostics.AnalysisState, Boolean)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver`1[[Microsoft.CodeAnalysis.CSharp.SyntaxKind, Microsoft.CodeAnalysis.CSharp, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]].TryExecuteDeclaringReferenceActions(Microsoft.CodeAnalysis.SyntaxReference, Int32, Microsoft.CodeAnalysis.Diagnostics.SymbolDeclaredCompilationEvent, Microsoft.CodeAnalysis.Diagnostics.AnalysisScope, Microsoft.CodeAnalysis.Diagnostics.AnalysisState, Boolean, Boolean, Boolean, Boolean, Boolean, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver`1[[Microsoft.CodeAnalysis.CSharp.SyntaxKind, Microsoft.CodeAnalysis.CSharp, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]].TryExecuteDeclaringReferenceActions(Microsoft.CodeAnalysis.Diagnostics.SymbolDeclaredCompilationEvent, Microsoft.CodeAnalysis.Diagnostics.AnalysisScope, Microsoft.CodeAnalysis.Diagnostics.AnalysisState, Boolean, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.TryProcessSymbolDeclared(Microsoft.CodeAnalysis.Diagnostics.SymbolDeclaredCompilationEvent, Microsoft.CodeAnalysis.Diagnostics.AnalysisScope, Microsoft.CodeAnalysis.Diagnostics.AnalysisState, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.TryProcessEventCore(Microsoft.CodeAnalysis.Diagnostics.CompilationEvent, Microsoft.CodeAnalysis.Diagnostics.AnalysisScope, Microsoft.CodeAnalysis.Diagnostics.AnalysisState, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver+&lt;ProcessCompilationEventsCoreAsync&gt;d__70.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].Start[[Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver+&lt;ProcessCompilationEventsCoreAsync&gt;d__70, Microsoft.CodeAnalysis, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;ProcessCompilationEventsCoreAsync&gt;d__70 ByRef)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.ProcessCompilationEventsCoreAsync(Microsoft.CodeAnalysis.Diagnostics.AnalysisScope, Microsoft.CodeAnalysis.Diagnostics.AnalysisState, Boolean, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver+&lt;&gt;c__DisplayClass69_0+&lt;&lt;ProcessCompilationEventsAsync&gt;b__0&gt;d.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].Start[[Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver+&lt;&gt;c__DisplayClass69_0+&lt;&lt;ProcessCompilationEventsAsync&gt;b__0&gt;d, Microsoft.CodeAnalysis, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;&lt;ProcessCompilationEventsAsync&gt;b__0&gt;d ByRef)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver+&lt;&gt;c__DisplayClass69_0.&lt;ProcessCompilationEventsAsync&gt;b__0()
   at System.Threading.Tasks.Task`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].InnerInvoke()
   at System.Threading.Tasks.Task.Execute()
   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)
   at System.Threading.Tasks.Task.ExecuteEntry(Boolean)
   at System.Threading.ThreadPoolWorkQueue.Dispatch()
```

I have no easy repro of the issue. But from the stacktrace it seems that `null` is being passed to the `TryGetValue` of the dictionary in `SubsumptionDiagnosticBuilder.CheckSubsumed`: `byValue.ValueAndDecision.TryGetValue(constantPattern.Value.ConstantValue.Value, out decision)`. 

Sidenote: I have no easy repro of the issue, because I can't identify what input source code and code analyzer produces this error. I'm trying to run a SonarQube analysis of the Roslyn project based on this: http://docs.sonarqube.org/display/SCAN/From+the+Command+Line. Internally what happens is that when `msbuild Roslyn.sln` is called, then a custom analyzer DLLs are being passed to CSC with the help of a targets file. In general this approach is working, and it was also working for the Roslyn.sln, however as the Roslyn.sln dogfeeds the latest CSC to itself, due to the above bug, the analysis also fails. </Description>
        <CreatedDate>06/01/2017</CreatedDate>
        <ClosedDate>19/01/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>16569</PullRequestID>
        <IssueID>16559</IssueID>
        <Title>Stack Overflow in BindPatternSwitchLabelForInference</Title>
        <Description>**Version Used**: VS2015 RC3

**Steps to Reproduce**:

Attempt to compile this code:

```cs
public class Program5815
{
    public static void Main(string[] args)
    {
        switch ((int)M())
        {
            case var x3:
            case true ? x3 : 4:
                break;
        }
    }
    private static object M() =&gt; null;
}
```

**Expected Behavior**: Compiler error about case label not being a constant

**Actual Behavior**: Compiler stack overflow

See also https://devdiv.visualstudio.com/DefaultCollection/DevDiv/_workitems?_a=edit&amp;id=369796</Description>
        <CreatedDate>17/01/2017</CreatedDate>
        <ClosedDate>25/01/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>16569</PullRequestID>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Operators.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/SubsumptionDiagnosticBuilder.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/DecisionTreeBuilder.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>16467</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Expression variables declared in a local function parameter default are given a scope</Title>
    <Description>**Customer scenario**

If you declare an expression variable (e.g. out variable) inside the default value
expression of a parameter to a local function, **the IDE crashes**.

**Bugs this fixes:** 

Fixes #16167

**Workarounds, if any**

Don't make that mistake.

**Risk**

Small. Corrects a small oversight in the implementation of the interaction of new language features.

**Performance impact**

Trivial.

**Is this a regression from a previous update?**

No.

**Root cause analysis:**

Missing test for interaction between multiple new language features. Lack of dedicated testing team. Lack of coordinated testing role for new features and interactions between new features.

**How was the bug found?**

Customer reported. It occurred accidentally when the customer pasted XML inside a method body instead of inside the doc comment.

@jcouv @cston previously reviewed this fix in #16315; this moves it to the rc3 branch.
</Description>
    <CreatedDate>12/01/2017</CreatedDate>
    <ClosedDate>13/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>16467</PullRequestID>
        <IssueID>16167</IssueID>
        <Title>VS crashes if xml is pasted in C# editor</Title>
        <Description>**Version Used**: 

**Steps to Reproduce**:

1. create new C# console app
2. paste text below as a body of `Main`
```xml
      &lt;summary&gt;Copies a range of elements from an &lt;see cref="T:System.Array" /&gt; starting at the first element and pastes them into another &lt;see cref="T:System.Array" /&gt; starting at the first element. The length is specified as a 32-bit integer.&lt;/summary&gt;
      &lt;param name="sourceArray"&gt;The &lt;see cref="T:System.Array" /&gt; that contains the data to copy.&lt;/param&gt;
      &lt;param name="destinationArray"&gt;The &lt;see cref="T:System.Array" /&gt; that receives the data.&lt;/param&gt;
      &lt;param name="length"&gt;A 32-bit integer that represents the number of elements to copy.&lt;/param&gt;
      &lt;exception cref="T:System.ArgumentNullException"&gt;
        &lt;paramref name="sourceArray" /&gt; is null.-or-&lt;paramref name="destinationArray" /&gt; is null.&lt;/exception&gt;
      &lt;exception cref="T:System.RankException"&gt;
        &lt;paramref name="sourceArray" /&gt; and &lt;paramref name="destinationArray" /&gt; have different ranks.&lt;/exception&gt;
      &lt;exception cref="T:System.ArrayTypeMismatchException"&gt;
        &lt;paramref name="sourceArray" /&gt; and &lt;paramref name="destinationArray" /&gt; are of incompatible types.&lt;/exception&gt;
      &lt;exception cref="T:System.InvalidCastException"&gt;At least one element in &lt;paramref name="sourceArray" /&gt; cannot be cast to the type of &lt;paramref name="destinationArray" /&gt;.&lt;/exception&gt;
      &lt;exception cref="T:System.ArgumentOutOfRangeException"&gt;
        &lt;paramref name="length" /&gt; is less than zero.&lt;/exception&gt;
      &lt;exception cref="T:System.ArgumentException"&gt;
        &lt;paramref name="length" /&gt; is greater than the number of elements in &lt;paramref name="sourceArray" /&gt;.-or-&lt;paramref name="length" /&gt; is greater than the number of elements in &lt;paramref name="destinationArray" /&gt;.&lt;/exception&gt;

```

**Expected Behavior**:
Sea of red in the editor.

**Actual Behavior**:
VS crashes:
```
Application: devenv.exe
Framework Version: v4.0.30319
Description: The application requested process termination through System.Environment.FailFast(string message).
Message: System.NullReferenceException: Object reference not set to an instance of an object.
   at Microsoft.CodeAnalysis.CSharp.Binder.BindDeclarationPattern(DeclarationPatternSyntax node, BoundExpression operand, TypeSymbol operandType, Boolean hasErrors, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindPattern(PatternSyntax node, BoundExpression operand, TypeSymbol operandType, Boolean hasErrors, DiagnosticBag diagnostics, Boolean wasSwitchCase)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindIsPatternExpression(IsPatternExpressionSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpression(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindNamespaceOrTypeOrExpression(ExpressionSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLowerBoundNode(CSharpSyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node, CSharpSyntaxNode&amp; bindableNode, BoundNode&amp; lowestBoundNode, BoundNode&amp; highestBoundNode, BoundNode&amp; boundParent)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetSymbolInfoWorker(CSharpSyntaxNode node, SymbolInfoOptions options, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(ExpressionSyntax expression, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.ClassifyTypeSyntax(NameSyntax name, SemanticModel semanticModel, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.ClassifyNode(SyntaxNode syntax, SemanticModel semanticModel, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService.Worker.ClassifyNode(SyntaxNode syntax)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService.Worker.ProcessNodes()
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService.Worker.Classify(Workspace workspace, SemanticModel semanticModel, TextSpan textSpan, List`1 list, Func`2 getNodeClassifiers, Func`2 getTokenClassifiers, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService.&lt;AddSemanticClassificationsAsync&gt;d__5.MoveNext()
Stack:
   at System.Environment.FailFast(System.String, System.Exception)
   at Microsoft.CodeAnalysis.FailFast.OnFatalException(System.Exception)
   at Microsoft.CodeAnalysis.ErrorReporting.FatalError.Report(System.Exception, System.Action`1&lt;System.Exception&gt;)
   at Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportUnlessCanceled(System.Exception)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__5.MoveNext()
   at Microsoft.CodeAnalysis.CSharp.Binder.BindDeclarationPattern(Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationPatternSyntax, Microsoft.CodeAnalysis.CSharp.BoundExpression, Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, Boolean, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindPattern(Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax, Microsoft.CodeAnalysis.CSharp.BoundExpression, Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, Boolean, Microsoft.CodeAnalysis.DiagnosticBag, Boolean)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindIsPatternExpression(Microsoft.CodeAnalysis.CSharp.Syntax.IsPatternExpressionSyntax, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, Microsoft.CodeAnalysis.DiagnosticBag, Boolean, Boolean)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, Microsoft.CodeAnalysis.DiagnosticBag, Boolean, Boolean)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindNamespaceOrTypeOrExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Bind(Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.Bind(Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLowerBoundNode(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetSymbolInfoWorker(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, SymbolInfoOptions, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.ClassifyTypeSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax, Microsoft.CodeAnalysis.SemanticModel, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.ClassifyNode(Microsoft.CodeAnalysis.SyntaxNode, Microsoft.CodeAnalysis.SemanticModel, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService+Worker.ClassifyNode(Microsoft.CodeAnalysis.SyntaxNode)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService+Worker.ProcessNodes()
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService+Worker.Classify(Microsoft.CodeAnalysis.Workspace, Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.Text.TextSpan, System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__5.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Classification.AbstractClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__5, Microsoft.CodeAnalysis.Workspaces, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;AddSemanticClassificationsAsync&gt;d__5 ByRef)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Document, Microsoft.CodeAnalysis.Text.TextSpan, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.AbstractEditorClassificationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Document, Microsoft.CodeAnalysis.Text.TextSpan, System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ClassifySpansAsync&gt;d__2.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ClassifySpansAsync&gt;d__2, Microsoft.CodeAnalysis.EditorFeatures, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;ClassifySpansAsync&gt;d__2 ByRef)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.ClassifySpansAsync(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IEditorClassificationService, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;TryClassifyContainingMemberSpan&gt;d__1.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].Start[[Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;TryClassifyContainingMemberSpan&gt;d__1, Microsoft.CodeAnalysis.EditorFeatures, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;TryClassifyContainingMemberSpan&gt;d__1 ByRef)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.TryClassifyContainingMemberSpan(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IEditorClassificationService, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ProduceTagsAsync&gt;d__0.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ProduceTagsAsync&gt;d__0, Microsoft.CodeAnalysis.EditorFeatures, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;ProduceTagsAsync&gt;d__0 ByRef)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.ProduceTagsAsync(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IEditorClassificationService, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationViewTaggerProvider.ProduceTagsAsync(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;)
   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource+&lt;RecomputeTagsAsync&gt;d__83[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource+&lt;RecomputeTagsAsync&gt;d__83[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Microsoft.CodeAnalysis.EditorFeatures, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;RecomputeTagsAsync&gt;d__83&lt;System.__Canon&gt; ByRef)
   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].RecomputeTagsAsync(System.Object, System.Nullable`1&lt;Microsoft.VisualStudio.Text.SnapshotPoint&gt;, System.Nullable`1&lt;Microsoft.CodeAnalysis.Text.TextChangeRange&gt;, System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan&gt;, System.Collections.Immutable.ImmutableDictionary`2&lt;Microsoft.VisualStudio.Text.ITextBuffer,Microsoft.CodeAnalysis.Editor.Shared.Tagging.TagSpanIntervalTree`1&lt;System.__Canon&gt;&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource+&lt;&gt;c__DisplayClass74_0[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].&lt;RecomputeTagsForeground&gt;b__0(System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.Shared.Threading.AsynchronousSerialWorkQueue+&lt;&gt;c__DisplayClass11_0.&lt;EnqueueBackgroundTask&gt;b__0(System.Threading.Tasks.Task)
   at System.Threading.Tasks.ContinuationResultTaskFromTask`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].InnerInvoke()
   at System.Threading.Tasks.Task.Execute()
   at System.Threading.Tasks.Task.ExecutionContextCallback(System.Object)
   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)
   at System.Threading.Tasks.Task.ExecuteEntry(Boolean)
   at System.Threading.Tasks.Task.System.Threading.IThreadPoolWorkItem.ExecuteWorkItem()
   at System.Threading.ThreadPoolWorkQueue.Dispatch()
   at System.Threading._ThreadPoolWaitCallback.PerformWaitCallback()

```
</Description>
        <CreatedDate>31/12/2016</CreatedDate>
        <ClosedDate>13/01/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>16467</PullRequestID>
        <IssueID>16315</IssueID>
        <Title>Expression variables declared in a local function parameter default are given a scope</Title>
        <Description>**Customer scenario**

If you declare an expression variable (e.g. out variable) inside the default value
expression of a parameter to a local function, the IDE crashes.

**Bugs this fixes:** 

Fixes #16167

**Workarounds, if any**

Don't make that mistake.

**Risk**

Small. Corrects a small oversight in the implementation of the interaction of new language features.

**Performance impact**

Trivial.

**Is this a regression from a previous update?**

No.

**Root cause analysis:**

Missing test for interaction between multiple new language features. Lack of dedicated testing team. Lack of coordinated testing role for new features and interactions between new features.

**How was the bug found?**

Customer reported.

@AlekseyTs @agocke @dotnet/roslyn-compiler May I please have a couple of reviews for this very small bug fix?
</Description>
        <CreatedDate>07/01/2017</CreatedDate>
        <ClosedDate>12/01/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>16467</PullRequestID>
      <File>src/Compilers/CSharp/Portable/Binder/LocalBinderFactory.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceComplexParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/FuzzTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/LocalFunctionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/OutVarTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>16409</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Do not run Naming Styles on overrides, etc.</Title>
    <Description>Fixes #15345

Do not run Naming Styles on overrides or known explicit/implicit interface implementations.

Escrow Template
================

**Customer scenario**: Customers who enable Naming Rules for members currently see the rules enforced on overrides and interface implementations, which can be noisy. This is particularly bad when the name is not fixable (when the name being overridden is in metadata), or when we eventually enable closed file analysis for this analyzer.

**Bugs this fixes:**: #15345

**Workarounds, if any**: None

**Risk**: Low. This is at the top of the stack and should just cause Naming Styles to be enforced less places.

**Performance impact**: For every Method/Property/Event without the "override" keyword and without being an explicit implementation of something, we will now do the work of examining each member of all base types and implemented interfaces to see if the given Method/Property/Event implements that member.

**Is this a regression from a previous update?**: No

**Root cause analysis:** This case was missed during the original feature work. Unit tests have been added to prevent regressions.

**How was the bug found?**: Dogfooding</Description>
    <CreatedDate>11/01/2017</CreatedDate>
    <ClosedDate>12/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>16409</PullRequestID>
        <IssueID>15345</IssueID>
        <Title>Naming rules fire on overrides</Title>
        <Description>The naming rules are firing on overrides - instead, it should be firing on the original declaration, the override cannot do anything about the name.

Like we did in FxCop you should also watch out for:

1. C# Implicit interface implementations
2. C# explicit interface implementations
3. VB explicit interface implementation
4. Overrides</Description>
        <CreatedDate>18/11/2016</CreatedDate>
        <ClosedDate>12/01/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>16409</PullRequestID>
        <IssueID>15345</IssueID>
        <Title>Naming rules fire on overrides</Title>
        <Description>The naming rules are firing on overrides - instead, it should be firing on the original declaration, the override cannot do anything about the name.

Like we did in FxCop you should also watch out for:

1. C# Implicit interface implementations
2. C# explicit interface implementations
3. VB explicit interface implementation
4. Overrides</Description>
        <CreatedDate>18/11/2016</CreatedDate>
        <ClosedDate>12/01/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>16409</PullRequestID>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/NamingStyles/NamingStylesTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/NamingStyles/NamingStylesTests_OptionSets.cs</File>
      <File>src/Workspaces/Core/Portable/NamingStyles/NamingStyleRules.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>16407</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Foreach deconstruction should mark iteration variables as assigned.</Title>
    <Description>Fixes:#16106

**Customer scenario**

When deconstruction is used in a context of foreach, the deconstructed variables are not marked as assigned. As a result, if a deconstruction variable is a struct (KeyValuePair, etc...). Dotting off the variable in the loop body would result in a false definite assignment error.

**Bugs this fixes:** 

#16106

No workarounds other than not using the given language construct when structs are involved.
The bug would block a sizeable fraction of user scenarios for the feature.

**Risk**

The change is specific to the deconstruction foreach. 
It basically just marks the iteration variables introduced by deconstruction all definitely assigned at the beginning of the loop body

**Performance impact**

Low.

**Is this a regression from a previous update?**

**Root cause analysis:**

How did we miss it?  What tests are we adding to guard against it in the future?

The bug is at intersection of "foreach" and "deconstruction" features. It also requires that deconstruction targets are structs. 
We seem to have missed this combination in testing.

**How was the bug found?**

Customer report.</Description>
    <CreatedDate>10/01/2017</CreatedDate>
    <ClosedDate>11/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>16407</PullRequestID>
        <IssueID>16106</IssueID>
        <Title>False error CS0170: Use of possibly unassigned field 'Item1'</Title>
        <Description>```
public class MyClass
{
    public void Test4(IEnumerable&lt;((int, int), string)&gt; en)
    {
        foreach ((ValueTuple&lt;int,int&gt; t, string s) in en)
        {
            var a =t.Item1; // false error CS0170: Use of possibly unassigned field
        }
    }

    public void Test5(IEnumerable&lt;((int, int), string)&gt; en)
    {
        foreach (((int,int) t, string s) in en)
        {
            var a = t.k; // false error CS0170: Use of possibly unassigned field
        }
    }
}
```</Description>
        <CreatedDate>26/12/2016</CreatedDate>
        <ClosedDate>10/01/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>16407</PullRequestID>
        <IssueID>16106</IssueID>
        <Title>False error CS0170: Use of possibly unassigned field 'Item1'</Title>
        <Description>```
public class MyClass
{
    public void Test4(IEnumerable&lt;((int, int), string)&gt; en)
    {
        foreach ((ValueTuple&lt;int,int&gt; t, string s) in en)
        {
            var a =t.Item1; // false error CS0170: Use of possibly unassigned field
        }
    }

    public void Test5(IEnumerable&lt;((int, int), string)&gt; en)
    {
        foreach (((int,int) t, string s) in en)
        {
            var a = t.k; // false error CS0170: Use of possibly unassigned field
        }
    }
}
```</Description>
        <CreatedDate>26/12/2016</CreatedDate>
        <ClosedDate>10/01/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>16407</PullRequestID>
      <File>src/Compilers/CSharp/Portable/Binder/ForEachLoopBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/Statement.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/DataFlowPass.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/DataFlowsOutWalker.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/PreciseAbstractFlowPass.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/ReadWriteWalker.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/VariablesDeclaredWalker.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_ForEachStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenDeconstructTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/ForEachTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>16381</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Have Narrator announce that an Inline Rename session has started</Title>
    <Description>Fixes part of #9960

Escrow Template
===========

**Customer scenario**: When a sight-impaired user invokes the Inline Rename command, they have no way of knowing that they've entered Inline Rename mode.

**Bugs this fixes:** This fixes part of #9960

**Workarounds, if any**: None really. The user could just *believe* that inline rename has started and proceed, but that's not really acceptable.

**Risk**: Low. This is at the top of the stack and only impacts accessibility.

**Performance impact**: Essentially none. We now explicitly make an AutomationPeer instead of using the built-in one. I'm not sure if that's an extra allocation or not, but it's only once per Inline Rename session anyway.

**Is this a regression from a previous update?** No

**Root cause analysis:** This was simply not done as part of the original feature work

**How was the bug found?** The Inline Rename Dashboard was known to have accessibility problems internally basically since it was introduced.</Description>
    <CreatedDate>10/01/2017</CreatedDate>
    <ClosedDate>12/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>16381</PullRequestID>
        <IssueID>9960</IssueID>
        <Title>Inline Rename unusable under Narrator</Title>
        <Description>1. No indication that Inline Rename has started
2. No indication that Inline Rename has been cancelled or completed
3. No way to focus the Dashboard &amp; read options
</Description>
        <CreatedDate>22/03/2016</CreatedDate>
        <ClosedDate>26/05/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>16381</PullRequestID>
        <IssueID>9960</IssueID>
        <Title>Inline Rename unusable under Narrator</Title>
        <Description>1. No indication that Inline Rename has started
2. No indication that Inline Rename has been cancelled or completed
3. No way to focus the Dashboard &amp; read options
</Description>
        <CreatedDate>22/03/2016</CreatedDate>
        <ClosedDate>26/05/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>16381</PullRequestID>
      <File>src/EditorFeatures/Core/EditorFeaturesResources.Designer.cs</File>
      <File>src/EditorFeatures/Core/Implementation/InlineRename/Dashboard/Dashboard.xaml.cs</File>
      <File>src/EditorFeatures/Core/Implementation/InlineRename/Dashboard/DashboardAutomationPeer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>16380</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Make the General Code Style &amp; Naming Style options pages accessible</Title>
    <Description>Fixes #13579
Fixes #13099

Fixes for tabbing and Narrator.

Escrow Template
===========

**Customer scenario**: Sight-impaired users could not use the General Code Style &amp; Naming Style option pages.

**Bugs this fixes:**  #13579, #13099

**Workarounds, if any**: None. I suppose the sight-impaired user could find a sighted person to explain what's going on, but that is unacceptable.

**Risk**: Very little. This change is at the very top of the stack, and it doesn't change any non-accessibility-related product functionality.

**Performance impact**: Essentially none. There will be at least one additional allocation every time the option pages are shown, but this is negligible, especially because it's on an infrequent user action. 

**Is this a regression from a previous update?**: No

**Root cause analysis:** This work was simply not done as part of the original feature work for either option page.

**How was the bug found?** Directed testing (thanks @rchande)</Description>
    <CreatedDate>10/01/2017</CreatedDate>
    <ClosedDate>11/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>16380</PullRequestID>
        <IssueID>13579</IssueID>
        <Title>CodeStyle Tools Options window : improve keyboard navigation</Title>
        <Description>1. Have to tab twice to select severity/preference
2. should show drop down on some key (space ?)
</Description>
        <CreatedDate>02/09/2016</CreatedDate>
        <ClosedDate>12/01/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>16380</PullRequestID>
        <IssueID>13099</IssueID>
        <Title>CodeStyle -&gt; General and Naming Styles do not support Narrator</Title>
        <Description>Windows Narrator reads the name of the view model type if you highlight one of these combo boxes.

![image](https://cloud.githubusercontent.com/assets/3751401/17602243/a4ef8d94-5fc0-11e6-9470-3bb0560c0009.png)
</Description>
        <CreatedDate>11/08/2016</CreatedDate>
        <ClosedDate>12/01/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>16380</PullRequestID>
        <IssueID>13579</IssueID>
        <Title>CodeStyle Tools Options window : improve keyboard navigation</Title>
        <Description>1. Have to tab twice to select severity/preference
2. should show drop down on some key (space ?)
</Description>
        <CreatedDate>02/09/2016</CreatedDate>
        <ClosedDate>12/01/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>16380</PullRequestID>
        <IssueID>13099</IssueID>
        <Title>CodeStyle -&gt; General and Naming Styles do not support Narrator</Title>
        <Description>Windows Narrator reads the name of the view model type if you highlight one of these combo boxes.

![image](https://cloud.githubusercontent.com/assets/3751401/17602243/a4ef8d94-5fc0-11e6-9470-3bb0560c0009.png)
</Description>
        <CreatedDate>11/08/2016</CreatedDate>
        <ClosedDate>12/01/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>16380</PullRequestID>
      <File>src/VisualStudio/Core/Def/ServicesVSResources.Designer.cs</File>
      <File>src/VisualStudio/Core/Impl/Options/ColumnToTabStopConverter.cs</File>
      <File>src/VisualStudio/Core/Impl/Options/Style/NamingPreferences/NamingStyleOptionPageViewModel.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>16357</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Have VisualStudioDocumentNavigationService perform bounds checks</Title>
    <Description>Fixes #7660
Fixes internal bugs 112211, 136895, 224318, 235409

We have a number of bugs (listed above) that show features trying to
navigate to positions that are not within the bounds of the documents in
which they are navigating. I have not been able to figure out the common
root cause of this problem, but they all flow through the
VisualStudioDocumentNavigationService, so adding bounds checks there
should alleviate the symptoms (reported as crashes, hangs, and error
dialogs).

Ask Mode
============

**Customer scenario**: The customer tries to navigate using the Navigation Bar or initiate a rename in a Razor file, and they are sometimes met with a crash, a hang, or an error dialog. **The total hit count from the Watson is currently 6686**. It is unclear why this only happens occasionally, and we have not been able to reproduce the failure locally.

**Bugs this fixes:** 

#7660
https://devdiv.visualstudio.com/DevDiv/_workitems?id=112211
https://devdiv.visualstudio.com/DevDiv/_workitems?id=136895
https://devdiv.visualstudio.com/DevDiv/_workitems?id=224318
https://devdiv.visualstudio.com/DevDiv/_workitems?id=235409

**Workarounds, if any**: None. The product crashes, hangs, or shows an error dialog.

**Risk**: Fairly low. We now return false instead of true for CanNavigateTo* for ContainedDocuments if their navigation target is outside the bounds of the document, which will cause rename to give a "You cannot rename this element" dialog instead of an "ArgumentOutOfRange" dialog. For the actual TryNavigateTo* methods, we are just adjusting the requested bounds to be within the bounds of the Document's length. In the worst case that I can imagine, we will navigate to the end of the document instead of some non-existent (and crashing) location that was requested of us.

**Performance impact**: Low perf impact, it's just a few math operations and one allocation, and it's only done on infrequent user-initiated actions.

**Is this a regression from a previous update?** No

**Root cause analysis:** We do not understand the root cause at this time. However, this change should address the symptoms being reported by customers (and Watson).

**How was the bug found?** Watson and customer reports</Description>
    <CreatedDate>09/01/2017</CreatedDate>
    <ClosedDate>10/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>16357</PullRequestID>
        <IssueID>7660</IssueID>
        <Title>VS2015.1: ArgumentOutOfRangeException while inline renaming in razor</Title>
        <Description>With `Index.cshtml` looking like

``` cshtml
@using ArgumentOutOfRangeTest.Controllers
@model Some
@Html.GetTest().TestMethod(x =&gt;
{
    x.SomeMethod(new { Controller = "Test", Action = nameof(TestController.Other) });
}).GetHtml()
```

I set the cursor to `Other`, pressed `F2` and got an error MessageBox telling me about a ArgumentOutOfRangeException for parametername position.
Pressing `F2` again, it did the same error again.
Attaching Visual Studio got me this stacktrace:

```
ArgumentOutOfRangeException: param: position
   at Microsoft.VisualStudio.Text.Implementation.BinaryStringRebuilder.GetLineNumberFromPosition(Int32 position)
   at Microsoft.VisualStudio.Text.Implementation.TextSnapshot.GetLineNumberFromPosition(Int32 position)
   at Microsoft.CodeAnalysis.Text.Extensions.SnapshotSourceText.LineInfo.IndexOf(Int32 position)
   at Microsoft.CodeAnalysis.Text.Extensions.SnapshotSourceText.LineInfo.GetLineFromPosition(Int32 position)
   at Microsoft.CodeAnalysis.Shared.Extensions.SourceTextExtensions.GetLineAndOffset(SourceText text, Int32 position, Int32&amp; lineNumber, Int32&amp; offset)
   at Microsoft.VisualStudio.LanguageServices.Implementation.Extensions.SourceTextExtensions.GetVsTextSpanForSpan(SourceText text, TextSpan textSpan)
   at Microsoft.VisualStudio.LanguageServices.Implementation.VisualStudioDocumentNavigationService.CanNavigateToSpan(Workspace workspace, DocumentId documentId, TextSpan textSpan)
   at Microsoft.CodeAnalysis.Editor.Implementation.InlineRename.AbstractEditorInlineRenameService.GetRenameInfo(IEnumerable`1 refactorNotifyServices, Document document, SyntaxToken triggerToken, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Editor.Implementation.InlineRename.AbstractEditorInlineRenameService.GetRenameInfo(Document document, Int32 position, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Editor.Implementation.InlineRename.AbstractEditorInlineRenameService.GetRenameInfoAsync(Document document, Int32 position, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Editor.Implementation.InlineRename.InlineRenameService.StartInlineSession(Document document, TextSpan textSpan, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Editor.Implementation.InlineRename.RenameCommandHandler.ExecuteRenameWorker(RenameCommandArgs args, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Editor.Implementation.InlineRename.RenameCommandHandler.&lt;&gt;c__DisplayClass37_0.&lt;ExecuteCommand&gt;b__0(IWaitContext waitContext)
   at Microsoft.VisualStudio.LanguageServices.Implementation.Utilities.VisualStudioWaitIndicator.Wait(String title, String message, Boolean allowCancel, Action`1 action)
   at Microsoft.CodeAnalysis.Editor.Implementation.InlineRename.RenameCommandHandler.ExecuteCommand(RenameCommandArgs args, Action nextHandler)
   at Microsoft.CodeAnalysis.Editor.Implementation.Commands.CommandHandlerService.ExecuteHandlers[T](IList`1 commandHandlers, T args, Action lastHandler)
   at Microsoft.CodeAnalysis.Editor.Implementation.Commands.CommandHandlerService.Microsoft.CodeAnalysis.Editor.ICommandHandlerService.Execute[T](IContentType contentType, T args, Action lastHandler)
   at Microsoft.VisualStudio.LanguageServices.Implementation.AbstractOleCommandTarget.ExecuteRename(ITextBuffer subjectBuffer, IContentType contentType, Action executeNextCommandTarget)
   at Microsoft.VisualStudio.LanguageServices.Implementation.AbstractOleCommandTarget.ExecuteVisualStudio2000(Guid&amp; pguidCmdGroup, UInt32 commandId, UInt32 executeInformation, IntPtr pvaIn, IntPtr pvaOut, ITextBuffer subjectBuffer, IContentType contentType)
   at Microsoft.VisualStudio.LanguageServices.Implementation.AbstractOleCommandTarget.Exec(Guid&amp; pguidCmdGroup, UInt32 commandId, UInt32 executeInformation, IntPtr pvaIn, IntPtr pvaOut)
   at Microsoft.VisualStudio.Html.Interop.OleToCommandTargetShim.Invoke(Guid group, Int32 id, Object inputArg, Object&amp; outputArg)
   at Microsoft.Html.Editor.Commands.HtmlMainController.Invoke(Guid group, Int32 id, Object inputArg, Object&amp; outputArg)
   at Microsoft.VisualStudio.Html.Interop.CommandTargetToOleShim.Exec(Guid&amp; guidCommandGroup, UInt32 commandID, UInt32 commandExecOpt, IntPtr variantIn, IntPtr variantOut)
   at Microsoft.VisualStudio.Editor.Implementation.CommandChainNode.InnerExec(Guid&amp; pguidCmdGroup, UInt32 nCmdID, UInt32 nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut)
   at Microsoft.VisualStudio.Editor.Implementation.SimpleTextViewWindow.Exec(Guid&amp; pguidCmdGroup, UInt32 nCmdID, UInt32 nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut)
   at Microsoft.VisualStudio.Editor.Implementation.CompoundTextViewWindow.Exec(Guid&amp; pguidCmdGroup, UInt32 nCmdID, UInt32 nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut)
   at Microsoft.VisualStudio.Platform.WindowManagement.DocumentObjectSite.Exec(Guid&amp; pguidCmdGroup, UInt32 nCmdID, UInt32 nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut)
   at Microsoft.VisualStudio.Platform.WindowManagement.WindowFrame.Exec(Guid&amp; pguidCmdGroup, UInt32 nCmdID, UInt32 nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut)
```

While trying to create a minimal reproduction (see `Index.cshtml` above), VS bugged me all the time with an messagebox, telling me `You cannot rename this element` (translated from german).
After restarting Visual Studio it was able to rename it without problems.

Unfortunately i couldn't reproduce it and also the renaming in the originally affected solution worked after restarting Visual Studio, so i'm opening this issue in the hope that someone will figure it out eventually.

EDIT: but i just run into it again so it seems to happen after some time.
</Description>
        <CreatedDate>22/12/2015</CreatedDate>
        <ClosedDate>11/01/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>16357</PullRequestID>
        <IssueID>7660</IssueID>
        <Title>VS2015.1: ArgumentOutOfRangeException while inline renaming in razor</Title>
        <Description>With `Index.cshtml` looking like

``` cshtml
@using ArgumentOutOfRangeTest.Controllers
@model Some
@Html.GetTest().TestMethod(x =&gt;
{
    x.SomeMethod(new { Controller = "Test", Action = nameof(TestController.Other) });
}).GetHtml()
```

I set the cursor to `Other`, pressed `F2` and got an error MessageBox telling me about a ArgumentOutOfRangeException for parametername position.
Pressing `F2` again, it did the same error again.
Attaching Visual Studio got me this stacktrace:

```
ArgumentOutOfRangeException: param: position
   at Microsoft.VisualStudio.Text.Implementation.BinaryStringRebuilder.GetLineNumberFromPosition(Int32 position)
   at Microsoft.VisualStudio.Text.Implementation.TextSnapshot.GetLineNumberFromPosition(Int32 position)
   at Microsoft.CodeAnalysis.Text.Extensions.SnapshotSourceText.LineInfo.IndexOf(Int32 position)
   at Microsoft.CodeAnalysis.Text.Extensions.SnapshotSourceText.LineInfo.GetLineFromPosition(Int32 position)
   at Microsoft.CodeAnalysis.Shared.Extensions.SourceTextExtensions.GetLineAndOffset(SourceText text, Int32 position, Int32&amp; lineNumber, Int32&amp; offset)
   at Microsoft.VisualStudio.LanguageServices.Implementation.Extensions.SourceTextExtensions.GetVsTextSpanForSpan(SourceText text, TextSpan textSpan)
   at Microsoft.VisualStudio.LanguageServices.Implementation.VisualStudioDocumentNavigationService.CanNavigateToSpan(Workspace workspace, DocumentId documentId, TextSpan textSpan)
   at Microsoft.CodeAnalysis.Editor.Implementation.InlineRename.AbstractEditorInlineRenameService.GetRenameInfo(IEnumerable`1 refactorNotifyServices, Document document, SyntaxToken triggerToken, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Editor.Implementation.InlineRename.AbstractEditorInlineRenameService.GetRenameInfo(Document document, Int32 position, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Editor.Implementation.InlineRename.AbstractEditorInlineRenameService.GetRenameInfoAsync(Document document, Int32 position, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Editor.Implementation.InlineRename.InlineRenameService.StartInlineSession(Document document, TextSpan textSpan, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Editor.Implementation.InlineRename.RenameCommandHandler.ExecuteRenameWorker(RenameCommandArgs args, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Editor.Implementation.InlineRename.RenameCommandHandler.&lt;&gt;c__DisplayClass37_0.&lt;ExecuteCommand&gt;b__0(IWaitContext waitContext)
   at Microsoft.VisualStudio.LanguageServices.Implementation.Utilities.VisualStudioWaitIndicator.Wait(String title, String message, Boolean allowCancel, Action`1 action)
   at Microsoft.CodeAnalysis.Editor.Implementation.InlineRename.RenameCommandHandler.ExecuteCommand(RenameCommandArgs args, Action nextHandler)
   at Microsoft.CodeAnalysis.Editor.Implementation.Commands.CommandHandlerService.ExecuteHandlers[T](IList`1 commandHandlers, T args, Action lastHandler)
   at Microsoft.CodeAnalysis.Editor.Implementation.Commands.CommandHandlerService.Microsoft.CodeAnalysis.Editor.ICommandHandlerService.Execute[T](IContentType contentType, T args, Action lastHandler)
   at Microsoft.VisualStudio.LanguageServices.Implementation.AbstractOleCommandTarget.ExecuteRename(ITextBuffer subjectBuffer, IContentType contentType, Action executeNextCommandTarget)
   at Microsoft.VisualStudio.LanguageServices.Implementation.AbstractOleCommandTarget.ExecuteVisualStudio2000(Guid&amp; pguidCmdGroup, UInt32 commandId, UInt32 executeInformation, IntPtr pvaIn, IntPtr pvaOut, ITextBuffer subjectBuffer, IContentType contentType)
   at Microsoft.VisualStudio.LanguageServices.Implementation.AbstractOleCommandTarget.Exec(Guid&amp; pguidCmdGroup, UInt32 commandId, UInt32 executeInformation, IntPtr pvaIn, IntPtr pvaOut)
   at Microsoft.VisualStudio.Html.Interop.OleToCommandTargetShim.Invoke(Guid group, Int32 id, Object inputArg, Object&amp; outputArg)
   at Microsoft.Html.Editor.Commands.HtmlMainController.Invoke(Guid group, Int32 id, Object inputArg, Object&amp; outputArg)
   at Microsoft.VisualStudio.Html.Interop.CommandTargetToOleShim.Exec(Guid&amp; guidCommandGroup, UInt32 commandID, UInt32 commandExecOpt, IntPtr variantIn, IntPtr variantOut)
   at Microsoft.VisualStudio.Editor.Implementation.CommandChainNode.InnerExec(Guid&amp; pguidCmdGroup, UInt32 nCmdID, UInt32 nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut)
   at Microsoft.VisualStudio.Editor.Implementation.SimpleTextViewWindow.Exec(Guid&amp; pguidCmdGroup, UInt32 nCmdID, UInt32 nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut)
   at Microsoft.VisualStudio.Editor.Implementation.CompoundTextViewWindow.Exec(Guid&amp; pguidCmdGroup, UInt32 nCmdID, UInt32 nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut)
   at Microsoft.VisualStudio.Platform.WindowManagement.DocumentObjectSite.Exec(Guid&amp; pguidCmdGroup, UInt32 nCmdID, UInt32 nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut)
   at Microsoft.VisualStudio.Platform.WindowManagement.WindowFrame.Exec(Guid&amp; pguidCmdGroup, UInt32 nCmdID, UInt32 nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut)
```

While trying to create a minimal reproduction (see `Index.cshtml` above), VS bugged me all the time with an messagebox, telling me `You cannot rename this element` (translated from german).
After restarting Visual Studio it was able to rename it without problems.

Unfortunately i couldn't reproduce it and also the renaming in the originally affected solution worked after restarting Visual Studio, so i'm opening this issue in the hope that someone will figure it out eventually.

EDIT: but i just run into it again so it seems to happen after some time.
</Description>
        <CreatedDate>22/12/2015</CreatedDate>
        <ClosedDate>11/01/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>16357</PullRequestID>
      <File>src/VisualStudio/Core/Def/Implementation/Workspace/VisualStudioDocumentNavigationService.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>15831</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Adjust scope of variables declared within a ‚Äòfor‚Äô condition and ‚Äòfor‚Äô incrementors.</Title>
    <Description>Variables declared within a ‚Äòfor‚Äô condition are in scope only inside the condition, incrementors and body of the loop.
Variables declared within ‚Äòfor‚Äô incrementors are in scope only inside the incrementors.

Customer scenario
See #15529.

Bugs this fixes:
Fixes #15630.

Workarounds, if any
Explicitly copy values to locals declared within the body of the loop and use those in lambdas instead.

Risk
Low

Performance impact
Low.

Is this a regression from a previous update?
No

Root cause analysis:
Design change for a new feature.

How was the bug found?
Requested by a customer.

@dotnet/roslyn-compiler Please review.
</Description>
    <CreatedDate>12/12/2016</CreatedDate>
    <ClosedDate>14/12/2016</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>15831</PullRequestID>
        <IssueID>15529</IssueID>
        <Title>while variable closure</Title>
        <Description>In C# 5, `foreach` was explicitly changed - a breaking change no less - to ensure that loop variables were not closed over. At the time Eric Lippert wrote:

&gt;this is the single most common incorrect bug report we get... That‚Äôs a terrible situation for everyone; we very much wish to design a language which does not have ‚Äúgotcha‚Äù features like this. [[1]](https://blogs.msdn.microsoft.com/ericlippert/2009/11/12/closing-over-the-loop-variable-considered-harmful/)

With C# 7's current rules for `while` loop scoping, we again have the same problem where condition and loop variables will be closed over by default,

Wouldn't it make sense to consider this ahead of time and ensure that out and pattern match vars do not fall into this trap?

`while(GetNext(out T value)){...}` should follow in the footsteps of `foreach` and produce something like:
```
{
    T tmp;
    while(GetNext(out tmp))
    {
        T value = tmp;
        ...
    }
}
```

In general I do not agree with the new scoping rules for `if` and `while`, but I see the later being not just confusing or an inconvenience, but a flaw that will be a "gotcha" for many.

@ericlippert 's final quote in the link above is also quite poignant:
&gt; Design is, of course, the art of compromise in the face of many competing principles. ‚ÄúEliminate gotchas‚Äù in this case directly opposes other principles like ‚Äúno breaking changes‚Äù, and ‚Äúbe consistent with other language features‚Äù.

The C# 7 language team has a real opportunity to meet all of these principles before they become an issue.

Please reconsider the scoping rules for out and pattern match variables.




</Description>
        <CreatedDate>25/11/2016</CreatedDate>
        <ClosedDate>24/04/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>15831</PullRequestID>
        <IssueID>15630</IssueID>
        <Title>Change scoping of expression variables for while, for</Title>
        <Description>In response to community issue #15529, the LDM met yesterday and decided to approve this proposed change to the scoping of expression variables in a while loop. Specifically, a while loop written

```cs
while (&lt;cond&gt;) &lt;body&gt;
```

will have expression-variables declared in `expr` scoped as if it were rewritten

```cs
continueLabel:;
{
    if (!&lt;cond&gt;) goto breakLabel;
    {
        &lt;body&gt;
    }
    goto continueLabel;
}
breakLabel:;
```

We will also make a corresponding change to the `for` loop. A `for` loop written

```cs
for (&lt;decl&gt;; &lt;cond&gt;; &lt;incr&gt;) &lt;body&gt;
```

will have expression-variables declared in the three parts scoped as if it were rewritten

``` c#
{
    &lt;decl&gt;
    while(&lt;cond&gt;)
    {
        &lt;body&gt;
    continueLabel:;
        { &lt;incr&gt; }
    }
}
```

Note that `&lt;incr&gt;` has its own little scope.

/cc @jaredpar </Description>
        <CreatedDate>01/12/2016</CreatedDate>
        <ClosedDate>14/12/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>15831</PullRequestID>
      <File>src/Compilers/CSharp/Portable/Binder/ExpressionListVariableBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/ForLoopBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/LocalBinderFactory.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/MemberSemanticModel.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/DataFlowPass.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/Instrumentation/CompoundInstrumenter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/Instrumentation/DebugInfoInjector.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/Instrumentation/Instrumenter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_ForEachStatement.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_ForStatement.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/MethodToClassRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/LookupPosition.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/SyntaxNodeExtensions.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenDeconstructTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/OutVarTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests_Scope.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>15801</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Variable declared within a while‚Äô condition should be in scope only within the loop.</Title>
    <Description>**Customer scenario**
See #15529.

**Bugs this fixes:** 
Related to #15630.

**Workarounds, if any**
Explicitly copy values to locals declared within the body of the loop and use those in lambdas instead.

**Risk**
Low

**Performance impact**
Low.

**Is this a regression from a previous update?**
No

**Root cause analysis:**
Design change for a new feature.

**How was the bug found?**
Requested by a customer.


@dotnet/roslyn-compiler Please review.</Description>
    <CreatedDate>09/12/2016</CreatedDate>
    <ClosedDate>11/12/2016</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>15801</PullRequestID>
        <IssueID>15529</IssueID>
        <Title>while variable closure</Title>
        <Description>In C# 5, `foreach` was explicitly changed - a breaking change no less - to ensure that loop variables were not closed over. At the time Eric Lippert wrote:

&gt;this is the single most common incorrect bug report we get... That‚Äôs a terrible situation for everyone; we very much wish to design a language which does not have ‚Äúgotcha‚Äù features like this. [[1]](https://blogs.msdn.microsoft.com/ericlippert/2009/11/12/closing-over-the-loop-variable-considered-harmful/)

With C# 7's current rules for `while` loop scoping, we again have the same problem where condition and loop variables will be closed over by default,

Wouldn't it make sense to consider this ahead of time and ensure that out and pattern match vars do not fall into this trap?

`while(GetNext(out T value)){...}` should follow in the footsteps of `foreach` and produce something like:
```
{
    T tmp;
    while(GetNext(out tmp))
    {
        T value = tmp;
        ...
    }
}
```

In general I do not agree with the new scoping rules for `if` and `while`, but I see the later being not just confusing or an inconvenience, but a flaw that will be a "gotcha" for many.

@ericlippert 's final quote in the link above is also quite poignant:
&gt; Design is, of course, the art of compromise in the face of many competing principles. ‚ÄúEliminate gotchas‚Äù in this case directly opposes other principles like ‚Äúno breaking changes‚Äù, and ‚Äúbe consistent with other language features‚Äù.

The C# 7 language team has a real opportunity to meet all of these principles before they become an issue.

Please reconsider the scoping rules for out and pattern match variables.




</Description>
        <CreatedDate>25/11/2016</CreatedDate>
        <ClosedDate>24/04/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>15801</PullRequestID>
        <IssueID>15630</IssueID>
        <Title>Change scoping of expression variables for while, for</Title>
        <Description>In response to community issue #15529, the LDM met yesterday and decided to approve this proposed change to the scoping of expression variables in a while loop. Specifically, a while loop written

```cs
while (&lt;cond&gt;) &lt;body&gt;
```

will have expression-variables declared in `expr` scoped as if it were rewritten

```cs
continueLabel:;
{
    if (!&lt;cond&gt;) goto breakLabel;
    {
        &lt;body&gt;
    }
    goto continueLabel;
}
breakLabel:;
```

We will also make a corresponding change to the `for` loop. A `for` loop written

```cs
for (&lt;decl&gt;; &lt;cond&gt;; &lt;incr&gt;) &lt;body&gt;
```

will have expression-variables declared in the three parts scoped as if it were rewritten

``` c#
{
    &lt;decl&gt;
    while(&lt;cond&gt;)
    {
        &lt;body&gt;
    continueLabel:;
        { &lt;incr&gt; }
    }
}
```

Note that `&lt;incr&gt;` has its own little scope.

/cc @jaredpar </Description>
        <CreatedDate>01/12/2016</CreatedDate>
        <ClosedDate>14/12/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>15801</PullRequestID>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Statements.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/ExpressionVariableFinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/LocalBinderFactory.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/LocalScopeBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/WhileBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/DataFlowPass.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/Instrumentation/CompoundInstrumenter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/Instrumentation/DebugInfoInjector.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/Instrumentation/DynamicAnalysisInjector.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/Instrumentation/Instrumenter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_DoStatement.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_WhileStatement.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/MethodToClassRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceMemberContainerSymbol.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/OutVarTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests_Global.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests_Scope.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>15773</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Fix local function capturing by another local function</Title>
    <Description>**Customer scenario**

See #15599. The program must contain a local function which captures another local function not in the same scope and also captures a variable in a different scope from the captured local function.

The fix is to avoid capturing frame pointers if the frame type is a struct. If the frame is a struct then frame pointers are not captured, like in lambdas, they are passed sequentially to the capturing local function as by-ref parameters.

**Bugs this fixes:** 

#15599

**Workarounds, if any**

Capturing can be avoided and variables can be passed as parameters to local functions, but this workaround is difficult to figure out, since the compiler crashes on the given input.

**Risk**

This change is restricted to scenarios with local function lowering.

**Performance impact**

Low. This change prevents an extra code path from being taken, so if anything it is likely to increase performance.

**Is this a regression from a previous update?**

No.

**Root cause analysis:**

This is another case where too complex of a scenario (more capturing) doesn't show the problem and not complex enough (less capturing) also doesn't show the problem. It's a Goldilocks bug.

To help catch these bugs, this fix contains a new test that tries to brute force check every possible capturing combination for local functions within a certain complexity bound. When tested against this bug it found the issue independently through two completely different code paths.

**How was the bug found?**

Customer reported.</Description>
    <CreatedDate>08/12/2016</CreatedDate>
    <ClosedDate>18/12/2016</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>15773</PullRequestID>
        <IssueID>15599</IssueID>
        <Title>Compiler: NullRef on local method that uses instance and scoped local method</Title>
        <Description>**Version Used**: 0694d5ccc05b7e1cc37c82a1c15c8f9fc23e3775 

```C#
public class C {
    int instance;
    public void Test() {
        int M() =&gt; instance;
        {
            int local = 0;
            bool M2() =&gt; local == M();
        }
    }
}
```

The compiler throws a NullRef:

&gt; 
&gt;    at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.FramePointer(SyntaxNode syntax, NamedTypeSymbol frameClass) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\LambdaRewriter.cs:line 500
&gt;    at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.FrameOfType(SyntaxNode syntax, NamedTypeSymbol frameType) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\LambdaRewriter.cs:line 450
&gt;    at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.RemapLambdaOrLocalFunction(SyntaxNode syntax, MethodSymbol originalMethod, ImmutableArray`1 typeArgumentsOpt, ClosureKind closureKind, MethodSymbol&amp; synthesizedMethod, BoundExpression&amp; receiver, NamedTypeSymbol&amp; constructedFrame) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\LambdaRewriter.cs:line 820
&gt;    at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.RemapLocalFunction(SyntaxNode syntax, MethodSymbol symbol, BoundExpression&amp; receiver, MethodSymbol&amp; method, ImmutableArray`1&amp; parameters, ImmutableArray`1 typeArguments) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\LambdaRewriter.LocalFunctionReferenceRewriter.cs:line 133
&gt;    at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.LocalFunctionReferenceRewriter.VisitCall(BoundCall node) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\LambdaRewriter.LocalFunctionReferenceRewriter.cs:line 37
&gt; 

http://tryroslyn.azurewebsites.net/#b:master/f:r/A4VwRgNglgxgBDCBDAziuBhOBvAUHAuKAOwBcjiVSliYBTAbn0NEljgDcB7KAEzgAqdKgAoAlDmaFCJcgFlxcALwA+ClRr0m06Xh36K5CFxhIIyuAAZtB6WC5dzcgEyLVcY6fNKlcBWJt9AF8pOBCgoA</Description>
        <CreatedDate>30/11/2016</CreatedDate>
        <ClosedDate>18/12/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>15773</PullRequestID>
        <IssueID>15599</IssueID>
        <Title>Compiler: NullRef on local method that uses instance and scoped local method</Title>
        <Description>**Version Used**: 0694d5ccc05b7e1cc37c82a1c15c8f9fc23e3775 

```C#
public class C {
    int instance;
    public void Test() {
        int M() =&gt; instance;
        {
            int local = 0;
            bool M2() =&gt; local == M();
        }
    }
}
```

The compiler throws a NullRef:

&gt; 
&gt;    at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.FramePointer(SyntaxNode syntax, NamedTypeSymbol frameClass) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\LambdaRewriter.cs:line 500
&gt;    at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.FrameOfType(SyntaxNode syntax, NamedTypeSymbol frameType) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\LambdaRewriter.cs:line 450
&gt;    at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.RemapLambdaOrLocalFunction(SyntaxNode syntax, MethodSymbol originalMethod, ImmutableArray`1 typeArgumentsOpt, ClosureKind closureKind, MethodSymbol&amp; synthesizedMethod, BoundExpression&amp; receiver, NamedTypeSymbol&amp; constructedFrame) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\LambdaRewriter.cs:line 820
&gt;    at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.RemapLocalFunction(SyntaxNode syntax, MethodSymbol symbol, BoundExpression&amp; receiver, MethodSymbol&amp; method, ImmutableArray`1&amp; parameters, ImmutableArray`1 typeArguments) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\LambdaRewriter.LocalFunctionReferenceRewriter.cs:line 133
&gt;    at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.LocalFunctionReferenceRewriter.VisitCall(BoundCall node) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\LambdaRewriter.LocalFunctionReferenceRewriter.cs:line 37
&gt; 

http://tryroslyn.azurewebsites.net/#b:master/f:r/A4VwRgNglgxgBDCBDAziuBhOBvAUHAuKAOwBcjiVSliYBTAbn0NEljgDcB7KAEzgAqdKgAoAlDmaFCJcgFlxcALwA+ClRr0m06Xh36K5CFxhIIyuAAZtB6WC5dzcgEyLVcY6fNKlcBWJt9AF8pOBCgoA</Description>
        <CreatedDate>30/11/2016</CreatedDate>
        <ClosedDate>18/12/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>15773</PullRequestID>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/LambdaRewriter.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenCapturing.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenLocalFunctionTests.cs</File>
      <File>src/Test/Utilities/Desktop/CommonTestBase.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>15687</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Add a code refactoring to add argument names</Title>
    <Description>Fixes #9883 (previous PR: #9934)

/cc @CyrusNajmabadi </Description>
    <CreatedDate>05/12/2016</CreatedDate>
    <ClosedDate>09/12/2016</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>15687</PullRequestID>
        <IssueID>9883</IssueID>
        <Title>Request: Analyzer for named arguments</Title>
        <Description>Named arguments are a great feature to write self-documented code, but if the original author didn't write them you should write every argument by hand which is kinda cumbersome. Also, when you write named arguments you might write them in a random order that makes the compiler to introduce locals to preserve side-effects in order. It would be nice to (1) have an analyzer add all named arguments for a method call (2) and suggest correction if they are not in the same order as method parameters.
</Description>
        <CreatedDate>18/03/2016</CreatedDate>
        <ClosedDate>18/03/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>15687</PullRequestID>
        <IssueID>9934</IssueID>
        <Title>Add a code refactoring for adding named arguments</Title>
        <Description>Fixes #9883
</Description>
        <CreatedDate>21/03/2016</CreatedDate>
        <ClosedDate>04/12/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>15687</PullRequestID>
      <File>src/EditorFeatures/CSharpTest/CodeActions/UseNamedArguments/UseNamedArgumentsTests.cs</File>
      <File>src/EditorFeatures/TestUtilities/Traits.cs</File>
      <File>src/Features/CSharp/Portable/CodeRefactorings/UseNamedArguments/CSharpUseNamedArgumentsCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/CodeRefactorings/UseNamedArguments/AbstractUseNamedArgumentsCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/FeaturesResources.Designer.cs</File>
      <File>src/Workspaces/CSharp/Portable/Extensions/BaseArgumentListSyntaxExtensions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>15655</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Add editorconfig option for PreferExplicitTupleName</Title>
    <Description>**Customer scenario**

Allows the user to specify that they want to use explicit tuple names using editorconfig

**Bugs this fixes:** 

#15307

**Workarounds, if any**

Use can specify this option manually in VS.  Changing the option manually for each project.

**Risk**

Low, , it is reusing all existing editoconfig code.

**Performance impact**

Low, it is reusing all existing editoconfig code.

**Is this a regression from a previous update?**

No, this is a follow up to this option being added in PR #15202

**Root cause analysis:**

editor config support for code style options was in review when this was merged into master.

**How was the bug found?**

bug was filed as part of PR #15202
</Description>
    <CreatedDate>03/12/2016</CreatedDate>
    <ClosedDate>08/12/2016</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>15655</PullRequestID>
        <IssueID>15307</IssueID>
        <Title>Need .editor_config option for PreferExplicitTupleName.</Title>
        <Description>Related pr: https://github.com/dotnet/roslyn/pull/15202

@jmarolf </Description>
        <CreatedDate>17/11/2016</CreatedDate>
        <ClosedDate>08/12/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>15655</PullRequestID>
        <IssueID>15202</IssueID>
        <Title>Add a feature to suggest using explicit tuple names when they are available.</Title>
        <Description>
        </Description>
        <CreatedDate>13/11/2016</CreatedDate>
        <ClosedDate>17/11/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>15655</PullRequestID>
        <IssueID>15202</IssueID>
        <Title>Add a feature to suggest using explicit tuple names when they are available.</Title>
        <Description>
        </Description>
        <CreatedDate>13/11/2016</CreatedDate>
        <ClosedDate>17/11/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>15655</PullRequestID>
      <File>src/Workspaces/Core/Portable/CodeStyle/CodeStyleOptions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>15646</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Fix DeclaredInside for expression variables and deconstruction</Title>
    <Description>@dotnet/roslyn-compiler Please review.

**Customer scenario**

`DeclaredInside` is used for extract method, so the bugs fixed here result in incorrect behavior for that IDE feature. Also, it fixes a `NullReferenceException` that would result in an IDE crash when extract method is used in some circumstances.

**Bugs this fixes:** 

Fixes #12940
Fixes #14110
Fixes #15640

**Workarounds, if any**

Don't use extract method (or any other IDE features that use `DeclaredInside`).

**Risk**

Fairly low; the changes are localized to the affected scenarios, and significantly simplify the implementation.

**Performance impact**

Small. Slightly larger node for `BoundLocal`, which is transiently used during semantic analysis and in the `SemanticModel`

**Is this a regression from a previous update?**

No. The bugs have been present as long as the feature implementations have been in the code base.

**Root cause analysis:**

Implementing this API for expression variables has been a known laggard in the implementation of the new features. Because it wasn't implemented, it also wasn't tested. This PR adds tests for the affected scenarios.

**How was the bug found?**

Ad-hoc and unit testing while completing the feature.
</Description>
    <CreatedDate>02/12/2016</CreatedDate>
    <ClosedDate>15/12/2016</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>15646</PullRequestID>
        <IssueID>12940</IssueID>
        <Title>Missing bound node for out variable declaration</Title>
        <Description>We have a design invariant for the bound nodes that the initial bound tree is roughly isomorphic to the shape of the syntax. We create and retain bound nodes even when they do not represent runtime operations, e.g. local variable declarations.

The out variable declaration is not retained in the initial bound trees. It should be. This would slightly simplify the handling of the diagnostic reporting it being unsupported in expression trees, for example, and would simplify the handling of some error cases in flow analysis. It is necessary for region analysis to compute the "declared inside" property.
</Description>
        <CreatedDate>04/08/2016</CreatedDate>
        <ClosedDate>15/12/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>15646</PullRequestID>
        <IssueID>14110</IssueID>
        <Title>DataFlowAnalysis.VariablesDeclared does not handle deconstruction declarations</Title>
        <Description>The following proposed unit test fails.

``` cs
        [Fact, WorkItem(14110, "https://github.com/dotnet/roslyn/issues/14110")]
        public void Test14110()
        {
            var dataFlowAnalysisResults = CompileAndAnalyzeDataFlowStatements(@"
using System;

class Program
{
    static void Main()
    {
/*&lt;bind&gt;*/
        var (x, y) = (1, 2);
        (var a, var b) = (3, 4);
/*&lt;/bind&gt;*/
        Console.WriteLine(x + a);
    }
}
");
            Assert.Equal("a, b, x, y", GetSymbolNamesJoined(dataFlowAnalysisResults.VariablesDeclared));
        }
```

One symptom of this is #14108.
</Description>
        <CreatedDate>27/09/2016</CreatedDate>
        <ClosedDate>15/12/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>15646</PullRequestID>
        <IssueID>15640</IssueID>
        <Title>NullReferenceException in DeclaredInside for deconstruction foreach loop</Title>
        <Description>The following test fails with a `NullReferenceException`.

```cs
        [Fact, WorkItem(15640, "https://github.com/dotnet/roslyn/issues/15640")]
        public void Test15640()
        {
            var dataFlowAnalysisResults = CompileAndAnalyzeDataFlowStatements(@"
using System;

class Program
{
    static void Main()
    {
/*&lt;bind&gt;*/
        foreach (var (a, b) in new[] { (1, 2) }) {}
/*&lt;/bind&gt;*/
    }
}
");
            Assert.Equal("a, b", GetSymbolNamesJoined(dataFlowAnalysisResults.VariablesDeclared));
        }
```
</Description>
        <CreatedDate>02/12/2016</CreatedDate>
        <ClosedDate>15/12/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>15646</PullRequestID>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Deconstruct.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Expressions.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/BoundExpression.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/DeconstructionVariablePendingInference.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/OutVariablePendingInference.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/VariablesDeclaredWalker.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/FlowAnalysis/RegionAnalysisTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>15597</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Port 3 fixes from master to rc2</Title>
    <Description>**Customer scenario**

it fixes 2 customer issues.

1. random crash when user builds solution using special "devenv /build" command line argument (#15490)
2. various issues reported from new OOP features released in RC (#14978, #15110).

**Bugs this fixes:** 
#15490, #14978, #15110

**Workarounds, if any**
there is no workaround. these fixes are better to be in early so that we can catch more issues before RTM.

**Risk**

Fix for the first issue is very low risk. simple and very specific fix. no broad impact.
Fix for the second issue will not make OOP any less stable than before. it either makes it more stable or let us have better dump if it happens again. 

**Performance impact**

these fixes are not related to any major perf releated code.

**Is this a regression from a previous update?**
No. both of them are issues we first found out. especially second fix is for feature which released in RC.

**Root cause analysis:**
issue for the first fix is due to a race. 
OOP related issues has multiple root causes. one is due to some failure in service hub, another is due to us not setting option correctly in some code path or not catching exception we should have and etc.

How did we miss it?  What tests are we adding to guard against it in the future?
race is hard to test and catch. OOP is new feature so there were missing test holes and pattern we didn't thought of.

unit tests are added for found issues.

**How was the bug found?**
customer reports and watsons.
</Description>
    <CreatedDate>30/11/2016</CreatedDate>
    <ClosedDate>30/11/2016</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>15597</PullRequestID>
        <IssueID>15490</IssueID>
        <Title>random crash on devenv /build</Title>
        <Description>**Version Used**: 
VS 2017 RC

this bug is from customer report.

...

It  appears that devenv.exe will crash periodically when it is used to invoke a build, and there is a C# project present in the solution.
The failures are intermittent and we saw them happening about once in 3-10 builds on our virtual machines 
 
The command line that we  used  to reproduce the issue (multiple times):
"C:\Program Files (x86)\Microsoft Visual Studio\2017\Enterprise\Common7\IDE\devenv.com" "C:\Users\Administrator\Documents\Visual Studio 2017\Projects\ConsoleApplication2\ConsoleApplication2.sln" /rebuild  "Debug|x86" 

We saw this sort of behavior even with solutions that consist of a single C# console application project.
The devenv.exe build with which we saw the problem is  15.0.25909.2 

As IncrediBuild invokes a DevEnv command for every executed build, IncrediBuild will fail whenever DevEnv crashes.

</Description>
        <CreatedDate>23/11/2016</CreatedDate>
        <ClosedDate>28/11/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>15597</PullRequestID>
        <IssueID>14978</IssueID>
        <Title>Fix All for Code Styles is broken</Title>
        <Description>If I `Ctrl+.` to convert 'var' to 'explicit' type and then 'Fix All in Document', the entire lightbulb menu+preview dialog disappears and nothing happens (no code fix is applied). </Description>
        <CreatedDate>04/11/2016</CreatedDate>
        <ClosedDate>29/11/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>15597</PullRequestID>
        <IssueID>15110</IssueID>
        <Title>fixed 2 known OOP issues</Title>
        <Description>1. there is a known issue where RequestServiceAsync might fail randomly.
   people are looking at the root cause, but until that is fixed,
   we will retry rather than failing right away.

2. if we close named pipe stream in the middle of object writer/reader is
   using them, we can get various exceptions. make sure we check cancellation
   before propagating that exception.</Description>
        <CreatedDate>09/11/2016</CreatedDate>
        <ClosedDate>28/11/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>15597</PullRequestID>
        <IssueID>15490</IssueID>
        <Title>random crash on devenv /build</Title>
        <Description>**Version Used**: 
VS 2017 RC

this bug is from customer report.

...

It  appears that devenv.exe will crash periodically when it is used to invoke a build, and there is a C# project present in the solution.
The failures are intermittent and we saw them happening about once in 3-10 builds on our virtual machines 
 
The command line that we  used  to reproduce the issue (multiple times):
"C:\Program Files (x86)\Microsoft Visual Studio\2017\Enterprise\Common7\IDE\devenv.com" "C:\Users\Administrator\Documents\Visual Studio 2017\Projects\ConsoleApplication2\ConsoleApplication2.sln" /rebuild  "Debug|x86" 

We saw this sort of behavior even with solutions that consist of a single C# console application project.
The devenv.exe build with which we saw the problem is  15.0.25909.2 

As IncrediBuild invokes a DevEnv command for every executed build, IncrediBuild will fail whenever DevEnv crashes.

</Description>
        <CreatedDate>23/11/2016</CreatedDate>
        <ClosedDate>28/11/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>15597</PullRequestID>
        <IssueID>14978</IssueID>
        <Title>Fix All for Code Styles is broken</Title>
        <Description>If I `Ctrl+.` to convert 'var' to 'explicit' type and then 'Fix All in Document', the entire lightbulb menu+preview dialog disappears and nothing happens (no code fix is applied). </Description>
        <CreatedDate>04/11/2016</CreatedDate>
        <ClosedDate>29/11/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>15597</PullRequestID>
        <IssueID>15110</IssueID>
        <Title>fixed 2 known OOP issues</Title>
        <Description>1. there is a known issue where RequestServiceAsync might fail randomly.
   people are looking at the root cause, but until that is fixed,
   we will retry rather than failing right away.

2. if we close named pipe stream in the middle of object writer/reader is
   using them, we can get various exceptions. make sure we check cancellation
   before propagating that exception.</Description>
        <CreatedDate>09/11/2016</CreatedDate>
        <ClosedDate>28/11/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>15597</PullRequestID>
      <File>src/Features/Core/Portable/SolutionCrawler/WorkCoordinator.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/LanguageService/AbstractPackage`2.cs</File>
      <File>src/VisualStudio/Core/Next/Remote/ServiceHubRemoteHostClient.cs</File>
      <File>src/Workspaces/Remote/Core/Services/SolutionService.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Services/CodeAnalysisService_Diagnostics.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Services/ServiceHubServiceBase.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Shared/Extensions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>15584</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Ignore use-before-declaration in local functions (#15339)</Title>
    <Description>Prior to C# 7 we tried to avoid giving duplicate errors
when the user used a variable before it was declared (which
is both a use-before-declared and a use-before-assigned error),
but the line here is blurred with local functions, which can
use variables before they are declared in subtle ways that can't
be detected based on declaration order in syntax.

It may be possible to provide the earlier behavior, but the
current optimization is definitely insufficient and hides
legitimate errors in user programs.

Fixes #15298
Fixes #15322

(cherry picked from commit 1c8372cea14d7b75e8b55c6c38314291af165d5f)</Description>
    <CreatedDate>29/11/2016</CreatedDate>
    <ClosedDate>30/11/2016</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>15584</PullRequestID>
        <IssueID>15298</IssueID>
        <Title>Call to local function referencing then-undeclared variable incorrectly allowed</Title>
        <Description>**Version Used**: 2.0.0.61104 - which is in the recent VS2017RC release.

(Don't have a dev build set up, so I apologize if this has been fixed already - scanned through local function issues and couldn't find any related items, and didn't quickly see any tests with this specific case)

**Repro code**:

```csharp
class Program
{
    static void Main(string[] args)
    {
        Foo();
        int x = 2;
        void Foo() =&gt; System.Console.WriteLine(x); // prints "0"
    }
}
```

**Expected Behavior**:

Something similar to the following example:

```csharp
class Program
{
    static void Main(string[] args)
    {
        int x;
        Foo(); // CS0165: Use of unassigned local variable 'x'
        x = 2;
        void Foo() =&gt; System.Console.WriteLine(x);
    }
}
```

Ping @dotnet/roslyn-compiler - probably @agocke in particular?</Description>
        <CreatedDate>16/11/2016</CreatedDate>
        <ClosedDate>29/11/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>15584</PullRequestID>
        <IssueID>15322</IssueID>
        <Title>Roslyn fails to enforce definitely assigned rules and cannot emit code for local functions with closures over pattern variables in switch statements</Title>
        <Description>Following code should have error CS0165: Use of unassigned local variable 'x'

```cs
class Program
{
    static void Main(object[] args)
    {
        switch(args[0])
        {
            case string x:
                Foo(); // missing error
                break;
            case int x:
                void Foo() =&gt; System.Console.WriteLine(x);
                break;
        }
    }
}
```

Roslyn doesn't detect the error and fails to compile the code, this is VS2017 RC output:
```
csc.exe exited with code 255
```

Note that if you reorder the cases you get correct error i.e.
```cs
class Program
{
    static void Main(object[] args)
    {
        switch(args[0])
        {
            case int x:
                void Foo() =&gt; System.Console.WriteLine(x);
                break;
            case string x:
                Foo(); // error CS0165: Use of unassigned local variable 'x'
                break;
        }
    }
}
```

TryRoslyn emits following stacktrace for original code (it may be a bit outdated though):
```
The given key was not present in the dictionary. 
at System.Collections.Generic.Dictionary`2.get_Item(TKey key) 
at Microsoft.CodeAnalysis.CodeGen.LocalSlotManager.GetLocal(ILocalSymbol symbol) in ...\Src\Compilers\Core\Portable\CodeGen\LocalSlotManager.cs:line 148 
at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.GetLocal(LocalSymbol symbol) in ...\Src\Compilers\CSharp\Portable\CodeGen\EmitStatement.cs:line 1387 
at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.GetLocal(BoundLocal localExpression) in ...\Src\Compilers\CSharp\Portable\CodeGen\EmitStatement.cs:line 1382 
at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitLocalAddress(BoundLocal localAccess) in ...\Src\Compilers\CSharp\Portable\CodeGen\EmitAddress.cs:line 167 
at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitAddress(BoundExpression expression, AddressKind addressKind) in ...\Src\Compilers\CSharp\Portable\CodeGen\EmitAddress.cs:line 38 
at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitArgument(BoundExpression argument, RefKind refKind) in ...\Src\Compilers\CSharp\Portable\CodeGen\EmitExpression.cs:line 594 
at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitArguments(ImmutableArray`1 arguments, ImmutableArray`1 parameters) in ...\Src\Compilers\CSharp\Portable\CodeGen\EmitExpression.cs:line 769 
at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitCallExpression(BoundCall call, UseKind useKind) in ...\Src\Compilers\CSharp\Portable\CodeGen\EmitExpression.cs:line 1480 
at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitExpressionCore(BoundExpression expression, Boolean used) in ...\Src\Compilers\CSharp\Portable\CodeGen\EmitExpression.cs:line 92 
at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitExpressionCoreWithStackGuard(BoundExpression expression, Boolean used) in ...\Src\Compilers\CSharp\Portable\CodeGen\EmitExpression.cs:line 72 
at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitExpression(BoundExpression expression, Boolean used) in ...\Src\Compilers\CSharp\Portable\CodeGen\EmitExpression.cs:line 60 
```

ping @agocke </Description>
        <CreatedDate>17/11/2016</CreatedDate>
        <ClosedDate>29/11/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>15584</PullRequestID>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/DataFlowPass.LocalFunctions.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/DataFlowPass.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenLocalFunctionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/FlowAnalysis/LocalFunctions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>15548</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Combine deconstruction assignment and declaration, and support discards.</Title>
    <Description>- Combine deconstruction assignment and declaration, and support discards.
- Because tuples may contain declarations, adjust lambda disambiguation
  and adjust parsing of argument lists.
- Diagnose tuple element names on the left of a deconstruction.
- Add relational operators to disambiguating tokens in 7.5.4.2
- Remove `BoundVoid`

~~Fixes #15548 
Fixes #15549~~

Update (from jcouv): the bug numbers seem wrong. I think the correct ones were #14794
 and #14832

/cc @jcouv @AlekseyTs @VSadov @dotnet/roslyn-compiler </Description>
    <CreatedDate>27/11/2016</CreatedDate>
    <ClosedDate>12/12/2016</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>15548</PullRequestID>
        <IssueID>15548</IssueID>
        <Title>Combine deconstruction assignment and declaration, and support discards.</Title>
        <Description>- Combine deconstruction assignment and declaration, and support discards.
- Because tuples may contain declarations, adjust lambda disambiguation
  and adjust parsing of argument lists.
- Diagnose tuple element names on the left of a deconstruction.
- Add relational operators to disambiguating tokens in 7.5.4.2
- Remove `BoundVoid`

~~Fixes #15548 
Fixes #15549~~

Update (from jcouv): the bug numbers seem wrong. I think the correct ones were #14794
 and #14832

/cc @jcouv @AlekseyTs @VSadov @dotnet/roslyn-compiler </Description>
        <CreatedDate>27/11/2016</CreatedDate>
        <ClosedDate>12/12/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>15548</PullRequestID>
        <IssueID>15549</IssueID>
        <Title>Cleanup in FindReferences engine.</Title>
        <Description>1. For areas where we don't actually use parallalism, remove use of concurrent collections.
We can switch back to concurrent collections if we ever need them.

2. Use using aliases to make types clearer.

3. Simplify how progress was tracked in FAR.</Description>
        <CreatedDate>27/11/2016</CreatedDate>
        <ClosedDate>28/11/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>15548</PullRequestID>
        <IssueID>14794</IssueID>
        <Title>Proposed changes for deconstruction, declaration expressions, and discards</Title>
        <Description>This week's LDM meetings (2016-10-25 and 2016-10-26) proposed some possible changes to the handling of deconstruction, declaration expressions, and wildcards that, even if done later, would affect the shape of compiler APIs today. That suggests we would want to consider what to do today so that we are compatible with that possible future. This is a summary of the proposed changes and their API impact.
### Wildcards

The LDM is proposing to change the character that we would use to represent a "wildcard" from `*` to `_`. We also considered some alternatives, but both `*` and `?` have a logical (if not technical) ambiguity, because `int?` and `int*` are valid types. `_` doesn't likely have the same kind of syntactic ambiguity, because it is already an identifier in all of the places where we want to support wildcards. But it may be a _semantic_ ambiguity for that  same reason. The reason we like `_` is that users already introduce variables, for example parameters, named `_` when their intention is to ignore them.

We want to support both the "short form" `_` and the "long form" `var _` just in case there is an ambiguity with, for example, a field in scope. We'll return to this later.
### Declaration Expressions

We currently represent an out variable declaration using a "declaration expression" node in the syntax model. That was done because we were thinking that we may want to generalize declaration expressions in the future.

There is some slight discomfort with declaration expressions as they appear in the current API and proposed language spec, because while they are expressions in the syntax model, they are not expressions in the draft spec, and do not have types, and therefore there are special rules called out for them wherever they may appear in the specification. Besides the mismatch between the spec and model, we expect we may want to allow declaration expressions in more contexts in the future, in which case we will want them to be treated as expressions. In that case we will be better served by treating them as expressions (i.e. they can have a type) today.
### Deconstruction

Possibly generalizing declaration expressions in the future makes us want to reconsider our syntax model for deconstruction today. For example, given the statement

``` cs
(int x, int y) = e;
```

We can think of this as a special deconstruction declaration statement (as it is today), or alternatively we can think of it as a statement expressions containing an assignment expression with a tuple expression on the left-hand-side. In that case the tuple expression contains two declaration expressions. The latter formulation makes more sense in the possible future in which we generalize declaration expressions.

Similarly, given the statement

``` cs
var (x, y) = e;
```

We can think of this as a special deconstruction declaration statement (as it is today), or alternatively we can think of it as a statement expressions containing an assignment expression with a declaration expression on the left-hand-side. The latter formulation makes more sense in the possible future in which we generalize declaration expressions.

This reformulation of deconstruction allows us to remove from the syntax model the new statement form for a deconstruction declaration. It also allows us to generalize what we allow in the future:

``` cs
int x;
(x, int y) = e;
```

Here, the left-hand-side contains a mixture of already-existing variables (in this case `x`) and newly declared variables (`int y`). And it can be used in an expression context as well (e.g. as the body of an expression-bodied method).
### Wildcards (revisited)

Given this new understanding of the direction of the syntax, there are four forms that wildcards can take. First, it can take the place of an identifier in a _designator_ (i.e. in a declaration expression):

``` cs
var (x, _) = e;
(int x, int _) = e;
M(out int _);
```

Since `_` is already an identifier, no syntax model change is required. However, semantically we want this to create an anonymous variable, and shadow any true variable (e.g. parameter or field) from an enclosing scope named `_`. There is no name conflict error if wildcards are declared this way more than once in a scope.

Second, it can similarly be used to declare a pattern variable:

``` cs
switch (o)
{
    case int _:
    case long _:
        Console.WriteLine("int or long");
        break;
}
```

Third, it can take the place of an identifier in a simple expression where an lvalue is expected and is used as a target in a deconstruction assignment or out parameter, but in that case its special behavior as a wildcard only occurs if looking up `_` doesn't find a variable of that name

``` cs
M(out _);
(x, _) = e;
```

This special name lookup is similar to the way we handle `var`.

Finally, it can be used where a parameter can be declared today. However, we relax the single-definition rule to allow multiple conflicting declarations (same scope or nested scopes), in which case the identifier `_` binds as a wildcard.

``` cs
Func&lt;int, int, int&gt; f = (_,_) =&gt; 3;
```

We have to be careful with these changes so that any program that uses `_` as an identifier and is legal today continues to compile with the same meaning under these revised rules. 
### Syntax model changes

This allows us to simplify the handling of the `for` loop to handle deconstruction. Now the deconstruction is just one of the expressions in the expression list of the initializer part, and doesn't require its own placeholder in the syntax. That means that the syntax node for the `for` loop remains unchanged from the C# 6 version.

This requires a change to the way we handle the deconstruction form of the `foreach` loop. Because we want the left-hand-side to be capable of representing all of these forms

``` cs
foreach ((int x, int y) in e) ...
foreach ((int x, _) in e) ...
foreach (var (x, _) in e) ...
```

we now need to use _expression_ for the syntax node before the `in` keyword.

We can remove the syntax node for the _deconstruction declaration statement_, because that is just an assignment statement in this model.
### Syntax.xml changes

The following changes are proposed compared to the current [implementation in master](https://github.com/dotnet/roslyn/blob/master/src/Compilers/CSharp/Portable/Syntax/Syntax.xml). We **remove**

``` xml
  &lt;AbstractNode Name="VariableComponentSyntax" Base="CSharpSyntaxNode"&gt;
  &lt;/AbstractNode&gt;
  &lt;Node Name="TypedVariableComponentSyntax" Base="VariableComponentSyntax"&gt;
    &lt;Kind Name="TypedVariableComponent"/&gt;
    &lt;Field Name="Type" Type="TypeSyntax"/&gt;
    &lt;Field Name="Designation" Type="VariableDesignationSyntax"/&gt;
  &lt;/Node&gt;
  &lt;Node Name="ParenthesizedVariableComponentSyntax" Base="VariableComponentSyntax"&gt;
    &lt;Kind Name="ParenthesizedVariableComponent"/&gt;
    &lt;Field Name="OpenParenToken" Type="SyntaxToken"&gt;
      &lt;Kind Name="OpenParenToken"/&gt;
    &lt;/Field&gt;
    &lt;Field Name="Variables" Type="SeparatedSyntaxList&amp;lt;VariableComponentSyntax&amp;gt;"/&gt;
    &lt;Field Name="CloseParenToken" Type="SyntaxToken"&gt;
      &lt;Kind Name="CloseParenToken"/&gt;
    &lt;/Field&gt;
  &lt;/Node&gt;
  &lt;Node Name="DeconstructionDeclarationStatementSyntax" Base="StatementSyntax"&gt;
    &lt;Kind Name="DeconstructionDeclarationStatement"/&gt;
    &lt;Field Name="Modifiers" Type="SyntaxList&amp;lt;SyntaxToken&amp;gt;"/&gt;
    &lt;Field Name="Assignment" Type="VariableComponentAssignmentSyntax"/&gt;
    &lt;Field Name="SemicolonToken" Type="SyntaxToken"&gt;
      &lt;Kind Name="SemicolonToken"/&gt;
    &lt;/Field&gt;
  &lt;/Node&gt;
  &lt;Node Name="VariableComponentAssignmentSyntax" Base="CSharpSyntaxNode"&gt;
    &lt;Kind Name="VariableComponentAssignment"/&gt;
    &lt;Field Name="VariableComponent" Type="VariableComponentSyntax"/&gt;
    &lt;Field Name="EqualsToken" Type="SyntaxToken"&gt;
      &lt;Kind Name="EqualsToken"/&gt;
    &lt;/Field&gt;
    &lt;Field Name="Value" Type="ExpressionSyntax"/&gt;
  &lt;/Node&gt;
```

and we remove the `Deconstruction` field from the `ForStatementSyntax`

We change the `VariableComponent` field of `ForEachComponentStatementSyntax` to be an `ExpressionSyntax`, and probably change the name of `ForEachComponentStatementSyntax`.

And we change

``` xml
  &lt;Node Name="DeclarationExpressionSyntax" Base="ExpressionSyntax"&gt;
    &lt;Kind Name="DeclarationExpression"/&gt;
    &lt;Field Name="VariableComponent" Type="VariableComponentSyntax"&gt;
    &lt;/Field&gt;
  &lt;/Node&gt;
```

to

``` xml
  &lt;Node Name="DeclarationExpressionSyntax" Base="ExpressionSyntax"&gt;
    &lt;Kind Name="DeclarationExpression"/&gt;
    &lt;Field Name="Type" Type="TypeSyntax"/&gt;
    &lt;Field Name="Designation" Type="VariableDesignationSyntax"/&gt;
  &lt;/Node&gt;
```

We leave unchanged

``` xml
  &lt;AbstractNode Name="VariableDesignationSyntax" Base="CSharpSyntaxNode"&gt;
  &lt;/AbstractNode&gt;
  &lt;Node Name="SingleVariableDesignationSyntax" Base="VariableDesignationSyntax"&gt;
    &lt;Kind Name="SingleVariableDesignation"/&gt;
    &lt;Field Name="Identifier" Type="SyntaxToken"&gt;
      &lt;Kind Name="IdentifierToken"/&gt;
    &lt;/Field&gt;
  &lt;/Node&gt;
  &lt;Node Name="ParenthesizedVariableDesignationSyntax" Base="VariableDesignationSyntax"&gt;
    &lt;Kind Name="ParenthesizedVariableDesignation"/&gt;
    &lt;Field Name="OpenParenToken" Type="SyntaxToken"&gt;
      &lt;Kind Name="OpenParenToken"/&gt;
    &lt;/Field&gt;
    &lt;Field Name="Variables" Type="SeparatedSyntaxList&amp;lt;VariableDesignationSyntax&amp;gt;"/&gt;
    &lt;Field Name="CloseParenToken" Type="SyntaxToken"&gt;
      &lt;Kind Name="CloseParenToken"/&gt;
    &lt;/Field&gt;
  &lt;/Node&gt;
```
### SemanticModel changes

We may want to change the behavior of `GetTypeInfo` on a declaration expression, depending on how the shape of the specification evolves.

We probably need to consider what the behavior of `SemanticModel` APIs should be on wildcards.
### Summary

The changes to declaration expressions and deconstruction should be done today so that we don't have an incompatible change later.

Wildcards are an interesting problem. Even if we don't want to implement them for C# 7, we want to wall off the semantic space so that valid C# 7 programs don't change meaning or become invalid in a later language version. I suspect the simplest way to do that is to implement wildcards today.

/cc @dotnet/ldm @dotnet/roslyn-compiler 
</Description>
        <CreatedDate>28/10/2016</CreatedDate>
        <ClosedDate>14/01/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>15548</PullRequestID>
        <IssueID>14832</IssueID>
        <Title>Work Breakdown for "Proposed changes for deconstruction, declaration expressions, and discards"</Title>
        <Description>This is a breakdown of the work needed to implement the changes described in https://github.com/dotnet/roslyn/issues/14794 ("Proposed changes for deconstruction, declaration expressions, and wildcards")

### Language design loose ends

- [x] We need to specify more precisely the interaction of existing declarations (named `_`) with wildcards. (1 LDM meeting or less)
- [x] We should record the spec decisions in a suite of tests that describe the principal design points. (&lt; 1 day)
- [x] There are some [parsing ambiguity resolutions](https://github.com/dotnet/roslyn/issues/14794#issuecomment-257030797) that need to be decided and implemented. (&lt; 1 day)

### Syntax and parser changes

- [x] The syntax changes described in that issue need to be made in Syntax.xml (&lt; 1 day)
- [x] Corresponding changes to the parser need to be made. (&lt; 1 day)
  - [x] For the purpose of parsing, a declaration expression should be accepted in a tuple literal
- [x] Tests need to be modified and augmented to reflect these changes (&lt; 1 day)
- [x] There are no parser changes needed to support wildcards.

### Semantic analysis changes

- [x] Semantic analysis should reject a declaration expression in a tuple literal except in a deconstruction context, which is (&lt; 1 day)
  - [x] On the left-hand-side of an assignment expression
  - [x] In the variable of a `foreach` statement (which is now an ExpressionSyntax)
  - [x] A declaration expression is permitted in an out argument
  - [x] Other contexts will be an error, but may be supported in the future
- [x] Binding of a deconstruction assignment needs to be modified to support a mixture of existing variables (i.e. lvalue expressions), wildcards, and declaration expressions. (&lt; 4 days)
- [x] (requires LDM review) Pattern, out, and deconstruction variables that are declared but not used should cause a warning to be produced (because if you didn't want to use the variable you could have used a wildcard). (&lt; 1 day)

### Scoping changes

There are a number of changes related to the scoping of `_` as an identifier.
- [x] Remove support for the deconstruction declaration statement. It is a special case of an expression statement. (&lt; 1 day)
- [x] When binding an lvalue for a deconstruction or out argument, if we are looking up the simple identifier `_` and find nothing, we treat it as a target-typed wildcard rather than an error. (&lt; 1 day)
  - [x] This probably requires a new bound node, so that its type can be inferred for the purposes of lowering and the `SemanticModel`
- [x] When a declaration expression for an out argument or in a tuple expression declares `_`, we treat it as a wildcard.
- [ ] Permit multiple declarations for `_` lambda parameters, but they introduce nothing into scope. (&lt; 2 days) https://github.com/dotnet/roslyn/issues/16255
- [x] Debuggers should ignore wildcards, except lambda parameters should be displayed as `_`. (&lt; 2 days)
- [x] There are probably other scope-related behavioral changes for `_` that need to be specified and implemented. (&lt; 4 days)
- [x] Although it is proposed to support wildcards in lambda parameters such as `(_,_)=&gt;1`, I propose we not implement that in the first iteration of changes. It is a separable and compatible change that can be done in the next iteration.

### Lowering changes

- [x] Remove support for deconstruction declaration. (&lt; 1 day)
- [x] Generalize the assignment expression to allow declaration expressions and wildcards inside a tuple lvalue. (&lt; 1 day when done together with related binding changes)
- [x] We should be careful to retain the optimization that we do not construct a tuple result of a deconstruction assignment when it is in a context that discards the value.

### Semantic Model changes

The behavior for the semantic model needs to be decided in a design meeting among compiler folks and IDE people.

- [x] GetTypeInfo on a NameSyntax that is a wildcard should give the type of the discarded value. (&lt; 1 day)
- [x] We need to define the behavior for a declaration expression whose identifier is `_`.
- [x] GetTypeInfo on a declaration expression that is not a tuple should give the type of the variable.
- [x] GetTypeInfo on a declaration expression that is a tuple (e.g. `var (x, (y, _))`) should give the type of the consumed tuple value.
- [x] We need to define and implement the behavior for a tuple designator, like `(y, _)` in `var (x, (y, _))`.
- [x] Need tests to confirm that SemanticModel behavior (e.g. GetTypeInfo) works for non-declaration discard expressions in deconstruction expression, foreach loop, and for loop initializer.

### IDE impact (per @CyrusNajmabadi)

IDE impact for existing features is fairly superficial. The IDE tests are mostly behavioral, and virtually all of them of them remain correct in their current form. Most of the changes will just "work right" once the `SemanticModel` has been adjusted to implement behavior for the new features. (&lt; 2 days)

The rename refactoring will have to be modified to prevent you from renaming something to `_` unless it has no references.

There will be some opportunities for new features. For example, fixing a "pattern/out/deconstruction variable declared but not used" warning would be a small refactor that changes it to use a wildcard (i.e. rename it to `_`). That is a new feature, optional, and not required as part of this work.

### Other items to follow-up on:
- [x] Consider renaming `IDiscardedSymbol` to `IDiscardSymbol`

### Overall estimate

This assumes work done by area owners

Language design wrapup &lt; 1 day
Syntax changes &lt; 3 days
Scope changes &lt; 4 days
Semantics changes &lt; 4 days
Lowering changes &lt; 4 days
IDE changes &lt; 2 days

If the work herein is shared among area owners (e.g. scope work done or assisted by @AlekseyTs, deconstruction lowering done or assisted by @jcouv) this work can be largely completed over the duration of one sprint; it is less than one half of the team's work for the duration of a sprint, with a few smaller issues trailing into the following sprint.
</Description>
        <CreatedDate>31/10/2016</CreatedDate>
        <ClosedDate>24/01/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>15548</PullRequestID>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Deconstruct.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Expressions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Invocation.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Patterns.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Statements.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/ExpressionVariableFinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/ForEachLoopBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/OverloadResolution/OverloadResolution.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/OverloadResolution/OverloadResolutionResult.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/BoundDiscardExpression.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/Expression.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/Formatting.cs</File>
      <File>src/Compilers/CSharp/Portable/CSharpResources.Designer.cs</File>
      <File>src/Compilers/CSharp/Portable/CodeGen/EmitExpression.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/ErrorCode.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/MessageID.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/PreciseAbstractFlowPass.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_AssignmentOperator.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_DeconstructionAssignmentOperator.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_Patterns.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LoweredDynamicOperationFactory.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/SyntheticBoundNodeFactory.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/LanguageParser.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/LanguageParser_Patterns.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/SyntaxParser.cs</File>
      <File>src/Compilers/CSharp/Portable/SymbolDisplay/SymbolDisplayVisitor.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/DiscardSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceLocalSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Symbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/SymbolVisitor.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/SymbolVisitor`1.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/SymbolVisitor`2.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/InternalSyntax/TypeSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/SyntaxExtensions.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/SyntaxKind.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/TypeSyntax.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenDeconstructTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTupleTest.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Diagnostics/DiagnosticAnalyzerTests.AllInOne.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/DeconstructionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/ForEachTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/LocalFunctionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/OutVarTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTestBase.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests_Global.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests_Scope.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternSwitchTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/Source/FieldTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/AwaitParsingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/DeclarationExpressionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/DeconstructionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/LambdaParameterParsingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/LocalFunctionParsingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/ParserErrorMessageTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/ParsingErrorRecoveryTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/ParsingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/PatternParsingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/SeparatedSyntaxListParsingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/ValueTupleTests.cs</File>
      <File>src/Compilers/Core/Portable/Symbols/IDiscardSymbol.cs</File>
      <File>src/Compilers/Core/Portable/Symbols/SymbolKind.cs</File>
      <File>src/Compilers/Core/Portable/Symbols/SymbolVisitor.cs</File>
      <File>src/Compilers/Core/Portable/Symbols/SymbolVisitor`1.cs</File>
      <File>src/EditorFeatures/CSharpTest/Completion/CompletionProviders/SymbolCompletionProviderTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/DiagnosticAnalyzerDriver/DiagnosticAnalyzerDriverTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/GenerateMethod/GenerateMethodTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Formatting/Indentation/SmartIndenterTests.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Source/ExpressionCompiler/EvaluationContext.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Source/ExpressionCompiler/Rewriters/MayHaveSideEffectsVisitor.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Test/ExpressionCompiler/DeclarationTests.cs</File>
      <File>src/Workspaces/CSharp/Portable/Extensions/ContextQuery/SyntaxTreeExtensions.cs</File>
      <File>src/Workspaces/CSharp/Portable/LanguageServices/CSharpTypeInferenceService.TypeInferrer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>14798</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Never use raw arguments when running on Mono</Title>
    <Description>Fixes issues #9954 and #11317
</Description>
    <CreatedDate>28/10/2016</CreatedDate>
    <ClosedDate>08/11/2016</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>14798</PullRequestID>
        <IssueID>9954</IssueID>
        <Title>Command line argument parsing breaks on non-.net platforms</Title>
        <Description>**Version Used**:  1.2.0.60220

**Steps to Reproduce**:

Using Mono to run csc.exe on Windows uses following syntax

1.Run `C:\Program Files (x86)\Mono\bin&gt;mono-sgen.exe --attach=disable ..\..\..\roslyn\tools\csc.exe`

**Expected Behavior**:

Correctly parsed arguments of csc and not all arguments passed to mono-sgen.exe. This is issue in Roslyn codebase which assumes `csc.exe` is the process which in Mono case it's not true.

Relevant source code https://github.com/dotnet/roslyn/blob/df01b581f1e224d0e34418724679afeae3c5fa76/src/Compilers/Core/CommandLine/BuildClient.cs#L221

This is similar to #6677 except for Mono on Windows this is a blocker.

**Actual Behavior**:

Microsoft (R) Visual C# Compiler version 1.2.0.60220
Copyright (C) Microsoft Corporation. All rights reserved.

error CS2007: Unrecognized option: '--attach=disable'
</Description>
        <CreatedDate>22/03/2016</CreatedDate>
        <ClosedDate>16/11/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>14798</PullRequestID>
        <IssueID>11317</IssueID>
        <Title>Fix a bug with command line args on Windows+Mono, fixes #11316</Title>
        <Description>We shouldn't invoke `GetCommandLineWindows` on Mono. Otherwise, arguments for `mono csc.exe Program.cs` will be equal to [`csc.exe`, `Program.cs`] instead of [`Program.cs`]. As a result, csc.exe will try to compile binary content of `csc.exe`. Original bug report: #11316.
</Description>
        <CreatedDate>15/05/2016</CreatedDate>
        <ClosedDate>26/04/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>14798</PullRequestID>
      <File>src/Compilers/Shared/BuildClient.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>14729</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Handle expression variables defined in a switch case expression.</Title>
    <Description>Fixes #14717
See also #14727 

Note: this fixes a crash that can occur while typing a switch statement. Proposed for dev15-rc

@AlekseyTs @agocke Please review
@dotnet/roslyn-compiler Additional reviews welcome.
@MattGertz For ask mode approval.
</Description>
    <CreatedDate>25/10/2016</CreatedDate>
    <ClosedDate>26/10/2016</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>14729</PullRequestID>
        <IssueID>14717</IssueID>
        <Title>VS crash due NRE in Microsoft.CodeAnalysis.CSharp.Binder.BindDeclarationPattern</Title>
        <Description>Version: 
Latest Roslyn RC build (20161024.7).

Repro:
Create a new console app. Replace the code with the following, then copy &amp; paste `is EnvDTE.Project project` to the position indicated by `|`:

``` C#
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleApp2
{
    class Program
    {
        static void Main(string[] args)
        {
            switch (args)
            {
                case |
            }
        }
    }
}
```

Stack trace:

```
Message: System.NullReferenceException: Object reference not set to an instance of an object.
   at Microsoft.CodeAnalysis.CSharp.Binder.BindDeclarationPattern(DeclarationPatternSyntax node, BoundExpression operand, TypeSymbol operandType, Boolean hasErrors, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindPattern(PatternSyntax node, BoundExpression operand, TypeSymbol operandType, Boolean hasErrors, DiagnosticBag diagnostics, Boolean wasSwitchCase)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindIsPatternExpression(IsPatternExpressionSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpression(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed)
   at Microsoft.CodeAnalysis.CSharp.SwitchBinder.BuildSwitchLabels(SyntaxList`1 labelsSyntax, Binder sectionBinder, ArrayBuilder`1 labels, DiagnosticBag tempDiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.SwitchBinder.BuildLabels()
   at Microsoft.CodeAnalysis.CSharp.LocalScopeBinder.get_Labels()
   at Microsoft.CodeAnalysis.CSharp.SwitchBinder.get_LabelsByNode()
   at Microsoft.CodeAnalysis.CSharp.PatternSwitchBinder.BindPatternSwitchSection(BoundExpression boundSwitchExpression, SwitchSectionSyntax node, Binder originalBinder, BoundPatternSwitchLabel&amp; defaultLabel, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.PatternSwitchBinder.BindPatternSwitchSections(BoundExpression boundSwitchExpression, SyntaxList`1 sections, Binder originalBinder, BoundPatternSwitchLabel&amp; defaultLabel, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.PatternSwitchBinder.BindSwitchExpressionAndSections(SwitchStatementSyntax node, Binder originalBinder, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindSwitchExpressionAndSections(SwitchStatementSyntax node, Binder originalBinder, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindSwitchExpressionAndSections(SwitchStatementSyntax node, Binder originalBinder, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.IncrementalBinder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLowerBoundNode(CSharpSyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node, CSharpSyntaxNode&amp; bindableNode, BoundNode&amp; lowestBoundNode, BoundNode&amp; highestBoundNode, BoundNode&amp; boundParent)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetSymbolInfoWorker(CSharpSyntaxNode node, SymbolInfoOptions options, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetSymbolInfoWorker(CSharpSyntaxNode node, SymbolInfoOptions options, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(ExpressionSyntax expression, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.ClassifyTypeSyntax(NameSyntax name, SemanticModel semanticModel, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.ClassifyNode(SyntaxNode syntax, SemanticModel semanticModel, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService.Worker.ClassifyNode(SyntaxNode syntax)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService.Worker.ProcessNodes()
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService.Worker.Classify(Workspace workspace, SemanticModel semanticModel, TextSpan textSpan, List`1 list, Func`2 getNodeClassifiers, Func`2 getTokenClassifiers, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService.&lt;AddSemanticClassificationsAsync&gt;d__5.MoveNext()
Stack:
   at System.Environment.FailFast(System.String, System.Exception)
   at Microsoft.CodeAnalysis.FailFast.OnFatalException(System.Exception)
   at Microsoft.CodeAnalysis.ErrorReporting.FatalError.Report(System.Exception, System.Action`1&lt;System.Exception&gt;)
   at Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportUnlessCanceled(System.Exception)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__5.MoveNext()
   at Microsoft.CodeAnalysis.CSharp.Binder.BindDeclarationPattern(Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationPatternSyntax, Microsoft.CodeAnalysis.CSharp.BoundExpression, Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, Boolean, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindPattern(Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax, Microsoft.CodeAnalysis.CSharp.BoundExpression, Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, Boolean, Microsoft.CodeAnalysis.DiagnosticBag, Boolean)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindIsPatternExpression(Microsoft.CodeAnalysis.CSharp.Syntax.IsPatternExpressionSyntax, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, Microsoft.CodeAnalysis.DiagnosticBag, Boolean, Boolean)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, Microsoft.CodeAnalysis.DiagnosticBag, Boolean, Boolean)
   at Microsoft.CodeAnalysis.CSharp.SwitchBinder.BuildSwitchLabels(Microsoft.CodeAnalysis.SyntaxList`1&lt;Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax&gt;, Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol&gt;, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.SwitchBinder.BuildLabels()
   at Microsoft.CodeAnalysis.CSharp.LocalScopeBinder.get_Labels()
   at Microsoft.CodeAnalysis.CSharp.SwitchBinder.get_LabelsByNode()
   at Microsoft.CodeAnalysis.CSharp.PatternSwitchBinder.BindPatternSwitchSection(Microsoft.CodeAnalysis.CSharp.BoundExpression, Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax, Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.CSharp.BoundPatternSwitchLabel ByRef, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.PatternSwitchBinder.BindPatternSwitchSections(Microsoft.CodeAnalysis.CSharp.BoundExpression, Microsoft.CodeAnalysis.SyntaxList`1&lt;Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax&gt;, Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.CSharp.BoundPatternSwitchLabel ByRef, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.PatternSwitchBinder.BindSwitchExpressionAndSections(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax, Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindSwitchExpressionAndSections(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax, Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindSwitchExpressionAndSections(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax, Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel+IncrementalBinder.BindStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Bind(Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.Bind(Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLowerBoundNode(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetSymbolInfoWorker(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, SymbolInfoOptions, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetSymbolInfoWorker(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, SymbolInfoOptions, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.ClassifyTypeSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax, Microsoft.CodeAnalysis.SemanticModel, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.ClassifyNode(Microsoft.CodeAnalysis.SyntaxNode, Microsoft.CodeAnalysis.SemanticModel, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService+Worker.ClassifyNode(Microsoft.CodeAnalysis.SyntaxNode)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService+Worker.ProcessNodes()
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService+Worker.Classify(Microsoft.CodeAnalysis.Workspace, Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.Text.TextSpan, System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__5.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Classification.AbstractClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__5, Microsoft.CodeAnalysis.Workspaces, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;AddSemanticClassificationsAsync&gt;d__5 ByRef)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Document, Microsoft.CodeAnalysis.Text.TextSpan, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.AbstractEditorClassificationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Document, Microsoft.CodeAnalysis.Text.TextSpan, System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ClassifySpansAsync&gt;d__2.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ClassifySpansAsync&gt;d__2, Microsoft.CodeAnalysis.EditorFeatures, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;ClassifySpansAsync&gt;d__2 ByRef)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.ClassifySpansAsync(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IEditorClassificationService, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;TryClassifyContainingMemberSpan&gt;d__1.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].Start[[Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;TryClassifyContainingMemberSpan&gt;d__1, Microsoft.CodeAnalysis.EditorFeatures, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;TryClassifyContainingMemberSpan&gt;d__1 ByRef)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.TryClassifyContainingMemberSpan(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IEditorClassificationService, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ProduceTagsAsync&gt;d__0.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ProduceTagsAsync&gt;d__0, Microsoft.CodeAnalysis.EditorFeatures, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;ProduceTagsAsync&gt;d__0 ByRef)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.ProduceTagsAsync(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IEditorClassificationService, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationViewTaggerProvider.ProduceTagsAsync(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;)
   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].ProduceTagsAsync(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;System.__Canon&gt;)
   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource+&lt;RecomputeTagsAsync&gt;d__83[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource+&lt;RecomputeTagsAsync&gt;d__83[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Microsoft.CodeAnalysis.EditorFeatures, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;RecomputeTagsAsync&gt;d__83&lt;System.__Canon&gt; ByRef)
   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].RecomputeTagsAsync(System.Object, System.Nullable`1&lt;Microsoft.VisualStudio.Text.SnapshotPoint&gt;, System.Nullable`1&lt;Microsoft.CodeAnalysis.Text.TextChangeRange&gt;, System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan&gt;, System.Collections.Immutable.ImmutableDictionary`2&lt;Microsoft.VisualStudio.Text.ITextBuffer,Microsoft.CodeAnalysis.Editor.Shared.Tagging.TagSpanIntervalTree`1&lt;System.__Canon&gt;&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource+&lt;&gt;c__DisplayClass74_0[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].&lt;RecomputeTagsForeground&gt;b__0(System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.Shared.Threading.AsynchronousSerialWorkQueue+&lt;&gt;c__DisplayClass11_0.&lt;EnqueueBackgroundTask&gt;b__0(System.Threading.Tasks.Task)
   at System.Threading.Tasks.ContinuationResultTaskFromTask`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].InnerInvoke()
   at System.Threading.Tasks.Task.Execute()
   at System.Threading.Tasks.Task.ExecutionContextCallback(System.Object)
   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)
   at System.Threading.Tasks.Task.ExecuteEntry(Boolean)
   at System.Threading.Tasks.Task.System.Threading.IThreadPoolWorkItem.ExecuteWorkItem()
   at System.Threading.ThreadPoolWorkQueue.Dispatch()
   at System.Threading._ThreadPoolWaitCallback.PerformWaitCallback()
```
</Description>
        <CreatedDate>25/10/2016</CreatedDate>
        <ClosedDate>26/10/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>14729</PullRequestID>
        <IssueID>14727</IssueID>
        <Title>Need additional tests for expression variables defined in a switch case expression</Title>
        <Description>... including the behavior of SemanticModel.

Such tests would have caught https://github.com/dotnet/roslyn/issues/14717 earlier.
</Description>
        <CreatedDate>25/10/2016</CreatedDate>
        <ClosedDate>26/10/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>14729</PullRequestID>
      <File>src/Compilers/CSharp/Portable/Binder/ExpressionVariableFinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/LocalBinderFactory.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/OutVarTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTestBase.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternSwitchTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>14711</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Fixing a crash when consuming combinations of ref returns, tuples and dynamic from metadata</Title>
    <Description>Decoder of dynamic flags does not distinguish between parameters and returns and historically "ref" was assigned an extra dynamic flag (always false). 
We do not encode that extra flag for the ref returns thus making the flags invalid for that scenario. Normally this would just result in a loss of  dynamic/object  distinction which is bad but not fatal. However if there is a tuple involved we would crash with NRE.

This change fixes
- encode dynamic flags on ref returns as expected by the decoder.
- handling unexpected/misaligned dynamic flags in a case of tuples without crashing

Fixes:#14708
Fixes:#14709
</Description>
    <CreatedDate>24/10/2016</CreatedDate>
    <ClosedDate>27/10/2016</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>14711</PullRequestID>
        <IssueID>14708</IssueID>
        <Title>We are not handling malformed dynamic flags on tuple elements gracefully.</Title>
        <Description>One scenario that could get us into such situation is caused by another bug, but generally misaligned dynamic flags should be ignored. 

metadata reference:

``` cs
namespace ClassLibrary1
{
    public class C1
    {
        // because of another bug we are emitting fewer dynamic flags than expected by decoder here
        // so 'dynamic' should be ignored
        public virtual ref (int, dynamic) Foo(int  arg)
        {
            throw null;
        }
    }
}
```

console app:

``` cs
namespace ConsoleApplication5
{
    class Program
    {
        static void Main(string[] args)
        {
        }
    }

    class C2: ClassLibrary1.C1
    {
        public override ref (int, object) Foo(int arg)
        {
            throw null;
        }
    }
}
```

We crash with NullReferenceException

Microsoft.CodeAnalysis.CSharp.ni!Microsoft.CodeAnalysis.CSharp.Symbols.TupleTypeSymbol.Create in TupleTypeSymbol.cs
at Microsoft.CodeAnalysis.CSharp.ni!Microsoft.CodeAnalysis.CSharp.Symbols.TupleTypeSymbol.Create in TupleTypeSymbol.cs
at Microsoft.CodeAnalysis.CSharp.ni!Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.DynamicTypeDecoder.TransformNamedType in DynamicTypeDecoder.cs
at Microsoft.CodeAnalysis.CSharp.ni!Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.DynamicTypeDecoder.TransformType in DynamicTypeDecoder.cs
at Microsoft.CodeAnalysis.CSharp.ni!Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.DynamicTypeDecoder.TransformTypeInternal in DynamicTypeDecoder.cs
at Microsoft.CodeAnalysis.CSharp.ni!Microsoft.CodeAnalysis.CSharp.Symbols.CustomModifierUtils.CopyTypeCustomModifiers in CustomModifierUtils.cs
at Microsoft.CodeAnalysis.CSharp.ni!Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertyAccessorSymbol.MethodChecks in SourcePropertyAccessorSymbol.cs
at Microsoft.CodeAnalysis.CSharp.ni!Microsoft.CodeAnalysis.CSharp.Symbols.SourceMethodSymbol.LazyMethodChecks in SourceMethodSymbol.cs
at Microsoft.CodeAnalysis.CSharp.ni!Microsoft.CodeAnalysis.CSharp.Symbols.SourceMethodSymbol.get_OverriddenOrHiddenMembers in SourceMethodSymbol.cs
at Microsoft.CodeAnalysis.CSharp.ni!Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.CheckMembersAgainstBaseType in SourceMemberContainerSymbol_ImplementationChecks.cs
</Description>
        <CreatedDate>24/10/2016</CreatedDate>
        <ClosedDate>29/10/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>14711</PullRequestID>
        <IssueID>14709</IssueID>
        <Title>dynamic flags emitted for ref returns do not match what expected by the decoder.</Title>
        <Description>Decoder treats return signature slot as another parameter and thus historically expects that there will be a flag for the "ref".
That flag is currently missing for ref returns and as a result the flags are invalid.

Normally such situation would lead to flags being ignored, but in combination with another bug
(https://github.com/dotnet/roslyn/issues/14708) it currently causes crashes.

metadata reference:

``` cs
namespace ClassLibrary1
{
    public class C1
    {
        // because of another bug we are emitting fewer dynamic flags than expected by decoder here
        // so 'dynamic' should be ignored
        public virtual ref (int, dynamic) Foo(int  arg)
        {
            throw null;
        }
    }
}
```

console app:

``` cs
namespace ConsoleApplication5
{
    class Program
    {
        static void Main(string[] args)
        {
        }
    }

    class C2: ClassLibrary1.C1
    {
        public override ref (int, object) Foo(int arg)
        {
            throw null;
        }
    }
}
```

We crash with NullReferenceException

Microsoft.CodeAnalysis.CSharp.ni!Microsoft.CodeAnalysis.CSharp.Symbols.TupleTypeSymbol.Create in TupleTypeSymbol.cs
at Microsoft.CodeAnalysis.CSharp.ni!Microsoft.CodeAnalysis.CSharp.Symbols.TupleTypeSymbol.Create in TupleTypeSymbol.cs
at Microsoft.CodeAnalysis.CSharp.ni!Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.DynamicTypeDecoder.TransformNamedType in DynamicTypeDecoder.cs
at Microsoft.CodeAnalysis.CSharp.ni!Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.DynamicTypeDecoder.TransformType in DynamicTypeDecoder.cs
at Microsoft.CodeAnalysis.CSharp.ni!Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.DynamicTypeDecoder.TransformTypeInternal in DynamicTypeDecoder.cs
at Microsoft.CodeAnalysis.CSharp.ni!Microsoft.CodeAnalysis.CSharp.Symbols.CustomModifierUtils.CopyTypeCustomModifiers in CustomModifierUtils.cs
at Microsoft.CodeAnalysis.CSharp.ni!Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertyAccessorSymbol.MethodChecks in SourcePropertyAccessorSymbol.cs
at Microsoft.CodeAnalysis.CSharp.ni!Microsoft.CodeAnalysis.CSharp.Symbols.SourceMethodSymbol.LazyMethodChecks in SourceMethodSymbol.cs
at Microsoft.CodeAnalysis.CSharp.ni!Microsoft.CodeAnalysis.CSharp.Symbols.SourceMethodSymbol.get_OverriddenOrHiddenMembers in SourceMethodSymbol.cs
at Microsoft.CodeAnalysis.CSharp.ni!Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.CheckMembersAgainstBaseType in SourceMemberContainerSymbol_ImplementationChecks.cs
</Description>
        <CreatedDate>24/10/2016</CreatedDate>
        <ClosedDate>29/10/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>14711</PullRequestID>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/DynamicTypeDecoder.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PEPropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/CustomModifierUtils.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceEventSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourcePropertyAccessorSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourcePropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTupleTest.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>14698</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Compiler server should be tolerant of corrupted application settings</Title>
    <Description>When a machine.config or app.config is corrupted it's possible for `ConfigurationManager.AppSettings` to throw an exception.  The compiler server was not tolerant of such a failure and as a result would terminate immediately after startup.

The compiler workflow is generally very tolerant of failures in the server.  It is an optimization only, and any crashes, bad results, etc ... are ignored and the workflow will fall back to the command line.  Failing on startup is one case the workflow does not handle well right now.  The workflow does not distinguish between a crash at startup and a very slow JIT situation (as is the case with old, single core machines).  As such it ends up adding an unnecessary 25 second delay to the compilation.  Issue #14265 tracks fixing this delay but it won't make RC.

Up until now only one incident of corrupted app settings was reported and it was considered an extremely unlikely problem (as it would break a lot of apps).  Going through VS feedback last night I found one other incident which could would be explained by this problem.  Hence it's possible this is more likley than originally thought (although still very rare) and decided to put it into RC.

closes #14288
</Description>
    <CreatedDate>24/10/2016</CreatedDate>
    <ClosedDate>25/10/2016</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>14698</PullRequestID>
        <IssueID>14265</IssueID>
        <Title>Compiler needs to be tolerant of failed server startup</Title>
        <Description>The compilers do not monitor the VBCSCompiler process for crashes during startup.  Instead it assumes startup succeeds and unconditionally waits the standard timeout (20 seconds) until timing out on the named pipe connection.

While rare it is possible for VBCSCompiler to crash on startup.  One example recently demonstrated by a customer is an invalid machine.config file.  In that case the server crashes 100% of the time on startup and hence there is always a 20+ second delay in compiling code.  

The fix is to monitor the server process.  It's exit needs to be considered as a part of waiting on the named pipe connection.  
</Description>
        <CreatedDate>04/10/2016</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>14698</PullRequestID>
        <IssueID>14288</IssueID>
        <Title>Must handle corrupted application settings</Title>
        <Description>The compiler makes use of `ConfigurationManager.AppSettings`.  In the cases where an application configuration file, or the machine wide config file, is corrupted accessing this property will throw.  The compiler code base must be tolerant of this fault.  
</Description>
        <CreatedDate>05/10/2016</CreatedDate>
        <ClosedDate>26/10/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>14698</PullRequestID>
      <File>src/Compilers/Server/VBCSCompiler/DesktopBuildServerController.cs</File>
      <File>src/Compilers/Server/VBCSCompiler/VBCSCompiler.cs</File>
      <File>src/Compilers/Server/VBCSCompilerTests/VBCSCompilerServerTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>13877</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Fixes 7 failing pattern matching tests due to an incorrect assumption about standard cultural settings</Title>
    <Description>This fixes an issue related to #10362:

7 of the C# pattern matching tests in master fail due to the use of `Roslyn.Test.Utilities.EnsureEnglishCulture`: The tests print out some numbers, expecting them to be formatted using English formatting rules. To ensure this, the `EnsureEnglishCulture` class is used.
This class basically checks if the current culture's names starts with `en` (which it does in my case) and then does nothing -- otherwise, it sets the invariant culture. However, as shown in #10362, I use non-standard cultural settings for the `en` culture, in particular changing the decimal symbol. Thus, the `GeneralizedSwitchStatement` test, for instance, fails as it prints out `double 1,2` instead of `double 1.2`.

This issue can be fixed by always setting the invariant culture, in which case all 7 tests succeed. In that case, however, the entire class should probably be renamed to `EnsureInvariantCulture`. As the class is only used by the pattern matching tests, this change seems to be safe. 

This pull requests thus makes the necessary changes to fix the tests.
</Description>
    <CreatedDate>17/09/2016</CreatedDate>
    <ClosedDate>21/09/2016</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>13877</PullRequestID>
        <IssueID>10362</IssueID>
        <Title>[Test Failure] Some tests fail due to non-standard cultural settings</Title>
        <Description>I'm encountering test failures on my local Windows machine (even though the build servers show all tests as passing). I'm on the latest commit 9bac4a6f86515f2d6f9a09d07dc73bc7e81dd7e4 in the master branch. The failing tests are:
- `Microsoft.CodeAnalysis.VisualBasic.UnitTests.Semantics.BinaryOperators.Test1`
- `Microsoft.CodeAnalysis.VisualBasic.UnitTests.AnonymousTypesCodeGenTests.TestAnonymousType_ToString`
- `Microsoft.CodeAnalysis.VisualBasic.UnitTests.AnonymousTypesCodeGenTests.TestAnonymousType_LocalAsNewWith`
- `Microsoft.CodeAnalysis.VisualBasic.UnitTests.StaticLocalsSemanticTests.Semantic_StaticLocalDeclaration_LateBound`
- `Microsoft.CodeAnalysis.CSharp.UnitTests.Symbols.AnonymousTypesSymbolTests.AnonymousType_ToString`

A quick investigation showed that the root cause seems to be my unusual culture settings in Windows:

![roslyn cultural settings](https://cloud.githubusercontent.com/assets/1945136/14309911/69a208f6-fbdf-11e5-9699-af5379cac41e.png)

In particular, I use the en-US culture, but modified the decimal symbol to be `,` and the digit grouping symbol to be `.`, like it is in German. Switching these back to the default cause all tests to succeed again, except for `BinaryOperators.Test1`. That one fails because I'm not using the US date time format and can thus be fixed by reverting to it.

**Fix**

I don't think that tests should depend on cultural settings. In fact, the tests (except for `BinaryOperators.Test1` as far as I can see) actually try to avoid this problem by changing the executing thread's current culture before executing the tests and reverting the culture afterwards. However, they are explicitly using the `en-US` culture, which I've modified with my Windows settings. Hence the output

```
Expected: { a = 1, b = text, c = 123.456 }
Actual:   { a = 1, b = text, c = 123,456 }
```

for `Microsoft.CodeAnalysis.VisualBasic.UnitTests.AnonymousTypesCodeGenTests.TestAnonymousType_ToString`, for instance.

The fix seems to be to replace the line `System.Threading.Thread.CurrentThread.CurrentCulture = New System.Globalization.CultureInfo("en-US")` with `System.Threading.Thread.CurrentThread.CurrentCulture = System.Globalization.CultureInfo.InvariantCulture`, which seems to be the correct culture to use in this case. From [MSDN](https://msdn.microsoft.com/en-us/library/system.globalization.cultureinfo.invariantculture%28v=vs.110%29.aspx?f=255&amp;MSPPError=-2147217396) (emphasis mine):

&gt; Unlike **culture-sensitive data**, which is **subject to change by user customization** or by updates to the .NET Framework or the operating system, **invariant culture data is stable over time and across installed cultures and cannot be customized by users**. This makes the invariant culture particularly useful for operations that **require culture-independent results**, such as formatting and parsing operations that persist formatted data, or sorting and ordering operations **that require that data be displayed in a fixed order regardless of culture**. 

The other tests could be fixed in a similar way. Let me know if you think this fix is correct and I'll submit a pull request. 
</Description>
        <CreatedDate>06/04/2016</CreatedDate>
        <ClosedDate>21/09/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>13877</PullRequestID>
        <IssueID>10362</IssueID>
        <Title>[Test Failure] Some tests fail due to non-standard cultural settings</Title>
        <Description>I'm encountering test failures on my local Windows machine (even though the build servers show all tests as passing). I'm on the latest commit 9bac4a6f86515f2d6f9a09d07dc73bc7e81dd7e4 in the master branch. The failing tests are:
- `Microsoft.CodeAnalysis.VisualBasic.UnitTests.Semantics.BinaryOperators.Test1`
- `Microsoft.CodeAnalysis.VisualBasic.UnitTests.AnonymousTypesCodeGenTests.TestAnonymousType_ToString`
- `Microsoft.CodeAnalysis.VisualBasic.UnitTests.AnonymousTypesCodeGenTests.TestAnonymousType_LocalAsNewWith`
- `Microsoft.CodeAnalysis.VisualBasic.UnitTests.StaticLocalsSemanticTests.Semantic_StaticLocalDeclaration_LateBound`
- `Microsoft.CodeAnalysis.CSharp.UnitTests.Symbols.AnonymousTypesSymbolTests.AnonymousType_ToString`

A quick investigation showed that the root cause seems to be my unusual culture settings in Windows:

![roslyn cultural settings](https://cloud.githubusercontent.com/assets/1945136/14309911/69a208f6-fbdf-11e5-9699-af5379cac41e.png)

In particular, I use the en-US culture, but modified the decimal symbol to be `,` and the digit grouping symbol to be `.`, like it is in German. Switching these back to the default cause all tests to succeed again, except for `BinaryOperators.Test1`. That one fails because I'm not using the US date time format and can thus be fixed by reverting to it.

**Fix**

I don't think that tests should depend on cultural settings. In fact, the tests (except for `BinaryOperators.Test1` as far as I can see) actually try to avoid this problem by changing the executing thread's current culture before executing the tests and reverting the culture afterwards. However, they are explicitly using the `en-US` culture, which I've modified with my Windows settings. Hence the output

```
Expected: { a = 1, b = text, c = 123.456 }
Actual:   { a = 1, b = text, c = 123,456 }
```

for `Microsoft.CodeAnalysis.VisualBasic.UnitTests.AnonymousTypesCodeGenTests.TestAnonymousType_ToString`, for instance.

The fix seems to be to replace the line `System.Threading.Thread.CurrentThread.CurrentCulture = New System.Globalization.CultureInfo("en-US")` with `System.Threading.Thread.CurrentThread.CurrentCulture = System.Globalization.CultureInfo.InvariantCulture`, which seems to be the correct culture to use in this case. From [MSDN](https://msdn.microsoft.com/en-us/library/system.globalization.cultureinfo.invariantculture%28v=vs.110%29.aspx?f=255&amp;MSPPError=-2147217396) (emphasis mine):

&gt; Unlike **culture-sensitive data**, which is **subject to change by user customization** or by updates to the .NET Framework or the operating system, **invariant culture data is stable over time and across installed cultures and cannot be customized by users**. This makes the invariant culture particularly useful for operations that **require culture-independent results**, such as formatting and parsing operations that persist formatted data, or sorting and ordering operations **that require that data be displayed in a fixed order regardless of culture**. 

The other tests could be fixed in a similar way. Let me know if you think this fix is correct and I'll submit a pull request. 
</Description>
        <CreatedDate>06/04/2016</CreatedDate>
        <ClosedDate>21/09/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>13877</PullRequestID>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests.cs</File>
      <File>src/Test/Utilities/Shared/FX/EnsureEnglishCulture.cs</File>
      <File>src/Test/Utilities/Shared/FX/EnsureInvariantCulture.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>13865</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Ensure proper validation of operator signatures when tuple types are involved.</Title>
    <Description>Fixes #11986.
Fixes #11530.

@dotnet/roslyn-compiler, @VSadov, @jcouv Please review.
</Description>
    <CreatedDate>16/09/2016</CreatedDate>
    <ClosedDate>20/09/2016</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>13865</PullRequestID>
        <IssueID>11986</IssueID>
        <Title>Tuple implementation rejects implicit operators</Title>
        <Description>Related to #11530, the following code is improperly rejected by the tuple implementation in `master`.

``` cs
namespace System
{
    public struct ValueTuple&lt;T1, T2&gt;
    {
        public T1 Item1;
        public T2 Item2;
        public ValueTuple(T1 item1, T2 item2)
        {
            this.Item1 = item1;
            this.Item2 = item2;
        }

        // error: conversion must convert to or from enclosing type
        public static explicit operator int((T1, T2)? source)
        {
            return 1;
        }
        // error: conversion must convert to or from enclosing type
        public static explicit operator long(Nullable&lt;(T1, T2)&gt; source)
        {
            return 1;
        }
        // error: conversion must convert to or from enclosing type
        public static explicit operator string(Nullable&lt;ValueTuple&lt;T1, T2&gt;&gt; source)
        {
            return "";
        }
        // error: conversion must convert to or from enclosing type
        public static explicit operator double(ValueTuple&lt;T1, T2&gt;? source)
        {
            return 1;
        }
    }
}
```
</Description>
        <CreatedDate>14/06/2016</CreatedDate>
        <ClosedDate>20/09/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>13865</PullRequestID>
        <IssueID>11530</IssueID>
        <Title>Tuple implementation rejects implicit operators</Title>
        <Description>The following code is improperly rejected by the tuple implementation

``` cs
namespace System
{
    public struct ValueTuple&lt;T1, T2&gt;
    {
        public T1 Item1;
        public T2 Item2;

        // error: conversion must convert to or from enclosing type
        public static implicit operator Collections.Generic.KeyValuePair&lt;T1, T2&gt;(ValueTuple&lt;T1, T2&gt; tuple)
        {
            T1 k;
            T2 v;
            (k, v) = tuple;
            return new KeyValuePair&lt;T1, T2&gt;(k, v);
        }

        // error: conversion must convert to or from enclosing type
        public static implicit operator ValueTuple&lt;T1, T2&gt;(Collections.Generic.KeyValuePair&lt;T1, T2&gt; kvp)
        {
            return (kvp.Key, kvp.Value);
        }
    }
}
```

This was tested against https://github.com/jcouv/roslyn/tree/tuple-deconstruction (from https://github.com/dotnet/roslyn/pull/11457) at commit https://github.com/jcouv/roslyn/commit/c7b60a478ce0f5993d1e7a85af17545b96611a9e
</Description>
        <CreatedDate>24/05/2016</CreatedDate>
        <ClosedDate>20/09/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>13865</PullRequestID>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceUserDefinedOperatorSymbolBase.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTupleTest.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>13851</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Adding tests to close #13661 and #12802</Title>
    <Description>Both issues no longer repro.

Chuck noticed an assertion with long tuples with missing names, such as `var o = (A: 1, 2, C: 3, D: 4, E: 5, F: 6, G: 7, 8, I: 9);`. This is issue #13661. This was fixed by Vlad's preview 5 fix to rationalize `TupleTypeSymbol.CreateMembers` and align it between C# and VB.

I'd noticed a refactoring problem with decontruction, #12802. The generated code was not simplified far enough. This no longer repros.

@dotnet/roslyn-compiler for review.
</Description>
    <CreatedDate>16/09/2016</CreatedDate>
    <ClosedDate>17/09/2016</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>13851</PullRequestID>
        <IssueID>13661</IssueID>
        <Title>Assert failure in TupleVirtualElementFieldSymbol..ctor</Title>
        <Description>Compiling the following results in an assert failure in `TupleVirtualElementFieldSymbol..ctor`: `Debug.Assert(name != null)`.

```
class C
{
    static void Main()
    {
        var o = (A: 1, 2, C: 3, D: 4, E: 5, F: 6, G: 7, 8, I: 9);
    }
}
```
</Description>
        <CreatedDate>07/09/2016</CreatedDate>
        <ClosedDate>17/09/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>13851</PullRequestID>
        <IssueID>12802</IssueID>
        <Title>Un-necessary parens and type arguments introduced by inline variable on deconstruction</Title>
        <Description>This is probably a problem in the IDE simplification logic.

![extra-parens](https://cloud.githubusercontent.com/assets/12466233/17224519/11ccbd76-54b6-11e6-889b-a0101fdb5ea0.png)
</Description>
        <CreatedDate>28/07/2016</CreatedDate>
        <ClosedDate>14/09/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>13851</PullRequestID>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTupleTest.cs</File>
      <File>src/EditorFeatures/CSharpTest/CodeActions/InlineTemporary/InlineTemporaryTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>13818</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Handle Out Variable Declarations in a Script.</Title>
    <Description>Fixes #13450.
Fixes #13590.

@dotnet/roslyn-compiler Please review.
</Description>
    <CreatedDate>15/09/2016</CreatedDate>
    <ClosedDate>16/09/2016</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>13818</PullRequestID>
        <IssueID>13450</IssueID>
        <Title>Out variables in top level script causes .GetDiagnostics() to throw an exception</Title>
        <Description>**Version Used**: Commit 9e6ecbd6 (8/27/2016)

**Steps to Reproduce**:
1. Create a console project with the code below:

``` csharp
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;

namespace SemanticsCS
{
    class Program
    {
        static void Main(string[] args)
        {
            SyntaxTree tree = CSharpSyntaxTree.ParseText(
@"using System;
using System.Collections.Generic;
using System.Text;

OutVar(out string q);

void OutVar(out string s)
{
    s = null;
}", options: new CSharpParseOptions(kind: SourceCodeKind.Script ));

            var root = (CompilationUnitSyntax)tree.GetRoot();

            var compilation = CSharpCompilation.Create("HelloWorld")
                                               .AddReferences(
                                                    MetadataReference.CreateFromFile(
                                                        typeof(object).Assembly.Location))
                                               .AddSyntaxTrees(tree);

            Console.WriteLine("Just before .GetDiagnostics()");
            var diags = compilation.GetDiagnostics(); //Exception occurs here.
        }
    }
}
```
1. Reference the M.CodeAnalysis and M.CodeAnalysis.CSharp libraries compiled from the source tree (not from Nuget)

**Expected Behavior**: Get diagnostics.

**Actual Behavior**: Throws InvalidOperationException "This program location is thought to be unreachable."

```
StackTrace:

   at Microsoft.CodeAnalysis.CSharp.Binder.BindArgumentValue(DiagnosticBag diagnostics, ArgumentSyntax argumentSyntax, Boolean allowArglist, RefKind refKind) in F:\Roslyn_Project\Roslyn\roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 2076
   at Microsoft.CodeAnalysis.CSharp.Binder.BindArgumentAndName(AnalyzedArguments result, DiagnosticBag diagnostics, Boolean hadError, ArgumentSyntax argumentSyntax, Boolean allowArglist, Boolean isDelegateCreation) in F:\Roslyn_Project\Roslyn\roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 2010
   at Microsoft.CodeAnalysis.CSharp.Binder.BindInvocationExpression(InvocationExpressionSyntax node, DiagnosticBag diagnostics) in F:\Roslyn_Project\Roslyn\roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Invocation.cs:line 145
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed) in F:\Roslyn_Project\Roslyn\roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 452
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpression(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed) in F:\Roslyn_Project\Roslyn\roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 396
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionStatement(CSharpSyntaxNode node, ExpressionSyntax syntax, Boolean allowsAnyExpression, DiagnosticBag diagnostics) in F:\Roslyn_Project\Roslyn\roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 533
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionStatement(ExpressionStatementSyntax node, DiagnosticBag diagnostics) in F:\Roslyn_Project\Roslyn\roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 526
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics) in F:\Roslyn_Project\Roslyn\roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 50
   at Microsoft.CodeAnalysis.CSharp.Binder.BindGlobalStatement(Binder binder, SynthesizedInteractiveInitializerMethod scriptInitializer, StatementSyntax statementNode, DiagnosticBag diagnostics, Boolean isLast) in F:\Roslyn_Project\Roslyn\roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Initializers.cs:line 212
   at Microsoft.CodeAnalysis.CSharp.Binder.BindScriptFieldInitializers(CSharpCompilation compilation, SynthesizedInteractiveInitializerMethod scriptInitializer, ImmutableArray`1 initializers, ArrayBuilder`1 boundInitializers, DiagnosticBag diagnostics, ImportChain&amp; firstDebugImports) in F:\Roslyn_Project\Roslyn\roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Initializers.cs:line 192
   at Microsoft.CodeAnalysis.CSharp.Binder.BindFieldInitializers(CSharpCompilation compilation, SynthesizedInteractiveInitializerMethod scriptInitializerOpt, ImmutableArray`1 initializers, DiagnosticBag diagnostics, ImportChain&amp; firstImportChain) in F:\Roslyn_Project\Roslyn\roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Initializers.cs:line 57
   at Microsoft.CodeAnalysis.CSharp.Binder.BindFieldInitializers(CSharpCompilation compilation, SynthesizedInteractiveInitializerMethod scriptInitializerOpt, ImmutableArray`1 fieldInitializers, DiagnosticBag diagnostics, ProcessedFieldInitializers&amp; processedInitializers) in F:\Roslyn_Project\Roslyn\roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Initializers.cs:line 28
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(NamedTypeSymbol containingType) in F:\Roslyn_Project\Roslyn\roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 369
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.&lt;&gt;c__DisplayClass20_0.&lt;CompileNamedTypeAsTask&gt;b__0() in F:\Roslyn_Project\Roslyn\roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 323
   at Roslyn.Utilities.UICultureUtilities.&lt;&gt;c__DisplayClass5_0.&lt;WithCurrentUICulture&gt;b__0() in F:\Roslyn_Project\Roslyn\roslyn\src\Compilers\Core\Portable\InternalUtilities\UICultureUtilities.cs:line 136
   at System.Threading.Tasks.Task.InnerInvoke()
   at System.Threading.Tasks.Task.Execute()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.WaitForWorkers() in F:\Roslyn_Project\Roslyn\roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 238
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethodBodies(CSharpCompilation compilation, PEModuleBuilder moduleBeingBuiltOpt, Boolean generateDebugInfo, Boolean hasDeclarationErrors, DiagnosticBag diagnostics, Predicate`1 filterOpt, CancellationToken cancellationToken) in F:\Roslyn_Project\Roslyn\roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 137
   at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnosticsForAllMethodBodies(DiagnosticBag diagnostics, CancellationToken cancellationToken) in F:\Roslyn_Project\Roslyn\roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs:line 2004
   at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnostics(CompilationStage stage, Boolean includeEarlierStages, CancellationToken cancellationToken) in F:\Roslyn_Project\Roslyn\roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs:line 1971
   at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnostics(CancellationToken cancellationToken) in F:\Roslyn_Project\Roslyn\roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs:line 1910
   at SemanticsCS.Program.Main(String[] args) in c:\users\code\documents\visual studio 2015\Projects\TestSemanticAnalysis\TestSemanticAnalysis\Program.cs:line 33
   at System.AppDomain._nExecuteAssembly(RuntimeAssembly assembly, String[] args)
   at System.AppDomain.ExecuteAssembly(String assemblyFile, Evidence assemblySecurity, String[] args)
   at Microsoft.VisualStudio.HostingProcess.HostProc.RunUsersAssembly()
   at System.Threading.ThreadHelper.ThreadStart_Context(Object state)
   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   at System.Threading.ThreadHelper.ThreadStart()
```
</Description>
        <CreatedDate>30/08/2016</CreatedDate>
        <ClosedDate>16/09/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>13818</PullRequestID>
        <IssueID>13590</IssueID>
        <Title>Declaration of a fixed buffer in a top level script code causes a System.InvalidCastException</Title>
        <Description>```
        [Fact]
        public void Variables()
        {
            string source =
@"fixed int x[3];
";
            var tree = Parse(source, options: TestOptions.Script);
            var compilation = CreateCompilationWithMscorlib45(new[] { tree });

            compilation.VerifyDiagnostics(
                );
        }
```

Observed:

```
Exception thrown: 'System.InvalidCastException' in Microsoft.CodeAnalysis.CSharp.dll

Additional information: Unable to cast object of type 'PENamedTypeSymbolNonGeneric' to type 'Microsoft.CodeAnalysis.CSharp.Symbols.PointerTypeSymbol'.

&gt;   Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberFieldSymbol.GetFieldType(Roslyn.Utilities.ConsList&lt;Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol&gt; fieldsBeingBound) Line 278    C#
    Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberFieldSymbol.ForceComplete(Microsoft.CodeAnalysis.SourceLocation locationOpt, System.Threading.CancellationToken cancellationToken) Line 505 C#
    Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.ForceComplete(Microsoft.CodeAnalysis.SourceLocation locationOpt, System.Threading.CancellationToken cancellationToken) Line 492 C#
    Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Symbol.ForceCompleteMemberByLocation(Microsoft.CodeAnalysis.SourceLocation locationOpt, Microsoft.CodeAnalysis.CSharp.Symbol member, System.Threading.CancellationToken cancellationToken) Line 709 C#
    Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamespaceSymbol.ForceComplete(Microsoft.CodeAnalysis.SourceLocation locationOpt, System.Threading.CancellationToken cancellationToken) Line 72    C#
    Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Symbols.SourceModuleSymbol.ForceComplete(Microsoft.CodeAnalysis.SourceLocation locationOpt, System.Threading.CancellationToken cancellationToken) Line 254  C#
    Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol.ForceComplete(Microsoft.CodeAnalysis.SourceLocation locationOpt, System.Threading.CancellationToken cancellationToken) Line 893    C#
    Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetSourceDeclarationDiagnostics(Microsoft.CodeAnalysis.SyntaxTree syntaxTree, Microsoft.CodeAnalysis.Text.TextSpan? filterSpanWithinTree, System.Func&lt;System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.Diagnostic&gt;, Microsoft.CodeAnalysis.SyntaxTree, Microsoft.CodeAnalysis.Text.TextSpan?, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.Diagnostic&gt;&gt; locationFilterOpt, System.Threading.CancellationToken cancellationToken) Line 2080  C#
    Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnostics(Microsoft.CodeAnalysis.CompilationStage stage, bool includeEarlierStages, System.Threading.CancellationToken cancellationToken) Line 1958  C#
    Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnostics(System.Threading.CancellationToken cancellationToken) Line 1910    C#
    Roslyn.Test.Utilities.Desktop.dll!Microsoft.CodeAnalysis.DiagnosticExtensions.VerifyDiagnostics&lt;Microsoft.CodeAnalysis.CSharp.CSharpCompilation&gt;(Microsoft.CodeAnalysis.CSharp.CSharpCompilation c, Microsoft.CodeAnalysis.Test.Utilities.DiagnosticDescription[] expected) Line 98 C#
```
</Description>
        <CreatedDate>02/09/2016</CreatedDate>
        <ClosedDate>16/09/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>13818</PullRequestID>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Expressions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Initializers.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Invocation.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Statements.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/ExpressionVariableFinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/OverloadResolution/OverloadResolution.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/OverloadResolution/OverloadResolutionResult.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/Expression.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/Formatting.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/OutVarLocalPendingInference.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/OutVariablePendingInference.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/CSharpSemanticModel.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/SyntaxTreeSemanticModel.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/PreciseAbstractFlowPass.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_LocalDeclaration.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceEventFieldSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceFixedFieldSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceMemberContainerSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceMemberFieldSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceMemberFieldSymbolFromDesignation.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/SyntaxExtensions.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/SyntaxFacts.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/IteratorTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/OutVarTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/ScriptSemanticsTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>13814</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Implement new syntactic disambiguation rule for pattern-matching</Title>
    <Description>Fixes #10492
The behavior is specified in #13813 

@dotnet/roslyn-compiler Please review.
</Description>
    <CreatedDate>15/09/2016</CreatedDate>
    <ClosedDate>22/09/2016</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>13814</PullRequestID>
        <IssueID>10492</IssueID>
        <Title>Precedence errors in parsing the relational "is" expression</Title>
        <Description>The following short program illustrates two errors in the Roslyn expression parser. These issues interfere with the extension of the parser to support pattern-matching.

``` cs
using System;

class Program
{
    const bool B = true;

    public static void Main(string[] args)
    {
        object a = null;
        B c = null;
        Console.WriteLine(a is B &amp; c); // prints 5 (correct)
        Console.WriteLine(a is B &gt; c); // prints 6 (correct)
        Console.WriteLine(a is B &lt; c); // syntax error but should print 7
        Console.WriteLine(a is B + c); // should be syntax error but prints 8
    }
}

class B
{
    public static int operator &amp;(bool left, B right) =&gt; 5;
    public static int operator &gt;(bool left, B right) =&gt; 6;
    public static int operator &lt;(bool left, B right) =&gt; 7;
    public static int operator +(bool left, B right) =&gt; 8;
}
```

The last of these cases is most problematic for pattern-matching. While `a is B + c` should have been a syntax error in C# 6, in C# 7 it should mean `a is (B + c)`, which works if `B + c` is a constant value. However, we parse it incorrectly as `(a is B) + b`, which is an inversion of the precedence required by the language specification.
</Description>
        <CreatedDate>12/04/2016</CreatedDate>
        <ClosedDate>16/12/2019</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>13814</PullRequestID>
        <IssueID>13813</IssueID>
        <Title>New syntactic disambiguation rule for pattern-matching</Title>
        <Description>Related to #10492, there is now a new syntactic ambiguity due to patterns. The case is this

``` cs
M(e is A &lt; B, C &gt; x)
```

Where we are either passing two arguments to `M`, or declaring a pattern variable `x`.

The existing (C# 6) rules say it is two arguments because the token after the `&gt;` isn‚Äôt one of the ones on the list in the section entitled _Grammar Ambiguities_ in the _Lexical Structure_ chapter. That seems wrong in the presence of pattern-matching, because there is no other way to write the type so as to disambiguate and give it the meaning of matching the type `A&lt;B,C&gt;`.

Fortunately, previous compilers were unable to parse this according to the specification, and simply gave a syntax error (unable to handle an _is-expression_ on the left of a `&lt;`). That suggests we may have some room to change the rules.

However, if we simply add _identifier_ to the list, we‚Äôd get this case wrong

``` cs
M(A &lt; B, C &gt; D)
```

Maybe we only add _identifier_ to the list only when the type is being parsed for a pattern? That is the solution I have currently implemented, and it seems to do the right thing.

This will have to go in the language spec.
</Description>
        <CreatedDate>14/09/2016</CreatedDate>
        <ClosedDate>27/03/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>13814</PullRequestID>
      <File>src/Compilers/CSharp/Portable/Parser/LanguageParser.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/LanguageParser_Patterns.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/ParserErrorMessageTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>13798</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Never offer to remove an unboxing cast, as it can cause an exception.</Title>
    <Description>Fixes #12572 
Fixes #10306

It turns out the underlying bug has nothing to do with pattern-matching, or anything in the compiler.

@DustinCampbell @mavasani Can you please review this?
@dotnet/roslyn-compiler Any additional reviews are welcome.
</Description>
    <CreatedDate>14/09/2016</CreatedDate>
    <ClosedDate>14/09/2016</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>13798</PullRequestID>
        <IssueID>12572</IssueID>
        <Title>Incorrect "Cast is redundant" when switch on an `object`</Title>
        <Description>**Version Used**: 

Master branch, commit d9b6e87a1b08f2f12f5fbd5eb0b071d82b672beb (latest when submitted this issue)

**Steps to Reproduce**:

``` C#
public static void TestSwitchInt(object i)
{
    switch ((int)i)
    {
        case 0:
            Console.WriteLine("0");
            break;
        case 1:
            Console.WriteLine("1");
            break;
        case 2:
            Console.WriteLine("2");
            break;
    }
}
```

**Expected Behavior**:

No "Cast is redundant" suggestion.

**Actual Behavior**:

"Cast is redundant" on `(int)i`.

Removing it will cause the compiler to generate more complicated code (to check the type of `i`).
</Description>
        <CreatedDate>17/07/2016</CreatedDate>
        <ClosedDate>14/09/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>13798</PullRequestID>
        <IssueID>10306</IssueID>
        <Title>[Bug] Redundant "Remove Unnecessary Cast" with pattern-matching</Title>
        <Description>**Version Used**: 
Microsoft Visual Studio Enterprise 15 Preview
Version 15.0.25123.0 PREVIEW
Microsoft .NET Framework
Version 4.6.01038

**Steps to Reproduce**:
Write a code:

``` cs
static class Program
{
  static void Main(string[] args) {
    switch((object)args) {
        // ^~~~~~~^ cast marked as IDE0004  C# Cast is redundant.
    case int[] i:
      break;
    }
  }
}
```
1. Compile code: succeeded
2. Remove cast and compile code: error CS0030: Cannot convert type 'string[]' to 'int[]'

**Expected Behavior**:
Do not suggest to remove a type cast.
</Description>
        <CreatedDate>03/04/2016</CreatedDate>
        <ClosedDate>14/09/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>13798</PullRequestID>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/RemoveUnnecessaryCast/RemoveUnnecessaryCastTests.cs</File>
      <File>src/Workspaces/CSharp/Portable/Extensions/CastExpressionSyntaxExtensions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>13781</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>this is port of 7 different changes from master. and enabled remote host by default</Title>
    <Description>6 changes ported from master as they are.
#13694
#13721
#13703
#13743
#13756
#13779
#13787

all these changes are signed off from master.

...

only change in preview 5 branch is making remotehost to be on by default.

public static readonly Option&lt;bool&gt; RemoteHost = new Option&lt;bool&gt;(OptionName, nameof(RemoteHost), defaultValue: true);
</Description>
    <CreatedDate>14/09/2016</CreatedDate>
    <ClosedDate>14/09/2016</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>13781</PullRequestID>
        <IssueID>13694</IssueID>
        <Title>make checksum build time of roslyn-internal from 1 min to 8 seconds</Title>
        <Description>got rid of as much async as possible. it can't be completely non-async due to getting text is async.

made building any async part concurrent.
</Description>
        <CreatedDate>08/09/2016</CreatedDate>
        <ClosedDate>09/09/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>13781</PullRequestID>
        <IssueID>13721</IssueID>
        <Title>added OpenFileOnly in IBuiltInAnalyzer and removed RunInProcess</Title>
        <Description>now, all builtin analyzer that is not set to only run on open files will run in OOP.

any builtin analyzer that can't run in OOP should mark it as open file only.

for analyzers that return only hidden severity but return different severity on runtime should use the new API to control whether it want to run full solution or not. if set to run on full solution, it will run in OOP.
</Description>
        <CreatedDate>09/09/2016</CreatedDate>
        <ClosedDate>12/09/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>13781</PullRequestID>
        <IssueID>13703</IssueID>
        <Title>support options in asset builder and send over option set to OOP</Title>
        <Description>
        </Description>
        <CreatedDate>09/09/2016</CreatedDate>
        <ClosedDate>13/09/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>13781</PullRequestID>
        <IssueID>13743</IssueID>
        <Title>check whether options that require OOP are enabled.</Title>
        <Description>no code lens check yet since we don't have option yet. but as soon as I have one, we will check that as well.
</Description>
        <CreatedDate>12/09/2016</CreatedDate>
        <ClosedDate>12/09/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>13781</PullRequestID>
        <IssueID>13756</IssueID>
        <Title>add codelen option check</Title>
        <Description>
        </Description>
        <CreatedDate>13/09/2016</CreatedDate>
        <ClosedDate>13/09/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>13781</PullRequestID>
        <IssueID>13779</IssueID>
        <Title>Add out of proc CodeLens processing</Title>
        <Description>@heejaechang Here is the move to have the CodeLens service run out of proc. (It also include for the moment the other PR about fixing the extra parameter, but you can ignore that in this PR.) Let me know what you think...
</Description>
        <CreatedDate>14/09/2016</CreatedDate>
        <ClosedDate>14/09/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>13781</PullRequestID>
        <IssueID>13787</IssueID>
        <Title>Update OOP analyzers to calculate OpenFileOnly based on options</Title>
        <Description>Only Error- and Warning-level Code Style options will run on closed files.
Suggestions will only run on open files.

This will help with perf (I believe), and is part of @heejaechang 's larger effort for OOP.
</Description>
        <CreatedDate>14/09/2016</CreatedDate>
        <ClosedDate>14/09/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>13781</PullRequestID>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/DiagnosticAnalyzerDriver/DiagnosticAnalyzerDriverTests.cs</File>
      <File>src/EditorFeatures/Core/Implementation/RenameTracking/RenameTrackingDiagnosticAnalyzer.cs</File>
      <File>src/EditorFeatures/Test/CodeLens/AbstractCodeLensTest.cs</File>
      <File>src/EditorFeatures/Test/Diagnostics/AbstractSuppressionAllCodeTests.cs</File>
      <File>src/Features/CSharp/Portable/AddBraces/CSharpAddBracesDiagnosticAnalyzer.cs</File>
      <File>src/Features/CSharp/Portable/Diagnostics/Analyzers/CSharpPreferFrameworkTypeDiagnosticAnalyzer.cs</File>
      <File>src/Features/CSharp/Portable/Diagnostics/Analyzers/CSharpQualifyMemberAccessDiagnosticAnalyzer.cs</File>
      <File>src/Features/CSharp/Portable/Diagnostics/Analyzers/CSharpTypeStyleDiagnosticAnalyzerBase.State.cs</File>
      <File>src/Features/CSharp/Portable/Diagnostics/Analyzers/CSharpTypeStyleDiagnosticAnalyzerBase.cs</File>
      <File>src/Features/CSharp/Portable/InvokeDelegateWithConditionalAccess/InvokeDelegateWithConditionalAccessAnalyzer.cs</File>
      <File>src/Features/Core/Portable/CodeLens/CodeLensReferencesService.cs</File>
      <File>src/Features/Core/Portable/CodeLens/CodeLensReferencesServiceFactory.cs</File>
      <File>src/Features/Core/Portable/CodeLens/ReferenceLocationDescriptor.cs</File>
      <File>src/Features/Core/Portable/CodeLens/ReferenceMethodDescriptor.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/AnalyzerHelper.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/Analyzers/NamingStyles/NamingStyleDiagnosticAnalyzerBase.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/Analyzers/PreferFrameworkTypeDiagnosticAnalyzerBase.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/Analyzers/QualifyMemberAccessDiagnosticAnalyzerBase.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/Analyzers/RemoveUnnecessaryCastDiagnosticAnalyzerBase.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/Analyzers/RemoveUnnecessaryImportsDiagnosticAnalyzerBase.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/Analyzers/RudeEditUserDiagnosticAnalyzer.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/Analyzers/SimplifyTypeNamesDiagnosticAnalyzerBase.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/Analyzers/UnboundIdentifiersDiagnosticAnalyzerBase.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/BaseDiagnosticIncrementalAnalyzer.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/EngineV2/DiagnosticIncrementalAnalyzer_IncrementalAnalyzer.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/IBuiltInAnalyzer.cs</File>
      <File>src/Features/Core/Portable/PopulateSwitch/PopulateSwitchDiagnosticAnalyzer.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Remote/RemoteHostClient.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Remote/RemoteHostClientServiceFactory.RemoteHostClientService.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Remote/RemoteHostClientServiceFactory.SolutionChecksumUpdater.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Remote/RemoteHostClientServiceFactory.cs</File>
      <File>src/VisualStudio/Next/CodeLens/RemoteCodeLensReferencesService.cs</File>
      <File>src/VisualStudio/Next/Diagnostics/OutOfProcDiagnosticAnalyzerExecutor.cs</File>
      <File>src/Workspaces/CSharp/Portable/Execution/CSharpOptionsSerializationService.cs</File>
      <File>src/Workspaces/Core/Portable/CodeStyle/CodeStyleOption.cs</File>
      <File>src/Workspaces/Core/Portable/CodeStyle/NotificationOption.cs</File>
      <File>src/Workspaces/Core/Portable/Execution/AbstractOptionsSerializationService.cs</File>
      <File>src/Workspaces/Core/Portable/Execution/AssetBuilder.cs</File>
      <File>src/Workspaces/Core/Portable/Execution/ChecksumObject.cs</File>
      <File>src/Workspaces/Core/Portable/Execution/ChecksumTreeBuilder.cs</File>
      <File>src/Workspaces/Core/Portable/Execution/ChecksumTreeCollection.TreeNodes.cs</File>
      <File>src/Workspaces/Core/Portable/Execution/ChecksumTreeCollection.cs</File>
      <File>src/Workspaces/Core/Portable/Execution/IChecksumTreeNodes.cs</File>
      <File>src/Workspaces/Core/Portable/Execution/IOptionsSerializationService.cs</File>
      <File>src/Workspaces/Core/Portable/Execution/Serializer.cs</File>
      <File>src/Workspaces/Core/Portable/Execution/Serializer_ChecksumObjectWithChildren.cs</File>
      <File>src/Workspaces/Core/Portable/Execution/Serializer_OptionSet.cs</File>
      <File>src/Workspaces/Core/Portable/Log/FunctionId.cs</File>
      <File>src/Workspaces/CoreTest/Execution/SnapshotSerializationTests.cs</File>
      <File>src/Workspaces/Remote/Core/Services/AssetService.cs</File>
      <File>src/Workspaces/Remote/Core/Services/SolutionService.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/CodeLens/CodeLensArguments.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Diagnostics/DiagnosticArguments.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Services/CodeAnalysisService_CodeLens.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Services/CodeAnalysisService_Diagnostics.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Shared/WellKnownServiceHubServices.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>13765</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Implement code gen for expression-bodied ctor and dtor</Title>
    <Description>Fixes #13578
Fixes #13691
Fixes #13692 
@dotnet/roslyn-compiler @lachbaer Please Review.
</Description>
    <CreatedDate>13/09/2016</CreatedDate>
    <ClosedDate>22/09/2016</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>13765</PullRequestID>
        <IssueID>13578</IssueID>
        <Title>Need tests for expression-bodied ctors, dtors, and accessors</Title>
        <Description>including semantic model tests targeting those scenarios.

Addendum: This is now mostly done in https://github.com/dotnet/roslyn/pull/13695, but there is a suggestion in https://github.com/dotnet/roslyn/pull/13695#discussion_r78219131 for additional tests:

&gt; Looking back at the change with the feature code (PR 13543), some additional test suggestions:
&gt; - features disabled (errors for IDS_FeatureExpressionBodiedAccessor and IDS_FeatureExpressionBodiedDeOrConstructor)
&gt; - a direct parsing test for expression and constructor/deconstructor
</Description>
        <CreatedDate>02/09/2016</CreatedDate>
        <ClosedDate>22/09/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>13765</PullRequestID>
        <IssueID>13691</IssueID>
        <Title>expression-bodied ctor fails to generate call to base()</Title>
        <Description>The following test fails on the `features/exprbody` branch:

``` cs
        [Fact]
        public void RunCtorProp()
        {
            string source = @"
using System;
public class Program 
{
    static void Main()
    {
        var p = new Program();
        p.Prop = 2;
    }
    Program() =&gt; Console.Write(1);
    int Prop { set =&gt; Console.Write(value); }
    ~Program() =&gt; Console.Write(string.Empty);
}
";
            CompileAndVerify(source, expectedOutput: "12");
        }
```

with

``` none
Test 'Microsoft.CodeAnalysis.CSharp.Semantic.UnitTests.Semantics.ExpressionBodiedMemberTests.RunCtorProp' failed: Microsoft.CodeAnalysis.Test.Utilities.PeVerifyException : 
PeVerify failed for assembly 'C:\Users\ngafter\AppData\Local\Temp\':
[ : Program::.ctor][mdToken=0x6000002][offset 0x00000006] Return from .ctor when this is uninitialized.


    RuntimeAssemblyManager.cs(471,0): at Microsoft.CodeAnalysis.Test.Utilities.RuntimeAssemblyManager.PeVerifyModules(String[] modulesToVerify, Boolean throwOnError)
    at Microsoft.CodeAnalysis.Test.Utilities.RuntimeAssemblyManager.PeVerifyModules(String[] modulesToVerify, Boolean throwOnError)
    HostedRuntimeEnvironment.cs(304,0): at Microsoft.CodeAnalysis.Test.Utilities.HostedRuntimeEnvironment.PeVerify()
    CommonTestBase.CompilationVerifier.cs(99,0): at Microsoft.CodeAnalysis.Test.Utilities.CommonTestBase.CompilationVerifier.Emit(String expectedOutput, IEnumerable`1 manifestResources, EmitOptions emitOptions, Boolean peVerify, SignatureDescription[] expectedSignatures)
    D:\Roslyn\src\Test\Utilities\Desktop\CommonTestBase.cs(212,0): at Microsoft.CodeAnalysis.Test.Utilities.CommonTestBase.Emit(Compilation compilation, IEnumerable`1 dependencies, IEnumerable`1 manifestResources, SignatureDescription[] expectedSignatures, String expectedOutput, Action`1 assemblyValidator, Action`1 symbolValidator, EmitOptions emitOptions, Boolean verify)
    D:\Roslyn\src\Test\Utilities\Desktop\CommonTestBase.cs(135,0): at Microsoft.CodeAnalysis.Test.Utilities.CommonTestBase.CompileAndVerify(Compilation compilation, IEnumerable`1 manifestResources, IEnumerable`1 dependencies, Action`1 sourceSymbolValidator, Action`1 assemblyValidator, Action`1 symbolValidator, SignatureDescription[] expectedSignatures, String expectedOutput, EmitOptions emitOptions, Boolean verify)
    D:\Roslyn\src\Test\Utilities\Desktop\CommonTestBase.cs(89,0): at Microsoft.CodeAnalysis.Test.Utilities.CommonTestBase.CompileAndVerify(String[] sources, IEnumerable`1 additionalRefs, IEnumerable`1 dependencies, Action`1 sourceSymbolValidator, Action`1 assemblyValidator, Action`1 symbolValidator, SignatureDescription[] expectedSignatures, String expectedOutput, CompilationOptions options, ParseOptions parseOptions, EmitOptions emitOptions, Boolean verify)
    D:\Roslyn\src\Test\Utilities\Desktop\CommonTestBase.cs(53,0): at Microsoft.CodeAnalysis.Test.Utilities.CommonTestBase.CompileAndVerify(String source, IEnumerable`1 additionalRefs, IEnumerable`1 dependencies, Action`1 sourceSymbolValidator, Action`1 assemblyValidator, Action`1 symbolValidator, SignatureDescription[] expectedSignatures, String expectedOutput, CompilationOptions options, ParseOptions parseOptions, EmitOptions emitOptions, Boolean verify)
    D:\Roslyn\src\Compilers\Test\Utilities\CSharp.Desktop\CSharpTestBase.cs(81,0): at Microsoft.CodeAnalysis.CSharp.Test.Utilities.CSharpTestBase.CompileAndVerify(String source, IEnumerable`1 additionalRefs, IEnumerable`1 dependencies, Action`1 sourceSymbolValidator, Action`1 assemblyValidator, Action`1 symbolValidator, SignatureDescription[] expectedSignatures, String expectedOutput, CompilationOptions options, ParseOptions parseOptions, EmitOptions emitOptions, Boolean verify)
    Semantics\ExpressionBodiedMemberTests.cs(366,0): at Microsoft.CodeAnalysis.CSharp.Semantic.UnitTests.Semantics.ExpressionBodiedMemberTests.RunCtorProp()
```
</Description>
        <CreatedDate>08/09/2016</CreatedDate>
        <ClosedDate>22/09/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>13765</PullRequestID>
        <IssueID>13692</IssueID>
        <Title>expression-bodied dtor fails to generate call to ~base()</Title>
        <Description>The following test fails on the `features/exprbody` branch:

``` cs
        [Fact]
        public void ExpressionBodiedClassDestructor()
        {
            var text = @"
using System;

public class Base
{
    ~Base() =&gt; Console.WriteLine(""~Base"");
}

public class Program
{
    public static void Main()
    {
        Base b = new Base();
        b = null;
        GC.Collect(GC.MaxGeneration);
        GC.WaitForPendingFinalizers();
    }
}
";
            var validator = GetDestructorValidator("Base");
            var compVerifier = CompileAndVerify(text,
                sourceSymbolValidator: validator,
                symbolValidator: validator,
                expectedOutput: @"~Base",
                expectedSignatures: new[]
                {
                    Signature("Base", "Finalize", ".method family hidebysig virtual instance System.Void Finalize() cil managed")
                });

            compVerifier.VerifyIL("Base.Finalize", @"
{
  // Code size       20 (0x14)
  .maxstack  1
  .try
  {
    IL_0000:  ldstr      ""~Base""
    IL_0005:  call       ""void System.Console.WriteLine(string)""
    IL_000a:  leave.s    IL_0013
  }
  finally
  {
    IL_000c:  ldarg.0
    IL_000d:  call       ""void object.Finalize()""
    IL_0012:  endfinally
  }
  IL_0013:  ret
}
");
        }
```

with

``` none
------ Test started: Assembly: Roslyn.Compilers.CSharp.Emit.UnitTests.dll ------

Unknown .NET Framework Version: v4.6
Test 'Microsoft.CodeAnalysis.CSharp.UnitTests.CodeGen.DestructorTests.ExpressionBodiedClassDestructor' failed: 
Expected:
{
  // Code size       20 (0x14)
  .maxstack  1
  .try
  {
    IL_0000:  ldstr      ""~Base""
    IL_0005:  call       ""void System.Console.WriteLine(string)""
    IL_000a:  leave.s    IL_0013
  }
  finally
  {
    IL_000c:  ldarg.0
    IL_000d:  call       ""void object.Finalize()""
    IL_0012:  endfinally
  }
  IL_0013:  ret
}
Actual:
{
  // Code size       11 (0xb)
  .maxstack  1
  IL_0000:  ldstr      ""~Base""
  IL_0005:  call       ""void System.Console.WriteLine(string)""
  IL_000a:  ret
}
Differences:
    {
++&gt;   // Code size       11 (0xb)
--&gt;   // Code size       20 (0x14)
      .maxstack  1
++&gt;   IL_0000:  ldstr      ""~Base""
++&gt;   IL_0005:  call       ""void System.Console.WriteLine(string)""
++&gt;   IL_000a:  ret
--&gt;   .try
--&gt;   {
--&gt;     IL_0000:  ldstr      ""~Base""
--&gt;     IL_0005:  call       ""void System.Console.WriteLine(string)""
--&gt;     IL_000a:  leave.s    IL_0013
--&gt;   }
--&gt;   finally
--&gt;   {
--&gt;     IL_000c:  ldarg.0
--&gt;     IL_000d:  call       ""void object.Finalize()""
--&gt;     IL_0012:  endfinally
--&gt;   }
--&gt;   IL_0013:  ret
    }

Expected: True
Actual:   False
    D:\Roslyn\src\Test\Utilities\Shared\Assert\AssertEx.cs(340,0): at Roslyn.Test.Utilities.AssertEx.AssertEqualToleratingWhitespaceDifferences(String expected, String actual, Boolean escapeQuotes, String expectedValueSourcePath, Int32 expectedValueSourceLine)
    CommonTestBase.CompilationVerifier.cs(187,0): at Microsoft.CodeAnalysis.Test.Utilities.CommonTestBase.CompilationVerifier.VerifyILImpl(String qualifiedMethodName, String expectedIL, Boolean realIL, String sequencePoints, String callerPath, Int32 callerLine, Boolean escapeQuotes)
    CommonTestBase.CompilationVerifier.cs(157,0): at Microsoft.CodeAnalysis.Test.Utilities.CommonTestBase.CompilationVerifier.VerifyIL(String qualifiedMethodName, String expectedIL, Boolean realIL, String sequencePoints, String callerPath, Int32 callerLine)
    CodeGen\DestructorTests.cs(110,0): at Microsoft.CodeAnalysis.CSharp.UnitTests.CodeGen.DestructorTests.ExpressionBodiedClassDestructor()

0 passed, 1 failed, 0 skipped, took 4.02 seconds (xUnit.net 2.1.0 build 3179).
```
</Description>
        <CreatedDate>08/09/2016</CreatedDate>
        <ClosedDate>22/09/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>13765</PullRequestID>
      <File>src/Compilers/CSharp/Portable/Compiler/MethodBodySynthesizer.cs</File>
      <File>src/Compilers/CSharp/Portable/Compiler/MethodCompiler.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/DestructorTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/ExpressionBodiedMemberTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/DeclarationParsingTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>13747</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Fix crash on "is type" operator with typeless tuple expression.</Title>
    <Description>Add tests for non-reproducible issue #13723
Fixes #13746 
Also rename an error code for clarity.

@VSadov @jcouv Please review
@dotnet/roslyn-compiler More reviews welcome!
</Description>
    <CreatedDate>12/09/2016</CreatedDate>
    <ClosedDate>13/09/2016</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>13747</PullRequestID>
        <IssueID>13723</IssueID>
        <Title>Compiler crashes when using a constant pattern against an expression that doesn't have a type</Title>
        <Description>```
        [Fact]
        public void ExpressionWithoutAType()
        {
            var source =
@"
public class Vec
{
    public static void Main()
    {
        if (null is 1)
        {}
    }
}
";

            CreateCompilationWithMscorlib45(source, options: TestOptions.DebugExe).VerifyDiagnostics(
                );
        }
```

Observed:

```
Test 'M:Microsoft.CodeAnalysis.CSharp.UnitTests.PatternMatchingTests.ExpressionWithoutAType' failed: Object reference not set to an instance of an object.
    System.NullReferenceException: Object reference not set to an instance of an object.
    Binder\Semantics\Conversions\ConversionsBase.cs(1065,0): at Microsoft.CodeAnalysis.CSharp.ConversionsBase.HasImplicitEnumerationConversion(BoundExpression source, TypeSymbol destination)
    Binder\Semantics\Conversions\ConversionsBase.cs(786,0): at Microsoft.CodeAnalysis.CSharp.ConversionsBase.ClassifyImplicitBuiltInConversionFromExpression(BoundExpression sourceExpression, TypeSymbol source, TypeSymbol destination, HashSet`1&amp; useSiteDiagnostics)
    Binder\Semantics\Conversions\ConversionsBase.cs(57,0): at Microsoft.CodeAnalysis.CSharp.ConversionsBase.ClassifyImplicitConversionFromExpression(BoundExpression sourceExpression, TypeSymbol destination, HashSet`1&amp; useSiteDiagnostics)
    Binder\Binder_Statements.cs(2369,0): at Microsoft.CodeAnalysis.CSharp.Binder.GenerateConversionForAssignment(TypeSymbol targetType, BoundExpression expression, DiagnosticBag diagnostics, Boolean isDefaultParameter, RefKind refKind)
    Binder\Binder_Patterns.cs(140,0): at Microsoft.CodeAnalysis.CSharp.Binder.ConvertPatternExpression(TypeSymbol inputType, CSharpSyntaxNode node, BoundExpression expression, ConstantValue&amp; constantValue, DiagnosticBag diagnostics)
    Binder\Binder_Patterns.cs(124,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindConstantPattern(CSharpSyntaxNode node, BoundExpression operand, TypeSymbol operandType, ExpressionSyntax patternExpression, Boolean hasErrors, DiagnosticBag diagnostics, Boolean&amp; wasExpression, Boolean wasSwitchCase)
    Binder\Binder_Patterns.cs(38,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindPattern(PatternSyntax node, BoundExpression operand, TypeSymbol operandType, Boolean hasErrors, DiagnosticBag diagnostics, Boolean wasSwitchCase)
    Binder\Binder_Patterns.cs(17,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindIsPatternExpression(IsPatternExpressionSyntax node, DiagnosticBag diagnostics)
    Binder\Binder_Expressions.cs(623,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed)
    Binder\Binder_Expressions.cs(396,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindExpression(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed)
    Binder\Binder_Statements.cs(2848,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindBooleanExpression(ExpressionSyntax node, DiagnosticBag diagnostics)
    Binder\Binder_Statements.cs(2804,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindIfStatement(IfStatementSyntax node, DiagnosticBag diagnostics)
    Binder\Binder_Statements.cs(50,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics)
    Binder\Binder_Statements.cs(2315,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindBlockParts(BlockSyntax node, DiagnosticBag diagnostics)
    Compiler\MethodCompiler.cs(1550,0): at Microsoft.CodeAnalysis.CSharp.MethodCompiler.BindMethodBody(MethodSymbol method, TypeCompilationState compilationState, DiagnosticBag diagnostics, ImportChain&amp; importChain, Boolean&amp; originalBodyNested)
    Compiler\MethodCompiler.cs(878,0): at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethod(MethodSymbol methodSymbol, Int32 methodOrdinal, ProcessedFieldInitializers&amp; processedInitializers, SynthesizedSubmissionFields previousSubmissionFields, TypeCompilationState compilationState)
    Compiler\MethodCompiler.cs(433,0): at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(NamedTypeSymbol containingType)
    Compiler\MethodCompiler.cs(323,0): at Microsoft.CodeAnalysis.CSharp.MethodCompiler.&lt;&gt;c__DisplayClass20_0.&lt;CompileNamedTypeAsTask&gt;b__0()
    InternalUtilities\UICultureUtilities.cs(136,0): at Roslyn.Utilities.UICultureUtilities.&lt;&gt;c__DisplayClass5_0.&lt;WithCurrentUICulture&gt;b__0()
    at System.Threading.Tasks.Task.InnerInvoke()
    at System.Threading.Tasks.Task.Execute()
    --- End of stack trace from previous location where exception was thrown ---
    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
    Compiler\MethodCompiler.cs(238,0): at Microsoft.CodeAnalysis.CSharp.MethodCompiler.WaitForWorkers()
    Compiler\MethodCompiler.cs(137,0): at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethodBodies(CSharpCompilation compilation, PEModuleBuilder moduleBeingBuiltOpt, Boolean generateDebugInfo, Boolean hasDeclarationErrors, DiagnosticBag diagnostics, Predicate`1 filterOpt, CancellationToken cancellationToken)
    Compilation\CSharpCompilation.cs(2004,0): at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnosticsForAllMethodBodies(DiagnosticBag diagnostics, CancellationToken cancellationToken)
    Compilation\CSharpCompilation.cs(1971,0): at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnostics(CompilationStage stage, Boolean includeEarlierStages, CancellationToken cancellationToken)
    Compilation\CSharpCompilation.cs(1910,0): at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnostics(CancellationToken cancellationToken)
    DiagnosticExtensions.cs(98,0): at Microsoft.CodeAnalysis.DiagnosticExtensions.VerifyDiagnostics[TCompilation](TCompilation c, DiagnosticDescription[] expected)
    Semantics\PatternMatchingTests.cs(14567,0): at Microsoft.CodeAnalysis.CSharp.UnitTests.PatternMatchingTests.ExpressionWithoutAType()
```
</Description>
        <CreatedDate>10/09/2016</CreatedDate>
        <ClosedDate>13/09/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>13747</PullRequestID>
        <IssueID>13746</IssueID>
        <Title>Compiler crashes with typeless tuple on the left of an is-type operator</Title>
        <Description>``` cs
        [Fact]
        public void ExpressionWithoutAType()
        {
            var source =
@"
public class Vec
{
    public static void Main()
    {
        if ((1, null) is Vec)
        {}
    }
}
";

            CreateCompilationWithMscorlib45(source, options: TestOptions.DebugExe).VerifyDiagnostics(
                );
        }
```

this crashes the C# compiler.
</Description>
        <CreatedDate>12/09/2016</CreatedDate>
        <ClosedDate>13/09/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>13747</PullRequestID>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Operators.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/SwitchBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/CSharpResources.Designer.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/ErrorCode.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternSwitchTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/SwitchTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/PatternParsingTests.cs</File>
      <File>src/Test/Utilities/Shared/Traits/CompilerFeature.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>13720</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Remove an incorrect ContainsDiagnostics test in LanguageParser</Title>
    <Description>by which the presence of a nested warning could suppress
what should be an error. Also adds a test for #13719, which is
related.
Fixes #13667 

@VSadov @jcouv @dotnet/roslyn-compiler Please review
@jaredpar You might want to look at this too, since you were **_sooooo**_ interested in the issue ;)
</Description>
    <CreatedDate>09/09/2016</CreatedDate>
    <ClosedDate>12/09/2016</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>13720</PullRequestID>
        <IssueID>13719</IssueID>
        <Title>Roslyn fails to give syntax error for incomplete member that contains a lexical warning</Title>
        <Description>The following program contains an obvious syntax error, but Roslyn compiles it successfully!

``` cs
class A
{
    [Obsolete(2l)]
    public int
}
```

This was discovered while investigating #13667. Each of the places in the parser that tests whether or not a node contains diagnostics should be checked to see if that test is correct.
</Description>
        <CreatedDate>09/09/2016</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>13720</PullRequestID>
        <IssueID>13667</IssueID>
        <Title>Untested code in parsing tuples.</Title>
        <Description>The following code appears in `LanguageParser.cs`:

``` cs
                if (!result.ContainsDiagnostics &amp;&amp; list.Count &lt; 2)
                {
                    result = this.AddError(result, ErrorCode.ERR_TupleTooFewElements);
                }
```

but the condition `result.ContainsDiagnostics` doesn't make a difference in any compiler tests. It should probably be removed or tested.

(Note that `ContainsDiagnostics` does not test for errors in the node, or even errors anywhere beneath the node)
</Description>
        <CreatedDate>07/09/2016</CreatedDate>
        <ClosedDate>12/09/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>13720</PullRequestID>
      <File>src/Compilers/CSharp/Portable/Parser/LanguageParser.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenExprLambdaTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Compilation/CompilationAPITests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/ParserRegressionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/ValueTupleTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>13675</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Handle names correctly in long tuples in EE</Title>
    <Description>Port #13651 to dev15-preview-5.

Fixes #13625.
</Description>
    <CreatedDate>08/09/2016</CreatedDate>
    <ClosedDate>08/09/2016</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>13675</PullRequestID>
        <IssueID>13651</IssueID>
        <Title>Handle names in long tuples in EE</Title>
        <Description>Handle names in long tuples in EE

Fixes #13625
</Description>
        <CreatedDate>07/09/2016</CreatedDate>
        <ClosedDate>07/09/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>13675</PullRequestID>
        <IssueID>13625</IssueID>
        <Title>Incorrect names in the EE in long tuple</Title>
        <Description>Names in the last nested tuple of `C.F` are incorrect in the EE.

```
class C
{
    static ((int A, (int B, int C) D, int E, int F, int G, int H, int I, int J) K, (int L, int M, int N) O) F =
        ((1, (2, 3), 4, 5, 6, 7, 8, 9), (10, 11, 12));
}
```

Result:

```
((int A, (int B, int C) D, int E, int F, int G, int H, int I, int J) K, (int, int L, int M) O)
```
</Description>
        <CreatedDate>06/09/2016</CreatedDate>
        <ClosedDate>07/09/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>13675</PullRequestID>
      <File>src/ExpressionEvaluator/CSharp/Test/ResultProvider/TupleTests.cs</File>
      <File>src/ExpressionEvaluator/Core/Source/ExpressionCompiler/CustomTypeInfo.cs</File>
      <File>src/ExpressionEvaluator/Core/Source/ResultProvider/Formatter.TypeNames.cs</File>
      <File>src/ExpressionEvaluator/Core/Source/ResultProvider/Helpers/AttributeHelpers.cs</File>
      <File>src/ExpressionEvaluator/Core/Source/ResultProvider/Helpers/CustomTypeInfoTypeArgumentMap.cs</File>
      <File>src/ExpressionEvaluator/Core/Source/ResultProvider/Helpers/TypeHelpers.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>13648</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Revert an incorrect optimization in binary operator overload resolution</Title>
    <Description>from PR #9543; issue #13380 shows why the optimization is not correct.

@dotnet/roslyn-compiler Please review
/cc @VSadov @tmat @agocke @AlekseyTs
</Description>
    <CreatedDate>07/09/2016</CreatedDate>
    <ClosedDate>12/09/2016</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>13648</PullRequestID>
        <IssueID>9543</IssueID>
        <Title>more allocation reduction.</Title>
        <Description>- avoid instantiating nullable type when doing operator overloading on enums
- avoid instantiating generics when checking for impossibly rare case of duplicated interface implementations
- skipping materializing of sequence point array
</Description>
        <CreatedDate>08/03/2016</CreatedDate>
        <ClosedDate>08/03/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>13648</PullRequestID>
        <IssueID>13380</IssueID>
        <Title>Error combining nullable and implicit operators</Title>
        <Description>Consider the following code

``` csharp
public class Class1
{
    public Class1()
    {
        var a = new Registration&lt;Something&gt;();
        var x = (a == Something.Bad);                    //this line fails in VS2015.3
    }
}

public struct Registration&lt;T&gt; where T : struct
{
    public static implicit operator T? (Registration&lt;T&gt; registration)
    {
        return null;
    }
}

public enum Something
{
    Good,
    Bad
}

```

This compiled fine in VS 2013 and VS 2015 Update 2 (not fully verified).  Need to make sure we fix this regression for the next version. 
</Description>
        <CreatedDate>25/08/2016</CreatedDate>
        <ClosedDate>12/09/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>13648</PullRequestID>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/Operators/BinaryOperatorOverloadResolution.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/Operators/UnaryOperatorOverloadResolution.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/OverloadResolutionTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>10590</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Check that constant patterns are constant</Title>
    <Description>- Check that constant patterns are constant
- Fix check for cross-assembly pattern-matching operators.
- Fixes #10459 #10364
- Closes #8778 #9284
- Add a flag to the constant pattern binder to distinguish switch from other contexts because the LDM is grandfathering the conversions that the switch statement already does.
</Description>
    <CreatedDate>14/04/2016</CreatedDate>
    <ClosedDate>16/04/2016</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>10590</PullRequestID>
        <IssueID>10459</IssueID>
        <Title>Compiler crash switching on a value of type System.Type</Title>
        <Description>Reported in https://github.com/dotnet/roslyn/issues/8194#issuecomment-207867184:

&gt; Seems you can do it in future branch
&gt; ![snip_20160410064405](https://cloud.githubusercontent.com/assets/1330321/14406886/acd14546-fee7-11e5-9784-e38da4ba3f61.png)
&gt; But the compiler will crash when compiling it :(
</Description>
        <CreatedDate>11/04/2016</CreatedDate>
        <ClosedDate>16/04/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>10590</PullRequestID>
        <IssueID>10364</IssueID>
        <Title>Pattern matching `is` operator doesn't function correctly across assemblies.</Title>
        <Description>**Version Used**: 
Build of Visual Studio from the `features/patterns` branch as of 4th April 2016.

**Steps to Reproduce**:
**1** Within a new solution, create a library project, `TypeDeclarations`, with the `__DEMO_EXPERIMENTAL__` conditional compilation symbol set. Then create the following classes:

``` cs
namespace TypeDeclarations
{
    public class A
    {
        public int Prop1 { get; set; }
    }

    public class B
    {
        public static bool operator is(A a) =&gt; a.Prop1 == 0;
    }

    public class C
    {
        public int Prop2 { get; set; }

        public static bool operator is(A a, out C c)
        {
            c = a.Prop1 != 0 ? new C { Prop2 = a.Prop1 } : null;
            return a.Prop1 != 0;
        }
    }

    public static class Patterns
    {
        public static int Pattern1(A a) =&gt; a is C(var c) ? c.Prop2 : 0;

        public static int Pattern2(A a) =&gt;
            a match (
                case C(var c) : c.Prop2
                case B() : 0
            );
    }
}
```

**2**  Create another, cmdline, project, `IsOperatorBugDemo`, again with `__DEMO_EXPERIMENTAL__` set. Create a main class, compile and run the code:

``` cs
using System;
using TypeDeclarations;

namespace IsOperatorBugDemo
{
    static class Program
    {
        static void Main()
        {
            Console.WriteLine(Patterns.Pattern1(new A()));
            Console.WriteLine(Patterns.Pattern2(new A()));
            Console.WriteLine(Patterns.Pattern1(new A { Prop1 = 1 }));
            Console.WriteLine(Patterns.Pattern2(new A { Prop1 = 1 }));
            Console.ReadLine();
        }
    }
}
```

**3** Modify `Program.cs` in step 2 to the following and try to compile and run once more:

``` cs
using System;
using TypeDeclarations;

namespace IsOperatorBugDemo
{
    static class Program
    {
        static void Main()
        {
            Console.WriteLine(Pattern1(new A()));
            Console.WriteLine(Pattern2(new A()));
            Console.WriteLine(Pattern1(new A { Prop1 = 1 }));
            Console.WriteLine(Pattern2(new A { Prop1 = 1 }));
            Console.ReadLine();
        }
        private static int Pattern1(A a) =&gt; a is C(var c) ? c.Prop2 : 0;

        private static int Pattern2(A a) =&gt;
            a match (
                case C(var c) : c.Prop2
                case B() : 0
            );
    }
}
```

**Expected Behavior**:
For both steps 2 and 3, the output should be:

```
0
0
1
1
```

**Actual Behavior**:
For step 2, the actual behaviour is as expected. For step 3, the IDE gives no "red squiggles" to indicate a problem, and the error list remains empty. The compilation fails though, with:

```
Program.cs(16,50,16,58): error CS8157: No 'operator is' declaration in 'C' was found with 1 out parameters
Program.cs(16,61,16,62): error CS0165: Use of unassigned local variable 'c'
Program.cs(20,22,20,30): error CS8157: No 'operator is' declaration in 'C' was found with 1 out parameters
Program.cs(21,22,21,25): error CS8157: No 'operator is' declaration in 'B' was found with 0 out parameters
Program.cs(20,35,20,40): error CS0428: Cannot convert method group 'Prop2' to non-delegate type 'int'. Did you intend to invoke the method?
```
</Description>
        <CreatedDate>06/04/2016</CreatedDate>
        <ClosedDate>16/04/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>10590</PullRequestID>
        <IssueID>8778</IssueID>
        <Title>Some unit tests disabled for pattern-matching branch</Title>
        <Description>Some unit tests are disabled for the pattern-matching branch future/patterns. They will be marked with this issue number. They are being disabled so that issues with those tests can be addressed separately from development of the rest of the feature.

The specific issue that is a problem in that branch is getting a speculative semantic model for a statement that is a local declaration.
</Description>
        <CreatedDate>16/02/2016</CreatedDate>
        <ClosedDate>16/04/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>10590</PullRequestID>
        <IssueID>9284</IssueID>
        <Title>SymbolInfo for bad property in a property pattern should contain candidate symbols</Title>
        <Description>The `SymbolInfo` returned when there is a bad property in a property pattern (e.g. because it is ambiguous, inaccessible, `static`, etc) should contain any properties that are (improperly) referenced.

See, for example, the test `AmbiguousNamedProperty` in `PatternMatchingTests`.
</Description>
        <CreatedDate>28/02/2016</CreatedDate>
        <ClosedDate>05/06/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>10590</PullRequestID>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Operators.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Patterns.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/SwitchBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/SwitchBinder_BindPatternSwitch.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_Patterns.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PEMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>10450</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Accessibility Improvements</Title>
    <Description>Extract Interface (fixes #9958)
- Read textbox labels
- Read extractable members

Generate Type (fixes #9959)
- Read label text on dropdowns
- Read combobox items

Change Signature (fixes #9957)
- Read parameter and button text

Options pages (fixes #9962)
- Read labels/checkboxes/radiobuttons
</Description>
    <CreatedDate>10/04/2016</CreatedDate>
    <ClosedDate>02/05/2016</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>10450</PullRequestID>
        <IssueID>9958</IssueID>
        <Title>[PR in review] Extract Interface dialog unusable under Narrator</Title>
        <Description>1. The three textblocks at the top don't give context (pri 1)
2. The checkboxes in the "Select public members to form interface" list are not read properly (pri 1)
</Description>
        <CreatedDate>22/03/2016</CreatedDate>
        <ClosedDate>02/05/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>10450</PullRequestID>
        <IssueID>9959</IssueID>
        <Title>[PR in review] Generate Type dialog unusable under Narrator</Title>
        <Description>1. Access/Kind dropdowns don't give any context (pri 2)
2. Project-choosing combo box is read improperly (pri 1)
3. "Add to existing file" combo box is read improperly (pri 1)
</Description>
        <CreatedDate>22/03/2016</CreatedDate>
        <ClosedDate>02/05/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>10450</PullRequestID>
        <IssueID>9957</IssueID>
        <Title>[PR in review] Change Signature dialog unusable under Narrator</Title>
        <Description>1. The up &amp; down buttons are read as just "button" (pri 1)
2. The rows of the "Parameters" table are not read properly (pri 1)
3. The "Preview method signature" is not a tab stop (pri 2)
</Description>
        <CreatedDate>22/03/2016</CreatedDate>
        <ClosedDate>02/05/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>10450</PullRequestID>
        <IssueID>9962</IssueID>
        <Title>[PR in review] Options pages with previews are unusable under Narrator</Title>
        <Description>1. Checkboxes &amp; radio buttons are read improperly (Pri 1)
2. Preview code is not read at all (Pri 2)
</Description>
        <CreatedDate>22/03/2016</CreatedDate>
        <ClosedDate>02/05/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>10450</PullRequestID>
      <File>src/VisualStudio/Core/Def/Implementation/ChangeSignature/ChangeSignatureDialogViewModel.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ExtractInterface/ExtractInterfaceDialogViewModel.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Utilities/AutomationDelegatingListView.cs</File>
      <File>src/VisualStudio/Core/Def/ServicesVSResources.Designer.cs</File>
      <File>src/VisualStudio/Core/Impl/Options/OptionPreviewControl.xaml.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>10427</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Stop creating local function nodes w/o flag</Title>
    <Description>When the experimental features flag is not enabled we should create only
C#6 nodes to prevent legacy consumers from being given parse nodes they
can't understand.

Fixes #9940 

@jaredpar @VSadov @dotnet/roslyn-compiler Please review
</Description>
    <CreatedDate>08/04/2016</CreatedDate>
    <ClosedDate>12/04/2016</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>10427</PullRequestID>
        <IssueID>6</IssueID>
        <Title>Corrected documentation on FullSpan and Span</Title>
        <Description>As per the [Incorrect Docs on FullSpan/Span properties](http://roslyn.codeplex.com/workitem/260) issue, the documentation was reversed on a few of these pairs.

&lt;!---
@huboard:{"order":8.0}
--&gt;
</Description>
        <CreatedDate>15/01/2015</CreatedDate>
        <ClosedDate>09/02/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>10427</PullRequestID>
        <IssueID>9940</IssueID>
        <Title>Parser builds nodes for local functions when feature not enabled</Title>
        <Description>For compatibility with analyzers that were written for C# 6, the parser should not build new nodes unless the relevant feature is enabled. Though we do give an error, we do build a node for a local function even without the feature being enabled.
</Description>
        <CreatedDate>21/03/2016</CreatedDate>
        <ClosedDate>12/04/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>10427</PullRequestID>
      <File>src/Compilers/CSharp/Portable/CSharpParseOptions.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/LanguageParser.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/ConstantTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/LocalFunctionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/LocalFunctionParsingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/ParsingTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/DiagnosticAnalyzerDriver/DiagnosticAnalyzerDriverTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>8435</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Require prohibit this me</Title>
    <Description>This is a port of #7540 (now closed) to the `future` branch.
### Description

Splits the option _"Qualify member access with 'this' or 'Me'"_ into four separate options (and marks the former as `[Obsolete]`):
- Qualify **field** access.
- Qualify **property** access.
- Qualify **method** access.
- Qualify **event** access.
### Known Issues
1. We've discussed giving the user a dial in how and when these properties should be applied, e.g., "only apply this style on newly generated code" all the way up to "flag violations of this style as a build break" and various steps in between.  That has not been addressed in this PR and is still an open discussion item that I filed as #7289.
2. If a user currently has _"Qualify member access with 'this' or 'Me'"_ set to `true`, we need some way to upgrade/migrate that setting to the 4 new separate settings.

Fixes #7065.
Fixes #7090.

Also fixes an unrelated bug I found in Encapsulate Field in VB that caused `Me.` to be improperly included when an escaped keyword is used when the option wasn't set and also enables Encapsulate Field in C# for escaped identifiers.

Also fixes event hookup generation in C# to produce `MyEvent += this.GeneratedEventHandler;` where `this.` will be appropriately simplified or not and the inline rename session will always use the `GeneratedEventHandler` span.

@dotnet/roslyn-ide
</Description>
    <CreatedDate>06/02/2016</CreatedDate>
    <ClosedDate>29/02/2016</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>8435</PullRequestID>
        <IssueID>7540</IssueID>
        <Title>add options to require this/Me for fields, properties, methods, and events</Title>
        <Description>This is a re-creation of PR #7296 to address feedback.  Since there are so many changes I opted to close the other PR and open a new one to preserve an easy comment history and enable a side-by-side diff.
### Description

Splits the option _"Qualify member access with 'this' or 'Me'"_ into four separate options (and marks the former as `[Obsolete]`):
- Qualify **field** access.
- Qualify **property** access.
- Qualify **method** access.
- Qualify **event** access.
### Known Issues
1. We've discussed giving the user a dial in how and when these properties should be applied, e.g., "only apply this style on newly generated code" all the way up to "flag violations of this style as a build break" and various steps in between.  That has not been addressed in this PR and is still an open discussion item that I filed as #7289.
2. If a user currently has _"Qualify member access with 'this' or 'Me'"_ set to `true`, we need some way to upgrade/migrate that setting to the 4 new separate settings.

Fixes #7065.
Fixes #7090.
Also fixes an unrelated bug I found in Encapsulate Field in VB that caused `Me.` to be improperly included when an escaped keyword is used when the option wasn't set and also enables Encapsulate Field in C# for escaped identifiers.
</Description>
        <CreatedDate>16/12/2015</CreatedDate>
        <ClosedDate>06/02/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>8435</PullRequestID>
        <IssueID>7289</IssueID>
        <Title>Let users specify how/when their code styles will be applied.</Title>
        <Description>If the user has certain code styles specified (e.g., qualify member access with this/Me) there are 4 (quite possibly more) distinct levels of enforcement that they may want applied.  Roughly in order:
1.  Only apply to newly generated code/refactorings.
2.  Allow me to change styles that don't match, but I have to go looking for them (e.g., how "Inline temporary variable" is exposed today.)
3.  Notify me in the IDE (glyph, underline, etc.) but not via the error list (e.g., info).
4.  Notify me in the error list (e.g., info) and also on the command line.
5.  Notify me in the error list and also potentially break my build (e.g., warning, error.)

These should likely be applied to all items mentioned in #7071.
</Description>
        <CreatedDate>07/12/2015</CreatedDate>
        <ClosedDate>19/01/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>8435</PullRequestID>
        <IssueID>7065</IssueID>
        <Title>Code Style: Analyzer + Code fix for requiring/prohibiting this/Me</Title>
        <Description>We have an analyzer + code fix to support removing redundant uses, but we need options for what type of access it is (field/property/method/etc), and to require it.
</Description>
        <CreatedDate>25/11/2015</CreatedDate>
        <ClosedDate>15/03/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>8435</PullRequestID>
        <IssueID>7090</IssueID>
        <Title>"Encapsulate fields" refactoring should consider personal code style</Title>
        <Description>If I have this code:

``` csharp
public class Test
{
    protected readonly bool IsATest;
}
```

the refactoring generates the following code.

``` csharp
public class Test
{
    private readonly bool isATest;
    protected bool IsATest
    {
        get
        {
            return isATest;
        }
    }
}
```

Since I have checked "Qualify member access with 'this'" I expect to get following refactoring:

``` csharp
public class Test
{
    private readonly bool isATest;
    protected bool IsATest
    {
        get
        {
            return this.isATest;
        }
    }
}
```

Notice the added `this.`.

![image](https://cloud.githubusercontent.com/assets/8558126/11429724/75333598-947c-11e5-938e-ed170971450b.png)

Thanks to @sharwell for referring to the right project in DotNetAnalyzers/StyleCopAnalyzers#1833
</Description>
        <CreatedDate>26/11/2015</CreatedDate>
        <ClosedDate>12/04/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>8435</PullRequestID>
      <File>src/EditorFeatures/CSharp/EventHookup/EventHookupCommandHandler_TabKeyCommand.cs</File>
      <File>src/EditorFeatures/CSharpTest/CodeActions/EncapsulateField/EncapsulateFieldTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/CodeActions/GenerateFromMembers/GenerateConstructor/GenerateConstructorTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/GenerateConstructor/GenerateConstructorTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/GenerateType/GenerateTypeTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/QualifyMemberAccess/QualifyMemberAccessTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/SimplifyTypeNames/SimplifyTypeNamesTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/SimplifyTypeNames/SimplifyTypeNamesTests_FixAllTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/EventHookup/EventHookupCommandHandlerTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/EventHookup/EventHookupTestState.cs</File>
      <File>src/EditorFeatures/Test/CodeActions/AbstractCodeActionOrUserDiagnosticTest.cs</File>
      <File>src/EditorFeatures/Test/Diagnostics/AbstractDiagnosticProviderBasedUserDiagnosticTest.cs</File>
      <File>src/EditorFeatures/Test/Extensions/WorkspaceExtensions.cs</File>
      <File>src/EditorFeatures/TestUtilities/Traits.cs</File>
      <File>src/Features/CSharp/Portable/CSharpFeaturesResources.Designer.cs</File>
      <File>src/Features/CSharp/Portable/CodeFixes/QualifyMemberAccess/CSharpQualifyMemberAccessCodeFixProvider.cs</File>
      <File>src/Features/CSharp/Portable/CodeFixes/SimplifyTypeNames/SimplifyTypeNamesCodeFixProvider.cs</File>
      <File>src/Features/CSharp/Portable/Diagnostics/Analyzers/CSharpQualifyMemberAccessDiagnosticAnalyzer.cs</File>
      <File>src/Features/CSharp/Portable/Diagnostics/Analyzers/CSharpSimplifyTypeNamesDiagnosticAnalyzer.cs</File>
      <File>src/Features/CSharp/Portable/EncapsulateField/CSharpEncapsulateFieldService.cs</File>
      <File>src/Features/Core/Portable/CodeFixes/PredefinedCodeFixProviderNames.cs</File>
      <File>src/Features/Core/Portable/CodeFixes/Qualify/AbstractFullyQualifyCodeFixProvider.cs</File>
      <File>src/Features/Core/Portable/CodeFixes/Qualify/AbstractQualifyMemberAccessCodeFixprovider.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/AnalyzerHelper.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/Analyzers/IDEDiagnosticIds.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/Analyzers/QualifyMemberAccessDiagnosticAnalyzerBase.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/Analyzers/SimplifyTypeNamesDiagnosticAnalyzerBase.cs</File>
      <File>src/Features/Core/Portable/EncapsulateField/AbstractEncapsulateFieldService.cs</File>
      <File>src/Features/Core/Portable/FeaturesResources.Designer.cs</File>
      <File>src/VisualStudio/CSharp/Impl/CSharpVSResources.Designer.cs</File>
      <File>src/VisualStudio/CSharp/Impl/Options/AutomationObject.cs</File>
      <File>src/VisualStudio/CSharp/Impl/Options/Formatting/StyleViewModel.cs</File>
      <File>src/Workspaces/CSharp/Portable/Extensions/ExpressionSyntaxExtensions.cs</File>
      <File>src/Workspaces/Core/Portable/Simplification/SimplificationHelpers.cs</File>
      <File>src/Workspaces/Core/Portable/Simplification/SimplificationOptionProvider.cs</File>
      <File>src/Workspaces/Core/Portable/Simplification/SimplificationOptions.cs</File>
      <File>src/Workspaces/Core/Portable/WorkspacesResources.Designer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>8425</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Change how we format on certain commit..</Title>
    <Description>..chars from completion. We used to call the formatting service from the
completion list with the span equal to that of the text that we
inserted, in all cases. This may not be the right approach in all cases
and that is manifested when we are formatting for a typed char that
happens to be the trigger character for the formatter as well. In such
cases we must find the right span to give to the formatter, or in other
words, the span the formatter would have come up with if it were
triggered first for the typed char. We do this by simply invoking the
appropriate formatting service API and giving it the typed char and its
position, which lets the formatting service to compute the right
span.
We do this only when were invoking the completion's commit char is also
a trigger for formatting. In other cases, we continue taking the
existing code path of formatting by giving it a known span.

Fixes #7768, #8228
</Description>
    <CreatedDate>05/02/2016</CreatedDate>
    <ClosedDate>09/02/2016</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>8425</PullRequestID>
        <IssueID>7768</IssueID>
        <Title>Formatting of automatic properties in WPF and UWP apps</Title>
        <Description>Hi!

When I'm editing a WPF or UWP app in Visual Studio 2015, and I'm creating an automatic property in C#, I type something like: 

``` C#
public string Whatever {get
```

but when I type the semicolon after the get, the get; moves down to the next line, regardless of my editor formatting settings in Visual Studio.

``` C#
public string Whatever {
    get;
```

This does not happen in ASP.NET applications. Hardly a showstopper, but annoying and breaks my flow for a moment.

Thanks!
Scott
</Description>
        <CreatedDate>04/01/2016</CreatedDate>
        <ClosedDate>09/02/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>8425</PullRequestID>
        <IssueID>8228</IssueID>
        <Title>Autocomplete forces new line</Title>
        <Description>Forgot to file this separately (#2837)...

Update 1 RTM (24720), relevant settings:
C# &gt; Formatting &gt; Wrapping &gt; Leave block on single line  on  (on by default)
C# &gt; Automatic brace completion  off  (newly on by default)

The following code is expected to stay on the same line.

``` C#
namespace ConsoleApplication1
{
    class Program
    {
        public static bool One { get|

        static void Main(string[] args)
        {
        }
    }
}
```

But instead it turns into:

``` C#
        public static bool One {
            get;
```

The same with:

``` C#
public static void Test() { return|
```

Note that if you cancel the autocomplete suggestions of `get`/`return` it does not happen.
</Description>
        <CreatedDate>28/01/2016</CreatedDate>
        <ClosedDate>28/01/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>8425</PullRequestID>
      <File>src/EditorFeatures/CSharpTest/Completion/CompletionProviders/KeywordCompletionProviderTests.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/Completion/Controller_Commit.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>8417</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Format Do block on Close brace without suppression</Title>
    <Description>Fixes #8413

Related to #6645 

Format the do block on close brace even if the while clause is missing.
This improves the typing experience.

Review : @dotnet/roslyn-ide 
</Description>
    <CreatedDate>05/02/2016</CreatedDate>
    <ClosedDate>05/02/2016</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>8417</PullRequestID>
        <IssueID>8413</IssueID>
        <Title>Formatting on close brace doesn't format do/while block</Title>
        <Description>This issue is similar to #6645
</Description>
        <CreatedDate>05/02/2016</CreatedDate>
        <ClosedDate>05/02/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>8417</PullRequestID>
        <IssueID>6645</IssueID>
        <Title>try formatting does not put { on new line</Title>
        <Description>Automatic brace completion setting off. All new line settings default.

``` C#
try {
|
```

Type `}`. Actual:

``` C#
try {
}|
```

Expected:

``` C#
try
{
}|
```

like in Visual Studio 2013.

This breaks the workflow when you hit up arrow key and enter, expecting to end up writing the body of the try block.

When you format the document, the brackets go where expected, suggesting that "Automatically format completed block on }" does not work for the case of `try`.
</Description>
        <CreatedDate>08/11/2015</CreatedDate>
        <ClosedDate>04/02/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>8417</PullRequestID>
      <File>src/EditorFeatures/CSharp/Formatting/Indentation/SmartTokenFormatter.cs</File>
      <File>src/EditorFeatures/CSharpTest/Formatting/Indentation/SmartTokenFormatterFormatRangeTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>8390</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Fix speculation analyzer to correctly use converted type when testing conversions with Option Strict On</Title>
    <Description>Fixes #8381

Previously, I'd made a fix to the speculation analyzer to not remove necessary casts in the presence of Option Strict On. For example:

``` VB
Option Strict On
Class C
    Sub M()
        Dim b As Byte
        b += CByte(1)
    End Sub
End Class
```

This was fixed to address #2560. However, the fix was less than ideal because it had to work around the fact that there isn't a compiler API
available to retrieve the built-in operator of an AssignmentStatement in VB (#6366). Essentially, here's how the workaround works:

When Option Strict is not Off and an assignment statement is being replaced with another assignment statement, the workaround checks the type
of the new expression on the right and verifies that it's convertible to the type of the expression on the right. For the example above, it checks
to see if '1' (System.Int32) is implicitly convertible to 'b' (System.Byte), which it isn't. So, the cast is left behind for Option Strict On.

**_...Fast forward to now...**_

``` VB
Option Strict On
Class C
    Privat i As Short
    Sub M()
        Me.i = 0
    End Sub
End Class
```

It turns out that this was caused by the workaround described above. With that workaround, we check to see if the '0' (System.Int32) is convertible
to 'Me.i' (System.Int16). It isn't, so things go askew. The fix is to use the _converted type_ of the expression on the right (System.Int16) and check
to see if it is convertible to the type on the left.

tagging @dotnet/roslyn-ide 
</Description>
    <CreatedDate>04/02/2016</CreatedDate>
    <ClosedDate>05/02/2016</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>8390</PullRequestID>
        <IssueID>8381</IssueID>
        <Title>VB.NET: Short fields are ignored in IDE0003 code fix</Title>
        <Description>The VB.NET IDE editor does not provide IDE0003 (Name can be simplified) code fix for fields or properties declared as Short (System.Int16).

``` vb
Class Class1
    Private field1 As Short
    Private field2 As Integer

    Public Sub New()
        Me.field1 = 0 ' IDE0003 fix not available for the Me keyword
        Me.field2 = 0
    End Sub
End Class
```

Tested in Visual Studio 2015 Update 1.
</Description>
        <CreatedDate>04/02/2016</CreatedDate>
        <ClosedDate>05/02/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>8390</PullRequestID>
        <IssueID>2560</IssueID>
        <Title>Wrong Cast is redundant with Option Strict On in VB</Title>
        <Description>In a VB.NET project with Option Strict On the following code with += operator trigger "Cast is redundant" but when apply the fix, the code became broken:

``` vb
Dim b As Byte
b += CByte(1) ' IDE0004 Cast is redundant
```

After the fix:

``` vb
Dim b As Byte
b += 1 ' Option Strict On disallows implicit conversions from 'Integer' to 'Byte'.
```

This happens with any data type requires explicit conversion.
</Description>
        <CreatedDate>06/05/2015</CreatedDate>
        <ClosedDate>27/10/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>8390</PullRequestID>
        <IssueID>6366</IssueID>
        <Title>VB: No compiler API to get built in-operator of AssignmentStatement</Title>
        <Description>While we can use `GetSymbolInfo` to retrieve the built-in operator used in an expression, we currently lack an API to retrieve the built-in operator used in a VB assignment statement. This results in analysis problems like the one causing #2560. Additionally, VB IDE features work inconsistently because built-in operators can't always be retrieved from the compiler APIs.

``` VB
Module Program
    Sub Main()
        Dim x As Integer
        x = x + 1
        x += 1
    End Sub
End Module
```

In the code above, if the user hovers over `+` in the first assignment statement, they'll see the built-in operator in the Quick Info tooltip:

![image](https://cloud.githubusercontent.com/assets/116161/10771400/d5728292-7cad-11e5-885d-1aafe305a1bd.png)

However, there's no tooltip if they hover over `+=`.

This is in contrast to C#. In C#, because assignments are expressions, `GetSymbolInfo` can return the built-in operator for each case:

![image](https://cloud.githubusercontent.com/assets/116161/10771443/127f03fe-7cae-11e5-962a-47d564d5d829.png)

![image](https://cloud.githubusercontent.com/assets/116161/10771456/1ce72ede-7cae-11e5-879b-8ecf1b9794ca.png)
</Description>
        <CreatedDate>27/10/2015</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>8390</PullRequestID>
      <File>src/Features/CSharp/Portable/Diagnostics/Analyzers/CSharpSimplifyTypeNamesDiagnosticAnalyzer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>8362</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>  Pass through features, publicsign, and deterministic flags to the IDE</Title>
    <Description>This adds support for a new ICompilerOptionsHostObject which is how we can pass options through the project system without having to manually add separate properties for everything as we've traditionally done in the past. To ensure compatibility with "new" compiler tasks against
"old" project systems, and "new" project systems against "old" tasks, we continue to use the historical ICscHostObject\* and IVbcHostObject\* properties for all existing values, and only use this property to
shuttle through new values. For the rest of Visual Studio 2015, we can just use this for any new "simple" switches that we must pass along.  We still would need to do additional work in the project system for any inputs that are lists of files because of the fast-up-to-date check.

Longer term, there is still the unanswered question of how we want to future versions of Visual Studio to get command line options to completely get rid of all language service knowledge of this. There are
two possible approaches:
1. We just use the support added in #4604 and just delete this entirely.
2. We continue to use ICompilerOptionsHostObject. My proposal for that would be we continue to use the model of "we pass all options not supported by a strongly typed host object interface to ICompilerOptionsHostObject", and the project system would just remove all support for everything else and fail those QueryInterface calls.

This is therefore written with the idea that we could switch to option 2 in a coordinated way, if we wanted to do so.

Fixes #7812, assuming you have an updated csproj.dll and msvbprj.dll which understands the new ICompilerOptionsHostObject.

_Review:_ @dotnet/roslyn-compiler, @dotnet/roslyn-ide 
</Description>
    <CreatedDate>03/02/2016</CreatedDate>
    <ClosedDate>10/02/2016</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>8362</PullRequestID>
        <IssueID>4604</IssueID>
        <Title>Allow collection of C#/VB command line without actually compiling</Title>
        <Description>For design-time builds that seek to initialize the language service the command line is all we need. 
This change makes the command line arguments available to other MSBuild targets or (more importantly) a host that sets these global properties as part of the build:

```
ProvideCommandLineInvocation=true
SkipCompilerExecution=true
```

In this way, the CoreCompile target's `Returns` produces the command line that has all the information necessary to initialize the language service elsewhere. 
</Description>
        <CreatedDate>17/08/2015</CreatedDate>
        <ClosedDate>01/09/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>8362</PullRequestID>
        <IssueID>7812</IssueID>
        <Title>New compiler switches need to be threaded through the project system for intellisense builds</Title>
        <Description>Right now these flags are not being passed through to the IDE design time builds:
- /features
- /deterministic
- /pathmap
- /publicsign
- /pdb:portable

Issue #6945 is tracking the feature request of adding UI, but even if we do not do that, we must pass these flags through design time builds or all sorts of things don't work. Notably, lack of /publicsign breaks semantics like crazy, since it assumes the .snk has private keys. Lack of /pathmap would be observable if an ENC edit did something around CallerInfo. /feature is a blocker for anybody trying to build new features.
</Description>
        <CreatedDate>07/01/2016</CreatedDate>
        <ClosedDate>10/02/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>8362</PullRequestID>
      <File>src/Compilers/Core/MSBuildTask/Shared/Csc.cs</File>
      <File>src/Compilers/Core/MSBuildTask/Shared/ICompilerOptionsHostObject.cs</File>
      <File>src/Compilers/Core/MSBuildTask/Shared/ManagedCompiler.cs</File>
      <File>src/Compilers/Core/MSBuildTask/Shared/Vbc.cs</File>
      <File>src/Compilers/Core/MSBuildTaskTests/CscTests.cs</File>
      <File>src/Compilers/Core/MSBuildTaskTests/VbcTests.cs</File>
      <File>src/VisualStudio/CSharp/Impl/CSharpPackage.cs</File>
      <File>src/VisualStudio/CSharp/Impl/LanguageService/CSharpLanguageService.cs</File>
      <File>src/VisualStudio/CSharp/Impl/ProjectSystemShim/CSharpProject.cs</File>
      <File>src/VisualStudio/CSharp/Impl/ProjectSystemShim/CSharpProjectShim.ICSInputSet.cs</File>
      <File>src/VisualStudio/CSharp/Impl/ProjectSystemShim/CSharpProjectShim.ICSharpVenusProjectSite.cs</File>
      <File>src/VisualStudio/CSharp/Impl/ProjectSystemShim/CSharpProjectShim.cs</File>
      <File>src/VisualStudio/CSharp/Test/ProjectSystemShim/CSharpReferencesTests.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/AbstractVsTextViewFilter`3.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/EditAndContinue/VsENCRebuildableProjectImpl.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/EditAndContinue/VsReadOnlyDocumentTracker.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/AbstractEncProject.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/AbstractProject.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/AbstractProject_IAnalyzerHost.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/AbstractRoslynProject.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/AbstractRoslynProject_IVsENCRebuildableProjectCfg.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/Interop/ICompilerOptionsHostObject.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>8289</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Read Portable PDB directly in EEs instead of thru ISymUnmanagedReader</Title>
    <Description>We need to read at least CDI directly since the portable PDB bridge doesn't translate them to the legacy format. Since we are already special casing CDI we could very well read all the infomration directly and avoid a layer of translation.

Fixes #7856
Fixes #1989
Fixes #1985
Fixes #702
</Description>
    <CreatedDate>01/02/2016</CreatedDate>
    <ClosedDate>09/02/2016</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>8289</PullRequestID>
        <IssueID>7856</IssueID>
        <Title>[Portable PDB] Expression evaluator doesn't pickup using statements when compiling using portable PDBs</Title>
        <Description>Repro steps:
1. Install build of update 2 with core debugger support for portable PDBs (you will need to get this from me at the moment)
2. Write a little debuggee that uses Linq
3. Set a breakpoint and hit it
4. Attempt to evaluate a Linq statement in the immediate window

Result:
myKids.Where(x =&gt; x.Age == 8).First().Name
error CS1061: 'List&lt;Person&gt;' does not contain a definition for 'Where' and no extension method 'Where' accepting a first argument of type 'List&lt;Person&gt;' could be found (are you missing a using directive or an assembly reference?)

This works correctly if I use traditional PDBs
</Description>
        <CreatedDate>08/01/2016</CreatedDate>
        <ClosedDate>09/02/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>8289</PullRequestID>
        <IssueID>1989</IssueID>
        <Title>[Portable PDB] Support TypeSpecs in MetadataDecoder.ResolveSignatureTypeHandleOrThrow</Title>
        <Description>
        </Description>
        <CreatedDate>14/04/2015</CreatedDate>
        <ClosedDate>09/02/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>8289</PullRequestID>
        <IssueID>1985</IssueID>
        <Title>[Portable PDB] Avoid dependencies on legacy PDB format in EE tests</Title>
        <Description>Currently the tests are disabled. Search EE tests for the bug number.
</Description>
        <CreatedDate>14/04/2015</CreatedDate>
        <ClosedDate>09/02/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>8289</PullRequestID>
        <IssueID>702</IssueID>
        <Title>[Portable PDB] Update the Expression Compiler to consume the portable PDB format</Title>
        <Description>Phase 1: introduce an abstraction over the custom debug info.
</Description>
        <CreatedDate>20/02/2015</CreatedDate>
        <ClosedDate>09/02/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>8289</PullRequestID>
      <File>src/Compilers/Core/Portable/MetadataReader/MetadataDecoder.cs</File>
      <File>src/Compilers/Core/Portable/PEWriter/MetadataTablesBuilder.cs</File>
      <File>src/Compilers/Core/SharedCollections/ArrayBuilder.cs</File>
      <File>src/Debugging/Microsoft.DiaSymReader.PortablePdb/SymConstant.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Source/ExpressionCompiler/CSharpEESymbolProvider.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Source/ExpressionCompiler/CompilationContext.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Source/ExpressionCompiler/CompilationExtensions.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Source/ExpressionCompiler/EvaluationContext.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Source/ExpressionCompiler/SymUnmanagedReaderExtensions.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Test/ExpressionCompiler/DynamicTests.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Test/ExpressionCompiler/ExpressionCompilerTestBase.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Test/ExpressionCompiler/ExpressionCompilerTests.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Test/ExpressionCompiler/HoistedStateMachineLocalTests.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Test/ExpressionCompiler/HoistedThisTests.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Test/ExpressionCompiler/LocalsTests.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Test/ExpressionCompiler/MethodContextReuseConstraintsTests.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Test/ExpressionCompiler/ReferencedModulesTests.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Test/ExpressionCompiler/UsingDebugInfoTests.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Test/ExpressionCompiler/WinMdTests.cs</File>
      <File>src/ExpressionEvaluator/Core/Source/ExpressionCompiler/EESymbolProvider.cs</File>
      <File>src/ExpressionEvaluator/Core/Source/ExpressionCompiler/ILSpan.cs</File>
      <File>src/ExpressionEvaluator/Core/Source/ExpressionCompiler/MetadataUtilities.cs</File>
      <File>src/ExpressionEvaluator/Core/Source/ExpressionCompiler/MethodContextReuseConstraints.cs</File>
      <File>src/ExpressionEvaluator/Core/Source/ExpressionCompiler/PDB/ExternAliasRecord.cs</File>
      <File>src/ExpressionEvaluator/Core/Source/ExpressionCompiler/PDB/HoisedLocalScopeRecord.cs</File>
      <File>src/ExpressionEvaluator/Core/Source/ExpressionCompiler/PDB/ImportRecord.cs</File>
      <File>src/ExpressionEvaluator/Core/Source/ExpressionCompiler/PDB/MethodDebugInfo.Native.cs</File>
      <File>src/ExpressionEvaluator/Core/Source/ExpressionCompiler/PDB/MethodDebugInfo.Portable.cs</File>
      <File>src/ExpressionEvaluator/Core/Source/ExpressionCompiler/PDB/MethodDebugInfo.cs</File>
      <File>src/ExpressionEvaluator/Core/Source/ExpressionCompiler/PDB/NativeExternAliasRecord.cs</File>
      <File>src/ExpressionEvaluator/Core/Source/ExpressionCompiler/PDB/NativeImportRecord.cs</File>
      <File>src/ExpressionEvaluator/Core/Source/ExpressionCompiler/PDB/PdbHelpers.cs</File>
      <File>src/ExpressionEvaluator/Core/Source/ExpressionCompiler/PDB/PortableExternAliasRecord.cs</File>
      <File>src/ExpressionEvaluator/Core/Source/ExpressionCompiler/PDB/PortableImportRecord.cs</File>
      <File>src/ExpressionEvaluator/Core/Test/ExpressionCompiler/MethodDebugInfoBytes.cs</File>
      <File>src/ExpressionEvaluator/Core/Test/ExpressionCompiler/MethodDebugInfoValidation.cs</File>
      <File>src/ExpressionEvaluator/Core/Test/ExpressionCompiler/RuntimeInstance.cs</File>
      <File>src/Test/PdbUtilities/Metadata/MetadataVisualizer.cs</File>
      <File>src/Test/PdbUtilities/Shared/CustomDebugInfoReader.cs</File>
      <File>src/Test/Utilities/Shared/Pdb/PdbValidation.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>8184</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Bug Fix 5607: VB Parenthesis overtyping</Title>
    <Description>Fixes #5607

The bug was that automatic brace completion will not overtype close
parenthesis if the close parenthesis token was preceded by a numeric
literal. The bug was in `IsEntirelyWithinStringOrCharOrNumericLiteral`,
where we were imposing checks meant for chars and strings on numeric
literals, which was likely introduced in PR #1763. This change addresses
it by not enforcing checks meant for chars/strings on numeric literals.
</Description>
    <CreatedDate>26/01/2016</CreatedDate>
    <ClosedDate>26/01/2016</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>8184</PullRequestID>
        <IssueID>5607</IssueID>
        <Title>VB "match closing parenthesis" fails for some constructs (works for others)</Title>
        <Description>![matchclosingparenthesis](https://cloud.githubusercontent.com/assets/3316258/10220871/76d1e1e6-6818-11e5-86e8-cb7359d407af.gif)

Here's a minimal video repro. In all three lines I'm typing the closing parenthesis `)` rather than cursoring-right over it. Observe that "match closing parenthesis" feature works fine when I write the generic type, and when I write console.writeline, but it fails on list.RemoveAt.

I've noticed this failure a lot in my day-to-day coding. I haven't figured out which things work and which don't.
</Description>
        <CreatedDate>01/10/2015</CreatedDate>
        <ClosedDate>26/01/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>8184</PullRequestID>
        <IssueID>1763</IssueID>
        <Title>Don't trigger completion within numeric literals</Title>
        <Description>Or, in VB, date literals. Fixes #1736 

May be interested: @brettfo @jasonmalinowski @Pilchie @dpoeschl @basoundr @balajikris 
</Description>
        <CreatedDate>02/04/2015</CreatedDate>
        <ClosedDate>03/04/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>8184</PullRequestID>
      <File>src/EditorFeatures/Test/AutomaticCompletion/AbstractAutomaticBraceCompletionTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>7600</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Remove SymReader mock, use the real reader since we always have ISymUnmanagedReader3 now</Title>
    <Description>This change was previously reverted since it caused random failures. Apply again now with a fix of the root cause: SymReaderFactory has to keep the PEReader it creates alive while DummyMetadataImport is being used.

Fixes #6815.
Fixes #6651.
</Description>
    <CreatedDate>18/12/2015</CreatedDate>
    <ClosedDate>19/12/2015</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>7600</PullRequestID>
        <IssueID>6815</IssueID>
        <Title>LocalDuplicateConstantAndConstantNonDynamic is failing occasionally </Title>
        <Description>MESSAGE:
System.BadImageFormatException : An attempt was made to load a program with an incorrect format. (Exception from HRESULT: 0x8007000B)
+++++++++++++++++++
STACK TRACE:
at System.Runtime.InteropServices.Marshal.ThrowExceptionForHRInternal(Int32 errorCode, IntPtr errorInfo) at System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(Int32 errorCode, IntPtr errorInfo) at Microsoft.DiaSymReader.SymUnmanagedReaderExtensions.ThrowExceptionForHR(Int32 hr) in d:\j\workspace\roslyn_prtest_win_dbg_unit32\src\Test\PdbUtilities\Shared\SymUnmanagedReaderExtensions.cs:line 489 at Microsoft.DiaSymReader.SymUnmanagedReaderExtensions.GetItems[TEntity,TItem](TEntity entity, ItemsGetter`2 getter) in d:\j\workspace\roslyn_prtest_win_dbg_unit32\src\Test\PdbUtilities\Shared\SymUnmanagedReaderExtensions.cs:line 106 at Microsoft.DiaSymReader.SymUnmanagedReaderExtensions.GetSignature(ISymUnmanagedConstant constant) in d:\j\workspace\roslyn_prtest_win_dbg_unit32\src\Test\PdbUtilities\Shared\SymUnmanagedReaderExtensions.cs:line 457 at Microsoft.CodeAnalysis.CSharp.ExpressionEvaluator.EvaluationContext.GetConstants(ArrayBuilder`1 builder, MethodSymbol method, ArrayBuilder`1 scopes, MetadataDecoder metadataDecoder, ImmutableDictionary`2 dynamicLocalConstantMap, SourceAssemblySymbol containingAssembly) in d:\j\workspace\roslyn_prtest_win_dbg_unit32\src\ExpressionEvaluator\CSharp\Source\ExpressionCompiler\EvaluationContext.cs:line 517 at Microsoft.CodeAnalysis.CSharp.ExpressionEvaluator.EvaluationContext.CreateMethodContext(CSharpCompilation compilation, Object symReader, Guid moduleVersionId, Int32 methodToken, Int32 methodVersion, Int32 ilOffset, Int32 localSignatureToken) in d:\j\workspace\roslyn_prtest_win_dbg_unit32\src\ExpressionEvaluator\CSharp\Source\ExpressionCompiler\EvaluationContext.cs:line 223 at Microsoft.CodeAnalysis.CSharp.ExpressionEvaluator.EvaluationContext.CreateMethodContext(CSharpMetadataContext previous, ImmutableArray`1 metadataBlocks, Object symReader, Guid moduleVersionId, Int32 methodToken, Int32 methodVersion, UInt32 ilOffset, Int32 localSignatureToken) in d:\j\workspace\roslyn_prtest_win_dbg_unit32\src\ExpressionEvaluator\CSharp\Source\ExpressionCompiler\EvaluationContext.cs:line 147 at Microsoft.CodeAnalysis.CSharp.UnitTests.ExpressionCompilerTestBase.CreateMethodContext(RuntimeInstance runtime, String methodName, Int32 atLineNumber) in d:\j\workspace\roslyn_prtest_win_dbg_unit32\src\ExpressionEvaluator\CSharp\Test\ExpressionCompiler\ExpressionCompilerTestBase.cs:line 132 at Microsoft.CodeAnalysis.CSharp.UnitTests.DynamicTests.LocalDuplicateConstantAndConstantNonDynamic() in d:\j\workspace\roslyn_prtest_win_dbg_unit32\src\ExpressionEvaluator\CSharp\Test\ExpressionCompiler\DynamicTests.cs:line 470
</Description>
        <CreatedDate>17/11/2015</CreatedDate>
        <ClosedDate>19/12/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>7600</PullRequestID>
        <IssueID>6651</IssueID>
        <Title>Constants test in the BasicExpressionCompilerTest.LocalsTests occasionally fails with OverflowException</Title>
        <Description>Likely due to a DSR issue. see http://dotnet-ci.cloudapp.net/job/roslyn_master_win_dbg_unit32/297/testReport/Microsoft.CodeAnalysis.VisualBasic.UnitTests/LocalsTests/Constants/ for an example
</Description>
        <CreatedDate>09/11/2015</CreatedDate>
        <ClosedDate>19/12/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>7600</PullRequestID>
      <File>src/Debugging/Microsoft.DiaSymReader.PortablePdb.Tests/TestHelpers/SymTestHelpers.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Test/ExpressionCompiler/DynamicTests.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Test/ExpressionCompiler/ExpressionCompilerTestBase.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Test/ExpressionCompiler/ExpressionCompilerTests.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Test/ExpressionCompiler/HoistedThisTests.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Test/ExpressionCompiler/LocalsTests.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Test/ExpressionCompiler/MissingAssemblyTests.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Test/ExpressionCompiler/NoPIATests.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Test/ExpressionCompiler/PseudoVariableTests.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Test/ExpressionCompiler/ReferencedModulesTests.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Test/ExpressionCompiler/ResultPropertiesTests.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Test/ExpressionCompiler/UsingDebugInfoTests.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Test/ExpressionCompiler/WinMdTests.cs</File>
      <File>src/Test/PdbUtilities/Pdb/PdbToXml.cs</File>
      <File>src/Test/PdbUtilities/Pdb/SymReader.cs</File>
      <File>src/Test/PdbUtilities/Pdb/SymReaderFactory.cs</File>
      <File>src/Test/PdbUtilities/Shared/DummyMetadataImport.cs</File>
      <File>src/Test/PdbUtilities/Shared/SymUnmanagedReaderExtensions.cs</File>
      <File>src/Test/Utilities/Desktop/CommonTestBase.CompilationVerifier.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>7526</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Allow analyzers to configure generated code analysis</Title>
    <Description>1. Add a new API: `AnalysisContext.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags analysisMode)`:
   Configures analyzer callbacks + diagnostic reporting for the analyzer. Recommended for analyzer authors to always invoke this API.
2. Analyzer driver uses a heuristic to identify generated code:
   1. Symbols marked with GeneratedCodeAttribute.
   2. Files with specific extensions (see [here](http://source.roslyn.io/Microsoft.CodeAnalysis.Workspaces/R/ef3599fb042e3706.html)).
   3. Files which have a single line comment starting with &lt;auto-generated&gt; at the beginning of a source file.
3. Driver defaults for non-configured analyzers:
   1. Run analysis on generated code: This avoids semantic breaks for analyzers and will be guaranteed to be always enabled in future.
   2. Report all diagnostics on generated code: This will likely be changed to perform some level of default filtering after #3705 is implemented.

Fixes #6998
</Description>
    <CreatedDate>16/12/2015</CreatedDate>
    <ClosedDate>23/12/2015</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>7526</PullRequestID>
        <IssueID>3705</IssueID>
        <Title>Exclude files or folder from running through the analyzers through a configuration file.</Title>
        <Description>Hi,

we have a lot of generated files that trigger warnings, errors when analyzers run them.
since the file name of the generated files do not follow the common naming conventions for generated code roslyn fires the analyzers away. As a result there are ten of thousands of warnings in the solution.
Could we get a exclude file from analyzing logic that:
- Exclude a file by adding it to a exclusion list
- Exclude a file by adding it to a exclusion list
- Annotate classes with a special Attribute that exclude the class
- exclude certain file name extensions ( like js files generated by typescript)
- Combination of the above like exclude all js files that live under the folder x including all sub folders

Most of the rules come straight from Resharper's exclusion file manager

Thanks
</Description>
        <CreatedDate>26/06/2015</CreatedDate>
        <ClosedDate>20/12/2019</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>7526</PullRequestID>
        <IssueID>6998</IssueID>
        <Title>Analyzers must be able to specify that they report issues in generated code</Title>
        <Description>The proposal is to add an optional property to `DiagnosticDescriptor` called IsReportedOnGeneratedCode which would be false by default. The definition of generated code will be some set of heuristics for now #3705 is about adding some configuration file that can specify what constitutes generated code.

This workitem is about implementing the support in the engine with these heuristics:
- The set of heuristics defined in `IGeneratedRecognitionService`
- @DustinCampbell's heuristic to identify the auto-generated comment from syntax trees.
- The `GeneratedCodeAttribute` that FxCop used to have. #1751.
</Description>
        <CreatedDate>24/11/2015</CreatedDate>
        <ClosedDate>23/12/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>7526</PullRequestID>
      <File>src/Compilers/CSharp/Portable/Compilation/CSharpCompilation.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Diagnostics/DiagnosticAnalyzerTests.cs</File>
      <File>src/Compilers/Core/Portable/DiagnosticAnalyzer/AnalysisState.cs</File>
      <File>src/Compilers/Core/Portable/DiagnosticAnalyzer/AnalyzerDriver.GeneratedCodeUtilities.cs</File>
      <File>src/Compilers/Core/Portable/DiagnosticAnalyzer/AnalyzerDriver.cs</File>
      <File>src/Compilers/Core/Portable/DiagnosticAnalyzer/AnalyzerExecutor.cs</File>
      <File>src/Compilers/Core/Portable/DiagnosticAnalyzer/AnalyzerManager.cs</File>
      <File>src/Compilers/Core/Portable/DiagnosticAnalyzer/DiagnosticAnalysisContext.cs</File>
      <File>src/Compilers/Core/Portable/DiagnosticAnalyzer/DiagnosticQueue.cs</File>
      <File>src/Compilers/Core/Portable/DiagnosticAnalyzer/DiagnosticStartAnalysisScope.cs</File>
      <File>src/Compilers/Core/Portable/FileSystem/PathUtilities.cs</File>
      <File>src/Compilers/Core/Portable/InternalUtilities/FileNameUtilities.cs</File>
      <File>src/Compilers/Core/Portable/Syntax/SyntaxTreeExtensions.cs</File>
      <File>src/Test/Utilities/Desktop/CommonDiagnosticAnalyzers.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>6458</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Inherit references from previous submissions</Title>
    <Description>Moves the logic of reusing metadata references from Script down to ReferenceManager. This is necessary to avoid duplication of PE assembly symbols due to repeatedly resolved missing references. 

The metadata resolver creates a new reference whenever asked to resolve a missing assembly identity. That results in creating new PE assembly symbol. We could implement deduplication in the resolver. However the lifetime of the resolver isn't necessarily related to the lifetime of the interactive session. hence it is better to implement it in the ReferenceManager. This work item was previously suggested for U1 but postponed for U2 (#5301) since the thinking was that it only affects performance. However, as described in #6457 it is critical for correctness of basic scenarios in csi and Hosting APIs, which don't use shadow copying.

Also fixes #6474.
</Description>
    <CreatedDate>30/10/2015</CreatedDate>
    <ClosedDate>02/11/2015</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>6458</PullRequestID>
        <IssueID>5301</IssueID>
        <Title>Submission references should be inherited from previous submissions</Title>
        <Description>
        </Description>
        <CreatedDate>17/09/2015</CreatedDate>
        <ClosedDate>03/11/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>6458</PullRequestID>
        <IssueID>6457</IssueID>
        <Title>REPL reports error CS0029: Cannot implicitly convert type T to T in common cases</Title>
        <Description>Consider source compiled into a library a.dll:

```
public class C
{
    public System.Diagnostics.Process P;
}
```

and session:

``` C#
&gt;  #r "a.dll"
&gt; C c;
&gt; c = new C();
(1,6): error CS0029: Cannot implicitly convert type 'C [a.dll]' to 'C [a, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null]'
```

The problem is that we resolved a missing reference to System.Configuration.dll (thru System.dll) reference twice and constructed two PE symbols for it. That caused other PE assembly symbols to not be reused ultimately resulting in creating two PE type symbols for the same class C.
</Description>
        <CreatedDate>30/10/2015</CreatedDate>
        <ClosedDate>03/11/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>6458</PullRequestID>
        <IssueID>6474</IssueID>
        <Title>Reuse already loaded assemblies if they are identical</Title>
        <Description>Scenario:
Solution with 3 projects that don't build into a common directory but rather each builds into their own:

```
Shared\bin\debug\Shared.dll
Lib1\bin\debug\Lib1.dll 
               Shared.dll (copy)
Lib2\bin\debug\Lib2.dll
               Shared.dll (copy)
```

Now in a REPL:

``` C#
&gt; #r "Lib1\bin\debug\Lib1.dll" 
&gt; Lib1 l1 = new Lib1();  // loads Lib1 and Shared from Lib1\bin\debug dir
&gt; #r "Lib2\bin\debug\Lib2.dll" 
&gt; Lib2 l2 = new Lib2();   // loads Lib1 and Shared from Lib2\bin\debug dir
&gt; l2.libBase
Field not found: 'Lib2.libBase'.
  + System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[TResult].Start(TStateMachine&amp; stateMachine)
```

The problem is that we load Shared twice at runtime because it's in a different directory. The compiler correctly dedups it since both copies have the same identity. The loader should check whether the assemblies are the same. If they are then we can reuse the existing one. Otherwise we should report an error.
</Description>
        <CreatedDate>30/10/2015</CreatedDate>
        <ClosedDate>03/11/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>6458</PullRequestID>
      <File>src/Compilers/CSharp/Portable/Symbols/ReferenceManager.cs</File>
      <File>src/Compilers/CSharp/Test/CommandLine/CommandLineScriptTests.cs</File>
      <File>src/Compilers/Core/Portable/CorLightup.cs</File>
      <File>src/Compilers/Core/Portable/ReferenceManager/CommonReferenceManager.Binding.cs</File>
      <File>src/Compilers/Core/Portable/ReferenceManager/CommonReferenceManager.Resolution.cs</File>
      <File>src/Compilers/Core/Portable/ReferenceManager/CommonReferenceManager.State.cs</File>
      <File>src/Interactive/EditorFeatures/Core/Extensibility/Interactive/InteractiveEvaluator.cs</File>
      <File>src/Interactive/Features/Interactive/Core/InteractiveHost.Service.cs</File>
      <File>src/Interactive/HostTest/InteractiveHostTests.cs</File>
      <File>src/Scripting/CSharpTest.Desktop/InteractiveSessionTests.cs</File>
      <File>src/Scripting/CSharpTest/CommandLineRunnerTests.cs</File>
      <File>src/Scripting/CSharpTest/InteractiveSessionTests.cs</File>
      <File>src/Scripting/Core/Hosting/AssemblyLoader/InteractiveAssemblyLoader.cs</File>
      <File>src/Scripting/Core/Hosting/AssemblyLoader/InteractiveAssemblyLoaderException.cs</File>
      <File>src/Scripting/Core/Hosting/CommandLine/CommandLineRunner.cs</File>
      <File>src/Scripting/Core/Hosting/Resolvers/RuntimeMetadataReferenceResolver.cs</File>
      <File>src/Scripting/Core/Script.cs</File>
      <File>src/Scripting/Core/ScriptBuilder.cs</File>
      <File>src/Scripting/CoreTest/TestCompilationFactory.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>6432</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Add expansion rule to add cast to lambda expression bodies</Title>
    <Description>Fixes #6306
Fixes #6308

This change also fixes two outstanding (though not yet reported) bugs in the expansion engine:
- Generic type arguments should _not_ be addded to a name if they contain anonymous types
- A lambda parameter should not be expanded if its type is an anonymous type

Tagging @dotnet/roslyn-ide 
</Description>
    <CreatedDate>29/10/2015</CreatedDate>
    <ClosedDate>07/11/2015</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>6432</PullRequestID>
        <IssueID>6306</IssueID>
        <Title>Rename doesn't resolve conflicts by value of uncastable lambda</Title>
        <Description>``` C#
void X&lt;T&gt;(T t, Func&lt;T, long&gt; e) { X(new { a = 1 }, a =&gt; a.a); }
[Obsolete]
void Y&lt;T&gt;(T t, Func&lt;T, int&gt; e) { }
```

Rename `Y` to `X`.

&lt;strike&gt;
**Expected**:

``` C#
X(new { a = (long)1 }, a =&gt; a.a);
```

&lt;/strike&gt;

**Expected**:

``` C#
X(new { a = 1 }, a =&gt; (long)a.a);
```
</Description>
        <CreatedDate>25/10/2015</CreatedDate>
        <ClosedDate>07/11/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>6432</PullRequestID>
        <IssueID>6308</IssueID>
        <Title>Rename doesn't resolve conflicts by inserting identity conversion</Title>
        <Description>``` C#
[Obsolete]
void M&lt;T&gt;(T t, Func&lt;T,int, int&gt; e) { }
int M&lt;T&gt;(T t, Func&lt;T, long, long&gt; e) =&gt; M(new { }, (_, a) =&gt; X(a));

long X(long a) =&gt; a;
int Y(int a) =&gt; a;
```

Rename `Y` to `X`.

**Expected**:

``` C#
M(new { }, (_, a) =&gt; X((long)a));
```
</Description>
        <CreatedDate>25/10/2015</CreatedDate>
        <ClosedDate>07/11/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>6432</PullRequestID>
      <File>src/Features/CSharp/Portable/CodeRefactorings/InlineTemporary/InlineTemporaryCodeRefactoringProvider.cs</File>
      <File>src/Workspaces/CSharp/Portable/Extensions/ExpressionSyntaxExtensions.cs</File>
      <File>src/Workspaces/CSharp/Portable/Simplification/CSharpSimplificationService.Expander.cs</File>
      <File>src/Workspaces/Core/Portable/Simplification/SimplificationHelpers.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>6386</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Update MS.DSR.N and SRM to RTM versions</Title>
    <Description>Fixes #6010, #4398 and #5813.
</Description>
    <CreatedDate>28/10/2015</CreatedDate>
    <ClosedDate>28/10/2015</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>6386</PullRequestID>
        <IssueID>6010</IssueID>
        <Title>[ask mode] Update Roslyn to use Microsoft.DiaSymReader.Native 1.3.0</Title>
        <Description>Currently we use 1.2.0-rc, which doesn't support deterministic PDB ID. The new version should be available by the EOW -- we are waiting for the C++ team to deliver it.
</Description>
        <CreatedDate>15/10/2015</CreatedDate>
        <ClosedDate>28/10/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>6386</PullRequestID>
        <IssueID>4398</IssueID>
        <Title>System.Reflection.Metadata dependency is 'PreRelease'</Title>
        <Description>Our current System.Reflect.Metadata dependency is considered 'PreRelease'. This will need to be updated to a 'Release' version before v1.1 can be released.

Once this issue has been resolved, Setup.proj needs to have Release packaging re-enabled.
</Description>
        <CreatedDate>07/08/2015</CreatedDate>
        <ClosedDate>28/10/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>6386</PullRequestID>
        <IssueID>5813</IssueID>
        <Title>Re-Enable 5 Failing Emit tests</Title>
        <Description>These five tests need to be fixed and re-enabled

```
Microsoft.CodeAnalysis.VisualBasic.UnitTests.Emit.DeterministicTests.CompareAllBytesEmitted_Debug
Microsoft.CodeAnalysis.VisualBasic.UnitTests.Emit.DeterministicTests.CompareAllBytesEmitted_Release
Microsoft.CodeAnalysis.CSharp.UnitTests.Emit.DeterministicTests.Simple 
Microsoft.CodeAnalysis.CSharp.UnitTests.Emit.DeterministicTests.CompareAllBytesEmitted_Debug
Microsoft.CodeAnalysis.CSharp.UnitTests.Emit.DeterministicTests.CompareAllBytesEmitted_Release
```
</Description>
        <CreatedDate>09/10/2015</CreatedDate>
        <ClosedDate>28/10/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>6386</PullRequestID>
      <File>src/Compilers/CSharp/Test/Emit/Emit/DeterministicTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>6294</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Log low VM telemetry at most once per session</Title>
    <Description>Fixes #6279 

Supersedes #6281 

@Pilchie @heejaechang 
</Description>
    <CreatedDate>24/10/2015</CreatedDate>
    <ClosedDate>27/10/2015</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>6294</PullRequestID>
        <IssueID>6279</IssueID>
        <Title>make vb/ide/vbcs/virtualmemory/lowmemory fire only once when we get into low memory situation.</Title>
        <Description>currently we fire it every time it is raised even if we are already in that mode.
</Description>
        <CreatedDate>23/10/2015</CreatedDate>
        <ClosedDate>29/10/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>6294</PullRequestID>
        <IssueID>6281</IssueID>
        <Title>Log low VM telemetry at most once per session</Title>
        <Description>Fixes #6279 

@heejaechang @Pilchie 

This is the simplest fix for Update 1.

Note: The shell will keep broadcasting VSM_VIRTUALMEMORYLOW/CRITICAL once a minute while the low VM situation persists. There is no corresponding message indicating "VM is back to normal".

Another approach might be to do some rate limiting on the telemetry. i.e. note the time of the last notification and log telemetry only if it's been more than some interval (say 30 minutes or an hour). Thoughts?
</Description>
        <CreatedDate>23/10/2015</CreatedDate>
        <ClosedDate>24/10/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>6294</PullRequestID>
      <File>src/VisualStudio/Core/Def/Implementation/VirtualMemoryNotificationListener.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>6254</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Handle in-memory assemblies correctly in ScriptOptions.AddReference and when adding reference to the host object</Title>
    <Description>Throw NotSupportedException when a reference to an assembly without a location is added to script.
Don't try to implicitly add a reference to host assembly if it is an in-memory assembly.

Fixes #2246 

(originally PR #6246)
</Description>
    <CreatedDate>22/10/2015</CreatedDate>
    <ClosedDate>23/10/2015</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>6254</PullRequestID>
        <IssueID>2246</IssueID>
        <Title>Can't use object from a dynamic assembly as global object for script</Title>
        <Description>To reproduce, create a dynamic assembly using Roslyn:

```
SyntaxTree syntaxTree = CSharpSyntaxTree.ParseText(@"
    public class MyGlobals
    {
        ...
    }
");
CSharpCompilation compilation = CSharpCompilation.Create("DynamicAssembly")
    .WithOptions(new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary))
    .AddSyntaxTrees(syntaxTree)
    .AddReferences(...);
byte[] assemblyBytes;
using (MemoryStream ms = new MemoryStream())
{
    compilation.Emit(ms);
    assemblyBytes = ms.ToArray();
}
Assembly assembly = Assembly.Load(assemblyBytes);
Type globalsType = assembly.GetType("MyGlobals");
object globals = Activator.CreateInstance(globalsType);
```

Then try and use the dynamic globals object in a script:

```
ScriptOptions options = new ScriptOptions()
    .AddNamespaces(...)
    .AddReferences(...);
CSharpScript.Eval(@"...", options, globals);
```

It throws an exception `System.ArgumentException : Empty path name is not legal.`. This is the same exception you see if you attempt to call `MetadataReference.CreateFromAssembly()` with a dynamic assembly. Since dynamic assemblies don't have a `Location`, the following call in `MetadataReference.cs" fails:

```
string location = AssemblyLocationLightUp.GetAssemblyLocation(assembly);
Stream peStream = FileStreamLightUp.OpenFileStream(location);
```

Normally I get around this in a compilation by creating my `MetadataReference` from a `Stream`:

```
MetadataReference dynamicReference;
using (MemoryStream ms = new MemoryStream(assemblyBytes))
{
    dynamicReference = MetadataReference.CreateFromStream(ms);
}
```

However, this doesn't work for script globals because of the following line in `Core\Script.cs` (https://github.com/dotnet/roslyn/blob/master/src/Scripting/Core/Script.cs#L375):

```
var globalsTypeAssembly = MetadataReference.CreateFromAssembly(this.GlobalsType.Assembly);
```

**TL;DR: A script always tries to use `MetadataReference.CreateFromAssembly()` to get the assembly metadata for the global object, and that approach doesn't work for global objects defined in dynamic assemblies.**

Not sure what a good fix would be. Perhaps allowing the specification of a `MetadataReference` for the global object to be used? Or checking the provided assembly references for one that contains the global object _before_ attempting to get one? Alternatively, any fix for dynamic assemblies causing an exception with `MetadataReference.CreateFromAssembly()` would also resolve this more specific, but related issue.
</Description>
        <CreatedDate>24/04/2015</CreatedDate>
        <ClosedDate>23/10/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>6254</PullRequestID>
        <IssueID>6246</IssueID>
        <Title>Handle in-memory assemblies correctly in ScriptOptions.AddReference and when adding reference to the host object</Title>
        <Description>Throw NotSupportedException when a reference to an assembly without a location is added to script.
Don't try to implicitly add a reference to host assembly if it is an in-memory assembly.

Fixes https://github.com/dotnet/roslyn/issues/2246
</Description>
        <CreatedDate>22/10/2015</CreatedDate>
        <ClosedDate>23/10/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>6254</PullRequestID>
      <File>src/Compilers/Core/CodeAnalysisTest/MetadataReferences/MetadataReferenceTests.cs</File>
      <File>src/Compilers/Core/Portable/CodeAnalysisResources.Designer.cs</File>
      <File>src/Compilers/Core/Portable/MetadataReference/MetadataReference.cs</File>
      <File>src/Scripting/CSharpTest.Desktop/InteractiveSessionTests.cs</File>
      <File>src/Scripting/Core/Script.cs</File>
      <File>src/Scripting/Core/ScriptOptions.cs</File>
      <File>src/Scripting/CoreTest/TestCompilationFactory.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>6230</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Port commit from PR #6194 to stabilization branch</Title>
    <Description>Explicitly invoke diagnostic re-analysis whenever any bulk suppression fix is invoked from the error list or solution explorer.

Ported from #6194 - Already [approved](https://github.com/dotnet/roslyn/pull/6194#issuecomment-150046678) for 1.1 by MattGe.

Fixes #6007
</Description>
    <CreatedDate>21/10/2015</CreatedDate>
    <ClosedDate>22/10/2015</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>6230</PullRequestID>
        <IssueID>6194</IssueID>
        <Title>Explicitly invoke diagnostic re-analysis whenever any bulk suppressio‚Ä¶</Title>
        <Description>‚Ä¶n fix is invoked from the error list or solution explorer.

**User Scenario:** User installs an analyzer with syntax diagnostics (e.g. CodeCracker), and bulk suppresses the syntax diagnostics from the error list or using the solution explorer "Suppress active issues" command. The code fix correctly adds suppressions to the global suppressions file, but the error list entries never get cleared. Even doing a rebuild doesn't clear the error list.

**Reason:** Our IDE diagnostic service assumes that syntax diagnostics only depend on text version of the document. Adding a global suppression to other file invalidates this assumption. We cannot run all syntax analyzers on every single edit, that would cause perf problems.

**Fix:** We explicitly invoke diagnostic re-analysis whenever any bulk suppression fix is invoked from the error list or solution explorer. This ensures that the error list gets refreshed.

**Testing:** Verified that syntax diagnostics are correctly removed from the error list for bulk suppression scenarios.

**Fixes #6007**
</Description>
        <CreatedDate>20/10/2015</CreatedDate>
        <ClosedDate>21/10/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>6230</PullRequestID>
        <IssueID>6007</IssueID>
        <Title>Syntax analysis is not re-executed in the IDE diagnostic service on adding global suppressions</Title>
        <Description>1. Create a new C# class library with below code:
   
   ``` C#
   class Class1
   {
       // Comment with trailing whitespaces     
   }
   ```
2. Install [codecracker](http://www.nuget.org/packages/codecracker/1.0.0-rc3) analyzer nuget package (check "Include prerelease" checkbox in Nuget package manager).
3. Change rule _"CC0065 (Remove trailing whitespace)"_ to be a warning from the ruleset editor.
4. Build project and see CC0065 diagnostic:
   
   ```
   Severity    Code    Description Project File    Line    Suppression State
   Warning CC0065  Remove trailing whitespace  ClassLibrary14  c:\users\mavasani\documents\visual studio 2015\Projects\ClassLibrary14\ClassLibrary14\Class1.cs 3   
   
   ```
5. From the lightbulb menu select "Suppress CC0065" -&gt; "In Suppression File" and hit enter
6. Verify suppression added to GlobalSuppressions.cs
   
   **Expected:** Diagnostic is suppressed in the error list + squiggle disappears.
   **Actual:** Diagnostic is retained in the error list and squiggle also doesn't go away. If you rebuild the project, the output window doesn't show the original diagnostic (though it shows 2 more instances of CC0065 in the newly added GlobalSuppressions file), but the error list still shows the origin CC0065 intellisense diagnostic.
7. Edit Class1.cs at an unrelated location - say hit enter at the end of the last line of the source file.
   You will now see the expected behavior, and the diagnostic and squiggle disappear.

**Details:** The reason for this bug is that CC0065 is a syntax diagnostic (syntax tree analyzer action), and our IDE diagnostic service assumes that syntax diagnostics only depend on text version of the document. Adding a global suppression to other file invalidates this assumption. We cannot run all syntax analyzers on every single edit, that would cause perf problems - we need to figure out how to implement this reasonably.
</Description>
        <CreatedDate>15/10/2015</CreatedDate>
        <ClosedDate>21/10/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>6230</PullRequestID>
      <File>src/VisualStudio/Core/Def/Implementation/TableDataSource/Suppression/VisualStudioSuppressionFixService.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>5123</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Disable snippets in the Interactive window</Title>
    <Description>...for v1.  Filed #5107 to revive them.

(There are fewer VB tests since VB doesn't have SurroundWith and
Interactive window completion is NYI.)

Bonus: Improve consistency between `ExecuteCommand` and
`GetCommandState` in snippet handler (part of #4993).
</Description>
    <CreatedDate>10/09/2015</CreatedDate>
    <ClosedDate>11/09/2015</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>5123</PullRequestID>
        <IssueID>5107</IssueID>
        <Title>Enable snippets in the Interactive window</Title>
        <Description>
        </Description>
        <CreatedDate>09/09/2015</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>5123</PullRequestID>
        <IssueID>4993</IssueID>
        <Title>In ICommandHandler&lt;T&gt; implementations ExecuteCommand should respect GetCommandState</Title>
        <Description>For example, in `RenameCommandHandler`, which implements `ICommandHandler&lt;RenameCommandArgs&gt;`, `GetCommandState` will delegate to the next handler if `IDocumentSupportsSuggestionService.SupportsRename` returns `false`, but `ExecuteCommand` doesn't consider `SupportsRename`.  As a result, the command will be executed even if it is a subsequent handler that indicates the command is available.

In general, `GetCommandState` will either indicate availability, indicate lack of availability or delegate to the next handler.  `ExecuteCommand` should only do work in the first case - it should never be called in the second and it should delegate in the third.
</Description>
        <CreatedDate>03/09/2015</CreatedDate>
        <ClosedDate>27/04/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>5123</PullRequestID>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/Completion/Model.cs</File>
      <File>src/Features/CSharp/Portable/Completion/CompletionProviders/SnippetCompletionProvider.cs</File>
      <File>src/Interactive/EditorFeatures/Core/Implementation/Interactive/InteractiveWorkspace.cs</File>
      <File>src/VisualStudio/CSharp/Impl/Snippets/SnippetCommandHandler.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Snippets/AbstractSnippetCommandHandler.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>5014</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Fixes a subtle bug in branch optimizer.</Title>
    <Description>"branch over branch" optimization eliminates chains of trivial basic blocks from the graph, which is correct as long as trivial blocks are not reachable individually from outside via branches.
The "same as next" optimization can make a block trivial and if it was targeted by a branch, break the assumption, leading to a rare situation of some branches having stale offsets.

The fix makes sure if a block becomes trivial, its labels are moved to the next nontrivial block.

Fixes #4838
Fixes #4839
</Description>
    <CreatedDate>04/09/2015</CreatedDate>
    <ClosedDate>05/09/2015</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>5014</PullRequestID>
        <IssueID>4838</IssueID>
        <Title>Incorrect compiler output for code involving async, loop, switch.</Title>
        <Description>I've spotted an issue with compilation output from VS 2015 Enterprise (RTM version).

The following code involving async, loop and switch constructs causes  `ArgumentOutOfRangeException` from `default:` branch when run, whereas a return from `case 0:` is expected. Apparently the compiler generates code without `case 0:` branch.

**Code**

```
using System;
using System.Threading.Tasks;

namespace ConsoleApplication11
{
    class Program
    {
        static void Main()
        {
            M(0).Wait();
        }

        static async Task M(int input)
        {
            for (;;)
            {
                var value = await Task.FromResult(input);
                switch (value)
                {
                    case 0:
                        return;
                    case 3:
                        return;
                    case 4:
                        continue;
                    case 100:
                        return;
                    default:
                        throw new ArgumentOutOfRangeException("Unknown value: " + value);
                }
            }
        }
    }
}
```

**Compile with optimizations**

```
D:\dev\bugs&gt;"c:\Program Files (x86)\MSBuild\14.0\Bin\csc.exe" Program1.cs /o+
Microsoft (R) Visual C# Compiler version 1.0.0.50618
Copyright (C) Microsoft Corporation. All rights reserved.
```

**Output**

```

Unhandled Exception: System.AggregateException: One or more errors occurred. ---&gt; System.ArgumentOutOfRangeException: Specified argument was out of the range of valid values.
Parameter name: Unknown value: 0
   at ConsoleApplication11.Program.&lt;M&gt;d__1.MoveNext()
   --- End of inner exception stack trace ---
   at System.Threading.Tasks.Task.ThrowIfExceptional(Boolean includeTaskCanceledExceptions)
   at System.Threading.Tasks.Task.Wait(Int32 millisecondsTimeout, CancellationToken cancellationToken)
   at ConsoleApplication11.Program.Main()
```
</Description>
        <CreatedDate>27/08/2015</CreatedDate>
        <ClosedDate>05/09/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>5014</PullRequestID>
        <IssueID>4839</IssueID>
        <Title>Invalid compilation output for code involving async and switch</Title>
        <Description>I've spotted an issue with compilation output from VS 2015 Enterprise (RTM version).

The compiler generates invalid IL for the following code involving async and switch constructs.

**Code**

```
using System;
using System.Threading.Tasks;

namespace ConsoleApplication11
{
    class Program
    {
        static void Main()
        {
            M(0).Wait();
        }

        static async Task M(int input)
        {
            var value = await Task.FromResult(input);
            switch (value)
            {
                case 0:
                    return;
                case 1:
                    return;
            }
        }
    }
}
```

**Compile with optimizations**

```
D:\dev\bugs&gt;"c:\Program Files (x86)\MSBuild\14.0\Bin\csc.exe" Program2.cs /o+
Microsoft (R) Visual C# Compiler version 1.0.0.50618
Copyright (C) Microsoft Corporation. All rights reserved.
```

**Output**

```
Unhandled Exception: System.InvalidProgramException: Common Language Runtime detected an invalid program.
   at ConsoleApplication11.Program.&lt;M&gt;d__1.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[TStateMachine](TStateMachine&amp; stateMachine)
   at ConsoleApplication11.Program.M(Int32 input)
   at ConsoleApplication11.Program.Main()
```
</Description>
        <CreatedDate>27/08/2015</CreatedDate>
        <ClosedDate>05/09/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>5014</PullRequestID>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenAsyncTests.cs</File>
      <File>src/Compilers/Core/Portable/CodeGen/BasicBlock.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>4979</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Making stack scheduling optimizations more robust and fixing #4828</Title>
    <Description>Stack scheduler performs two kinds of transformations -
1) it turns local slots into ephemeral locals that live on the evaluation stack.
2) It also tries to Dup previous expressions when the next one is exactly the same and other condittions allow.

The operation # 2 is basically a workaround for cases like

   temp = ...
   result = temp + temp;

Since ephemeral locals are modeled as occupying the space "below" the eval values, having temp on eval stack prevents that same temp from loading as a stack local.
The self-interference situations like above are fairly common, so the stack scheduler tries to reduce some of the cases by attempting a peephole optimization where value of previous expression could be Dup-ed if the following one is the same. (thus in our example it would look like the second load of the temp does not happen at all).

This # 2 optimization has numerous conditions where it is not applicable and as bug #4828 shows it is still fairly fragile. It relies on the presence of the value produced by the previous expression and that is not always guaranteed to be there if the expression has no sideeffects.

Instead of adding more conditions, I am removing the # 2 entirely.

It appears that it can be removed without any serious regression in # 1 as long as we track not only the depth of the eval stack but also what we have on it. That way we can detect self-interference cases by just examining our best knowledge of the stack and handle definite self-interference cases as not prohibiting.

The result of this change is that many dups have disappeared from the code, but in most cases they were dups of trivial local/parameter loads and as such are not a concern.
On the other hand most cases where local slots can be optimized away are still there and in some cases we actually are slightly better.

The most important part is that the whole scheduling got simpler and uses fewer assumptions about what emit might do.

Fixes #4828
</Description>
    <CreatedDate>03/09/2015</CreatedDate>
    <ClosedDate>05/09/2015</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>4979</PullRequestID>
        <IssueID>4828</IssueID>
        <Title>Compiler emits invalid MSIL</Title>
        <Description>I have a problem with the compiler in VS2015. The following code will crash the application with an InvalidProgramException. (But only if /optimize+ is passed). Is this a bug in the compiler, or am I doing something wrong?

**Compiler command line:**

```
"C:\Program Files (x86)\MSBuild\14.0\bin\csc.exe" /nostdlib+ /reference:C:\Windows\Microsoft.NET\Framework\v2.0.50727\mscorlib.dll  /optimize+ /out:App.exe /target:exe Program.cs
```

**Contents of Program.cs:**

```
namespace App
{
    class Program
    {
        static void Main(string[] args)
        {
            int a = 0;
            int b = a + a / 1;
        }
    }
}
```

**Emitted MSIL of the method that fails:**

```
.method private hidebysig static void  Main(string[] args) cil managed
{
  .entrypoint
  // Code size       7 (0x7)
  .maxstack  8
  IL_0000:  ldc.i4.0
  IL_0001:  pop
  IL_0002:  dup
  IL_0003:  ldc.i4.1
  IL_0004:  div
  IL_0005:  pop
  IL_0006:  ret
} // end of method Program::Main
```

**Exception message:**

```
Unhandled Exception: System.InvalidProgramException: Common Language Runtime detected an invalid program.
   at App.Program.Main(String[] args)
```

**Output from PEVerify.exe:**

```
"C:\Program Files (x86)\Microsoft SDKs\Windows\v10.0A\bin\NETFX 4.6 Tools\PEVerify.exe" /nologo App.exe
[IL]: Error: [C:\Src\OutsideTFS\RslnBug\RslnBug\App\App.exe : App.Program::Main][offset 0x00000002] Stack underflow.
1 Error(s) Verifying App.exe
```
</Description>
        <CreatedDate>27/08/2015</CreatedDate>
        <ClosedDate>05/09/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>4979</PullRequestID>
        <IssueID>4828</IssueID>
        <Title>Compiler emits invalid MSIL</Title>
        <Description>I have a problem with the compiler in VS2015. The following code will crash the application with an InvalidProgramException. (But only if /optimize+ is passed). Is this a bug in the compiler, or am I doing something wrong?

**Compiler command line:**

```
"C:\Program Files (x86)\MSBuild\14.0\bin\csc.exe" /nostdlib+ /reference:C:\Windows\Microsoft.NET\Framework\v2.0.50727\mscorlib.dll  /optimize+ /out:App.exe /target:exe Program.cs
```

**Contents of Program.cs:**

```
namespace App
{
    class Program
    {
        static void Main(string[] args)
        {
            int a = 0;
            int b = a + a / 1;
        }
    }
}
```

**Emitted MSIL of the method that fails:**

```
.method private hidebysig static void  Main(string[] args) cil managed
{
  .entrypoint
  // Code size       7 (0x7)
  .maxstack  8
  IL_0000:  ldc.i4.0
  IL_0001:  pop
  IL_0002:  dup
  IL_0003:  ldc.i4.1
  IL_0004:  div
  IL_0005:  pop
  IL_0006:  ret
} // end of method Program::Main
```

**Exception message:**

```
Unhandled Exception: System.InvalidProgramException: Common Language Runtime detected an invalid program.
   at App.Program.Main(String[] args)
```

**Output from PEVerify.exe:**

```
"C:\Program Files (x86)\Microsoft SDKs\Windows\v10.0A\bin\NETFX 4.6 Tools\PEVerify.exe" /nologo App.exe
[IL]: Error: [C:\Src\OutsideTFS\RslnBug\RslnBug\App\App.exe : App.Program::Main][offset 0x00000002] Stack underflow.
1 Error(s) Verifying App.exe
```
</Description>
        <CreatedDate>27/08/2015</CreatedDate>
        <ClosedDate>05/09/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>4979</PullRequestID>
      <File>src/Compilers/CSharp/Portable/CodeGen/Optimizer.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenAsyncEHTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenClosureLambdaTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenDynamicTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenOperators.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenShortCircuitOperatorTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTryFinally.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/ForLoopsTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/ExtensionMethodTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/GenericConstraintTests.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Test/ExpressionCompiler/AccessibilityTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>4911</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>fixing history to mimic developer command prompt behaviour...</Title>
    <Description>Fixes #4669 
This PR replaces PR #4857 which had merge conflicts that beyond compare was having trouble with. So I replayed the changes in a new branch after getting the latest.

@amcasey  FYI
</Description>
    <CreatedDate>01/09/2015</CreatedDate>
    <ClosedDate>01/09/2015</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>4911</PullRequestID>
        <IssueID>4669</IssueID>
        <Title>History in interactive window should not cycle</Title>
        <Description>It should stop when it reaches 1st item in the history list and user tries to go to previous and similarly when it is at the last item and user tries to go to next. This is the behavior in command window too.
</Description>
        <CreatedDate>20/08/2015</CreatedDate>
        <ClosedDate>01/09/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>4911</PullRequestID>
        <IssueID>4857</IssueID>
        <Title>Makes history navigation stop at top and bottom and and fixes several‚Ä¶</Title>
        <Description>‚Ä¶ history navigation bugs. Fixes #4669 
</Description>
        <CreatedDate>28/08/2015</CreatedDate>
        <ClosedDate>01/09/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>4911</PullRequestID>
      <File>src/InteractiveWindow/Editor/History.cs</File>
      <File>src/InteractiveWindow/Editor/InteractiveWindow_UIThread.cs</File>
      <File>src/InteractiveWindow/EditorTest/InteractiveWindowTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>4882</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Pattern Matching</Title>
    <Description>An implementation of pattern matching as specified in #206. You can follow the progress here. Much of this work will be pulling pieces of the implementation from https://github.com/semihokur/pattern-matching-csharp

Related features possibly to be added at the same time as pattern-matching:
- [x] #5154 expression-based switch ("match")
- [x] #5143 make "throw expression" an expression form
- [ ] #6183 "out var" declarations
- [ ] #188 Completeness checking for "match" and Algebraic Data Types
- [x] #6400 destructuring assignment
- [ ] #206 Record types, #5172 "with" expressions, #5757 Algebraic Data Types

Progress checklist:
- [X] Scoping for variables introduced in patterns (binders)
- [x] `SemanticModel.GetDeclaredSymbol` for pattern variable declarations.
- [X] Simple pattern matching expressions `expression is Type Identifier` in most statements.
- [x] Extend the parser to handle all of the other specified pattern-matching operations.
  - [x] Add tests for the parser, including precedence tests for the edge cases.
  - [ ] Augment `TestResource.AllInOneCSharpCode` to handle all pattern forms.
- [x] Check for feature availability in the parser (error if feature not supported).
- [X] Error pattern matching to a nullable value type
- [x] Implement pattern matching to a type that is an unconstrained type variable (requires a double type test)
- [ ] Implement and test scoping in remaining "odd" contexts (where the scope is not the enclosing statement)
  - [x] pattern matching in ctor-initializers
  - [x] pattern matching in catch filters
  - [x] pattern matching in field initializers
  - [x] pattern matching in expression-bodied methods and properties
  - [x] pattern matching in an expression-bodied lambda
  - [x] pattern matching in an expression-bodied local function
  - [x] pattern matching in attributes and parameter defaults (lookup and error recovery)
  - [x] test these "odd" contexts in `SemanticModel`.
- [ ] Semantics and code-gen for all pattern forms
  - [X] Type ID
  - [x] *
  - [x] 3
    - [X] matching with exact type for integral constants (as a short-term hack)
    - [ ] matching with appropriate integral conversions
  - [x] `var` ID
  - [x] Type { ID is Pattern ... }
  - ~~Type ( Pattern ... )~~ This will be done when Records are integrated.
- [ ] Extend the switch statement to handle patterns
  - [x] Parser
  - [ ] Syntax Tests
  - [x] Binding
  - [ ] Binding (failure cases) tests
  - [x] Flow analysis
  - [x] Lowering
  - [x] Code-gen tests
- ~~Allow declaration of `operator is`~~ This will be done when Records are integrated.
- [x] An expression form for mutli-armed pattern-matching (`match`?)
- [ ] Extend the scope of a pattern variable declared in a catch filter to the catch block.
  - [ ] Test for error on reusing a variable name, and lambda-capturing.
- [ ] Add a decision tree to enable
  - [ ] completeness checking: a mutli-armed pattern-matching expression is required to be complete
  - [ ] subsumption checking: a branch of a switch statement or match expression may not be subsumed by the totality of previous branches
- [ ] Generate efficient code like `switch` does in corresponding situations.
- [ ] Test for name conflicts with locals in enclosing scopes for normal and "odd" contexts.
- [ ] Lots more Tests!

Records will be added in a separate feature branch.
</Description>
    <CreatedDate>29/08/2015</CreatedDate>
    <ClosedDate>01/03/2016</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>4882</PullRequestID>
        <IssueID>206</IssueID>
        <Title>Proposal: Pattern matching and record types</Title>
        <Description>### The spec has been moved

The specs for pattern matching and records have been moved to https://github.com/dotnet/roslyn/blob/features/patterns/docs/features/patterns.md and https://github.com/dotnet/roslyn/blob/features/records/docs/features/records.md

There are new discussion threads at #10153 for pattern-matching and #10154 for records.
</Description>
        <CreatedDate>03/02/2015</CreatedDate>
        <ClosedDate>28/03/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>4882</PullRequestID>
        <IssueID>5154</IssueID>
        <Title>Proposal: expression-based switch ("match") for pattern matching</Title>
        <Description>### The spec has been moved

The spec for the proposed match expression has been moved to https://github.com/dotnet/roslyn/blob/future/docs/features/patterns.md

Below is a snapshot that may be out of date.

---
## Match Expression

A _match-expression_ is added to support `switch`-like semantics for an expression context.

The C# language syntax is augmented with the following syntactic productions:

``` antlr
relational-expression
    : match-expression
    ;
```

We add the _match-expression_ as a new kind of _relational-expression_.

``` antlr
match-expression
    : relational-expression 'switch' match-block
    ;

match-block
    : '(' match-sections ','? ')'
    ;

match-sections
    : match-section
    | match-sections ',' match-section
    ;
```

At least one _match-section_ is required.

``` antlr
match-section
    : 'case' pattern case-guard? ':' expression
    ;

case-guard
    : 'when' expression
    ;
```

The _match-expression_ is not allowed as an _expression-statement_.

The type of the _match-expression_ is the _least common type_ of the expressions appearing to the right of the `:` tokens of the _match section_s.

It is an error if the compiler can prove (using a set of techniques that has not yet been specified) that some _match-section_'s pattern cannot affect the result because some previous pattern will always match.

At runtime, the result of the _match-expression_ is the value of the _expression_ of the first _match-section_ for which the expression on the left-hand-side of the _match-expression_ matches the _match-section_'s pattern, and for which the _case-guard_ of the _match-section_, if present, evaluates to `true`.
</Description>
        <CreatedDate>11/09/2015</CreatedDate>
        <ClosedDate>28/01/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>4882</PullRequestID>
        <IssueID>5143</IssueID>
        <Title>Proposal: Make "throw expression" an expression form</Title>
        <Description>### The spec has been moved

The spec for the proposed throw expression has been moved to https://github.com/dotnet/roslyn/blob/future/docs/features/patterns.md

Below is a snapshot that may be out of date.

---

I propose to extend the set of expression forms to include

&gt; _throw-expression_:
&gt; &amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;`throw` _null-coalescing-expression_
&gt; _null-coalescing-expression_:
&gt; &amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;_throw-expression_

The type rules are as follows:

&gt; A _throw-expression_ has no type.
&gt; A _throw-expression_ is convertible to every type by an implicit conversion.

The flow-analysis rules are as follows:

&gt; For every variable _v_,
&gt; - _v_ is definitely assigned before the _null-coalescing-expression_ of a _throw-expression_ iff it is definitely assigned before the _throw-expression_.
&gt; - _v_ is definitely assigned after _throw-expression_.

A _throw expression_ is allowed in only the following contexts:
- As the second operand of a ternary conditional operator `?:`
- As the third operand of a ternary conditional operator `?:`
- As the second operand of a null coalescing operator `??`
- After the colon of a _match section_ (see #5154)
- As the body of an expression-bodied lambda or method.

---

This proposal is intended to facilitate a move toward expression-oriented programming, adding convenience in a number of scenarios. For example

An expression-bodied method may now throw

``` cs
void M() =&gt; throw new NotImplementedException();
```

A conditional expression may throw on one branch:

``` cs
var foo = term.HasValue ? term.Value.Foo() : throw new ArgumentException("term");
```

I am proposing this to facilitate a proposal (#5154) for an expression form of a pattern-matching switch, where one may want to throw in some branch.

This is related to #59 and #1226.
</Description>
        <CreatedDate>10/09/2015</CreatedDate>
        <ClosedDate>28/01/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>4882</PullRequestID>
        <IssueID>6183</IssueID>
        <Title>Proposal: out var declaration</Title>
        <Description>This feature would allow a variable be declared at the same time that is it passed as an out parameter:

&gt; _argument-value_:
&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;`out` _type_ _identifier_

A variable declared this way is read-only and scoped to the enclosing statement. More specifically, the scope will be the same as for a _pattern-variable_ introduced via pattern-matching.

You should be able to use the contextual keyword `var` for the variable's type, in which case the specification for overload resolution would have to be modified to account for that possibility.
</Description>
        <CreatedDate>20/10/2015</CreatedDate>
        <ClosedDate>13/01/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>4882</PullRequestID>
        <IssueID>188</IssueID>
        <Title>Proposal: Add completeness checking to pattern matching draft specification</Title>
        <Description># Background

As noted in issue #180, many modern programming programs are data-focused, especially distributed applications which tend to store, manipulate, and move sets of data between different storage and computation points. One solution proposed to deal with this issue is a combination of records and pattern matching. Records provide a simple way to declare and structure the data types and pattern matching provides a way to destructure and manipulate the data. 
# Problem

Records provide a great way to represent the data and pattern matching provides a great way to manipulate the data, but there is currently no mechanism in the #180 proposal to ensure that the data and the logic remain in sync. The nature of records and pattern matching is that the data declaration code is often far from the data consumption code. In a distributed system it's even more likely that a single data structure will be consumed and manipulated in various parts of the code base. If the data structure is ever modified, there is currently no mechanism in the draft to alert the programmer that all instances of manipulation logic must be updated.
# Solution

Add completeness checking to certain `switch` statements on certain record types. The core of this proposal is to provide a warning when a `switch` statement does not handle every possible match on a type hierarchy. This proposal features two possible designs for this idea, presented in order of increasingly intrusive modification to the language.
## Design 1

This design actually features no new syntax or semantics beyond that of proposal #180. The suggestion is to create a C# type heirarchy which can be guaranteed 'complete' with existing language features. In this case, complete means that it is not possible for a new subclass of the root member of the type hierarchy, so the compiler can be sure that any and all subclasses of the chosen switching type are visible in the current compilation.

We can construct this type hierarchy in existing C# with the following rules:
1. All subclasses of the root type must be sealed, preventing any subclassing of any existing leaf types in the hierarchy.
2. All constructors of the root type must be private, prevent any subclassing of the root type.
   - As a consequence, all subclasses must be inner classes and thus must be in source in the current compilation

Here's an example of the structure of this type hierarchy:

``` csharp
abstract class C
{
  private C() {}
  public sealed class C_1 : C {}
  public sealed class C_2 : C {}
      ...
  public sealed class C_n : C {}
}
```

This guarantees that `switch`ing on an instance of type `C` which explicitly matches `C_1`...`C_n` has matched against every possible instance of `C`. The only thing which changes about the language specification is a requirement that the compiler produce a warning when not all cases are matched.
## Design 2

There are a few disadvantages to Design 1:
1. The mandated structure is complicated and brittle. Forgetting to mark any of the subclasses as `sealed` or adding any public constructors won't produce a compiler error or warning, but the compiler will now silently skip the completeness check.
2. The structure is verbose -- most of the `sealed` or `private` markers are mostly part of the 'incantation' of completeness and are not directly related to the task at hand.
3. The relevant record instances are all nested classes, so all references require an extra layer of naming indirection.

Design 2 attempts to fix these problems by replacing much of the boiler plate with a new combination of modifiers on a type -- `abstract` + `sealed`. Under Design 2, marking the root type of a hierarchy as `abstract sealed` will cause the structure from Design 1 to be generated by the compiler in lowering. The following example demonstrates what the structure from Design 1 looks like with an `abstract sealed` type:

``` csharp
abstract sealed class C {}
public class C_1 : C {}
public class C_2 : C {}
   ...
public class C_n : C {}
```

In this case, most of the problems with Design 1 are solved, but new semantics are required to be added to the language.
</Description>
        <CreatedDate>31/01/2015</CreatedDate>
        <ClosedDate>21/04/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>4882</PullRequestID>
        <IssueID>6400</IssueID>
        <Title>Proposal: Destructuring (assignment?) statement</Title>
        <Description>### The spec has been moved

The spec for the proposed `let` statement has been moved to https://github.com/dotnet/roslyn/blob/future/docs/features/patterns.md

Below is a snapshot that may be out of date.

---

Inspired by an [F# feature](https://msdn.microsoft.com/en-us/library/dd233238.aspx) and a [conversation on github](https://github.com/dotnet/roslyn/issues/5154#issuecomment-151974994), we could support decomposition like this:

``` antlr
block-statement
    : let-statement
    ;

let-statement
    : 'let' identifier '=' expression ';'
    | 'let' complex-pattern '=' expression ';'
    | 'let' complex-pattern '=' expression 'else' embedded-statement
    ;
```

`let` is an existing contextual keyword.

The form

&gt; `let` _identifier_ `=` _expression_ `;`

is shorthand for 

&gt; `let` `var` _identifier_ `=` _expression_ `;`

(i.e. a _var-pattern_) and is a convenient way for declaring a read-only local variable.

Semantically, it is an error unless precisely one of the following is true
1. the compiler can prove that the expression always matches the pattern; or
2. an `else` clause is present.

If an `else` clause is present, it is an error if the endpoint of its _embedded-statement_ is reachable.

Any pattern variables in the _pattern_ are in scope throughout the enclosing block. They are not definitely assigned before the `else` clause, and are definitely assigned after the _let-statement_. It is an error to use these variables before their point of definition.

A _let-statement_ is a _block-statement_ and not an _embedded-statement_ because its primary purpose is to introduce names into the enclosing scope. It therefore does not introduce a dangling-else ambiguity.
</Description>
        <CreatedDate>28/10/2015</CreatedDate>
        <ClosedDate>28/01/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>4882</PullRequestID>
        <IssueID>206</IssueID>
        <Title>Proposal: Pattern matching and record types</Title>
        <Description>### The spec has been moved

The specs for pattern matching and records have been moved to https://github.com/dotnet/roslyn/blob/features/patterns/docs/features/patterns.md and https://github.com/dotnet/roslyn/blob/features/records/docs/features/records.md

There are new discussion threads at #10153 for pattern-matching and #10154 for records.
</Description>
        <CreatedDate>03/02/2015</CreatedDate>
        <ClosedDate>28/03/2016</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>4882</PullRequestID>
        <IssueID>5172</IssueID>
        <Title>Proposal: "with" expressions for record types</Title>
        <Description>This is a proposed enhancement to the proposal for _records_ in #206.

A new expression form is proposed:

&gt; _primary-expression_:
&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;_with-expression_:
&gt; _with-expression_:
&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;_primary-expression_ `with` `{` _with-initializer-list_ `}`
&gt; _with-initializer-list_:
&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;_with-initializer_
&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;_with-initializer_ `,` _with-initializer-list_
&gt; _with-initializer_:
&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;_identifier_ `=` _expression_

The token `with` is a new context-sensitive keyword.
### Semantics

The _with-expression_ is translated into a primary constructor invocation that copies members from the _primary-expression_ on the left-hand-side into constructor's parameters, but with some of those replaced by values from the initializer list. Because it depends on the presence of a primary constructor, this is only defined for record types (#206).

(This needs to be described in more detail, including specifying that the left-hand-side expression is evaluated once, the constraints on its type, that identifiers in a _with-intiializer_ bind to a property (or field) of that type, and that the correspondence between constructor parameters and properties are used according to the spec for _records_. Similarly it needs to give definite assignment rules, order of evaluation, etc.)
### Example:

``` cs
class Person(string FirstName, string LastName);
...
    Person p = new Person(FirstName: "Neil", LastName: "Gafter");
    Person q = p with { FirstName = "Neal" };
```

The latter is translated into

``` cs
    Person q = new Person(FirstName: "Neal", LastName: p.LastName);
```

To be clear, the `Person` declaration's expansion includes the following:

``` cs
class Person
{
    public string FirstName { get; }
    public string LastName { get; }
    public Person(string FirstName, string LastName)
        { this.FirstName = FirstName; this.LastName = LastName; }
    // as well as other members not relevant to this issue
}
```

Because the semantics of this new expression form require a language-defined mapping between constructor arguments and properties of the type, and a _primary_ constructor, it is only defined for record types as specified in #206. Expanding this construct to other types may be the subject of a separate proposal.
</Description>
        <CreatedDate>11/09/2015</CreatedDate>
        <ClosedDate>27/03/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>4882</PullRequestID>
        <IssueID>5757</IssueID>
        <Title>Notes on Records and Pattern Matching for 2015-10-07 design review</Title>
        <Description>### Records and Pattern Matching (https://github.com/dotnet/roslyn/issues/206)

Prototyped together last year by @semihokur, but that prototype is
based on very out-of-date Roslyn code. We also have some design changes
since that time and we want to separate a pattern-matching prototype from
records/ADTs so we can make independent decisions about whether
and when to include them in the language(s).

First step is to port pattern matching to the latest sources.
In-progress port at https://github.com/dotnet/roslyn/pull/4882
### Spec changes since the 2014 prototype

For pattern matching:
1. Scoping of pattern-introduced variables (with "funny" rule for `if`)
2. Rules for `switch` statement that make it a compatible extension of the existing construct (https://github.com/dotnet/roslyn/issues/4944)
3. An expression form of multi-arm pattern-matching (https://github.com/dotnet/roslyn/issues/5154)
4. A `when` clause added to `switch` cases.

And, for records:
1. No `record` keyword necessary
2. `with` expressions (https://github.com/dotnet/roslyn/issues/5172)
3. Approach for for algebraic data types
### Implementation status of prototype port
1. For pattern matching, checklist at https://github.com/dotnet/roslyn/pull/4882 tracking the progress
2. For records, port not started
### Making the extension of `switch` backward-compatible
- We say that the cases are matched in order, except `default` which is always the last
  resort.
- Integral-typed case labels match any integral-valued control expression with the same value.
- One issue around user-defined conversions to switchable types is
  resolved (https://github.com/dotnet/roslyn/issues/4944). In the draft spec,
  a conversion will be applied on the `case`s, not on the control-expression unilaterally.
  Instead of converting only to `swithable` types, each
  `case` arm will consider any conversions that allow the `case` to be applied.
  Any given conversion would be applied at most once. 

``` cs
Foo foo = ...; // has a conversion to int
switch (foo)
{
    case 1: // uses the converted value
    case Foo(2): // uses the original value
    case 3: // uses the converted value
}
```
- The `goto case` statement is extended to allow any expression as its argument.
### Expression form of multi-arm pattern matching (https://github.com/dotnet/roslyn/issues/5154)

``` cs
var areas =
    from primitive in primitives
    let area = primitive match (
        case Line l: 0
        case Rectangle r: r.Width * r.Height
        case Circle c: Math.PI * c.Radius * c.Radius
        case *: throw new ApplicationException()
    )
    select new { Primitive = primitive, Area = area };
```

There is no `default` here, so cases are handled strictly in order.

I propose the spec require that the compiler "prove" that all cases are handled
in a `match` expression using not-yet-specified rules. Writing those rules
is an open work item, but I imagine it will require the compiler to build
a decision tree and check it for completeness. That will also be needed to
implement checks that no case is subsumed by a previous case, which will
cause a warning (for `switch`) or error (for `match`).
### With-expressions (https://github.com/dotnet/roslyn/issues/5172)

``` cs
class Point(int X, int Y, int Z);
...
    Point p = ...;
    Point q = p with { Y = 2 };
```

The latter is translated into

``` cs
    Point q = new Point(X: p.X, Y: 2, Z: p.Z);
```

We know how to do this for record types (because the language specifies the
mapping between constructor parameters and properties). We're examining how
to extend it to more general types.

To support inheritance, rather than directly using the constructor (as above) the generated code will
invoke a compiler-generated (but user-overridable) factory method.

``` cs
    Point q = p.With(X: p.X, Y: 2, Z: p.Z);
```
### Draft approach for algebraic data types

``` cs
abstract sealed class Expression
{
    class Binary(Operator Operator, Expression Left, Expression Right) : Expression;
    class Constant(int Value) : Expression;
}
```

None of these classes would be permitted to be extended elsewhere.
a `match` expression that handles both `Binary` and `Constant` cases
would not need a `*` (default) case, as the compiler can prove it
is complete.
### Remaining major issues
1. We need to specify the rules for checking
   - If the set of cases in a `match` is complete 
   - If a `case` is subsumed by a previous `case`
2. We need more experience with algebraic data types and active patterns.
3. Can we extend `with` expressions to non-record types?
</Description>
        <CreatedDate>07/10/2015</CreatedDate>
        <ClosedDate>25/04/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>4882</PullRequestID>
      <File>src/Compilers/CSharp/Portable/Binder/Binder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Conversions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Expressions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Initializers.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Operators.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Patterns.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Query.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Statements.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Symbols.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/BlockBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/BuckStopsHereBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/CatchClauseBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/FixedStatementBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/InMethodBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/LocalBinderFactory.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/LocalScopeBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/PatternVariableBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/PatternVariableFinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/Conversions/Conversion.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/Conversions/ConversionKind.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/Conversions/ConversionKindExtensions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/Conversions/Conversions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/Conversions/UserDefinedImplicitConversions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/SwitchBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/SwitchBinder_BindPatternSwitch.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/BoundNodeExtensions.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/BoundStatementExtensions.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/Constructors.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/Expression.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/Statement.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/UnboundLambda.cs</File>
      <File>src/Compilers/CSharp/Portable/CSharpExtensions.cs</File>
      <File>src/Compilers/CSharp/Portable/CSharpParseOptions.cs</File>
      <File>src/Compilers/CSharp/Portable/CSharpResources.Designer.cs</File>
      <File>src/Compilers/CSharp/Portable/CodeGen/EmitConversion.cs</File>
      <File>src/Compilers/CSharp/Portable/CodeGen/EmitExpression.cs</File>
      <File>src/Compilers/CSharp/Portable/CodeGen/EmitStatement.cs</File>
      <File>src/Compilers/CSharp/Portable/CodeGen/Optimizer.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/CSharpSemanticModel.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/MemberSemanticModel.NodeMapBuilder.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/MemberSemanticModel.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/SyntaxTreeSemanticModel.cs</File>
      <File>src/Compilers/CSharp/Portable/Compiler/AnonymousTypeMethodBodySynthesizer.cs</File>
      <File>src/Compilers/CSharp/Portable/Compiler/MethodBodySynthesizer.Lowered.cs</File>
      <File>src/Compilers/CSharp/Portable/Compiler/MethodCompiler.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/ErrorCode.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/MessageID.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/ControlFlowPass.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/DataFlowPass.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/DataFlowsOutWalker.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/PreciseAbstractFlowPass.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/PreciseAbstractFlowPass_Switch.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/VariablesDeclaredWalker.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/AsyncRewriter/AsyncExceptionHandlerRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/AsyncRewriter/AsyncMethodToStateMachineRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/AsyncRewriter/AsyncRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/AsyncRewriter/AwaitExpressionSpiller.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/IteratorRewriter/IteratorMethodToStateMachineRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/IteratorRewriter/IteratorRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_Block.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_Call.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_Conversion.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_FixedStatement.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_IfStatement.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_MatchStatement.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_Patterns.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_SwitchStatement.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/MethodToClassRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/StateMachineRewriter/StateMachineRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/SyntheticBoundNodeFactory.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/LanguageParser.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/LanguageParser_Patterns.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/Lexer.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/SyntaxParser.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/LocalDeclarationKind.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/LocalSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/MemberSymbolExtensions.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceLocalSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/LambdaUtilities.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/LookupPosition.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/SyntaxFacts.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/SyntaxKind.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/SyntaxKindFacts.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/SyntaxNodeExtensions.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Diagnostics/DiagnosticAnalyzerTests.AllInOne.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/ConstantTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/LocalFunctionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/NameOfTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/OperatorTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/SwitchTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/UnsafeTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Compilation/SemanticModelAPITests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/PatternParsingTests.cs</File>
      <File>src/Compilers/Test/Utilities/CSharp/CompilingTestBase.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/DiagnosticAnalyzerDriver/DiagnosticAnalyzerDriverTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/ExtractMethod/ExtractMethodBase.cs</File>
      <File>src/EditorFeatures/CSharpTest/ExtractMethod/ExtractMethodTests.LanguageInteraction.cs</File>
      <File>src/EditorFeatures/CSharpTest/Formatting/Indentation/SmartIndenterEnterOnTokenTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Formatting/Indentation/SmartIndenterTests.cs</File>
      <File>src/EditorFeatures/Test/Workspaces/TestWorkspace_Create.cs</File>
      <File>src/EditorFeatures/Test/Workspaces/TestWorkspace_XmlConsumption.cs</File>
      <File>src/EditorFeatures/Test/Workspaces/TestWorkspace_XmlCreation.cs</File>
      <File>src/Features/CSharp/Portable/CSharpFeaturesResources.Designer.cs</File>
      <File>src/Features/CSharp/Portable/EditAndContinue/CSharpEditAndContinueAnalyzer.cs</File>
      <File>src/Features/CSharp/Portable/ExtractMethod/CSharpSelectionValidator.cs</File>
      <File>src/Test/Utilities/Shared/Diagnostics/TrackingDiagnosticAnalyzer.cs</File>
      <File>src/Workspaces/CSharp/Portable/Extensions/SyntaxNodeExtensions.cs</File>
      <File>src/Workspaces/CSharp/Portable/Formatting/Rules/IndentBlockFormattingRule.cs</File>
      <File>src/Workspaces/CSharp/Portable/Formatting/Rules/SuppressFormattingRule.cs</File>
      <File>src/Workspaces/CSharp/Portable/Formatting/Rules/TokenBasedFormattingRule.cs</File>
      <File>src/Workspaces/CSharpTest/Formatting/FormattingTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>3986</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Make InteractiveWindow states explicit</Title>
    <Description>Instead of having a collection of boolean flags, introduce a State enum
that captures all of the possible states of the window and document
transitions between them.  Furthermore, assert that state transitions only
happen on the UI thread (for synchronization purposes).

Fixes #3970

TODO: The transitions to and from the ReadingStandardInput state are not
well understood/handled (#3984).

TODO: Integration test to follow.

_Note: You'll probably want to review the commits separately - I've tried to isolate the broad refactorings in the second one._
</Description>
    <CreatedDate>17/07/2015</CreatedDate>
    <ClosedDate>23/07/2015</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>3986</PullRequestID>
        <IssueID>3970</IssueID>
        <Title>Interactive window Reset button inserts an extra prompt</Title>
        <Description>Clicking the button prints `&gt; &gt; Reset` to the Interactive window.
</Description>
        <CreatedDate>15/07/2015</CreatedDate>
        <ClosedDate>23/07/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>3986</PullRequestID>
        <IssueID>3984</IssueID>
        <Title>Make StandardInput in InteractiveWindow thread-safe</Title>
        <Description>It can happen at any time and can be cancelled at any time and it's not clear that either operation is handled gracefully.

We'll probably need some info on the API's intended function from @DinoV. 
</Description>
        <CreatedDate>16/07/2015</CreatedDate>
        <ClosedDate>25/08/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>3986</PullRequestID>
      <File>src/InteractiveWindow/Editor/Commands/ResetCommand.cs</File>
      <File>src/InteractiveWindow/Editor/InteractiveWindow.cs</File>
      <File>src/InteractiveWindow/Editor/InteractiveWindowResources.Designer.cs</File>
      <File>src/InteractiveWindow/Editor/InteractiveWindow_UIThread.cs</File>
      <File>src/InteractiveWindow/Editor/Output/OutputBuffer.cs</File>
      <File>src/InteractiveWindow/EditorTest/InteractiveWindowTestHost.cs</File>
      <File>src/InteractiveWindow/EditorTest/InteractiveWindowTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>3811</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>[EnC] Update UnitTests to use resource strings</Title>
    <Description>Fix #1853 and #2657
</Description>
    <CreatedDate>02/07/2015</CreatedDate>
    <ClosedDate>02/07/2015</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>3811</PullRequestID>
        <IssueID>1853</IssueID>
        <Title>Roslyn.Services.Editor.CSharp.UnitTests.dll - 24 unit-test fail on Russian OS with localized resources present</Title>
        <Description>## See #821 for repro steps.

Assemblies Run

Roslyn.Services.Editor.CSharp.UnitTests.dll

Summary

Tests run: 11063   Failures: 24, Skipped: 52, Run time: 424.894s

Failed tests

0.020s
‚úò
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Lambdas_Insert_Catch1 : Actual: Diagnostic(RudeEditKind.InsertLambdaWithMultiScopeCapture, "x1", "!VQ1Yq!lambda –Å–ß!", "x0", "x1") Differences: ++&gt; Diagnostic(RudeEditKind.InsertLambdaWithMultiScopeCapture, "x1", "!VQ1Yq!lambda –Å–ß!", "x0", "x1") --&gt; Diagnostic(RudeEditKind.InsertLambdaWithMultiScopeCapture, "x1", "lambda", "x0", "x1") 
   –≤ Xunit.Assert.True(Boolean condition, String userMessage)
   –≤ Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:—Å—Ç—Ä–æ–∫–∞ 256
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 16
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:—Å—Ç—Ä–æ–∫–∞ 301
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 83
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 72
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 63
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Lambdas_Insert_Catch1() –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:—Å—Ç—Ä–æ–∫–∞ 3002

0.015s
‚úò
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Lambdas_Insert_For1 : Actual: Diagnostic(RudeEditKind.InsertLambdaWithMultiScopeCapture, "x2", "!VQ1Yq!lambda –Å–ß!", "x0", "x2") Differences: ++&gt; Diagnostic(RudeEditKind.InsertLambdaWithMultiScopeCapture, "x2", "!VQ1Yq!lambda –Å–ß!", "x0", "x2") --&gt; Diagnostic(RudeEditKind.InsertLambdaWithMultiScopeCapture, "x2", "lambda", "x0", "x2") 
   –≤ Xunit.Assert.True(Boolean condition, String userMessage)
   –≤ Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:—Å—Ç—Ä–æ–∫–∞ 256
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 16
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:—Å—Ç—Ä–æ–∫–∞ 301
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 83
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 72
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 63
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Lambdas_Insert_For1() –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:—Å—Ç—Ä–æ–∫–∞ 2814

0.007s
‚úò
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Lambdas_Insert_ForEach1 : Actual: Diagnostic(RudeEditKind.InsertLambdaWithMultiScopeCapture, "x1", "!VQ1Yq!lambda –Å–ß!", "x0", "x1") Differences: ++&gt; Diagnostic(RudeEditKind.InsertLambdaWithMultiScopeCapture, "x1", "!VQ1Yq!lambda –Å–ß!", "x0", "x1") --&gt; Diagnostic(RudeEditKind.InsertLambdaWithMultiScopeCapture, "x1", "lambda", "x0", "x1") 
   –≤ Xunit.Assert.True(Boolean condition, String userMessage)
   –≤ Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:—Å—Ç—Ä–æ–∫–∞ 256
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 16
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:—Å—Ç—Ä–æ–∫–∞ 301
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 83
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 72
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 63
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Lambdas_Insert_ForEach1() –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:—Å—Ç—Ä–æ–∫–∞ 2729

0.023s
‚úò
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Lambdas_Insert_ForEach2 : Actual: Diagnostic(RudeEditKind.InsertLambdaWithMultiScopeCapture, "x1", "!VQ1Yq!lambda –Å–ß!", "x0", "x1") Differences: ++&gt; Diagnostic(RudeEditKind.InsertLambdaWithMultiScopeCapture, "x1", "!VQ1Yq!lambda –Å–ß!", "x0", "x1") --&gt; Diagnostic(RudeEditKind.InsertLambdaWithMultiScopeCapture, "x1", "lambda", "x0", "x1") 
   –≤ Xunit.Assert.True(Boolean condition, String userMessage)
   –≤ Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:—Å—Ç—Ä–æ–∫–∞ 256
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 16
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:—Å—Ç—Ä–æ–∫–∞ 301
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 83
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 72
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 63
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Lambdas_Insert_ForEach2() –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:—Å—Ç—Ä–æ–∫–∞ 2768

0.034s
‚úò
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Lambdas_Insert_Switch1 : Actual: Diagnostic(RudeEditKind.InsertLambdaWithMultiScopeCapture, "x0", "!VQ1Yq!lambda –Å–ß!", "x2", "x0") Differences: ++&gt; Diagnostic(RudeEditKind.InsertLambdaWithMultiScopeCapture, "x0", "!VQ1Yq!lambda –Å–ß!", "x2", "x0") --&gt; Diagnostic(RudeEditKind.InsertLambdaWithMultiScopeCapture, "x0", "lambda", "x2", "x0") 
   –≤ Xunit.Assert.True(Boolean condition, String userMessage)
   –≤ Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:—Å—Ç—Ä–æ–∫–∞ 256
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 16
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:—Å—Ç—Ä–æ–∫–∞ 301
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 83
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 72
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 63
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Lambdas_Insert_Switch1() –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:—Å—Ç—Ä–æ–∫–∞ 2888

0.013s
‚úò
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Lambdas_Insert_Using1 : Actual: Diagnostic(RudeEditKind.InsertLambdaWithMultiScopeCapture, "x1", "!VQ1Yq!lambda –Å–ß!", "x0", "x1") Differences: ++&gt; Diagnostic(RudeEditKind.InsertLambdaWithMultiScopeCapture, "x1", "!VQ1Yq!lambda –Å–ß!", "x0", "x1") --&gt; Diagnostic(RudeEditKind.InsertLambdaWithMultiScopeCapture, "x1", "lambda", "x0", "x1") 
   –≤ Xunit.Assert.True(Boolean condition, String userMessage)
   –≤ Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:—Å—Ç—Ä–æ–∫–∞ 256
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 16
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:—Å—Ç—Ä–æ–∫–∞ 301
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 83
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 72
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 63
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Lambdas_Insert_Using1() –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:—Å—Ç—Ä–æ–∫–∞ 2946

0.025s
‚úò
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_AccessingCapturedTransparentIdentifier1 : Actual: Diagnostic(RudeEditKind.ChangingQueryLambdaType, "select", "!PEpxp!select clause –Å–ß!") Differences: ++&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "select", "!PEpxp!select clause –Å–ß!") --&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "select", "select clause") 
   –≤ Xunit.Assert.True(Boolean condition, String userMessage)
   –≤ Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:—Å—Ç—Ä–æ–∫–∞ 256
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 16
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:—Å—Ç—Ä–æ–∫–∞ 301
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 83
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 72
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 63
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_AccessingCapturedTransparentIdentifier1() –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:—Å—Ç—Ä–æ–∫–∞ 5591

0.045s
‚úò
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_AccessingCapturedTransparentIdentifier2 : Actual: Diagnostic(RudeEditKind.AccessingCapturedVariableInLambda, "a", "a", "!PEpxp!select clause –Å–ß!") Differences: ++&gt; Diagnostic(RudeEditKind.AccessingCapturedVariableInLambda, "a", "a", "!PEpxp!select clause –Å–ß!") --&gt; Diagnostic(RudeEditKind.AccessingCapturedVariableInLambda, "a", "a", "select clause") 
   –≤ Xunit.Assert.True(Boolean condition, String userMessage)
   –≤ Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:—Å—Ç—Ä–æ–∫–∞ 256
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 16
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:—Å—Ç—Ä–æ–∫–∞ 301
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 83
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 72
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 63
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_AccessingCapturedTransparentIdentifier2() –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:—Å—Ç—Ä–æ–∫–∞ 5633

0.009s
‚úò
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_AccessingCapturedTransparentIdentifier3 : Actual: Diagnostic(RudeEditKind.AccessingCapturedVariableInLambda, "a", "a", "!PEpxp!select clause –Å–ß!"), Diagnostic(RudeEditKind.AccessingCapturedVariableInLambda, "a", "a", "!VQ1Yq!lambda –Å–ß!") Differences: ++&gt; Diagnostic(RudeEditKind.AccessingCapturedVariableInLambda, "a", "a", "!PEpxp!select clause –Å–ß!"), ++&gt; Diagnostic(RudeEditKind.AccessingCapturedVariableInLambda, "a", "a", "!VQ1Yq!lambda –Å–ß!") --&gt; Diagnostic(RudeEditKind.AccessingCapturedVariableInLambda, "a", "a", "select clause"), --&gt; Diagnostic(RudeEditKind.AccessingCapturedVariableInLambda, "a", "a", "lambda") 
   –≤ Xunit.Assert.True(Boolean condition, String userMessage)
   –≤ Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:—Å—Ç—Ä–æ–∫–∞ 256
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 16
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:—Å—Ç—Ä–æ–∫–∞ 301
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 83
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 72
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 63
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_AccessingCapturedTransparentIdentifier3() –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:—Å—Ç—Ä–æ–∫–∞ 5673

0.013s
‚úò
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_NotAccessingCapturedTransparentIdentifier1 : Actual: Diagnostic(RudeEditKind.NotAccessingCapturedVariableInLambda, "select", "a", "!PEpxp!select clause –Å–ß!") Differences: ++&gt; Diagnostic(RudeEditKind.NotAccessingCapturedVariableInLambda, "select", "a", "!PEpxp!select clause –Å–ß!") --&gt; Diagnostic(RudeEditKind.NotAccessingCapturedVariableInLambda, "select", "a", "select clause") 
   –≤ Xunit.Assert.True(Boolean condition, String userMessage)
   –≤ Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:—Å—Ç—Ä–æ–∫–∞ 256
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 16
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:—Å—Ç—Ä–æ–∫–∞ 301
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 83
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 72
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 63
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_NotAccessingCapturedTransparentIdentifier1() –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:—Å—Ç—Ä–æ–∫–∞ 5716

0.009s
‚úò
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_NotAccessingCapturedTransparentIdentifier2 : Actual: Diagnostic(RudeEditKind.AccessingCapturedVariableInLambda, "a", "a", "!PEpxp!select clause –Å–ß!"), Diagnostic(RudeEditKind.AccessingCapturedVariableInLambda, "a", "a", "!VQ1Yq!lambda –Å–ß!") Differences: ++&gt; Diagnostic(RudeEditKind.AccessingCapturedVariableInLambda, "a", "a", "!PEpxp!select clause –Å–ß!"), ++&gt; Diagnostic(RudeEditKind.AccessingCapturedVariableInLambda, "a", "a", "!VQ1Yq!lambda –Å–ß!") --&gt; Diagnostic(RudeEditKind.AccessingCapturedVariableInLambda, "a", "a", "select clause"), --&gt; Diagnostic(RudeEditKind.AccessingCapturedVariableInLambda, "a", "a", "lambda") 
   –≤ Xunit.Assert.True(Boolean condition, String userMessage)
   –≤ Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:—Å—Ç—Ä–æ–∫–∞ 256
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 16
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:—Å—Ç—Ä–æ–∫–∞ 301
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 83
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 72
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 63
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_NotAccessingCapturedTransparentIdentifier2() –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:—Å—Ç—Ä–æ–∫–∞ 5756

0.006s
‚úò
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_From1 : Actual: Diagnostic(RudeEditKind.ChangingQueryLambdaType, "from", "!5xC22!from clause –Å–ß!") Differences: ++&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "from", "!5xC22!from clause –Å–ß!") --&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "from", "from clause") 
   –≤ Xunit.Assert.True(Boolean condition, String userMessage)
   –≤ Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:—Å—Ç—Ä–æ–∫–∞ 256
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 16
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:—Å—Ç—Ä–æ–∫–∞ 301
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 83
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 72
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 63
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_From1() –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:—Å—Ç—Ä–æ–∫–∞ 4800

0.008s
‚úò
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_GroupBy1 : Actual: Diagnostic(RudeEditKind.ChangingQueryLambdaType, "group", "!p4EYV!groupby clause –Å–ß!") Differences: ++&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "group", "!p4EYV!groupby clause –Å–ß!") --&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "group", "groupby clause") 
   –≤ Xunit.Assert.True(Boolean condition, String userMessage)
   –≤ Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:—Å—Ç—Ä–æ–∫–∞ 256
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 16
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:—Å—Ç—Ä–æ–∫–∞ 301
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 83
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 72
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 63
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_GroupBy1() –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:—Å—Ç—Ä–æ–∫–∞ 5146

0.017s
‚úò
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_GroupBy2 : Actual: Diagnostic(RudeEditKind.ChangingQueryLambdaType, "group", "!p4EYV!groupby clause –Å–ß!") Differences: ++&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "group", "!p4EYV!groupby clause –Å–ß!") --&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "group", "groupby clause") 
   –≤ Xunit.Assert.True(Boolean condition, String userMessage)
   –≤ Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:—Å—Ç—Ä–æ–∫–∞ 256
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 16
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:—Å—Ç—Ä–æ–∫–∞ 301
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 83
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 72
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 63
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_GroupBy2() –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:—Å—Ç—Ä–æ–∫–∞ 5181

0.009s
‚úò
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_Join1 : Actual: Diagnostic(RudeEditKind.ChangingQueryLambdaType, "join", "!j4Xqe!join clause –Å–ß!") Differences: ++&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "join", "!j4Xqe!join clause –Å–ß!") --&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "join", "join clause") 
   –≤ Xunit.Assert.True(Boolean condition, String userMessage)
   –≤ Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:—Å—Ç—Ä–æ–∫–∞ 256
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 16
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:—Å—Ç—Ä–æ–∫–∞ 301
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 83
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 72
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 63
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_Join1() –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:—Å—Ç—Ä–æ–∫–∞ 5006

0.073s
‚úò
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_Join2 : Actual: Diagnostic(RudeEditKind.ChangingQueryLambdaType, "join", "!j4Xqe!join clause –Å–ß!") Differences: ++&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "join", "!j4Xqe!join clause –Å–ß!") --&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "join", "join clause") 
   –≤ Xunit.Assert.True(Boolean condition, String userMessage)
   –≤ Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:—Å—Ç—Ä–æ–∫–∞ 256
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 16
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:—Å—Ç—Ä–æ–∫–∞ 301
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 83
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 72
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 63
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_Join2() –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:—Å—Ç—Ä–æ–∫–∞ 5041

0.011s
‚úò
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_Join3 : Actual: Diagnostic(RudeEditKind.ChangingQueryLambdaType, "join", "!j4Xqe!join clause –Å–ß!") Differences: ++&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "join", "!j4Xqe!join clause –Å–ß!") --&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "join", "join clause") 
   –≤ Xunit.Assert.True(Boolean condition, String userMessage)
   –≤ Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:—Å—Ç—Ä–æ–∫–∞ 256
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 16
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:—Å—Ç—Ä–æ–∫–∞ 301
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 83
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 72
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 63
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_Join3() –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:—Å—Ç—Ä–æ–∫–∞ 5076

0.007s
‚úò
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_Join4 : Actual: Diagnostic(RudeEditKind.ChangingQueryLambdaType, "join", "!j4Xqe!join clause –Å–ß!") Differences: ++&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "join", "!j4Xqe!join clause –Å–ß!") --&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "join", "join clause") 
   –≤ Xunit.Assert.True(Boolean condition, String userMessage)
   –≤ Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:—Å—Ç—Ä–æ–∫–∞ 256
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 16
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:—Å—Ç—Ä–æ–∫–∞ 301
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 83
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 72
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 63
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_Join4() –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:—Å—Ç—Ä–æ–∫–∞ 5111

0.006s
‚úò
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_Let1 : Actual: Diagnostic(RudeEditKind.ChangingQueryLambdaType, "let", "!KmPDb!let clause –Å–ß!") Differences: ++&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "let", "!KmPDb!let clause –Å–ß!") --&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "let", "let clause") 
   –≤ Xunit.Assert.True(Boolean condition, String userMessage)
   –≤ Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:—Å—Ç—Ä–æ–∫–∞ 256
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 16
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:—Å—Ç—Ä–æ–∫–∞ 301
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 83
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 72
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 63
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_Let1() –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:—Å—Ç—Ä–æ–∫–∞ 4901

0.028s
‚úò
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_OrderBy1 : Actual: Diagnostic(RudeEditKind.ChangingQueryLambdaType, "a + 1.0 descending", "!wIIAy!orderby clause –Å–ß!") Differences: ++&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "a + 1.0 descending", "!wIIAy!orderby clause –Å–ß!") --&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "a + 1.0 descending", "orderby clause") 
   –≤ Xunit.Assert.True(Boolean condition, String userMessage)
   –≤ Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:—Å—Ç—Ä–æ–∫–∞ 256
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 16
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:—Å—Ç—Ä–æ–∫–∞ 301
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 83
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 72
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 63
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_OrderBy1() –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:—Å—Ç—Ä–æ–∫–∞ 4936

0.008s
‚úò
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_OrderBy2 : Actual: Diagnostic(RudeEditKind.ChangingQueryLambdaType, "a + 2.0 ascending", "!wIIAy!orderby clause –Å–ß!") Differences: ++&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "a + 2.0 ascending", "!wIIAy!orderby clause –Å–ß!") --&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "a + 2.0 ascending", "orderby clause") 
   –≤ Xunit.Assert.True(Boolean condition, String userMessage)
   –≤ Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:—Å—Ç—Ä–æ–∫–∞ 256
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 16
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:—Å—Ç—Ä–æ–∫–∞ 301
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 83
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 72
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 63
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_OrderBy2() –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:—Å—Ç—Ä–æ–∫–∞ 4971

0.004s
‚úò
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_Select1 : Actual: Diagnostic(RudeEditKind.ChangingQueryLambdaType, "select", "!PEpxp!select clause –Å–ß!") Differences: ++&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "select", "!PEpxp!select clause –Å–ß!") --&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "select", "select clause") 
   –≤ Xunit.Assert.True(Boolean condition, String userMessage)
   –≤ Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:—Å—Ç—Ä–æ–∫–∞ 256
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 16
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:—Å—Ç—Ä–æ–∫–∞ 301
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 83
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 72
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 63
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_Select1() –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:—Å—Ç—Ä–æ–∫–∞ 4734

0.007s
‚úò
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_Select2 : Actual: Diagnostic(RudeEditKind.ChangingQueryLambdaType, "select", "!PEpxp!select clause –Å–ß!") Differences: ++&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "select", "!PEpxp!select clause –Å–ß!") --&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "select", "select clause") 
   –≤ Xunit.Assert.True(Boolean condition, String userMessage)
   –≤ Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:—Å—Ç—Ä–æ–∫–∞ 256
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 16
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:—Å—Ç—Ä–æ–∫–∞ 301
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 83
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 72
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 63
   –≤ Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_Select2() –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:—Å—Ç—Ä–æ–∫–∞ 4767

0.013s
‚úò
 Microsoft.CodeAnalysis.Editor.CSharp.UnitTests.Completion.CompletionSetSources.SymbolCompletionProviderTests.MethodOverloadDifferencesIgnored_ExtensionMethod2 : Assert.Equal() Failure Position: First difference is at position 1 Expected: (extension) void C.Do(string x) Actual: (!Qfuzb!extension –Å–ß!) void C.Do(string x)
   –≤ Xunit.Assert.Equal[T](T expected, T actual, IEqualityComparer`1 comparer)
   –≤ Xunit.Assert.Equal[T](T expected, T actual)
   –≤ Microsoft.CodeAnalysis.Editor.UnitTests.Completion.AbstractCompletionProviderTests`1.VerifyItemInLinkedFiles(String xmlString, String expectedItem, String expectedDescription) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\Completion\AbstractCompletionProviderTests.cs:—Å—Ç—Ä–æ–∫–∞ 542
   –≤ Microsoft.CodeAnalysis.Editor.CSharp.UnitTests.Completion.CompletionSetSources.SymbolCompletionProviderTests.MethodOverloadDifferencesIgnored_ExtensionMethod2() –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\Completion\CompletionProviders\SymbolCompletionProviderTests.cs:—Å—Ç—Ä–æ–∫–∞ 7026
</Description>
        <CreatedDate>07/04/2015</CreatedDate>
        <ClosedDate>02/07/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>3811</PullRequestID>
        <IssueID>2657</IssueID>
        <Title>Roslyn.Services.Editor.VisualBasic.UnitTests.dll - 2 tests fail in presence of localized resources</Title>
        <Description>Assemblies Run

Roslyn.Services.Editor.VisualBasic.UnitTests.dll

Summary

Tests run: 8323   Failures: 2, Skipped: 63, Run time: 276.222s

Failed tests

0.005s
‚úò
 Microsoft.CodeAnalysis.VisualBasic.EditAndContinue.UnitTests.ActiveStatementTests.ForEach_Update_Lambda2 : Actual: Diagnostic(RudeEditKind.UpdateAroundActiveStatement, "For Each a In G(Function(a) a)", "!VU3Qz!For Each statement –Å–ß–´!") Differences: ++&gt; Diagnostic(RudeEditKind.UpdateAroundActiveStatement, "For Each a In G(Function(a) a)", "!VU3Qz!For Each statement –Å–ß–´!") --&gt; Diagnostic(RudeEditKind.UpdateAroundActiveStatement, "For Each a In G(Function(a) a)", "For Each statement") 
   –≤ Xunit.Assert.True(Boolean condition, String userMessage)
   –≤ Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:—Å—Ç—Ä–æ–∫–∞ 257
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 16
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifyRudeDiagnostics(EditScript`1 editScript, ActiveStatementsDescription description, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:—Å—Ç—Ä–æ–∫–∞ 125
   –≤ Microsoft.CodeAnalysis.VisualBasic.EditAndContinue.UnitTests.Extensions.VerifyRudeDiagnostics(EditScript`1 editScript, ActiveStatementsDescription description, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\VisualBasicTest\EditAndContinue\Helpers\Extensions.vb:—Å—Ç—Ä–æ–∫–∞ 39
   –≤ Microsoft.CodeAnalysis.VisualBasic.EditAndContinue.UnitTests.ActiveStatementTests.ForEach_Update_Lambda2() –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\VisualBasicTest\EditAndContinue\ActiveStatementTests.vb:—Å—Ç—Ä–æ–∫–∞ 2909

0.044s
‚úò
 Microsoft.CodeAnalysis.VisualBasic.EditAndContinue.UnitTests.ActiveStatementTests.SyncLock_Update_Lambda2 : Actual: Diagnostic(RudeEditKind.UpdateAroundActiveStatement, "SyncLock G(Function(a) a)", "!lp9Rs!SyncLock statement –Å–ß–´!") Differences: ++&gt; Diagnostic(RudeEditKind.UpdateAroundActiveStatement, "SyncLock G(Function(a) a)", "!lp9Rs!SyncLock statement –Å–ß–´!") --&gt; Diagnostic(RudeEditKind.UpdateAroundActiveStatement, "SyncLock G(Function(a) a)", "SyncLock statement") 
   –≤ Xunit.Assert.True(Boolean condition, String userMessage)
   –≤ Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:—Å—Ç—Ä–æ–∫–∞ 257
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:—Å—Ç—Ä–æ–∫–∞ 16
   –≤ Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifyRudeDiagnostics(EditScript`1 editScript, ActiveStatementsDescription description, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:—Å—Ç—Ä–æ–∫–∞ 125
   –≤ Microsoft.CodeAnalysis.VisualBasic.EditAndContinue.UnitTests.Extensions.VerifyRudeDiagnostics(EditScript`1 editScript, ActiveStatementsDescription description, RudeEditDiagnosticDescription[] expectedDiagnostics) –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\VisualBasicTest\EditAndContinue\Helpers\Extensions.vb:—Å—Ç—Ä–æ–∫–∞ 39
   –≤ Microsoft.CodeAnalysis.VisualBasic.EditAndContinue.UnitTests.ActiveStatementTests.SyncLock_Update_Lambda2() –≤ C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\VisualBasicTest\EditAndContinue\ActiveStatementTests.vb:—Å—Ç—Ä–æ–∫–∞ 2621
</Description>
        <CreatedDate>11/05/2015</CreatedDate>
        <ClosedDate>02/07/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>3811</PullRequestID>
      <File>src/EditorFeatures/CSharpTest/EditAndContinue/RudeEditStatementTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>3793</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Revert "Make APIs related to scripting and interactive internal for RTM"</Title>
    <Description>This reverts commit 15443a233a4cfb400e349f40f9d265ec341998a2.

Conflicts:
- src/Compilers/CSharp/Portable/CommandLine/CommandLineParser.cs
- src/Compilers/CSharp/Portable/PublicAPI.txt
- src/Compilers/Core/Portable/PublicAPI.txt
- src/Compilers/VisualBasic/Portable/CommandLine/CommandLineParser.vb

Fixes #3786 and #2888.
</Description>
    <CreatedDate>01/07/2015</CreatedDate>
    <ClosedDate>02/07/2015</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>3793</PullRequestID>
        <IssueID>3786</IssueID>
        <Title>Symbols from previous submissions are squiggled in the Interactive Window</Title>
        <Description>![interactivewindow](https://cloud.githubusercontent.com/assets/10508071/8463620/ba1b15dc-1ff0-11e5-9e80-916bed37e725.png)

They bind, but they're not available via Completion and they're squiggled.  They're probably not available through the SemanticModel.
</Description>
        <CreatedDate>01/07/2015</CreatedDate>
        <ClosedDate>02/07/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>3793</PullRequestID>
        <IssueID>2888</IssueID>
        <Title>Reenable interactive tests after RTM snaps</Title>
        <Description>Some tests had to be disabled due to removal of public API.
</Description>
        <CreatedDate>19/05/2015</CreatedDate>
        <ClosedDate>02/07/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>3793</PullRequestID>
      <File>src/Compilers/CSharp/Portable/CommandLine/CommandLineParser.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/CSharpCompilation.cs</File>
      <File>src/Compilers/Core/Portable/CommandLine/CommonCommandLineArguments.cs</File>
      <File>src/Compilers/Core/Portable/CommandLine/CommonCommandLineParser.cs</File>
      <File>src/Compilers/Core/Portable/Compilation/Compilation.cs</File>
      <File>src/EditorFeatures/CSharpTest/Interactive/CodeActions/InteractiveIntroduceVariableTests.cs</File>
      <File>src/Features/CSharp/IntroduceVariable/CSharpIntroduceVariableService_IntroduceField.cs</File>
      <File>src/Features/Core/IntroduceVariable/AbstractIntroduceVariableService.State.cs</File>
      <File>src/Interactive/EditorFeatures/CSharp/Interactive/CSharpInteractiveEvaluator.cs</File>
      <File>src/Interactive/EditorFeatures/CSharp/Interactive/CSharpRepl.cs</File>
      <File>src/Interactive/Features/Interactive/Core/InteractiveHost.Service.cs</File>
      <File>src/Workspaces/CSharp/Portable/LanguageServices/CSharpCompilationFactoryService.cs</File>
      <File>src/Workspaces/CSharp/Portable/LanguageServices/CSharpHostBuildDataFactory.cs</File>
      <File>src/Workspaces/Core/Portable/FindSymbols/FindReferences/DependentProjectsFinder.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/Solution/Project.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/Solution/Solution.CompilationTracker.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>3126</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Port: Don't assume rename text parses as IdentiferNameSyntax</Title>
    <Description>Port of #3069 to stabilization

Two commits:

Don't assume rename text parses as IdentiferNameSyntax
Fixes #1031

In both the C# and VB RenameRewriterLanguageServices, we were assuming
the new rename text would parse as an IdentifierNameSyntax, but if the
rename text is invalid it could parse as anything. For example, if the
user tries to rename "A" to "A.B", then it will parse as a
QualifiedNameSyntax. We now accommodate these cases.

Improve handling of invalid rename text in Inline Rename
This contains two small rename fixes related to invalid rename text:
1. In OnTextBufferChanged, we were trying to ensure that the
intersection of the tracked rename spans and buffer changes was a single
span. However, when the rename text is invalid, there can be many buffer
change spans that intersect a single tracked rename span, so we now use
the least bounding span of the resulting intersection. We maintain the
requirement that this bounding buffer change span intersect a single
tracked rename span.
2. When the rename text is invalid, we display it in the Rename
Dashboard. This change adds the same truncation algorithm already
applied to the original symbol name (which reduces it to 15 characters
and appends a "..." if necessary).
</Description>
    <CreatedDate>27/05/2015</CreatedDate>
    <ClosedDate>27/05/2015</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>3126</PullRequestID>
        <IssueID>3069</IssueID>
        <Title>Don't assume rename text parses as IdentiferNameSyntax</Title>
        <Description>Two commits:

**Don't assume rename text parses as IdentiferNameSyntax**
Fixes #1031

In both the C# and VB RenameRewriterLanguageServices, we were assuming
the new rename text would parse as an IdentifierNameSyntax, but if the
rename text is invalid it could parse as anything. For example, if the
user tries to rename "A" to "A.B", then it will parse as a
QualifiedNameSyntax. We now accommodate these cases.

**Improve handling of invalid rename text in Inline Rename**
This contains two small rename fixes related to invalid rename text:
1. In OnTextBufferChanged, we were trying to ensure that the
intersection of the tracked rename spans and buffer changes was a single
span. However, when the rename text is invalid, there can be many buffer
change spans that intersect a single tracked rename span, so we now use
the least bounding span of the resulting intersection. We maintain the
requirement that this bounding buffer change span intersect a single
tracked rename span.
2. When the rename text is invalid, we display it in the Rename
Dashboard. This change adds the same truncation algorithm already
applied to the original symbol name (which reduces it to 15 characters
and appends a "..." if necessary).
</Description>
        <CreatedDate>24/05/2015</CreatedDate>
        <ClosedDate>27/05/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>3126</PullRequestID>
        <IssueID>1031</IssueID>
        <Title>Renamer throws InvalidCastException</Title>
        <Description>Building a CodeFix to adjust namespace to match folder structure, I initially tried to delegate the renaming work to the Renamer class which unfortunately throws _InvalidCastException Unable to cast object of type 'Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax' to type 'Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax'._

The repro are steps are super easy, just pass to the Renamer a symbol representing a namespace and a name with . (dot) e.g 
`Renamer.RenameSymbolAsync(solution, symbol, "My.New.Namespace", options, cancellationToken)`

I'm using VS2015 CTP 6 running on Win 10 TP.

Full Stack Trace is:
Application: devenv.exe
Framework Version: v4.0.30319
Description: The application requested process termination through `System.Environment.FailFast(string message).
Message: System.InvalidCastException: Unable to cast object of type 'Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax' to type 'Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax'.
   at Microsoft.CodeAnalysis.CSharp.Rename.CSharpRenameConflictLanguageService.RenameRewriter.RenameToken(SyntaxToken oldToken, SyntaxToken newToken, String suffix, Boolean isAccessorLocation)
   at Microsoft.CodeAnalysis.CSharp.Rename.CSharpRenameConflictLanguageService.RenameRewriter.&lt;RenameAndAnnotateAsync&gt;d__1.MoveNext()
Stack:
   at System.Environment.FailFast(System.String, System.Exception)
   at Microsoft.CodeAnalysis.FailFast.OnFatalException(System.Exception)
   at Microsoft.CodeAnalysis.ErrorReporting.FatalError.Report(System.Exception, System.Action`1&lt;System.Exception&gt;)
   at Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportUnlessCanceled(System.Exception)
   at Microsoft.CodeAnalysis.CSharp.Rename.CSharpRenameConflictLanguageService+RenameRewriter+&lt;RenameAndAnnotateAsync&gt;d__1.MoveNext()
   at Microsoft.CodeAnalysis.CSharp.Rename.CSharpRenameConflictLanguageService+RenameRewriter.RenameToken(Microsoft.CodeAnalysis.SyntaxToken, Microsoft.CodeAnalysis.SyntaxToken, System.String, Boolean)
   at Microsoft.CodeAnalysis.CSharp.Rename.CSharpRenameConflictLanguageService+RenameRewriter+&lt;RenameAndAnnotateAsync&gt;d__1.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[Microsoft.CodeAnalysis.SyntaxToken, Microsoft.CodeAnalysis, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]].Start[[Microsoft.CodeAnalysis.CSharp.Rename.CSharpRenameConflictLanguageService+RenameRewriter+&lt;RenameAndAnnotateAsync&gt;d__1, Microsoft.CodeAnalysis.CSharp.Workspaces, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;RenameAndAnnotateAsync&gt;d__1 ByRef)
   at Microsoft.CodeAnalysis.CSharp.Rename.CSharpRenameConflictLanguageService+RenameRewriter.RenameAndAnnotateAsync(Microsoft.CodeAnalysis.SyntaxToken, Microsoft.CodeAnalysis.SyntaxToken, Boolean, Boolean)
   at Microsoft.CodeAnalysis.CSharp.Rename.CSharpRenameConflictLanguageService+RenameRewriter.VisitToken(Microsoft.CodeAnalysis.SyntaxToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitIdentifierName(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax)
   at Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax.Accept[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1&lt;System.__Canon&gt;)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].Visit(Microsoft.CodeAnalysis.SyntaxNode)
   at Microsoft.CodeAnalysis.CSharp.Rename.CSharpRenameConflictLanguageService+RenameRewriter.Visit(Microsoft.CodeAnalysis.SyntaxNode)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitQualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax)
   at Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax.Accept[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1&lt;System.__Canon&gt;)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].Visit(Microsoft.CodeAnalysis.SyntaxNode)
   at Microsoft.CodeAnalysis.CSharp.Rename.CSharpRenameConflictLanguageService+RenameRewriter.Visit(Microsoft.CodeAnalysis.SyntaxNode)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)
   at Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.Accept[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1&lt;System.__Canon&gt;)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].Visit(Microsoft.CodeAnalysis.SyntaxNode)
   at Microsoft.CodeAnalysis.CSharp.Rename.CSharpRenameConflictLanguageService+RenameRewriter.Visit(Microsoft.CodeAnalysis.SyntaxNode)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](System.__Canon)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](Microsoft.CodeAnalysis.SyntaxList`1&lt;System.__Canon&gt;)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitCompilationUnit(Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax)
   at Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax.Accept[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1&lt;System.__Canon&gt;)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].Visit(Microsoft.CodeAnalysis.SyntaxNode)
   at Microsoft.CodeAnalysis.CSharp.Rename.CSharpRenameConflictLanguageService+RenameRewriter.Visit(Microsoft.CodeAnalysis.SyntaxNode)
   at Microsoft.CodeAnalysis.CSharp.Rename.CSharpRenameConflictLanguageService.AnnotateAndRename(Microsoft.CodeAnalysis.Rename.RenameRewriterParameters)
   at Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver+Session+&lt;AnnotateAndRename_WorkerAsync&gt;d__1.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].Start[[Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver+Session+&lt;AnnotateAndRename_WorkerAsync&gt;d__1, Microsoft.CodeAnalysis.Workspaces, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;AnnotateAndRename_WorkerAsync&gt;d__1 ByRef)
   at Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver+Session.AnnotateAndRename_WorkerAsync(Microsoft.CodeAnalysis.Solution, Microsoft.CodeAnalysis.Solution, System.Collections.Generic.HashSet`1&lt;Microsoft.CodeAnalysis.DocumentId&gt;, System.Collections.Generic.IEnumerable`1&lt;Microsoft.CodeAnalysis.Rename.RenameLocation&gt;, Microsoft.CodeAnalysis.Rename.ConflictEngine.RenamedSpansTracker, Boolean)
   at Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver+Session+&lt;ResolveConflictsAsync&gt;d__1.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].Start[[Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver+Session+&lt;ResolveConflictsAsync&gt;d__1, Microsoft.CodeAnalysis.Workspaces, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;ResolveConflictsAsync&gt;d__1 ByRef)
   at Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver+Session.ResolveConflictsAsync()
   at Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.ResolveConflictsAsync(Microsoft.CodeAnalysis.Rename.RenameLocationSet, System.String, System.String, Microsoft.CodeAnalysis.Options.OptionSet, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Rename.Renamer+&lt;RenameSymbolAsync&gt;d__1.MoveNext()
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.InvokeMoveNext(System.Object)
   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.Run()
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore+&lt;&gt;c__DisplayClass1.&lt;OutputAsyncCausalityEvents&gt;b__0()
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore+ContinuationWrapper.Invoke()
   at System.Runtime.CompilerServices.TaskAwaiter+&lt;&gt;c__DisplayClass1.&lt;OutputWaitEtwEvents&gt;b__0()
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore+ContinuationWrapper.Invoke()
   at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Action, Boolean, System.Threading.Tasks.Task ByRef)
   at System.Threading.Tasks.Task.FinishContinuations()
   at System.Threading.Tasks.Task.FinishStageThree()
   at System.Threading.Tasks.Task`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].TrySetResult(System.__Canon)
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].SetResult(System.__Canon)
   at Microsoft.CodeAnalysis.Rename.RenameLocationSet+&lt;FindAsync&gt;d__1.MoveNext()
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.InvokeMoveNext(System.Object)
   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.Run()
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore+&lt;&gt;c__DisplayClass1.&lt;OutputAsyncCausalityEvents&gt;b__0()
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore+ContinuationWrapper.Invoke()
   at System.Runtime.CompilerServices.TaskAwaiter+&lt;&gt;c__DisplayClass1.&lt;OutputWaitEtwEvents&gt;b__0()
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore+ContinuationWrapper.Invoke()
   at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Action, Boolean, System.Threading.Tasks.Task ByRef)
   at System.Threading.Tasks.Task.FinishContinuations()
   at System.Threading.Tasks.Task.FinishStageThree()
   at System.Threading.Tasks.Task`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].TrySetResult(System.__Canon)
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].SetResult(System.__Canon)
   at Microsoft.CodeAnalysis.Rename.RenameLocationSet+&lt;AddLocationsReferenceSymbolsAsync&gt;d__1.MoveNext()
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.InvokeMoveNext(System.Object)
   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.Run()
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore+&lt;&gt;c__DisplayClass1.&lt;OutputAsyncCausalityEvents&gt;b__0()
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore+ContinuationWrapper.Invoke()
   at System.Runtime.CompilerServices.TaskAwaiter+&lt;&gt;c__DisplayClass1.&lt;OutputWaitEtwEvents&gt;b__0()
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore+ContinuationWrapper.Invoke()
   at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Action, Boolean, System.Threading.Tasks.Task ByRef)
   at System.Threading.Tasks.Task.FinishContinuations()
   at System.Threading.Tasks.Task.FinishStageThree()
   at System.Threading.Tasks.Task.FinishStageTwo()
   at System.Threading.Tasks.Task.Finish(Boolean)
   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)
   at System.Threading.Tasks.Task.ExecuteEntry(Boolean)
   at System.Threading.Tasks.Task.System.Threading.IThreadPoolWorkItem.ExecuteWorkItem()
   at System.Threading.ThreadPoolWorkQueue.Dispatch()
   at System.Threading._ThreadPoolWaitCallback.PerformWaitCallback()`
</Description>
        <CreatedDate>04/03/2015</CreatedDate>
        <ClosedDate>27/05/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>3126</PullRequestID>
      <File>src/EditorFeatures/Core/Implementation/InlineRename/Dashboard/DashboardViewModel.cs</File>
      <File>src/EditorFeatures/Core/Implementation/InlineRename/InlineRenameSession.OpenTextBufferManager.cs</File>
      <File>src/Workspaces/CSharp/Portable/Rename/CSharpRenameRewriterLanguageService.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>3022</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Fix connection issues in server</Title>
    <Description>This addresses the following issues:
- GitHub #2866: Asserts in the check connection loop.
- DevDiv 1175084: Crashes when server is unable to complete the connection to the named pipe.

These issues are being addressed together because they stem from the same
underlying problem.  The code is not fulfilling two of the main invariants
of connection processing in the server:
- The `Task` representing a client connection should never throw an exception.
  Failed connections are instead represented by the data returned from the `Task`.
- A connection should always provide a new timeout value before completing the
  compilation process.

The `Connection` type is responsible for the majority of the processing here
and is careful to maintain these invariants.  The `ServerDispatcher` type though
didn't fully account for exceptions.  This meant that errors actually completing
the `NamedPipeClientStream` connection ended up violating both of the core
invariants.

The solution here is two fold:
1. Properly handle the exceptional cases that can come from completing the named
   pipe connection.
2. Use a single `Task` to represent a client connection instead of a separate one
   for the compilation and keep alive.

close #2866
</Description>
    <CreatedDate>22/05/2015</CreatedDate>
    <ClosedDate>22/05/2015</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>3022</PullRequestID>
        <IssueID>2866</IssueID>
        <Title>Fix the issue in CheckConnectionTask</Title>
        <Description>The `CheckConnectionTask` method in the compiler server [is asserting](https://github.com/dotnet/roslyn/blob/master/src/Compilers/Core/VBCSCompiler/ServerDispatcher.cs#L287) in Debug builds of the compiler.  This assertion is not definitive but happening with decent regularity during both builds and running of the unit tests.  

``` csharp
Debug.Assert(current.ChangeKeepAliveTask == null);
```

This code is being disabled for the moment to get Jenkins unstuck but needs to be investigated and fixed.  
</Description>
        <CreatedDate>18/05/2015</CreatedDate>
        <ClosedDate>22/05/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>3022</PullRequestID>
        <IssueID>2866</IssueID>
        <Title>Fix the issue in CheckConnectionTask</Title>
        <Description>The `CheckConnectionTask` method in the compiler server [is asserting](https://github.com/dotnet/roslyn/blob/master/src/Compilers/Core/VBCSCompiler/ServerDispatcher.cs#L287) in Debug builds of the compiler.  This assertion is not definitive but happening with decent regularity during both builds and running of the unit tests.  

``` csharp
Debug.Assert(current.ChangeKeepAliveTask == null);
```

This code is being disabled for the moment to get Jenkins unstuck but needs to be investigated and fixed.  
</Description>
        <CreatedDate>18/05/2015</CreatedDate>
        <ClosedDate>22/05/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>3022</PullRequestID>
      <File>src/Compilers/Core/VBCSCompiler/ServerDispatcher.Connection.cs</File>
      <File>src/Compilers/Core/VBCSCompiler/ServerDispatcher.cs</File>
      <File>src/Compilers/Core/VBCSCompilerTests/CompilerServerApiTest.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>2996</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Ensure that calls into EnvDTE.CodeModel work even if the underlying FileCodeModel has not been realized</Title>
    <Description>Fixes issue #2893.

When calling into an EnvDTE.CodeModel API, the caller must pass the file name of the file to be operated on. For example:

var ns = codeModel.AddNamespace("MyFile.cs", "MyNamespace");

However, the implementation EnvDTE.CodeModel would only ever succeed to find the FileCodeModel for "MyFile.cs" if had already been created and cached. If the FileCodeModel wasn't in the cache, the API that was called would throw.

Ultimately, this comes down to a set of APIs with bad names that don't reflect that they only return cached values. This change renames those APIs to give them proper names (e.g. TryGetCachedFileCodeModelInstance) and adds an API that will retrieve a cached FileCodeModel or create a new one if needed.

Testing this is problematic, as it requires Visual Studio to be present. The only way to create an automated test would be through a VS-only integration test, which seems like overkill. To verify, I manually created a VS package containing the repro code in #2893 and verified that works as expected with my change.
</Description>
    <CreatedDate>21/05/2015</CreatedDate>
    <ClosedDate>21/05/2015</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>2996</PullRequestID>
        <IssueID>2893</IssueID>
        <Title>Calls to Project.CodeModel.AddNamespace crashes VS2015</Title>
        <Description>How to reproduce:

``` C#
        private EnvDTE.CodeClass GenerateCodeClassFile(EnvDTE.Project project, /* other unrelated stuff */)
        {
            string project_path = project.Properties.Item("FullPath").Value.ToString();
            string file_path    = System.IO.Path.Combine(project_path, className + ".cs");
            string file_header = @"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;";


            System.IO.File.WriteAllText(file_path, file_header);

            var proj_item = project.ProjectItems.AddFromFile(file_path);

        /* Crashes here */
            var code_namespace  = project.CodeModel.AddNamespace(project.Properties.Item("DefaultNamespace").Value.ToString(), file_path, Type.Missing);
```

Exception thrown:

```
System.InvalidOperationException was unhandled
  HResult=-2146233079
  Message=Nullable object must have a value.
  Source=EnvDTE
  StackTrace:
       at System.ThrowHelper.ThrowInvalidOperationException(ExceptionResource resource)
       at Microsoft.VisualStudio.LanguageServices.Implementation.CodeModel.RootCodeModel.GetFileCodeModel(Object location)
       at Microsoft.VisualStudio.LanguageServices.Implementation.CodeModel.RootCodeModel.AddNamespace(String name, Object location, Object position)
       at EnvDTE.CodeModel.AddNamespace(String Name, Object Location, Object Position)
       at Trinity.VSExtension.Wizards.GraphEngineAppWizard.GenerateCodeClassFile(Project project, String ref_namespace, String className, List`1 baseTypeGenericParams, String baseName)
       at Trinity.VSExtension.Wizards.GraphEngineAppWizard.GenerateMain(Project project, List`1 servers, List`1 proxies, String ref_namespace, Boolean stubsGenerated)
       at Trinity.VSExtension.Wizards.GraphEngineAppWizard.WizardWindowClosed(Object sender, EventArgs e)
       at System.Windows.Window.OnClosed(EventArgs e)
       at System.Windows.Window.WmDestroy()
       at System.Windows.Window.WindowFilterMessage(IntPtr hwnd, Int32 msg, IntPtr wParam, IntPtr lParam, Boolean&amp; handled)
       at System.Windows.Interop.HwndSource.PublicHooksFilterMessage(IntPtr hwnd, Int32 msg, IntPtr wParam, IntPtr lParam, Boolean&amp; handled)
       at MS.Win32.HwndWrapper.WndProc(IntPtr hwnd, Int32 msg, IntPtr wParam, IntPtr lParam, Boolean&amp; handled)
       at MS.Win32.HwndSubclass.DispatcherCallbackOperation(Object o)
       at System.Windows.Threading.ExceptionWrapper.InternalRealCall(Delegate callback, Object args, Int32 numArgs)
       at System.Windows.Threading.ExceptionWrapper.TryCatchWhen(Object source, Delegate callback, Object args, Int32 numArgs, Delegate catchHandler)
       at System.Windows.Threading.Dispatcher.LegacyInvokeImpl(DispatcherPriority priority, TimeSpan timeout, Delegate method, Object args, Int32 numArgs)
       at MS.Win32.HwndSubclass.SubclassWndProc(IntPtr hwnd, Int32 msg, IntPtr wParam, IntPtr lParam)
  InnerException: 

```

The stack trace indicates that the problem is related to the second parameter Location, which is the file path. I also tried to extract relative path from the item I just created through AddFromFile but it produces the same exception.
</Description>
        <CreatedDate>19/05/2015</CreatedDate>
        <ClosedDate>21/05/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>2996</PullRequestID>
        <IssueID>2893</IssueID>
        <Title>Calls to Project.CodeModel.AddNamespace crashes VS2015</Title>
        <Description>How to reproduce:

``` C#
        private EnvDTE.CodeClass GenerateCodeClassFile(EnvDTE.Project project, /* other unrelated stuff */)
        {
            string project_path = project.Properties.Item("FullPath").Value.ToString();
            string file_path    = System.IO.Path.Combine(project_path, className + ".cs");
            string file_header = @"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;";


            System.IO.File.WriteAllText(file_path, file_header);

            var proj_item = project.ProjectItems.AddFromFile(file_path);

        /* Crashes here */
            var code_namespace  = project.CodeModel.AddNamespace(project.Properties.Item("DefaultNamespace").Value.ToString(), file_path, Type.Missing);
```

Exception thrown:

```
System.InvalidOperationException was unhandled
  HResult=-2146233079
  Message=Nullable object must have a value.
  Source=EnvDTE
  StackTrace:
       at System.ThrowHelper.ThrowInvalidOperationException(ExceptionResource resource)
       at Microsoft.VisualStudio.LanguageServices.Implementation.CodeModel.RootCodeModel.GetFileCodeModel(Object location)
       at Microsoft.VisualStudio.LanguageServices.Implementation.CodeModel.RootCodeModel.AddNamespace(String name, Object location, Object position)
       at EnvDTE.CodeModel.AddNamespace(String Name, Object Location, Object Position)
       at Trinity.VSExtension.Wizards.GraphEngineAppWizard.GenerateCodeClassFile(Project project, String ref_namespace, String className, List`1 baseTypeGenericParams, String baseName)
       at Trinity.VSExtension.Wizards.GraphEngineAppWizard.GenerateMain(Project project, List`1 servers, List`1 proxies, String ref_namespace, Boolean stubsGenerated)
       at Trinity.VSExtension.Wizards.GraphEngineAppWizard.WizardWindowClosed(Object sender, EventArgs e)
       at System.Windows.Window.OnClosed(EventArgs e)
       at System.Windows.Window.WmDestroy()
       at System.Windows.Window.WindowFilterMessage(IntPtr hwnd, Int32 msg, IntPtr wParam, IntPtr lParam, Boolean&amp; handled)
       at System.Windows.Interop.HwndSource.PublicHooksFilterMessage(IntPtr hwnd, Int32 msg, IntPtr wParam, IntPtr lParam, Boolean&amp; handled)
       at MS.Win32.HwndWrapper.WndProc(IntPtr hwnd, Int32 msg, IntPtr wParam, IntPtr lParam, Boolean&amp; handled)
       at MS.Win32.HwndSubclass.DispatcherCallbackOperation(Object o)
       at System.Windows.Threading.ExceptionWrapper.InternalRealCall(Delegate callback, Object args, Int32 numArgs)
       at System.Windows.Threading.ExceptionWrapper.TryCatchWhen(Object source, Delegate callback, Object args, Int32 numArgs, Delegate catchHandler)
       at System.Windows.Threading.Dispatcher.LegacyInvokeImpl(DispatcherPriority priority, TimeSpan timeout, Delegate method, Object args, Int32 numArgs)
       at MS.Win32.HwndSubclass.SubclassWndProc(IntPtr hwnd, Int32 msg, IntPtr wParam, IntPtr lParam)
  InnerException: 

```

The stack trace indicates that the problem is related to the second parameter Location, which is the file path. I also tried to extract relative path from the item I just created through AddFromFile but it produces the same exception.
</Description>
        <CreatedDate>19/05/2015</CreatedDate>
        <ClosedDate>21/05/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>2996</PullRequestID>
      <File>src/VisualStudio/Core/Impl/CodeModel/AbstractProjectCodeModel.cs</File>
      <File>src/VisualStudio/Core/Impl/CodeModel/CodeModelIncrementalAnalyzer.cs</File>
      <File>src/VisualStudio/Core/Impl/CodeModel/FileCodeModel_Events.cs</File>
      <File>src/VisualStudio/Core/Impl/CodeModel/NodeKeyValidation.cs</File>
      <File>src/VisualStudio/Core/Impl/CodeModel/RootCodeModel.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>2995</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Harden access to MetadataReader</Title>
    <Description>Fixes #2992 and #2988. Both are crashes.

**Scenarios**
1) When a referenced metadata image is empty the compiler should report an error and not crash. 
2) When ModuleMetadata is disposed the compiler should throw ObjectDisposedException and not AV. The primary benefit is that ObjectDisposedException clearly identifies what went wrong (so the code that disposed the metadata object can be blamed) while AV just means some memory is read that shouldn't and usually results in blaming the MetadataReader, which is not in fault. This was also reported by a customer (https://github.com/dotnet/roslyn/pull/25) and also happened in XAML designer in VS.

**Fix**
Add a couple of additional checks to PEModule.MetadataReader property. As described in https://github.com/dotnet/roslyn/pull/25 we don't guarantee (2), it would be too much work and it might negatively impact perf. However we can do a very cheap check that avoids AV i 99% cases (when there is not a race between a thread that disposes the metadata and the thread accessing PE symbols).

The root cause of 1) is in System.Reflection.Metadata and is being fixed (dotnet/corefx#1815). To avoid a bigger change of updating the nuget package for RTM we can do a simple check in Roslyn to avoid hitting the PE reader issue.

**Testing**
Added unit tests for both languages.

@ManishJayaswal 
</Description>
    <CreatedDate>21/05/2015</CreatedDate>
    <ClosedDate>22/05/2015</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>2995</PullRequestID>
        <IssueID>2992</IssueID>
        <Title>Throw an ObjectDisposedException instead of an AccessViolationException</Title>
        <Description>In the following code, Roslyn throws an AccessViolationException on the last line. 

``` c#
var md = AssemblyMetadata.CreateFromFile(typeof(object).Assembly.Location);
var compilation = CSharpCompilation.Create("test", references: new[] { md.GetReference() });

// Use the Compilation once to force lazy initialization of the underlying MetadataReader
compilation.GetTypeByMetadataName("System.Version").GetMembers();

md.Dispose();

compilation.GetTypeByMetadataName("System.Exception").GetMembers(); // &lt;-- AccessViolationException is thrown here
```
</Description>
        <CreatedDate>21/05/2015</CreatedDate>
        <ClosedDate>22/05/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>2995</PullRequestID>
        <IssueID>2988</IssueID>
        <Title>Compiler crashes when an empty file is specified as a metadata reference</Title>
        <Description>The root cause is in the PEReader. Bug https://github.com/dotnet/corefx/issues/1815 is tracking that work. It is however trivial (one-line change) to work around in the compiler.

I think we should fix this for RTM - the fix is small and low risk.
</Description>
        <CreatedDate>21/05/2015</CreatedDate>
        <ClosedDate>22/05/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>2995</PullRequestID>
        <IssueID>1815</IssueID>
        <Title>VB EE: report error on invalid constant value </Title>
        <Description>We should report an error if the value of a constant can't be retrieved from PDB or the retrieved value is invalid.
</Description>
        <CreatedDate>06/04/2015</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>2995</PullRequestID>
      <File>src/Compilers/CSharp/Test/Symbol/Compilation/ReferenceManagerTests.cs</File>
      <File>src/Compilers/Core/CodeAnalysisTest/MetadataReferences/ModuleMetadataTests.cs</File>
      <File>src/Compilers/Core/Portable/MetadataReader/PEModule.cs</File>
      <File>src/Compilers/Core/Portable/MetadataReference/ModuleMetadata.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>2950</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Numeric literals (binary and digit separators)</Title>
    <Description>This PR implements binary literals for C# and VB, as well as digit separators (underscores) for both C# and VB. It also implements a feature check and two /features flags for binary literals and digit separators, again for both C# and VB.

This implements proposals #215 and #216

Original PR [here](https://github.com/dotnet/roslyn/pull/2730), closed due to branching reorganization.

@gafter @jaredpar @VSadov @AlekseyTs @agocke Please review
</Description>
    <CreatedDate>20/05/2015</CreatedDate>
    <ClosedDate>23/07/2015</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>2950</PullRequestID>
        <IssueID>215</IssueID>
        <Title>Proposal: Binary literals</Title>
        <Description>There‚Äôs a relatively common request to add binary literals to C# and VB. For bitmasks (e.g. flag enums) this seems genuinely useful, but it would also be great just for educational purposes.

Binary literals would look like this:

``` c#
int nineteen = 0b10011;
```

Syntactically and semantically they are identical to hexadecimal literals, except for using `b`/`B` instead of `x`/`X`, having only digits `0` and `1` and being interpreted in base 2 instead of 16.

There‚Äôs little cost to implementing these, and little conceptual overhead to users of the language.
# Syntax

The grammar would be as follows:

&gt; _integer-literal:_
&gt; &amp;emsp;  ...
&gt; &amp;emsp;  _binary-integer-literal_
&gt; 
&gt; _binary-integer-literal:_
&gt; &amp;emsp;  `0b`  &amp;emsp;  _binary-digits_  &amp;emsp;  _integer-type-suffixopt_
&gt; &amp;emsp;  `0B`  &amp;emsp;  _binary-digits_  &amp;emsp;  _integer-type-suffixopt_
&gt; 
&gt; _binary-digits:_
&gt; &amp;emsp;  _binary-digit_
&gt; &amp;emsp;  _binary-digits_  &amp;emsp;  _binary-digit_
&gt; 
&gt; _binary-digit:_  &amp;emsp; one of
&gt; &amp;emsp;  `0`  `1`
</Description>
        <CreatedDate>03/02/2015</CreatedDate>
        <ClosedDate>27/03/2017</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>2950</PullRequestID>
        <IssueID>216</IssueID>
        <Title>Proposal: Digit separators</Title>
        <Description>Being able to group digits in large numeric literals would have great readability impact and no significant downside. 

Adding binary literals (#215) would increase the likelihood of numeric literals being long, so the two features enhance each other. 

We would follow Java and others, and use an underscore `_` as a digit separator. It would be able to occur everywhere in a numeric literal (except as the first and last character), since different groupings may make sense in different scenarios and especially for different numeric bases:

``` c#
int bin = 0b1001_1010_0001_0100;
int hex = 0x1b_a0_44_fe;
int dec = 33_554_432;
int weird = 1_2__3___4____5_____6______7_______8________9;
double real = 1_000.111_1e-1_000;
```

Any sequence of digits may be separated by underscores, possibly more than one underscore between two consecutive digits. They are allowed in decimals as well as exponents, but following the previous rule, they may not appear next to the decimal (`10_.0`), next to the exponent character (`1.1e_1`), or next to the type specifier (`10_f`). When used in binary and hexadecimal literals, they may not appear immediately following the `0x` or `0b`.

The syntax is straightforward, and the separators have no semantic impact - they are simply ignored.

This has broad value and is easy to implement.
</Description>
        <CreatedDate>03/02/2015</CreatedDate>
        <ClosedDate>07/03/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>2950</PullRequestID>
      <File>src/Compilers/CSharp/Portable/CSharpResources.Designer.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/MessageID.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/CharacterInfo.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/Lexer.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/SyntaxParser.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/LexicalAndXml/LexicalTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>2939</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Guard against concurrent callbacks into analyzers in IDE</Title>
    <Description>**Customer scenario:** We need to do so for couple of scenarios:
1. Different diagnostic clients might end up requesting diagnostics at the same time and hence end up attempting to invoke into the same analyzer simultaneously.
2. FixAll occurrences computes diagnostics in parallel, hence can causes concurrent callbacks.

If the analyzer hasn't been written in a thread-safe way, then concurrent callbacks into it can cause analyzers to produce incorrect/misleading/duplicate diagnostics or the analyzer itself might throw and never execute again in the VS session.

**Fixes #2410**

**Testing:** There is no functional change here, so existing tests provide adequate coverage. I manually verified that FixAll performance is acceptable for simplify name/remove unnecessary usings across projects/solution in Roslyn.sln

/cc @srivatsn @ManishJayaswal Note that this is an identical change as #2833 (which was in the main repot). This one is directly in the stabilization branch. I already have couple of signoffs on #2833, so I just need your approval.
</Description>
    <CreatedDate>20/05/2015</CreatedDate>
    <ClosedDate>21/05/2015</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>2939</PullRequestID>
        <IssueID>2410</IssueID>
        <Title>Analyzer actions may get executed in parallel in FixAll occurrences scenario</Title>
        <Description>Currently we conservatively guard each analyzer from having its actions executed in parallel for command line builds. Even for the IDE live diagnostic analysis, we ensure no concurrency within analyzer. However, for FixAll we invoke document diagnostic computation in parallel for all documents in the scope of fix all (project/solution). This is required as otherwise the perf for FixAll is really bad.

However, this code path doesn't guard analyzer actions from concurrent execution. We should fix this behavior in the diagnostic service running analyzers for fix all code path.
</Description>
        <CreatedDate>30/04/2015</CreatedDate>
        <ClosedDate>21/05/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>2939</PullRequestID>
        <IssueID>2833</IssueID>
        <Title>Guard against concurrent callbacks into analyzers in IDE</Title>
        <Description>We need to do so for couple of scenarios:
1.  Different diagnostic clients might end up requesting diagnostics at the same time and hence end up attempting to invoke into the same analyzer simultaneously.
2. FixAll occurrences computes diagnostics in parallel, hence can causes concurrent callbacks. I plan to test that this doesn't drastically regress FixAll perf for common scenarios across large solutions, but am currently blocked by #2832
</Description>
        <CreatedDate>16/05/2015</CreatedDate>
        <ClosedDate>27/05/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>2939</PullRequestID>
        <IssueID>2833</IssueID>
        <Title>Guard against concurrent callbacks into analyzers in IDE</Title>
        <Description>We need to do so for couple of scenarios:
1.  Different diagnostic clients might end up requesting diagnostics at the same time and hence end up attempting to invoke into the same analyzer simultaneously.
2. FixAll occurrences computes diagnostics in parallel, hence can causes concurrent callbacks. I plan to test that this doesn't drastically regress FixAll perf for common scenarios across large solutions, but am currently blocked by #2832
</Description>
        <CreatedDate>16/05/2015</CreatedDate>
        <ClosedDate>27/05/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>2939</PullRequestID>
      <File>src/Compilers/Core/AnalyzerDriver/AnalyzerExecutor.cs</File>
      <File>src/Compilers/Core/Portable/DiagnosticAnalyzer/AnalyzerDriver.cs</File>
      <File>src/Features/Core/Diagnostics/EngineV1/DiagnosticAnalyzerDriver.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>2289</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Add skipped test for another repro case for #463</Title>
    <Description>Add test for another repro of #463 in SyntaxTree.GetChanges(tree)

@mattwar I am going to re-open #463, you can repro the bug through this unit test.

This test is derived from https://github.com/DotNetAnalyzers/StyleCopAnalyzers/issues/723 reported by @AArnott 

/cc @sharwell 
</Description>
    <CreatedDate>27/04/2015</CreatedDate>
    <ClosedDate>27/04/2015</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>2289</PullRequestID>
        <IssueID>463</IssueID>
        <Title>Problem with C# diff edit representation returned by SyntaxTree.GetChanges()</Title>
        <Description>See the testcase SyntaxDiffingTests.TestQualifyWithThis(...) added in Pull Request #457.

For the referenced testcase, it returns 2 changes - with an add followed by delete.

This causes downstream pieces to consider this as conflicting edits, even though they are not.

/cc @mavasani 
</Description>
        <CreatedDate>13/02/2015</CreatedDate>
        <ClosedDate>28/04/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>2289</PullRequestID>
        <IssueID>463</IssueID>
        <Title>Problem with C# diff edit representation returned by SyntaxTree.GetChanges()</Title>
        <Description>See the testcase SyntaxDiffingTests.TestQualifyWithThis(...) added in Pull Request #457.

For the referenced testcase, it returns 2 changes - with an add followed by delete.

This causes downstream pieces to consider this as conflicting edits, even though they are not.

/cc @mavasani 
</Description>
        <CreatedDate>13/02/2015</CreatedDate>
        <ClosedDate>28/04/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>2289</PullRequestID>
      <File>src/Compilers/CSharp/Test/Syntax/Syntax/SyntaxDiffingTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>2286</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Fix a race condition in BatchFixAllProvider's merge logic, in presence o...</Title>
    <Description>...f merge conflicts.

The current merge logic that merges code fixes from batch fixes ignores individual text changes that conflict with already merged batch fixes. This can be problematic if we have already merged a fix in the document in a later text span. We may end up adding text changes of kind Insert, but silently ignore text changes of kind Remove, returned by SyntaxTree.GetChanges(tree). This can cause the merged text document to be completely corrupt.
Fix is to ignore **all** the text changes from a code fix (that is part of batch fixes) if any of its text change has a conflict.

NOTE: https://github.com/DotNetAnalyzers/StyleCopAnalyzers/issues/723 represents another case similar to #463, where SyntaxTree.GetChanges returns an add + remove text change with long spans, when the actual text change is just a single char replace. This causes completely independent code fixes to seem as conflicting to the batch fixer. I'll file a separate issue for this API bug.

Fixes #320 
</Description>
    <CreatedDate>27/04/2015</CreatedDate>
    <ClosedDate>27/04/2015</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>2286</PullRequestID>
        <IssueID>463</IssueID>
        <Title>Problem with C# diff edit representation returned by SyntaxTree.GetChanges()</Title>
        <Description>See the testcase SyntaxDiffingTests.TestQualifyWithThis(...) added in Pull Request #457.

For the referenced testcase, it returns 2 changes - with an add followed by delete.

This causes downstream pieces to consider this as conflicting edits, even though they are not.

/cc @mavasani 
</Description>
        <CreatedDate>13/02/2015</CreatedDate>
        <ClosedDate>28/04/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>2286</PullRequestID>
        <IssueID>320</IssueID>
        <Title>Possible bug in Batch Fixer merge algorithm</Title>
        <Description>We have a code fix that uses the batch fixer to provide support for correcting all instances of a particular style problem in a document/project/solution. Even though each correction is made to a distinct `ExpressionSyntax` node in the source tree, the batch fixer fails to properly merge two changes in a particular scenario.

The problem is described (with example input/output) in the following issue:
https://github.com/DotNetAnalyzers/StyleCopAnalyzers/issues/466
</Description>
        <CreatedDate>09/02/2015</CreatedDate>
        <ClosedDate>27/04/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>2286</PullRequestID>
      <File>src/Workspaces/Core/Portable/CodeFixes/FixAllOccurrences/BatchFixAllProvider.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>2285</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Adding error triggers  for the add-usings fixers</Title>
    <Description>Adding additional errors for the Add Imports/Usings fixers to react to.
Now, when we get an error on an extension method we offer to import the
correct namespace.

Fixes #935
Fixes #562
</Description>
    <CreatedDate>27/04/2015</CreatedDate>
    <ClosedDate>27/04/2015</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>2285</PullRequestID>
        <IssueID>935</IssueID>
        <Title>Add Using should work for extension methods even if other methods are in scope.</Title>
        <Description>Consider a programming referencing Roslyn binaries:

``` C#
using Microsoft.CodeAnalysis.CSharp;

class Program
{
    static void Main(string[] args)
    {
        var node = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseCompilationUnit("");

        node = node.NormalizeWhitespace();
    }
}
```

Place cursor on the line with the call to `NormalizeWhitespace()`.

_Result_
No lightbulb suggesting to add `using Microsoft.CodeAnalysis;`

_Expected_
There should be.

_Note_
This is happening because the `using Microsoft.CodeAnalysis.CSharp;` is pulling in another extension method named `NormalizeWhitespace()` which doesn't apply to this receiver type.
</Description>
        <CreatedDate>27/02/2015</CreatedDate>
        <ClosedDate>27/04/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>2285</PullRequestID>
        <IssueID>562</IssueID>
        <Title>Non-conflicting extension method suppresses Add Using quick fix</Title>
        <Description>Source:

``` C#
using System.Linq;

class C {
    int i = 0.All();
}
namespace X {
    static class E {
        public static int All(this int o) =&gt; 0;
    }
}
```

No quick fix is offered to add `using X;`.

Removing the existing `using` directive will make the quick fix appear.
</Description>
        <CreatedDate>17/02/2015</CreatedDate>
        <ClosedDate>27/04/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>2285</PullRequestID>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/AddUsing/AddUsingTests.cs</File>
      <File>src/Features/CSharp/CodeFixes/AddImport/CSharpAddImportCodeFixProvider.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>2283</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Report semantic errors in lambdas</Title>
    <Description>The compiler does not generate semantic errors inside lambdas in the
presence of syntactic errors causing several features to not work in
lambdas with syntax errors.  The bug for this
([1867](https://github.com/dotnet/roslyn/issues/1867)) was moved to
milestone 1.1 so we are going to use an analyzer in the interim for 1.0.
1. We now check for IncompleteMemberSyntax nodes and
   LambdaExpressionSyntax nodes which contain syntax diagnostics on any of
   their descendant nodes.
2. We report both unbound identifier names and constructors that the
   compiler reports as binding, but which fail overload resolution
   (actually don't exist).

Performance considerations should be mitigated by only doing these
checks only lambdas with syntax errors.

Other notes:
- Renamed analyzer to UnboundIdentifier instead of AddImport since it is
  being used in more places than just the AddImport fixer
- Updated the DiagnosticDescriptor for this analyzer to take
  localizeable strings.

Fixes #1744
Fixes #1241
Fixes #1239
</Description>
    <CreatedDate>27/04/2015</CreatedDate>
    <ClosedDate>28/04/2015</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>2283</PullRequestID>
        <IssueID>1744</IssueID>
        <Title>Incomplete catch block in lambda doesn't show Add Using quick fix</Title>
        <Description>Source:

``` C#
class A {
    System.Action a = () =&gt; {
        try {
        }
        catch (Exception
    };
}
```

The Add Using/Qualify Name quick fix will not appear until after adding `) {`.
</Description>
        <CreatedDate>01/04/2015</CreatedDate>
        <ClosedDate>28/04/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>2283</PullRequestID>
        <IssueID>1241</IssueID>
        <Title>Generate Constructor doesn't appear in statement lambda with missing semicolon</Title>
        <Description>```
using System.Threading.Tasks;

class C {
    C() {
        Task.Run(() =&gt; {
            new C(0)
        });
    }
}
```

No quick fix will appear until a semicolon is added.

This may be a dup of #1239; I'm not sure.
</Description>
        <CreatedDate>13/03/2015</CreatedDate>
        <ClosedDate>28/04/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>2283</PullRequestID>
        <IssueID>1239</IssueID>
        <Title>Add using quick fix doesn't show in incomplete lamba</Title>
        <Description>Source (entire file):

``` C#
using System.Linq;

class C {
    C() {
        "".Select(() =&gt; {
            new Byte
```

No quick fix appears in `Exception`.

---

Alternate source with same issue:

``` C#
using System.Linq;

class C {
    C() {
        "".Select(() =&gt; {
            new Byte()
            }
```

Here, removing the `()` makes the quick fix appear.
</Description>
        <CreatedDate>13/03/2015</CreatedDate>
        <ClosedDate>28/04/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>2283</PullRequestID>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/AddUsing/AddUsingTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/GenerateConstructor/GenerateConstructorTests.cs</File>
      <File>src/Features/CSharp/CSharpFeaturesResources.Designer.cs</File>
      <File>src/Features/CSharp/Diagnostics/Analyzers/CSharpAddImportDiagnosticAnalyzer.cs</File>
      <File>src/Features/CSharp/Diagnostics/Analyzers/CSharpUnboundIdentifiersDiagnosticAnalyzer.cs</File>
      <File>src/Features/Core/Diagnostics/Analyzers/UnboundIdentifiersDiagnosticAnalyzerBase.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>2158</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Use a recent Unicode version for case mapping by relying on a neutral culture</Title>
    <Description>instead of the not-so-neutral invarant culture.
Fixes #2116, #620
See also #1070

@ellismg @jaredpar @AlekseyTs : Please review
/cc @VladimirReshetnikov
</Description>
    <CreatedDate>21/04/2015</CreatedDate>
    <ClosedDate>27/04/2015</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>2158</PullRequestID>
        <IssueID>2116</IssueID>
        <Title>Change VB's case-mapping rules to use a more recent Unicode version</Title>
        <Description>VB's current case-mapping rules for identifier equivalence uses a pretty old version of the Unicode spec, and has bugs. Specifically we use the "invariant" locale, which because it is invariant will never change to be updated as the Unicode spec evolves.

We should instead use a "neutral" culture for the case-mapping, such as the "en" locale, which follows the Unicode case-mapping rules and has no locale-specific exceptions.

&lt;!---
@huboard:{"order":1968.0,"milestone_order":2116,"custom_state":""}
--&gt;
</Description>
        <CreatedDate>20/04/2015</CreatedDate>
        <ClosedDate>27/04/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>2158</PullRequestID>
        <IssueID>620</IssueID>
        <Title>Roslyn VB is more case-sensitive than the native with certain Unicode characters</Title>
        <Description>``` vb
#Const «á = True

Module Program
    Const «à = "«à"

    Sub Main()
        Console.WriteLine(«à.ToUpperInvariant = "«á") ' True
        Foo()
    End Sub

    &lt;Conditional(«à)&gt;
    Sub Foo()
        Console.WriteLine("Foo")
    End Sub
End Module
```

This code prints True Foo when compiled with the native vbc, but only True with Roslyn.
The upper-case form of «à, 'LATIN CAPITAL LETTER L WITH SMALL LETTER J' (U+01C8) is «á. 

Originally reported by @VladimirReshetnikov 
</Description>
        <CreatedDate>18/02/2015</CreatedDate>
        <ClosedDate>08/04/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>2158</PullRequestID>
        <IssueID>1070</IssueID>
        <Title>Add a doc about the change in unicode version.</Title>
        <Description>
        </Description>
        <CreatedDate>06/03/2015</CreatedDate>
        <ClosedDate>06/03/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>2158</PullRequestID>
      <File>src/Compilers/Core/Portable/CaseInsensitiveComparison.cs</File>
      <File>src/Workspaces/Core/Portable/Shared/Extensions/SourceTextExtensions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>2121</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Fix recursion problem in syntax normalizer</Title>
    <Description>This is a fix for #1066, #2076
</Description>
    <CreatedDate>20/04/2015</CreatedDate>
    <ClosedDate>20/04/2015</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>2121</PullRequestID>
        <IssueID>1066</IssueID>
        <Title>Problem formatting .cs files</Title>
        <Description>There is a problem while formatting (indenting, adding/erasing whitespaces and/or newlines, etc.) directives such as #endregion, #pragma, etc..

The problem lies within the following classes/functions:
-SyntaxFormatter
-NormalizeWhitespaceCore
-NormalizeWhitespace

These functions are inconsistent with the CSharp compiler, which allows lines such as:

``` cs
#endregion foo
```

where the conventional way of doing this is:

``` cs
#endregion //foo
```

The formatting erases the whitespace after the directive, giving a non-compilable file like this:

``` cs
#endregionfoo &lt;--- here, having written "#endregion //foo" wouldn¬¥t cause any problem, because one would be getting a compilable "#endregion//foo"
```

Similar problem with #pragma, where an extra enter is erased while formatting the following:

``` cs
#pragma warning disable 123

namespace foo {
}

#pragma warning restore 123
```

one gets the following non-compilable code:

``` cs
#pragma warning disable 123
namespace foo {
}#pragma warning restore 123  &lt;--- extra enter erased here, after the closing bracket
```
</Description>
        <CreatedDate>06/03/2015</CreatedDate>
        <ClosedDate>23/04/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>2121</PullRequestID>
        <IssueID>2076</IssueID>
        <Title>Weird Formatting Issue With String Interpolation</Title>
        <Description>When I parse code that contains string interpolation, I end up getting formatting issues that leave the resulting code in a state that cannot be compiled.

To reproduce, create a "Compiler Platform Console Application" in VS2015 CTP6, and put the following code into Program.cs:

``` C#
using System;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

namespace StringInterpolationIssue
{
    class Program
    {
        static void Main(string[] args)
        {
            var code =
@"public class MyClass
{
    public string Foo(int a)
    {
        return $""Message is {a}"";
   }
}";

            var tree = SyntaxFactory.ParseSyntaxTree(code)
                .GetCompilationUnitRoot().NormalizeWhitespace();

            Console.Out.WriteLine(tree);
        }
    }
}
```

What I see in the console window is this:

```
public class MyClass
{
    public string Foo(int a)
    {
        return $"Message is
        {
        a
        }

        ";
    }
}
Press any key to continue . . .
```

If I copy the class code into a CS file, I get 5 compilation errors.

Note that if I take out the call to NormalizeWhitespace() the code is fine (but then I lose the whitespace normalization).
</Description>
        <CreatedDate>17/04/2015</CreatedDate>
        <ClosedDate>23/04/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>2121</PullRequestID>
      <File>src/Compilers/CSharp/Portable/Syntax/CSharpSyntaxNode.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/SyntaxExtensions.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/SyntaxNormalizer.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Syntax/SyntaxFactoryTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Syntax/SyntaxFormatterTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Syntax/SyntaxNormalizerTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>1117</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Disable Array.Empty params array optimization in expression lambdas</Title>
    <Description>Fixes #1103.  Or more specifically, #1103 represents two issues: that we do the Array.Empty optimization for params arrays in the expression lambda, and that this optimization does not kick in when compiling expression lambdas... this fix addresses the former but not the latter.

The actual fix is a one-line trivial change.  In terms of tests, there's actually already a test for this case, but as it compiles against an earlier mscorlib that lacks Array.Empty, it passes even before the fix.  I augmented the test to also try to run it on a newer mscorlib, but since the Roslyn test suite doesn't yet contain the metadata for mscorlib 4.6, I use the mscorlib on which the test is running as a substitute (thanks to @jaredpar for the suggestion); worst case is the test isn't running on 4.6 and it passes but doesn't verify what we wanted it to.  I did verify that on 4.6 the test fails before the product fix and passes after it.
</Description>
    <CreatedDate>07/03/2015</CreatedDate>
    <ClosedDate>09/03/2015</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>1117</PullRequestID>
        <IssueID>1103</IssueID>
        <Title>Array.Empty&lt;T&gt;() optimization issues</Title>
        <Description>``` c#
using System;
using System.Linq.Expressions;

namespace System {
    public static class Array {
        public static T[] Empty&lt;T&gt;() =&gt; new T[0];
    }
}

public class C {
    public static void M(params int[] xs) {
        // expression tree with empty-arguments-params-call
        Expression&lt;Action&gt; f = () =&gt; M();
    }
}
```

Produces this code:

``` c#
public class C {
    public static void M(params int[] xs) {
        Expression.Lambda&lt;Action&gt;(
            Expression.Call(null, methodof(C.M(int[])), new Expression[] {
                Expression.Call(null, methodof(System.Array.Empty()), new Expression[0])
            }),
            new ParameterExpression[0]);
    }
}
```
1. This C# 6.0 change can break various LINQ quotation translators, since nobody knows what `System.Array.Empty&lt;T&gt;` method actually do and how to translate it. We should disable this optimization inside expression trees.
2. When expression tree code is lowered, we can see a lot of `new Expression[0]` or `new ParameterExpression[0]` expressions (passed to `params` parameters) produced - exactly the cases for this optimization.
</Description>
        <CreatedDate>06/03/2015</CreatedDate>
        <ClosedDate>09/03/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>1117</PullRequestID>
        <IssueID>1103</IssueID>
        <Title>Array.Empty&lt;T&gt;() optimization issues</Title>
        <Description>``` c#
using System;
using System.Linq.Expressions;

namespace System {
    public static class Array {
        public static T[] Empty&lt;T&gt;() =&gt; new T[0];
    }
}

public class C {
    public static void M(params int[] xs) {
        // expression tree with empty-arguments-params-call
        Expression&lt;Action&gt; f = () =&gt; M();
    }
}
```

Produces this code:

``` c#
public class C {
    public static void M(params int[] xs) {
        Expression.Lambda&lt;Action&gt;(
            Expression.Call(null, methodof(C.M(int[])), new Expression[] {
                Expression.Call(null, methodof(System.Array.Empty()), new Expression[0])
            }),
            new ParameterExpression[0]);
    }
}
```
1. This C# 6.0 change can break various LINQ quotation translators, since nobody knows what `System.Array.Empty&lt;T&gt;` method actually do and how to translate it. We should disable this optimization inside expression trees.
2. When expression tree code is lowered, we can see a lot of `new Expression[0]` or `new ParameterExpression[0]` expressions (passed to `params` parameters) produced - exactly the cases for this optimization.
</Description>
        <CreatedDate>06/03/2015</CreatedDate>
        <ClosedDate>09/03/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>1117</PullRequestID>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_Call.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenExprLambdaTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>1115</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Provide explicit `StringComparison.Ordinal` in invocations of Xunit methods</Title>
    <Description>**MAIN CHANGES:**
- Fix #1108. Provide explicit `StringComparison.Ordinal` in invocations of Xunit methods `Assert.Contains` and `Assert.DoesNotContain`
- Unskip test `CommandLineTests.PreferredUILang`

**ALSO:**
- Fix a typo in a comment: "reversed" -&gt; "reserved"
- Remove unnecessary `string.Trim()` invocations
- Remove unnecessary `using` directives

See the explanation of these changes in #1108.
</Description>
    <CreatedDate>07/03/2015</CreatedDate>
    <ClosedDate>09/03/2015</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>1115</PullRequestID>
        <IssueID>1108</IssueID>
        <Title>CommandLineTests.PreferredUILang fails on some machines</Title>
        <Description>There is a reported test failure that occurs on certain machines. It is likely a culture-related issue. It does not reproduce on my machine, but I have an idea what might cause it. The test is currently skipped due to a different bug.

```
Test 'Microsoft.CodeAnalysis.CSharp.CommandLine.UnitTests.CommandLineTests.PreferredUILang' failed: Assert.Contains() failure:

Not found: CS2038

In value: Microsoft (R) Visual C# Compiler version 42.42.42.42

Copyright (C) Microsoft Corporation. All rights reserved.

warning CS2008: No source files specified.

error CS1562: Outputs without source must have the /out option specified

C:\R1\Open\src\Compilers\CSharp\Test\CommandLine\CommandLineTests.cs(6258,0): at Microsoft.CodeAnalysis.CSharp.CommandLine.UnitTests.CommandLineTests.PreferredUILang()
```

&lt;br&gt;&lt;sup&gt;Also tracked as DevDiv 1119609.&lt;/sup&gt;

&lt;!---
@huboard:{"milestone_order":1108.0}
--&gt;
</Description>
        <CreatedDate>06/03/2015</CreatedDate>
        <ClosedDate>06/05/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>1115</PullRequestID>
        <IssueID>1108</IssueID>
        <Title>CommandLineTests.PreferredUILang fails on some machines</Title>
        <Description>There is a reported test failure that occurs on certain machines. It is likely a culture-related issue. It does not reproduce on my machine, but I have an idea what might cause it. The test is currently skipped due to a different bug.

```
Test 'Microsoft.CodeAnalysis.CSharp.CommandLine.UnitTests.CommandLineTests.PreferredUILang' failed: Assert.Contains() failure:

Not found: CS2038

In value: Microsoft (R) Visual C# Compiler version 42.42.42.42

Copyright (C) Microsoft Corporation. All rights reserved.

warning CS2008: No source files specified.

error CS1562: Outputs without source must have the /out option specified

C:\R1\Open\src\Compilers\CSharp\Test\CommandLine\CommandLineTests.cs(6258,0): at Microsoft.CodeAnalysis.CSharp.CommandLine.UnitTests.CommandLineTests.PreferredUILang()
```

&lt;br&gt;&lt;sup&gt;Also tracked as DevDiv 1119609.&lt;/sup&gt;

&lt;!---
@huboard:{"milestone_order":1108.0}
--&gt;
</Description>
        <CreatedDate>06/03/2015</CreatedDate>
        <ClosedDate>06/05/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>1115</PullRequestID>
      <File>src/Compilers/CSharp/Test/CommandLine/CommandLineTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenIterators.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/UseSiteErrorTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/LexicalAndXml/CrefLexerTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/LexicalAndXml/NameAttributeValueLexerTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/LexicalAndXml/PreprocessorTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/DeclarationParsingTests.cs</File>
      <File>src/Compilers/Core/CodeAnalysisTest/CommonCommandLineParserTests.cs</File>
      <File>src/Compilers/Core/VBCSCompilerTests/CompilerServerTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/CodeActions/Preview/PreviewTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Interactive/NavigateTo/InteractiveNavigateToTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/NavigateTo/NavigateToTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Squiggles/ErrorSquiggleProducerTests.cs</File>
      <File>src/EditorFeatures/Test/Completion/AbstractCompletionProviderTests.cs</File>
      <File>src/Interactive/HostTest/InteractiveHostTests.cs</File>
      <File>src/Test/Utilities/AssertEx.cs</File>
      <File>src/Workspaces/CoreTest/WorkspaceTests/MSBuildWorkspaceTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>1113</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Increment BloomFilter serialization version</Title>
    <Description>When a BloomFilter is serialized, it includes a serialization format
version number, some other metadata, and a bitarray. Prior to PR #877,
the bitarray portion also included its own serialization format version
number, so the data serialized was Format 1 of the BloomFilter
containing Format 0 of the bitarray. PR #877 removed the (redundant)
serialization format version number from the bitarray portion but did
not also version the BloomFilter's serialization format, causing the
previous bitarray version number (0) to be read as part of the bitarray
itself. We believe this would sometimes lead to extremely long Find
References calls as the BloomFilter continually tried and failed to
understand the data in the bitarray.
</Description>
    <CreatedDate>07/03/2015</CreatedDate>
    <ClosedDate>07/03/2015</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>1113</PullRequestID>
        <IssueID>877</IssueID>
        <Title>Move serialization specific BitArray helpers to where they are used</Title>
        <Description>These helpers are only used when serializing BloomFilter. Move them there and remove an unnecessary "SerializationFormat" string written into the stream.
</Description>
        <CreatedDate>25/02/2015</CreatedDate>
        <ClosedDate>26/02/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>1113</PullRequestID>
        <IssueID>877</IssueID>
        <Title>Move serialization specific BitArray helpers to where they are used</Title>
        <Description>These helpers are only used when serializing BloomFilter. Move them there and remove an unnecessary "SerializationFormat" string written into the stream.
</Description>
        <CreatedDate>25/02/2015</CreatedDate>
        <ClosedDate>26/02/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>1113</PullRequestID>
      <File>src/Workspaces/Core/Portable/Shared/Utilities/BloomFilter_Serialization.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>1098</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Undo nuget upgrade</Title>
    <Description>This is an undo for PR #1077.  

There is an API change associated with this upgrade and it will require more extensive work to integrate into both Roslyn and Visual Studio.  Given the proximity to ZBB we decided to undo this change for now.  It will be reapplied next Thursday.  

Issue #1097 tracks reapplying this change.
</Description>
    <CreatedDate>06/03/2015</CreatedDate>
    <ClosedDate>06/03/2015</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>1098</PullRequestID>
        <IssueID>1077</IssueID>
        <Title>Upgrade BCL nuget packages to RC releases</Title>
        <Description>There are 3 parts:
- 6891c08  - (yawn) Version search and replace across _.config;_.nupsec;_.csproj;_.vbproj
- ae23df1 - Adjust to small breaking changes in System.Collections.Immutable
- a663279 - Adjust test expectation to correct projected version of System.Numerics.Vectors

cc @tmat @jaredpar @theoy @joshfree
</Description>
        <CreatedDate>06/03/2015</CreatedDate>
        <ClosedDate>06/03/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>1098</PullRequestID>
        <IssueID>1097</IssueID>
        <Title>Upgrade BCL NuGet Packages to RC</Title>
        <Description>Once we pass ZBB and have the bandwidth to update the BCL packages we need to re-merge this PR.  

https://github.com/dotnet/roslyn/pull/1077
</Description>
        <CreatedDate>06/03/2015</CreatedDate>
        <ClosedDate>22/04/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>1098</PullRequestID>
      <File>src/Compilers/CSharp/Portable/Symbols/ModuleSymbol.cs</File>
      <File>src/Compilers/Core/Desktop/CommandLine/CommonCompiler.cs</File>
      <File>src/Compilers/Core/Portable/Collections/ImmutableArrayExtensions.cs</File>
      <File>src/Compilers/Core/Portable/Collections/StaticCast.cs</File>
      <File>src/Compilers/Core/SharedCollections/ArrayBuilder.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>1026</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Fixing parentheses simplification in the presence of a conditional member access.</Title>
    <Description>Fixes #987

Giving the ConditionalMemberAcces the same precedence as member access while determining associativity fixes the issue.

In VB, removing parentheses simplification works fine. There is a case where cast simplfication doesn't work and I've filed #1025 to track that.
</Description>
    <CreatedDate>04/03/2015</CreatedDate>
    <ClosedDate>05/03/2015</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>1026</PullRequestID>
        <IssueID>987</IssueID>
        <Title>Inline Temporary Variable adds redundant parentheses for conditional access expression</Title>
        <Description>Ported from TFS WorkItem: &lt;b&gt;1091928&lt;/b&gt;

---

&lt;p&gt;&lt;b&gt;Repro Steps:&lt;/b&gt;&lt;/p&gt;

&lt;P&gt;1. Start with the following code:&lt;/P&gt;

``` csharp
class Program
{
    static void Main(string[] args)
    {
        var x = args.Length.ToString();
        var y = x?.ToString();
    }
}
```

&lt;P&gt;2. Apply Inline Temporary Variable on 'x'&lt;/P&gt;

&lt;P&gt;&lt;STRONG&gt;Expected Result:&lt;/STRONG&gt;&lt;/P&gt;

``` csharp
class Program
{
    static void Main(string[] args)
    {
        var y = args.Length.ToString()?.ToString();
    }
}
```

&lt;P&gt;&lt;STRONG&gt;Actual Result:&lt;/STRONG&gt;&lt;/P&gt;

``` csharp
class Program
{
    static void Main(string[] args)
    {
        var y = (args.Length.ToString())?.ToString();
    }
}
```
</Description>
        <CreatedDate>03/03/2015</CreatedDate>
        <ClosedDate>05/03/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>1026</PullRequestID>
        <IssueID>1025</IssueID>
        <Title>Inline temp doesn't remove casts in some specific cases in VB</Title>
        <Description>Try inlining `x` in the following code:

``` VB.NET
Class C
    Function M(args As String()) As Boolean
        Dim x = args(0)
        Return x?.Length = 0
    End Function
End Class
```

**Expected:**

``` VB.NET
Class C
    Function M(args As String()) As Boolean
        Return args(0)?.Length = 0
    End Function
End Class
```

**Actual:**

``` VB.NET
Class C
    Function M(args As String()) As Boolean
        Return CType(args(CInt(0)), String)?.Length = 0
    End Function
End Class
```
</Description>
        <CreatedDate>04/03/2015</CreatedDate>
        <ClosedDate>06/03/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>1026</PullRequestID>
      <File>src/EditorFeatures/CSharpTest/CodeActions/InlineTemporary/InlineTemporaryTests.cs</File>
      <File>src/Workspaces/CSharp/Portable/Extensions/ExpressionSyntaxExtensions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>983</IssueID>
    <RepoID>roslyn</RepoID>
    <Title>Better handle dismissed rename tracking sessions</Title>
    <Description>Fixes #540 "Stale rename entries in the lightbulb menu"

Prior to this change, dismissed rename tracking sessions continued to
provide codefixes which would silently fail when invoked, without
completing the rename operation.

With this change, we now do the following when rename tracking is
manually dismissed:
- Trigger the diagnostic service to reanalyze the document, thus
  removing the rename tracking diagnostic.
- Stop providing a codefix when requested
- Show a dialog if a cached codefix is invoked explaining that the
  rename was not performed.

Here are the there user scenarios:
1. The user dismisses rename tracking
- The lightbulb will continue to show in the margin, regardless of
  whether any codefix/refactoring is actually still available.
1. The user expands the lightbulb without it ever having been expanded
   before.
- In this case, we are queried for fixes and will not return any, so
  either the lightbulb will disappear or it will contain other relevant
  codefixes/refactorings at that position, excluding rename.
1. The user expands the lightbulb after it was previously expanded.
- Our fix was already cached, so we can only give a reasonable message
  when it is invoked.

Once #885 is fixed, we can instead implement IDiagnosticUpdateSource and
avoid forcing diagnostic reanalysis.
</Description>
    <CreatedDate>03/03/2015</CreatedDate>
    <ClosedDate>04/03/2015</ClosedDate>
    <Issues>
      <Issue>
        <PullRequestID>983</PullRequestID>
        <IssueID>540</IssueID>
        <Title>Stale rename entries in the lightbulb menu</Title>
        <Description>Ported from TFS WorkItem: **1125186**

---

**Repro Steps:**

**Affected Branch:**&amp;nbsp;vspro_1
 **Affected Build:**&amp;nbsp;22611
 **Affected Product Language:** 

**Steps to reproduce:**
1. paste the following code&lt;div&gt;
   &lt;/div&gt;&lt;div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; int M3(int x) { return x; }&lt;/div&gt;&lt;/div&gt;&lt;div&gt;
   &lt;/div&gt;&lt;div&gt;
2. change "x" in "return x;" to "xrenamed", note that the rectangle around xrenamed indicating the rename tracking&lt;/div&gt;&lt;div&gt;
3. press [ESC], note that the rectangle is gone&lt;/div&gt;&lt;div&gt;
4. Ctrl+[DOT]&lt;/div&gt;&lt;div&gt;
5. Select either rename option.&lt;/div&gt;&lt;div&gt;&lt;div&gt;
   &lt;/div&gt;&lt;div&gt;**Expected**:&lt;/div&gt;&lt;div&gt;x renamed to y,&lt;/div&gt;&lt;div&gt;or rename options shouldn't appear if the tracking is gone.&lt;/div&gt;&lt;div&gt;
   &lt;/div&gt;&lt;div&gt;**Actual**:&lt;/div&gt;&lt;/div&gt;&lt;div&gt;Nothing happened.&lt;/div&gt;

---

**Revisions:**

1) Created By Jeremy Meng (2/13/2015 10:54:57 AM)

---
</Description>
        <CreatedDate>16/02/2015</CreatedDate>
        <ClosedDate>04/03/2015</ClosedDate>
      </Issue>
      <Issue>
        <PullRequestID>983</PullRequestID>
        <IssueID>885</IssueID>
        <Title>Provide a way to recalculate Roslyn's lightbulb state/contents without solution change</Title>
        <Description>Related to bug #540 (with PR #770 &amp; #983)

For RenameTracking, we will clear the rename tracking diagnostic on Escape and trigger DiagnosticsUpdated, which will trigger SuggestedActionsSourceProvider.OnDiagnosticsUpdated. We need some way to trigger OnDiagnosticsUpdated to refresh its lightbulb state/contents without versioning the solution. One suggestion is to use a null value for DiagnosticsUpdatedArgs.Solution to indicate reanalysis, but we could certain add another flag to DiagnosticsUpdatedArgs or find some other approach.
</Description>
        <CreatedDate>26/02/2015</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <PullRequestID>983</PullRequestID>
      <File>src/EditorFeatures/Core/EditorFeaturesResources.Designer.cs</File>
      <File>src/EditorFeatures/Core/Implementation/RenameTracking/AbstractRenameTrackingCodeFixProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/RenameTracking/RenameTrackingTaggerProvider.RenameTrackingCodeAction.cs</File>
      <File>src/EditorFeatures/Core/Implementation/RenameTracking/RenameTrackingTaggerProvider.StateMachine.cs</File>
      <File>src/EditorFeatures/Core/Implementation/RenameTracking/RenameTrackingTaggerProvider.cs</File>
      <File>src/EditorFeatures/Test/RenameTracking/RenameTrackingTaggerProviderTests.cs</File>
      <File>src/EditorFeatures/Test/RenameTracking/RenameTrackingTestState.cs</File>
    </Files>
  </PullRequest>
</PullRequests>