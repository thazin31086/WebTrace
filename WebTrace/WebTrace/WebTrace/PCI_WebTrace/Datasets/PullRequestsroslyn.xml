<PullRequests>
  <PullRequest>
    <IssueID>41847</IssueID>
    <Title>Features/local function attributes</Title>
    <Description>Related to #38801

All commits in this PR have been reviewed. Everything is done except:
- dotnet/csharplang#3198 has not been merged yet
- #24135 has not been fixed yet (SpeculativeSemanticModel gives attribute class instead of attribute constructor on attributes inside a method body).

I wasn't able to determine a scenario where the IDE experience was significantly harmed by the speculative GetSymbolInfo returning the attribute class rather than the attribute constructor, and it's been difficult to figure out what needs to change in order to get the right behavior, so I'd like to punt on it until after merge.</Description>
    <CreatedDate>21/02/2020</CreatedDate>
    <ClosedDate>21/02/2020</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>38801</IssueID>
        <Title>Test plan for "local function attributes"</Title>
        <Description>Championed issue: dotnet/csharplang#1888

- [ ] Specification checked in to `csharplang`.
- [x] attribute on declaration
- [x] attributes on declaration are emitted
- [x] attribute on return type
- [x] attributes on return type are emitted
- [x] attribute on type parameters
- [x] attributes on type parameters are emitted
- [x] attribute on parameters
- [x] attributes on parameters are emitted
- [x] Correctness of `AttributeUsage`
  - [x] On declaration and return](https://github.com/dotnet/roslyn/blob/features/local-function-attributes/src/Compilers/CSharp/Test/Semantic/Semantics/LocalFunctionTests.cs#L631)
  - [x] On parameters and type parameters
- [x] interaction with potentially ambiguous syntax?
- [ ] speculative semantic model #24135
- [x] semantic model on attribute arguments for method/return/param/type param attributes
- [x] ~~expected diagnostics when binding a local function statement in speculative semantic model~~
  - Speculative semantic models don't give diagnostics
- [x] Scrub references (skipped tests and such) referencing this issue
- [x] test `Obsolete` attribute (and related)
  - [x] Diagnostics about attributes occur in local function locations
- [x] test `Conditional` attribute
  - [x] test `Conditional` with bad target method (non-void returning)
- [x] test various nullability attributes
- [x] test `[EnumeratorCancellation]` attribute on parameter of async-iterator local function #40959
- [x] MethodImplAttribute
- [x] DllImportAttribute
- [x] `static extern` local functions
- [x] local functions with no body
- [x] ExcludeFromCodeCoverageAttribute #41129 
- [x] MarshalAsAttribute #41299
- [x] SkipLocalsInitAttribute #41183
- [x] test restricted attributes such as IsReadOnlyAttribute, IsUnmanaged, ExtensionAttribute, etc.
- [x] Caller...Attribute #41299
- [x] LanguageVersion (tests added in #38808)
  - [x] Including in parameters
- [x] Scoping inside full syntax (See LookupTests.cs)
  - [x] Scoping for attribute lists on incomplete statements https://github.com/dotnet/roslyn/pull/41379#issuecomment-585453870
- [x] Can't use locals inside attribute creation, e.g. calling other local functions, using captured variables
  - [x] Local constants should probably be valid
  - [x] Attribute argument with declaration pattern
  - [x] Attribute argument with call containing 'out var'
  - [x] Attribute constructor with `out` parameter (disallowed)
     - [x] Out to a local
     - [x] Out var
- [x] Referencing local function with ConditionalAttribute only in a "dead" condition `#if` should not produce unused warning
- [x] ConditionalAttribute should be disallowed on non-static local functions #41333

IDE:
- [x] Test interactive typing
- [x] Start with an attribute
- [x] Completion
- [x] Keyword recommendation (`extern`)

Before merge:

- [x] ConditionalAttribute disallowed on non-static local functions #41333
- [x] IDE interactive testing
- [x] [AttributeUsage](https://github.com/dotnet/roslyn/blob/features/local-function-attributes/src/Compilers/CSharp/Test/Semantic/Semantics/LocalFunctionTests.cs#L631)
- [x] Prevent regressing EndToEndTests
- [ ] Draft spec checked into proposals, awaiting validation by Neal</Description>
        <CreatedDate>23/09/2019</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>3198</IssueID>
        <Title>Ensure SemanticModel reports node as a default instance access rather than as a type reference, when the type reference is reclassified as such.</Title>
        <Description>Addresses DevDiv 1169533.

@VSadov, @gafter, @agocke, @jaredpar, @khyperia Please review.
</Description>
        <CreatedDate>31/05/2015</CreatedDate>
        <ClosedDate>01/06/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>24135</IssueID>
        <Title>Speculative semantic model produces different behavior for local functions </Title>
        <Description>See the behavior in this test:

```csharp
        [Fact]
        public void LocalFunctionAttribute()
        {
            const string text = @"
using System;
class A : Attribute {}

class C
{
    static void M()
    {
        void local&lt;[A]T&gt;() {}
    }
}";
            var tree = SyntaxFactory.ParseSyntaxTree(text);
            var comp = CreateStandardCompilation(tree);
            var model = comp.GetSemanticModel(tree);
            var a = tree.GetRoot().DescendantNodes()
                .OfType&lt;IdentifierNameSyntax&gt;().ElementAt(2);
            Assert.Equal("A", a.Identifier.Text);
            var attrInfo = model.GetSymbolInfo(a);
            var attrType = comp.GlobalNamespace.GetTypeMember("A");
            var attrCtor = attrType.GetMember(".ctor");
            Assert.Equal(attrCtor, attrInfo.Symbol);

            // Assert that this is also true for the speculative semantic model
            var newTree = SyntaxFactory.ParseSyntaxTree(text + " ");
            var m = newTree.GetRoot()
                .DescendantNodes().OfType&lt;MethodDeclarationSyntax&gt;().Single();

            Assert.True(model.TryGetSpeculativeSemanticModelForMethodBody(m.Body.SpanStart, m, out model));

            a = newTree.GetRoot().DescendantNodes().OfType&lt;IdentifierNameSyntax&gt;().ElementAt(2);
            Assert.Equal("A", a.Identifier.Text);

            // If we aren't using the right binder here, the compiler crashes going through the binder factory
            var info = model.GetSymbolInfo(a);
            Assert.Equal(attrType, info.Symbol);
        }
```

When using the regular semantic model, the symbol returned by GetSymbolInfo is the attribute constructor. When using the speculative semantic model, the type is returned instead.

The root cause of this seems to be that `TryGetSpeculativeSemanticModelForMethodBody` directly returns a MethodBody semantic model, which bypasses the `GetMemberModel` call which may be needed to retrieve a more specific model (like an Attribute or InitializerSemanticModel) that may be needed to bind pieces of local functions.</Description>
        <CreatedDate>10/01/2018</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Statements.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/BoundLocalFunctionStatement.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/UnboundLambda.cs</File>
      <File>src/Compilers/CSharp/Portable/Compiler/MethodCompiler.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/ErrorCode.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/MessageID.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/NullableWalker.cs</File>
      <File>src/Compilers/CSharp/Portable/Generated/Syntax.xml.Internal.Generated.cs</File>
      <File>src/Compilers/CSharp/Portable/Generated/Syntax.xml.Main.Generated.cs</File>
      <File>src/Compilers/CSharp/Portable/Generated/Syntax.xml.Syntax.Generated.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/AsyncRewriter/AsyncRewriter.AsyncIteratorRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/Instrumentation/DynamicAnalysisInjector.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/LambdaRewriter.Analysis.Tree.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/LambdaRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/SynthesizedClosureMethod.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/SynthesizedMethodBaseSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/LanguageParser.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/MethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/LambdaSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/LocalFunctionSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceMemberMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceMethodSymbolWithAttributes.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceOrdinaryMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/SubstitutedTypeParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/SymbolExtensions.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedIntrinsicOperatorSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedSubstitutedTypeParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Wrapped/WrappedTypeParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/BlockSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/BreakStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/CheckedStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/ContinueStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/DoStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/EmptyStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/ExpressionStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/FixedStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/ForEachStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/ForEachVariableStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/ForStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/GotoStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/IfStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/LabeledStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/LocalDeclarationStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/LocalFunctionStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/LockStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/ReturnStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/StackAllocArrayCreationExpressionSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/SwitchStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/SyntaxFactory.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/ThrowStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/TryStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/UnsafeStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/UsingStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/WhileStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/YieldStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Attributes/AttributeTests_CallerInfoAttributes.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Attributes/AttributeTests_Experimental.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Attributes/AttributeTests_MarshalAs.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Attributes/AttributeTests_Security.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Attributes/AttributeTests_Synthesized.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Attributes/AttributeTests_WellKnownAttributes.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenAsyncIteratorTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenLocalFunctionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Emit/DynamicAnalysis/DynamicInstrumentationTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/LocalFunctionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/LookupTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/NullableReferenceTypesTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/OutVarTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/DefaultInterfaceImplementationTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/Source/EventTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/Source/NullablePublicAPITests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/SymbolErrorTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Generated/Syntax.Test.xml.Generated.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/IncrementalParsing/IncrementalParsingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/LocalFunctionParsingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/ParserErrorMessageTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/RoundTrippingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/StatementAttributeParsingTests.cs</File>
      <File>src/Compilers/Core/Portable/PEWriter/MetadataWriter.cs</File>
      <File>src/Compilers/Test/Utilities/CSharp/CSharpTestBase.cs</File>
      <File>src/EditorFeatures/CSharpTest2/Recommendations/AsyncKeywordRecommenderTests.cs</File>
      <File>src/EditorFeatures/CSharpTest2/Recommendations/ExternKeywordRecommenderTests.cs</File>
      <File>src/EditorFeatures/CSharpTest2/Recommendations/IntKeywordRecommenderTests.cs</File>
      <File>src/EditorFeatures/CSharpTest2/Recommendations/ReturnKeywordRecommenderTests.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Source/ExpressionCompiler/SyntaxHelpers.cs</File>
      <File>src/Features/CSharp/Portable/Completion/KeywordRecommenders/AsyncKeywordRecommender.cs</File>
      <File>src/Features/CSharp/Portable/Completion/KeywordRecommenders/ExternKeywordRecommender.cs</File>
      <File>src/Features/CSharp/Portable/Completion/KeywordRecommenders/ReturnKeywordRecommender.cs</File>
      <File>src/Features/CSharp/Portable/Completion/KeywordRecommenders/StaticKeywordRecommender.cs</File>
      <File>src/Features/CSharp/Portable/Completion/KeywordRecommenders/UnsafeKeywordRecommender.cs</File>
      <File>src/Features/CSharp/Portable/Completion/KeywordRecommenders/VoidKeywordRecommender.cs</File>
      <File>src/Test/Utilities/Portable/Traits/CompilerFeature.cs</File>
      <File>src/Tools/Source/CompilerGeneratorTools/Source/CSharpSyntaxGenerator/SourceWriter.cs</File>
      <File>src/Workspaces/CSharp/Portable/CodeGeneration/CSharpSyntaxGenerator.cs</File>
      <File>src/Workspaces/SharedUtilitiesAndExtensions/Workspace/CSharp/Extensions/ContextQuery/CSharpSyntaxContext.cs</File>
      <File>src/Workspaces/SharedUtilitiesAndExtensions/Workspace/CSharp/Extensions/ContextQuery/SyntaxTokenExtensions.cs</File>
      <File>src/Workspaces/SharedUtilitiesAndExtensions/Workspace/CSharp/Extensions/ContextQuery/SyntaxTreeExtensions.cs</File>
      <File>src/Workspaces/SharedUtilitiesAndExtensions/Workspace/CSharp/Utilities/SyntaxKindSet.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>41775</IssueID>
    <Title>Add shared resx files to our shared projects</Title>
    <Description>Extracted from #41363
Third follow-up item from #41462

Apart from adding resx files, changes also include:
1. Moving resource strings duplicated across Workspaces and CodeStyle layer into the shared resx files
2. Source file changes to use the resource strings from the shared resx.

We should no longer require use of `#if CODE_STYLE` in the shared layer for the purpose of resource strings.</Description>
    <CreatedDate>19/02/2020</CreatedDate>
    <ClosedDate>19/02/2020</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>41363</IssueID>
        <Title>Port few IDE analyzers/fixers to shared layer to be enabled in CodeStyle NuGet package</Title>
        <Description>**NOTE: More than half the changed files in this PR are xlf files and majority of source file changes are just using resources from a shared resx file. Strongly recommend reviewing with GitHub filter feature to collapse all xlf file changes: [Review Link](https://github.com/dotnet/roslyn/pull/41363/files?file-filters%5B%5D=.cs&amp;file-filters%5B%5D=.csproj&amp;file-filters%5B%5D=.json&amp;file-filters%5B%5D=.projitems&amp;file-filters%5B%5D=.sln&amp;file-filters%5B%5D=.targets&amp;file-filters%5B%5D=.txt&amp;file-filters%5B%5D=.vb&amp;file-filters%5B%5D=.vbproj)**

Following analyzers/fixers have been ported to the shared layer and will get enabled in CodeStyle NuGet package:
1. **Remove unused private members (IDE0051)**: An analyzer without options.
2. **C# make struct fields writable (IDE0064)**: Another simple analyzer without options.
3. **C# convert switch statement to expression (IDE0066)**: An analyzer with a C# code style option. Also includes refactoring of options infrastructure and test framework code to support option based analyzers and corresponding unit tests.
4. **C# use implicit or explicit type style analyzers (IDE0007 and IDE0008)**: Typical code style analyzers with bunch of utility types.
5. **Remove unnecessary usings/imports (IDE0005)**: Analyzer which used some language services, and is very commonly requested analyzer for CI enforcement.
_NOTE: This analyzer works on command line only if XML document comments are enabled for the project._ This seems to be a compiler bug (https://github.com/dotnet/roslyn/issues/41640): https://github.com/dotnet/roslyn/blob/41bc8954aa449ee96a0858de5f614f8a61fa2cad/src/Compilers/CSharp/Portable/Compilation/CSharpCompilation.cs#L2116-L2118

![CodeStyleAnalyzers](https://user-images.githubusercontent.com/10605811/74381230-ed06b500-4d9f-11ea-8c6c-4b9db762d2c6.png)

https://github.com/dotnet/roslyn/issues/41462 tracks follow-up items once this PR goes in.</Description>
        <CreatedDate>03/02/2020</CreatedDate>
        <ClosedDate>20/02/2020</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>41462</IssueID>
        <Title>Follow up items after PR 41363</Title>
        <Description>During the design meeting discussion on https://github.com/dotnet/roslyn/pull/41363, we decided to go ahead with the current approach in the PR with the following follow-up items:

- [ ] De-dupe analyzers and code fixes in IDE Features layer and Code Style layer inside the diagnostic analyzer and code fix engines. Currently, both the copies execute and we also see duplicate diagnostics being reported.
- [ ] Remove MEF based discovery of language services. Replace it with an explicit mapping from each language service to the type implementing it. We also need to design how external clients, similar to CodeStyle, can be supported, which means we may not be able to explicitly hardcode the assembly/types that implement the language services.
- [ ] Remove duplicated resources from CodeStyle and Workspaces/Features layer with a shared resource file. Need to wait on @tmat's change that simplifies resource generation in Roslyn.sln.
- [ ] Revert changes required to get existing IDE analyzer/fixer tests working in CodeStyle layer once all the tests are switched to `Microsoft.CodeAnalysis.Testing`:
  - [ ] Test framework files linked into CodeStyle.UnitTests projects
  - [ ] IVTs added from Roslyn test utilities and Workspaces to CodeStyle.UnitTests projects
- [ ] Move all our analyzers and fixers to work completely based on `AnalyzerConfigOptions` instead of `OptionSet`. This involves adding support for creating and passing a fallback .editorconfig/AnalyzerConfigOptions from Tools Options settings into analysis context.
- [ ] Remove use of `GetDocumentOptionSetAsync` API in the shared layer, which is currently used to get fallback Workspace options. Likely the work in prior bullet item will automatically take care of this, but adding an explicit cleanup item here so we validate that.
- [ ] Remove the TODOs added for code moved to shared layer which uses very recently added compiler APIs, which are not yet available in CodeStyle layer. For example, see [this](https://github.com/dotnet/roslyn/pull/41363/files?file-filters%5B%5D=.cs&amp;file-filters%5B%5D=.csproj&amp;file-filters%5B%5D=.targets&amp;file-filters%5B%5D=.txt&amp;file-filters%5B%5D=.vb#r376532640) comment.
- [ ] Remove all the `#if CODE_STYLE` from the shared projects. All of them should be possible to remove trivially, except the ones related to public Options related types (OptionSet, IOption, CodeStyleOption, CodeStyleOptions, NotificationOptions, etc.), which are public APIs in Workspaces layer but also need by the CodeStyle analyzers which do not have access to Workspaces.
- [ ] We have lot more scope of refactoring the existing extension methods and utilities in Workspaces layer and move them down into the shared layers. There is scope even to move lot of code in WorkspaceExtensions layer that is currently used by code fixes, but not specific to Workspaces itself, to be moved down to CompilerExtensions layer. This will likely be a continuous refactoring work item.
- [ ] `CodeAction.DocumentChangeAction` is used in IDE code fixes, and was replaced with a new type `CustomCodeActions` in shared layer. Do we want to get rid of the CustomCodeActions types completely? Do we want to avoid them just in CodeStyle layer but still use them for analyzers linked into Features? Latter will introduce `#if CODE_STYLE` clutter in each code fix file, which seems undesirable.
- [ ] Cleanup the API signature for `SytnaxEditorBasedCodeFixProvider.IncludeDiagnosticDuringFixAll` as per https://github.com/dotnet/roslyn/pull/41510#discussion_r377391657
- [ ] Remove `AbstractRemoveUnnecessaryImportsDiagnosticAnalyzer.IsRegularCommentOrDocComment` and directly call into syntax facts service once it is available in shared analyzer layer.
- [ ] Consider deleting `IGeneratedCodeRecognitionService.IsGeneratedCode` and moving all existing callers to `IGeneratedCodeRecognitionService.IsGeneratedCodeAsync` 
- [ ] Rationalize use of `SyntaxGenerator.GetGenerator(document)` versus `document.GetRequiredLanguageService&lt;SyntaxGenerator&gt;()` in our code base.</Description>
        <CreatedDate>06/02/2020</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Workspaces/Core/Portable/CodeFixes/CodeFixContext.cs</File>
      <File>src/Workspaces/Core/Portable/CodeStyle/CodeStyleOptions.cs</File>
      <File>src/Workspaces/Core/Portable/Shared/Extensions/ISolutionExtensions.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/Solution/SolutionState.cs</File>
      <File>src/Workspaces/SharedUtilitiesAndExtensions/Compiler/CSharp/CodeStyle/CSharpCodeStyleOptions.cs</File>
      <File>src/Workspaces/SharedUtilitiesAndExtensions/Compiler/Core/Utilities/CompilerUtilities/CompilerPathUtilities.cs</File>
      <File>src/Workspaces/SharedUtilitiesAndExtensions/Compiler/Core/Utilities/CompilerUtilities/ImmutableHashMap.cs</File>
      <File>src/Workspaces/SharedUtilitiesAndExtensions/Workspace/CSharp/Extensions/SyntaxTreeExtensions.cs</File>
      <File>src/Workspaces/SharedUtilitiesAndExtensions/Workspace/Core/CodeFixes/FixAll/FixAllState.cs</File>
      <File>src/Workspaces/SharedUtilitiesAndExtensions/Workspace/Core/CodeFixes/FixAllContextHelper.cs</File>
      <File>src/Workspaces/SharedUtilitiesAndExtensions/Workspace/Core/Extensions/DocumentExtensions.cs</File>
      <File>src/Workspaces/SharedUtilitiesAndExtensions/Workspace/Core/Extensions/ISolutionExtensions.cs</File>
      <File>src/Workspaces/SharedUtilitiesAndExtensions/Workspace/Core/Extensions/ProjectExtensions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>41079</IssueID>
    <Title>Filter identifier name simplification according to aliases and predefined types</Title>
    <Description>Extracted from #40746 and generalized to work with Visual Basic.

Baseline numbers (49a468ca83f5d61e8bcab9341398a86ccbd71690 + #41072):

```text
Found 24193 diagnostics in 97737ms (148431953600 bytes allocated)
Execution times (ms):
CSharpSimplifyTypeNamesDiagnosticAnalyzer:      1552142
  SimpleMemberAccessExpression: 917073ms to try simplifying 1383559 instances
  IdentifierName: 321246ms to try simplifying 2951512 instances
  GenericName: 127254ms to try simplifying 92323 instances
  QualifiedName: 60160ms to try simplifying 158084 instances
  QualifiedCref: 238ms to try simplifying 1245 instances
  AliasQualifiedName: 10ms to try simplifying 30 instances
VisualBasicSimplifyTypeNamesDiagnosticAnalyzer: 1528633
  SimpleMemberAccessExpression: 1098896ms to try simplifying 632418 instances
  IdentifierName: 272517ms to try simplifying 1197747 instances
  GenericName: 51408ms to try simplifying 32776 instances
  QualifiedName: 48384ms to try simplifying 62234 instances
```

Updated numbers (49a468ca83f5d61e8bcab9341398a86ccbd71690 + this pull request):

```text
Found 24202 diagnostics in 93467ms (141284021216 bytes allocated)
Execution times (ms):
CSharpSimplifyTypeNamesDiagnosticAnalyzer:      1601508
  SimpleMemberAccessExpression: 1237560ms to try simplifying 1383578 instances
  GenericName: 169917ms to try simplifying 92326 instances
  QualifiedName: 73563ms to try simplifying 158087 instances
  IdentifierName: 1724ms to try simplifying 10343 instances
  QualifiedCref: 340ms to try simplifying 1245 instances
  AliasQualifiedName: 10ms to try simplifying 30 instances
VisualBasicSimplifyTypeNamesDiagnosticAnalyzer: 1487597
  SimpleMemberAccessExpression: 1300676ms to try simplifying 632444 instances
  QualifiedName: 57909ms to try simplifying 62236 instances
  GenericName: 57496ms to try simplifying 32779 instances
  IdentifierName: 1739ms to try simplifying 4668 instances
```

📝 The increase in diagnostics is due to a bug in Simplify Type Names for the Visual Basic code `NameOf([Object])`. The apparent increase in analyzer execution time is noise caused by contested locks used for measuring the callbacks. The allocation numbers and end-to-end time improvements were consistent.

📝 In combination with #41072, **99.75%** of calls to `TrySimplify` were eliminated as unnecessary for `IdentifierNameSyntax`.</Description>
    <CreatedDate>19/01/2020</CreatedDate>
    <ClosedDate>22/01/2020</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>40746</IssueID>
        <Title>Improve performance of SimplifyTypeNames by 5x.</Title>
        <Description>This should be reviewed after https://github.com/dotnet/roslyn/pull/40544 goes in.

This PR introduces a change in the approach the simplify-type-names feature works.  Currently the feature is a standard syntax-node analyzer that effectively analyzes pretty much all identifiers in every file to see if they're simplifiable.  This is unsurprisingly quite expensive.

The approach taken here is to do the following:

1. replace the syntax-node-analysis with a semantic-model-analysis where we can analyze files in a single pass.
2. walk down the tree building up information to avoid having to even do analysis if there's no point to it.

For example, *today* every identifier is checked to see if it could possibly be replaced with an alias in scope.  This can trivially be avoided if, as we walk down the tree, we keep track of the names of types that have an alias to them.  i.e. if we see `using MyFoo = X.Foo`, then we only need to check identifiers called `Foo` to see if they could be aliased.

We only need to update these tracked names as we encounter them down the tree.  That happens vastly less times than the number of times we need to analyze some identifier.

Importantly, we still go through the core simplification system to determine if something is actually simplifiable.  THe new system does not make this determination.  It just attempts to call into the main system much less as it is very costly.

--

Using hte AnalyzerRunner on Roslyn.sln itself for CSharpSimplifyTypeNamesDiagnosticAnalyzer yields a change from:

```
CSharpSimplifyTypeNamesDiagnosticAnalyzer: 7386702   to
CSharpSimplifyTypeNamesDiagnosticAnalyzer: 1529353
```

An improvement of 5x.  There are likely other avenues for improvement.  However, my primary concern was safety and correctness.  in other words, the simplifier *feature* is still very conservative and will call into the simplifier *engine* every time it think there is a potential simplification it could perform.  

This is likely unnecessary in many cases as we could probably tell immediately in the feature taht things are safe.  However, this would likely involve duplicating some amount of simplification logic (which would then need to be kept in sync).  

This approach avoids taht (for now).  But does not limit further improvements that could be made here by refactoring the simplification engine and making is smarter and more reusable for situations like this.
</Description>
        <CreatedDate>04/01/2020</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>41072</IssueID>
        <Title>Avoid trying to simplify descendant identifier names</Title>
        <Description>These identifiers are already simplified as part of nodes further up the tree.

Extracted from #40746.

Baseline numbers (49a468ca83f5d61e8bcab9341398a86ccbd71690):

```text
Found 24193 diagnostics in 102883ms (150147571248 bytes allocated)
Execution times (ms):
CSharpSimplifyTypeNamesDiagnosticAnalyzer:      2190940
  SimpleMemberAccessExpression: 1170342ms to try simplifying 1383556 instances
  IdentifierName: 605398ms to try simplifying 4466446 instances
  GenericName: 146827ms to try simplifying 92323 instances
  QualifiedName: 68286ms to try simplifying 158081 instances
  QualifiedCref: 434ms to try simplifying 1245 instances
  AliasQualifiedName: 10ms to try simplifying 30 instances
VisualBasicSimplifyTypeNamesDiagnosticAnalyzer: 1764312
  SimpleMemberAccessExpression: 1236160ms to try simplifying 632416 instances
  IdentifierName: 353337ms to try simplifying 1860769 instances
  GenericName: 64360ms to try simplifying 32776 instances
  QualifiedName: 55078ms to try simplifying 62234 instances
```

Updated numbers (49a468ca83f5d61e8bcab9341398a86ccbd71690 + this pull request):

```text
Found 24193 diagnostics in 97737ms (148431953600 bytes allocated)
Execution times (ms):
CSharpSimplifyTypeNamesDiagnosticAnalyzer:      1552142
  SimpleMemberAccessExpression: 917073ms to try simplifying 1383559 instances
  IdentifierName: 321246ms to try simplifying 2951512 instances
  GenericName: 127254ms to try simplifying 92323 instances
  QualifiedName: 60160ms to try simplifying 158084 instances
  QualifiedCref: 238ms to try simplifying 1245 instances
  AliasQualifiedName: 10ms to try simplifying 30 instances
VisualBasicSimplifyTypeNamesDiagnosticAnalyzer: 1528633
  SimpleMemberAccessExpression: 1098896ms to try simplifying 632418 instances
  IdentifierName: 272517ms to try simplifying 1197747 instances
  GenericName: 51408ms to try simplifying 32776 instances
  QualifiedName: 48384ms to try simplifying 62234 instances
```</Description>
        <CreatedDate>18/01/2020</CreatedDate>
        <ClosedDate>21/01/2020</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>41072</IssueID>
        <Title>Avoid trying to simplify descendant identifier names</Title>
        <Description>These identifiers are already simplified as part of nodes further up the tree.

Extracted from #40746.

Baseline numbers (49a468ca83f5d61e8bcab9341398a86ccbd71690):

```text
Found 24193 diagnostics in 102883ms (150147571248 bytes allocated)
Execution times (ms):
CSharpSimplifyTypeNamesDiagnosticAnalyzer:      2190940
  SimpleMemberAccessExpression: 1170342ms to try simplifying 1383556 instances
  IdentifierName: 605398ms to try simplifying 4466446 instances
  GenericName: 146827ms to try simplifying 92323 instances
  QualifiedName: 68286ms to try simplifying 158081 instances
  QualifiedCref: 434ms to try simplifying 1245 instances
  AliasQualifiedName: 10ms to try simplifying 30 instances
VisualBasicSimplifyTypeNamesDiagnosticAnalyzer: 1764312
  SimpleMemberAccessExpression: 1236160ms to try simplifying 632416 instances
  IdentifierName: 353337ms to try simplifying 1860769 instances
  GenericName: 64360ms to try simplifying 32776 instances
  QualifiedName: 55078ms to try simplifying 62234 instances
```

Updated numbers (49a468ca83f5d61e8bcab9341398a86ccbd71690 + this pull request):

```text
Found 24193 diagnostics in 97737ms (148431953600 bytes allocated)
Execution times (ms):
CSharpSimplifyTypeNamesDiagnosticAnalyzer:      1552142
  SimpleMemberAccessExpression: 917073ms to try simplifying 1383559 instances
  IdentifierName: 321246ms to try simplifying 2951512 instances
  GenericName: 127254ms to try simplifying 92323 instances
  QualifiedName: 60160ms to try simplifying 158084 instances
  QualifiedCref: 238ms to try simplifying 1245 instances
  AliasQualifiedName: 10ms to try simplifying 30 instances
VisualBasicSimplifyTypeNamesDiagnosticAnalyzer: 1528633
  SimpleMemberAccessExpression: 1098896ms to try simplifying 632418 instances
  IdentifierName: 272517ms to try simplifying 1197747 instances
  GenericName: 51408ms to try simplifying 32776 instances
  QualifiedName: 48384ms to try simplifying 62234 instances
```</Description>
        <CreatedDate>18/01/2020</CreatedDate>
        <ClosedDate>21/01/2020</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Features/CSharp/Portable/Diagnostics/Analyzers/TypeSyntaxSimplifierWalker.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>40910</IssueID>
    <Title>Fix special handling of Winforms Reset method in IDE0051 (RemoveUnuse…</Title>
    <Description>…dMembers)

My previous fix to #30887 added special handling for special Winforms  method with prefix "ShouldSerialize" or "Reset". However, I incorrectly required both these methods to have boolean return type, while only the former should have boolean return. Reset methods needs to be void returning. This change fixes this case.

Fixes #38491 reported on developer community for this bug.</Description>
    <CreatedDate>11/01/2020</CreatedDate>
    <ClosedDate>11/01/2020</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>30887</IssueID>
        <Title>"Private members is unused" fires on ShouldSerializeXXX pattern</Title>
        <Description>#### Repro steps

``` VB
        &lt;VBDescription(My.Resources.Microsoft_VisualStudio_Editors_Designer.ConstantResourceIDs.PPG_WebReferenceNameDescription)&gt;
        &lt;MergableProperty(False)&gt;
        &lt;HelpKeyword("Folder Properties.FileName")&gt;
        Public Property Name() As String
            Get
                Try
                    Return _projectItem.Name
                Catch ex As Exception When Common.ReportWithoutCrash(ex, NameOf(Name), NameOf(WebReferenceComponent))
                    Return String.Empty
                End Try
            End Get
            Set(value As String)
                _projectItem.Name = value
                _page.OnWebReferencePropertyChanged(Me)
            End Set
        End Property

        ' Prevent using Bold Font in the property grid (the same style as other reference)
        Private Function ShouldSerializeName() As Boolean
            Return False
        End Function
```
#### Expected behavior
No warning on ShouldSerializeName()


#### Actual behavior
Severity	Code	Description	Project	File	Line	Suppression State
Message	IDE0051	Private member 'WebReferenceComponent.ShouldSerializeName' is unused.	Microsoft.VisualStudio.Editors	E:\project-system2\src\Microsoft.VisualStudio.Editors\PropPages\WebReferenceComponent.vb	41	Active


ShouldSerializeXXX is a pattern used by controls &amp; things that show up in the property grid that determines whether they are written to InitializeComponent for a WinForms component. The associated FxCop original rule has an exclusion for this.
</Description>
        <CreatedDate>30/10/2018</CreatedDate>
        <ClosedDate>08/11/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>38491</IssueID>
        <Title>winforms ResetPropertyName and ShouldSerializePropertyName incorrectly marked with IDE0051: Private member is unused</Title>
        <Description>_This issue has been moved from [a ticket on Developer Community](https://developercommunity.visualstudio.com/content/problem/678086/winforms-resetpropertyname-and-shouldserializeprop.html)._

---
https://github.com/binki/ShouldSerializeResetPropertyIde0051/blob/971f524e347c472da9157a6048c88335c82f5fe6/ShouldSerializeResetPropertyIde0051/UserControl1.cs#L31

https://docs.microsoft.com/en-us/dotnet/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods

When I have a member `void ResetX() {}` in a class inheriting from `System.Windows.Forms.Control` with a member `public object X { get; set; } `, Visual Studio incorrectly reports IDE0051 and provides a codefix to remove “unused code”. However, that method is actually discovered and called by Designer if the user right-clicks on the property in the PropertyGridView and selects Reset.

Visual Studio should know about the private members that winforms will discover and not mark them unused. It should, for example, find unused members that are unused because the property referenced by the naming convention is not found. For example, it should report `void ResetY() {}` as unused if there is no `public object Y { get; set; } `.

---
### Original Comments

#### Visual Studio Feedback System on 8/6/2019, 00:12 AM: 

&lt;p&gt;We have directed your feedback to the appropriate engineering team for further evaluation. The team will review the feedback and notify you about the next steps.&lt;/p&gt;


---
### Original Solutions
(no solutions)</Description>
        <CreatedDate>04/09/2019</CreatedDate>
        <ClosedDate>11/01/2020</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/RemoveUnusedMembers/RemoveUnusedMembersTests.cs</File>
      <File>src/Features/Core/Portable/RemoveUnusedMembers/AbstractRemoveUnusedMembersDiagnosticAnalyzer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>40896</IssueID>
    <Title>Use appropriate code fix title for IDE0059 for unnecessary compound a…</Title>
    <Description>…ssigment

Fixes #38507
Fixes #40483</Description>
    <CreatedDate>10/01/2020</CreatedDate>
    <ClosedDate>11/01/2020</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>38507</IssueID>
        <Title>IDE0059 has misleading auto-fix name / incorrect preview with unnecessary ??= assignment</Title>
        <Description>**Version Used**: 
3.4.0-beta1-19426-03+b18d90790da95b6862def56802fa4249e4868bb4

**Steps to Reproduce**:
```C#
class Program
{
    static void Main() { }

    static object M(object o) =&gt; o ??= new object();
}
```

**Expected Behavior**:
IDE0059 triggers about using `??=` instead of `??` here.

**Actual Behavior**:
![image](https://user-images.githubusercontent.com/2642209/64352426-040fd280-cfca-11e9-9d74-bf86dfa9b11f.png)

The good news is the auto-fix will correctly substitute the "??" for the "??=".  However, two issues:
1) It names the auto-fix "Use discard _", even though it won't.
2) The preview doesn't show either the old or the new code being transformed.</Description>
        <CreatedDate>05/09/2019</CreatedDate>
        <ClosedDate>11/01/2020</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>40483</IssueID>
        <Title>Unnecessary assignment warning which changes the result</Title>
        <Description>_This issue has been moved from [a ticket on Developer Community](https://developercommunity.visualstudio.com/content/problem/858406/unnecessary-assignment-warning-which-changes-the-r.html)._

---

```
using System;

class P
{
    public ref bool f(ref bool z, ref bool q)
    {
        z = ref q;
        return ref z;
    }
}

class Q
{
    static void F()
    {
        bool a = true;
        bool b = false;
        ref var r = ref new P().f(ref a, ref b);
        b = true;

Console.WriteLine(r);
    }

static void Main()
    {
        F();
    }
}
```

Message	IDE0059	Unnecessary assignment of a value to 'b'	

If you remove `b = true` then output is False an not True.

---
### Original Comments

#### Visual Studio Feedback System on 12/18/2019, 01:48 AM: 

&lt;p&gt;We have directed your feedback to the appropriate engineering team for further evaluation. The team will review the feedback and notify you about the next steps.&lt;/p&gt;

#### Visual Studio Feedback System on 12/18/2019, 03:43 PM: 

&lt;p&gt;This issue is currently being investigated. Our team will get back to you if either more information is needed, a workaround is available, or the issue is resolved.&lt;/p&gt;


---
### Original Solutions
(no solutions)</Description>
        <CreatedDate>19/12/2019</CreatedDate>
        <ClosedDate>11/01/2020</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/RemoveUnusedParametersAndValues/RemoveUnusedValueAssignmentTests.cs</File>
      <File>src/Features/Core/Portable/RemoveUnusedParametersAndValues/AbstractRemoveUnusedValuesCodeFixProvider.cs</File>
      <File>src/Workspaces/CSharp/Portable/Extensions/SyntaxNodeExtensions.cs</File>
      <File>src/Workspaces/CSharp/Portable/LanguageServices/CSharpSyntaxFactsService.cs</File>
      <File>src/Workspaces/Core/Portable/LanguageServices/SyntaxFactsService/ISyntaxFactsService.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>40862</IssueID>
    <Title>Revert "Improve the code gen for a conditional access on a readonly unconstrained field"</Title>
    <Description>Reverts #35979
Closes #40690 

We found that this change makes the compiler generate invalid IL in some cases. For now we have decided that the right thing to do is to back the change out while keeping the tests (adjusting for the IL now produced after reverting).

@YairHalberstadt sorry that we have to revert this. We would be happy to consider a future PR that restores this optimization while ensuring that more corner cases like the one in the linked issue are handled.</Description>
    <CreatedDate>09/01/2020</CreatedDate>
    <ClosedDate>13/01/2020</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>35979</IssueID>
        <Title>Improve the code gen for a conditional access on a readonly unconstrained field</Title>
        <Description>See #35319

This improves the codegen when we perform a conditional access on an unconstrained temp. The temp could be as a result of a read on a readonly field, or of a conditional access on the result of an intermediary expression.

This is my first PR on Emit, and I admit to having only a rough understanding of the intricacies of IL.

So if there's something obvious I missed, or a thousand more tests I need to add, please let me know.

The IL a conditional access on an unconstrained readonly field will now emit is:

```csharp
  .locals init (T V_0)
  IL_0000:  ldarg.0
  IL_0001:  ldfld      ""T Foo&lt;T&gt;.t""
  IL_0006:  stloc.0
  IL_0007:  ldloca.s   V_0
  IL_0009:  ldloc.0
  IL_000a:  box        ""T""
  IL_000f:  brtrue.s   IL_0015
  IL_0011:  pop
  IL_0012:  ldnull
  IL_0013:  br.s       IL_0020
  IL_0015:  constrained. ""T""
  IL_001b:  callvirt   ""string object.ToString()""
  IL_0020:  call       ""void System.Console.WriteLine(string)""
  IL_0025:  ret
```

which is functionally identical to the IL emitted for a read of an unconstrained readonly field, followed by a conditional access on that:

```csharp
  .locals init (T V_0) //temp
  IL_0000:  ldarg.0
  IL_0001:  ldfld      ""T Foo&lt;T&gt;.t""
  IL_0006:  stloc.0
  IL_0007:  ldloc.0
  IL_0008:  box        ""T""
  IL_000d:  brtrue.s   IL_0012
  IL_000f:  ldnull
  IL_0010:  br.s       IL_001f
  IL_0012:  ldloca.s   V_0
  IL_0014:  constrained. ""T""
  IL_001a:  callvirt   ""string object.ToString()""
  IL_001f:  call       ""void System.Console.WriteLine(string)""
  IL_0024:  ret
```

the only difference being, the first we load the receiver's address, and then pop it if it's null, the other we only load the receiver's address if its not null.</Description>
        <CreatedDate>26/05/2019</CreatedDate>
        <ClosedDate>28/08/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>40690</IssueID>
        <Title>System.AccessViolationException when invoking extension method on ValueTuple</Title>
        <Description># Issue Title

With .NET Core 3.1.100 we're getting a:
`Fatal error. System.AccessViolationException: Attempted to read or write protected memory. This is often an indication that other memory is corrupt.` 
when invoking an extension method on a field of a `ValueTuple`.

This was fine with .NET Core 3.0.100

# General

We're trying to update the Quantum Development Kit runtime from `3.0.100` to `3.1.100` and one of our tests is failing and crashing execution with the exception mentioned above. 

I have pinpoint the problem, it happens when we're trying to call an extension method (an extension for `object`) of a field of a ValueTuple if the field is a generic Type Parameter, for example:

```C#
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

namespace bug
{
    public static class Extension
    {
        public static String GetValue(this object value) =&gt; value?.ToString();
    }

    public partial class BGen&lt;__T__&gt;
    {
        public (Int64, __T__) Data { get; }

        public BGen((Int64, __T__) data)
        {
            this.Data = data;
        }

        internal String Value
        {
            get
            {
                /// This works fine:
                //var i2 = Data.Item2;
                //var q2 = i2?.GetValue();

                // This causes the AccessViolation:
                var q2 = Data.Item2?.GetValue();
                return q2;
            }
        }
    }
    
    class Program
    {
        static void Main(string[] args)
        {
            var i = new BGen&lt;string&gt;((0, "foo"));
            var r = i.Value;

            Console.WriteLine($"Hello World: {string.Join(',', r)}");
        }
    }
}
```

This happens on windows with version `3.1.100`. Works fine if downgrading to `3.0.100`.

</Description>
        <CreatedDate>26/12/2019</CreatedDate>
        <ClosedDate>13/01/2020</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/CodeGen/EmitExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenConditionalOperatorTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenShortCircuitOperatorTests.cs</File>
      <File>src/Compilers/CSharp/Test/WinRT/AnonymousTypesSymbolTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>40824</IssueID>
    <Title>Update AnalyzerRunner to include a netcoreapp3.0 target</Title>
    <Description>This is now blocked on:

#40885 
#40886 
#40888 
</Description>
    <CreatedDate>08/01/2020</CreatedDate>
    <ClosedDate>11/01/2020</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>40885</IssueID>
        <Title>Avoid setting BuildingInsideVisualStudio on .NET Core builds</Title>
        <Description>Fixes errors loading projects when run on .NET Core.

Related to microsoft/msbuild#5045</Description>
        <CreatedDate>10/01/2020</CreatedDate>
        <ClosedDate>10/01/2020</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>40886</IssueID>
        <Title>Use the most recent instance when registering MSBuildLocator</Title>
        <Description>
        </Description>
        <CreatedDate>10/01/2020</CreatedDate>
        <ClosedDate>10/01/2020</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>40888</IssueID>
        <Title>Add /compilerStats option for AnalyzerRunner</Title>
        <Description>Prints a table of all compiler diagnostics after solution load.

Example:

```
  Hidden CS8019: 6461 instances (Unnecessary using directive)
  Hidden CS8020: 4 instances (Unused extern alias)
  Hidden BC50001: 4777 instances (Unused import statement)
  Error CS0103: 218 instances (The name '{0}' does not exist in the current context)
  Error CS1061: 59 instances ('{0}' does not contain a definition for '{1}' and no accessible extension method '{1}' accepting a first argument of type '{0}' could be found (are you missing a using directive or an assembly reference?))
  Error BC30311: 1 instances (Value of type '{0}' cannot be converted to '{1}'.)
  Error BC30451: 89 instances ('{0}' is not declared. It may be inaccessible due to its protection level.)
  Error BC30057: 1 instances (Too many arguments to '{0}'.)
```</Description>
        <CreatedDate>10/01/2020</CreatedDate>
        <ClosedDate>10/01/2020</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Tools/AnalyzerRunner/CodeRefactoringRunner.cs</File>
      <File>src/Tools/AnalyzerRunner/DiagnosticAnalyzerRunner.cs</File>
      <File>src/Tools/AnalyzerRunner/LooseAssemblyVersionLoader.cs</File>
      <File>src/Tools/AnalyzerRunner/PerformanceTracker.cs</File>
      <File>src/Tools/AnalyzerRunner/Program.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>40748</IssueID>
    <Title>Improve error message for CS0191</Title>
    <Description>Fixes #16982 

This PR is a rebase of #22874. I know it's been dormant for 2 years but the fix is still relevant. 

Improves the error message for CS0191 with more explanation for the issue. </Description>
    <CreatedDate>05/01/2020</CreatedDate>
    <ClosedDate>06/01/2020</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>16982</IssueID>
        <Title>Improve the error message for compiler error CS0191</Title>
        <Description>**Version Used**: 
VS 2015 Community 14.0.25431.01 Update 3, .NET 4.6.01586

**Steps to Reproduce**:
1. Create a class 'A' with a readonly field 'foo'.
2. Create a class 'B' which derives from class 'A'.
3. Attempt to assign a value to 'foo' in the constructor of 'B'.

**Expected Behavior**:
"A readonly field cannot be assigned to (except in the constructor of the class in which the field is defined or a variable initializer)"

**Actual Behavior**:
"A readonly field cannot be assigned to (except in a constructor or a variable initializer)"

The error message as it stands is wrong/ incomplete, which is confusing.</Description>
        <CreatedDate>06/02/2017</CreatedDate>
        <ClosedDate>06/01/2020</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22874</IssueID>
        <Title>Improved error message for CS0191</Title>
        <Description>Fixes #16982

Improved Error Message</Description>
        <CreatedDate>26/10/2017</CreatedDate>
        <ClosedDate>17/05/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/CSharpResources.Designer.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTupleTest.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/ObjectAndCollectionInitializerTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/SemanticAnalyzerTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/SemanticErrorTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>40330</IssueID>
    <Title>Pass in the "isGeneratedCode" flag from editorconfig options into syn…</Title>
    <Description>…tax tree parse APIs in command line compiler and IDE syntax tree factory service and IGeneratedCodeRecognitionService.

Builds on top of #39051
Addresses #3705</Description>
    <CreatedDate>12/12/2019</CreatedDate>
    <ClosedDate>17/12/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>39051</IssueID>
        <Title>Add API for marking a syntax tree as generated</Title>
        <Description>Provides API to fix #3705.</Description>
        <CreatedDate>04/10/2019</CreatedDate>
        <ClosedDate>19/11/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>3705</IssueID>
        <Title>Exclude files or folder from running through the analyzers through a configuration file.</Title>
        <Description>Hi,

we have a lot of generated files that trigger warnings, errors when analyzers run them.
since the file name of the generated files do not follow the common naming conventions for generated code roslyn fires the analyzers away. As a result there are ten of thousands of warnings in the solution.
Could we get a exclude file from analyzing logic that:
- Exclude a file by adding it to a exclusion list
- Exclude a file by adding it to a exclusion list
- Annotate classes with a special Attribute that exclude the class
- exclude certain file name extensions ( like js files generated by typescript)
- Combination of the above like exclude all js files that live under the folder x including all sub folders

Most of the rules come straight from Resharper's exclusion file manager

Thanks
</Description>
        <CreatedDate>26/06/2015</CreatedDate>
        <ClosedDate>20/12/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/CommandLine/CSharpCompiler.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/SyntaxFactory.cs</File>
      <File>src/Compilers/CSharp/Test/CommandLine/CommandLineTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/NullableReferenceTypesTests.cs</File>
      <File>src/Compilers/Core/Portable/DiagnosticAnalyzer/AnalyzerDriver.cs</File>
      <File>src/Compilers/Core/Portable/InternalUtilities/GeneratedCodeUtilities.cs</File>
      <File>src/Workspaces/CSharp/Portable/LanguageServices/CSharpSyntaxTreeFactoryService.cs</File>
      <File>src/Workspaces/Core/Portable/GeneratedCodeRecognition/AbstractGeneratedCodeRecognitionService.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/Host/SyntaxTreeFactory/AbstractSyntaxTreeFactoryService.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/Host/SyntaxTreeFactory/ISyntaxTreeFactoryService.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/Solution/DocumentState.cs</File>
      <File>src/Workspaces/CoreTest/GeneratedCodeRecognitionTests.cs</File>
      <File>src/Workspaces/CoreTest/SolutionTests/SolutionTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>40284</IssueID>
    <Title>Fix extract local function bugs</Title>
    <Description>Fixes #40188 and fixes #40214

Previously, a fix for #40188 was opened in [this PR](https://github.com/dotnet/roslyn/pull/40265), but while working on the fix for #40214, I realized some of the code overlapped and thus decided to just merge everything into one PR. I have also addressed all the feedback from the initial PR.</Description>
    <CreatedDate>10/12/2019</CreatedDate>
    <ClosedDate>23/12/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>40188</IssueID>
        <Title>Extract method does not respect .editorconfig settings</Title>
        <Description>**Version Used**: 16.4.0 Preview 6.0

**Steps to Reproduce**:

1. Have .editorconfig containing ```csharp_style_expression_bodied_methods = true:silent```
2. With the following code:
```
class Program
{
    static void Main(string[] args)
    {
        bool b = true;
        System.Console.WriteLine(b != true ? b = true : b = false);
    }
}
```
highlight ```b != true``` and select the extract method code action.

**Expected Behavior**:
```
class Program
{
    static void Main(string[] args)
    {
        bool b = true;
        System.Console.WriteLine({|Rename:NewMethod|}(b) ? b = true : b = false);
    }

    private static bool NewMethod(bool b) =&gt; b != true;
}
```

**Actual Behavior**:
```
class Program
{
    static void Main(string[] args)
    {
        bool b = true;
        System.Console.WriteLine(NewMethod(b) ? b = true : b = false);
    }

    private static bool NewMethod(bool b)
    {
        return b != true;
    }
}
```
It seems that the issue involves extract method getting its options from the workspace rather than the document (thanks to @mavasani for helping figure this out).</Description>
        <CreatedDate>06/12/2019</CreatedDate>
        <ClosedDate>23/12/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>40214</IssueID>
        <Title>ExtractLocalFunction: code style for naming local functions isn't respected</Title>
        <Description>Currently, if you extract a block of code to a local function, the local function will be named using PascalCase convention, instead of honoring the user's preference.</Description>
        <CreatedDate>06/12/2019</CreatedDate>
        <ClosedDate>23/12/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>40188</IssueID>
        <Title>Extract method does not respect .editorconfig settings</Title>
        <Description>**Version Used**: 16.4.0 Preview 6.0

**Steps to Reproduce**:

1. Have .editorconfig containing ```csharp_style_expression_bodied_methods = true:silent```
2. With the following code:
```
class Program
{
    static void Main(string[] args)
    {
        bool b = true;
        System.Console.WriteLine(b != true ? b = true : b = false);
    }
}
```
highlight ```b != true``` and select the extract method code action.

**Expected Behavior**:
```
class Program
{
    static void Main(string[] args)
    {
        bool b = true;
        System.Console.WriteLine({|Rename:NewMethod|}(b) ? b = true : b = false);
    }

    private static bool NewMethod(bool b) =&gt; b != true;
}
```

**Actual Behavior**:
```
class Program
{
    static void Main(string[] args)
    {
        bool b = true;
        System.Console.WriteLine(NewMethod(b) ? b = true : b = false);
    }

    private static bool NewMethod(bool b)
    {
        return b != true;
    }
}
```
It seems that the issue involves extract method getting its options from the workspace rather than the document (thanks to @mavasani for helping figure this out).</Description>
        <CreatedDate>06/12/2019</CreatedDate>
        <ClosedDate>23/12/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>40214</IssueID>
        <Title>ExtractLocalFunction: code style for naming local functions isn't respected</Title>
        <Description>Currently, if you extract a block of code to a local function, the local function will be named using PascalCase convention, instead of honoring the user's preference.</Description>
        <CreatedDate>06/12/2019</CreatedDate>
        <ClosedDate>23/12/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/CodeActions/ExtractMethod/ExtractLocalFunctionTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/CodeActions/ExtractMethod/ExtractMethodTests.cs</File>
      <File>src/Features/CSharp/Portable/CodeRefactorings/ConvertLocalFunctionToMethod/CSharpConvertLocalFunctionToMethodCodeRefactoringProvider.cs</File>
      <File>src/Features/CSharp/Portable/ExtractMethod/CSharpMethodExtractor.CSharpCodeGenerator.ExpressionCodeGenerator.cs</File>
      <File>src/Features/CSharp/Portable/ExtractMethod/CSharpMethodExtractor.CSharpCodeGenerator.MultipleStatementsCodeGenerator.cs</File>
      <File>src/Features/CSharp/Portable/ExtractMethod/CSharpMethodExtractor.CSharpCodeGenerator.SingleStatementCodeGenerator.cs</File>
      <File>src/Features/CSharp/Portable/ExtractMethod/CSharpMethodExtractor.CSharpCodeGenerator.cs</File>
      <File>src/Features/CSharp/Portable/ExtractMethod/CSharpMethodExtractor.cs</File>
      <File>src/Features/Core/Portable/ExtractMethod/MethodExtractor.CodeGenerator.cs</File>
      <File>src/Features/Core/Portable/ExtractMethod/MethodExtractor.cs</File>
      <File>src/Workspaces/CSharp/Portable/CodeGeneration/CSharpCodeGenerationService.cs</File>
      <File>src/Workspaces/CSharp/Portable/CodeGeneration/MethodGenerator.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/CodeGenerationOptions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>40274</IssueID>
    <Title>Revert "Revert "Move to new API for GetSuggestedActions""</Title>
    <Description>Reverts dotnet/roslyn#40206 and restores functionality added in #39914. DDRIT failure that caused us to revert it seems unrelated to that PR.

</Description>
    <CreatedDate>10/12/2019</CreatedDate>
    <ClosedDate>10/12/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>40206</IssueID>
        <Title>Revert "Move to new API for GetSuggestedActions"</Title>
        <Description>Reverts dotnet/roslyn#39914

This PR broke DDRITs, likely from upgrading to newer package versions. Reverting to unblock insertion.</Description>
        <CreatedDate>06/12/2019</CreatedDate>
        <ClosedDate>06/12/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>39914</IssueID>
        <Title>Move to new API for GetSuggestedActions</Title>
        <Description>Editor team recently added a new GetSuggestedActions API overload that allows providing a more detailed operation scope message. This PR moves us to that API for Roslyn suggested actions. We now display the name of the executing analyzer/fixer/refactoring when user hits Ctrl + Dot to bring up the light bulb. This should help the users identify the slow extension and help us in improving performance of our analyzers/fixers/refactorings.

![GatheringSuggestions_SlowAnalyzer](https://user-images.githubusercontent.com/10605811/69291704-e7db0500-0bb8-11ea-92d0-f16719fabaf8.png)

![GatheringSuggestions_SlowCodeFixer](https://user-images.githubusercontent.com/10605811/69291714-ead5f580-0bb8-11ea-871e-317f343b897f.png)
</Description>
        <CreatedDate>21/11/2019</CreatedDate>
        <ClosedDate>06/12/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/DiagnosticAnalyzerDriver/DiagnosticAnalyzerDriverTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/DocumentationComments/DocumentationCommentTests.cs</File>
      <File>src/EditorFeatures/Core.Wpf/EditorFeaturesWpfResources.Designer.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Suggestions/SuggestedActionsSource.cs</File>
      <File>src/EditorFeatures/Core/EditorFeaturesResources.Designer.cs</File>
      <File>src/EditorFeatures/Core/Implementation/CodeFixes/CodeFixService.cs</File>
      <File>src/Features/Core/Portable/CodeFixes/ICodeFixService.cs</File>
      <File>src/Features/Core/Portable/CodeRefactorings/CodeRefactoringService.cs</File>
      <File>src/Features/Core/Portable/CodeRefactorings/ICodeRefactoringService.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/DiagnosticAnalyzerService.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/EngineV2/DiagnosticIncrementalAnalyzer_GetDiagnosticsForSpan.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/HostAnalyzerManager.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/IDiagnosticAnalyzerService.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>39644</IssueID>
    <Title>Follow-up on adding NullableAnnotation/WithNullableAnnotation APIs to ITypeSymbol.</Title>
    <Description>Related to #39641.
Related to #39643.</Description>
    <CreatedDate>01/11/2019</CreatedDate>
    <ClosedDate>04/11/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>39641</IssueID>
        <Title>Microsoft.CodeAnalysis.CSharp.UnitTests.Editing.AddImportsTests.TestSafeWithMatchingSimpleNameInAllLocations started failing after ITypeSymbol.NullableAnnotation API was added.</Title>
        <Description>```ITypeSymbol.NullableAnnotation``` API was added in https://github.com/dotnet/roslyn/pull/39498 and TestSafeWithMatchingSimpleNameInAllLocations unit-test started failing in that PR. Presumably due to the fact that presence of NullableAnnotation affects the way symbols are matched by involved components.

Per request in https://github.com/dotnet/roslyn/pull/39498#discussion_r340840007, the base-line for the test is restored to the original state and the test is disabled.</Description>
        <CreatedDate>01/11/2019</CreatedDate>
        <ClosedDate>21/01/2020</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>39643</IssueID>
        <Title>Microsoft.CodeAnalysis.Shared.Utilities.SymbolEquivalenceComparer should be modified to properly deal with differences caused by nullability</Title>
        <Description>```ITypeSymbol.NullableAnnotation``` API was added in https://github.com/dotnet/roslyn/pull/39498 and some unit-test started failing in that PR due to the fact that SymbolEquivalenceComparer stopped treating some symbols equivalent when the only difference comes from NullableAnnotation.
A temporary workaround was added to AreEquivalent method to get tests passing, it is not guaranteed to handle all different situations that can arise in the real world. A more robust long term solution should be implemented instead.</Description>
        <CreatedDate>01/11/2019</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Workspaces/CSharpTest/CodeGeneration/AddImportsTests.cs</File>
      <File>src/Workspaces/Core/Portable/Shared/Utilities/SymbolEquivalenceComparer.EquivalenceVisitor.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>39596</IssueID>
    <Title>Hook up "Run Code Analysis" commands in Visual Studio to execute Rosl…</Title>
    <Description>…yn analyzers.

Closes #38051: Users can now use this command to force complete all the analyzers on a project/solution (includes NuGet based + VSIX based analyzers, including IDE code style analyzers).

Complements #39544: Users can now potentially disable continuous analyzer execution  during live analysis and instead execute them on demand with these commands.

Few things to note:
1. This change hooks up new "Run Code Analysis on ProjectName" menu commands for CPS based managed projects. These commands are already hooked up for csproj based legacy projects in StanCore, but that should eventually go away.
2. ~~This change only hooks up these new commands for top level Build and Analyze menus. Adding these to "Analyzer and Code Cleanup" context menus for project/solution in solution explorer is much trickier as the command groups are defined in StanCore. I will do so in a separate PR.~~ Implemented with https://github.com/dotnet/roslyn/pull/39596/commits/38e4eda41251b043d5a92d696506de38243db315
3. This change also exposes a "RunAnalyzers" API for StanCore, so we can trigger analyzer execution when user executes run code analysis on solution/csproj based project. There is a VS side [PR](https://devdiv.visualstudio.com/DevDiv/_git/VS/pullrequest/211392) that will consume this functionality to make the experience uniform across all "Run Code Analysis" commands.</Description>
    <CreatedDate>30/10/2019</CreatedDate>
    <ClosedDate>01/11/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>38051</IssueID>
        <Title>provide a way for users to run vsix analyzers on build</Title>
        <Description>some users want to run analyzers and see all issues before invoking fix all for the issues to understand/predict impacts before running fix all.

nuget analyzers work great for this scenario. since you can build to force run them. problem is vsix analyzers including built-in IDE analyzers. since the only way for users to see all issues is turning on full solution analysis and wait for them to run full-analysis.

the catch is our full solution analysis is not built for throughput but as low priority background work. what I mean by that is to reduce the impact on GC and VS UX, it runs on a  lower priority process with plenty of yield to VS to never interfere with VS operations. 

to mitigate this, users can explicitly build to force run analyzers for throughput. VBCSCompiler will run these analyzers for throughput. you can see that VBCSCompiler basically overtake all resources on the machine (100% CPU and IO) since it puts the priority on throughput than VS responsiveness.

but unfortunately, vsix analyzers won't participate in VBCSCompiler. leaving no choice for users to force run those.

we should provide a way to do so. it doesn't need to be VBCSCompiler but a way to force run those for throughput like how we do that for fix all. but to show issues to users.</Description>
        <CreatedDate>16/08/2019</CreatedDate>
        <ClosedDate>01/11/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>39544</IssueID>
        <Title>Respect RunAnalyzers and RunCodeAnalysisDuringLiveAnalysis project pr…</Title>
        <Description>…operties for VSIX analyzer execution

We recently added project properties for configuring analyzer execution during build and live analysis, see documentation [here](https://docs.microsoft.com/visualstudio/code-quality/disable-code-analysis). Currently, these properties are only respected for NuGet based analyzers. This PR adds support to respect these properties even for VSIX based analyzers, including the built-in IDE code style analyzers. https://github.com/dotnet/project-system/pull/5598 passes the required properties down to the Roslyn langauge service, and this PR consumes these properties and adds this support.

PS: @ryzngard I have shamelessly copied quite a bit of your implementation for `MaxSupportedLangVersion` support</Description>
        <CreatedDate>27/10/2019</CreatedDate>
        <ClosedDate>06/11/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Features/Core/Portable/Diagnostics/DiagnosticAnalyzerService.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/EngineV2/DiagnosticIncrementalAnalyzer.Executor.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/EngineV2/DiagnosticIncrementalAnalyzer_IncrementalAnalyzer.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/IDiagnosticAnalyzerService.cs</File>
      <File>src/VisualStudio/Core/Def/ExternalAccess/LegacyCodeAnalysis/Api/ILegacyCodeAnalysisVisualStudioDiagnosticAnalyzerServiceAccessor.cs</File>
      <File>src/VisualStudio/Core/Def/ExternalAccess/LegacyCodeAnalysis/LegacyCodeAnalysisVisualStudioDiagnosticAnalyzerServiceAccessor.cs</File>
      <File>src/VisualStudio/Core/Def/ID.RoslynCommands.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Diagnostics/IVisualStudioDiagnosticAnalyzerService.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Diagnostics/VisualStudioDiagnosticAnalyzerService.cs</File>
      <File>src/VisualStudio/Core/Def/RoslynPackage.cs</File>
      <File>src/VisualStudio/Core/Def/ServicesVSResources.Designer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>39584</IssueID>
    <Title>Fix Host Object Access in Interactive</Title>
    <Description>Fixes #39565
Fixes #39581
Fixes #39548

Note that instead of reporting `error CS8422: A static local function cannot contain a reference to 'this' or 'base'.` we instead report `error CS0120: An object reference is required for the non-static field, method, or property`

Given that this is an extremely edge scenario in scripting I think that's not too much of an issue?

Also fixing #39581 is a breaking change. I highly doubt it's one anyone's hit, but insofar as that's true, maybe there's no point fixing it?</Description>
    <CreatedDate>30/10/2019</CreatedDate>
    <ClosedDate>01/11/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>39565</IssueID>
        <Title>CreateDelegate throws exception on calling function with "out var x" (Regression in Microsoft.CodeAnalysis.CSharp.Scripting 3.3.1))</Title>
        <Description>**Version Used**: 
Issue can be reproduced with .net Core 2.2 or .net Core 3.0 (Not tested on older .net Core versions)
with Microsoft.CodeAnalysis.CSharp.Scripting 3.3.1 (Older versions of this package do work correctly)

**Steps to Reproduce**:
Run the following program:

```C#
using Microsoft.CodeAnalysis.CSharp.Scripting;
using Microsoft.CodeAnalysis.Scripting;
using System;

namespace CSharpScripting
{
    public class HelpResult{ }
    public class ExecutionContext
    {
        public bool TryGetFastHelp(out HelpResult helpResult)
        {
            helpResult = new HelpResult();
            return true;
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            ScriptOptions so = ScriptOptions.Default
                .AddReferences(AppDomain.CurrentDomain.GetAssemblies())
                .AddImports(new string[] {
                    "CSharpScripting"
              });

            string code = @"
            if(TryGetFastHelp(out var result)){
                Console.WriteLine(result);
            }
            return true;
            ";

            var script = CSharpScript.Create&lt;bool&gt;(code, globalsType: typeof(ExecutionContext), options: so);
            var d = script.CreateDelegate();
            d(new ExecutionContext()).Wait();
            Console.ReadLine();
        }
    }
}
```


**Expected Behavior**:
Runs without errors.

**Actual Behavior**:
Throws exception on line `var d = script.CreateDelegate()` with message: **only methods, properties, fields and events can take a receiver (Parameter 'symbol')**

This code works fine with versions of Microsoft.CodeAnalysis.CSharp.Scripting **prior** to 3.3.1
This has been reproduced with .net Core 2.2 and .net Core 3.0

For version 3.3.1 one can explicitly mention the type as a workaround and no exception will be thrown: replace `TryGetFastHelp(out var result)` with `TryGetFastHelp(out HelpResult result)` 




</Description>
        <CreatedDate>29/10/2019</CreatedDate>
        <ClosedDate>01/11/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>39581</IssueID>
        <Title>C# Interactive static local can invoke instance method on global</Title>
        <Description>**Version Used**: VS 16.4 preview 2, Microsoft.CodeAnalysis.Scripting.CSharp v 3.3.1

**Steps to Reproduce**:

Run the following:
```csharp
using Microsoft.CodeAnalysis.CSharp.Scripting;
using Microsoft.CodeAnalysis.Scripting;

public class ExecutionContext
{
	public bool TryGetValue(out object obj)
	{
		obj = new object();
		return true;
	}
}

class Program
{
	static async System.Threading.Tasks.Task Main(string[] args)
	{
		var options = ScriptOptions.Default
			.AddReferences(typeof(ExecutionContext).Assembly);

		var code = @"
			bool M()
			{
				return Inner();
				static bool Inner()
				{
					if(TryGetValue(out var result)){
					    _ = result;
					}
					return true;
				}
			}
			return M();
            ";

		await CSharpScript.RunAsync&lt;bool&gt;(code, globalsType: typeof(ExecutionContext), options: options, globals: new ExecutionContext());
	}
}
```

**Expected Behavior**:

error CS8422: A static local function cannot contain a reference to 'this' or 'base'.

Note that you do get `error CS0120: An object reference is required for the non-static field, method, or property 'ExecutionContext.TryGetValue(out object)'` when you run the following:

```csharp
using Microsoft.CodeAnalysis.CSharp.Scripting;
using Microsoft.CodeAnalysis.Scripting;

public class ExecutionContext
{
	public bool TryGetValue(out object obj)
	{
		obj = new object();
		return true;
	}
}

class Program
{
	static async System.Threading.Tasks.Task Main(string[] args)
	{
		var options = ScriptOptions.Default
			.AddReferences(typeof(ExecutionContext).Assembly);

		var code = @"
			static bool M()
			{
				if(TryGetValue(out var result)){
				    _ = result;
				}
				return true;
			}
			return M();
            ";

		await CSharpScript.RunAsync&lt;bool&gt;(code, globalsType: typeof(ExecutionContext), options: options, globals: new ExecutionContext());
	}
}
```

**Actual Behavior**:

No error</Description>
        <CreatedDate>30/10/2019</CreatedDate>
        <ClosedDate>01/11/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>39548</IssueID>
        <Title>C# pattern match crashes VS 2019</Title>
        <Description>_This issue has been moved from [a ticket on Developer Community](https://developercommunity.visualstudio.com/content/problem/784408/c-pattern-match-crashes-vs-2019.html)._

---
In VS 2019 16.3.5, or 16.4P2, open C# interactive and type the following:
```
var x = (false, 4);
x is (false, var y)
```
Press enter after `;`
Expected the second expression to evaluate to `true`,
but instead right after typing the last `)` VS hangs then restarts.

---
### Original Comments

#### Visual Studio Feedback System on 10/20/2019, 11:01 PM: 

&lt;p&gt;We have directed your feedback to the appropriate engineering team for further evaluation. The team will review the feedback and notify you about the next steps.&lt;/p&gt;

#### Visual Studio Feedback System on 10/21/2019, 10:11 AM: 

&lt;p&gt;This issue is currently being investigated. Our team will get back to you if either more information is needed, a workaround is available, or the issue is resolved.&lt;/p&gt;

#### Visual Studio Feedback System on 10/21/2019, 10:23 AM: 

&lt;p&gt;We have directed your feedback to the appropriate engineering team for further evaluation. The team will review the feedback and notify you about the next steps.&lt;/p&gt;

#### Robert Larkins on 10/27/2019, 11:04 PM: 

&lt;p&gt;I was able to replicate this on 16.3.6.&lt;/p&gt;


---
### Original Solutions
(no solutions)</Description>
        <CreatedDate>28/10/2019</CreatedDate>
        <ClosedDate>01/11/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>39581</IssueID>
        <Title>C# Interactive static local can invoke instance method on global</Title>
        <Description>**Version Used**: VS 16.4 preview 2, Microsoft.CodeAnalysis.Scripting.CSharp v 3.3.1

**Steps to Reproduce**:

Run the following:
```csharp
using Microsoft.CodeAnalysis.CSharp.Scripting;
using Microsoft.CodeAnalysis.Scripting;

public class ExecutionContext
{
	public bool TryGetValue(out object obj)
	{
		obj = new object();
		return true;
	}
}

class Program
{
	static async System.Threading.Tasks.Task Main(string[] args)
	{
		var options = ScriptOptions.Default
			.AddReferences(typeof(ExecutionContext).Assembly);

		var code = @"
			bool M()
			{
				return Inner();
				static bool Inner()
				{
					if(TryGetValue(out var result)){
					    _ = result;
					}
					return true;
				}
			}
			return M();
            ";

		await CSharpScript.RunAsync&lt;bool&gt;(code, globalsType: typeof(ExecutionContext), options: options, globals: new ExecutionContext());
	}
}
```

**Expected Behavior**:

error CS8422: A static local function cannot contain a reference to 'this' or 'base'.

Note that you do get `error CS0120: An object reference is required for the non-static field, method, or property 'ExecutionContext.TryGetValue(out object)'` when you run the following:

```csharp
using Microsoft.CodeAnalysis.CSharp.Scripting;
using Microsoft.CodeAnalysis.Scripting;

public class ExecutionContext
{
	public bool TryGetValue(out object obj)
	{
		obj = new object();
		return true;
	}
}

class Program
{
	static async System.Threading.Tasks.Task Main(string[] args)
	{
		var options = ScriptOptions.Default
			.AddReferences(typeof(ExecutionContext).Assembly);

		var code = @"
			static bool M()
			{
				if(TryGetValue(out var result)){
				    _ = result;
				}
				return true;
			}
			return M();
            ";

		await CSharpScript.RunAsync&lt;bool&gt;(code, globalsType: typeof(ExecutionContext), options: options, globals: new ExecutionContext());
	}
}
```

**Actual Behavior**:

No error</Description>
        <CreatedDate>30/10/2019</CreatedDate>
        <ClosedDate>01/11/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Expressions.cs</File>
      <File>src/Scripting/CSharpTest/InteractiveSessionTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>39570</IssueID>
    <Title>Support non-monotonic transfer for local functions</Title>
    <Description>Local function flow analysis has always been special-cased for definite
assignment, and specifically for definite assignment with monotonic
assignment. This change implements the same non-monotonic tracking that
we use for try-finally for local functions. This is a conservative
analysis, meaning that certain rare cases may not transfer as much
information as possible. It's currently assumed that these cases are
rare enough to not be frustrating. No safety problems should be present
in the conservative analysis.

Fixes #14400
Fixes #14214</Description>
    <CreatedDate>29/10/2019</CreatedDate>
    <ClosedDate>01/11/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>14400</IssueID>
        <Title>DataFlowsOut vs local functions</Title>
        <Description>The region analysis API `DataFlowsOut` is not computed correctly when the region is inside a local function. Below is a test case suitable for addition to `RegionAnalysisTests.cs`. The line testing `DataFlowsOut` fails (it returns an empty set rather than the correct result, `"x"`).

``` cs
        [Fact]
        public void AssignmentInsideLocal()
        {
            var dataFlowAnalysisResults = CompileAndAnalyzeDataFlowStatements(@"
class Program
{
    static void Main()
    {
        int x = 3, y = 4;
        void Local()
        {
/*&lt;bind&gt;*/
            x = 1;
/*&lt;/bind&gt;*/
        }
        Local();
        System.Console.WriteLine(x);
    }
}
");
            Assert.Equal(null, GetSymbolNamesJoined(dataFlowAnalysisResults.VariablesDeclared));
            Assert.Equal("x", GetSymbolNamesJoined(dataFlowAnalysisResults.AlwaysAssigned));
            Assert.Equal(null, GetSymbolNamesJoined(dataFlowAnalysisResults.DataFlowsIn));
            Assert.Equal("x", GetSymbolNamesJoined(dataFlowAnalysisResults.DataFlowsOut));
            Assert.Equal(null, GetSymbolNamesJoined(dataFlowAnalysisResults.ReadInside));
            Assert.Equal("x", GetSymbolNamesJoined(dataFlowAnalysisResults.ReadOutside));
            Assert.Equal("x", GetSymbolNamesJoined(dataFlowAnalysisResults.WrittenInside));
            Assert.Equal("x, y", GetSymbolNamesJoined(dataFlowAnalysisResults.WrittenOutside));
            Assert.Equal("x", GetSymbolNamesJoined(dataFlowAnalysisResults.Captured));
        }
```
</Description>
        <CreatedDate>09/10/2016</CreatedDate>
        <ClosedDate>01/11/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>14214</IssueID>
        <Title>Flow analysis APIs do not work with local functions</Title>
        <Description>Due to the recent changes to data flow analysis with local functions, the flow analysis APIs now sometimes return an incorrect result or crash. Here are tests:

``` cs
        [Fact]
        public void FlowAPI01()
        {
            var analysisResults = CompileAndAnalyzeControlAndDataFlowStatements(@"
class C {
    static short Main()
    {
        short x = 0, y = 1, z = 2;
/*&lt;bind&gt;*/
        Local();
        void Local()
        {
            x++; y--;
        }
/*&lt;/bind&gt;*/
        return y;
    }
}
");
            var controlFlowAnalysisResults = analysisResults.Item1;
            var dataFlowAnalysisResults = analysisResults.Item2;
            Assert.Equal(0, controlFlowAnalysisResults.EntryPoints.Count());
            Assert.Equal(0, controlFlowAnalysisResults.ExitPoints.Count());
            Assert.Equal(0, controlFlowAnalysisResults.ReturnStatements.Count());
            Assert.True(controlFlowAnalysisResults.StartPointIsReachable);
            Assert.True(controlFlowAnalysisResults.EndPointIsReachable);
            Assert.Equal(null, GetSymbolNamesJoined(dataFlowAnalysisResults.VariablesDeclared));
            Assert.Equal("x, y", GetSymbolNamesJoined(dataFlowAnalysisResults.AlwaysAssigned));
            Assert.Equal("x, y", GetSymbolNamesJoined(dataFlowAnalysisResults.DataFlowsIn));
            Assert.Equal("y", GetSymbolNamesJoined(dataFlowAnalysisResults.DataFlowsOut));
            Assert.Equal("x, y", GetSymbolNamesJoined(dataFlowAnalysisResults.ReadInside));
            Assert.Equal("y", GetSymbolNamesJoined(dataFlowAnalysisResults.ReadOutside));
            Assert.Equal("x, y", GetSymbolNamesJoined(dataFlowAnalysisResults.WrittenInside));
            Assert.Equal("x, y, z", GetSymbolNamesJoined(dataFlowAnalysisResults.WrittenOutside));
        }

        [Fact]
        public void FlowAPI02()
        {
            var analysisResults = CompileAndAnalyzeControlAndDataFlowStatements(@"
class C {
    static short Main()
    {
        short x = 0, y = 1, z = 2;
/*&lt;bind&gt;*/
        Local();
/*&lt;/bind&gt;*/
        void Local()
        {
            x++; y--;
        }
        return y;
    }
}
");
            var controlFlowAnalysisResults = analysisResults.Item1;
            var dataFlowAnalysisResults = analysisResults.Item2;
            Assert.Equal(0, controlFlowAnalysisResults.EntryPoints.Count());
            Assert.Equal(0, controlFlowAnalysisResults.ExitPoints.Count());
            Assert.Equal(0, controlFlowAnalysisResults.ReturnStatements.Count());
            Assert.True(controlFlowAnalysisResults.StartPointIsReachable);
            Assert.True(controlFlowAnalysisResults.EndPointIsReachable);
            Assert.Equal(null, GetSymbolNamesJoined(dataFlowAnalysisResults.VariablesDeclared));
            Assert.Equal("x, y", GetSymbolNamesJoined(dataFlowAnalysisResults.AlwaysAssigned));
            Assert.Equal("x, y", GetSymbolNamesJoined(dataFlowAnalysisResults.DataFlowsIn));
            Assert.Equal("y", GetSymbolNamesJoined(dataFlowAnalysisResults.DataFlowsOut));
            Assert.Equal("x, y", GetSymbolNamesJoined(dataFlowAnalysisResults.ReadInside));
            Assert.Equal("x, y", GetSymbolNamesJoined(dataFlowAnalysisResults.ReadOutside));
            Assert.Equal("x, y", GetSymbolNamesJoined(dataFlowAnalysisResults.WrittenInside));
            Assert.Equal("x, y, z", GetSymbolNamesJoined(dataFlowAnalysisResults.WrittenOutside));
        }
```
</Description>
        <CreatedDate>30/09/2016</CreatedDate>
        <ClosedDate>01/11/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/AbstractFlowPass.ILocalState.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/AbstractFlowPass.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/AbstractFlowPass_LocalFunctions.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/ControlFlowPass.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/DefiniteAssignment.LocalFunctions.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/DefiniteAssignment.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/NullableWalker.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/FlowAnalysis/RegionAnalysisTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>39556</IssueID>
    <Title>Support nullability codefix for default, ternary, conditional expressions</Title>
    <Description>Fixes: #39422
Fixes: #39420
Fixes: #39423</Description>
    <CreatedDate>28/10/2019</CreatedDate>
    <ClosedDate>17/12/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>39422</IssueID>
        <Title>CS8603 code fix should support conditional access operator</Title>
        <Description>**Version Used**: 16.4 Preview 2

**Steps to Reproduce**:

```csharp
string Method(bool? value)
{
  return value?.ToString();
}
```

Apply a code fix for CS8603 on the conditional operator.

**Expected Behavior**:

```csharp
string? Method(bool? value)
{
  return value?.ToString();
}
```

**Actual Behavior**:

No code fix is provided.

📝 The code fix should use a unique Equivalence Key for this situation.</Description>
        <CreatedDate>21/10/2019</CreatedDate>
        <ClosedDate>17/12/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>39420</IssueID>
        <Title>CS8603 code fix should support ternary expressions with explicit null</Title>
        <Description>**Version Used**: 16.4 Preview 2

**Steps to Reproduce**:

```csharp
string Method(bool value) {
  return value ? "text" : null;
}
```

Apply a code fix for CS8603 on the return statement.

**Expected Behavior**:

```csharp
string? Method(bool value) {
  return value ? "text" : null;
}
```

**Actual Behavior**:

No code fix is provided.</Description>
        <CreatedDate>21/10/2019</CreatedDate>
        <ClosedDate>17/12/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>39423</IssueID>
        <Title>CS8603 code fix should support default expressions and literals</Title>
        <Description>**Version Used**: 16.4 Preview 2

**Steps to Reproduce**:

```csharp
string Method1()
{
  return default(string);
}

string Method2()
{
  return default;
}
```

Apply a code fix on each `return` statement.

**Expected Behavior**:

```csharp
string? Method1()
{
  return default(string);
}

string? Method2()
{
  return default;
}
```

**Actual Behavior**:

No code fix is provided.
</Description>
        <CreatedDate>21/10/2019</CreatedDate>
        <ClosedDate>17/12/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/Nullable/CSharpDeclareAsNullableCodeFixTests.cs</File>
      <File>src/Features/CSharp/Portable/CodeFixes/Nullable/CSharpDeclareAsNullableCodeFixProvider.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>39450</IssueID>
    <Title>Enable logging of informational telemetry for analyzers/fixers/refact…</Title>
    <Description>…orings executed during Ctrl + .

If user enables informational RoslynEventSource telemetry following the steps at https://aka.ms/reportPerf, we log the execution times for each analyzer/fixer/refactorings when computing the code fixes and refactorings to show in the light bulb. This will help us identify slow analyzers/fixers/refactorings that lead to UI delays with "Gathering suggestions" dialog.



**Customer and scenario info**
**Who is impacted by this bug?**
Users seeing UI delays on Ctrl + . to bring up the light bulb cannot provide actionable performance traces.

**Bugs fixed**
Additional telemetry to help diagnose VSO [#944957](https://devdiv.visualstudio.com/DevDiv/_workitems/edit/944957) in future

**What is the customer scenario and impact of the bug?**
We are seeing UI delays in Ctrl + . code path, where users see prolonged "Gathering suggestions" dialog. This delay can be caused by any IDE or third party extension (analyzer/fixer/refactoring) that run on this code path. Currently, we do not log telemetry to aid identifying the slow extension. This change allows users to provide actionable performance data for this code path.

**What is the workaround?**
N/A

**How was the bug found?**
UI delay VSO [#944957](https://devdiv.visualstudio.com/DevDiv/_workitems/edit/944957)

**If this fix is for a regression - what had regressed, when was the regression introduced, and why was the regression originally missed?**
This is a new top UI delay for 16.3. We are adding additional telemetry to help us investigate this better in future.

**Testing**
Verified the new telemetry is indeed logged.</Description>
    <CreatedDate>22/10/2019</CreatedDate>
    <ClosedDate>25/10/2019</ClosedDate>
    <Issues />
    <Files>
      <File>src/EditorFeatures/Core/Implementation/CodeFixes/CodeFixService.cs</File>
      <File>src/Features/Core/Portable/CodeRefactorings/CodeRefactoringService.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/EngineV2/DiagnosticIncrementalAnalyzer_GetDiagnosticsForSpan.cs</File>
      <File>src/Workspaces/Core/Portable/Log/EtwLogger.cs</File>
      <File>src/Workspaces/Core/Portable/Log/FunctionId.cs</File>
      <File>src/Workspaces/Core/Portable/Log/RoslynEventSource.LogBlock.cs</File>
      <File>src/Workspaces/Core/Portable/Log/RoslynEventSource.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/Host/SyntaxTreeFactory/AbstractSyntaxTreeFactoryService.AbstractRecoverableSyntaxRoot.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>39393</IssueID>
    <Title>Fix switch expression conversion creates broken code due to unspecific var return</Title>
    <Description>Fixes #38771, fixes #39363 and fixes #39171

Also changed the result of an existing test that seems to result in a compiler error.</Description>
    <CreatedDate>18/10/2019</CreatedDate>
    <ClosedDate>31/12/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>38771</IssueID>
        <Title>Switch expression conversion creates broken code due to unspecific var return</Title>
        <Description>_This issue has been moved from [a ticket on Developer Community](https://developercommunity.visualstudio.com/content/problem/725942/switch-expression-conversion-creates-broken-code-d.html)._

---
Hence the following code:

```cs
using System;

namespace ConsoleApp1
{
    interface IFruit { }
    class Apple : IFruit { }
    class Banana : IFruit { }

class Program
    {
        static void Main(string[] args)
        {
            IFruit fruit;
            switch (args[0])
            {
                case &amp;quot;apple&amp;quot;:
                    fruit = new Apple();
                    break;
                case &amp;quot;banana&amp;quot;:
                    fruit = new Banana();
                    break;
                default:
                    throw new InvalidOperationException(&amp;quot;Unknown fruit.&amp;quot;);
            }
            Console.WriteLine(fruit. ToString());
        }
    }
}
```

The switch expression conversion suggests creating the following code:
```
var fruit = (args[0]) switch // C8506 No best type was found for the switch expression.
{
    &amp;quot;apple&amp;quot; =&amp;gt; new Apple(),
    &amp;quot;banana&amp;quot; =&amp;gt; new Banana(),
    _ =&amp;gt; throw new InvalidOperationException(&amp;quot;Unknown fruit.&amp;quot;),
};
```

However, the use of `var` causes the error `No best type was found for the switch expression.` which should be `IFruit`. There is no helper to change `var` explicitly to `IFruit`. If the conversion would've taken the original declaration of `IFruit` or the nearest compatible type, there would have been no problem.
```cs
IFruit fruit = (args[0]) switch
{
    &amp;quot;apple&amp;quot; =&amp;gt; new Apple(),
    &amp;quot;banana&amp;quot; =&amp;gt; new Banana(),
    _ =&amp;gt; throw new InvalidOperationException(&amp;quot;Unknown fruit.&amp;quot;),
};
```

I don't expect helpers to create broken code; and it would be nice to have this fixed :-)

---
### Original Comments

#### Visual Studio Feedback System on 9/9/2019, 01:17 AM: 

&lt;p&gt;We have directed your feedback to the appropriate engineering team for further evaluation. The team will review the feedback and notify you about the next steps.&lt;/p&gt;


---
### Original Solutions
(no solutions)</Description>
        <CreatedDate>19/09/2019</CreatedDate>
        <ClosedDate>31/12/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>39363</IssueID>
        <Title>IDE0047 Remove unnecessary parentheses fails to appear for switch expressions</Title>
        <Description>**Version Used**: 16.4.0 P1

**Steps to Reproduce**:
1. Have a switch expression that contains unnecessary parentheses.
2. Pull up code fixes menu.

![switchbug](https://user-images.githubusercontent.com/16968319/67036612-c88c1c00-f0d0-11e9-8f15-333bcb19aabc.png)

![switchbug2](https://user-images.githubusercontent.com/16968319/67036734-fcffd800-f0d0-11e9-80df-067aaa6700e7.png)

**Expected Behavior**: Code fix option IDE0047 appears to remove unnecessary parentheses.

**Actual Behavior**: No code fix shown. IDE0047 does appear for the local variable declaration on line 16, so this seems to be an issue specific to switch expressions.
</Description>
        <CreatedDate>17/10/2019</CreatedDate>
        <ClosedDate>31/12/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>39171</IssueID>
        <Title>switch expression "no best type found" conflicts with IDE0007 C# use 'var' instead of explicit type</Title>
        <Description>_This issue has been moved from [a ticket on Developer Community](https://developercommunity.visualstudio.com/content/problem/759620/switch-expression-no-best-type-found-conflicts-wit.html)._

---
First of all I have a switch expression that returns instances of classes that all have a common superclass, so I would expect the switch expression to return the common superclass type instead of having a &amp;quot;no best type found&amp;quot; error.

Secondly, if I manually specify the type of the variable to put the result of the switch expression in, I get the IDE0007 suggestion.  If I follow the suggestion I'm back at the &amp;quot;no best type found&amp;quot; error.

---
### Original Comments

#### Visual Studio Feedback System on 10/7/2019, 02:19 AM: 

&lt;p&gt;We have directed your feedback to the appropriate engineering team for further evaluation. The team will review the feedback and notify you about the next steps.&lt;/p&gt;


---
### Original Solutions
(no solutions)</Description>
        <CreatedDate>09/10/2019</CreatedDate>
        <ClosedDate>31/12/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/ConvertSwitchStatementToExpression/ConvertSwitchStatementToExpressionTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/UseImplicitOrExplicitType/UseImplicitTypeTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/RemoveUnnecessaryParentheses/RemoveUnnecessaryParenthesesTests.cs</File>
      <File>src/Features/CSharp/Portable/ConvertSwitchStatementToExpression/ConvertSwitchStatementToExpressionCodeFixProvider.Rewriter.cs</File>
      <File>src/Features/CSharp/Portable/ConvertSwitchStatementToExpression/ConvertSwitchStatementToExpressionCodeFixProvider.cs</File>
      <File>src/Workspaces/CSharp/Portable/Extensions/ParenthesizedExpressionSyntaxExtensions.cs</File>
      <File>src/Workspaces/CSharp/Portable/Utilities/CSharpUseImplicitTypeHelper.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>38457</IssueID>
    <Title>Disable failing tests</Title>
    <Description>Related to #38454.

These tests fail in the CI runs for #38417 which adds translations for various resources. The problem is the test compares localized text with the original English text; this worked fine until now because the localized text wasn't yet translated, and so just happened to be the same as the English.

The point of this change is to unblock #38417.</Description>
    <CreatedDate>03/09/2019</CreatedDate>
    <ClosedDate>05/09/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>38454</IssueID>
        <Title>Suppressed diagnostic unit tests fail on Spanish runs</Title>
        <Description>The following unit tests (both C# and VB variants) fail on Spanish CI runs:

- TestSuppression_CompilerWarningAsError
- TestSuppression_CompilerParserWarningAsError
- TestSuppression_AnalyzerWarning
- TestSuppression_CompilerWarning
- TestSuppression_CompilerSemanticWarning
- TestSuppression_CompilerSyntaxWarning

The tests force the compiler output to English, but then they look up the expected text through `CodeAnalysisResources` which means they will get the Spanish version.

These tests will be disabled to unblock loc check-ins in release/dev16.3-vs-deps.</Description>
        <CreatedDate>03/09/2019</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>38417</IssueID>
        <Title>LOC CHECKIN | dotnet/roslyn release/dev16.3-vs-deps | 20190830</Title>
        <Description>
        </Description>
        <CreatedDate>30/08/2019</CreatedDate>
        <ClosedDate>06/09/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>38417</IssueID>
        <Title>LOC CHECKIN | dotnet/roslyn release/dev16.3-vs-deps | 20190830</Title>
        <Description>
        </Description>
        <CreatedDate>30/08/2019</CreatedDate>
        <ClosedDate>06/09/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Test/CommandLine/CommandLineTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>38441</IssueID>
    <Title>Move to a newer FlowAnalysis utilities package</Title>
    <Description>This addresses the memory leak in #38330. The underlying memory leak was fixed in the FlowAnalysis utilities assembly with https://github.com/dotnet/roslyn-analyzers/pull/2795. This PR just moves Roslyn to newer Flow analysis utilities package reference with the fix.

Fixes #38330</Description>
    <CreatedDate>01/09/2019</CreatedDate>
    <ClosedDate>03/09/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>38330</IssueID>
        <Title>[Regression] ServiceHub.RoslynCodeAnalysisService32.exe is OOMing multiple times a day</Title>
        <Description>**Version Used**: 
Version 16.3.0 Preview 3.0 [29221.207.master]

This is a regresssion, either because we've opt'd into more analyzers when we moved over to .editorconfig enforcement of analyzer levels, or because we're running on newer builds of VS.

**Steps to Reproduce**:

1. `git clone http://github.com/dotnet/project-system`
2. `cd project-system`
3. `git checkout 369551a45088071ec37673d11cfca67658c5ba25`
4. `ProjectSystem.sln`
5. Work for a couple of hours.

This occurs 3 or 4 times a day, and I've also experienced it in other codebases. I had a look at the watsons and every time this crashes its getting into a unique bucket due to the random nature of what frame the OOM is being thrown.

[internalshare]\\public\davkean\Roslyn\38330.zip</Description>
        <CreatedDate>28/08/2019</CreatedDate>
        <ClosedDate>04/09/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>38330</IssueID>
        <Title>[Regression] ServiceHub.RoslynCodeAnalysisService32.exe is OOMing multiple times a day</Title>
        <Description>**Version Used**: 
Version 16.3.0 Preview 3.0 [29221.207.master]

This is a regresssion, either because we've opt'd into more analyzers when we moved over to .editorconfig enforcement of analyzer levels, or because we're running on newer builds of VS.

**Steps to Reproduce**:

1. `git clone http://github.com/dotnet/project-system`
2. `cd project-system`
3. `git checkout 369551a45088071ec37673d11cfca67658c5ba25`
4. `ProjectSystem.sln`
5. Work for a couple of hours.

This occurs 3 or 4 times a day, and I've also experienced it in other codebases. I had a look at the watsons and every time this crashes its getting into a unique bucket due to the random nature of what frame the OOM is being thrown.

[internalshare]\\public\davkean\Roslyn\38330.zip</Description>
        <CreatedDate>28/08/2019</CreatedDate>
        <ClosedDate>04/09/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Features/Core/Portable/DisposeAnalysis/DisposableFieldsShouldBeDisposedDiagnosticAnalyzer.cs</File>
      <File>src/Features/Core/Portable/DisposeAnalysis/DisposeObjectsBeforeLosingScopeDiagnosticAnalyzer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>38394</IssueID>
    <Title>Properly detect whether an explicit event implementation in an interface is a WinRT event.</Title>
    <Description>Fixes #36532.
Closes #34658.</Description>
    <CreatedDate>29/08/2019</CreatedDate>
    <ClosedDate>30/08/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>36532</IssueID>
        <Title>SourceEventSymbol.ComputeIsWindowsRuntimeEvent is improperly handling WinRT events implemented in derived interfaces</Title>
        <Description>```
        private bool ComputeIsWindowsRuntimeEvent()
        {
            // Interface events don't override or implement other events, so they only
            // depend the output kind.
            if (this.containingType.IsInterfaceType())
            {
                return this.IsCompilationOutputWinMdObj();
            }
            ...
```
Now that we have DIM (Default Interface Methods), the comment "Interface events don't override or implement other events" is not accurate any more. Returning from the '''if``` in that case is likely cause an unexpected behavior of the compiler.</Description>
        <CreatedDate>18/06/2019</CreatedDate>
        <ClosedDate>30/08/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>34658</IssueID>
        <Title>Current set of Netstandard 3.0 reference assemblies doesn't include types required to emit async methods, this blocks some test scenarios</Title>
        <Description>See Microsoft.CodeAnalysis.CSharp.UnitTests.Symbols.DefaultInterfaceImplementationTests.MethodModifiers_18

Update (jcouv): the test produces
```
    (8,5): error CS0518: Predefined type 'System.Runtime.CompilerServices.AsyncTaskMethodBuilder' is not defined or imported
    (8,5): error CS0656: Missing compiler required member 'System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Create'
    (8,5): error CS0656: Missing compiler required member 'System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Task'
```</Description>
        <CreatedDate>01/04/2019</CreatedDate>
        <ClosedDate>30/08/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceEventSymbol.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/DefaultInterfaceImplementationTests.cs</File>
      <File>src/Test/Utilities/Portable/Mocks/TestReferences.cs</File>
      <File>src/Test/Utilities/Portable/TargetFrameworkUtil.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>38319</IssueID>
    <Title>Enable tests disabled due to changes in behavior in runtime.</Title>
    <Description>Fixes #32576. Fixes #33564.</Description>
    <CreatedDate>27/08/2019</CreatedDate>
    <ClosedDate>28/08/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>32576</IssueID>
        <Title>A number of C# and VB compiler unit-tests utilizing decimal numbers fail due to a baseline difference when run against netcoreapp3.0</Title>
        <Description>The issue for coreclr https://github.com/dotnet/coreclr/issues/22046

Microsoft.CodeAnalysis.CSharp.UnitTests.CodeGen.CodeGenIncrementTests.TestIncrementDecimal
Microsoft.CodeAnalysis.CSharp.UnitTests.CodeGen.CodeGenTests.DecimalBinaryOp_03
Microsoft.CodeAnalysis.CSharp.UnitTests.CodeGen.CodeGenTests.DecimalLiteral_BreakingChange
Microsoft.CodeAnalysis.VisualBasic.UnitTests.CodeGenTests.DecimalLiteral_BreakingChange
Microsoft.CodeAnalysis.VisualBasic.UnitTests.CodeGenTests.PreserveZeroDigitsInDecimal

The tests are temporarily disabled for CoreClr in DefaultInterfaceImplementation branch. Need to decide what to do about them.</Description>
        <CreatedDate>17/01/2019</CreatedDate>
        <ClosedDate>28/08/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>33564</IssueID>
        <Title>A number of C# and VB compiler unit-tests utilizing formatting of numbers fail in CI due to a baseline difference when run on CoreCLR against Microsoft.NETCore.App 3.0.0-preview4-27420-5. The formatting of numbers possibly became dependent on environment. </Title>
        <Description>The tests do not fail when I run them locally, but failed in CI (https://dev.azure.com/dnceng/public/_build/results?buildId=102071).
```
XUnit : error : Tests failed: F:\vsagent\1\s\artifacts\TestResults\Release\Microsoft.CodeAnalysis.VisualBasic.Emit.UnitTests_netcoreapp2.1_x64.html [netcoreapp2.1|x64] [F:\vsagent\1\s\src\Compilers\VisualBasic\Test\Emit\Microsoft.CodeAnalysis.VisualBasic.Emit.UnitTests.vbproj]
XUnit : error : Tests failed: F:\vsagent\1\s\artifacts\TestResults\Release\Microsoft.CodeAnalysis.CSharp.Semantic.UnitTests_netcoreapp2.1_x64.html [netcoreapp2.1|x64] [F:\vsagent\1\s\src\Compilers\CSharp\Test\Semantic\Microsoft.CodeAnalysis.CSharp.Semantic.UnitTests.csproj]
XUnit : error : Tests failed: F:\vsagent\1\s\artifacts\TestResults\Release\Microsoft.CodeAnalysis.CSharp.Scripting.UnitTests_netcoreapp2.1_x64.html [netcoreapp2.1|x64] [F:\vsagent\1\s\src\Scripting\CSharpTest\Microsoft.CodeAnalysis.CSharp.Scripting.UnitTests.csproj]
XUnit : error : Tests failed: F:\vsagent\1\s\artifacts\TestResults\Release\Microsoft.CodeAnalysis.VisualBasic.Semantic.UnitTests_netcoreapp2.1_x64.html [netcoreapp2.1|x64] [F:\vsagent\1\s\src\Compilers\VisualBasic\Test\Semantic\Microsoft.CodeAnalysis.VisualBasic.Semantic.UnitTests.vbproj]
XUnit : error : Tests failed: F:\vsagent\1\s\artifacts\TestResults\Release\Microsoft.CodeAnalysis.CSharp.Syntax.UnitTests_netcoreapp2.1_x64.html [netcoreapp2.1|x64] [F:\vsagent\1\s\src\Compilers\CSharp\Test\Syntax\Microsoft.CodeAnalysis.CSharp.Syntax.UnitTests.csproj]
XUnit : error : Tests failed: F:\vsagent\1\s\artifacts\TestResults\Release\Microsoft.CodeAnalysis.VisualBasic.Syntax.UnitTests_netcoreapp2.1_x64.html [netcoreapp2.1|x64] [F:\vsagent\1\s\src\Compilers\VisualBasic\Test\Syntax\Microsoft.CodeAnalysis.VisualBasic.Syntax.UnitTests.vbproj]
XUnit : error : Tests failed: F:\vsagent\1\s\artifacts\TestResults\Release\Microsoft.CodeAnalysis.CSharp.Emit.UnitTests_netcoreapp2.1_x64.html [netcoreapp2.1|x64] [F:\vsagent\1\s\src\Compilers\CSharp\Test\Emit\Microsoft.CodeAnalysis.CSharp.Emit.UnitTests.csproj]
    0 Warning(s)
    7 Error(s)

XUnit : error : Tests failed: F:\vsagent\1\s\artifacts\TestResults\Debug\Microsoft.CodeAnalysis.CSharp.Emit.UnitTests_netcoreapp2.1_x64.html [netcoreapp2.1|x64] [F:\vsagent\1\s\src\Compilers\CSharp\Test\Emit\Microsoft.CodeAnalysis.CSharp.Emit.UnitTests.csproj]
XUnit : error : Tests failed: F:\vsagent\1\s\artifacts\TestResults\Debug\Microsoft.CodeAnalysis.CSharp.Syntax.UnitTests_netcoreapp2.1_x64.html [netcoreapp2.1|x64] [F:\vsagent\1\s\src\Compilers\CSharp\Test\Syntax\Microsoft.CodeAnalysis.CSharp.Syntax.UnitTests.csproj]
XUnit : error : Tests failed: F:\vsagent\1\s\artifacts\TestResults\Debug\Microsoft.CodeAnalysis.CSharp.Semantic.UnitTests_netcoreapp2.1_x64.html [netcoreapp2.1|x64] [F:\vsagent\1\s\src\Compilers\CSharp\Test\Semantic\Microsoft.CodeAnalysis.CSharp.Semantic.UnitTests.csproj]
XUnit : error : Tests failed: F:\vsagent\1\s\artifacts\TestResults\Debug\Microsoft.CodeAnalysis.VisualBasic.Emit.UnitTests_netcoreapp2.1_x64.html [netcoreapp2.1|x64] [F:\vsagent\1\s\src\Compilers\VisualBasic\Test\Emit\Microsoft.CodeAnalysis.VisualBasic.Emit.UnitTests.vbproj]
XUnit : error : Tests failed: F:\vsagent\1\s\artifacts\TestResults\Debug\Microsoft.CodeAnalysis.VisualBasic.Semantic.UnitTests_netcoreapp2.1_x64.html [netcoreapp2.1|x64] [F:\vsagent\1\s\src\Compilers\VisualBasic\Test\Semantic\Microsoft.CodeAnalysis.VisualBasic.Semantic.UnitTests.vbproj]
XUnit : error : Tests failed: F:\vsagent\1\s\artifacts\TestResults\Debug\Microsoft.CodeAnalysis.VisualBasic.Syntax.UnitTests_netcoreapp2.1_x64.html [netcoreapp2.1|x64] [F:\vsagent\1\s\src\Compilers\VisualBasic\Test\Syntax\Microsoft.CodeAnalysis.VisualBasic.Syntax.UnitTests.vbproj]
XUnit : error : Tests failed: F:\vsagent\1\s\artifacts\TestResults\Debug\Microsoft.CodeAnalysis.CSharp.Scripting.UnitTests_netcoreapp2.1_x64.html [netcoreapp2.1|x64] [F:\vsagent\1\s\src\Scripting\CSharpTest\Microsoft.CodeAnalysis.CSharp.Scripting.UnitTests.csproj]
    0 Warning(s)
    7 Error(s)
```

The tests are temporarily disabled for CoreClr in DefaultInterfaceImplementation branch. Need to decide what to do about them.

The test logs are attached:
[Windows CoreClr Release.zip](https://github.com/dotnet/roslyn/files/2890506/Windows.CoreClr.Release.zip)


[Windows CoreClr Debug.zip](https://github.com/dotnet/roslyn/files/2890497/Windows.CoreClr.Debug.zip)
</Description>
        <CreatedDate>21/02/2019</CreatedDate>
        <ClosedDate>28/08/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenIncrementTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/PDB/PDBConstantTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/ConstantTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Syntax/SyntaxFactoryTests.cs</File>
      <File>src/Scripting/CSharpTest/CommandLineRunnerTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>38288</IssueID>
    <Title>VB: Report access to members of an interface that are not supported by runtime.</Title>
    <Description>Fixes #35834. Fixes #35885.
Also addresses some scenarios related to #35824.</Description>
    <CreatedDate>26/08/2019</CreatedDate>
    <ClosedDate>30/08/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>35834</IssueID>
        <Title>VB DIM: An attempt to use protected method declared in an interface from code targeting desktop framework doesn't cause runtime capability error</Title>
        <Description>```
        &lt;Fact&gt;
        Public Sub MethodImplementation_27()

            Dim csSource =
"
public interface I1
{
    protected static string M1()
    {
        return ""I1.M1"";
    }
}
"
            Dim csCompiation = GetCSharpCompiation(csSource).EmitToImageReference()

            Dim source1 =
&lt;compilation&gt;
    &lt;file name="c.vb"&gt;&lt;![CDATA[
Public Class C
    Implements I1
    Shared Sub Main()
        System.Console.WriteLine(I1.M1())
    End Sub
End Class
]]&gt;&lt;/file&gt;
&lt;/compilation&gt;

            Dim comp1 = CreateCompilation(source1, options:=TestOptions.DebugExe, targetFramework:=TargetFramework.DesktopLatestExtended, references:={csCompiation})
            comp1.AssertTheseDiagnostics(
&lt;error&gt;
BC30390: 'I1.Function M1() As String' is not accessible in this context because it is 'Protected'.
        System.Console.WriteLine(I1.M1())
                                 ~~~~~
&lt;/error&gt;)
        End Sub
```

Expect to see an error similar to:
```
error CS8707: Target runtime doesn't support 'protected', 'protected internal', or 'private protected' accessibility for a member of an interface.
```

Observed: Only accessibility error is reported which will go away once https://github.com/dotnet/roslyn/issues/35827 is fixed.</Description>
        <CreatedDate>21/05/2019</CreatedDate>
        <ClosedDate>30/08/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>35885</IssueID>
        <Title>VB DIM: An attempt to use non virtual method with implementation declared in an interface from code targeting desktop framework should cause runtime capability error</Title>
        <Description>```
        &lt;Fact&gt;
        Public Sub MethodImplementation_31()

            Dim csSource =
"
public interface I1
{
    sealed string M1() =&gt; ""I1.M1"";
}
"
            Dim csCompiation = GetCSharpCompiation(csSource).EmitToImageReference()

            Dim source1 =
&lt;compilation&gt;
    &lt;file name="c.vb"&gt;&lt;![CDATA[
Public Class C
    Shared Sub Main()
        Dim i1 as I1 = New Test()
        i1.M1()
    End Sub
End Class

Class Test
    Implements I1
End Class
]]&gt;&lt;/file&gt;
&lt;/compilation&gt;

            Dim comp1 = CreateCompilation(source1, options:=TestOptions.DebugExe, targetFramework:=TargetFramework.DesktopLatestExtended, references:={csCompiation})
            ' Expect an error similar to - error CS8501: Target runtime doesn't support default interface implementation.
            comp1.AssertTheseDiagnostics()
        End Sub
```</Description>
        <CreatedDate>22/05/2019</CreatedDate>
        <ClosedDate>30/08/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>35824</IssueID>
        <Title>VB DIM: No error is reported for an attempt to implement an inaccessible interface method</Title>
        <Description>```
        &lt;Fact&gt;
        Public Sub MethodImplementation_07()

            Dim csSource =
"
public interface I1
{
    internal void M1();
}
"
            Dim csCompiation = GetCSharpCompiation(csSource).EmitToImageReference()

            Dim source1 =
&lt;compilation&gt;
    &lt;file name="c.vb"&gt;&lt;![CDATA[
Public Class C
    Implements I1

    Sub M1() Implements I1.M1
    End Sub
End Class
]]&gt;&lt;/file&gt;
&lt;/compilation&gt;

            Dim comp1 = CreateCompilation(source1, targetFramework:=TargetFramework.NetStandardLatest, references:={csCompiation})
            comp1.AssertTheseDiagnostics(
&lt;errors&gt;
&lt;/errors&gt;
            )
        End Sub
```

Observed: No error is reported

Expected: An error saying something like: "'I1.M1' is inaccessible due to its protection level"</Description>
        <CreatedDate>20/05/2019</CreatedDate>
        <ClosedDate>19/08/2019</ClosedDate>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>38238</IssueID>
    <Title>Update IfToSwitch refactoring for switch expressions</Title>
    <Description>Fixes #38083 
Fixes #37035

Also the feature is rewritten to share most logic for VB and C# as they get close to feature parity.</Description>
    <CreatedDate>23/08/2019</CreatedDate>
    <ClosedDate>16/10/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>38083</IssueID>
        <Title>IDE refactoring for cascading ifs?</Title>
        <Description>Consider a method like:
```C#
public static StringComparer GetStringComparer(this CompareInfo compareInfo, CompareOptions options)
{
    if (compareInfo == null)
    {
        throw new ArgumentNullException(nameof(compareInfo));
    }

    if (options == CompareOptions.Ordinal)
    {
        return StringComparer.Ordinal;
    }

    if (options == CompareOptions.OrdinalIgnoreCase)
    {
        return StringComparer.OrdinalIgnoreCase;
    }

    return new CultureAwareComparer(compareInfo, options);
}
```
It can be expressed more succinctly as e.g.
```C#
public static StringComparer GetStringComparer(this CompareInfo compareInfo, CompareOptions options) =&gt;
    compareInfo is null ? throw new ArgumentNullException(nameof(compareInfo)) :
    options == CompareOptions.Ordinal ? StringComparer.Ordinal :
    options == CompareOptions.OrdinalIgnoreCase ? StringComparer.OrdinalIgnoreCase :
    new CultureAwareComparer(compareInfo, options);
}
```
or e.g.
```C#
public static StringComparer GetStringComparer(this CompareInfo compareInfo, CompareOptions options) =&gt;
    compareInfo is null ? throw new ArgumentNullException(nameof(compareInfo)) :
    options switch
    {
        CompareOptions.Ordinal =&gt; StringComparer.Ordinal,
        CompareOptions.OrdinalIgnoreCase =&gt; StringComparer.OrdinalIgnoreCase,
        _ =&gt; new CultureAwareComparer(compareInfo, options)
    }
}
```
It'd be nice if there were an IDE refactoring for that.</Description>
        <CreatedDate>18/08/2019</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>37035</IssueID>
        <Title>Convert to switch replaces with broken code.</Title>
        <Description>```cs
if (o is string text &amp;&amp;
    int.TryParse(text, out var n) &amp;&amp;
    n &lt; 5 &amp;&amp; n &gt; -5)
{
}
else
{
}
```

Is refactored to:

```cs
switch (o)
{
    case string text when int.TryParse(text, out var n) &amp;&amp;
    n &lt; 5:
        break;
    default:
        break;
}
```

Not ideal that it trims off `&amp;&amp; n &gt; -5`

I expected:

```cs
switch (o)
{
    case string text when int.TryParse(text, out var n) &amp;&amp;
                        n &lt; 5 &amp;&amp; n &gt; -5:
        break;
    default:
        break;
}
```

![Animation](https://user-images.githubusercontent.com/1640096/60790007-bf4df380-a160-11e9-92a9-2f1621060833.gif)</Description>
        <CreatedDate>07/07/2019</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/Core/Portable/InternalUtilities/EnumerableExtensions.cs</File>
      <File>src/EditorFeatures/CSharpTest/CodeActions/ConvertIfToSwitch/ConvertIfToSwitchTests.cs</File>
      <File>src/Features/CSharp/Portable/CSharpFeaturesResources.Designer.cs</File>
      <File>src/Features/CSharp/Portable/ConvertIfToSwitch/CSharpConvertIfToSwitchCodeRefactoringProvider.Analyzer.cs</File>
      <File>src/Features/CSharp/Portable/ConvertIfToSwitch/CSharpConvertIfToSwitchCodeRefactoringProvider.Pattern.cs</File>
      <File>src/Features/CSharp/Portable/ConvertIfToSwitch/CSharpConvertIfToSwitchCodeRefactoringProvider.Rewriting.cs</File>
      <File>src/Features/CSharp/Portable/ConvertIfToSwitch/CSharpConvertIfToSwitchCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/ConvertIfToSwitch/AbstractConvertIfToSwitchCodeRefactoringProvider.AnalyzedNodes.cs</File>
      <File>src/Features/Core/Portable/ConvertIfToSwitch/AbstractConvertIfToSwitchCodeRefactoringProvider.Analyzer.cs</File>
      <File>src/Features/Core/Portable/ConvertIfToSwitch/AbstractConvertIfToSwitchCodeRefactoringProvider.Rewriting.cs</File>
      <File>src/Features/Core/Portable/ConvertIfToSwitch/AbstractConvertIfToSwitchCodeRefactoringProvider.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>38200</IssueID>
    <Title>Exclude textual changes made in unchangeable document</Title>
    <Description>This is my third attempt of fixing the feedback below (see #38070 for another approach)
https://developercommunity.visualstudio.com/content/problem/682938/csharperenametrackingcodefixprovider-encountered-a.html 

The root cause is symbol finder returns all the references for a given symbol, including those from unchangeable document (i.e. *.g.cs file from Razor). As a result, refactoring uses "find reference" would end up fixing those references and cause workspace to throw when the change is being applied.

This added a new helper method that simply drop all changes made in those unchangeable document. And call this helper before refactoring returns final solution.

Affected refactoring:
1. rename
2. sync/change namespace (#37521)
3. change signature

Note that this change only avoids the crash. User code will be left in a broken state, which is really undesirable, but there's not much we can do until Razor provides us a way to modify closed files.</Description>
    <CreatedDate>22/08/2019</CreatedDate>
    <ClosedDate>05/09/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>38070</IssueID>
        <Title>Don't include unchangeable references as renamable references</Title>
        <Description>Fix feedback https://developercommunity.visualstudio.com/content/problem/682938/csharperenametrackingcodefixprovider-encountered-a.html

I tried an alternative approach @jasonmalinowski suggested, i.e. creating a more general helper like
```cs
Solution ExcludeDisallowedChange(Solution oldSolution, Solution newSolution);
```
However, simply replacing the text/syntax in new document with the one from old one doesn't seem to work, because later when we apply the change, it just check the ref equality of the old and new DocumentState in `GetChangedDocuments`. So I ended up having the "fixed" document still being flagged as changed.

---

@CyrusNajmabadi @heejaechang The repro I have is to rename a type referenced in a .cshtml file, when the cshtml file is not opened in editor. In that scenario, the corresponding .g.cs document contains an auto-generated syntax tree that has the reference, which is then found by SymbolFinder. The part I don't quite understand is that it seems whenever the .cshtml is opened, it's added to the project on the fly and removed when closed, as a result for the .g.cs file, the one with auto-gen syntax tree is replaced with one with empty tree when cshtml is opened (and replaced back when it's closed). Is this how Razor works? 

That said, it seems FAR can handle this regardless of whether cshtml is opened nor not, do you know where it is implemented? It seems to be a different path from `FindReferencesSearchEngine.FindReferencesAsync` that is used by `SymbolFinder.FindRenamableReferencesAsync`? If possible, I'd rather fix this by making rename use whatever implementation that supports FAR.</Description>
        <CreatedDate>17/08/2019</CreatedDate>
        <ClosedDate>22/08/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>37521</IssueID>
        <Title>CSharpSyncNamespaceCodeRefactoringProvider crashes when refactoring class reference have a reference in g.cshtml.cs</Title>
        <Description>In VS 2019 (community edition), When I try to move a class from namespace1 to namespace2, the Roslyn refactoring crashing by saying that `CSharpSyncNamespaceCodeRefactoringProvider changing document g.cshtml.cs file is not supported`. It looks like the refactoring of the razor generated file is not working(my file was at obj\Debug\netcoreapp2.2\Razor\Views\**\**.g.cshtml.cs).

</Description>
        <CreatedDate>27/07/2019</CreatedDate>
        <ClosedDate>05/09/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/ChangeSignature/ChangeSignatureTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/CodeActions/SyncNamespace/CSharpSyncNamespaceTestsBase.cs</File>
      <File>src/EditorFeatures/CSharpTest/CodeActions/SyncNamespace/SyncNamespaceTests_ChangeNamespace.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/InlineRenameSession.cs</File>
      <File>src/EditorFeatures/TestUtilities/Utilities/TestDocumentServiceProvider.cs</File>
      <File>src/EditorFeatures/TestUtilities/Workspaces/TestWorkspace_XmlConsumption.cs</File>
      <File>src/Features/Core/Portable/ChangeSignature/AbstractChangeSignatureService.cs</File>
      <File>src/Features/Core/Portable/ChangeSignature/ChangeSignatureCodeAction.cs</File>
      <File>src/Features/Core/Portable/CodeRefactorings/SyncNamespace/AbstractChangeNamespaceService.cs</File>
      <File>src/Workspaces/Core/Portable/Rename/ConflictEngine/ConflictResolver.Session.cs</File>
      <File>src/Workspaces/Core/Portable/Shared/Extensions/ISolutionExtensions.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/Workspace.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>38176</IssueID>
    <Title>VB: Add tests for consuming operators defined within interfaces.</Title>
    <Description>Closes #35998. Closes #35999.</Description>
    <CreatedDate>21/08/2019</CreatedDate>
    <ClosedDate>22/08/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>35998</IssueID>
        <Title>VB DIM: Add tests for consuming operators defined within interfaces</Title>
        <Description>**Version Used**: 

**Steps to Reproduce**:

1. 
2. 
3. 

**Expected Behavior**:

**Actual Behavior**:
</Description>
        <CreatedDate>28/05/2019</CreatedDate>
        <ClosedDate>22/08/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>35999</IssueID>
        <Title>VB DIM: Should probably disable consumption of operators declared within interfaces</Title>
        <Description>There were some changes made to operators overload resolution in C#. For VB, we probably don't have time to finalize the design and implementation in this area. As it stands right now, it is possible that those operators are simply ignored by VB compiler, but we should confirm.</Description>
        <CreatedDate>28/05/2019</CreatedDate>
        <ClosedDate>22/08/2019</ClosedDate>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>38166</IssueID>
    <Title>Cleanup &amp; rework of `IsOnTypeHeader` usage</Title>
    <Description>~Based on: #37884~
Work for: #35525</Description>
    <CreatedDate>21/08/2019</CreatedDate>
    <ClosedDate>29/08/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>37884</IssueID>
        <Title>Move some ComputeRefactoringsAsync to common helpers 6/n</Title>
        <Description>Work for #35525</Description>
        <CreatedDate>09/08/2019</CreatedDate>
        <ClosedDate>21/08/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>35525</IssueID>
        <Title>Improve discoverability of code refactorings</Title>
        <Description>A bunch of recent customer surveys done by @kendrahavens identified that quite a few customers find our refactorings to be not discoverable. The refactorings that they requested were already implemented by us, but they needed Kendra to point out where to put the cursor or how to change the selection span for these to show up in the light bulb menu. The same concern does not apply to code fixes due to visual cue from the squiggle/suggestion dots in the UI, and pressing Ctrl + dot anywhere on the line shows up the fix, ordering being based on the distance from the diagnostic span. Note that the primary reason why we don't show up all the refactorings available on a given line are to avoid overloading the light bulb menu, which is already quite noisy. We need to fine tune the experience here to find a balance between discoverability of actions and overloading the light bulb menu.

We have talked about adding 2 different discoverability enhancements to address these concerns:

1. **Show additional actions in light bulb menu**
Improve the discoverability of the refactorings in the light bulb, by showing additional, but likely less relevant actions, that are applicable for positions _near_ the current cursor or selection span. Most relevant refactorings would still be show at the top of the menu and these additional actions will either be shown at the bottom of the menu or nested within a separate menu towards the bottom. Internal discussions have led to bunch of different implementation suggestions on how to achieve this (discussed below), but the primary conclusion being that we need to somehow _associate a fix span/ideal span with each registered code action within a refactoring, so the engine can prioritize the ordering and/or nesting of these refactorings based on promixity of this span with current cursor position or selection span_.
Possible implementation approaches that came out:
   1. **Implementation 1**: Convert all the IDE refactorings that are not selection based into a pair of diagnostic analyzer reporting hidden diagnostics + code fix. The diagnostic span would be the ideal span for the code actions.

      PROS:
         1. All refactorings available on any position in a line show up in the light bulb, solving the discoverability concerns. 
         2. We get other useful analyzer/fixer features for free: fix all, ability to bump up the severity to see squiggles/error list entries across a wider scope, etc.

      CONS:
         1. Likely to overload the light bulb menu with lot more actions now showing up. If so, one option might be to move all the code actions registered for hidden diagnostics whose span does not intersect with current position into a nested menu near the bottom of the light bulb menu.
         2. This approach adds quite a bit of implementation cost as we need to refactor code in each code refactoring into a pair of diagnostic analyzer/code fix.

   2. **Implementation 2**: Currently, the refactoring service executes naively for identifying available actions for current cursor position or span. It passes in the entire line span or selection span into each refactoring, and then treats all registered refactorings to be on par with each other. This forces our refactorings to then be implemented in a restrictive manner, so they are not offered everywhere on the line and do not overload the light bulb menu. This whole setup relies on the assumption that users are already aware about where to put their cursor or what span to select to get the relevant refactorings, which does not seem to be true as mentioned at the start of this post. This proposal tries to remove this assumption by making the following changes:
      1. Change the code refactoring service to perform multiple passes instead of just one. It first identifies the current token/node at the position or selection span and identifies available actions. These would be the most relevant refactorings that get offered at the top level of the light bulb menu. Then the service walks up the parent node and asks available actions for the parent and siblings of previous token/node. These actions would automatically be assigned a lower priority and will be shown under a nested menu near the bottom. These additional nearby actions would serve as a discoverability point for beginner users, while also not polluting the menu for advanced users.
      2. Change all the refactorings so they only register an action if the input text span exactly matches the token/node that is most relevant to it.

     PROS:
         1. We do not alter the existing light bulb menu significantly for advanced/experienced users, while adding a new discoverability point for beginner users to discover new potential actions in nearby locations.
         2. The implementation for each refactoring is greatly simplified and unified as they only work when input span exactly matches it's fixed span.

      CONS: 
         1. We might end up with a perf hit due to the code refactoring service doing multiple passes. We would need perf measurements to identify if this indeed a concern as most refactorings would just bail out upfront. 
         2. We need to experiment/decide if a nested menu is indeed a good discoverability point as beginner users might not know that they need to dive into a nested menu at the bottom.

   3. **Implementation 3**: Allow refactorings to specify a span in [RegisterRefactoring](http://source.roslyn.io/#Microsoft.CodeAnalysis.Workspaces/CodeRefactorings/CodeRefactoringContext.cs,51) callback. This would serve as the virtual diagnostic span for the code action. We would need to change all the refactorings to then operate on all the nodes/tokens of interest in the input context span and register refactorings for each node/token with their span. The code refactoring service would be changed to prioritize refactorings whose registered span is a close match to current position/span, and show the rest of refactorings in a nested menu or towards the bottom of the menu.

     PROS: Get the similar user experience as prior approaches, with potentially lesser implementation cost then approach i. and avoid multiple passes that are needed in approach ii.

     CONS: Adds implementation complexity in each refactoring of identifying multiple nodes/tokens of interest and then register each action with a span.

   4. **Implementation 4**: Enforce common [helpers](https://github.com/dotnet/roslyn/blob/master/src/Features/Core/Portable/CodeRefactoringHelpers.cs) that each code refactoring ought to use to determine it's applicability span and bail out if that is not the case. We need to ensure we polish and/or extend the existing helpers, make them public as appropriate and audit all existing or just the problematic refactorings to ensure they are using these helpers.

2. **New UI for viewing available actions in a broader scope**: Create a separate tool window to show available code actions within a given scope (document/project/solution, with document being the default). Few open questions:
   1. Should the refactorings shown in this window be opt-in to avoid polluting it with common refactorings that show up everywhere?
   2. Should the tool window automatically be opened and brought to focus when user invokes light bulb and/or applies a code action? If not, how would we make this UI discoverable for users?
   3. Should the actions list in the window be ordered such that the actions closer to current cursor are near the top?
   We would potentially start with a simple UI, that only works for document scope to start with, and iterate on improving it to work with broader scopes.
</Description>
        <CreatedDate>06/05/2019</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/IntroduceVariable/IntroduceLocalForExpressionTests.cs</File>
      <File>src/Features/CSharp/Portable/CodeRefactorings/CSharpRefactoringHelpersService.cs</File>
      <File>src/Features/CSharp/Portable/ConvertLinq/CSharpConvertLinqQueryToForEachProvider.cs</File>
      <File>src/Features/CSharp/Portable/GenerateMember/GenerateDefaultConstructors/CSharpGenerateDefaultConstructorsService.cs</File>
      <File>src/Features/Core/Portable/CodeRefactorings/AbstractRefactoringHelpersService.cs</File>
      <File>src/Features/Core/Portable/CodeRefactorings/AddAwait/AbstractAddAwaitCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/ConvertAutoPropertyToFullProperty/AbstractConvertAutoPropertyToFullPropertyCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/ConvertForEachToFor/AbstractConvertForEachToForCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/ConvertIfToSwitch/AbstractConvertIfToSwitchCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/ConvertLinq/AbstractConvertLinqQueryToForEachProvider.cs</File>
      <File>src/Features/Core/Portable/ConvertNumericLiteral/AbstractConvertNumericLiteralCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/ConvertToInterpolatedString/AbstractConvertPlaceholderToInterpolatedStringRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/GenerateConstructorFromMembers/GenerateConstructorFromMembersCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/GenerateEqualsAndGetHashCodeFromMembers/GenerateEqualsAndGetHashCodeFromMembersCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/GenerateFromMembers/AbstractGenerateFromMembersCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/GenerateOverrides/GenerateOverridesCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/IntroduceVariable/IntroduceLocalForExpressionCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/InvertIf/AbstractInvertIfCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/ReplacePropertyWithMethods/ReplacePropertyWithMethodsCodeRefactoringProvider.cs</File>
      <File>src/Workspaces/CSharp/Portable/LanguageServices/CSharpSyntaxFactsService.cs</File>
      <File>src/Workspaces/CSharp/Portable/LanguageServices/CSharpSyntaxKindsService.cs</File>
      <File>src/Workspaces/Core/Portable/LanguageServices/SyntaxFactsService/AbstractSyntaxFactsService.cs</File>
      <File>src/Workspaces/Core/Portable/LanguageServices/SyntaxFactsService/ISyntaxFactsService.cs</File>
      <File>src/Workspaces/Core/Portable/LanguageServices/SyntaxFactsService/ISyntaxKindsService.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>37445</IssueID>
    <Title>Add IMethodSymbol.Construct overload with nullable annotations</Title>
    <Description>Fixes #37310
Fixes #37279</Description>
    <CreatedDate>24/07/2019</CreatedDate>
    <ClosedDate>25/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>37310</IssueID>
        <Title>IMethodSymbol.Construct doesn't have a way to pass top-level nullability</Title>
        <Description>This is the same as #36046 but for IMethodSymbol.</Description>
        <CreatedDate>17/07/2019</CreatedDate>
        <ClosedDate>25/07/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>37279</IssueID>
        <Title>NamedTypeSymbolWithNullableAnnotation.Construct(ImmutableArray&lt;ITypeSymbol&gt;, ImmutableArray&lt;NullableAnnotation&gt;) drops top-level nullability</Title>
        <Description>`NamedTypeSymbolWithNullableAnnotation.Construct(ImmutableArray&lt;ITypeSymbol&gt;, ImmutableArray&lt;NullableAnnotation&gt;)` drops top-level nullability.

See https://github.com/dotnet/roslyn/pull/37271#discussion_r304076179</Description>
        <CreatedDate>16/07/2019</CreatedDate>
        <ClosedDate>25/07/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Symbols/MethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/NamedTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Symbol.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Compilation/CompilationAPITests.cs</File>
      <File>src/Compilers/Core/Portable/Symbols/IMethodSymbol.cs</File>
      <File>src/Features/Core/Portable/MetadataAsSource/AbstractMetadataAsSourceService.WrappedMethodSymbol.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/Symbols/CodeGenerationAbstractMethodSymbol.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/Symbols/CodeGenerationConstructedMethodSymbol.cs</File>
      <File>src/Workspaces/Core/Portable/Utilities/NullableHelpers/NamedTypeSymbolWithNullableAnnotation.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>37323</IssueID>
    <Title>Add ref and qualified generic name detection for SpeculativeT completion.</Title>
    <Description>Fixes #37224 
Fixes #37268 
Fixes #37361 </Description>
    <CreatedDate>18/07/2019</CreatedDate>
    <ClosedDate>08/08/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>37224</IssueID>
        <Title>Intellisense not listing "T" when starting to write a ref return method</Title>
        <Description>**Version Used**: 
VS16.1.6

**Steps to Reproduce**:

1. Inside a C# class, type `ref Span&lt;T&gt;`

**Expected Behavior**:

`ref Span&lt;T&gt;`

**Actual Behavior**:

`ref Span&lt;ThreadStaticAttribute&gt;`</Description>
        <CreatedDate>15/07/2019</CreatedDate>
        <ClosedDate>08/08/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>37268</IssueID>
        <Title>Intellisense not listing "T" when starting to write a qualified return type</Title>
        <Description>**Version Used**: 16.2 Preview 3

:link: Found while reviewing #37224

**Steps to Reproduce**:

1. Inside a C# class, type `System.Span&lt;T&gt;`

**Expected Behavior**:

`System.Span&lt;T&gt;`

**Actual Behavior**:

`System.Span&lt;ThreadStaticAttribute&gt;`</Description>
        <CreatedDate>16/07/2019</CreatedDate>
        <ClosedDate>08/08/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>37361</IssueID>
        <Title>SpeculativeT completion does not support tuples.</Title>
        <Description>This is found during review of #37323

**Version Used**:
VS16.2 

**Steps to Reproduce**:

1. Inside a C# class, type `(T `

**Expected Behavior**:

`(T )`

**Actual Behavior**:

`(ThreadStaticAttribute )`</Description>
        <CreatedDate>19/07/2019</CreatedDate>
        <ClosedDate>08/08/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/Completion/CompletionProviders/SpeculativeTCompletionProviderTests.cs</File>
      <File>src/Features/CSharp/Portable/Completion/CompletionProviders/SpeculativeTCompletionProvider.cs</File>
      <File>src/Workspaces/CSharp/Portable/Extensions/ContextQuery/SyntaxTreeExtensions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>37303</IssueID>
    <Title>Analyzer driver performance fixes for IDE open file analysis</Title>
    <Description>IDE analyzer host invokes [CompilationWithAnalyzers.GetAnalyzerSemanticDiagnosticsAsync](http://source.roslyn.io/#q=CompilationWithAnalyzers.GetAnalyzerSemanticDiagnosticsAsync) APIs to compute open file semantic diagnostics. This PR performs the following optimizations on this code path:
1. `AnalysisState.PerAnalyzerState`: Delay allocations of per-symbol dictionary values stored in `_pendingDeclarations` map until we actually start analyzing the first declaration for the symbol. This avoids unncessary allocation overhead on the dictionary pool from which these dictionaries are allocated.
2. `CompilationWithAnalyzers` and `AnalyzerDriver`: Ensure that we force complete partial type trees only for symbol start analyzer(s) in the original analysis scope for which diagnostics were requested. Our current logic force completed partial tree diagnostics for all analyzers if at least one of the analyzer is a symbol start analyzer, which is always true as IDE already has few symbol start analyzers.

Addresses VS Feedback performance issues [#922802](https://dev.azure.com/devdiv/DevDiv/_workitems/edit/922802) and [#922837](https://dev.azure.com/devdiv/DevDiv/_workitems/edit/922837)

**NOTE:** ~~This PR currently targets master branch, but we need to decide if this meets the current 16.3 bar as the code changes are in the compiler layer, even though the affected code path/APIs are only ever invoked during IDE open file analysis.~~ Retargeted to `features/compilerNext` based on offline discussion.</Description>
    <CreatedDate>17/07/2019</CreatedDate>
    <ClosedDate>25/07/2019</ClosedDate>
    <Issues />
    <Files>
      <File>src/Compilers/CSharp/Test/Semantic/Diagnostics/DiagnosticAnalyzerTests.cs</File>
      <File>src/Compilers/Core/Portable/DiagnosticAnalyzer/AnalysisState.PerAnalyzerState.cs</File>
      <File>src/Compilers/Core/Portable/DiagnosticAnalyzer/AnalyzerDriver.cs</File>
      <File>src/Compilers/Core/Portable/DiagnosticAnalyzer/CompilationWithAnalyzers.cs</File>
      <File>src/Test/Utilities/Portable/Diagnostics/CommonDiagnosticAnalyzers.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>37290</IssueID>
    <Title>Fully qualify unimported type name when in import directive</Title>
    <Description>Fix #37038
Fix #37523</Description>
    <CreatedDate>17/07/2019</CreatedDate>
    <ClosedDate>31/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>37038</IssueID>
        <Title>Completion for "Show items from unimported namespaces" within a using alias results in unbuildable code</Title>
        <Description>Using aliases need to full specify types used as generic arguments. "Show items from unimported namespaces" is unaware of that and attempts to add a using directive, which still results in a build error.

**Steps to Reproduce**:

``` C#
using System;

using CollectionOfStringBuilders = System.Collections.Generic.List&lt;StringBui&gt;
```

**Expected Behavior**:
``` C#
using System;

using CollectionOfStringBuilders = System.Collections.Generic.List&lt;System.Text.StringBuilder&gt;
```

**Actual Behavior**:
``` C#
using System;
using System.Text;
using CollectionOfStringBuilders = System.Collections.Generic.List&lt;StringBuilder&gt;
```

```
Severity	Code	Description	Project	File	Line	Suppression State
Error	CS0246	The type or namespace name 'StringBuilder' could not be found (are you missing a using directive or an assembly reference?)	ConsoleApp5	C:\Users\davkean\source\repos\ConsoleApp5\ConsoleApp5\Program.cs	3	Active
```

tag @genlu </Description>
        <CreatedDate>08/07/2019</CreatedDate>
        <ClosedDate>31/07/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>37523</IssueID>
        <Title>Intellisense for using static adds an import rather than a full qualification</Title>
        <Description>**Version Used**: VS 16.3 preview 1

**Steps to Reproduce**:

![usingStatic](https://user-images.githubusercontent.com/29174528/62006252-19c1ea80-b136-11e9-814d-cd33a63ecd22.gif)

Make sure "Show Items From Unimported Namespaces" is switched on in `Tools-&gt;options-&gt;Text Editor-&gt;C#-&gt;Intellisense`

at the top of a file start typing `using static &lt;SomeType&gt;`
When intellisense shows up for `&lt;SomeType&gt;` press enter.

**Expected Behavior**:

The file now shows 
```csharp
using static &lt;SomeNamespace&gt;.&lt;SomeType&gt;
```

**Actual Behavior**:

The file now shows 
```csharp
using &lt;SomeNamespace&gt;;
using &lt;SomeType&gt;;
```
</Description>
        <CreatedDate>28/07/2019</CreatedDate>
        <ClosedDate>31/07/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/Completion/CompletionProviders/TypeImportCompletionProviderTests.cs</File>
      <File>src/Features/CSharp/Portable/Completion/CompletionProviders/ImportCompletion/TypeImportCompletionProvider.cs</File>
      <File>src/Features/CSharp/Portable/Completion/CompletionProviders/SymbolCompletionProvider.cs</File>
      <File>src/Features/Core/Portable/Completion/CompletionServiceOptions.cs</File>
      <File>src/Features/Core/Portable/Completion/Providers/ImportCompletionProvider/AbstractTypeImportCompletionProvider.cs</File>
      <File>src/Workspaces/CSharp/Portable/Extensions/ContextQuery/CSharpSyntaxContext.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>37272</IssueID>
    <Title>Move some ComputeRefactoringsAsync to common helpers 4/n</Title>
    <Description>Work for: #35525 and #35180

Based on (previous) PRs: #37236 (and thus subsequently on #37196)</Description>
    <CreatedDate>16/07/2019</CreatedDate>
    <ClosedDate>19/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>35525</IssueID>
        <Title>Improve discoverability of code refactorings</Title>
        <Description>A bunch of recent customer surveys done by @kendrahavens identified that quite a few customers find our refactorings to be not discoverable. The refactorings that they requested were already implemented by us, but they needed Kendra to point out where to put the cursor or how to change the selection span for these to show up in the light bulb menu. The same concern does not apply to code fixes due to visual cue from the squiggle/suggestion dots in the UI, and pressing Ctrl + dot anywhere on the line shows up the fix, ordering being based on the distance from the diagnostic span. Note that the primary reason why we don't show up all the refactorings available on a given line are to avoid overloading the light bulb menu, which is already quite noisy. We need to fine tune the experience here to find a balance between discoverability of actions and overloading the light bulb menu.

We have talked about adding 2 different discoverability enhancements to address these concerns:

1. **Show additional actions in light bulb menu**
Improve the discoverability of the refactorings in the light bulb, by showing additional, but likely less relevant actions, that are applicable for positions _near_ the current cursor or selection span. Most relevant refactorings would still be show at the top of the menu and these additional actions will either be shown at the bottom of the menu or nested within a separate menu towards the bottom. Internal discussions have led to bunch of different implementation suggestions on how to achieve this (discussed below), but the primary conclusion being that we need to somehow _associate a fix span/ideal span with each registered code action within a refactoring, so the engine can prioritize the ordering and/or nesting of these refactorings based on promixity of this span with current cursor position or selection span_.
Possible implementation approaches that came out:
   1. **Implementation 1**: Convert all the IDE refactorings that are not selection based into a pair of diagnostic analyzer reporting hidden diagnostics + code fix. The diagnostic span would be the ideal span for the code actions.

      PROS:
         1. All refactorings available on any position in a line show up in the light bulb, solving the discoverability concerns. 
         2. We get other useful analyzer/fixer features for free: fix all, ability to bump up the severity to see squiggles/error list entries across a wider scope, etc.

      CONS:
         1. Likely to overload the light bulb menu with lot more actions now showing up. If so, one option might be to move all the code actions registered for hidden diagnostics whose span does not intersect with current position into a nested menu near the bottom of the light bulb menu.
         2. This approach adds quite a bit of implementation cost as we need to refactor code in each code refactoring into a pair of diagnostic analyzer/code fix.

   2. **Implementation 2**: Currently, the refactoring service executes naively for identifying available actions for current cursor position or span. It passes in the entire line span or selection span into each refactoring, and then treats all registered refactorings to be on par with each other. This forces our refactorings to then be implemented in a restrictive manner, so they are not offered everywhere on the line and do not overload the light bulb menu. This whole setup relies on the assumption that users are already aware about where to put their cursor or what span to select to get the relevant refactorings, which does not seem to be true as mentioned at the start of this post. This proposal tries to remove this assumption by making the following changes:
      1. Change the code refactoring service to perform multiple passes instead of just one. It first identifies the current token/node at the position or selection span and identifies available actions. These would be the most relevant refactorings that get offered at the top level of the light bulb menu. Then the service walks up the parent node and asks available actions for the parent and siblings of previous token/node. These actions would automatically be assigned a lower priority and will be shown under a nested menu near the bottom. These additional nearby actions would serve as a discoverability point for beginner users, while also not polluting the menu for advanced users.
      2. Change all the refactorings so they only register an action if the input text span exactly matches the token/node that is most relevant to it.

     PROS:
         1. We do not alter the existing light bulb menu significantly for advanced/experienced users, while adding a new discoverability point for beginner users to discover new potential actions in nearby locations.
         2. The implementation for each refactoring is greatly simplified and unified as they only work when input span exactly matches it's fixed span.

      CONS: 
         1. We might end up with a perf hit due to the code refactoring service doing multiple passes. We would need perf measurements to identify if this indeed a concern as most refactorings would just bail out upfront. 
         2. We need to experiment/decide if a nested menu is indeed a good discoverability point as beginner users might not know that they need to dive into a nested menu at the bottom.

   3. **Implementation 3**: Allow refactorings to specify a span in [RegisterRefactoring](http://source.roslyn.io/#Microsoft.CodeAnalysis.Workspaces/CodeRefactorings/CodeRefactoringContext.cs,51) callback. This would serve as the virtual diagnostic span for the code action. We would need to change all the refactorings to then operate on all the nodes/tokens of interest in the input context span and register refactorings for each node/token with their span. The code refactoring service would be changed to prioritize refactorings whose registered span is a close match to current position/span, and show the rest of refactorings in a nested menu or towards the bottom of the menu.

     PROS: Get the similar user experience as prior approaches, with potentially lesser implementation cost then approach i. and avoid multiple passes that are needed in approach ii.

     CONS: Adds implementation complexity in each refactoring of identifying multiple nodes/tokens of interest and then register each action with a span.

   4. **Implementation 4**: Enforce common [helpers](https://github.com/dotnet/roslyn/blob/master/src/Features/Core/Portable/CodeRefactoringHelpers.cs) that each code refactoring ought to use to determine it's applicability span and bail out if that is not the case. We need to ensure we polish and/or extend the existing helpers, make them public as appropriate and audit all existing or just the problematic refactorings to ensure they are using these helpers.

2. **New UI for viewing available actions in a broader scope**: Create a separate tool window to show available code actions within a given scope (document/project/solution, with document being the default). Few open questions:
   1. Should the refactorings shown in this window be opt-in to avoid polluting it with common refactorings that show up everywhere?
   2. Should the tool window automatically be opened and brought to focus when user invokes light bulb and/or applies a code action? If not, how would we make this UI discoverable for users?
   3. Should the actions list in the window be ordered such that the actions closer to current cursor are near the top?
   We would potentially start with a simple UI, that only works for document scope to start with, and iterate on improving it to work with broader scopes.
</Description>
        <CreatedDate>06/05/2019</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>35180</IssueID>
        <Title>Offer codefixes on selections</Title>
        <Description>## Scenario
Codefixes often don't show if code is selected as opposed to only having your cursor placed within a word.
*  **5 out of the 11 users struggled with this in user studies.** 
* One user **only** ever double-clicked when clicking around the editor. This means he saw fewer codefixes since double clicking always selects the word and we don't show available codefixes in the context. Some users are used to double-clicking around their codebase.

## Proposal
Enable the same codefixes to appear if a block is selected as would appear if the cursor was placed inside a specific name. If this improves discoverability of codefixes we can enable this on a case-by-case basis per refactoring. My study observed more issues with the 'pull members up to base type' refactoring than others though general struggling was observed with many refactorings.

**Example: Pull members up**
Codefix offered when cursor is in the name:
![image](https://user-images.githubusercontent.com/8293542/56520118-8bb3e380-64f8-11e9-94fa-b79c60ed7ddb.png)

Codefix not offered if full line is selected:
![image](https://user-images.githubusercontent.com/8293542/56520215-bf8f0900-64f8-11e9-9022-7a5ebd464553.png)

**Example: Convert local function to method**
Offered if cursor is in name
![image](https://user-images.githubusercontent.com/8293542/56520344-0d0b7600-64f9-11e9-8fb9-6ac6d7b8de69.png)

Not offered when entire local function is selected
![image](https://user-images.githubusercontent.com/8293542/56520368-1ac0fb80-64f9-11e9-92a4-49037caea806.png)

**Example: LINQ to Foreach conversions**
![image](https://user-images.githubusercontent.com/8293542/56521136-1517e580-64fa-11e9-828a-a23aa22d8ce2.png)

If semi-colon is included in selection the conversion does not appear:
![image](https://user-images.githubusercontent.com/8293542/56521033-00d3e880-64fa-11e9-849f-2cc7a675f3ff.png)







</Description>
        <CreatedDate>22/04/2019</CreatedDate>
        <ClosedDate>06/09/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>37236</IssueID>
        <Title>Syntax kinds service cleanup</Title>
        <Description>Based on #37196 (only last commit is new).
</Description>
        <CreatedDate>15/07/2019</CreatedDate>
        <ClosedDate>18/07/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>37196</IssueID>
        <Title>Move some ComputeRefactoringsAsync to common helpers 3/n</Title>
        <Description>Continuation of work on #35525 and #35180</Description>
        <CreatedDate>12/07/2019</CreatedDate>
        <ClosedDate>17/07/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/ConvertForEachToFor/ConvertForEachToForTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/ConvertForToForEach/ConvertForToForEachTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/InvertIf/InvertIfTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/MoveDeclarationNearReference/MoveDeclarationNearReferenceTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/RefactoringHelpers/RefactoringHelpersTests.cs</File>
      <File>src/Features/CSharp/Portable/ConvertForEachToFor/CSharpConvertForEachToForCodeRefactoringProvider.cs</File>
      <File>src/Features/CSharp/Portable/ConvertForToForEach/CSharpConvertForToForEachCodeRefactoringProvider.cs</File>
      <File>src/Features/CSharp/Portable/InvertIf/CSharpInvertIfCodeRefactoringProvider.cs</File>
      <File>src/Features/CSharp/Portable/MoveDeclarationNearReference/CSharpMoveDeclarationNearReferenceCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/CodeRefactorings/AbstractRefactoringHelpersService.cs</File>
      <File>src/Features/Core/Portable/ConvertForEachToFor/AbstractConvertForEachToForCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/ConvertForToForEach/AbstractConvertForToForEachCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/ConvertIfToSwitch/AbstractConvertIfToSwitchCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/InvertIf/AbstractInvertIfCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/MoveDeclarationNearReference/AbstractMoveDeclarationNearReferenceCodeRefactoringProvider.cs</File>
      <File>src/Workspaces/CSharp/Portable/LanguageServices/CSharpSyntaxFactsService.cs</File>
      <File>src/Workspaces/CSharp/Portable/LanguageServices/CSharpSyntaxKindsService.cs</File>
      <File>src/Workspaces/Core/Portable/LanguageServices/SyntaxFactsService/AbstractSyntaxFactsService.cs</File>
      <File>src/Workspaces/Core/Portable/LanguageServices/SyntaxFactsService/ISyntaxFactsService.cs</File>
      <File>src/Workspaces/Core/Portable/LanguageServices/SyntaxFactsService/ISyntaxKindsService.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>37250</IssueID>
    <Title>Move to latest FlowAnalysis Utilities assembly</Title>
    <Description>Fixes #36643
Fixes #37065</Description>
    <CreatedDate>15/07/2019</CreatedDate>
    <ClosedDate>16/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>36643</IssueID>
        <Title>Questionable IDE0067 when awaiting class-member Task containing IDisposable</Title>
        <Description>**Version Used**: 
16.2.0 Preview 2.0

**Steps to Reproduce**:

```csharp
using System.IO;
using System.Threading.Tasks;

public class C
{
    private readonly Task&lt;FileStream&gt; fileStreamTask;
    public C() =&gt; fileStreamTask = Task.Run(() =&gt; File.OpenRead("")); // async resource initialization

    public async Task M()
    {
        var stream = await fileStreamTask; // IDE0067
        await stream.FlushAsync(); // more code using `stream`
    }
    // Dispose[Async]
}
```

**Expected Behavior**:
The Task holding the `IDisposable` has class scope. Disposing the contents breaks successive calls to M(). IDE0067 should not be reported.

**Actual Behavior**:
IDE0067 and a code fix that breaks the semantics.

On a side note: The cursor positions that show the code fix doesn't match the indicator: The smudge is placed under the letters `aw` of `await`, while the code fix is only available before and after the `=` and before the `a`.</Description>
        <CreatedDate>21/06/2019</CreatedDate>
        <ClosedDate>16/07/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>37065</IssueID>
        <Title>IDE0068 Triggers invalidly for awaited disposables already in a using</Title>
        <Description>**Version Used**: VS 16.2 Preview 3

**Steps to Reproduce**:
This code will trigger IDE0068:
```c#
using (var conn = await GetConnectionAsync())
{
    return await conn.ExecuteAsync("DBCC FREEPROCCACHE (@planHandle);", new { planHandle });
}
```
Where `GetConnectionAsync()` is a `Task&lt;DbConnection&gt;`, like so:
```c#
protected Task&lt;DbConnection&gt; GetConnectionAsync() =&gt;
  Connection.GetOpenAsync(ConnectionString);
```
And at the base (simplified):
```c#
public static async Task&lt;DbConnection&gt; GetOpenAsync(string connectionString) { }
```
Inside, this opens and returns a SQL connection via `.OpenAsync()`.

**Expected Behavior**: No warning when the usage *is* disposed, at least in the first `using` case. The 2 base methods: yeah okay, we can attribute them.

**Actual Behavior**: IDE0068 is issued for all 3 methods above.

100% of the cases we're seeing this is in with `await`. I tried to minimally repro this but could not, so I reverted my suppressions and made a repro available in Opserver. If you pull [this commit](https://github.com/opserver/Opserver/commit/c859a2d61226c9e9a475eac4d3d93f5006d25e08) it should give a slew of IDE0068 warnings that haven't been refactored around yet, most around paths in the connection bits mentioned above.

Getting a connection (asynchronously) and using it elsewhere is a *very* common pattern. Can we please handle the `await` case, or perhaps disable IDE0068 for the 16.2 GA release if it can't be resolved in time?</Description>
        <CreatedDate>09/07/2019</CreatedDate>
        <ClosedDate>16/07/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/DisposeAnalysis/DisposeObjectsBeforeLosingScopeTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>37247</IssueID>
    <Title>Symbol equality comparer</Title>
    <Description>Implements Symbol equality with comparers:
- Adds a SymbolEqualityComparer that implements IEqualityComparer&lt;ISymbol&gt;
- Adds an overload to ISymbol that takes a comparer
- Implements various static comparers, exposing two of them as public
- Uses comparers internally to ensure dictionaries and hashsets etc work correctly
- Updates the bound tree generator to use comparers rather than equals for all symbols

This is probably easiest reviewed commit by commit. In order commited:

1. Add the overload and make TypeSymbol implement it
2. Remove internal type comparers and use symbol comparers instead
3. Fixup internal comparisons
4. Make SubstitutedMethodSmbol type compare aware
5. Make some new hashset/dictionary pools to restore potentially lost perf

---

This PR was made by flipping the default rules back to `IgnoreNullability`, and initially running tests to see what broke. I then implemented the default equals call to call with both `IgnoreNullability` and `ConsiderEverything` and added an assert for when we got a different result (we might consider a mode in the future that we can do this for debugging equality bugs).

Each usage where the default and everything rules diverged was replaced with an explicit comparison to include everything.

This PR does not include a complete change to every usage of compare (tracked in #37382), just the minimum changes required to restore compatibility without breaking any internal comparisons. Nor does it completely fix equality for all symbols that could be affected by nullability (tracked in #37383). 

Because we're restoring the code to the original, C#7.3 behavior, the only things we can break are new code targeting C# 8.0 with nullability enabled, and any analyzers that opt in to consider nullability. While not ideal, we're already shipping with nullable bugs, so it is more desirable to be bug free in the back compat case and add bugs to the new feature than the other way around.


</Description>
    <CreatedDate>15/07/2019</CreatedDate>
    <ClosedDate>24/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>37382</IssueID>
        <Title>Symbol Comparisons should not use default Equals</Title>
        <Description>As part of #37247 we changed the default equals to ignore nullability. 

We changed everywhere that change broke to be explicit comparisons, but in reality we should change all of the usages in our code base and obsolete `Symbol.Equals(ISymbol)` and `Symbol operator ==` to ensure every comparison is valid

Proposal was to create an analyzer and code fixer to mechanically switch all the instances over, and prevent future breaks.</Description>
        <CreatedDate>19/07/2019</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>37383</IssueID>
        <Title>Substituted symbols should override Equals(ISymbol, TypeComparisonKind)</Title>
        <Description>In #37247 we updated `TypeSymbol` and `SubstituedMethodSymbol` to consider the compare kind when comparing for equality.

We should additionally light up other symbol types that can change depending on their nullability, to ensure analyzers can correctly determine symbol equality.</Description>
        <CreatedDate>19/07/2019</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>7</IssueID>
        <Title>Feature: Parameter Name Aliasing</Title>
        <Description>The human meaning of parameters may vary from method caller's perspective.

It would be useful if the language provides an ability to assign aliases to the parameters.

``` C#
[Alias({second: [secondAndHalf, quarterToThree], first: [Initial]})] 
public static void Member1(string first, string second) { 
  // Here the user will always use the given names: first and second.
  // which means the user cannot use the param by its nickname
  // inside the method scope.
}

private static void Caller1() {
  Member1(secondAndHalf: "secondly, this is not a bad idea after all",
          Initial: "Initially it sounded moot... :)  ");
}

private static void Caller2() {
  Member1(first: "1st",
          quarterToThree: "almost there");
}

private static void Caller3() {
  Member1("one", "two");
}
```

vs. this current approach:

``` c#
public static void Member1(string first, string second) {  }

public static void Member1(string first, string secondAndHalf, string devNull = null) { 
  Member1(first, secondAndHalf);
}
```

Note: the parameter `devNull` may violate [CA1026](http://msdn.microsoft.com/en-us/library/ms182135.aspx), in case of `overridden` methods. On the flip side, setting `devNull` as non-default parameter would yield "unused parameter".

Related / Real world example: https://github.com/madskristensen/WebEssentials2013/pull/380#issuecomment-31402391
</Description>
        <CreatedDate>15/01/2015</CreatedDate>
        <ClosedDate>26/08/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Imports.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/SwitchExpressionBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/BoundDecisionDag.cs</File>
      <File>src/Compilers/CSharp/Portable/Compiler/ClsComplianceChecker.cs</File>
      <File>src/Compilers/CSharp/Portable/Emitter/Model/SymbolAdapter.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/DefiniteAssignment.VariableIdentifier.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/EmptyStructTypeCache.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/NullableWalker.PlaceholderLocal.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/NullableWalker.cs</File>
      <File>src/Compilers/CSharp/Portable/Generated/BoundNodes.xml.Generated.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/AliasSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/AnonymousTypes/SynthesizedSymbols/AnonymousType.PropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ArrayTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/DiscardSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/EventSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/MemberSignatureComparer.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/MissingAssemblySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/MissingModuleSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/MissingNamespaceSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/NamedTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/PreprocessingSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/PropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/RangeVariableSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ReducedExtensionMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/SignatureOnlyParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/LambdaSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/LocalFunctionSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceLabelSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceLocalSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceNamedTypeSymbol_Bases.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceParameterSymbolBase.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/SubstitutedFieldSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/SubstitutedMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/SubstitutedParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Symbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedIntrinsicOperatorSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/SynthesizedNamespaceSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Tuples/TupleErrorFieldSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Tuples/TupleEventSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Tuples/TupleFieldSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Tuples/TupleMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Tuples/TupleParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Tuples/TuplePropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/TypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/TypeSymbolExtensions.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTupleTest.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/NullableReferenceTypesTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/SymbolDisplay/SymbolDisplayTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/SymbolEqualityTests.cs</File>
      <File>src/Compilers/Core/Portable/InternalUtilities/MultiDictionary.cs</File>
      <File>src/Compilers/Core/Portable/InternalUtilities/SpecializedCollections.Symbol.cs</File>
      <File>src/Compilers/Core/Portable/MetadataReader/MetadataDecoder.cs</File>
      <File>src/Compilers/Core/Portable/Symbols/ISymbol.cs</File>
      <File>src/Compilers/Core/Portable/Symbols/ISymbolInternal.cs</File>
      <File>src/Compilers/Core/Portable/Symbols/SymbolEqualityComparer.cs</File>
      <File>src/Dependencies/PooledObjects/PooledDictionary.cs</File>
      <File>src/Dependencies/PooledObjects/PooledHashSet.cs</File>
      <File>src/Features/Core/Portable/MetadataAsSource/AbstractMetadataAsSourceService.AbstractWrappedSymbol.cs</File>
      <File>src/Tools/Source/CompilerGeneratorTools/Source/BoundTreeGenerator/BoundNodeClassWriter.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/Symbols/CodeGenerationSymbol.cs</File>
      <File>src/Workspaces/Core/Portable/Utilities/NullableHelpers/TypeSymbolWithNullableAnnotation.cs</File>
      <File>src/Workspaces/CoreTest/ReferencedSymbolTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>37196</IssueID>
    <Title>Move some ComputeRefactoringsAsync to common helpers 3/n</Title>
    <Description>Continuation of work on #35525 and #35180</Description>
    <CreatedDate>12/07/2019</CreatedDate>
    <ClosedDate>17/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>35525</IssueID>
        <Title>Improve discoverability of code refactorings</Title>
        <Description>A bunch of recent customer surveys done by @kendrahavens identified that quite a few customers find our refactorings to be not discoverable. The refactorings that they requested were already implemented by us, but they needed Kendra to point out where to put the cursor or how to change the selection span for these to show up in the light bulb menu. The same concern does not apply to code fixes due to visual cue from the squiggle/suggestion dots in the UI, and pressing Ctrl + dot anywhere on the line shows up the fix, ordering being based on the distance from the diagnostic span. Note that the primary reason why we don't show up all the refactorings available on a given line are to avoid overloading the light bulb menu, which is already quite noisy. We need to fine tune the experience here to find a balance between discoverability of actions and overloading the light bulb menu.

We have talked about adding 2 different discoverability enhancements to address these concerns:

1. **Show additional actions in light bulb menu**
Improve the discoverability of the refactorings in the light bulb, by showing additional, but likely less relevant actions, that are applicable for positions _near_ the current cursor or selection span. Most relevant refactorings would still be show at the top of the menu and these additional actions will either be shown at the bottom of the menu or nested within a separate menu towards the bottom. Internal discussions have led to bunch of different implementation suggestions on how to achieve this (discussed below), but the primary conclusion being that we need to somehow _associate a fix span/ideal span with each registered code action within a refactoring, so the engine can prioritize the ordering and/or nesting of these refactorings based on promixity of this span with current cursor position or selection span_.
Possible implementation approaches that came out:
   1. **Implementation 1**: Convert all the IDE refactorings that are not selection based into a pair of diagnostic analyzer reporting hidden diagnostics + code fix. The diagnostic span would be the ideal span for the code actions.

      PROS:
         1. All refactorings available on any position in a line show up in the light bulb, solving the discoverability concerns. 
         2. We get other useful analyzer/fixer features for free: fix all, ability to bump up the severity to see squiggles/error list entries across a wider scope, etc.

      CONS:
         1. Likely to overload the light bulb menu with lot more actions now showing up. If so, one option might be to move all the code actions registered for hidden diagnostics whose span does not intersect with current position into a nested menu near the bottom of the light bulb menu.
         2. This approach adds quite a bit of implementation cost as we need to refactor code in each code refactoring into a pair of diagnostic analyzer/code fix.

   2. **Implementation 2**: Currently, the refactoring service executes naively for identifying available actions for current cursor position or span. It passes in the entire line span or selection span into each refactoring, and then treats all registered refactorings to be on par with each other. This forces our refactorings to then be implemented in a restrictive manner, so they are not offered everywhere on the line and do not overload the light bulb menu. This whole setup relies on the assumption that users are already aware about where to put their cursor or what span to select to get the relevant refactorings, which does not seem to be true as mentioned at the start of this post. This proposal tries to remove this assumption by making the following changes:
      1. Change the code refactoring service to perform multiple passes instead of just one. It first identifies the current token/node at the position or selection span and identifies available actions. These would be the most relevant refactorings that get offered at the top level of the light bulb menu. Then the service walks up the parent node and asks available actions for the parent and siblings of previous token/node. These actions would automatically be assigned a lower priority and will be shown under a nested menu near the bottom. These additional nearby actions would serve as a discoverability point for beginner users, while also not polluting the menu for advanced users.
      2. Change all the refactorings so they only register an action if the input text span exactly matches the token/node that is most relevant to it.

     PROS:
         1. We do not alter the existing light bulb menu significantly for advanced/experienced users, while adding a new discoverability point for beginner users to discover new potential actions in nearby locations.
         2. The implementation for each refactoring is greatly simplified and unified as they only work when input span exactly matches it's fixed span.

      CONS: 
         1. We might end up with a perf hit due to the code refactoring service doing multiple passes. We would need perf measurements to identify if this indeed a concern as most refactorings would just bail out upfront. 
         2. We need to experiment/decide if a nested menu is indeed a good discoverability point as beginner users might not know that they need to dive into a nested menu at the bottom.

   3. **Implementation 3**: Allow refactorings to specify a span in [RegisterRefactoring](http://source.roslyn.io/#Microsoft.CodeAnalysis.Workspaces/CodeRefactorings/CodeRefactoringContext.cs,51) callback. This would serve as the virtual diagnostic span for the code action. We would need to change all the refactorings to then operate on all the nodes/tokens of interest in the input context span and register refactorings for each node/token with their span. The code refactoring service would be changed to prioritize refactorings whose registered span is a close match to current position/span, and show the rest of refactorings in a nested menu or towards the bottom of the menu.

     PROS: Get the similar user experience as prior approaches, with potentially lesser implementation cost then approach i. and avoid multiple passes that are needed in approach ii.

     CONS: Adds implementation complexity in each refactoring of identifying multiple nodes/tokens of interest and then register each action with a span.

   4. **Implementation 4**: Enforce common [helpers](https://github.com/dotnet/roslyn/blob/master/src/Features/Core/Portable/CodeRefactoringHelpers.cs) that each code refactoring ought to use to determine it's applicability span and bail out if that is not the case. We need to ensure we polish and/or extend the existing helpers, make them public as appropriate and audit all existing or just the problematic refactorings to ensure they are using these helpers.

2. **New UI for viewing available actions in a broader scope**: Create a separate tool window to show available code actions within a given scope (document/project/solution, with document being the default). Few open questions:
   1. Should the refactorings shown in this window be opt-in to avoid polluting it with common refactorings that show up everywhere?
   2. Should the tool window automatically be opened and brought to focus when user invokes light bulb and/or applies a code action? If not, how would we make this UI discoverable for users?
   3. Should the actions list in the window be ordered such that the actions closer to current cursor are near the top?
   We would potentially start with a simple UI, that only works for document scope to start with, and iterate on improving it to work with broader scopes.
</Description>
        <CreatedDate>06/05/2019</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>35180</IssueID>
        <Title>Offer codefixes on selections</Title>
        <Description>## Scenario
Codefixes often don't show if code is selected as opposed to only having your cursor placed within a word.
*  **5 out of the 11 users struggled with this in user studies.** 
* One user **only** ever double-clicked when clicking around the editor. This means he saw fewer codefixes since double clicking always selects the word and we don't show available codefixes in the context. Some users are used to double-clicking around their codebase.

## Proposal
Enable the same codefixes to appear if a block is selected as would appear if the cursor was placed inside a specific name. If this improves discoverability of codefixes we can enable this on a case-by-case basis per refactoring. My study observed more issues with the 'pull members up to base type' refactoring than others though general struggling was observed with many refactorings.

**Example: Pull members up**
Codefix offered when cursor is in the name:
![image](https://user-images.githubusercontent.com/8293542/56520118-8bb3e380-64f8-11e9-94fa-b79c60ed7ddb.png)

Codefix not offered if full line is selected:
![image](https://user-images.githubusercontent.com/8293542/56520215-bf8f0900-64f8-11e9-9022-7a5ebd464553.png)

**Example: Convert local function to method**
Offered if cursor is in name
![image](https://user-images.githubusercontent.com/8293542/56520344-0d0b7600-64f9-11e9-8fb9-6ac6d7b8de69.png)

Not offered when entire local function is selected
![image](https://user-images.githubusercontent.com/8293542/56520368-1ac0fb80-64f9-11e9-92a4-49037caea806.png)

**Example: LINQ to Foreach conversions**
![image](https://user-images.githubusercontent.com/8293542/56521136-1517e580-64fa-11e9-828a-a23aa22d8ce2.png)

If semi-colon is included in selection the conversion does not appear:
![image](https://user-images.githubusercontent.com/8293542/56521033-00d3e880-64fa-11e9-849f-2cc7a675f3ff.png)







</Description>
        <CreatedDate>22/04/2019</CreatedDate>
        <ClosedDate>06/09/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/GenerateOverrides/GenerateOverridesTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/RefactoringHelpers/RefactoringHelpersTests.cs</File>
      <File>src/Features/CSharp/Portable/CodeRefactorings/CSharpRefactoringHelpersService.cs</File>
      <File>src/Features/CSharp/Portable/GenerateMember/GenerateDefaultConstructors/CSharpGenerateDefaultConstructorsService.cs</File>
      <File>src/Features/Core/Portable/CodeRefactorings/AbstractRefactoringHelpersService.cs</File>
      <File>src/Features/Core/Portable/CodeRefactorings/IRefactoringHelpersService.cs</File>
      <File>src/Features/Core/Portable/CodeRefactorings/MoveType/AbstractMoveTypeService.cs</File>
      <File>src/Features/Core/Portable/GenerateConstructorFromMembers/GenerateConstructorFromMembersCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/GenerateEqualsAndGetHashCodeFromMembers/GenerateEqualsAndGetHashCodeFromMembersCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/GenerateOverrides/GenerateOverridesCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/IntroduceUsingStatement/AbstractIntroduceUsingStatementCodeRefactoringProvider.cs</File>
      <File>src/Workspaces/CSharp/Portable/LanguageServices/CSharpSyntaxFactsService.cs</File>
      <File>src/Workspaces/CSharp/Portable/LanguageServices/CSharpSyntaxKindsService.cs</File>
      <File>src/Workspaces/Core/Portable/LanguageServices/SyntaxFactsService/AbstractSyntaxFactsService.cs</File>
      <File>src/Workspaces/Core/Portable/LanguageServices/SyntaxFactsService/ISyntaxFactsService.cs</File>
      <File>src/Workspaces/Core/Portable/LanguageServices/SyntaxFactsService/ISyntaxKindsService.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>37117</IssueID>
    <Title>Remove reflection based workaround for IRecursivePatternOperation</Title>
    <Description>The API was made public in #36709, so we don't need a reflection based workaround

Fixes #36866

NOTE: We already have unit tests verifying the affected code path.</Description>
    <CreatedDate>10/07/2019</CreatedDate>
    <ClosedDate>10/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>36709</IssueID>
        <Title>Make IRecursivePatternOperation public</Title>
        <Description>Fixes #35843
</Description>
        <CreatedDate>24/06/2019</CreatedDate>
        <ClosedDate>01/07/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>36866</IssueID>
        <Title>Remove reflection now that IRecursivePatternOperation is public</Title>
        <Description>See https://github.com/dotnet/roslyn/pull/36709#discussion_r296939885

We should remove this IDE reflection based hack that was added for this API: http://source.roslyn.io/#Microsoft.CodeAnalysis.Workspaces/Extensions/OperationExtensions.cs,64

`case IOperation iop when iop.GetType().GetInterfaces().Any(i =&gt; i.Name == "IRecursivePatternOperation"):`

/cc @mavasani 
</Description>
        <CreatedDate>28/06/2019</CreatedDate>
        <ClosedDate>10/07/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Workspaces/Core/Portable/Extensions/OperationExtensions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>37072</IssueID>
    <Title>Move some ComputeRefactoringsAsync to common helpers 2/n</Title>
    <Description>Continuation of work on #35525 and #35180</Description>
    <CreatedDate>09/07/2019</CreatedDate>
    <ClosedDate>12/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>35525</IssueID>
        <Title>Improve discoverability of code refactorings</Title>
        <Description>A bunch of recent customer surveys done by @kendrahavens identified that quite a few customers find our refactorings to be not discoverable. The refactorings that they requested were already implemented by us, but they needed Kendra to point out where to put the cursor or how to change the selection span for these to show up in the light bulb menu. The same concern does not apply to code fixes due to visual cue from the squiggle/suggestion dots in the UI, and pressing Ctrl + dot anywhere on the line shows up the fix, ordering being based on the distance from the diagnostic span. Note that the primary reason why we don't show up all the refactorings available on a given line are to avoid overloading the light bulb menu, which is already quite noisy. We need to fine tune the experience here to find a balance between discoverability of actions and overloading the light bulb menu.

We have talked about adding 2 different discoverability enhancements to address these concerns:

1. **Show additional actions in light bulb menu**
Improve the discoverability of the refactorings in the light bulb, by showing additional, but likely less relevant actions, that are applicable for positions _near_ the current cursor or selection span. Most relevant refactorings would still be show at the top of the menu and these additional actions will either be shown at the bottom of the menu or nested within a separate menu towards the bottom. Internal discussions have led to bunch of different implementation suggestions on how to achieve this (discussed below), but the primary conclusion being that we need to somehow _associate a fix span/ideal span with each registered code action within a refactoring, so the engine can prioritize the ordering and/or nesting of these refactorings based on promixity of this span with current cursor position or selection span_.
Possible implementation approaches that came out:
   1. **Implementation 1**: Convert all the IDE refactorings that are not selection based into a pair of diagnostic analyzer reporting hidden diagnostics + code fix. The diagnostic span would be the ideal span for the code actions.

      PROS:
         1. All refactorings available on any position in a line show up in the light bulb, solving the discoverability concerns. 
         2. We get other useful analyzer/fixer features for free: fix all, ability to bump up the severity to see squiggles/error list entries across a wider scope, etc.

      CONS:
         1. Likely to overload the light bulb menu with lot more actions now showing up. If so, one option might be to move all the code actions registered for hidden diagnostics whose span does not intersect with current position into a nested menu near the bottom of the light bulb menu.
         2. This approach adds quite a bit of implementation cost as we need to refactor code in each code refactoring into a pair of diagnostic analyzer/code fix.

   2. **Implementation 2**: Currently, the refactoring service executes naively for identifying available actions for current cursor position or span. It passes in the entire line span or selection span into each refactoring, and then treats all registered refactorings to be on par with each other. This forces our refactorings to then be implemented in a restrictive manner, so they are not offered everywhere on the line and do not overload the light bulb menu. This whole setup relies on the assumption that users are already aware about where to put their cursor or what span to select to get the relevant refactorings, which does not seem to be true as mentioned at the start of this post. This proposal tries to remove this assumption by making the following changes:
      1. Change the code refactoring service to perform multiple passes instead of just one. It first identifies the current token/node at the position or selection span and identifies available actions. These would be the most relevant refactorings that get offered at the top level of the light bulb menu. Then the service walks up the parent node and asks available actions for the parent and siblings of previous token/node. These actions would automatically be assigned a lower priority and will be shown under a nested menu near the bottom. These additional nearby actions would serve as a discoverability point for beginner users, while also not polluting the menu for advanced users.
      2. Change all the refactorings so they only register an action if the input text span exactly matches the token/node that is most relevant to it.

     PROS:
         1. We do not alter the existing light bulb menu significantly for advanced/experienced users, while adding a new discoverability point for beginner users to discover new potential actions in nearby locations.
         2. The implementation for each refactoring is greatly simplified and unified as they only work when input span exactly matches it's fixed span.

      CONS: 
         1. We might end up with a perf hit due to the code refactoring service doing multiple passes. We would need perf measurements to identify if this indeed a concern as most refactorings would just bail out upfront. 
         2. We need to experiment/decide if a nested menu is indeed a good discoverability point as beginner users might not know that they need to dive into a nested menu at the bottom.

   3. **Implementation 3**: Allow refactorings to specify a span in [RegisterRefactoring](http://source.roslyn.io/#Microsoft.CodeAnalysis.Workspaces/CodeRefactorings/CodeRefactoringContext.cs,51) callback. This would serve as the virtual diagnostic span for the code action. We would need to change all the refactorings to then operate on all the nodes/tokens of interest in the input context span and register refactorings for each node/token with their span. The code refactoring service would be changed to prioritize refactorings whose registered span is a close match to current position/span, and show the rest of refactorings in a nested menu or towards the bottom of the menu.

     PROS: Get the similar user experience as prior approaches, with potentially lesser implementation cost then approach i. and avoid multiple passes that are needed in approach ii.

     CONS: Adds implementation complexity in each refactoring of identifying multiple nodes/tokens of interest and then register each action with a span.

   4. **Implementation 4**: Enforce common [helpers](https://github.com/dotnet/roslyn/blob/master/src/Features/Core/Portable/CodeRefactoringHelpers.cs) that each code refactoring ought to use to determine it's applicability span and bail out if that is not the case. We need to ensure we polish and/or extend the existing helpers, make them public as appropriate and audit all existing or just the problematic refactorings to ensure they are using these helpers.

2. **New UI for viewing available actions in a broader scope**: Create a separate tool window to show available code actions within a given scope (document/project/solution, with document being the default). Few open questions:
   1. Should the refactorings shown in this window be opt-in to avoid polluting it with common refactorings that show up everywhere?
   2. Should the tool window automatically be opened and brought to focus when user invokes light bulb and/or applies a code action? If not, how would we make this UI discoverable for users?
   3. Should the actions list in the window be ordered such that the actions closer to current cursor are near the top?
   We would potentially start with a simple UI, that only works for document scope to start with, and iterate on improving it to work with broader scopes.
</Description>
        <CreatedDate>06/05/2019</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>35180</IssueID>
        <Title>Offer codefixes on selections</Title>
        <Description>## Scenario
Codefixes often don't show if code is selected as opposed to only having your cursor placed within a word.
*  **5 out of the 11 users struggled with this in user studies.** 
* One user **only** ever double-clicked when clicking around the editor. This means he saw fewer codefixes since double clicking always selects the word and we don't show available codefixes in the context. Some users are used to double-clicking around their codebase.

## Proposal
Enable the same codefixes to appear if a block is selected as would appear if the cursor was placed inside a specific name. If this improves discoverability of codefixes we can enable this on a case-by-case basis per refactoring. My study observed more issues with the 'pull members up to base type' refactoring than others though general struggling was observed with many refactorings.

**Example: Pull members up**
Codefix offered when cursor is in the name:
![image](https://user-images.githubusercontent.com/8293542/56520118-8bb3e380-64f8-11e9-94fa-b79c60ed7ddb.png)

Codefix not offered if full line is selected:
![image](https://user-images.githubusercontent.com/8293542/56520215-bf8f0900-64f8-11e9-9022-7a5ebd464553.png)

**Example: Convert local function to method**
Offered if cursor is in name
![image](https://user-images.githubusercontent.com/8293542/56520344-0d0b7600-64f9-11e9-8fb9-6ac6d7b8de69.png)

Not offered when entire local function is selected
![image](https://user-images.githubusercontent.com/8293542/56520368-1ac0fb80-64f9-11e9-92a4-49037caea806.png)

**Example: LINQ to Foreach conversions**
![image](https://user-images.githubusercontent.com/8293542/56521136-1517e580-64fa-11e9-828a-a23aa22d8ce2.png)

If semi-colon is included in selection the conversion does not appear:
![image](https://user-images.githubusercontent.com/8293542/56521033-00d3e880-64fa-11e9-849f-2cc7a675f3ff.png)







</Description>
        <CreatedDate>22/04/2019</CreatedDate>
        <ClosedDate>06/09/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/CodeActions/ConvertLocalFunctionToMethod/ConvertLocalFunctionToMethodTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/CodeActions/InlineTemporary/InlineTemporaryTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/PullMemberUp/CSharpPullMemberUpTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/RefactoringHelpers/RefactoringHelpersTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseNamedArguments/UseNamedArgumentsTests.cs</File>
      <File>src/Features/CSharp/Portable/CodeRefactorings/CSharpRefactoringHelpersService.cs</File>
      <File>src/Features/CSharp/Portable/CodeRefactorings/InlineTemporary/InlineTemporaryCodeRefactoringProvider.cs</File>
      <File>src/Features/CSharp/Portable/ConvertNumericLiteral/CSharpConvertNumericLiteralCodeRefactoringProvider.cs</File>
      <File>src/Features/CSharp/Portable/ReplaceMethodWithProperty/CSharpReplaceMethodWithPropertyService.cs</File>
      <File>src/Features/CSharp/Portable/ReplacePropertyWithMethods/CSharpReplacePropertyWithMethodsService.cs</File>
      <File>src/Features/Core/Portable/CodeRefactorings/AbstractRefactoringHelpersService.cs</File>
      <File>src/Features/Core/Portable/ConvertNumericLiteral/AbstractConvertNumericLiteralCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/InitializeParameter/AbstractInitializeParameterCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/ReplaceMethodWithProperty/AbstractReplaceMethodWithPropertyService.cs</File>
      <File>src/Features/Core/Portable/ReplaceMethodWithProperty/IReplaceMethodWithPropertyService.cs</File>
      <File>src/Features/Core/Portable/ReplaceMethodWithProperty/ReplaceMethodWithPropertyCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/ReplacePropertyWithMethods/AbstractReplacePropertyWithMethodsService.cs</File>
      <File>src/Features/Core/Portable/ReplacePropertyWithMethods/IReplacePropertyWithMethodsService.cs</File>
      <File>src/Features/Core/Portable/ReplacePropertyWithMethods/ReplacePropertyWithMethodsCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/UseNamedArguments/AbstractUseNamedArgumentsCodeRefactoringProvider.cs</File>
      <File>src/Features/LanguageServer/ProtocolUnitTests/CodeActions/CodeActionsTests.cs</File>
      <File>src/Workspaces/CSharp/Portable/LanguageServices/CSharpSyntaxFactsService.cs</File>
      <File>src/Workspaces/Core/Portable/LanguageServices/SyntaxFactsService/AbstractSyntaxFactsService.cs</File>
      <File>src/Workspaces/Core/Portable/LanguageServices/SyntaxFactsService/ISyntaxFactsService.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>36491</IssueID>
    <Title>Show &lt;value&gt; documentation in Metadata as Source and Object Browser</Title>
    <Description>* Show `&lt;value&gt;` documentation in Metadata as Source
* Show `&lt;value&gt;` documentation in Object Browser

This establishes the initial data flow and first features as a prerequisite for #31618 and #8627.</Description>
    <CreatedDate>15/06/2019</CreatedDate>
    <ClosedDate>06/02/2020</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>31618</IssueID>
        <Title>Intellisense Return Value Documentation</Title>
        <Description>&lt;p&gt;I can't believe this still hasn't been done in VS...can someone PLEASE make it possible to display the &amp;lt;return&amp;gt; xml doc content in Intellisense? The return value documentation is usually only a single line and it is extremely important to properly using methods and properties. I really don't understand why it's expected that I go to the online docs everytime I want to figure out what a method is returning.&lt;/p&gt;

_This issue has been moved from https://developercommunity.visualstudio.com/content/idea/402037/intellisense-return-value-documentation.html
VSTS ticketId: 743723_
_These are the original issue comments:_
(no comments)</Description>
        <CreatedDate>07/12/2018</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>8627</IssueID>
        <Title>VB XML doc inconsistency between template and IntelliSense for property (template contains &lt;returns&gt;, IntelliseSense not)</Title>
        <Description>Related to #8546, there is inconsistency between what gets inserted when I type ''', and what IntelliSense offers for properties.
When I type ''' above property &lt;summary&gt;

 and &lt;returns&gt; gets inserted. But when I delete &lt;returns&gt; and want to insert it again, IntelliSense does not offer it.
![vbprop](https://cloud.githubusercontent.com/assets/2221259/13007609/d1f9d636-d191-11e5-9dba-7366a04bda80.png)
</Description>
        <CreatedDate>12/02/2016</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/Test/MetadataAsSource/DocCommentFormatterTests.cs</File>
      <File>src/Features/Core/Portable/FeaturesResources.Designer.cs</File>
      <File>src/Features/Core/Portable/MetadataAsSource/AbstractMetadataAsSourceService.DocCommentFormatter.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Library/ObjectBrowser/AbstractDescriptionBuilder.cs</File>
      <File>src/VisualStudio/Core/Def/ServicesVSResources.Designer.cs</File>
      <File>src/Workspaces/Core/Portable/Shared/Utilities/DocumentationComment.cs</File>
      <File>src/Workspaces/CoreTest/UtilityTest/DocumentationCommentTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>36464</IssueID>
    <Title>(rebased) Add 'annotations' and 'warnings' support to nullable directive</Title>
    <Description>Resolves #35730. Resolves #35748. Resolves #35747.

You may wish to review this PR commit-by-commit, as several of the commits are just boilerplate to add or remove keywords from syntax nodes, etc.</Description>
    <CreatedDate>14/06/2019</CreatedDate>
    <ClosedDate>19/06/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>35730</IssueID>
        <Title>NoWarn is not respected in nullability analysis</Title>
        <Description>Consider this program:

```csharp
using System;

#nullable enable

namespace NullnessExample
{
    class Program
    {
        public void M(string? theString)
        {
            // In the project file, this warning code is suppressed, but the nowarn is ignored.
            Console.WriteLine($"Length is {theString.Length}");
        }
        static void Main(string[] args)
        {
            // Explicitly trigger a warning here, note that is gets suppressed
            while (false) { Console.Write(""); }

            Console.WriteLine("Hello World!");
        }
    }
}
```

And a corresponding project file:

```xml
&lt;Project Sdk="Microsoft.NET.Sdk"&gt;

  &lt;PropertyGroup&gt;
    &lt;OutputType&gt;Exe&lt;/OutputType&gt;
    &lt;TargetFramework&gt;netcoreapp2.2&lt;/TargetFramework&gt;
    &lt;LangVersion&gt;8.0&lt;/LangVersion&gt;
  &lt;/PropertyGroup&gt;

  &lt;PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|AnyCPU'"&gt;
    &lt;NoWarn&gt;1701;1702; 8602; 0162&lt;/NoWarn&gt;
  &lt;/PropertyGroup&gt;

&lt;/Project&gt;
```

**Expected**

No nullability warning.

**Actual**

The `CS8602` warning is still emitted.

The `CS0162` warning, by comparison, is correctly suppressed.</Description>
        <CreatedDate>15/05/2019</CreatedDate>
        <ClosedDate>19/06/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>35748</IssueID>
        <Title>Add support for `#nullable (enable | disable | restore) [ warnings | annotations ])`</Title>
        <Description>- Add support for `#nullable (enable | disable | restore) [ warnings | annotations ])`
- Track a "nullable warning context"
- Add support for `/nullable:annotations`
- Add support for `/NoWarn:nullable`

https://github.com/dotnet/csharplang/blob/master/meetings/2019/LDM-2019-05-13.md

&gt; 1. There is a nullable warning context as a separate "bit". It can be set by default at project-level, and overridden with `#nullable` directives. It needs to be on to get nullable warnings at a given point in the source.
&gt; 2. Individual warnings continue to be able to be individually disabled at the project-level with `/NoWarn` and disabled or restored in source with `#pragma warning ...`.
&gt; 3. Additionally there is a "virtual warning identifier", `nullable` that can be used in `/NoWarn` at the project level, and that individually disables all warnings related to the nullable feature.

</Description>
        <CreatedDate>16/05/2019</CreatedDate>
        <ClosedDate>19/06/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>35747</IssueID>
        <Title>Remove support for "nullable" group in `#pragma warning ...`</Title>
        <Description>Tentative decision from https://github.com/dotnet/csharplang/blob/master/meetings/2019/LDM-2019-05-13.md but needs to be confirmed after discussion of `pragma warning enable ...`

Relates to https://github.com/dotnet/roslyn/issues/35748 (Add support for `#nullable (enable | disable | restore) [ warnings | annotations ])`)</Description>
        <CreatedDate>16/05/2019</CreatedDate>
        <ClosedDate>19/06/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Constraints.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Symbols.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/BuckStopsHereBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/WithNullableContextBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/CSharpResources.Designer.cs</File>
      <File>src/Compilers/CSharp/Portable/CommandLine/CSharpCommandLineParser.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/CSharpDiagnosticFilter.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/ErrorCode.cs</File>
      <File>src/Compilers/CSharp/Portable/Generated/Syntax.xml.Internal.Generated.cs</File>
      <File>src/Compilers/CSharp/Portable/Generated/Syntax.xml.Main.Generated.cs</File>
      <File>src/Compilers/CSharp/Portable/Generated/Syntax.xml.Syntax.Generated.cs</File>
      <File>src/Compilers/CSharp/Portable/NullableContextOptions.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/DirectiveParser.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/CSharpPragmaWarningStateMap.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/CSharpSyntaxTree.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/NullableContextStateMap.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/NullableDirectiveMap.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/PragmaWarningDirectiveTriviaSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/SyntaxFactory.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/SyntaxKind.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/SyntaxKindFacts.cs</File>
      <File>src/Compilers/CSharp/Test/CommandLine/CommandLineTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Attributes/AttributeTests_Nullable.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/NullableReferenceTypesTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Diagnostics/DiagnosticTest.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Generated/Syntax.Test.xml.Generated.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/LexicalAndXml/PreprocessorTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Classification/SyntacticClassifierTests_Preprocessor.cs</File>
      <File>src/EditorFeatures/CSharpTest2/Recommendations/AnnotationsKeywordRecommenderTests.cs</File>
      <File>src/EditorFeatures/CSharpTest2/Recommendations/WarningsKeywordRecommenderTests.cs</File>
      <File>src/Features/CSharp/Portable/Completion/CompletionProviders/KeywordCompletionProvider.cs</File>
      <File>src/Features/CSharp/Portable/Completion/KeywordRecommenders/AnnotationsKeywordRecommender.cs</File>
      <File>src/Features/CSharp/Portable/Completion/KeywordRecommenders/WarningsKeywordRecommender.cs</File>
      <File>src/Workspaces/CSharp/Portable/Classification/Worker_Preprocesser.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>36395</IssueID>
    <Title>Don't show full attribute type name if in attribute name context</Title>
    <Description>Fix #35540
Also Fix #35124 to show correct suffix for generics in VB.

I also contemplated a different approach , which involves 
1. unseal CompletionItem, 
2. Derive a ImportCompletionItem from it
3. add mutable states to ImportCompletionItem , i.e. "IsAttribute", "IsGeneric", etc, and return different display/suffix/sort/etc. text, based on the current state.

Pros: this approach might be simpler as it requires less code change.

Cons: We will not be able to cache any data for creating VS completion items for generic/attribute types, so they will be calculated every time. In contrast, the current appraoch I'm using only need to do calculation in following scenarios (which is arguably rare):
- For generic types, if cache items are created for one language but completion is triggered by code written in another. e.g. if the first completion is triggered in C# project, but later an edit is being made in VB code.
- for attribute types, if completion is triggered in attribute name context.

@CyrusNajmabadi @jasonmalinowski @dpoeschl

TODO:

- [x] perf analysis
- [ ] Add tests for triggering completion in multiple files.</Description>
    <CreatedDate>13/06/2019</CreatedDate>
    <ClosedDate>10/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>35540</IssueID>
        <Title>Completion from unimported types should strip "Attribute" from attributes</Title>
        <Description>When a namespace is unimported, the completion list for attributes doesn't strip the word "Attribute" from the end.

Before importing:
![image](https://user-images.githubusercontent.com/754264/57257204-9b115180-700d-11e9-99b7-df7a460579f6.png)

After importing:
![image](https://user-images.githubusercontent.com/754264/57257233-a9f80400-700d-11e9-8ea1-18e7c160cacd.png)

It would be ideal if both experiences were the same, or at the very least the actual completion dropped the "Attribute" suffix so the resulting code was more idiomatic.</Description>
        <CreatedDate>06/05/2019</CreatedDate>
        <ClosedDate>10/07/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>35124</IssueID>
        <Title>Generic type name from Import completion should be language specific</Title>
        <Description>Right now, generic types are always displayed in C# even when completion is invoked in VB code.
i.e. `Foo&lt;&gt;` instead of `Foo(Of ...)`</Description>
        <CreatedDate>18/04/2019</CreatedDate>
        <ClosedDate>10/07/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/Core/Portable/InternalUtilities/StringExtensions.cs</File>
      <File>src/EditorFeatures/CSharpTest/Completion/CompletionProviders/TypeImportCompletionProviderTests.cs</File>
      <File>src/EditorFeatures/TestUtilities/Completion/AbstractCompletionProviderTests.cs</File>
      <File>src/Features/CSharp/Portable/Completion/CompletionProviders/ImportCompletion/CSharpTypeImportCompletionServiceFactory.cs</File>
      <File>src/Features/CSharp/Portable/Completion/CompletionProviders/ImportCompletion/TypeImportCompletionProvider.cs</File>
      <File>src/Features/Core/Portable/Completion/Providers/ImportCompletionProvider/AbstractTypeImportCompletionProvider.cs</File>
      <File>src/Features/Core/Portable/Completion/Providers/ImportCompletionProvider/AbstractTypeImportCompletionService.cs</File>
      <File>src/Features/Core/Portable/Completion/Providers/ImportCompletionProvider/AbstractTypeImportCompletionService_CacheService.cs</File>
      <File>src/Features/Core/Portable/Completion/Providers/ImportCompletionProvider/ITypeImportCompletionService.cs</File>
      <File>src/Features/Core/Portable/Completion/Providers/ImportCompletionProvider/TypeImportCompletionItem.cs</File>
      <File>src/Features/Core/Portable/Completion/Providers/TypeImportCompletionService.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>36067</IssueID>
    <Title>Add new analyzer API (DiagnosticSuppressor) to allow programmatic sup…</Title>
    <Description>…pression of analyzer and/or compiler non-error diagnostics

Fixes #20242 
Fixes #30172

Detailed design proposal [here](https://gist.github.com/mavasani/fcac17a9581b5c54cef8a689eeec954a)</Description>
    <CreatedDate>30/05/2019</CreatedDate>
    <ClosedDate>19/06/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>20242</IssueID>
        <Title>Allow an analyzer to suppress diagnostics</Title>
        <Description>There are several situations where it would be helpful for an analyzer, or an analyzer assembly, to have the ability to suppress diagnostics reported by another analyzer or as a warning by the compiler. For example:

* StyleCop Analyzers rule to "Use 'this.'" could automatically disable the IDE warning with the same intent
* Analyzers could suppress compiler warnings like CS1591 using application-specific logic

Such a "Diagnostic Filter" feature would likely run after analysis is complete, and be provided a list of reported diagnostics with the ability to suppress specific diagnostics. It would be helpful if the diagnostics were treated as suppressed in the Error List window, with the suppression source set to the name of the filter responsible for suppressing it.</Description>
        <CreatedDate>15/06/2017</CreatedDate>
        <ClosedDate>19/06/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>30172</IssueID>
        <Title>Programmatic suppression of warnings</Title>
        <Description>Serialization frameworks and tools embedding .NET Core or Mono often set the value of fields or call methods outside of user code.

This leads the IDE to show warning about unused code while the user of the framework knows the fields and methods are going to be used. One example of this scenario is Unity. A typical game object will look like this:

```csharp
using UnityEngine;

class BulletMovement : MonoBehaviour
{
    [SerializeField] private float speed;

    private void Update()
    {
         this.transform.position *= speed;
    }
}
```

In that case:

* the value of the field speed is set by Unity based on the value set in the Unity Editor.
* the method Update is going to be invoked by Unity at each and every frame of the game.

For the Tools for Unity, we'd like a way to suppress the warning `CS0649` for the field.

If down the line there is a warning about an unused private method such as Update, we'll want to suppress it as well.

@tmat suggested offline:

&gt; we could allow analyzers to register for callbacks on specified compiler warnings, pass the callback the context and let it decide whether the warning should be reported or not.

</Description>
        <CreatedDate>27/09/2018</CreatedDate>
        <ClosedDate>19/06/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Compilation/CSharpCompilation.cs</File>
      <File>src/Compilers/CSharp/Test/CommandLine/CommandLineTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Diagnostics/DiagnosticAnalyzerTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Diagnostics/DiagnosticSuppressorTests.cs</File>
      <File>src/Compilers/Core/Portable/CodeAnalysisResources.Designer.cs</File>
      <File>src/Compilers/Core/Portable/CommandLine/CommonCompiler.SuppressionDiagnostic.cs</File>
      <File>src/Compilers/Core/Portable/CommandLine/CommonCompiler.cs</File>
      <File>src/Compilers/Core/Portable/Compilation/Compilation.cs</File>
      <File>src/Compilers/Core/Portable/Diagnostic/Diagnostic.DiagnosticWithProgrammaticSuppression.cs</File>
      <File>src/Compilers/Core/Portable/Diagnostic/Diagnostic.cs</File>
      <File>src/Compilers/Core/Portable/Diagnostic/DiagnosticDescriptor.cs</File>
      <File>src/Compilers/Core/Portable/Diagnostic/ProgrammaticSuppressionInfo.cs</File>
      <File>src/Compilers/Core/Portable/Diagnostic/SuppressionDescriptor.cs</File>
      <File>src/Compilers/Core/Portable/DiagnosticAnalyzer/AnalysisResultBuilder.cs</File>
      <File>src/Compilers/Core/Portable/DiagnosticAnalyzer/AnalyzerDriver.cs</File>
      <File>src/Compilers/Core/Portable/DiagnosticAnalyzer/AnalyzerExecutor.cs</File>
      <File>src/Compilers/Core/Portable/DiagnosticAnalyzer/AnalyzerManager.AnalyzerExecutionContext.cs</File>
      <File>src/Compilers/Core/Portable/DiagnosticAnalyzer/AnalyzerManager.cs</File>
      <File>src/Compilers/Core/Portable/DiagnosticAnalyzer/AnalyzerTelemetry.cs</File>
      <File>src/Compilers/Core/Portable/DiagnosticAnalyzer/CompilationWithAnalyzers.cs</File>
      <File>src/Compilers/Core/Portable/DiagnosticAnalyzer/DiagnosticAnalysisContext.cs</File>
      <File>src/Compilers/Core/Portable/DiagnosticAnalyzer/DiagnosticSuppressor.cs</File>
      <File>src/Compilers/Core/Portable/DiagnosticAnalyzer/Suppression.cs</File>
      <File>src/Compilers/Test/Utilities/CSharp/TestOptions.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/AnalyzerHelper.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/DiagnosticResultSerializer.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/Log/DiagnosticLogAggregator.cs</File>
      <File>src/Test/Utilities/Portable/Diagnostics/CommonDiagnosticAnalyzers.cs</File>
      <File>src/Test/Utilities/Portable/Diagnostics/DiagnosticDescription.cs</File>
      <File>src/Test/Utilities/Portable/Diagnostics/DiagnosticExtensions.cs</File>
      <File>src/Tools/AnalyzerRunner/DiagnosticAnalyzerRunner.cs</File>
      <File>src/Tools/AnalyzerRunner/Extensions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>36028</IssueID>
    <Title>Implement Quick Info support for 'inheritdoc'</Title>
    <Description>Implements the primary features from dotnet/csharplang#313 as an IDE feature.

The first two commits are shared with #35667.</Description>
    <CreatedDate>29/05/2019</CreatedDate>
    <ClosedDate>13/08/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>313</IssueID>
        <Title>Fix Roslyn.sln</Title>
        <Description>
        </Description>
        <CreatedDate>09/02/2015</CreatedDate>
        <ClosedDate>09/02/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>35667</IssueID>
        <Title>Implement Quick Info styles</Title>
        <Description>* Support emphasis in Quick Info (`&lt;em&gt;` and `&lt;i&gt;` elements in XML documentation comments)
* Support strong in Quick Info (`&lt;strong&gt;` and `&lt;b&gt;` elements in XML documentation comments)
* Support code font in Quick Info (`&lt;c&gt;`, `&lt;code&gt;`, `&lt;tt&gt;` elements in XML documentation comments)
* Support bullet and numbered lists in Quick Info
* Support definition lists in Quick Info
* Support navigating to `cref` items by clicking in Quick Info
* Support navigating to `href` hyperlinks in Quick Info (`&lt;see href` and `&lt;a href`)

### Images

⚠️ This picture is *slightly* outdated relative to current behavior (both links to https://google.com now render correctly, and the spacing for list items has changed slightly.
![image](https://user-images.githubusercontent.com/1408396/57576804-51ba6b00-742e-11e9-9646-3788f4e534e5.png)

![image](https://user-images.githubusercontent.com/1408396/57576812-7878a180-742e-11e9-8721-8b948fcdd170.png)
</Description>
        <CreatedDate>12/05/2019</CreatedDate>
        <ClosedDate>25/07/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/Core/Portable/InternalUtilities/DocumentationCommentXmlNames.cs</File>
      <File>src/EditorFeatures/CSharpTest/Completion/CompletionProviders/XmlDocumentationCommentCompletionProviderTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/QuickInfo/SemanticQuickInfoSourceTests.cs</File>
      <File>src/Features/Core/Portable/Completion/Providers/AbstractDocCommentCompletionProvider.cs</File>
      <File>src/Features/Core/Portable/LanguageServices/SymbolDisplayService/AbstractSymbolDisplayService.AbstractSymbolDescriptionBuilder.cs</File>
      <File>src/Features/Core/Portable/Shared/Extensions/ISymbolExtensions_2.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Library/ObjectBrowser/AbstractDescriptionBuilder.cs</File>
      <File>src/Workspaces/Core/Portable/Shared/Extensions/ISymbolExtensions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>35957</IssueID>
    <Title>Add Default Interface Implementation tests for VB</Title>
    <Description>Related to #35820, #35821, #35823, #35824, #35827, #35834, #35852, #35885, #35911, #35948.</Description>
    <CreatedDate>24/05/2019</CreatedDate>
    <ClosedDate>02/06/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>35820</IssueID>
        <Title>VB DIM: Class is not required to implement a virtual interface method</Title>
        <Description>
```
        &lt;Fact&gt;
        Public Sub MethodImplementation_01()

            Dim csSource =
"
public interface I1
{
    void M1() 
    {
    }
}
"
            Dim csCompiation = GetCSharpCompiation(csSource).EmitToImageReference()

            Dim source1 =
&lt;compilation&gt;
    &lt;file name="c.vb"&gt;&lt;![CDATA[
Public Class C
    Implements I1
End Class
]]&gt;&lt;/file&gt;
&lt;/compilation&gt;

            Dim comp1 = CreateCompilation(source1, targetFramework:=TargetFramework.NetStandardLatest, references:={csCompiation})
            comp1.AssertTheseDiagnostics(
&lt;errors&gt;
BC30149: Class 'C' must implement 'Sub M1()' for interface 'I1'.
    Implements I1
               ~~
&lt;/errors&gt;
            )
        End Sub
```

Observed: The expected error is not reported</Description>
        <CreatedDate>20/05/2019</CreatedDate>
        <ClosedDate>19/08/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>35821</IssueID>
        <Title>VB DIM: Class cannot implement a virtual interface method</Title>
        <Description>```
        &lt;Fact&gt;
        Public Sub MethodImplementation_02()

            Dim csSource =
"
public interface I1
{
    void M1() 
    {
    }
}
"
            Dim csCompiation = GetCSharpCompiation(csSource).EmitToImageReference()

            Dim source1 =
&lt;compilation&gt;
    &lt;file name="c.vb"&gt;&lt;![CDATA[
Public Class C
    Implements I1

    Sub M1() Implements I1.M1
        System.Console.WriteLine("C.M1")
    End Sub

    Shared Sub Main()
        Dim i1 As I1 = new C()
        i1.M1()
    End Sub
End Class
]]&gt;&lt;/file&gt;
&lt;/compilation&gt;

            Dim comp1 = CreateCompilation(source1, options:=TestOptions.DebugExe, targetFramework:=TargetFramework.NetStandardLatest, references:={csCompiation})
            CompileAndVerify(comp1, expectedOutput:=If(ExecutionConditionUtil.IsMonoOrCoreClr, "C.M1", Nothing), verify:=VerifyOnMonoOrCoreClr)
        End Sub
```

Observed:
```
c.vb(4) : error BC30401: 'M1' cannot implement 'M1' because there is no matching sub on interface 'I1'.
```</Description>
        <CreatedDate>20/05/2019</CreatedDate>
        <ClosedDate>14/08/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>35823</IssueID>
        <Title>VB DIM: Class is required to implement a method representing a re-abstraction of an interface method from base interface</Title>
        <Description>```
        &lt;Fact&gt;
        Public Sub MethodImplementation_06()

            Dim csSource =
"
public interface I1
{
    void M1();
}

public interface I2 : I1
{
    abstract void I1.M1();
}
"
            Dim csCompiation = GetCSharpCompiation(csSource).EmitToImageReference()

            Dim source1 =
&lt;compilation&gt;
    &lt;file name="c.vb"&gt;&lt;![CDATA[
Public Class C
    Implements I2

    Sub M1() Implements I1.M1
        System.Console.WriteLine("C.M1")
    End Sub

    Shared Sub Main()
        Dim i1 As I1 = new C()
        i1.M1()
    End Sub
End Class
]]&gt;&lt;/file&gt;
&lt;/compilation&gt;

            Dim comp1 = CreateCompilation(source1, options:=TestOptions.DebugExe, targetFramework:=TargetFramework.NetStandardLatest, references:={csCompiation})
            CompileAndVerify(comp1, expectedOutput:=If(ExecutionConditionUtil.IsMonoOrCoreClr, "C.M1", Nothing), verify:=VerifyOnMonoOrCoreClr)
        End Sub
```

Observed:
```
c.vb(2) : error BC30149: Class 'C' must implement 'Sub I1.M1()' for interface 'I2'.
```</Description>
        <CreatedDate>20/05/2019</CreatedDate>
        <ClosedDate>19/08/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>35824</IssueID>
        <Title>VB DIM: No error is reported for an attempt to implement an inaccessible interface method</Title>
        <Description>```
        &lt;Fact&gt;
        Public Sub MethodImplementation_07()

            Dim csSource =
"
public interface I1
{
    internal void M1();
}
"
            Dim csCompiation = GetCSharpCompiation(csSource).EmitToImageReference()

            Dim source1 =
&lt;compilation&gt;
    &lt;file name="c.vb"&gt;&lt;![CDATA[
Public Class C
    Implements I1

    Sub M1() Implements I1.M1
    End Sub
End Class
]]&gt;&lt;/file&gt;
&lt;/compilation&gt;

            Dim comp1 = CreateCompilation(source1, targetFramework:=TargetFramework.NetStandardLatest, references:={csCompiation})
            comp1.AssertTheseDiagnostics(
&lt;errors&gt;
&lt;/errors&gt;
            )
        End Sub
```

Observed: No error is reported

Expected: An error saying something like: "'I1.M1' is inaccessible due to its protection level"</Description>
        <CreatedDate>20/05/2019</CreatedDate>
        <ClosedDate>19/08/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>35827</IssueID>
        <Title>VB DIM: Unexpected accessibility error while trying to access protected method declared in an interface</Title>
        <Description>```
        &lt;Fact&gt;
        Public Sub MethodImplementation_13()

            Dim csSource =
"
public interface I1
{
    protected static void M1()
    {
        System.Console.WriteLine(""I1.M1"");
    }
}
"
            Dim csCompiation = GetCSharpCompiation(csSource).EmitToImageReference()

            Dim source1 =
&lt;compilation&gt;
    &lt;file name="c.vb"&gt;&lt;![CDATA[
Public Class C
    Implements I1
    Shared Sub Main()
        I1.M1()
    End Sub
End Class
]]&gt;&lt;/file&gt;
&lt;/compilation&gt;

            Dim comp1 = CreateCompilation(source1, options:=TestOptions.DebugExe, targetFramework:=TargetFramework.NetStandardLatest, references:={csCompiation})
            CompileAndVerify(comp1, expectedOutput:=If(ExecutionConditionUtil.IsMonoOrCoreClr, "I1.M1", Nothing), verify:=VerifyOnMonoOrCoreClr)
        End Sub
```

Observed:
```
c.vb(4) : error BC30390: 'I1.Sub M1()' is not accessible in this context because it is 'Protected'.
```

Consuming public static methods works</Description>
        <CreatedDate>20/05/2019</CreatedDate>
        <ClosedDate>20/08/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>35834</IssueID>
        <Title>VB DIM: An attempt to use protected method declared in an interface from code targeting desktop framework doesn't cause runtime capability error</Title>
        <Description>```
        &lt;Fact&gt;
        Public Sub MethodImplementation_27()

            Dim csSource =
"
public interface I1
{
    protected static string M1()
    {
        return ""I1.M1"";
    }
}
"
            Dim csCompiation = GetCSharpCompiation(csSource).EmitToImageReference()

            Dim source1 =
&lt;compilation&gt;
    &lt;file name="c.vb"&gt;&lt;![CDATA[
Public Class C
    Implements I1
    Shared Sub Main()
        System.Console.WriteLine(I1.M1())
    End Sub
End Class
]]&gt;&lt;/file&gt;
&lt;/compilation&gt;

            Dim comp1 = CreateCompilation(source1, options:=TestOptions.DebugExe, targetFramework:=TargetFramework.DesktopLatestExtended, references:={csCompiation})
            comp1.AssertTheseDiagnostics(
&lt;error&gt;
BC30390: 'I1.Function M1() As String' is not accessible in this context because it is 'Protected'.
        System.Console.WriteLine(I1.M1())
                                 ~~~~~
&lt;/error&gt;)
        End Sub
```

Expect to see an error similar to:
```
error CS8707: Target runtime doesn't support 'protected', 'protected internal', or 'private protected' accessibility for a member of an interface.
```

Observed: Only accessibility error is reported which will go away once https://github.com/dotnet/roslyn/issues/35827 is fixed.</Description>
        <CreatedDate>21/05/2019</CreatedDate>
        <ClosedDate>30/08/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>35852</IssueID>
        <Title>VB DIM: An attempt to embed an interface with non-abstract members should cause an error</Title>
        <Description>```
        &lt;Fact&gt;
        Public Sub NoPia_02()
            Dim attributesRef = GetCSharpCompiation(NoPiaAttributes).EmitToImageReference()

            Dim csSource =
"
using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;

[assembly: PrimaryInteropAssemblyAttribute(1,1)]
[assembly: Guid(""f9c2d51d-4f44-45f0-9eda-c9d599b58257"")]

[ComImport()]
[Guid(""f9c2d51d-4f44-45f0-9eda-c9d599b58279"")]
public interface ITest33
{
    void M1(){}
}
" + NoPiaAttributes

            Dim csCompiation = GetCSharpCompiation(csSource, {attributesRef}).EmitToImageReference(embedInteropTypes:=True)

            Dim source1 =
&lt;compilation&gt;
    &lt;file name="c.vb"&gt;&lt;![CDATA[
class UsePia 
    Sub Main(x as ITest33)
        x.M1()
    End Sub
End Class
]]&gt;&lt;/file&gt;
&lt;/compilation&gt;

            Dim comp1 = CreateCompilation(source1, targetFramework:=TargetFramework.NetStandardLatest, references:={attributesRef, csCompiation})
            ' Expect an error similar to - CS8711: Type 'ITest33' cannot be embedded because it has a non-abstract member. Consider setting the 'Embed Interop Types' property to false.
            comp1.AssertTheseDiagnostics()
        End Sub
```</Description>
        <CreatedDate>21/05/2019</CreatedDate>
        <ClosedDate>21/08/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>35885</IssueID>
        <Title>VB DIM: An attempt to use non virtual method with implementation declared in an interface from code targeting desktop framework should cause runtime capability error</Title>
        <Description>```
        &lt;Fact&gt;
        Public Sub MethodImplementation_31()

            Dim csSource =
"
public interface I1
{
    sealed string M1() =&gt; ""I1.M1"";
}
"
            Dim csCompiation = GetCSharpCompiation(csSource).EmitToImageReference()

            Dim source1 =
&lt;compilation&gt;
    &lt;file name="c.vb"&gt;&lt;![CDATA[
Public Class C
    Shared Sub Main()
        Dim i1 as I1 = New Test()
        i1.M1()
    End Sub
End Class

Class Test
    Implements I1
End Class
]]&gt;&lt;/file&gt;
&lt;/compilation&gt;

            Dim comp1 = CreateCompilation(source1, options:=TestOptions.DebugExe, targetFramework:=TargetFramework.DesktopLatestExtended, references:={csCompiation})
            ' Expect an error similar to - error CS8501: Target runtime doesn't support default interface implementation.
            comp1.AssertTheseDiagnostics()
        End Sub
```</Description>
        <CreatedDate>22/05/2019</CreatedDate>
        <ClosedDate>30/08/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>35911</IssueID>
        <Title>An attempt to embed an interface with a re-abstraction of a method from base should produce an error</Title>
        <Description>```
        [Fact]
        public void NoPia_10()
        {
            var attributes = CreateCompilation(NoPiaAttributes, options: TestOptions.ReleaseDll, targetFramework: TargetFramework.NetStandardLatest);
            var attributesRef = attributes.EmitToImageReference();

            string pia = @"
using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;

[assembly: PrimaryInteropAssemblyAttribute(1,1)]
[assembly: Guid(""f9c2d51d-4f44-45f0-9eda-c9d599b58257"")]

[ComImport()]
[Guid(""f9c2d51d-4f44-45f0-9eda-c9d599b58279"")]
public interface ITest33
{
    void M1();
}

[ComImport()]
[Guid(""f9c2d51d-4f44-45f0-9eda-c9d599b58280"")]
public interface ITest44 : ITest33
{
    abstract void ITest33.M1();
}
";

            var piaCompilation = CreateCompilation(pia, options: TestOptions.ReleaseDll, references: new[] { attributesRef }, targetFramework: TargetFramework.NetStandardLatest);

            CompileAndVerify(piaCompilation, verify: VerifyOnMonoOrCoreClr);

            string consumer = @"
class UsePia
{
    public static void Main(ITest44 x)
    {
        x.M1();
    }
} 
";

            foreach (var reference in new[] { piaCompilation.ToMetadataReference(embedInteropTypes: true), piaCompilation.EmitToImageReference(embedInteropTypes: true) })
            {
                var compilation1 = CreateCompilation(consumer, options: TestOptions.ReleaseDll, references: new[] { reference, attributesRef }, targetFramework: TargetFramework.NetStandardLatest);

                compilation1.VerifyEmitDiagnostics(
                    // (4,29): error CS8711: Type 'ITest44' cannot be embedded because it has a non-abstract member. Consider setting the 'Embed Interop Types' property to false.
                    //     public static void Main(ITest44 x)
                    Diagnostic(ErrorCode.ERR_DefaultInterfaceImplementationInNoPIAType, "ITest44").WithArguments("ITest44").WithLocation(4, 29)
                    );
            }
        }
```</Description>
        <CreatedDate>23/05/2019</CreatedDate>
        <ClosedDate>21/08/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>35948</IssueID>
        <Title>VB DIM: Misleading accessibility in an error message about an attempt to access inaccessible event declared in an interface</Title>
        <Description>```
        &lt;Fact&gt;
        Public Sub EventImplementation_27()

            Dim csSource =
"
public interface I1
{
    internal static event System.Action P1;
}
"
            Dim csCompiation = GetCSharpCompiation(csSource).EmitToImageReference()

            Dim source1 =
&lt;compilation&gt;
    &lt;file name="c.vb"&gt;&lt;![CDATA[
Public Class C
    Shared Sub Main()
        AddHandler I1.P1, Nothing
        RemoveHandler I1.P1, Nothing
    End Sub
End Class
]]&gt;&lt;/file&gt;
&lt;/compilation&gt;

            Dim comp1 = CreateCompilation(source1, targetFramework:=TargetFramework.NetStandardLatest, references:={csCompiation})
            comp1.AssertTheseDiagnostics(
&lt;error&gt;
BC30456: 'P1' is not a member of 'I1'.
        AddHandler I1.P1, Nothing
                   ~~~~~
BC30456: 'P1' is not a member of 'I1'.
        RemoveHandler I1.P1, Nothing
                      ~~~~~
&lt;/error&gt;)

            Dim comp2 = CreateCompilation(source1, targetFramework:=TargetFramework.NetStandardLatest, references:={csCompiation}, options:=TestOptions.DebugDll.WithMetadataImportOptions(MetadataImportOptions.All))
            comp2.AssertTheseDiagnostics(
&lt;error&gt;
BC30389: 'I1.P1' is not accessible in this context because it is 'Private'.
        AddHandler I1.P1, Nothing
                   ~~~~~
BC30389: 'I1.P1' is not accessible in this context because it is 'Private'.
        RemoveHandler I1.P1, Nothing
                      ~~~~~
&lt;/error&gt;)
        End Sub
```

Observed:
```
BC30389: 'I1.P1' is not accessible in this context because it is 'Private'.
```

Expected:
```
BC30389: 'I1.P1' is not accessible in this context because it is 'Friend'.
```</Description>
        <CreatedDate>24/05/2019</CreatedDate>
        <ClosedDate>22/08/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/DefaultInterfaceImplementationTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>35853</IssueID>
    <Title>Update FindImplementationsForInterfaceMemberAsync to correctly handle ambiguous type returns</Title>
    <Description>`FindImplementationsForInterfaceMemberAsync` checks for forwarded types using `SymbolFinder.OriginalSymbolsMatch`, which expects non-null compilation for both the project containing the interface and the project containing the symbol to compare to. Until now, most instances have found equivalence without falling through, but in cases where the type forwarding isn't completely verified a non-null compilation for the interface symbol is needed as well. See [VerifyForwardedTypes](http://source.roslyn.io/#Microsoft.CodeAnalysis.Workspaces/FindSymbols/SymbolFinder_Hierarchy.cs,4ace7ec72cd5181d) for the logic being used. 

In #35786 the type System.Text.Encoding is provided by a a NuGet reference and could be ambiguous based on the build target. The OOP service attempts to find the correct type resolution but needs the original symbol compilation to verify. 

Without this fix, FindAllReferences may cause a null deref and fail. 

Fixes #35786 </Description>
    <CreatedDate>21/05/2019</CreatedDate>
    <ClosedDate>04/06/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>35786</IssueID>
        <Title>exception on "Find all references"</Title>
        <Description>@AArnott reported this issue.

```
05/17/2019 05:55:08 : Error : Microsoft.CodeAnalysis.Remote.CodeAnalysisService (37) : Exception: System.InvalidOperationException: Unexpected Null
   at Roslyn.Utilities.Contract.ThrowIfNull[T](T value, String message)
   at Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.VerifyForwardedTypes(Dictionary`2 equivalentTypesWithDifferingAssemblies, Compilation compilation, HashSet`1 verifiedKeys, Boolean isSearchSymbolCompilation)
   at Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.VerifyForwardedTypes(Dictionary`2 equivalentTypesWithDifferingAssemblies, ISymbol searchSymbol, ISymbol symbolToMatch, Solution solution, Compilation searchSymbolCompilation, Compilation symbolToMatchCompilation, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.OriginalSymbolsMatchCore(ISymbol searchSymbol, ISymbol symbolToMatch, Solution solution, Compilation searchSymbolCompilation, Compilation symbolToMatchCompilation, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.OriginalSymbolsMatch(ISymbol searchSymbol, ISymbol symbolToMatch, Solution solution, Compilation searchSymbolCompilation, Compilation symbolToMatchCompilation, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Shared.Extensions.ITypeSymbolExtensions.&lt;&gt;c__DisplayClass16_0.&lt;FindImplementationsForInterfaceMemberAsync&gt;b__1(ISymbol m)
   at System.Linq.ImmutableArrayExtensions.FirstOrDefault[T](ImmutableArray`1 immutableArray, Func`2 predicate)
   at Microsoft.CodeAnalysis.Shared.Extensions.ITypeSymbolExtensions.&lt;FindImplementationsForInterfaceMemberAsync&gt;d__16.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.&lt;FindImplementationsAsync&gt;d__50.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractMethodOrPropertyOrEventSymbolReferenceFinder`1.&lt;DetermineCascadedSymbolsAsync&gt;d__1.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
```

here is repro step from andrew

```
git clone https://github.com/aarnott/vs-streamjsonrpc.git
cd vs-streamjsonrpc\src 
git checkout RoslynBugRepro
streamjsonrpc.sln
```

Open the JsonMessageFormatter.cs file. I personally have all methods "collapsed" except WriteJToken, and I have the caret on the bufferTextWriter field reference on the first line of that method. Then I scroll down paste it a bit when the failure occurs.
</Description>
        <CreatedDate>17/05/2019</CreatedDate>
        <ClosedDate>04/06/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>35786</IssueID>
        <Title>exception on "Find all references"</Title>
        <Description>@AArnott reported this issue.

```
05/17/2019 05:55:08 : Error : Microsoft.CodeAnalysis.Remote.CodeAnalysisService (37) : Exception: System.InvalidOperationException: Unexpected Null
   at Roslyn.Utilities.Contract.ThrowIfNull[T](T value, String message)
   at Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.VerifyForwardedTypes(Dictionary`2 equivalentTypesWithDifferingAssemblies, Compilation compilation, HashSet`1 verifiedKeys, Boolean isSearchSymbolCompilation)
   at Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.VerifyForwardedTypes(Dictionary`2 equivalentTypesWithDifferingAssemblies, ISymbol searchSymbol, ISymbol symbolToMatch, Solution solution, Compilation searchSymbolCompilation, Compilation symbolToMatchCompilation, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.OriginalSymbolsMatchCore(ISymbol searchSymbol, ISymbol symbolToMatch, Solution solution, Compilation searchSymbolCompilation, Compilation symbolToMatchCompilation, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.OriginalSymbolsMatch(ISymbol searchSymbol, ISymbol symbolToMatch, Solution solution, Compilation searchSymbolCompilation, Compilation symbolToMatchCompilation, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Shared.Extensions.ITypeSymbolExtensions.&lt;&gt;c__DisplayClass16_0.&lt;FindImplementationsForInterfaceMemberAsync&gt;b__1(ISymbol m)
   at System.Linq.ImmutableArrayExtensions.FirstOrDefault[T](ImmutableArray`1 immutableArray, Func`2 predicate)
   at Microsoft.CodeAnalysis.Shared.Extensions.ITypeSymbolExtensions.&lt;FindImplementationsForInterfaceMemberAsync&gt;d__16.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.&lt;FindImplementationsAsync&gt;d__50.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractMethodOrPropertyOrEventSymbolReferenceFinder`1.&lt;DetermineCascadedSymbolsAsync&gt;d__1.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
```

here is repro step from andrew

```
git clone https://github.com/aarnott/vs-streamjsonrpc.git
cd vs-streamjsonrpc\src 
git checkout RoslynBugRepro
streamjsonrpc.sln
```

Open the JsonMessageFormatter.cs file. I personally have all methods "collapsed" except WriteJToken, and I have the caret on the bufferTextWriter field reference on the first line of that method. Then I scroll down paste it a bit when the failure occurs.
</Description>
        <CreatedDate>17/05/2019</CreatedDate>
        <ClosedDate>04/06/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Workspaces/Core/Portable/FindSymbols/SymbolFinder_Hierarchy.cs</File>
      <File>src/Workspaces/Core/Portable/Shared/Extensions/ITypeSymbolExtensions.cs</File>
      <File>src/Workspaces/CoreTest/FindReferencesTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>35832</IssueID>
    <Title>Allow nullable variance for in/out params when converting method group to delegate</Title>
    <Description>Resolves #32563
Resolves #32564</Description>
    <CreatedDate>20/05/2019</CreatedDate>
    <ClosedDate>24/05/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>32563</IssueID>
        <Title>Roslyn should allow top level implicit nullability conversion from 'in' delegate parameters to 'in' method parameters in method group conversions</Title>
        <Description>**Version Used**: 

Microsoft Visual Studio Enterprise 2019 Preview
Version 16.0.0 Preview 1.1
VisualStudio.16.Preview/16.0.0-pre.1.1+28408.50
Microsoft .NET Framework
Version 4.7.03056

**Steps to Reproduce**:

Compile the following code snippets
```cs
#nullable enable
delegate void MyDelegate(in string s);
class C
{
  void Test()
  {
    MyDelegate md = Method; // Warning CS8622
  }

  extern void Method(in string? s);
}
```

https://sharplab.io/#v2:EYLgtghgzgLgpgJwDQBMQGoA+BiAdgVwBtCJhC4ACOXU8gWACgU5yBzCeCgAQBYKBZAJ4ARFnHbwAFAEtc3AIwAGClACUAbkZcATBQDCjAN6MK3PgBU4sSapMVjDU6aGi2HSmBQUAvALgwACwB7FHUKAHpwigB1CARcWVZ9AGUADgA2bW07AF9GOzgAD3h4sz9AkJk5LiUAfhUNRhygA

**Expected Behavior**:
No warnings. An `in` parameter cannot be assigned within the method. Passing non-nullable values from delegate arguments into the method parameter which allows nulls is also safe.

**Actual Behavior**:
`warning CS8622: Nullability of reference types in type of parameter 's' of 'void C.Method(out string s)' doesn't match the target delegate 'MyDelegate'.`</Description>
        <CreatedDate>17/01/2019</CreatedDate>
        <ClosedDate>24/05/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>32564</IssueID>
        <Title>Roslyn should allow top level implicit nullability conversion from 'out' method parameters to delegate 'out' parameters  in method group conversions</Title>
        <Description>Similar to https://github.com/dotnet/roslyn/issues/32563

**Version Used**: 
Microsoft Visual Studio Enterprise 2019 Preview
Version 16.0.0 Preview 1.1
VisualStudio.16.Preview/16.0.0-pre.1.1+28408.50
Microsoft .NET Framework
Version 4.7.03056

**Steps to Reproduce**:

```cs
#nullable enable
delegate void MyDelegate(out string? s);
class C
{
  void Test()
  {
    MyDelegate md = Method; // Warning CS8622
  }

  extern void Method(out string s);
}
```

https://sharplab.io/#v2:EYLgtghgzgLgpgJwDQBMQGoA+BiAdgVwBtCJhC4ACOXU8gWACgU5yBzCeCgAQBYKBZAJ4ARFnHbwAFAHt8MbgEYADAH4KUAJQBuRlwBMFAMKMA3owrc+AFTixJG8xTMMLFoaLYdKYFBQC8AnAwABbSKFoUAPSRFADqEAi4AJa4rEYAygAcAGx6eo4AvoyOcAAe8ImWgSFhMnKKSurajAVAA=

**Expected Behavior**:
No warnings. `Method` is only allowed to assign non-nullable values to the delegate parameter which is safe. `Method` cannot receive any null values from the delegates arguments since `out` parameters cannot be read until reassigned.

**Actual Behavior**:
`warning CS8622: Nullability of reference types in type of parameter 's' of 'void C.Method(out string s)' doesn't match the target delegate 'MyDelegate'.`
</Description>
        <CreatedDate>17/01/2019</CreatedDate>
        <ClosedDate>24/05/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/NullableWalker.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/NullableReferenceTypesTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>35822</IssueID>
    <Title>Dont suggest this in static local functions</Title>
    <Description>See #35644, #27719

### The Problem

Currently `Symbol.IsStatic` is not very well defined. The compiler assumes it means any/all of the following:

1. A type is marked static,
2. A member is marked static,
3. A member does not require an instance receiver (with the exception of a non-static constructor - I will need to investigate more there)
4. A member cannot capture `this`
5. For some reason a namespace is considered static, but an assembly is not 🤷

In general this has worked till now because these definitions have mostly coincided, and when they haven't it has usually been in an understandable way (eg. constants are static even though they are not marked static).

Unfortunately Local Functions break that:

Static local functions are marked static, cannot capture this, and do not require an instance receiver.

Non-Static local functions are not marked static, can capture this, but do not require an instance receiver.

Currently all local functions are marked static, in order to make the compiler work with the fact that they do not require an instance receiver. This causes two problems:

1. It is non-intuitive that a non-static local functions IsStatic returns true. Since this is a public API, that's a problem.

2. We need an API to tell us if a local function is static or not. Indeed the ultimate purpose of this PR is to prevent `this` being suggested in local functions, which depends on such an API.

### Solutions

We need to decide what IsStatic means:

#### Option 1.

Make non-static local functions IsStatic return false. Replace all usages of IsStatic where we are checking to see if a member Requires an instance receiver with a new property, RequiresInstanceReciever. This property can be internal, since it is only really of interest to the compiler.

**advantages**
IsStatic now matches our intuition much better.
We've now increased the explicitness of the compiler. Rather than mashing up lots of different concepts into one, we've begun seperating them out into different concepts.

**disadvantages**
This is risky. RequiresInstanceReciever now behaves exactly like IsStatic used to, but IsStatic behaves slightly differently. If we forget to replace all relevant usages of IsStatic with RequiresInstanceReciever, we may introduce subtle bugs that only occur with non-static local functions.

#### Option 2.

We currently have a temporary internal API `IsStaticLocalfunction`. Make this public and move it to IMethodSymbol. Document what IsStatic means.

**advantages**
Very low risk. Simple to do.

**disadvantages**
IsStatic now doesn't match our intuitions.
Rather than solving the problem, we've worked around it. We've just increased the technical debt of the codebase, rather than decreasing it.


### Approach taken here

The ideal solution is obviously the first, which is what I've done, so that the risk can be properly evaluated. I've created a pr for the second solution at #35825 so they can be compared.

Changing a call from `IsStatic` to `RequiresInstanceReciever` is always safe, since the latter behaves like the former used to.

Leaving a call as a call to `IsStatic` is dangerous, as `IsStatic` now has different behaviour.

For fields/events/properties `IsStatic` and `RequiresInstanceReciever` are synonyms.

I've gone through every usage of `IsStatic` in the compiler code (not tests/workspaces/IDE) and if it appears to be about receivers, and is not explicitly talking about a field property or event, I have replaced it with a call to `RequiresInstanceReciever`.

This requires changing 27 files.

Depending on the opinion of the roslyn team, I am happy to either take the alternative solution, do more work here, or drop this altogether.
</Description>
    <CreatedDate>20/05/2019</CreatedDate>
    <ClosedDate>26/06/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>35644</IssueID>
        <Title>`this` keyword should not be recommended within a static local function</Title>
        <Description>![image](https://user-images.githubusercontent.com/12466233/57559770-5a307a00-7338-11e9-88a4-91745f45ce1a.png)
</Description>
        <CreatedDate>10/05/2019</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>27719</IssueID>
        <Title>LocalFunctionSymbol.IsStatic always returns true</Title>
        <Description>Current constructor always sets an implicit declaration modifier:
```C#
        public LocalFunctionSymbol(
            Binder binder,
            Symbol containingSymbol,
            LocalFunctionStatementSyntax syntax)
        {
            _declarationModifiers =
                DeclarationModifiers.Private |
                DeclarationModifiers.Static |
                syntax.Modifiers.ToDeclarationModifiers(diagnostics: _declarationDiagnostics);
```

`IsStatic` checks the declaration modifiers:
```C#
        public override bool IsStatic =&gt; (_declarationModifiers &amp; DeclarationModifiers.Static) != 0;
```

From discussion with @agocke and @AlekseyTs, `IsStatic` should always return `false`. Some overload resolution logic may need to be adjusted (to have special handling for local functions).

To save some typing, here's a test I had. 
```C#
        [Fact]
        [WorkItem(27028, "https://github.com/dotnet/roslyn/issues/27028")]
        public void LocalFunction_IsStatic()
        {
            const string text = @"
class C
{
    void M()
    {
        void local1() { }
        void outer() { void local2() { } }
    }
    static void M2()
    {
        void local3() { }
        void outer() { void local4() { }
    }
}";
            var comp = CreateCompilation(text);
            var tree = comp.SyntaxTrees.Single();
            var model = comp.GetSemanticModel(tree);

            var local1 = tree.GetRoot().DescendantNodes().OfType&lt;LocalFunctionStatementSyntax&gt;().ElementAt(0);
            Assert.Equal("void local1() { }", local1.ToString());
            var local1Symbol = (IMethodSymbol)model.GetDeclaredSymbol(local1);
            verify(local1Symbol);

            var local2 = tree.GetRoot().DescendantNodes().OfType&lt;LocalFunctionStatementSyntax&gt;().ElementAt(2);
            Assert.Equal("void local2() { }", local2.ToString());
            var local2Symbol = (IMethodSymbol)model.GetDeclaredSymbol(local2);
            verify(local2Symbol);

            var m2 = tree.GetRoot().DescendantNodes().OfType&lt;MethodDeclarationSyntax&gt;().ElementAt(1);
            Assert.Equal("M2", m2.Identifier.ToString());
            var m2Symbol = model.GetDeclaredSymbol(m2);
            Assert.True(m2Symbol.IsStatic);

            var local3 = tree.GetRoot().DescendantNodes().OfType&lt;LocalFunctionStatementSyntax&gt;().ElementAt(3);
            Assert.Equal("void local3() { }", local3.ToString());
            var local3Symbol = (IMethodSymbol)model.GetDeclaredSymbol(local3);
            verify(local3Symbol);

            var local4 = tree.GetRoot().DescendantNodes().OfType&lt;LocalFunctionStatementSyntax&gt;().ElementAt(5);
            Assert.Equal("void local4() { }", local4.ToString());
            var local4Symbol = (IMethodSymbol)model.GetDeclaredSymbol(local4);
            verify(local4Symbol);

            void verify(IMethodSymbol localSymbol)
            {
                Assert.False(localSymbol.IsAbstract);
                Assert.False(localSymbol.IsAsync);
                Assert.True(localSymbol.IsDefinition);
                Assert.False(localSymbol.IsExtensionMethod);
                Assert.False(localSymbol.IsExtern);
                Assert.False(localSymbol.IsGenericMethod);
                Assert.False(localSymbol.IsImplicitlyDeclared);
                Assert.False(localSymbol.IsOverride);
                Assert.False(localSymbol.IsSealed);
                Assert.False(localSymbol.IsStatic);
                Assert.False(localSymbol.IsVirtual);
            }
        }
```

Relates to https://github.com/dotnet/roslyn/issues/27028

Note: in the implementation of static local functions, an internal property `IsStaticLocalFunction` was added. It should be removed when this issue is fixed.</Description>
        <CreatedDate>11/06/2018</CreatedDate>
        <ClosedDate>08/07/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>35825</IssueID>
        <Title>don't suggest this in a static local function alternative</Title>
        <Description>This is the alternative option suggested in #35822, shown here for comparison.</Description>
        <CreatedDate>20/05/2019</CreatedDate>
        <ClosedDate>26/06/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder.ValueChecks.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Conversions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Expressions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Invocation.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/AccessCheck.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/Conversions/Conversions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/OverloadResolution/OverloadResolution.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/OverloadResolution/OverloadResolutionResult.cs</File>
      <File>src/Compilers/CSharp/Portable/CodeGen/EmitExpression.cs</File>
      <File>src/Compilers/CSharp/Portable/CodeGen/Optimizer.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/AbstractFlowPass.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/LocalDataFlowPass.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/NullableWalker.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/NullableWalker_Patterns.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/DiagnosticsPass_ExpressionTrees.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/ExpressionLambdaRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_Call.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_Conversion.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_DelegateCreationExpression.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LoweredDynamicOperationFactory.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/SpillSequenceSpiller.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/EventSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/FieldSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/MethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/PropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/LocalFunctionSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/SymbolExtensions.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Wrapped/WrappedMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/LocalFunctionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/Source/EventTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/Source/FieldTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/Source/MethodTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/Source/PropertyTests.cs</File>
      <File>src/EditorFeatures/CSharpTest2/Recommendations/ThisKeywordRecommenderTests.cs</File>
      <File>src/Workspaces/CSharp/Portable/Extensions/ContextQuery/SyntaxTreeExtensions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>35810</IssueID>
    <Title>🧹 Remove IInProcessAnalyzer</Title>
    <Description>* Remove unnecessary uses of IInProcessAnalyzer
* ~~Ban the ongoing use of IInProcessAnalyzer~~

    RenameTrackingDiagnosticAnalyzer is the only remaining in-process analyzer, which is tracked by #35808. Use of IInProcessAnalyzer in new locations is not allowed.

* After changing `RenameTrackingDiagnosticAnalyzer` to extend `DocumentDiagnosticAnalyzer`, the `IInProcessAnalyzer` interface is removed entirely

    Closes #35808</Description>
    <CreatedDate>20/05/2019</CreatedDate>
    <ClosedDate>11/06/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>35808</IssueID>
        <Title>Update RenameTrackingDiagnosticAnalyzer to run out-of-process</Title>
        <Description>Currently `RenameTrackingDiagnosticAnalyzer` depends on data stored on `ITextBuffer` instances which is not not available out-of-process. This analyzer will cease to work in its current form when the analyzer infrastructure is moved out-of-process. The analyzer should be updated to remove the in-process dependency, or the analyzer for this feature should be replaced with an alternative implementation that does not rely on analyzers.</Description>
        <CreatedDate>20/05/2019</CreatedDate>
        <ClosedDate>11/06/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>35808</IssueID>
        <Title>Update RenameTrackingDiagnosticAnalyzer to run out-of-process</Title>
        <Description>Currently `RenameTrackingDiagnosticAnalyzer` depends on data stored on `ITextBuffer` instances which is not not available out-of-process. This analyzer will cease to work in its current form when the analyzer infrastructure is moved out-of-process. The analyzer should be updated to remove the in-process dependency, or the analyzer for this feature should be replaced with an alternative implementation that does not rely on analyzers.</Description>
        <CreatedDate>20/05/2019</CreatedDate>
        <ClosedDate>11/06/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/Core/Implementation/RenameTracking/RenameTrackingDiagnosticAnalyzer.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/AnalyzerHelper.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/Analyzers/NamingStyleDiagnosticAnalyzerBase.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/EngineV2/DiagnosticIncrementalAnalyzer.InProcOrRemoteHostAnalyzerRunner.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/IInProcessAnalyzer.cs</File>
      <File>src/Features/Core/Portable/RemoveUnnecessaryImports/AbstractRemoveUnnecessaryImportsDiagnosticAnalyzer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>34916</IssueID>
    <Title>Remove the temporary mechanism for "external" nullable annotations.</Title>
    <Description>Relates to #29821
Fixes #34409
</Description>
    <CreatedDate>10/04/2019</CreatedDate>
    <ClosedDate>15/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>29821</IssueID>
        <Title>Need mechanism for injecting annotations</Title>
        <Description>This is a follow-up workitem to replace a number of PROTOTYPE markers.

Design issues:
- Right now extra annotations always win (even if we're loading a modern assembly). Is this what we want?

FYI @AlekseyTs </Description>
        <CreatedDate>13/09/2018</CreatedDate>
        <ClosedDate>04/05/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>34409</IssueID>
        <Title>Remove hard-coded nullable annotations in compiler before C# 8.0 RTM</Title>
        <Description>
        </Description>
        <CreatedDate>25/03/2019</CreatedDate>
        <ClosedDate>15/07/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/BoundTree/NullabilityRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ExtraAnnotations.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/NullableTypeDecoder.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PEMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PEParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PEPropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PETypeParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceComplexParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceSimpleParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/NullableReferenceTypesTests.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/Solution/SolutionState.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>34889</IssueID>
    <Title>Use of unannotated unconstrained type parameter in nullable diabled code</Title>
    <Description>A reference to an unconstrained type parameter in nullable-disabled code should be treated as *oblivious*, and therefore reading them should be considered to produce non-null values, and we are permitted to assign null values to them without a diagnostic.
Fixes #34842

Also disable the old WRN_DotOnDefault when the nullable feature is enabled.
Fixes #34855</Description>
    <CreatedDate>09/04/2019</CreatedDate>
    <ClosedDate>26/04/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>34842</IssueID>
        <Title>Use of unannotated unconstrained type parameter in nullable diabled code</Title>
        <Description>The issue is the treatment of a reference to a (unconstrainted) type parameter that was both declared and referenced in a disabled context (without an annotation).  Such a reference should designate an oblivious type and should be treated accordingly.  That does not appear to be the treatment today.  That is the issue in `M1` below.  There should be no problem with the default expression because it is being converted to an oblivious type.

See also https://github.com/dotnet/roslyn/issues/30214

``` c#
#nullable disable
class A&lt;T1, T2, T3&gt; where T2 : class where T3 : object
{
    T1 F1;
    T2 F2;
    T3 F3;
    B F4;

#nullable enable
    void M1()
    {
        F1 = default; // unexpected warning
        F2 = default; // unexpected warning
        F3 = default; // unexpected warning
        F4 = default;
    }
}

class B {}
```
</Description>
        <CreatedDate>08/04/2019</CreatedDate>
        <ClosedDate>26/04/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>34855</IssueID>
        <Title>Retire ErrorCode.WRN_DotOnDefault.</Title>
        <Description>This existing warning is redundant with warnings produced in the nullable pass, and doesn't respect null suppression.  Remove it in favor of the new warnings.</Description>
        <CreatedDate>09/04/2019</CreatedDate>
        <ClosedDate>26/04/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Conversions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Expressions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Operators.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/Constructors.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/AbstractFlowPass_Switch.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/NullableWalker.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/NullableWalker_Patterns.cs</File>
      <File>src/Compilers/CSharp/Portable/Generated/BoundNodes.xml.Generated.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_BinaryOperator.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_Conversion.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_Index.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_ObjectCreationExpression.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_Range.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_UnaryOperator.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Emit/EndToEndTests.cs</File>
      <File>src/Compilers/CSharp/Test/IOperation/IOperation/IOperationTests_IVariableDeclaration.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/NullableReferenceTypesTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/SemanticAnalyzerTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/SemanticErrorTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>34797</IssueID>
    <Title>Treat unconstrained type parameters declared in `#nullable disable` context as having an unknown nullability in case they are substituted with a reference type.</Title>
    <Description>As apposed to possibly nullable or not nullable reference type.
Fixes #29980.
Fixes #34844.</Description>
    <CreatedDate>05/04/2019</CreatedDate>
    <ClosedDate>16/04/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>29980</IssueID>
        <Title>Type parameters declared in disabled context should have oblivious nullability</Title>
        <Description>```
        [Fact]
        public void Constraints_65()
        {
            var source =
@"
#nullable disable 
interface I1
{
    void F1&lt;TF1&gt;();
}

#nullabe enable 
class A : I1
{
    public void F1&lt;TF1A&gt;() where TF1A : object
    {}
}
";
            var comp = CreateCompilation(new[] { source, NonNullTypesTrue, NonNullTypesAttributesDefinition });
            // PROTOTYPE(NullableReferenceTypes): unexpected warning
            comp.VerifyDiagnostics(
                // (21,17): warning CS8633: Nullability in constraints for type parameter 'TF1A' of method 'A.F1&lt;TF1A&gt;()' doesn't match the constraints for type parameter 'TF1' of interface method 'I1.F1&lt;TF1&gt;()'. Consider using an explicit interface implementation instead.
                //     public void F1&lt;TF1A&gt;() where TF1A : object
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F1").WithArguments("TF1A", "A.F1&lt;TF1A&gt;()", "TF1", "I1.F1&lt;TF1&gt;()").WithLocation(21, 17)
                );
        }
```</Description>
        <CreatedDate>17/09/2018</CreatedDate>
        <ClosedDate>16/04/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>34844</IssueID>
        <Title>Unexpected different between inferred type argument nullability and explicit</Title>
        <Description>The issue regards type inference in `M3` versus `M4` below.  Both should have the same annotation for the type argument, either unannotated, or oblivious.  Which it is may depend on the outcome of #34843, but in any case they should be the same.  And yet we report diagnostics for the type arguments in `M3` but not in `M4`.  It is possible that the problem is that we do not check the inferred type argument against the constraints in `M4`.  Either way, they should be treated the same and either there should be warnings on both or neither.

See also https://github.com/dotnet/roslyn/issues/30214

``` c#
#nullable disable
class A&lt;T1, T2, T3&gt; where T2 : class where T3 : object
{
    T1 F1;
    T2 F2;
    T3 F3;
    B F4;

#nullable enable
    void M3()
    {
        C.Test&lt;T1&gt;(); // warning given here
        C.Test&lt;T2&gt;(); // warning given here
        C.Test&lt;T3&gt;(); // warning given here
    }

    void M4()
    {
        D.Test(F1); // no warning given here
        D.Test(F2); // no warning given here
        D.Test(F3); // no warning given here
        D.Test(F4);
    }
}

class B {}

class C
{
    public static void Test&lt;T&gt;() where T : object
    {}
}

class D
{
    public static void Test&lt;T&gt;(T x) where T : object
    {}
}
```
</Description>
        <CreatedDate>08/04/2019</CreatedDate>
        <ClosedDate>16/04/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Constraints.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/AnonymousTypes/SynthesizedSymbols/AnonymousType.TypeParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ConstraintsHelper.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ErrorTypeSymbol.ErrorTypeParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/MemberSignatureComparer.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PETypeParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Retargeting/RetargetingTypeParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/CrefTypeParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/IndexedTypeParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/LocalFunctionSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceNamedTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceOrdinaryMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceTypeParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/TypeParameterConstraintClause.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/SubstitutedTypeParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/TypeParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/TypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/TypeSymbolExtensions.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Attributes/AttributeTests_Nullable.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/NullableReferenceTypesTests.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Source/ExpressionCompiler/Symbols/EETypeParameterSymbol.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Source/ExpressionCompiler/Symbols/SimpleTypeParameterSymbol.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>34793</IssueID>
    <Title>🔼 Compute indices when OOP is disabled</Title>
    <Description>Fixes #34631

### Customer scenario

Solution crawler indexing is disabled in host environments that do not support OOP (e.g. Visual Studio for Mac), or where OOP has been manually disabled (e.g. some customer scenarios for Visual Studio).

### Bugs this fixes

#34631

### Workarounds, if any

None.

### Risk

Low. This does not change behavior for primary host environments where OOP is used.

### Performance impact

No significant impact.

### Is this a regression from a previous update?

Yes.

### Root cause analysis

#31644 (specifically commit 6f5be2ef2849b22dc185081ed9e389f02b80e473) assumed that OOP is supported by the host. This is not always the case, and Visual Studio for Mac scenarios failed as a result.

### How was the bug found?

Reported by developers on Visual Studio for Mac.

### Test documentation updated?

No.
</Description>
    <CreatedDate>05/04/2019</CreatedDate>
    <ClosedDate>02/05/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>34631</IssueID>
        <Title>SymbolTreeInfoIncrementalAnalyzerProvider does not run anymore for VSMac</Title>
        <Description>**Version Used**: 
master

**Steps to Reproduce**:

1. Open a solution
2. Expect SymbolTreeInfoIncrementalAnalyzerProvider.IncrementalAnalyzer to run
3. It does not

**Expected Behavior**:
It should run and cache symbol tree infos in the database.

**Actual Behavior**:
It does not, thus making symboltreeinfo operations slower in the IDE.

Regression as of https://github.com/dotnet/roslyn/commit/6f5be2ef2849b22dc185081ed9e389f02b80e473#r32981653</Description>
        <CreatedDate>01/04/2019</CreatedDate>
        <ClosedDate>06/05/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>34631</IssueID>
        <Title>SymbolTreeInfoIncrementalAnalyzerProvider does not run anymore for VSMac</Title>
        <Description>**Version Used**: 
master

**Steps to Reproduce**:

1. Open a solution
2. Expect SymbolTreeInfoIncrementalAnalyzerProvider.IncrementalAnalyzer to run
3. It does not

**Expected Behavior**:
It should run and cache symbol tree infos in the database.

**Actual Behavior**:
It does not, thus making symboltreeinfo operations slower in the IDE.

Regression as of https://github.com/dotnet/roslyn/commit/6f5be2ef2849b22dc185081ed9e389f02b80e473#r32981653</Description>
        <CreatedDate>01/04/2019</CreatedDate>
        <ClosedDate>06/05/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>31644</IssueID>
        <Title>Remove OOP related feature options.</Title>
        <Description>This code to make it possible to run features OOP was added around 18 months ago.  Since then there has been no issue with it.  It has also been A/B tested with no stability issues arising, and positive numbers for all latency-oriented scenarios.

This PR simply removes the options for controlling this and makes it so that OOP is on all the time.

Fixes https://github.com/dotnet/roslyn/issues/26076</Description>
        <CreatedDate>09/12/2018</CreatedDate>
        <ClosedDate>01/03/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/VisualStudio/Core/Def/Implementation/Remote/RemoteHostClientServiceFactory.RemoteHostClientService.cs</File>
      <File>src/Workspaces/Core/Portable/Remote/DefaultRemoteHostClientServiceFactory.RemoteHostClientService.cs</File>
      <File>src/Workspaces/Core/Portable/Remote/IRemoteHostClientService.cs</File>
      <File>src/Workspaces/Core/Portable/Remote/RemoteFeatureOptions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>34791</IssueID>
    <Title>Avoid optimizing goto in SyntheticBoundNodeFactory.Switch()</Title>
    <Description>`SyntheticBoundNodeFactory.Switch()` is used to generate synthesized switch statements for async rewriters, and the `goto` maybe a branch outside of the current `try` block, so merging a `Beq` + `Br` might result in a conditional branch outside of the block which is not supported in the code generator.

Fixes #33542 
Fixes #34720</Description>
    <CreatedDate>05/04/2019</CreatedDate>
    <ClosedDate>08/04/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>33542</IssueID>
        <Title>One of our projects fails to build with: "csc.exe" exited with code -2146232797</Title>
        <Description>I don't have any idea why this would happen, this used to build on everything except Visual Studio 2019 Preview 2, preview 1.1 worked.

_This issue has been moved from https://developercommunity.visualstudio.com/content/problem/434543/one-of-our-projects-fails-to-build-with-cscexe-exi.html
VSTS ticketId: 776735_
_These are the original issue comments:_

tstedel on 1/31/2019, 05:49 PM (19 days ago): &lt;p&gt;Still does this in preview 2.1. It hangs for a very long time and then doesn't build.&lt;/p&gt;&lt;p&gt;1&amp;gt;------ Build started: Project: POS_Connector.Core, Configuration: Debug Any CPU ------&lt;br&gt;1&amp;gt;C:\Program Files (x86)\Microsoft Visual Studio\2019\Preview\MSBuild\15.0\Bin\Roslyn\Microsoft.CSharp.Core.targets(52,5): error MSB6006: "csc.exe" exited with code -2146232797.&lt;br&gt;========== Build: 0 succeeded, 1 failed, 3 up-to-date, 0 skipped ==========&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;/strong&gt;&lt;u&gt;&lt;/u&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sup&gt;&lt;/sup&gt;&lt;/p&gt;

tstedel on 1/31/2019, 06:41 PM (19 days ago): &lt;pre&gt;using System.Threading.Tasks;
namespace ConsoleApp6
\{
    class Program
    \{
        static async Task Main(string[] args)
        \{
            try
            \{
                try
                \{
                    return;
                }
                finally
                \{
                    await Task.CompletedTask;
                }
            }
            catch \{ }
            finally
            \{
                await Task.CompletedTask;
            }
        }
    }
}&lt;/pre&gt;

tstedel on 1/31/2019, 06:42 PM (19 days ago): &lt;p&gt;What I just posted is the minimum necessary to reproduce this issue&lt;/p&gt;

_These are the original issue solutions:_
(no solutions)</Description>
        <CreatedDate>21/02/2019</CreatedDate>
        <ClosedDate>08/04/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>34720</IssueID>
        <Title>Roslyn compiler fails on compiling for&gt;using&gt;try&gt;finally&gt;await</Title>
        <Description>**Version Used**: 
Windows 10.0.17763 Pro
Visual Studio 2017 Pro
Docker version 18.09.2, build 6247962

**Steps to Reproduce**:

1. Create NET.Core console app project with following code 

```
using System.IO;
using System.Threading.Tasks;

namespace ConsoleApp
{
    class Program
    {
        static void Main(string[] args)
        {
            
        }
    }

    public class CompilerFail
    {
        private async Task AsyncMethod()
        {
            for (var i = 0; i &lt; 5; i++)
            {
                using (var wc = new MemoryStream())
                {
                    try
                    {
                        continue;
                    }
                    finally
                    {
                        await Task.Delay(1);
                    }
                }
            }
        }
    }
}
```
2. Create build docker file:
```
FROM mcr.microsoft.com/dotnet/core/sdk:2.2 AS build-env
WORKDIR /app

COPY ConsoleApp/ConsoleApp.csproj ./ConsoleApp/

RUN dotnet restore ConsoleApp/ConsoleApp.csproj

COPY ConsoleApp ./ConsoleApp 

RUN dotnet publish -c Release -o /app/out ./ConsoleApp/ConsoleApp.csproj
```
3. Run build in docker 
```
docker build .
```

**Expected Behavior**:
Project is built

**Actual Behavior**:
```
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error : FailFast: [/app/ConsoleApp/ConsoleApp.csproj]
p/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error :    at Microsoft.CodeAnalysis.CodeGen.ILOpCodeExtensions.GetLeaveOpcode(ILOpCode opcode) [/app/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error :    at Microsoft.CodeAnalysis.CodeGen.ILBuilder.BasicBlock.RewriteBranchesAcrossExceptionHandlers() [/app/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error :    at Microsoft.CodeAnalysis.CodeGen.ILBuilder.RewriteBranchesAcrossExceptionHandlers() [/app/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error :    at Microsoft.CodeAnalysis.CodeGen.ILBuilder.RealizeBlocks() [/app/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error :    at Microsoft.CodeAnalysis.CodeGen.ILBuilder.Realize() [/app/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error :    at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.GenerateImpl() [/app/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error :    at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.Generate(Int32&amp; asyncCatchHandlerOffset, ImmutableArray`1&amp; asyncYieldPoints, ImmutableArray`1&amp; asyncResumePoints) [/app/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error :    at Microsoft.CodeAnalysis.CSharp.MethodCompiler.GenerateMethodBody(PEModuleBuilder moduleBuilder, MethodSymbol method, Int32 methodOrdinal, BoundStatement block, ImmutableArray`1 lambdaDebugInfo, ImmutableArray`1 closureDebugInfo, StateMachineTypeSymbol stateMachineTypeOpt, VariableSlotAllocator variableSlotAllocatorOpt, DiagnosticBag diagnostics, DebugDocumentProvider debugDocumentProvider, ImportChain importChainOpt, Boolean emittingPdb, Boolean emitTestCoverageData, ImmutableArray`1 dynamicAnalysisSpans) [/app/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error :    at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileSynthesizedMethods(TypeCompilationState compilationState) [/app/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error :    at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(NamedTypeSymbol containingType) [/app/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error :    at Microsoft.CodeAnalysis.CSharp.MethodCompiler.&lt;&gt;c__DisplayClass21_0.&lt;CompileNamedTypeAsTask&gt;b__0() [/app/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error :  [/app/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error :    at System.Environment.FailFast(System.String, System.Exception) [/app/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error :    at System.Environment.FailFast(System.String, System.Exception) [/app/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error :    at Microsoft.CodeAnalysis.FailFast.OnFatalException(System.Exception) [/app/ConsoleApp/ConsoleApp.csproj/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error :    at Microsoft.CodeAnalysis.FatalError.Report(System.Exception, System.Action`1&lt;System.Exception&gt;) [/app/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error :    at Microsoft.CodeAnalysis.FatalError.ReportUnlessCanceled(System.Exception) [/app/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error :    at Microsoft.CodeAnalysis.CSharp.MethodCompiler+&lt;&gt;c__DisplayClass21_0.&lt;CompileNamedTypeAsTask&gt;b__0() [/app/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error :    at Microsoft.CodeAnalysis.CodeGen.ILOpCodeExtensions.GetLeaveOpcode(System.Reflection.Metadata.ILOpCode) [/app/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error :    at Microsoft.CodeAnalysis.CodeGen.ILBuilder+BasicBlock.RewriteBranchesAcrossExceptionHandlers() [/app/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error :    at Microsoft.CodeAnalysis.CodeGen.ILBuilder.RewriteBranchesAcrossExceptionHandlers() [/app/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error :    at Microsoft.CodeAnalysis.CodeGen.ILBuilder.RealizeBlocks() [/app/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error :    at Microsoft.CodeAnalysis.CodeGen.ILBuilder.Realize() [/app/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error :    at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.GenerateImpl() [/app/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error :    at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.Generate(Int32 ByRef, System.Collections.Immutable.ImmutableArray`1&lt;Int32&gt; ByRef, System.Collections.Immutable.ImmutableArray`1&lt;Int32&gt; ByRef) [/app/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error :    at Microsoft.CodeAnalysis.CSharp.MethodCompiler.GenerateMethodBody(Microsoft.CodeAnalysis.CSharp.Emit.PEModuleBuilder, Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol, Int32, Microsoft.CodeAnalysis.CSharp.BoundStatement, System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.CodeGen.LambdaDebugInfo&gt;, System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.CodeGen.ClosureDebugInfo&gt;, Microsoft.CodeAnalysis.CSharp.StateMachineTypeSymbol, Microsoft.CodeAnalysis.CodeGen.VariableSlotAllocator, Microsoft.CodeAnalysis.DiagnosticBag, Microsoft.CodeAnalysis.CodeGen.DebugDocumentProvider, Microsoft.CodeAnalysis.CSharp.ImportChain, Boolean, Boolean, System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.CodeGen.SourceSpan&gt;) [/app/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error :    at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileSynthesizedMethods(Microsoft.CodeAnalysis.CSharp.TypeCompilationState) [/app/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error :    at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol) [/app/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error :    at Microsoft.CodeAnalysis.CSharp.MethodCompiler+&lt;&gt;c__DisplayClass21_0.&lt;CompileNamedTypeAsTask&gt;b__0() [/app/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error :    at Roslyn.Utilities.UICultureUtilities+&lt;&gt;c__DisplayClass5_0.&lt;WithCurrentUICulture&gt;b__0() [/app/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error :    at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object) [/app/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error :    at System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef) [/app/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error :    at System.Threading.ThreadPoolWorkQueue.Dispatch() [/app/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error :  [/app/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error : Exception details: [/app/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error : System.InvalidOperationException: Unexpected value 'Beq' of type 'System.Reflection.Metadata.ILOpCode' [/app/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error :    at Microsoft.CodeAnalysis.CodeGen.ILOpCodeExtensions.GetLeaveOpcode(ILOpCode opcode) [/app/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error :    at Microsoft.CodeAnalysis.CodeGen.ILBuilder.BasicBlock.RewriteBranchesAcrossExceptionHandlers() [/app/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error :    at Microsoft.CodeAnalysis.CodeGen.ILBuilder.RewriteBranchesAcrossExceptionHandlers() [/app/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error :    at Microsoft.CodeAnalysis.CodeGen.ILBuilder.RealizeBlocks() [/app/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error :    at Microsoft.CodeAnalysis.CodeGen.ILBuilder.Realize() [/app/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error :    at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.GenerateImpl() [/app/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error :    at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.Generate(Int32&amp; asyncCatchHandlerOffset, ImmutableArray`1&amp; asyncYieldPoints, ImmutableArray`1&amp; asyncResumePoints) [/app/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error :    at Microsoft.CodeAnalysis.CSharp.MethodCompiler.GenerateMethodBody(PEModuleBuilder moduleBuilder, MethodSymbol method, Int32 methodOrdinal, BoundStatement block, ImmutableArray`1 lambdaDebugInfo, ImmutableArray`1 closureDebugInfo, StateMachineTypeSymbol stateMachineTypeOpt, VariableSlotAllocator variableSlotAllocatorOpt, DiagnosticBag diagnostics, DebugDocumentProvider debugDocumentProvider, ImportChain importChainOpt, Boolean emittingPdb, Boolean emitTestCoverageData, ImmutableArray`1 dynamicAnalysisSpans) [/app/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error :    at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileSynthesizedMethods(TypeCompilationState compilationState) [/app/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error :    at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(NamedTypeSymbol containingType) [/app/ConsoleApp/ConsoleApp.csproj]
/usr/share/dotnet/sdk/2.2.202/Roslyn/Microsoft.CSharp.Core.targets(58,5): error :    at Microsoft.CodeAnalysis.CSharp.MethodCompiler.&lt;&gt;c__DisplayClass21_0.&lt;CompileNamedTypeAsTask&gt;b__0() [/app/ConsoleApp/ConsoleApp.csproj]
The command '/bin/sh -c dotnet publish -c Release -o /app/out ./ConsoleApp/ConsoleApp.csproj' returned a non-zero code: 1
```
</Description>
        <CreatedDate>03/04/2019</CreatedDate>
        <ClosedDate>08/04/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Lowering/SyntheticBoundNodeFactory.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenAsyncEHTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenAsyncIteratorTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenAsyncLocalsTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenAsyncMainTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenAsyncSpillTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenAsyncTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenAwaitForeachTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenAwaitUsingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Emit/EditAndContinue/EditAndContinueStateMachineTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Emit/EditAndContinue/LocalSlotMappingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/PDB/PDBAsyncTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/PDB/PDBConstantTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/PDB/PDBIteratorTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/PDB/PDBTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>34718</IssueID>
    <Title>Allow overriding members with nullable variance</Title>
    <Description>Implements a design change where overrides are allowed to change the
type of the member as long as there is an implicit nullable reference
conversion from the overriding type to the overridden type according to
the nullable variance rules.

Fixes #23268
Fixes #30958</Description>
    <CreatedDate>03/04/2019</CreatedDate>
    <ClosedDate>04/05/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>23268</IssueID>
        <Title>Covariant return types with respect to nullable reference types</Title>
        <Description>**Version Used**: Preview 11152017

**Steps to Reproduce**:

```csharp
abstract class A {
  public abstract object? GetData();
}

class B : A {
  public override object GetData() =&gt; new object();
}
```

**Expected Behavior**:

No warning is reported.

**Actual Behavior**:

CS8609 is reported for `B.GetData()`.

----
Update (jcouv, 3/29/2019): as part of this, if I do `b.GetData().ToString()`, there should be no warning. Confirmed with Mads.</Description>
        <CreatedDate>18/11/2017</CreatedDate>
        <ClosedDate>04/05/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>30958</IssueID>
        <Title>Contravariant parameter types with respect to nullable reference types</Title>
        <Description>**Version Used**: c9c6309

**Steps to Reproduce**:

```csharp
abstract class A {
  public abstract void SetData(object value);
}

class B : A {
  public override void SetData(object? value) =&gt; throw null;
}
```

**Expected Behavior**:

No warning is reported.

**Actual Behavior**:

CS8610 is reported for `B.SetData(object?)`.</Description>
        <CreatedDate>05/11/2018</CreatedDate>
        <ClosedDate>04/05/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/Conversions/ConversionsBase.cs</File>
      <File>src/Compilers/CSharp/Portable/CSharpResources.Designer.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/ErrorCode.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/ErrorFacts.cs</File>
      <File>src/Compilers/CSharp/Portable/Generated/ErrorFacts.Generated.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceMemberContainerSymbol_ImplementationChecks.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/NullableReferenceTypesTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Diagnostics/DiagnosticTest.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>34712</IssueID>
    <Title>Features/readonly members</Title>
    <Description>Related to #32911 and dotnet/csharplang#1710

All commits have been previously reviewed.

cc @jaredpar </Description>
    <CreatedDate>03/04/2019</CreatedDate>
    <ClosedDate>03/04/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>32911</IssueID>
        <Title>Test plan for "readonly members"</Title>
        <Description>Proposal: dotnet/csharplang#1710

This issue is a place to collect test ideas and track their validation. Use the [compiler test plan](
https://github.com/dotnet/roslyn/blob/master/docs/contributing/Compiler%20Test%20Plan.md) as a tool for brainstorming.

- [x] write speclet
- [x] update compiler test plan
- [x] validate with LangVersion 7.3

### Methods
- [x] struct instance methods
- [x] struct static methods (should error)
- [x] class/interface static/instance methods (should error)
- [x] ref/ref readonly returning methods
- [x] Inherited object members should be considered readonly
- [x] 'readonly partial' methods
- [x] 'readonly partial' where one of declaration or implementation is missing keyword (error)
- [x] `readonly` on `new ToString()`

### Properties
- [x] struct readonly getters
- [x] struct readonly setters (not auto-implemented)
- [x] struct static properties with readonly accessors (should error)
- [x] class/interface properties with readonly accessors (should error)
- [x] expression bodied properties `int P readonly =&gt; 42;` (should error)
- [x] indexers (allow)
- [x] readonly getter in a readonly property? (should be disallowed)
- [x] readonly on `int P { readonly get; set; }` allowed
- [x] getter implicitly readonly for all auto-props
- [x] `int P { readonly get; }` not allowed -&gt; `readonly int P { get; }`


### Misc
- [x] Constructors (disallow)
- [x] Operators (disallow)
- [x] Delegates (disallow)
- [x] Field-like events (disallow)
- [x] Manually implemented events (allow)
- [x] lambdas/local functions (error)
- [x] explicit interface implementations (should allow)
~~- [ ] SymbolDisplay on methods and property/indexer/event accessors~~ #34650
~~- [ ] IsDeclaredReadonly on ISymbol or IPropertySymbol/IMethodSymbol~~ #34213

### Semantic

- [x] Calling readonly methods from readonly methods
- [x] Calling non-readonly struct methods from readonly methods
- [x] Calling a non-readonly method on a reference type field from a readonly method
- [x] Variants of these which use different combinations of properties and methods
- [x] Assignment to `this`
- [x] Reference to instance fields in readonly member
    - [x] Assignment is an error
    - [x] Invocation w/ instance field as receiver causes copy when type is non-readonly struct
- [x] Invocation of non-readonly method or getter on `this` inside a `readonly` member causes copy and a warning. Non-readonly setter access on `this` or a value typed field is an error.
- [x] Unary increment/decrement operators on fields are errors
- [x] Compound assignment on fields is an error
- [x] Round-tripping through metadata
- [x] Error to take `ref` to `this` in `readonly` member
- [x] Property assignment:
  - [x] Disallow on non-readonly instance properties on `this` or value-typed fields
  - [x] Allow on static or readonly properties, or properties on reference-typed fields
  - [x] Compound assignment behavior should be consistent with a getter-then-setter access
https://sharplab.io/#v2:EYLgZgpghgLgrgJwgZwLRKgEwPYDsA2AnqgLYQnAQLIA0MIAlvjZiANQA+AAgAwAEXAIwBuALAAoDDgKE+yGAjgBjGHwDKEgN4S+uvg1yqACn018A5hFVmuAdj49hAXzlXTfF0517vurgBY+AFkACgN1OQBKX1MYvT4YAAsGZAA6EwBePn8AJjFxePi0zOy8mK8Cn3EKiXlFFXUcrRiDY3dLawF7RxdkNzNPGJipPCIBQNDwtRy5HOjK3W0FwoB6FaSU9L4s3PzCvTXkHK2dsuX4gH1thOTivf2bzZM2LLP4iviJJyA=

### IDE
~~- [ ] Extracting a method from a `readonly` method should produce a `readonly` method~~ #34647
~~- [ ] Suggestion to make a member `readonly` when it is called on a `ref readonly` receiver~~ #34648
~~- [ ] WRN_ImplicitCopyInReadOnlyMember should have a suggestion to make the callee `readonly` if possible~~ #34649
~~- [ ] WRN_ImplicitCopyInReadOnlyMember should have a suggestion to make an explicit copy of the receiver~~ 
- [x] Offered in completion in existing member
~~- [ ] Metadata as source~~ #34650

### Major sections of work (ideally PRs will not cover more than one of these)
- [x] Parsing of `readonly` method and property syntax (mostly just testing)
- [x] IsReadOnly API on MethodSymbol
  - In the case of properties, is `prop.GetMethod.IsReadOnly` acceptable design, or is it confusing to have `prop.IsReadOnly` potentially return a different value than `prop.GetMethod.IsReadOnly`?
- [x] Flow analysis to prevent mutation of `this` in `readonly` member implementation
  - maybe the analysis used for `in` params or `readonly struct` can just be reused?
- [x] Error on invalid usage of `readonly`
  - Any method or property without a `this` parameter (i.e. statics)
  - Any member inside a non-struct declaration (i.e. class, interface)
- [x] Emit tests to demonstrate that expected metadata (IsReadOnly, modopt, modreq) and optimizations (reduced value copying) are present in IL

~~- [ ] Should some synthesized methods be marked as readonly? ([discussion](https://github.com/dotnet/roslyn/pull/34260#issuecomment-474994280))~~ #36587
- [x] Should we disallow readonly members on readonly structs, since redundant? Or maybe we create an IDE fixer?
  - Resolution: Should be allowed, based on the principle that changing `struct` to `readonly struct` on a type where all members are marked readonly shouldn't result in a compile error. </Description>
        <CreatedDate>29/01/2019</CreatedDate>
        <ClosedDate>19/06/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>1710</IssueID>
        <Title>HostAnalyzerManager.GetAnalyzerReferenceId should generate a unique ID</Title>
        <Description>See: http://source.roslyn.io/Microsoft.CodeAnalysis.Features/R/a1c94dbeedc15fae.html

This method uses Display as the analyzer reference ID, which is incorrect as that can return just the assembly name or path name. Both of these can't really be a unique ID for an analyzer reference. We need AnalyzerReference to expose an ID which can be used to de-duplicate different instances of analyzer references created with same underlying analyzer assembly but from different sources, e.g. same analyzer assembly added as a VSIX analyzer reference and a project analyzer reference.

see #1703 for more comments on this issue.
</Description>
        <CreatedDate>31/03/2015</CreatedDate>
        <ClosedDate>05/05/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder.ValueChecks.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Deconstruct.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Expressions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Invocation.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/ForEachLoopBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/CSharpResources.Designer.cs</File>
      <File>src/Compilers/CSharp/Portable/CodeGen/EmitAddress.cs</File>
      <File>src/Compilers/CSharp/Portable/CodeGen/EmitExpression.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/ErrorCode.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/ErrorFacts.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/MessageID.cs</File>
      <File>src/Compilers/CSharp/Portable/Generated/ErrorFacts.Generated.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/LanguageParser.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/AnonymousTypes/PublicSymbols/AnonymousType.TypePublicSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/AnonymousTypes/SynthesizedSymbols/AnonymousType.SynthesizedMethodBase.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/AnonymousTypes/SynthesizedSymbols/AnonymousType.TemplateSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ArrayTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/DynamicTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ErrorMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ErrorTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PEMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PENamedTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/MethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/PointerTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ReducedExtensionMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/SignatureOnlyMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/LambdaSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/LocalFunctionSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceEventSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceMemberContainerSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceMemberMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceOrdinaryMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourcePropertyAccessorSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourcePropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/ThisParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedContainer.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedEmbeddedAttributeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedEntryPointSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedGlobalMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedInstanceMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedIntrinsicOperatorSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedStaticConstructor.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/TypeParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/TypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Wrapped/WrappedMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Wrapped/WrappedNamedTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenReadonlyStructTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Emit/CompilationEmitTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/ReadOnlyStructsTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/SymbolDisplay/SymbolDisplayTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/MockNamedTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Diagnostics/DiagnosticTest.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/DeclarationParsingTests.cs</File>
      <File>src/Compilers/Core/Portable/Symbols/IMethodSymbol.cs</File>
      <File>src/Compilers/Core/Portable/Symbols/ITypeSymbol.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Source/ExpressionCompiler/Symbols/EEMethodSymbol.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Source/ExpressionCompiler/Symbols/EENamedTypeSymbol.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Source/ExpressionCompiler/Symbols/PlaceholderMethodSymbol.cs</File>
      <File>src/Features/Core/Portable/MetadataAsSource/AbstractMetadataAsSourceService.WrappedMethodSymbol.cs</File>
      <File>src/Features/Core/Portable/MetadataAsSource/AbstractMetadataAsSourceService.WrappedNamedTypeSymbol.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/Symbols/CodeGenerationAbstractMethodSymbol.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/Symbols/CodeGenerationConstructedMethodSymbol.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/Symbols/CodeGenerationMethodSymbol.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/Symbols/CodeGenerationTypeSymbol.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>34468</IssueID>
    <Title>Readonly members prototype cleanup</Title>
    <Description>Related to #32911 

This PR has several minor fixes and adds coverage for some new scenarios.

- Addresses and removes prototype comments (except for the public API ones in #34514)
- Updates `ThisParameterSymbol.RefKind` API to use RefKind.In when containingMethod.IsEffectivelyReadOnly
- Updates compiler test plan to mention readonly members
- Tests codegen of ReadOnlyMethod_OverrideBaseMethod
- Tests `readonly partial` methods: both signatures must contain `readonly`. Is this what we want?
  - Resolution: either both signatures or neither signature must contain 'readonly'.
- Tests readonly explicit interface implementations. These are allowed. Do we want that?
  - Resolution: 'readonly' explicit interface implementations are allowed.

The last few items might need to be hashed out in review and the speclet should probably be updated to be clear about the expected behavior. (done)</Description>
    <CreatedDate>26/03/2019</CreatedDate>
    <ClosedDate>29/03/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>32911</IssueID>
        <Title>Test plan for "readonly members"</Title>
        <Description>Proposal: dotnet/csharplang#1710

This issue is a place to collect test ideas and track their validation. Use the [compiler test plan](
https://github.com/dotnet/roslyn/blob/master/docs/contributing/Compiler%20Test%20Plan.md) as a tool for brainstorming.

- [x] write speclet
- [x] update compiler test plan
- [x] validate with LangVersion 7.3

### Methods
- [x] struct instance methods
- [x] struct static methods (should error)
- [x] class/interface static/instance methods (should error)
- [x] ref/ref readonly returning methods
- [x] Inherited object members should be considered readonly
- [x] 'readonly partial' methods
- [x] 'readonly partial' where one of declaration or implementation is missing keyword (error)
- [x] `readonly` on `new ToString()`

### Properties
- [x] struct readonly getters
- [x] struct readonly setters (not auto-implemented)
- [x] struct static properties with readonly accessors (should error)
- [x] class/interface properties with readonly accessors (should error)
- [x] expression bodied properties `int P readonly =&gt; 42;` (should error)
- [x] indexers (allow)
- [x] readonly getter in a readonly property? (should be disallowed)
- [x] readonly on `int P { readonly get; set; }` allowed
- [x] getter implicitly readonly for all auto-props
- [x] `int P { readonly get; }` not allowed -&gt; `readonly int P { get; }`


### Misc
- [x] Constructors (disallow)
- [x] Operators (disallow)
- [x] Delegates (disallow)
- [x] Field-like events (disallow)
- [x] Manually implemented events (allow)
- [x] lambdas/local functions (error)
- [x] explicit interface implementations (should allow)
~~- [ ] SymbolDisplay on methods and property/indexer/event accessors~~ #34650
~~- [ ] IsDeclaredReadonly on ISymbol or IPropertySymbol/IMethodSymbol~~ #34213

### Semantic

- [x] Calling readonly methods from readonly methods
- [x] Calling non-readonly struct methods from readonly methods
- [x] Calling a non-readonly method on a reference type field from a readonly method
- [x] Variants of these which use different combinations of properties and methods
- [x] Assignment to `this`
- [x] Reference to instance fields in readonly member
    - [x] Assignment is an error
    - [x] Invocation w/ instance field as receiver causes copy when type is non-readonly struct
- [x] Invocation of non-readonly method or getter on `this` inside a `readonly` member causes copy and a warning. Non-readonly setter access on `this` or a value typed field is an error.
- [x] Unary increment/decrement operators on fields are errors
- [x] Compound assignment on fields is an error
- [x] Round-tripping through metadata
- [x] Error to take `ref` to `this` in `readonly` member
- [x] Property assignment:
  - [x] Disallow on non-readonly instance properties on `this` or value-typed fields
  - [x] Allow on static or readonly properties, or properties on reference-typed fields
  - [x] Compound assignment behavior should be consistent with a getter-then-setter access
https://sharplab.io/#v2:EYLgZgpghgLgrgJwgZwLRKgEwPYDsA2AnqgLYQnAQLIA0MIAlvjZiANQA+AAgAwAEXAIwBuALAAoDDgKE+yGAjgBjGHwDKEgN4S+uvg1yqACn018A5hFVmuAdj49hAXzlXTfF0517vurgBY+AFkACgN1OQBKX1MYvT4YAAsGZAA6EwBePn8AJjFxePi0zOy8mK8Cn3EKiXlFFXUcrRiDY3dLawF7RxdkNzNPGJipPCIBQNDwtRy5HOjK3W0FwoB6FaSU9L4s3PzCvTXkHK2dsuX4gH1thOTivf2bzZM2LLP4iviJJyA=

### IDE
~~- [ ] Extracting a method from a `readonly` method should produce a `readonly` method~~ #34647
~~- [ ] Suggestion to make a member `readonly` when it is called on a `ref readonly` receiver~~ #34648
~~- [ ] WRN_ImplicitCopyInReadOnlyMember should have a suggestion to make the callee `readonly` if possible~~ #34649
~~- [ ] WRN_ImplicitCopyInReadOnlyMember should have a suggestion to make an explicit copy of the receiver~~ 
- [x] Offered in completion in existing member
~~- [ ] Metadata as source~~ #34650

### Major sections of work (ideally PRs will not cover more than one of these)
- [x] Parsing of `readonly` method and property syntax (mostly just testing)
- [x] IsReadOnly API on MethodSymbol
  - In the case of properties, is `prop.GetMethod.IsReadOnly` acceptable design, or is it confusing to have `prop.IsReadOnly` potentially return a different value than `prop.GetMethod.IsReadOnly`?
- [x] Flow analysis to prevent mutation of `this` in `readonly` member implementation
  - maybe the analysis used for `in` params or `readonly struct` can just be reused?
- [x] Error on invalid usage of `readonly`
  - Any method or property without a `this` parameter (i.e. statics)
  - Any member inside a non-struct declaration (i.e. class, interface)
- [x] Emit tests to demonstrate that expected metadata (IsReadOnly, modopt, modreq) and optimizations (reduced value copying) are present in IL

~~- [ ] Should some synthesized methods be marked as readonly? ([discussion](https://github.com/dotnet/roslyn/pull/34260#issuecomment-474994280))~~ #36587
- [x] Should we disallow readonly members on readonly structs, since redundant? Or maybe we create an IDE fixer?
  - Resolution: Should be allowed, based on the principle that changing `struct` to `readonly struct` on a type where all members are marked readonly shouldn't result in a compile error. </Description>
        <CreatedDate>29/01/2019</CreatedDate>
        <ClosedDate>19/06/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>34514</IssueID>
        <Title>Add IMethodSymbol.IsReadOnly to public API</Title>
        <Description>This proposes adding the following public API to `IMethodSymbol`:

```cs
/// &lt;summary&gt;
/// Indicates whether the method is readonly, i.e.
/// whether 'this' is 'ref readonly' in the scope of the method.
/// &lt;/summary&gt;
bool IsReadOnly { get; }
```

Note that once the last prototype comments are addressed, the check `methodSymbol.IsReadOnly` will be basically equivalent to `methodSymbol.ThisParameter.RefKind == RefKind.In`.</Description>
        <CreatedDate>27/03/2019</CreatedDate>
        <ClosedDate>03/04/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/CSharpResources.Designer.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/ErrorCode.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceOrdinaryMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/ThisParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenReadonlyStructTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/ReadOnlyStructsTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>34440</IssueID>
    <Title>Export additional code styles in .editorconfig generation</Title>
    <Description>~~Builds on #33946~~
Possibly supersedes #34122 

* Export using directives styles when generating .editorconfig (Fixes #33766)
* Export naming styles when generating .editorconfig (Fixes #30086)</Description>
    <CreatedDate>26/03/2019</CreatedDate>
    <ClosedDate>19/04/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>33946</IssueID>
        <Title>Add AssertEx.EqualOrDiff</Title>
        <Description>Based on work by @AArnott in dotnet/roslyn-sdk#240.
</Description>
        <CreatedDate>07/03/2019</CreatedDate>
        <ClosedDate>08/04/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>34122</IssueID>
        <Title>[WIP]Bugfix: Settings for using-directives not exported to .editorconfig</Title>
        <Description>Fixes https://github.com/dotnet/roslyn/issues/33766

At the moment both `dotnet_sort_system_directives_first` and `dotnet_separate_import_directive_groups` rules are not exported when exporting overridden code style from Visual Studio to editorconfig. This PR will ensure both are exported.

EditorConfig-rules: https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference?view=vs-2017#net-formatting-settings</Description>
        <CreatedDate>14/03/2019</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>33766</IssueID>
        <Title>Settings for using directives not exported to .editorconfig</Title>
        <Description>**Version Used**: VS2019 dogfood

**Steps to Reproduce**:

1. Open Tools -&gt; Options
2. Configure settings on Text Editor -&gt; C# -&gt; Advanced for how to style using directives
    * Place 'System' directives first when sorting usings
    * Separate using directive groups
3. Switch to Code Style options and export .editorconfig settings

**Expected Behavior**:
These options for using directives should be exported (dotnet_sort_system_directives_first and dotnet_separate_import_directive_groups respectively)

**Actual Behavior**:
They are not exported to the .editorconfig file</Description>
        <CreatedDate>28/02/2019</CreatedDate>
        <ClosedDate>19/04/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>30086</IssueID>
        <Title>Add support for generating current naming rules/options in the editorconfig generator</Title>
        <Description>See the discussion here: https://github.com/dotnet/roslyn/pull/30043#discussion_r219246165. Current editorconfig file generation only handles formatting and code style options, but we should extend it to generate entries for naming rules as well.</Description>
        <CreatedDate>20/09/2018</CreatedDate>
        <ClosedDate>19/04/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/VisualStudio/Core/Impl/Options/GridOptionPreviewControl.xaml.cs</File>
      <File>src/Workspaces/Core/Portable/Diagnostics/Extensions.cs</File>
      <File>src/Workspaces/Core/Portable/Editing/GenerationOptions.cs</File>
      <File>src/Workspaces/Core/Portable/NamingStyles/EditorConfig/EditorConfigNamingStyleParser_NamingStyle.cs</File>
      <File>src/Workspaces/Core/Portable/NamingStyles/EditorConfig/EditorConfigNamingStyleParser_SymbolSpec.cs</File>
      <File>src/Workspaces/Core/Portable/Options/EditorConfig/EditorConfigFileGenerator.cs</File>
      <File>src/Workspaces/Core/Portable/WorkspacesResources.Designer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>33942</IssueID>
    <Title>Copy nullable state from a limited set of BoundExpression types only</Title>
    <Description>Reverts fix for #31395 for now.

Fixes #33908.</Description>
    <CreatedDate>07/03/2019</CreatedDate>
    <ClosedDate>07/03/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>31395</IssueID>
        <Title>Nullability of class fields are not inherited on assignment</Title>
        <Description>A warning is reported for `d.F`. (Compare with `t.F`.)
```c#
#nullable enable

class C
{
    internal object? F;
}

struct S
{
    internal object? F;
}

class Program
{
    static void F1()
    {
        var c = new C() { F = "" };
        F(c.F); // ok
        var d = c;
        F(d.F); // warning
    }

    static void F2()
    {
        var s = new S() { F = "" };
        F(s.F); // ok
        var t = s;
        F(t.F); // ok
    }

    static void F(object o)
    {
    }
}
```
</Description>
        <CreatedDate>27/11/2018</CreatedDate>
        <ClosedDate>16/05/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>33908</IssueID>
        <Title>StackOverflow when compiling CoreFX</Title>
        <Description>Trying to move to the current Arcade toolset results in a stackoverflow when compiling CoreFX: https://github.com/dotnet/corefx/pull/35826

Stack trace is 
[stacktrace2.txt](https://github.com/dotnet/corefx/files/2938556/stacktrace2.txt) -- Worth noting it exceeds the number of stack frames VS supports. I also have a dump locally, but it is 500mb.

Compiler version is `3.1.0-beta1-19127-06`, which corresponds to https://github.com/dotnet/roslyn/commits/3ef46d8367f4ae</Description>
        <CreatedDate>06/03/2019</CreatedDate>
        <ClosedDate>07/03/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/BoundTree/BoundExpressionExtensions.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/NullableWalker.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/NullableReferenceTypesTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>33938</IssueID>
    <Title>Fix several outstanding small formatter bugs</Title>
    <Description>📝 I can break this pull request up on request.

* `NewLineForElse` must check parent of preceding brace (fixes #33458)
* Fix spacing before parameter list for conversion operators (fixes #31571, fixes #33910)
* Fix formatting of switch expression blocks (fixes #33839)</Description>
    <CreatedDate>07/03/2019</CreatedDate>
    <ClosedDate>15/03/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>33458</IssueID>
        <Title>C# formatter missing linebreak after curly braces of for block</Title>
        <Description>When using an for block inside an if condition without curly braces, the else gets put in the same line as the closing brace of the for block.

example:

```csharp
if (true)
    for (int i = 0; i &lt;2; i++) {
       i++;
    } else
     b =5;
```

instead of the expected:

```csharp
if (true)
    for (int i = 0; i &lt;2; i++) {
       i++;
    } 
else
     b =5;
```

correct placement:

```csharp
if(true){
   b=2;
} else
   b=3;
```

and:

```csharp
if(true)
   b=2;
else
   b=4;
```

_This issue has been moved from https://developercommunity.visualstudio.com/content/problem/431619/c-formatter-missing-linebreak-after-curly-braces-o.html
VSTS ticketId: 774047_
_These are the original issue comments:_

roland.fredenhagen on 1/20/2019, 06:42 AM (27 days ago): The Title misses "else" sorry for that, but it seams like I am not able to edit anything.
_These are the original issue solutions:_
(no solutions)</Description>
        <CreatedDate>17/02/2019</CreatedDate>
        <ClosedDate>15/03/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>31571</IssueID>
        <Title>Incorrect formatting of conversion operator to nullable type</Title>
        <Description>**Version Used**: Visual Studio 2019 Preview 1

**Steps to Reproduce**:

Run Format Document on the following code:

```csharp
public class MyType
{
    public static explicit operator int?(MyType obj) =&gt; null;
}
```

**Expected Behavior**:

```csharp
public class MyType
{
    public static explicit operator int?(MyType obj) =&gt; null;
}
```

**Actual Behavior**:

```csharp
public class MyType
{
    public static explicit operator int? (MyType obj) =&gt; null;
}
```
</Description>
        <CreatedDate>06/12/2018</CreatedDate>
        <ClosedDate>15/03/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>33910</IssueID>
        <Title>Incorrect formatter behavior in implicit conversions to a tuple</Title>
        <Description>```C#
class C
{
    public static implicit operator (C, C)(C c) =&gt; throw null;
    public static implicit operator int?(C c) =&gt; throw null;
}
```

Currently, the formatter wants to insert a space between the type and the argument list here. It should not, like all other conversions.</Description>
        <CreatedDate>06/03/2019</CreatedDate>
        <ClosedDate>15/03/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>33839</IssueID>
        <Title>Intendation for switch expression is not good in expression bodied method</Title>
        <Description>**Version Used**: 
VS 2019 RC
![image](https://user-images.githubusercontent.com/5644458/53704071-b3b98b80-3e53-11e9-8187-a382808d578c.png)
![image](https://user-images.githubusercontent.com/5644458/53704073-c2a03e00-3e53-11e9-942c-e4bcbf396cc6.png)
![image](https://user-images.githubusercontent.com/5644458/53704077-d350b400-3e53-11e9-9810-2b2c682df721.png)
The first case should be considered mis-aligned, comparing to object initializer.</Description>
        <CreatedDate>04/03/2019</CreatedDate>
        <ClosedDate>15/03/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/ConvertTupleToStruct/ConvertTupleToStructTests.cs</File>
      <File>src/Workspaces/CSharp/Portable/Formatting/Rules/IndentBlockFormattingRule.cs</File>
      <File>src/Workspaces/CSharp/Portable/Formatting/Rules/NewLineUserSettingFormattingRule.cs</File>
      <File>src/Workspaces/CSharp/Portable/Formatting/Rules/SpacingFormattingRule.cs</File>
      <File>src/Workspaces/CSharpTest/Formatting/FormattingTests.cs</File>
      <File>src/Workspaces/Core/Portable/Shared/Extensions/ChildSyntaxListExtensions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>33927</IssueID>
    <Title>Refine the set of NullableAnnotation values to the three speakable options</Title>
    <Description>- Eliminate values of `NullableAnnotation` that are "unspeakable"
- Change the result of dynamic invocations to result in an oblivious state
- Simplify the code in a few places where we compute result annotations (TSWA and `TypeWithState` are capable of storing an annotation/state even for typeless expressions)

Fixes #33638 
Filed #33924 to fix the result state of `?:`
</Description>
    <CreatedDate>07/03/2019</CreatedDate>
    <ClosedDate>08/03/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>33638</IssueID>
        <Title>Incorrect nullability inferred with nested generics (nullable walker)</Title>
        <Description>The following test should produce no diagnostics, but it produces diagnostics.

``` c#
        [Fact]
        public void TupleFromNestedGenerics()
        {
            var source =
@"public class G&lt;T&gt;
{
    public (T, U) M&lt;U&gt;(T t, U u) =&gt; (t, u);
}
public class C
{
    public (T, U) M&lt;T, U&gt;(T t, U u) =&gt; (t, u);
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (3,37): warning CS8619: Nullability of reference types in value of type '(T t, U u)' doesn't match target type '(T, U)'.
                //     public (T, U) M&lt;U&gt;(T t, U u) =&gt; (t, u);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(t, u)").WithArguments("(T t, U u)", "(T, U)").WithLocation(3, 37),
                // (7,40): warning CS8619: Nullability of reference types in value of type '(T t, U u)' doesn't match target type '(T, U)'.
                //     public (T, U) M&lt;T, U&gt;(T t, U u) =&gt; (t, u);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(t, u)").WithArguments("(T t, U u)", "(T, U)").WithLocation(7, 40));
        }
```
</Description>
        <CreatedDate>24/02/2019</CreatedDate>
        <ClosedDate>08/03/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>33924</IssueID>
        <Title>Conditional expression should compute nullable result state from result state of operands</Title>
        <Description>Currently the computation is done in terms of nullable annotations.  But that is not correct, for example, with unconstrained type parameters that are known not to be null.  That fact is not representable in annotations, only in the nullable flow state.

See also #33664</Description>
        <CreatedDate>07/03/2019</CreatedDate>
        <ClosedDate>26/03/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Constraints.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Expressions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Operators.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/BestTypeInferrer.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/Conversions/ConversionsBase.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/OverloadResolution/MethodTypeInference.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/BoundExpressionExtensions.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/UnboundLambda.cs</File>
      <File>src/Compilers/CSharp/Portable/Emitter/Model/PEModuleBuilder.cs</File>
      <File>src/Compilers/CSharp/Portable/Emitter/Model/TypeParameterSymbolAdapter.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/NullableWalker.ObjectCreationPlaceholderLocal.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/NullableWalker.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/UnassignedFieldsWalker.cs</File>
      <File>src/Compilers/CSharp/Portable/SymbolDisplay/SymbolDisplayVisitor.Types.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ConstraintsHelper.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PETypeParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/SymbolFactory.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/NullableAnnotation.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/NullableAnnotationExtensions.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/NullableFlowState.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/NullableFlowStateExtensions.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceComplexParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/SubstitutedTypeParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Tuples/TupleTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/TypeParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/TypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/TypeSymbolWithAnnotations.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/TypeWithState.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/NullableReferenceTypesTests.cs</File>
      <File>src/Compilers/Test/Utilities/CSharp/CompilationTestUtils.cs</File>
      <File>src/Compilers/Test/Utilities/CSharp/UsesIsNullableVisitor.cs</File>
      <File>src/Scripting/CoreTest/ScriptOptionsTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>33880</IssueID>
    <Title>Remove comments for already-resolved github issues.</Title>
    <Description>See also #28798, #32047, #33879
Closes #29953</Description>
    <CreatedDate>05/03/2019</CreatedDate>
    <ClosedDate>06/03/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>28798</IssueID>
        <Title>Handle unreachable code in the nullable walker</Title>
        <Description>In unreachable code, the state for every trackable variable should be "not null".

There are a few reasons for this:
1. From a formal, flow-analysis theoretical point of view, this is one end of the lattice and is therefore the default value of the state that is refined as flow analysis proceeds.
2. From a practical point of view, this prevents producing (most) warnings in unreachable code (even if those warnings would later be suppressed).
3. The flow analysis base classes expect the state to implement `bool AbstractState.Reachable { get; }`

There are a couple of approaches for doing this. The simplest is to have a bit in the state that tracks whether the state is reachable or not (just like control flow analysis and data flow analysis). When such a state is asked for the nullable state of some variable, it always answers "not null".

Another approach, which may be worth doing in addition, would be to
1. Suppress all warnings when the state is unreachable.
2. When merging two states, if one of them is reachable then the result state is the other one.
</Description>
        <CreatedDate>23/07/2018</CreatedDate>
        <ClosedDate>10/05/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>32047</IssueID>
        <Title>Null state in unreachable code</Title>
        <Description>I think the null state of an expression should take into account when it occurs in unreachable code.  An expression in unreachable code is never ever `null`.  Even the expression `null` is never null in unreachable code.

This is not the same as simply suppressing warnings in unreachable code (though we should consider that too).  For example:
``` c#
#nullable enable
public class C {
    public void M(bool b, string s) {
        var t = (b || true) ? s : null;
        t.ToString(); // unexpected warning CS8602: Possible dereference of a null reference.
    }
}
```
Formally, my proposal is that an expression is never `null` in an unreachable statement, never `null` when false after the constant true, never `null` when true after the constant false, and never `null` when false after `expr is var x` and similar patterns (which are always true but not a constant).  These all have in common that the “current” state in the nullable analysis should be the unreachable state when evaluating the code in question.  That means there is a nice bottleneck in the rvalue-visiting method where this can be implemented.

</Description>
        <CreatedDate>28/12/2018</CreatedDate>
        <ClosedDate>05/03/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>33879</IssueID>
        <Title>Issues with lifted conversions</Title>
        <Description>There are three comments in `NullableWalker.cs` regarding issues in lifted operators, particularly conversions, that need to be reexamined.  They are marked with this issue number.

In `GetSlotsToMarkAsNotNullable`:
``` c#
                switch (operand.Kind)
                {
                    case BoundKind.Conversion:
                        // https://github.com/dotnet/roslyn/issues/33879 Detect when conversion has a nullable operand
                        operand = ((BoundConversion)operand).Operand;
                        continue;
```
also
``` c#
                    default:
                        // Attempt to create a slot for the current thing. If there were any more conditional accesses,
                        // they would have been on top, so this is the last thing we need to specially handle.

                        // https://github.com/dotnet/roslyn/issues/33879 When we handle unconditional access survival (ie after
                        // c.D has been invoked, c must be nonnull or we've thrown a NullRef), revisit whether
                        // we need more special handling here
```
Also in InferResultNullability
``` c#
        private TypeWithState InferResultNullability(BoundUserDefinedConditionalLogicalOperator node)
        {
            if (node.OperatorKind.IsLifted())
            {
                // https://github.com/dotnet/roslyn/issues/33879 Conversions: Lifted operator
                // Should this use the updated flow type and state?  How should it compute nullability?
                return new TypeWithState(node.Type, NullableFlowState.NotNull);
            }
```
</Description>
        <CreatedDate>05/03/2019</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>29953</IssueID>
        <Title>Various issues with nullability analysis in unary/binary operators</Title>
        <Description>In particular, one of the recurring PROTOTYPE markers was to handle lifted operators.

```C#
        private TypeSymbolWithAnnotations InferResultNullability(BinaryOperatorKind operatorKind, MethodSymbol methodOpt, TypeSymbol resultType, TypeSymbolWithAnnotations leftType, TypeSymbolWithAnnotations rightType)
        {
            bool? isNullable = null;
            if (operatorKind.IsUserDefined())
            {
                if (operatorKind.IsLifted())
                {
                    // https://github.com/dotnet/roslyn/issues/29953 Conversions: Lifted operator
                    return TypeSymbolWithAnnotations.Create(resultType);
                }
                // Update method based on operand types: see https://github.com/dotnet/roslyn/issues/29605.
                if ((object)methodOpt != null &amp;&amp; methodOpt.ParameterCount == 2)
                {
                    return methodOpt.ReturnType;
                }
            }
            else if (!operatorKind.IsDynamic() &amp;&amp; !resultType.IsValueType)
            {
                switch (operatorKind.Operator() | operatorKind.OperandTypes())
                {
                    case BinaryOperatorKind.DelegateCombination:
                        {
                            bool? leftIsNullable = leftType.IsNullable;
                            bool? rightIsNullable = rightType.IsNullable;
                            if (leftIsNullable == false || rightIsNullable == false)
                            {
                                isNullable = false;
                            }
                            else if (leftIsNullable == true &amp;&amp; rightIsNullable == true)
                            {
                                isNullable = true;
                            }
                            else
                            {
                                Debug.Assert(leftIsNullable == null || rightIsNullable == null);
                            }
                        }
                        break;
                    case BinaryOperatorKind.DelegateRemoval:
                        isNullable = true; // Delegate removal can produce null.
                        break;
                    default:
                        isNullable = false;
                        break;
                }
            }
            return TypeSymbolWithAnnotations.Create(resultType, isNullable);
        }

        protected override void AfterLeftChildHasBeenVisited(BoundBinaryOperator binary)
        {
            Debug.Assert(!IsConditionalState);
            //if (this.State.Reachable) // Consider reachability: see https://github.com/dotnet/roslyn/issues/28798
            {
                TypeSymbolWithAnnotations leftType = _resultType;
                bool warnOnNullReferenceArgument = (binary.OperatorKind.IsUserDefined() &amp;&amp; (object)binary.MethodOpt != null &amp;&amp; binary.MethodOpt.ParameterCount == 2);

                if (warnOnNullReferenceArgument)
                {
                    ReportArgumentWarnings(binary.Left, leftType, binary.MethodOpt.Parameters[0]);
                }

                VisitRvalue(binary.Right);
                Debug.Assert(!IsConditionalState);

                // At this point, State.Reachable may be false for
                // invalid code such as `s + throw new Exception()`.
                TypeSymbolWithAnnotations rightType = _resultType;

                if (warnOnNullReferenceArgument)
                {
                    ReportArgumentWarnings(binary.Right, rightType, binary.MethodOpt.Parameters[1]);
                }

                Debug.Assert(!IsConditionalState);
                _resultType = InferResultNullability(binary, leftType, rightType);

                BinaryOperatorKind op = binary.OperatorKind.Operator();
                if (op == BinaryOperatorKind.Equal || op == BinaryOperatorKind.NotEqual)
                {
                    BoundExpression operandComparedToNull = null;
                    TypeSymbolWithAnnotations operandComparedToNullType = default;

                    if (binary.Right.ConstantValue?.IsNull == true)
                    {
                        operandComparedToNull = binary.Left;
                        operandComparedToNullType = leftType;
                    }
                    else if (binary.Left.ConstantValue?.IsNull == true)
                    {
                        operandComparedToNull = binary.Right;
                        operandComparedToNullType = rightType;
                    }

                    if (operandComparedToNull != null)
                    {
                        // PROTOTYPE(NullableReferenceTypes): This check is incorrect since it compares declared
                        // nullability rather than tracked nullability. Moreover, we should only report such
                        // diagnostics for locals that are set or checked explicitly within this method.
                        if (!operandComparedToNullType.IsNull &amp;&amp; operandComparedToNullType.IsNullable == false)
                        {
                            ReportDiagnostic(op == BinaryOperatorKind.Equal ?
                                                                    ErrorCode.HDN_NullCheckIsProbablyAlwaysFalse :
                                                                    ErrorCode.HDN_NullCheckIsProbablyAlwaysTrue,
                                                                binary.Syntax);
                        }

                        // Skip reference conversions
                        operandComparedToNull = SkipReferenceConversions(operandComparedToNull);

                        var slotBuilder = ArrayBuilder&lt;int&gt;.GetInstance();

                        // Set all nested conditional slots. For example in a?.b?.c we'll set a, b, and c
                        // getOperandSlots will only return slots for locations that are reference types.
                        getOperandSlots(operandComparedToNull, slotBuilder);
                        if (slotBuilder.Count != 0)
                        {
                            Normalize(ref this.State);
                            Split();
                            ref LocalState state = ref (op == BinaryOperatorKind.Equal) ? ref this.StateWhenFalse : ref this.StateWhenTrue;
                            foreach (int slot in slotBuilder)
                            {
                                state[slot] = true;
                            }
                        }

                        slotBuilder.Free();
                    }
                }
            }

            void getOperandSlots(BoundExpression operand, ArrayBuilder&lt;int&gt; slotBuilder)
            {
                Debug.Assert(operand != null);
                Debug.Assert(_lastConditionalAccessSlot == -1);

                do
                {
                    // Due to the nature of binding, if there are conditional access they will be at the top of the bound tree,
                    // potentially with a conversion on top of it. We go through any conditional accesses, adding slots for the
                    // conditional receivers if they have them. If we ever get to a receiver that MakeSlot doesn't return a slot
                    // for, nothing underneath is trackable and we bail at that point. Example:
                    //
                    //     a?.GetB()?.C // a is a field, GetB is a method, and C is a property
                    //
                    // The top of the tree is the a?.GetB() conditional call. We'll ask for a slot for a, and we'll get one because
                    // locals have slots. The AccessExpression of the BoundConditionalAccess is another BoundConditionalAccess, this time
                    // with a receiver of the GetB() BoundCall. Attempting to get a slot for this receiver will fail, and we'll
                    // return an array with just the slot for a.
                    int slot;
                    switch (operand.Kind)
                    {
                        case BoundKind.Conversion:
                            // PROTOTYPE(NullableReferenceTypes): Detect when conversion has a nullable operand
                            operand = ((BoundConversion)operand).Operand;
                            continue;
                        case BoundKind.ConditionalAccess:
                            var conditional = (BoundConditionalAccess)operand;

                            slot = MakeSlot(conditional.Receiver);
                            if (slot &gt; 0)
                            {
                                // If we got a slot we must have processed the previous conditional receiver.
                                Debug.Assert(_lastConditionalAccessSlot == -1);

                                // We need to continue the walk regardless of whether the receiver is a value
                                // type, but we only want to update the slots of reference types
                                if (shouldUpdateType(conditional.Receiver.Type))
                                {
                                    slotBuilder.Add(slot);
                                }

                                // When MakeSlot is called on the nested AccessExpression, it will recurse through receivers
                                // until it gets to the BoundConditionalReceiver associated with this node. In our override,
                                // we substitute this slot when we encounter a BoundConditionalReceiver, and reset the
                                // _lastConditionalAccess field.
                                _lastConditionalAccessSlot = slot;
                                operand = conditional.AccessExpression;
                                continue;
                            }

                            // If there's no slot for this receiver, there cannot be another slot for any of the remaining
                            // access expressions.
                            break;
                        default:
                            // Attempt to create a slot for the current thing. If there were any more conditional accesses,
                            // they would have been on top, so this is the last thing we need to specially handle.

                            // PROTOTYPE(NullableReferenceTypes): When we handle unconditional access survival (ie after
                            // c.D has been invoked, c must be nonnull or we've thrown a NullRef), revisit whether
                            // we need more special handling here

                            slot = MakeSlot(operand);
                            if (slot &gt; 0 &amp;&amp; shouldUpdateType(operand.Type))
                            {
                                // If we got a slot then all previous BoundCondtionalReceivers must have been handled.
                                Debug.Assert(_lastConditionalAccessSlot == -1);

                                slotBuilder.Add(slot);
                            }

                            break;
                    }

                    // If we didn't get a slot, it's possible that the current _lastConditionalSlot was never processed,
                    // so we reset before leaving the function.
                    _lastConditionalAccessSlot = -1;
                    return;
                } while (true);

                bool shouldUpdateType(TypeSymbol operandType) =&gt;
                    !(operandType is null) &amp;&amp; !operandType.IsValueType;
            }
        }


        public override BoundNode VisitUnaryOperator(BoundUnaryOperator node)
        {
            Debug.Assert(!IsConditionalState);

            var result = base.VisitUnaryOperator(node);
            TypeSymbolWithAnnotations resultType = default;

            // Update method based on inferred operand type: see https://github.com/dotnet/roslyn/issues/29605.
            if (node.OperatorKind.IsUserDefined())
            {
                if (node.OperatorKind.IsLifted())
                {
                    // PROTOTYPE(NullableReferenceTypes): Conversions: Lifted operator
                }
                else if ((object)node.MethodOpt != null &amp;&amp; node.MethodOpt.ParameterCount == 1)
                {
                    ReportArgumentWarnings(node.Operand, _resultType, node.MethodOpt.Parameters[0]);
                    resultType = node.MethodOpt.ReturnType;
                }
            }

            _resultType = resultType.IsNull ? TypeSymbolWithAnnotations.Create(node.Type) : resultType;
            return null;
        }

        private TypeSymbolWithAnnotations InferResultNullability(BoundUserDefinedConditionalLogicalOperator node)
        {
            if (node.OperatorKind.IsLifted())
            {
                // PROTOTYPE(NullableReferenceTypes): Conversions: Lifted operator
                return TypeSymbolWithAnnotations.Create(node.Type);
            }
            // Update method based on inferred operand types: see https://github.com/dotnet/roslyn/issues/29605.
            if ((object)node.LogicalOperator != null &amp;&amp; node.LogicalOperator.ParameterCount == 2)
            {
                return node.LogicalOperator.ReturnType;
            }
            else
            {
                return default;
            }
        }

```</Description>
        <CreatedDate>17/09/2018</CreatedDate>
        <ClosedDate>06/03/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/NullableWalker.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/NullableReferenceTypesTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>33871</IssueID>
    <Title>Split CloseFile into CloseCodeFile and CloseDesignerFile</Title>
    <Description>Fixes #26442
Fixes #26443
Fixes #26444</Description>
    <CreatedDate>05/03/2019</CreatedDate>
    <ClosedDate>05/03/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>26442</IssueID>
        <Title>Flaky integration test VisualBasic.BasicWinForms.AddControl</Title>
        <Description>**VisualBasic.BasicWinForms.AddControl** [failed](https://ci.dot.net/job/dotnet_roslyn/job/master/job/windows_debug_vs-integration_prtest/915/testReport/junit/Roslyn.VisualStudio.IntegrationTests.VisualBasic/BasicWinForms/AddControl/) in debug on a non-code PR (https://github.com/dotnet/roslyn/pull/26416) with the following message:

**Roslyn.VisualStudio.IntegrationTests.VisualBasic.BasicWinForms.AddControl** (from Roslyn.VisualStudio.IntegrationTests)

Failing for the past 1 build (Since Failed#915 )
Took 2.6 sec.
Stacktrace
MESSAGE:
Assert.Contains() Failure
Not found: ``Me.SomeButton.Name = "SomeButton"``
In value: 
```VB
&lt;Global.Microsoft.VisualBasic.CompilerServices.DesignerGenerated()&gt; _
Partial Class Form1
 Inherits System.Windows.Forms.Form
 
 'Form overrides dispose to clean up the component list.
  &lt;System.Diagnostics.DebuggerNonUserCode()&gt; _
  Protected Overrides Sub Dispose(ByVal disposing As Boolean)
   Try
    If disposing AndAlso components IsNot Nothing Then
     components.Dispose()
    End If
   Finally
    MyBase.Dispose(disposing)
   End Try
  End Sub
  
  'Required by the Windows Form Designer
  Private components As System.ComponentModel.IContainer
  
  'NOTE: The following procedure is required by the Windows Form Designer
  'It can be modified using the Windows Form Designer. 
  'Do not modify it using the code editor.
  &lt;System.Diagnostics.DebuggerStepThrough()&gt; _
  Private Sub InitializeComponent()
   components = New System.ComponentModel.Container()
   Me.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font
   Me.ClientSize = New System.Drawing.Size(800, 450)
   Me.Text = "Form1"
  End Sub
 
End Class

```
+++++++++++++++++++
STACK TRACE:
at Roslyn.VisualStudio.IntegrationTests.VisualBasic.BasicWinForms.AddControl()</Description>
        <CreatedDate>27/04/2018</CreatedDate>
        <ClosedDate>05/03/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>26443</IssueID>
        <Title>Flakey integration test VisualBasic.BasicWinForms.ChangeControlProperty</Title>
        <Description>**VisualBasic.BasicWinForms.ChangeControlProperty** [failed](https://ci.dot.net/job/dotnet_roslyn/job/master/job/windows_debug_vs-integration_prtest/915/testReport/junit/Roslyn.VisualStudio.IntegrationTests.VisualBasic/BasicWinForms/ChangeControlProperty/) in debug on a non-code PR (https://github.com/dotnet/roslyn/pull/26416) with the following message:

**Roslyn.VisualStudio.IntegrationTests.VisualBasic.BasicWinForms.ChangeControlProperty** (from Roslyn.VisualStudio.IntegrationTests)

Failing for the past 1 build (Since Failed#915 )
Took 3.3 sec.
Stacktrace
MESSAGE:
Assert.Contains() Failure
Not found: `Me.SomeButton.Text = "NewButtonText"`
In value:
```VB 
&lt;Global.Microsoft.VisualBasic.CompilerServices.DesignerGenerated()&gt; _
Partial Class Form1
 Inherits System.Windows.Forms.Form

 'Form overrides dispose to clean up the component list.
 &lt;System.Diagnostics.DebuggerNonUserCode()&gt; _
 Protected Overrides Sub Dispose(ByVal disposing As Boolean)
  Try
   If disposing AndAlso components IsNot Nothing Then
    components.Dispose()
   End If
  Finally
   MyBase.Dispose(disposing)
  End Try
 End Sub

 'Required by the Windows Form Designer
 Private components As System.ComponentModel.IContainer

 'NOTE: The following procedure is required by the Windows Form Designer
 'It can be modified using the Windows Form Designer. 
 'Do not modify it using the code editor.
 &lt;System.Diagnostics.DebuggerStepThrough()&gt; _
 Private Sub InitializeComponent()
  components = New System.ComponentModel.Container()
  Me.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font
  Me.ClientSize = New System.Drawing.Size(800, 450)
  Me.Text = "Form1"
 End Sub

End Class
```
+++++++++++++++++++
STACK TRACE:
at Roslyn.VisualStudio.IntegrationTests.VisualBasic.BasicWinForms.ChangeControlProperty()</Description>
        <CreatedDate>27/04/2018</CreatedDate>
        <ClosedDate>14/03/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>26444</IssueID>
        <Title>Flaky integration test VisualBasic.BasicWinForms.ChangeControlPropertyInCode</Title>
        <Description>**VisualBasic.BasicWinForms.ChangeControlPropertyInCode** [failed](https://ci.dot.net/job/dotnet_roslyn/job/master/job/windows_debug_vs-integration_prtest/915/testReport/junit/Roslyn.VisualStudio.IntegrationTests.VisualBasic/BasicWinForms/ChangeControlPropertyInCode/) in debug on a non-code PR (https://github.com/dotnet/roslyn/pull/26416) with the following message:

**Roslyn.VisualStudio.IntegrationTests.VisualBasic.BasicWinForms.ChangeControlPropertyInCode** (from Roslyn.VisualStudio.IntegrationTests)

Failing for the past 1 build (Since Failed#915 )
Took 2.7 sec.
Stacktrace
MESSAGE:
Assert.Contains() Failure
Not found: `Me.SomeButton.Text = "ButtonTextGoesHere"`
In value:
```VB
&lt;Global.Microsoft.VisualBasic.CompilerServices.DesignerGenerated()&gt; _
Partial Class Form1
 Inherits System.Windows.Forms.Form

 'Form overrides dispose to clean up the component list.
 &lt;System.Diagnostics.DebuggerNonUserCode()&gt; _
 Protected Overrides Sub Dispose(ByVal disposing As Boolean)
  Try
   If disposing AndAlso components IsNot Nothing Then
    components.Dispose()
   End If
  Finally
   MyBase.Dispose(disposing)
  End Try
 End Sub

 'Required by the Windows Form Designer
 Private components As System.ComponentModel.IContainer

 'NOTE: The following procedure is required by the Windows Form Designer
 'It can be modified using the Windows Form Designer. 
 'Do not modify it using the code editor.
 &lt;System.Diagnostics.DebuggerStepThrough()&gt; _
 Private Sub InitializeComponent()
  components = New System.ComponentModel.Container()
  Me.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font
  Me.ClientSize = New System.Drawing.Size(800, 450)
  Me.Text = "Form1"
 End Sub

End Class


```
+++++++++++++++++++
STACK TRACE:
at Roslyn.VisualStudio.IntegrationTests.VisualBasic.BasicWinForms.ChangeControlPropertyInCode()</Description>
        <CreatedDate>27/04/2018</CreatedDate>
        <ClosedDate>14/03/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/VisualStudio/IntegrationTest/IntegrationTests/CSharp/CSharpGoToDefinition.cs</File>
      <File>src/VisualStudio/IntegrationTest/IntegrationTests/CSharp/CSharpGoToImplementation.cs</File>
      <File>src/VisualStudio/IntegrationTest/IntegrationTests/CSharp/CSharpWinForms.cs</File>
      <File>src/VisualStudio/IntegrationTest/IntegrationTests/VisualBasic/BasicLineCommit.cs</File>
      <File>src/VisualStudio/IntegrationTest/IntegrationTests/VisualBasic/BasicWinForms.cs</File>
      <File>src/VisualStudio/IntegrationTest/TestUtilities/InProcess/SolutionExplorer_InProc.cs</File>
      <File>src/VisualStudio/IntegrationTest/TestUtilities/OutOfProcess/SolutionExplorer_OutOfProc.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>33300</IssueID>
    <Title>Bad code for consecutive interface type tests with a when clause in a switch (dev16.0)</Title>
    <Description>Fixes #32774

This was previously reviewed and approved by reviewers at #32808

See also https://devdiv.visualstudio.com/DevDiv/_workitems/edit/792969 for shiproom purposes.

/cc @jaredpar </Description>
    <CreatedDate>11/02/2019</CreatedDate>
    <ClosedDate>15/02/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>32774</IssueID>
        <Title>Visual Studio 2019 Preview 2 breaks Switch Case with when Statements</Title>
        <Description>**Version Used**: 
Visual Studio 2019 Preview 2

**Steps to Reproduce**:
Certain switch case statements including a when clause stopped working since updating to VS 2019 Preview 2.

The following statement will fail for every case that is not matched before the when clause:

        switch (someObject)
         {
            case string x:
               return true;
            case int x:
               return true;
            case IObject x when x.SubObject != null:
               return true;
            case IOtherObject x:
               return true;
            case double x:
               return true;
            default:
               return false;
         }

The following exception is thrown:  
_System.InvalidCastException: Unable to cast object of type 'System.Double' to type 'IOtherObject'._

However if you have an additional case just after the when where check without a condition it works fine:  

         switch (someObject)
         {
            case string x:
               return true;
            case int x:
               return true;
            case IObject x when x.SubObject != null:
               return true;
            case IObject x:
               return true;
            case IOtherObject x:
               return true;
            case double x:
               return true;
            default:
               return false;
         }

I uploaded a demo project to github that includes both cases and respective tests to showcase the problem:
https://github.com/huserben/VS19_SwitchCaseWhen

You can run the tests in VS 19 Preview 1 and one will fail, while both succeed if run from VS 2017

**Expected Behavior**:
Switch Case works in any of the cases
</Description>
        <CreatedDate>25/01/2019</CreatedDate>
        <ClosedDate>09/02/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>32808</IssueID>
        <Title>Bad code for consecutive interface type tests with a when clause in a switch</Title>
        <Description>Fixes #32774

@dotnet/roslyn-compiler May I please have a couple of reviews for this bad code fix targeting preview 3?
</Description>
        <CreatedDate>25/01/2019</CreatedDate>
        <ClosedDate>09/02/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/SwitchBinder_Patterns.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_BasePatternSwitchLocalRewriter.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/PatternTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>33291</IssueID>
    <Title>Reduce allocations in the formatter</Title>
    <Description>Builds on #33170 

This change reduces allocations in `AbstractFormatEngine.Format` by 70% (numbers before this change exceeded 10GiB while compiling Roslyn.sln).

| Item | Allocation fraction |
| --- | --- |
| Dictionary in TryGetEditorConfigOption | 39.6% |
| GetAdjustNewLinesOperation | 15.7% |
| ApplyTriviaOperations | 6.8% |
| TryGetOption | 4.4% |
| GetTrailingColonTrivia | 1.7% |
| ColonTriviaFollowedByLineContinuation (#33170) | 1.6% |
| PartOfMultilineLambdaFooter | 0.9% |</Description>
    <CreatedDate>11/02/2019</CreatedDate>
    <ClosedDate>12/02/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>33170</IssueID>
        <Title>Remove dead code</Title>
        <Description>Closes #32964

I was not able to find a case where the IDE clearly misbehaves over this. Of particular relevance:

1. The use of `:_` at the end of a line produces a compiler error that `_` must be followed by a whitespace
2. Formatting a document containing `: _` at the end of a line results in both characters getting removed</Description>
        <CreatedDate>06/02/2019</CreatedDate>
        <ClosedDate>11/02/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>33170</IssueID>
        <Title>Remove dead code</Title>
        <Description>Closes #32964

I was not able to find a case where the IDE clearly misbehaves over this. Of particular relevance:

1. The use of `:_` at the end of a line produces a compiler error that `_` must be followed by a whitespace
2. Formatting a document containing `: _` at the end of a line results in both characters getting removed</Description>
        <CreatedDate>06/02/2019</CreatedDate>
        <ClosedDate>11/02/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/CodeStyle/Core/Analyzers/Options/AnalyzerConfigOptionsExtensions.cs</File>
      <File>src/Compilers/Core/Portable/InternalUtilities/PerformanceSensitiveAttribute.cs</File>
      <File>src/Workspaces/CSharp/Portable/Formatting/Engine/Trivia/TriviaDataFactory.ComplexTrivia.cs</File>
      <File>src/Workspaces/CSharp/Portable/Formatting/Engine/Trivia/TriviaDataFactory.FormattedComplexTrivia.cs</File>
      <File>src/Workspaces/CSharp/Portable/Formatting/Engine/Trivia/TriviaDataFactory.ModifiedComplexTrivia.cs</File>
      <File>src/Workspaces/Core/Portable/Formatting/Engine/AbstractFormatEngine.OperationApplier.cs</File>
      <File>src/Workspaces/Core/Portable/Formatting/Engine/AbstractFormatEngine.Partitioner.cs</File>
      <File>src/Workspaces/Core/Portable/Formatting/Engine/AbstractFormatEngine.cs</File>
      <File>src/Workspaces/Core/Portable/Formatting/Engine/AbstractTriviaDataFactory.FormattedWhitespace.cs</File>
      <File>src/Workspaces/Core/Portable/Formatting/Engine/AbstractTriviaDataFactory.ModifiedWhitespace.cs</File>
      <File>src/Workspaces/Core/Portable/Formatting/Engine/AbstractTriviaDataFactory.Whitespace.cs</File>
      <File>src/Workspaces/Core/Portable/Formatting/Engine/TriviaData.cs</File>
      <File>src/Workspaces/Core/Portable/Options/EditorConfig/EditorConfigStorageLocation`1.cs</File>
      <File>src/Workspaces/Core/Portable/Shared/Extensions/SyntaxTriviaListExtensions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>33279</IssueID>
    <Title>Fix parsing regression of expressions involving parens when used as a case expression or a constant pattern.</Title>
    <Description>- Fix parsing regression of expressions involving parens when used as a case expression or a constant pattern.
Fixes #33054
Fixes #33208
- Incidentally also correct and test the precedence of the switch expression
See https://github.com/dotnet/csharplang/blob/master/proposals/patterns.md#switch-expression for the spec.
- Fix terminology to match the spec - "conditional expression" rather than "ternary expression".

See also https://devdiv.visualstudio.com/DevDiv/_workitems/edit/792975 for shiproom purposes.

@dotnet/roslyn-compiler May I please have a couple of reviews of this parsing regression?
</Description>
    <CreatedDate>11/02/2019</CreatedDate>
    <ClosedDate>15/02/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>33054</IssueID>
        <Title>[x64](3.0.100-preview-010184) Switch expression bug</Title>
        <Description>Hi

Looks like the new pattern matching feature broke old style switch expression

https://github.com/rds1983/StbImageSharp/blob/master/src/StbImageSharp/PngDecoder.cs#L714

Doesn't compile anymore 

```
  PngDecoder.cs(714, 38): [CS1003] Syntax error, ':' expected
  PngDecoder.cs(714, 70): [CS1002] ; expected
  PngDecoder.cs(714, 70): [CS1513] } expected
  PngDecoder.cs(718, 39): [CS1003] Syntax error, ',' expected
  PngDecoder.cs(774, 39): [CS1003] Syntax error, ',' expected
  PngDecoder.cs(793, 39): [CS1003] Syntax error, ',' expected
  PngDecoder.cs(842, 39): [CS1003] Syntax error, ',' expected
  PngDecoder.cs(878, 39): [CS1003] Syntax error, ',' expected
```</Description>
        <CreatedDate>01/02/2019</CreatedDate>
        <ClosedDate>15/02/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>33208</IssueID>
        <Title>Breaking: case no longer works with constant expressions</Title>
        <Description>**Version Used**: VisualStudio.16.Preview/16.0.0-pre.2.1+28529.54

**Steps to Reproduce**:
Switching on an integer variable:
`case ((2) + (2)):` and `case ((2 + 2) - 2):`
```
(3,10): error CS8370: Feature 'recursive patterns' is not available in C# 7.3. Please use language version 8.0 or greater.
(3,15): error CS1003: Chyba syntaxe; očekávána hodnota: ,
```

`case (2) | (2):` or `case ((2 &lt;&lt; 2) | 2):`
```
(3,20): error CS1026: Očekává se ).
(3,20): error CS1003: Chyba syntaxe; očekávána hodnota: :
(3,20): error CS1525: Neplatný výraz |
(3,23): error CS1002: Očekával se středník (;).
(3,23): error CS1513: Očekával se znak }.
```

All cases above work in VS 2017.

(Sorry for non-English exceptions which is probably unrelated regression in VS2019.)</Description>
        <CreatedDate>07/02/2019</CreatedDate>
        <ClosedDate>15/02/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder.ValueChecks.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Operators.cs</File>
      <File>src/Compilers/CSharp/Portable/CSharpResources.Designer.cs</File>
      <File>src/Compilers/CSharp/Portable/CodeGen/EmitExpression.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/ErrorCode.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/NullableWalker.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_ConditionalAccess.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/LanguageParser.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/LanguageParser_Patterns.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/PatternParsingTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>33262</IssueID>
    <Title>Ensure that MSBuildWorkspace deals with duplicate ProjectReferences</Title>
    <Description>The workspace isn't supposed to allow duplicate ProjectReferences, but currently due to #12101 it does. This dedups (correctly) at the surface and also adds a test to ensure this isn't broken.

Fixes #31390. Further work will address #12101, but no matter how we address that it's good to have tests at the MSBuildWorkspace layer to make sure some additional bugs don't creep in there in it's processing.

Special thanks to @alexbuyn for #32557 that helped alert to the root cause here, and @aolszowka for also chiming in with a bit of details about their scenario to confirm this should help fix it.

&lt;details&gt;&lt;summary&gt;Ask Mode template&lt;/summary&gt;

### Customer scenario

Customer uses a tool built atop MSBuildWorkspace, and they have a project with duplicate ProjectReferences where the exact same project is being referenced twice in the exact same way. This tool will probably crash when ran on this solution.

### Bugs this fixes

#31390

### Workarounds, if any

Fix the duplicate project reference. Unfortunately the crash is deep within the CompilationTracker, which won't really hint to the user that anything is wrong.

### Risk

Very low, the actual core fix is just replacing an ImmutableArray with an ImmutableHashSet. This API is not used in Visual Studio and thus does not pose a risk there.

### Performance impact

None.

### Is this a regression from a previous update?

Not clear. The underlying Workspace bug is positively ancient.

### Root cause analysis

We didn't have any tests, and it wasn't obvious the underlying Workspace bug would actual result in crashes.

### How was the bug found?

Customer reports.

&lt;/details&gt;</Description>
    <CreatedDate>08/02/2019</CreatedDate>
    <ClosedDate>15/02/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>12101</IssueID>
        <Title>Project.WithProjectReferences and friends allows you to give duplicate references</Title>
        <Description>We guard against duplicate references being created in Project.AddProjectReferences and similar APIs, but no similar guarding is done if you call WithProjectReferences. It seems the checks should be added there instead.
</Description>
        <CreatedDate>20/06/2016</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>31390</IssueID>
        <Title>System.ArgumentException in SolutionState.CompilationTracker.cs</Title>
        <Description>**Version Used**: Latest roslyn master sources

**Steps to Reproduce**:

1. Sync to latest roslyn master, assuming repo root here is `C:\roslyn`.
2. Build Roslyn.sln in Debug configuration
3. Build [AnalyzerRunner.csproj](https://github.com/dotnet/roslyn/blob/master/src/Tools/AnalyzerRunner/AnalyzerRunner.csproj)
4. Execute all IDE analyzers on Roslyn.sln using the following command from an admin command prompt: `C:\roslyn\Binaries\Debug\Exes\AnalyzerRunner\AnalyzerRunner.exe C:\roslyn\Binaries\Debug\Exes\AnalyzerRunner c:\roslyn\Roslyn.sln /concurrent`

**Expected Behavior**:
No exceptions

**Actual Behavior**:
`System.ArgumentException: An item with the same key has already been added.`
Also note that you might see assert from https://github.com/dotnet/roslyn/issues/31388

`.Add` invocation below seems to be throwing [here](http://source.roslyn.io/#Microsoft.CodeAnalysis.Workspaces/Workspace/Solution/SolutionState.CompilationTracker.cs,638) when processing `src\NuGet\VisualStudio\VS.ExternalAPIs.Roslyn.Package.csproj`:
```
                                var metadataReference = await solution.GetMetadataReferenceAsync(
                                    projectReference, this.ProjectState, cancellationToken).ConfigureAwait(false);
 
                                // A reference can fail to be created if a skeleton assembly could not be constructed.
                                if (metadataReference != null)
                                {
                                    newReferences.Add(metadataReference);
                                    metadataReferenceToProjectId.Add(metadataReference, projectReference.ProjectId);
                                }
                                else
                                {
                                    hasSuccessfullyLoaded = false;
                                }
```

**Call stack:**
```
Failed to analyze VS.ExternalAPIs.Roslyn.Package with System.ArgumentException: An item with the same key has already been added.
   at System.ThrowHelper.ThrowArgumentException(ExceptionResource resource)
   at System.Collections.Generic.Dictionary`2.Insert(TKey key, TValue value, Boolean add)
   at Microsoft.CodeAnalysis.SolutionState.CompilationTracker.&lt;FinalizeCompilationAsync&gt;d__30.MoveNext() in C:\roslyn_2\src\Workspaces\Core\Portable\Workspace\Solution\SolutionState.CompilationTracker.cs:line 638
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult()
   at Microsoft.CodeAnalysis.SolutionState.CompilationTracker.&lt;BuildCompilationInfoFromScratchAsync&gt;d__24.MoveNext() in C:\roslyn_2\src\Workspaces\Core\Portable\Workspace\Solution\SolutionState.CompilationTracker.cs:line 478
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult()
   at Microsoft.CodeAnalysis.SolutionState.CompilationTracker.&lt;GetOrBuildCompilationInfoAsync&gt;d__22.MoveNext() in C:\roslyn_2\src\Workspaces\Core\Portable\Workspace\Solution\SolutionState.CompilationTracker.cs:line 407
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult()
   at Microsoft.CodeAnalysis.SolutionState.CompilationTracker.&lt;GetCompilationSlowAsync&gt;d__19.MoveNext() in C:\roslyn_2\src\Workspaces\Core\Portable\Workspace\Solution\SolutionState.CompilationTracker.cs:line 316
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult()
   at AnalyzerRunner.Program.&lt;GetProjectAnalysisResultAsync&gt;d__10.MoveNext() in C:\roslyn_2\src\Tools\AnalyzerRunner\Program.cs:line 437
```</Description>
        <CreatedDate>27/11/2018</CreatedDate>
        <ClosedDate>15/02/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>12101</IssueID>
        <Title>Project.WithProjectReferences and friends allows you to give duplicate references</Title>
        <Description>We guard against duplicate references being created in Project.AddProjectReferences and similar APIs, but no similar guarding is done if you call WithProjectReferences. It seems the checks should be added there instead.
</Description>
        <CreatedDate>20/06/2016</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>32557</IssueID>
        <Title>fix of the issue #24991</Title>
        <Description>Issue #24991 fix.
Avoid duplicates being added to the reference dictionary in SolutionState.CompilationTracker.cs

I'd like to discuss if proposed solution is acceptable. 
The other option is to throw exception with the meaningful error. In this case I think the code can continue to work without trouble, so its not neccessary to throw here. I may be wrong.

Also, the class is private and I can't really add unit tests to it easily. Any suggestions here will be appreciated.

tagging @DustinCampbell here as the one who was involved in the discussion of the issue.</Description>
        <CreatedDate>17/01/2019</CreatedDate>
        <ClosedDate>11/02/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>31390</IssueID>
        <Title>System.ArgumentException in SolutionState.CompilationTracker.cs</Title>
        <Description>**Version Used**: Latest roslyn master sources

**Steps to Reproduce**:

1. Sync to latest roslyn master, assuming repo root here is `C:\roslyn`.
2. Build Roslyn.sln in Debug configuration
3. Build [AnalyzerRunner.csproj](https://github.com/dotnet/roslyn/blob/master/src/Tools/AnalyzerRunner/AnalyzerRunner.csproj)
4. Execute all IDE analyzers on Roslyn.sln using the following command from an admin command prompt: `C:\roslyn\Binaries\Debug\Exes\AnalyzerRunner\AnalyzerRunner.exe C:\roslyn\Binaries\Debug\Exes\AnalyzerRunner c:\roslyn\Roslyn.sln /concurrent`

**Expected Behavior**:
No exceptions

**Actual Behavior**:
`System.ArgumentException: An item with the same key has already been added.`
Also note that you might see assert from https://github.com/dotnet/roslyn/issues/31388

`.Add` invocation below seems to be throwing [here](http://source.roslyn.io/#Microsoft.CodeAnalysis.Workspaces/Workspace/Solution/SolutionState.CompilationTracker.cs,638) when processing `src\NuGet\VisualStudio\VS.ExternalAPIs.Roslyn.Package.csproj`:
```
                                var metadataReference = await solution.GetMetadataReferenceAsync(
                                    projectReference, this.ProjectState, cancellationToken).ConfigureAwait(false);
 
                                // A reference can fail to be created if a skeleton assembly could not be constructed.
                                if (metadataReference != null)
                                {
                                    newReferences.Add(metadataReference);
                                    metadataReferenceToProjectId.Add(metadataReference, projectReference.ProjectId);
                                }
                                else
                                {
                                    hasSuccessfullyLoaded = false;
                                }
```

**Call stack:**
```
Failed to analyze VS.ExternalAPIs.Roslyn.Package with System.ArgumentException: An item with the same key has already been added.
   at System.ThrowHelper.ThrowArgumentException(ExceptionResource resource)
   at System.Collections.Generic.Dictionary`2.Insert(TKey key, TValue value, Boolean add)
   at Microsoft.CodeAnalysis.SolutionState.CompilationTracker.&lt;FinalizeCompilationAsync&gt;d__30.MoveNext() in C:\roslyn_2\src\Workspaces\Core\Portable\Workspace\Solution\SolutionState.CompilationTracker.cs:line 638
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult()
   at Microsoft.CodeAnalysis.SolutionState.CompilationTracker.&lt;BuildCompilationInfoFromScratchAsync&gt;d__24.MoveNext() in C:\roslyn_2\src\Workspaces\Core\Portable\Workspace\Solution\SolutionState.CompilationTracker.cs:line 478
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult()
   at Microsoft.CodeAnalysis.SolutionState.CompilationTracker.&lt;GetOrBuildCompilationInfoAsync&gt;d__22.MoveNext() in C:\roslyn_2\src\Workspaces\Core\Portable\Workspace\Solution\SolutionState.CompilationTracker.cs:line 407
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult()
   at Microsoft.CodeAnalysis.SolutionState.CompilationTracker.&lt;GetCompilationSlowAsync&gt;d__19.MoveNext() in C:\roslyn_2\src\Workspaces\Core\Portable\Workspace\Solution\SolutionState.CompilationTracker.cs:line 316
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult()
   at AnalyzerRunner.Program.&lt;GetProjectAnalysisResultAsync&gt;d__10.MoveNext() in C:\roslyn_2\src\Tools\AnalyzerRunner\Program.cs:line 437
```</Description>
        <CreatedDate>27/11/2018</CreatedDate>
        <ClosedDate>15/02/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Workspaces/Core/MSBuild/MSBuild/MSBuildProjectLoader.Worker_ResolveReferences.cs</File>
      <File>src/Workspaces/CoreTest/SolutionTests/SolutionTests.cs</File>
      <File>src/Workspaces/CoreTest/WorkspaceTests/AdhocWorkspaceTests.cs</File>
      <File>src/Workspaces/CoreTest/WorkspaceTests/GeneralWorkspaceTests.cs</File>
      <File>src/Workspaces/DesktopTest/CommandLineProjectWorkspaceTests.cs</File>
      <File>src/Workspaces/MSBuildTest/FileSet.cs</File>
      <File>src/Workspaces/MSBuildTest/MSBuildWorkspaceTests.cs</File>
      <File>src/Workspaces/MSBuildTest/Resources/Issue30174/InspectedLibrary/InspectedClass.cs</File>
      <File>src/Workspaces/MSBuildTest/Resources/Issue30174/ReferencedLibrary/SomeMetadataAttribute.cs</File>
      <File>src/Workspaces/MSBuildTest/Resources/NetCoreApp2/Program.cs</File>
      <File>src/Workspaces/MSBuildTest/Resources/NetCoreApp2AndLibrary/Class1.cs</File>
      <File>src/Workspaces/MSBuildTest/Resources/NetCoreApp2AndLibrary/Program.cs</File>
      <File>src/Workspaces/MSBuildTest/Resources/NetCoreApp2AndTwoLibraries/Class1.cs</File>
      <File>src/Workspaces/MSBuildTest/Resources/NetCoreApp2AndTwoLibraries/Class2.cs</File>
      <File>src/Workspaces/MSBuildTest/Resources/NetCoreApp2AndTwoLibraries/Program.cs</File>
      <File>src/Workspaces/MSBuildTest/Resources/NetCoreMultiTFM/Program.cs</File>
      <File>src/Workspaces/MSBuildTest/Resources/NetCoreMultiTFM_ProjectReference/Class1.cs</File>
      <File>src/Workspaces/MSBuildTest/Resources/NetCoreMultiTFM_ProjectReference/Program.cs</File>
      <File>src/Workspaces/MSBuildTest/Resources/NetCoreMultiTFM_ProjectReferenceToFSharp/csharplib/Class1.cs</File>
      <File>src/Workspaces/MSBuildTest/Resources/NetCoreMultiTFM_ProjectReferenceWithReversedTFMs/Class1.cs</File>
      <File>src/Workspaces/MSBuildTest/Resources/NetCoreMultiTFM_ProjectReferenceWithReversedTFMs/Program.cs</File>
      <File>src/Workspaces/MSBuildTest/Resources/SourceFiles/CSharp/App.xaml.cs</File>
      <File>src/Workspaces/MSBuildTest/Resources/SourceFiles/CSharp/AssemblyInfo.cs</File>
      <File>src/Workspaces/MSBuildTest/Resources/SourceFiles/CSharp/CSharpClass.cs</File>
      <File>src/Workspaces/MSBuildTest/Resources/SourceFiles/CSharp/CSharpClass_WithConditionalAttributes.cs</File>
      <File>src/Workspaces/MSBuildTest/Resources/SourceFiles/CSharp/CSharpConsole.cs</File>
      <File>src/Workspaces/MSBuildTest/Resources/SourceFiles/CSharp/CSharpExternAlias.cs</File>
      <File>src/Workspaces/MSBuildTest/Resources/SourceFiles/CSharp/MainWindow.xaml.cs</File>
      <File>src/Workspaces/MSBuildTest/Resources/SourceFiles/CSharp/OtherStuff_Foo.cs</File>
      <File>src/Workspaces/MSBuildTest/TestFiles/Resources.cs</File>
      <File>src/Workspaces/MSBuildTest/WorkspaceTestBase.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>33221</IssueID>
    <Title>Call ProjectCodeModel.OnSourceFileRemoved when we remove files </Title>
    <Description>**REVIEW NOTE:** commit-at-a-time is highly recommended here.

In the project system refactoring to support free-threaded initialization, I lost this call which was causing removing and readding files to do bad things. This fixes it. The fix is more complicated than just adding the call back in, because we now allow document removal to happen on a background thread which we didn't allow before, and so bit of work that must happen on the UI thread must now be deferred until a later cleanup point.

Fixes #33080.

&lt;details&gt;&lt;summary&gt;Ask Mode template&lt;/summary&gt;

### Customer scenario

Customer deletes a Windows Form from a project, and then adds a new one with the same name. Rather than opening the designer again, the designer fails to load.

### Bugs this fixes

#33080

### Workarounds, if any

After you get into this state, restart Visual Studio.

### Risk

Moderate; the area we're touching (CodeModel object lifetimes) is always tricky, but since it's an API that many features are built on a lot of not obvious things might be broken.

### Performance impact

None.

### Is this a regression from a previous update?

Yes, this was broken in our big project system refactoring to improve performance in Preview 1.

### Root cause analysis

We didn't have any tests that tested CodeModel object life times. We've added functional tests to test that.

### How was the bug found?

Customer report.

&lt;/details&gt;</Description>
    <CreatedDate>07/02/2019</CreatedDate>
    <ClosedDate>15/02/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>33080</IssueID>
        <Title>Error opening form designer of deleted and re-created form in VS 2019 Preview 2.1</Title>
        <Description>**Version Used**: Visual Studio 2019 Preview 2.1

**Steps to Reproduce**:

1. Create Windows Form VB.NET (or C#) project. Form1.vb file is created and its designer window is opened correctly
2. Delete Form1.vb in Solution Explorer
3. Right-click the project and select Add &gt; Windows Form... menu
4. Type Form1.vb as the name (same name than deleted form)

**Expected Behavior**:
The designer window of Form1.vb should be opened without errors, like the time when it was created by default.

**Actual Behavior**:
The designer window shows the error "Error HRESULT E_FAIL has been returned from a call to a COM component.". See attached image. The call stack of that error shows:

at System.Runtime.InteropServices.Marshal.ThrowExceptionForHRInternal(Int32 errorCode, IntPtr errorInfo) at Microsoft.VisualStudio.LanguageServices.Implementation.Utilities.Exceptions.ThrowEFail() at Microsoft.VisualStudio.LanguageServices.Implementation.CodeModel.FileCodeModel.GetDocument() at Microsoft.VisualStudio.LanguageServices.Implementation.CodeModel.FileCodeModel.GetSyntaxRoot() at Microsoft.VisualStudio.LanguageServices.Implementation.CodeModel.Collections.NamespaceCollection.LookupNode() at Microsoft.VisualStudio.LanguageServices.Implementation.CodeModel.Collections.NamespaceCollection.CreateSnapshot() at Microsoft.VisualStudio.LanguageServices.Implementation.CodeModel.Collections.AbstractCodeElementCollection.GetEnumerator() at EnvDTE.CodeElements.GetEnumerator() at Microsoft.VisualStudio.Design.Serialization.CodeDom.VSCodeDomParser.Parse(TextReader codeStream) at Microsoft.VisualStudio.Design.Serialization.CodeDom.MergedCodeDomParser.System.CodeDom.Compiler.ICodeParser.Parse(TextReader stream) at System.CodeDom.Compiler.CodeDomProvider.Parse(TextReader codeStream) at Microsoft.VisualStudio.Shell.Design.Serialization.CodeDom.CodeDomDocDataAdapter.get_CompileUnit() at Microsoft.VisualStudio.Design.Serialization.CodeDom.VSCodeDomDesignerLoader.PerformLoad(IDesignerSerializationManager serializationManager) at Microsoft.VisualStudio.Design.Serialization.CodeDom.VSCodeDomDesignerLoader.DeferredLoadHandler.Microsoft.VisualStudio.TextManager.Interop.IVsTextBufferDataEvents.OnLoadCompleted(Int32 fReload)

![error](https://user-images.githubusercontent.com/10756684/52179124-99e64380-27d6-11e9-90b4-9c6fb5aea358.png)
</Description>
        <CreatedDate>03/02/2019</CreatedDate>
        <ClosedDate>15/02/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>33080</IssueID>
        <Title>Error opening form designer of deleted and re-created form in VS 2019 Preview 2.1</Title>
        <Description>**Version Used**: Visual Studio 2019 Preview 2.1

**Steps to Reproduce**:

1. Create Windows Form VB.NET (or C#) project. Form1.vb file is created and its designer window is opened correctly
2. Delete Form1.vb in Solution Explorer
3. Right-click the project and select Add &gt; Windows Form... menu
4. Type Form1.vb as the name (same name than deleted form)

**Expected Behavior**:
The designer window of Form1.vb should be opened without errors, like the time when it was created by default.

**Actual Behavior**:
The designer window shows the error "Error HRESULT E_FAIL has been returned from a call to a COM component.". See attached image. The call stack of that error shows:

at System.Runtime.InteropServices.Marshal.ThrowExceptionForHRInternal(Int32 errorCode, IntPtr errorInfo) at Microsoft.VisualStudio.LanguageServices.Implementation.Utilities.Exceptions.ThrowEFail() at Microsoft.VisualStudio.LanguageServices.Implementation.CodeModel.FileCodeModel.GetDocument() at Microsoft.VisualStudio.LanguageServices.Implementation.CodeModel.FileCodeModel.GetSyntaxRoot() at Microsoft.VisualStudio.LanguageServices.Implementation.CodeModel.Collections.NamespaceCollection.LookupNode() at Microsoft.VisualStudio.LanguageServices.Implementation.CodeModel.Collections.NamespaceCollection.CreateSnapshot() at Microsoft.VisualStudio.LanguageServices.Implementation.CodeModel.Collections.AbstractCodeElementCollection.GetEnumerator() at EnvDTE.CodeElements.GetEnumerator() at Microsoft.VisualStudio.Design.Serialization.CodeDom.VSCodeDomParser.Parse(TextReader codeStream) at Microsoft.VisualStudio.Design.Serialization.CodeDom.MergedCodeDomParser.System.CodeDom.Compiler.ICodeParser.Parse(TextReader stream) at System.CodeDom.Compiler.CodeDomProvider.Parse(TextReader codeStream) at Microsoft.VisualStudio.Shell.Design.Serialization.CodeDom.CodeDomDocDataAdapter.get_CompileUnit() at Microsoft.VisualStudio.Design.Serialization.CodeDom.VSCodeDomDesignerLoader.PerformLoad(IDesignerSerializationManager serializationManager) at Microsoft.VisualStudio.Design.Serialization.CodeDom.VSCodeDomDesignerLoader.DeferredLoadHandler.Microsoft.VisualStudio.TextManager.Interop.IVsTextBufferDataEvents.OnLoadCompleted(Int32 fReload)

![error](https://user-images.githubusercontent.com/10756684/52179124-99e64380-27d6-11e9-90b4-9c6fb5aea358.png)
</Description>
        <CreatedDate>03/02/2019</CreatedDate>
        <ClosedDate>15/02/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/VisualStudio/Core/Def/Implementation/CodeModel/IProjectCodeModel.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/CodeModel/IProjectCodeModelFactory.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/InvisibleEditor.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/Legacy/AbstractLegacyProject.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/VisualStudioWorkspaceImpl.cs</File>
      <File>src/VisualStudio/Core/Impl/CodeModel/AbstractCodeModelObject.cs</File>
      <File>src/VisualStudio/Core/Impl/CodeModel/CodeModelProjectCache.cs</File>
      <File>src/VisualStudio/Core/Impl/CodeModel/FileCodeModel.cs</File>
      <File>src/VisualStudio/Core/Impl/CodeModel/ProjectCodeModel.cs</File>
      <File>src/VisualStudio/Core/Impl/CodeModel/ProjectCodeModelFactory.cs</File>
      <File>src/VisualStudio/Core/Impl/ProjectSystem/CPS/CPSProject_IWorkspaceProjectContext.cs</File>
      <File>src/VisualStudio/Core/Impl/RoslynVisualStudioWorkspace.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>33183</IssueID>
    <Title>Resolve Metadata As Source symbols in their original compilations</Title>
    <Description>Fixes a bug reported through email by @veleek 

The document in which disassembled code is added is part of a temporary project used specifically for Metadata as Source operations. The target symbol for navigation is derived from a different context, so the corresponding assembly symbol will not be an equality match. ~~We instead look up the metadata reference in the compilation using the metadata name, which accounts for the symbol mismatch and also allows for assembly version differences.~~

We now use the original compilation matching the `ISymbol` used for navigation to ensure the metadata reference can be correctly resolved.

Fixes #23478
Fixes #6859
</Description>
    <CreatedDate>06/02/2019</CreatedDate>
    <ClosedDate>14/02/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>23478</IssueID>
        <Title>Should MetadataAsSourceFileService be calling MetadataAsSourceHelpers.GetAssemblyDisplay?</Title>
        <Description>From @jasonmalinowski in https://github.com/dotnet/roslyn/pull/23430#discussion_r153933417:

&gt; Should this be calling `MetadataAsSourceHelpers.GetAssemblyDisplay`? Or unify that somehow with the other code? There's an interesting comment in `MetadataAsSourceHelpers` pointing to #6859 asking why it's not just calling GetMetadataReference. I worry that either if there is some subtle reason the shenanigans in the helpers is necessary, then you'll want that same thing here. (And if it's unnecessary, congrats, you've confirmed you can delete some code.)</Description>
        <CreatedDate>30/11/2017</CreatedDate>
        <ClosedDate>14/02/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>6859</IssueID>
        <Title>Should MetadataAsSourceHelpers.GetAssemblyDisplay use Compilation.GetMetadataReference?</Title>
        <Description>Old

``` C#
var assemblyReference = compilation.References.Where(r =&gt;
{
    var referencedSymbol = compilation.GetAssemblyOrModuleSymbol(r) as IAssemblySymbol;
    return
        referencedSymbol != null &amp;&amp;
        referencedSymbol.MetadataName == assemblySymbol.MetadataName;
})
.FirstOrDefault();
```

New

``` C#
var assemblyReference = compilation.GetMetadataReference(assemblySymbol);
```

It seems possible that the old code is attempting to do some sort of fuzzy matching.
</Description>
        <CreatedDate>18/11/2015</CreatedDate>
        <ClosedDate>14/02/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharp/DecompiledSource/CSharpDecompiledSourceService.cs</File>
      <File>src/EditorFeatures/Core/IDecompiledSourceService.cs</File>
      <File>src/EditorFeatures/Core/Implementation/MetadataAsSource/MetadataAsSourceFileService.cs</File>
      <File>src/Features/CSharp/Portable/MetadataAsSource/CSharpMetadataAsSourceService.cs</File>
      <File>src/Features/Core/Portable/MetadataAsSource/AbstractMetadataAsSourceService.cs</File>
      <File>src/Features/Core/Portable/MetadataAsSource/IMetadataAsSourceService.cs</File>
      <File>src/Features/Core/Portable/MetadataAsSource/MetadataAsSourceHelpers.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>32755</IssueID>
    <Title>Fix compiler crash and remove spurious hidden sequence points for switch expression</Title>
    <Description>Fixes #32370

Fix parsing error recovery for incomplete switch expression
Fixes #32749 

See also https://devdiv.visualstudio.com/DevDiv/_workitems/edit/792979 for shiproom purposes.

@dotnet/roslyn-compiler May I please have a couple of reviews?</Description>
    <CreatedDate>24/01/2019</CreatedDate>
    <ClosedDate>15/02/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>32370</IssueID>
        <Title>Stepping through switch expression is wrong</Title>
        <Description>The whole statement with the switch expression never gets highlighted as I step forward.

![switch-stepping](https://user-images.githubusercontent.com/12466233/51006761-8c041200-14f9-11e9-8738-029e04f8ec81.gif)

When fixing this, please also verify that LUT (live unittesting) instrumentation works.</Description>
        <CreatedDate>11/01/2019</CreatedDate>
        <ClosedDate>15/02/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>32749</IssueID>
        <Title>Compiler crash on incomplete switch expression</Title>
        <Description>Parsing the following expression causes the parser (or compiler) to crash with an out-of-memory exception

``` c#
(e switch {)
```
</Description>
        <CreatedDate>24/01/2019</CreatedDate>
        <ClosedDate>15/02/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_BasePatternSwitchLocalRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/LanguageParser_Patterns.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/PatternTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Emit/DynamicAnalysis/DynamicInstrumentationTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/PatternParsingTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>32704</IssueID>
    <Title>Features/unmanaged constructed types</Title>
    <Description>Related to dotnet/csharplang#1744 and #31374 

This merges the unmanaged constructed types feature into `dev16.1-preview1`. @jaredpar approval is required. All of this code has been previously reviewed before being merged into the `dotnet/features/unmanaged-constructed-types` branch.

It's worth noting that this implementation allows taking a pointer to a generic ref struct, because taking a pointer to a non-generic ref struct is already allowed. @agocke @gafter so you're aware as this came up in the test plan review.</Description>
    <CreatedDate>23/01/2019</CreatedDate>
    <ClosedDate>23/01/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>1744</IssueID>
        <Title>Incomplete catch block in lambda doesn't show Add Using quick fix</Title>
        <Description>Source:

``` C#
class A {
    System.Action a = () =&gt; {
        try {
        }
        catch (Exception
    };
}
```

The Add Using/Qualify Name quick fix will not appear until after adding `) {`.
</Description>
        <CreatedDate>01/04/2015</CreatedDate>
        <ClosedDate>28/04/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>31374</IssueID>
        <Title>Test plan for "unmanaged generic structs"</Title>
        <Description>Proposal: https://github.com/dotnet/csharplang/issues/1744

This issue is a place to collect test ideas and track their validation. Use the [compiler test plan](https://github.com/dotnet/roslyn/blob/master/docs/contributing/Compiler%20Test%20Plan.md) as a tool for brainstorming.

- [x] validate with LangVersion 7.3
- [x] test with tuple type ([SO](https://stackoverflow.com/questions/53992855/how-do-a-struct-containing-valuetuple-can-satisfy-unmanaged-constraint-but-valu) thread) #32103 
- [x] write speclet (contained under Design section of proposal)
- ~~[ ] update compiler test plan~~ (doesn't appear to be anything to add)
- [x] test public API `IsUnmanagedType` in new scenarios
- [x] Test for ref structs
- [x] Test the IsManagedType API as suggested by Julien
- [x] Test moveability (existing rules should be sufficient)
- [x] Have at least one test spit some IL to look at and have a few tests run with "expected output" to make sure the CLR can handle the code.
- [x] Stackalloc array of items
- [x] (Mutually) Recursive struct definition
  - [x] Also check the IsUnmanagedType API for these
- [x] Fixed-size buffer inside generic struct
- [x] Also check across metadata (metadata struct definition has private object or unmanaged field)
  - [x] Also private `T` field
- [x] For all places unmanaged type is required, we should have a test that covers that code path and ensures that the required feature diagnostic is produced at language version &lt; 8.0
  - [x] addressOf `&amp;`
  - [x] `fixed` with address of field
  - [x] `fixed` with array of generic structs
  - [x] `sizeof`
  - [x] `stackalloc` with size
  - [x] implicit `stackalloc` with initializer
  - [x] field of type pointer to unmanaged generic struct
  - [x] unmanaged constraint</Description>
        <CreatedDate>26/11/2018</CreatedDate>
        <ClosedDate>30/01/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Expressions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Operators.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Statements.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Symbols.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Imports.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/OverloadResolution/OverloadResolution.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/OverloadResolution/OverloadResolutionResult.cs</File>
      <File>src/Compilers/CSharp/Portable/CSharpResources.Designer.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/MessageID.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/AliasSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ArrayTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/BaseTypeAnalysis.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ConstraintsHelper.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/DynamicTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/NamedTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/PointerTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceCustomEventSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceEventSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceMemberContainerSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceMemberFieldSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceNamedTypeSymbol_Bases.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceOrdinaryMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourcePropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceTypeParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceUserDefinedOperatorSymbolBase.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedEmbeddedAttributeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Tuples/TupleTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/TypeParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/TypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/TypeSymbolWithAnnotations.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Wrapped/WrappedFieldSymbol.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/GenericConstraintsTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/SemanticErrorTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/UnsafeTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/MockNamedTypeSymbol.cs</File>
      <File>src/Compilers/Core/Portable/Symbols/ManagedKind.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Test/ExpressionCompiler/ManagedAddressOfTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>32675</IssueID>
    <Title>Add bail out cases for unused members analyzer</Title>
    <Description>1. Usages as an argument to `nameof`: We have multiple reports of these being false positives in presence of reflection based usages and in variour test frameworks. Fixes #32488.
2. Presence of 'dynamic' in C# - Conservatively bail out in presence of any dynamic operations. Fixes #32522.</Description>
    <CreatedDate>22/01/2019</CreatedDate>
    <ClosedDate>22/01/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>32488</IssueID>
        <Title>False positive for IDE0051</Title>
        <Description>C# Code:

```csharp
using System;
using System.Reflection;

namespace Test
{
    class TestClass
    {
        private static readonly MethodInfo TesteMethod =
            typeof(TestClass).GetTypeInfo().GetMethod(nameof(Test), BindingFlags.Static | BindingFlags.NonPublic);

        private static DateTime Test()
        {
            return DateTime.Now;
        }
    }
}
```

_This issue has been moved from https://developercommunity.visualstudio.com/content/problem/419930/false-positive-for-ide0051.html
VSTS ticketId: 760860_
_These are the original issue comments:_
(no comments)
_These are the original issue solutions:_
(no solutions)</Description>
        <CreatedDate>15/01/2019</CreatedDate>
        <ClosedDate>22/01/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>32522</IssueID>
        <Title>'Remove unused member' quick fix removes used members with dynamic parameter</Title>
        <Description>**Version Used**: VisualStudio.16.Preview/16.0.0-pre.1.1+28408.50

**Steps to Reproduce**:
```C#
static void Main()
{
    dynamic d = null;
    Test(d);
}

static void Test(dynamic d) { }
```

**Expected Behavior**: The `Test` method to be treated as used by the code.

**Actual Behavior**: The 'Remove unused member' quick fix appears, suggesting to remove the `Test` method. That results in a compile error that `Test` does not exist.
</Description>
        <CreatedDate>16/01/2019</CreatedDate>
        <ClosedDate>22/01/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/RemoveUnusedMembers/RemoveUnusedMembersTests.cs</File>
      <File>src/Features/Core/Portable/RemoveUnusedMembers/AbstractRemoveUnusedMembersDiagnosticAnalyzer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>32649</IssueID>
    <Title>Fix metadata references not always having file watchers</Title>
    <Description>When we created metadata references inside of VisualStudioProject, we ensured we created them with a file watcher so we would know about changes. When we created a metadata reference after we converted a project reference back to a metadata reference that was originally a metadata reference, we didn't do so since that conversion happens in VisualStudioWorkspaceImpl itself and it couldn't access the file watcher.

This fixes this. The majority of the work here is just moving code around. Basically the watchers were per-project, which meant that it'd be forbidden to call into them the Workspace code because that would violate the lock hierarchy. To fix this, I move the file watching logic into it's own little type with a lock, and since no calls are made back into the workspace under that lock, it removes the deadlock concerns.

Fixes #32554.

&lt;details&gt;&lt;summary&gt;Ask Mode template&lt;/summary&gt;

### Customer scenario

Customer has a project with lots of P2P references and loads/unloads projects in various orders. In some cases, this will cause VS to crash or at least the project system to get in a missynced state.

### Bugs this fixes

dotnet/roslyn#32554 and https://devdiv.visualstudio.com/DevDiv/_workitems/edit/750094

### Workarounds, if any

None, really. If you don't unload projects you won't hit it, but creating some types of projects implicitly do the problematic operations in their template wizard.

### Risk

Moderate: it's a fair amount of code churn, but the churn is fairly straightforward.

### Performance impact

None.

### Is this a regression from a previous update?

Yes, this was broken by a late Preview 1 fix that missed an edge case.

### Root cause analysis

This edge case noticed in testing of a fix we made for Preview 1, but the full impact wasn't realized, and at the time a bug was filed to follow up on it. This is fixing the issue. Tests have been added to cover this scenario too.

### How was the bug found?

Noticed during testing of another fix, and also internal testing with certain templates that also trigger the bug.

&lt;/details&gt;</Description>
    <CreatedDate>19/01/2019</CreatedDate>
    <ClosedDate>25/01/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>32554</IssueID>
        <Title>IntelliSense errors for dependency references in newly created Service Fabric project</Title>
        <Description>Regression in 16.0.

1. Launch the new project dialog
2. Create a Service Fabric Application project
3. Select the .NET Core Actor Service template from the New Service Fabric Service dialog
4. Wait for the solution to load and dependencies to restore
5. Check the Error List window and ensure the filter is set to show IntelliSense errors

Expected:
No IntelliSense errors should be reported (dependencies are restored and all references are resolvable).

Actual:
All references to dependencies (NuGet, SDK, or Project references) in the primary service project (Actor1 by default) are flagged as IntelliSense errors.

The errors are only reported for the newly created project and don't reappear after closing and re-opening the solution or unloading and reloading the specific project the errors are associated with. A full build succeeds without any errors or warnings, but doesn't clear the IntelliSense errors.</Description>
        <CreatedDate>09/01/2019</CreatedDate>
        <ClosedDate>25/01/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>32554</IssueID>
        <Title>IntelliSense errors for dependency references in newly created Service Fabric project</Title>
        <Description>Regression in 16.0.

1. Launch the new project dialog
2. Create a Service Fabric Application project
3. Select the .NET Core Actor Service template from the New Service Fabric Service dialog
4. Wait for the solution to load and dependencies to restore
5. Check the Error List window and ensure the filter is set to show IntelliSense errors

Expected:
No IntelliSense errors should be reported (dependencies are restored and all references are resolvable).

Actual:
All references to dependencies (NuGet, SDK, or Project references) in the primary service project (Actor1 by default) are flagged as IntelliSense errors.

The errors are only reported for the newly created project and don't reappear after closing and re-opening the solution or unloading and reloading the specific project the errors are associated with. A full build succeeds without any errors or warnings, but doesn't clear the IntelliSense errors.</Description>
        <CreatedDate>09/01/2019</CreatedDate>
        <ClosedDate>25/01/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/FileChangeWatcherProvider.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/MetadataReferences/FileWatchedPortableExecutableReferenceFactory.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/MetadataReferences/VisualStudioMetadataReference.Snapshot.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/MetadataReferences/VisualStudioMetadataReferenceManager.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/MetadataReferences/VisualStudioMetadataReferenceProviderServiceFactory.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/MetadataReferences/VisualStudioPortableExecutableReference.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/MiscellaneousFilesWorkspace.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/VisualStudioProject.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/VisualStudioWorkspaceImpl.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>32630</IssueID>
    <Title>Enable skipped tests that previously failed on AssertIsForeground</Title>
    <Description>Of the three stack traces included or linked to from #20953 two were being skipped and one had never been marked as skipped.
PeekTests.TestPeekAcrossProjectsInvolvingPortableReferences - Not Skipped
LinkedFileDiffMergingEditorTests.TestCodeActionPreviewAndApply - Skipped
InteractivePasteCommandhandlerTests.PasteCommandWithOutInteractiveFormat - Skipped

I was unable to find any hits on the failures. I recommend removing the skip and seeing if we can collect more data from these tests.

Closes #20953</Description>
    <CreatedDate>18/01/2019</CreatedDate>
    <ClosedDate>04/02/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>20953</IssueID>
        <Title>Test failures in AssertIsForeground (RenameTracking and DiagnosticsTaggerProvider)</Title>
        <Description>https://ci.dot.net/job/dotnet_roslyn/view/Official%20Builds/job/master/job/windows_debug_unit32_prtest/8289/artifact/Binaries/Debug/UnitTests/EditorServicesTest2/xUnitResults/Roslyn.Services.Editor2.UnitTests.dll.out.log

```
 Microsoft.CodeAnalysis.Editor.UnitTests.Peek.PeekTests.TestPeekAcrossProjectsInvolvingPortableReferences
      System.AggregateException : 3 exception(s) were thrown during test.
      Note: exceptions may have been thrown by another test running concurrently with
      this test.  This can happen with any tests that share the same ExportProvider.
      Examining individual exception stacks may help reveal the original test and source 
      of the problem.
      
      Exception 0:
      Microsoft.CodeAnalysis.ThrowingTraceListener+DebugAssertFailureException: When created kind       : StaUnitTest
      When created thread id  : 11
      When created thread name: StaTaskScheduler thread
      Current thread id       : 6
      Current thread name     : 
      
         at Microsoft.CodeAnalysis.ThrowingTraceListener.Fail(String message, String detailMessage)
         at System.Diagnostics.TraceListener.Fail(String message)
         at System.Diagnostics.TraceInternal.Fail(String message)
         at System.Diagnostics.Debug.Assert(Boolean condition, String message)
         at Microsoft.CodeAnalysis.Editor.Shared.Utilities.ForegroundThreadAffinitizedObject.AssertIsForeground()
         at Microsoft.CodeAnalysis.Editor.Implementation.RenameTracking.RenameTrackingTaggerProvider.StateMachine.Connect()
         at Microsoft.CodeAnalysis.Editor.Implementation.RenameTracking.RenameTrackingTaggerProvider.Tagger..ctor(StateMachine stateMachine, ITextUndoHistoryRegistry undoHistoryRegistry, IWaitIndicator waitIndicator, IEnumerable`1 refactorNotifyServices)
         at Microsoft.CodeAnalysis.Editor.Implementation.RenameTracking.RenameTrackingTaggerProvider.CreateTagger[T](ITextBuffer buffer)
         at Microsoft.VisualStudio.Text.Tagging.Implementation.TagAggregator`1.GatherTaggers(ITextBuffer textBuffer)
      
      Exception 1:
      Microsoft.CodeAnalysis.ThrowingTraceListener+DebugAssertFailureException: When created kind       : StaUnitTest
      When created thread id  : 11
      When created thread name: StaTaskScheduler thread
      Current thread id       : 6
      Current thread name     : 
      
         at Microsoft.CodeAnalysis.ThrowingTraceListener.Fail(String message, String detailMessage)
         at System.Diagnostics.TraceListener.Fail(String message)
         at System.Diagnostics.TraceInternal.Fail(String message)
         at System.Diagnostics.Debug.Assert(Boolean condition, String message)
         at Microsoft.CodeAnalysis.Editor.Shared.Utilities.ForegroundThreadAffinitizedObject.AssertIsForeground()
         at Microsoft.CodeAnalysis.Editor.Implementation.Diagnostics.AbstractDiagnosticsTaggerProvider`1.AggregatingTagger.OnTaggerCreated()
         at Microsoft.CodeAnalysis.Editor.Implementation.Diagnostics.AbstractDiagnosticsTaggerProvider`1.CreateTagger[T](ITextBuffer buffer)
         at Microsoft.CodeAnalysis.Editor.Implementation.Diagnostics.AbstractDiagnosticsTaggerProvider`1.Microsoft.VisualStudio.Text.Tagging.ITaggerProvider.CreateTagger[T](ITextBuffer buffer)
         at Microsoft.VisualStudio.Text.Tagging.Implementation.TagAggregator`1.GatherTaggers(ITextBuffer textBuffer)
      
      Exception 2:
      Microsoft.CodeAnalysis.ThrowingTraceListener+DebugAssertFailureException: When created kind       : StaUnitTest
      When created thread id  : 11
      When created thread name: StaTaskScheduler thread
      Current thread id       : 6
      Current thread name     : 
      
         at Microsoft.CodeAnalysis.ThrowingTraceListener.Fail(String message, String detailMessage)
         at System.Diagnostics.TraceListener.Fail(String message)
         at System.Diagnostics.TraceInternal.Fail(String message)
         at System.Diagnostics.Debug.Assert(Boolean condition, String message)
         at Microsoft.CodeAnalysis.Editor.Shared.Utilities.ForegroundThreadAffinitizedObject.AssertIsForeground()
         at Microsoft.CodeAnalysis.Editor.Implementation.Diagnostics.AbstractDiagnosticsTaggerProvider`1.AggregatingTagger.OnTaggerCreated()
         at Microsoft.CodeAnalysis.Editor.Implementation.Diagnostics.AbstractDiagnosticsTaggerProvider`1.CreateTagger[T](ITextBuffer buffer)
         at Microsoft.CodeAnalysis.Editor.Implementation.Diagnostics.AbstractDiagnosticsTaggerProvider`1.Microsoft.VisualStudio.Text.Tagging.ITaggerProvider.CreateTagger[T](ITextBuffer buffer)
         at Microsoft.VisualStudio.Text.Tagging.Implementation.TagAggregator`1.GatherTaggers(ITextBuffer textBuffer)
      
      
      ---- Microsoft.CodeAnalysis.ThrowingTraceListener+DebugAssertFailureException : When created kind       : StaUnitTest
      When created thread id  : 11
      When created thread name: StaTaskScheduler thread
      Current thread id       : 6
      Current thread name     : 
      
      ---- Microsoft.CodeAnalysis.ThrowingTraceListener+DebugAssertFailureException : When created kind       : StaUnitTest
      When created thread id  : 11
      When created thread name: StaTaskScheduler thread
      Current thread id       : 6
      Current thread name     : 
      
      ---- Microsoft.CodeAnalysis.ThrowingTraceListener+DebugAssertFailureException : When created kind       : StaUnitTest
      When created thread id  : 11
      When created thread name: StaTaskScheduler thread
      Current thread id       : 6
      Current thread name     : 
      
      Stack Trace:
           at Microsoft.CodeAnalysis.Editor.UnitTests.Workspaces.TestWorkspace.Dispose(Boolean finalize)
           at Microsoft.CodeAnalysis.Workspace.Dispose()
        q:\roslyn\src\EditorFeatures\Test2\Peek\PeekTests.vb(181,0): at Microsoft.CodeAnalysis.Editor.UnitTests.Peek.PeekTests.TestPeekAcrossProjectsInvolvingPortableReferences()
        ----- Inner Stack Trace #1 (Microsoft.CodeAnalysis.ThrowingTraceListener+DebugAssertFailureException) -----
           at Microsoft.CodeAnalysis.ThrowingTraceListener.Fail(String message, String detailMessage)
           at System.Diagnostics.TraceListener.Fail(String message)
           at System.Diagnostics.TraceInternal.Fail(String message)
           at System.Diagnostics.Debug.Assert(Boolean condition, String message)
           at Microsoft.CodeAnalysis.Editor.Shared.Utilities.ForegroundThreadAffinitizedObject.AssertIsForeground()
           at Microsoft.CodeAnalysis.Editor.Implementation.RenameTracking.RenameTrackingTaggerProvider.StateMachine.Connect()
           at Microsoft.CodeAnalysis.Editor.Implementation.RenameTracking.RenameTrackingTaggerProvider.Tagger..ctor(StateMachine stateMachine, ITextUndoHistoryRegistry undoHistoryRegistry, IWaitIndicator waitIndicator, IEnumerable`1 refactorNotifyServices)
           at Microsoft.CodeAnalysis.Editor.Implementation.RenameTracking.RenameTrackingTaggerProvider.CreateTagger[T](ITextBuffer buffer)
           at Microsoft.VisualStudio.Text.Tagging.Implementation.TagAggregator`1.GatherTaggers(ITextBuffer textBuffer)
        ----- Inner Stack Trace #2 (Microsoft.CodeAnalysis.ThrowingTraceListener+DebugAssertFailureException) -----
           at Microsoft.CodeAnalysis.ThrowingTraceListener.Fail(String message, String detailMessage)
           at System.Diagnostics.TraceListener.Fail(String message)
           at System.Diagnostics.TraceInternal.Fail(String message)
           at System.Diagnostics.Debug.Assert(Boolean condition, String message)
           at Microsoft.CodeAnalysis.Editor.Shared.Utilities.ForegroundThreadAffinitizedObject.AssertIsForeground()
           at Microsoft.CodeAnalysis.Editor.Implementation.Diagnostics.AbstractDiagnosticsTaggerProvider`1.AggregatingTagger.OnTaggerCreated()
           at Microsoft.CodeAnalysis.Editor.Implementation.Diagnostics.AbstractDiagnosticsTaggerProvider`1.CreateTagger[T](ITextBuffer buffer)
           at Microsoft.CodeAnalysis.Editor.Implementation.Diagnostics.AbstractDiagnosticsTaggerProvider`1.Microsoft.VisualStudio.Text.Tagging.ITaggerProvider.CreateTagger[T](ITextBuffer buffer)
           at Microsoft.VisualStudio.Text.Tagging.Implementation.TagAggregator`1.GatherTaggers(ITextBuffer textBuffer)
        ----- Inner Stack Trace #3 (Microsoft.CodeAnalysis.ThrowingTraceListener+DebugAssertFailureException) -----
           at Microsoft.CodeAnalysis.ThrowingTraceListener.Fail(String message, String detailMessage)
           at System.Diagnostics.TraceListener.Fail(String message)
           at System.Diagnostics.TraceInternal.Fail(String message)
           at System.Diagnostics.Debug.Assert(Boolean condition, String message)
           at Microsoft.CodeAnalysis.Editor.Shared.Utilities.ForegroundThreadAffinitizedObject.AssertIsForeground()
           at Microsoft.CodeAnalysis.Editor.Implementation.Diagnostics.AbstractDiagnosticsTaggerProvider`1.AggregatingTagger.OnTaggerCreated()
           at Microsoft.CodeAnalysis.Editor.Implementation.Diagnostics.AbstractDiagnosticsTaggerProvider`1.CreateTagger[T](ITextBuffer buffer)
           at Microsoft.CodeAnalysis.Editor.Implementation.Diagnostics.AbstractDiagnosticsTaggerProvider`1.Microsoft.VisualStudio.Text.Tagging.ITaggerProvider.CreateTagger[T](ITextBuffer buffer)
           at Microsoft.VisualStudio.Text.Tagging.Implementation.TagAggregator`1.GatherTaggers(ITextBuffer textBuffer)
```</Description>
        <CreatedDate>18/07/2017</CreatedDate>
        <ClosedDate>04/02/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>20953</IssueID>
        <Title>Test failures in AssertIsForeground (RenameTracking and DiagnosticsTaggerProvider)</Title>
        <Description>https://ci.dot.net/job/dotnet_roslyn/view/Official%20Builds/job/master/job/windows_debug_unit32_prtest/8289/artifact/Binaries/Debug/UnitTests/EditorServicesTest2/xUnitResults/Roslyn.Services.Editor2.UnitTests.dll.out.log

```
 Microsoft.CodeAnalysis.Editor.UnitTests.Peek.PeekTests.TestPeekAcrossProjectsInvolvingPortableReferences
      System.AggregateException : 3 exception(s) were thrown during test.
      Note: exceptions may have been thrown by another test running concurrently with
      this test.  This can happen with any tests that share the same ExportProvider.
      Examining individual exception stacks may help reveal the original test and source 
      of the problem.
      
      Exception 0:
      Microsoft.CodeAnalysis.ThrowingTraceListener+DebugAssertFailureException: When created kind       : StaUnitTest
      When created thread id  : 11
      When created thread name: StaTaskScheduler thread
      Current thread id       : 6
      Current thread name     : 
      
         at Microsoft.CodeAnalysis.ThrowingTraceListener.Fail(String message, String detailMessage)
         at System.Diagnostics.TraceListener.Fail(String message)
         at System.Diagnostics.TraceInternal.Fail(String message)
         at System.Diagnostics.Debug.Assert(Boolean condition, String message)
         at Microsoft.CodeAnalysis.Editor.Shared.Utilities.ForegroundThreadAffinitizedObject.AssertIsForeground()
         at Microsoft.CodeAnalysis.Editor.Implementation.RenameTracking.RenameTrackingTaggerProvider.StateMachine.Connect()
         at Microsoft.CodeAnalysis.Editor.Implementation.RenameTracking.RenameTrackingTaggerProvider.Tagger..ctor(StateMachine stateMachine, ITextUndoHistoryRegistry undoHistoryRegistry, IWaitIndicator waitIndicator, IEnumerable`1 refactorNotifyServices)
         at Microsoft.CodeAnalysis.Editor.Implementation.RenameTracking.RenameTrackingTaggerProvider.CreateTagger[T](ITextBuffer buffer)
         at Microsoft.VisualStudio.Text.Tagging.Implementation.TagAggregator`1.GatherTaggers(ITextBuffer textBuffer)
      
      Exception 1:
      Microsoft.CodeAnalysis.ThrowingTraceListener+DebugAssertFailureException: When created kind       : StaUnitTest
      When created thread id  : 11
      When created thread name: StaTaskScheduler thread
      Current thread id       : 6
      Current thread name     : 
      
         at Microsoft.CodeAnalysis.ThrowingTraceListener.Fail(String message, String detailMessage)
         at System.Diagnostics.TraceListener.Fail(String message)
         at System.Diagnostics.TraceInternal.Fail(String message)
         at System.Diagnostics.Debug.Assert(Boolean condition, String message)
         at Microsoft.CodeAnalysis.Editor.Shared.Utilities.ForegroundThreadAffinitizedObject.AssertIsForeground()
         at Microsoft.CodeAnalysis.Editor.Implementation.Diagnostics.AbstractDiagnosticsTaggerProvider`1.AggregatingTagger.OnTaggerCreated()
         at Microsoft.CodeAnalysis.Editor.Implementation.Diagnostics.AbstractDiagnosticsTaggerProvider`1.CreateTagger[T](ITextBuffer buffer)
         at Microsoft.CodeAnalysis.Editor.Implementation.Diagnostics.AbstractDiagnosticsTaggerProvider`1.Microsoft.VisualStudio.Text.Tagging.ITaggerProvider.CreateTagger[T](ITextBuffer buffer)
         at Microsoft.VisualStudio.Text.Tagging.Implementation.TagAggregator`1.GatherTaggers(ITextBuffer textBuffer)
      
      Exception 2:
      Microsoft.CodeAnalysis.ThrowingTraceListener+DebugAssertFailureException: When created kind       : StaUnitTest
      When created thread id  : 11
      When created thread name: StaTaskScheduler thread
      Current thread id       : 6
      Current thread name     : 
      
         at Microsoft.CodeAnalysis.ThrowingTraceListener.Fail(String message, String detailMessage)
         at System.Diagnostics.TraceListener.Fail(String message)
         at System.Diagnostics.TraceInternal.Fail(String message)
         at System.Diagnostics.Debug.Assert(Boolean condition, String message)
         at Microsoft.CodeAnalysis.Editor.Shared.Utilities.ForegroundThreadAffinitizedObject.AssertIsForeground()
         at Microsoft.CodeAnalysis.Editor.Implementation.Diagnostics.AbstractDiagnosticsTaggerProvider`1.AggregatingTagger.OnTaggerCreated()
         at Microsoft.CodeAnalysis.Editor.Implementation.Diagnostics.AbstractDiagnosticsTaggerProvider`1.CreateTagger[T](ITextBuffer buffer)
         at Microsoft.CodeAnalysis.Editor.Implementation.Diagnostics.AbstractDiagnosticsTaggerProvider`1.Microsoft.VisualStudio.Text.Tagging.ITaggerProvider.CreateTagger[T](ITextBuffer buffer)
         at Microsoft.VisualStudio.Text.Tagging.Implementation.TagAggregator`1.GatherTaggers(ITextBuffer textBuffer)
      
      
      ---- Microsoft.CodeAnalysis.ThrowingTraceListener+DebugAssertFailureException : When created kind       : StaUnitTest
      When created thread id  : 11
      When created thread name: StaTaskScheduler thread
      Current thread id       : 6
      Current thread name     : 
      
      ---- Microsoft.CodeAnalysis.ThrowingTraceListener+DebugAssertFailureException : When created kind       : StaUnitTest
      When created thread id  : 11
      When created thread name: StaTaskScheduler thread
      Current thread id       : 6
      Current thread name     : 
      
      ---- Microsoft.CodeAnalysis.ThrowingTraceListener+DebugAssertFailureException : When created kind       : StaUnitTest
      When created thread id  : 11
      When created thread name: StaTaskScheduler thread
      Current thread id       : 6
      Current thread name     : 
      
      Stack Trace:
           at Microsoft.CodeAnalysis.Editor.UnitTests.Workspaces.TestWorkspace.Dispose(Boolean finalize)
           at Microsoft.CodeAnalysis.Workspace.Dispose()
        q:\roslyn\src\EditorFeatures\Test2\Peek\PeekTests.vb(181,0): at Microsoft.CodeAnalysis.Editor.UnitTests.Peek.PeekTests.TestPeekAcrossProjectsInvolvingPortableReferences()
        ----- Inner Stack Trace #1 (Microsoft.CodeAnalysis.ThrowingTraceListener+DebugAssertFailureException) -----
           at Microsoft.CodeAnalysis.ThrowingTraceListener.Fail(String message, String detailMessage)
           at System.Diagnostics.TraceListener.Fail(String message)
           at System.Diagnostics.TraceInternal.Fail(String message)
           at System.Diagnostics.Debug.Assert(Boolean condition, String message)
           at Microsoft.CodeAnalysis.Editor.Shared.Utilities.ForegroundThreadAffinitizedObject.AssertIsForeground()
           at Microsoft.CodeAnalysis.Editor.Implementation.RenameTracking.RenameTrackingTaggerProvider.StateMachine.Connect()
           at Microsoft.CodeAnalysis.Editor.Implementation.RenameTracking.RenameTrackingTaggerProvider.Tagger..ctor(StateMachine stateMachine, ITextUndoHistoryRegistry undoHistoryRegistry, IWaitIndicator waitIndicator, IEnumerable`1 refactorNotifyServices)
           at Microsoft.CodeAnalysis.Editor.Implementation.RenameTracking.RenameTrackingTaggerProvider.CreateTagger[T](ITextBuffer buffer)
           at Microsoft.VisualStudio.Text.Tagging.Implementation.TagAggregator`1.GatherTaggers(ITextBuffer textBuffer)
        ----- Inner Stack Trace #2 (Microsoft.CodeAnalysis.ThrowingTraceListener+DebugAssertFailureException) -----
           at Microsoft.CodeAnalysis.ThrowingTraceListener.Fail(String message, String detailMessage)
           at System.Diagnostics.TraceListener.Fail(String message)
           at System.Diagnostics.TraceInternal.Fail(String message)
           at System.Diagnostics.Debug.Assert(Boolean condition, String message)
           at Microsoft.CodeAnalysis.Editor.Shared.Utilities.ForegroundThreadAffinitizedObject.AssertIsForeground()
           at Microsoft.CodeAnalysis.Editor.Implementation.Diagnostics.AbstractDiagnosticsTaggerProvider`1.AggregatingTagger.OnTaggerCreated()
           at Microsoft.CodeAnalysis.Editor.Implementation.Diagnostics.AbstractDiagnosticsTaggerProvider`1.CreateTagger[T](ITextBuffer buffer)
           at Microsoft.CodeAnalysis.Editor.Implementation.Diagnostics.AbstractDiagnosticsTaggerProvider`1.Microsoft.VisualStudio.Text.Tagging.ITaggerProvider.CreateTagger[T](ITextBuffer buffer)
           at Microsoft.VisualStudio.Text.Tagging.Implementation.TagAggregator`1.GatherTaggers(ITextBuffer textBuffer)
        ----- Inner Stack Trace #3 (Microsoft.CodeAnalysis.ThrowingTraceListener+DebugAssertFailureException) -----
           at Microsoft.CodeAnalysis.ThrowingTraceListener.Fail(String message, String detailMessage)
           at System.Diagnostics.TraceListener.Fail(String message)
           at System.Diagnostics.TraceInternal.Fail(String message)
           at System.Diagnostics.Debug.Assert(Boolean condition, String message)
           at Microsoft.CodeAnalysis.Editor.Shared.Utilities.ForegroundThreadAffinitizedObject.AssertIsForeground()
           at Microsoft.CodeAnalysis.Editor.Implementation.Diagnostics.AbstractDiagnosticsTaggerProvider`1.AggregatingTagger.OnTaggerCreated()
           at Microsoft.CodeAnalysis.Editor.Implementation.Diagnostics.AbstractDiagnosticsTaggerProvider`1.CreateTagger[T](ITextBuffer buffer)
           at Microsoft.CodeAnalysis.Editor.Implementation.Diagnostics.AbstractDiagnosticsTaggerProvider`1.Microsoft.VisualStudio.Text.Tagging.ITaggerProvider.CreateTagger[T](ITextBuffer buffer)
           at Microsoft.VisualStudio.Text.Tagging.Implementation.TagAggregator`1.GatherTaggers(ITextBuffer textBuffer)
```</Description>
        <CreatedDate>18/07/2017</CreatedDate>
        <ClosedDate>04/02/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/Test/LinkedFiles/LinkedFileDiffMergingEditorTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>32336</IssueID>
    <Title>Align VB implementation with recent changes around interface implementations and tuple types in C#.</Title>
    <Description>This is a follow up on https://github.com/dotnet/roslyn/pull/32041 on VB side.
Closes #30655.
Closes #31977.</Description>
    <CreatedDate>10/01/2019</CreatedDate>
    <ClosedDate>12/01/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>30655</IssueID>
        <Title>Should Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.MetadataDecoder.GetSymbolForMemberRef ignore tuple names when it compares type symbols?</Title>
        <Description>```
                if (scope != targetTypeSymbol &amp;&amp;
                    !(targetTypeSymbol.IsInterfaceType()
                        ? scope.AllInterfacesNoUseSiteDiagnostics.Contains((NamedTypeSymbol)targetTypeSymbol)
                        : scope.IsDerivedFrom(targetTypeSymbol, TypeCompareKind.ConsiderEverything, useSiteDiagnostics: ref useSiteDiagnostics)))
```

I had to adjust this code to ignore nullability information in order to get correct behavior in presence of nullability modifiers. It feels like that tuple names could cause the same problem.</Description>
        <CreatedDate>22/10/2018</CreatedDate>
        <ClosedDate>12/01/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>31977</IssueID>
        <Title>```Interfaces``` and ```AllInterfaces``` disagree in tuple element names used by interfaces, FindImplementationForInterfaceMember fails to locate correct implementation in some scenarios </Title>
        <Description>```
        [Fact]
        public void DuplicateInterfaceDetectionWithDifferentTupleNames_02()
        {
            var source = @"
public interface I1&lt;T&gt; { }
public interface I2 : I1&lt;(int a, int b)&gt; { }
public class C1 : I2, I1&lt;(int c, int d)&gt; { }
public class C2 : I1&lt;(int c, int d)&gt;, I2 { }
";
            var comp = CreateCompilation(source);
            comp.VerifyDiagnostics(
                // (4,14): error CS8140: 'I1&lt;(int c, int d)&gt;' is already listed in the interface list on type 'C1' with different tuple element names, as 'I1&lt;(int a, int b)&gt;'.
                // public class C1 : I2, I1&lt;(int c, int d)&gt; { }
                Diagnostic(ErrorCode.ERR_DuplicateInterfaceWithTupleNamesInBaseList, "C1").WithArguments("I1&lt;(int c, int d)&gt;", "I1&lt;(int a, int b)&gt;", "C1").WithLocation(4, 14),
                // (5,14): error CS8140: 'I1&lt;(int a, int b)&gt;' is already listed in the interface list on type 'C2' with different tuple element names, as 'I1&lt;(int c, int d)&gt;'.
                // public class C2 : I1&lt;(int c, int d)&gt;, I2 { }
                Diagnostic(ErrorCode.ERR_DuplicateInterfaceWithTupleNamesInBaseList, "C2").WithArguments("I1&lt;(int a, int b)&gt;", "I1&lt;(int c, int d)&gt;", "C2").WithLocation(5, 14)
                );

            var c1 = comp.GetTypeByMetadataName("C1");
            var c1Interfaces = c1.InterfacesNoUseSiteDiagnostics();
            var c1AllInterfaces = c1.AllInterfacesNoUseSiteDiagnostics;
            Assert.Equal(2, c1Interfaces.Length);
            Assert.Equal(2, c1AllInterfaces.Length);
            Assert.Equal("I2", c1Interfaces[0].ToTestDisplayString());
            Assert.Equal("I1&lt;(System.Int32 c, System.Int32 d)&gt;", c1Interfaces[1].ToTestDisplayString());
            Assert.Equal("I2", c1AllInterfaces[0].ToTestDisplayString());
            Assert.Equal("I1&lt;(System.Int32 c, System.Int32 d)&gt;", c1AllInterfaces[1].ToTestDisplayString());

            var c2 = comp.GetTypeByMetadataName("C2");
            var c2Interfaces = c2.InterfacesNoUseSiteDiagnostics();
            var c2AllInterfaces = c2.AllInterfacesNoUseSiteDiagnostics;
            Assert.Equal(2, c2Interfaces.Length);
            Assert.Equal(2, c2AllInterfaces.Length);
            Assert.Equal("I1&lt;(System.Int32 c, System.Int32 d)&gt;", c2Interfaces[0].ToTestDisplayString());
            Assert.Equal("I2", c2Interfaces[1].ToTestDisplayString());
            Assert.Equal("I2", c2AllInterfaces[0].ToTestDisplayString());
            Assert.Equal("I1&lt;(System.Int32 a, System.Int32 b)&gt;", c2AllInterfaces[1].ToTestDisplayString());
        }
```

Observed:
```
            Assert.Equal("I1&lt;(System.Int32 c, System.Int32 d)&gt;", c2Interfaces[0].ToTestDisplayString());
            Assert.Equal("I1&lt;(System.Int32 a, System.Int32 b)&gt;", c2AllInterfaces[1].ToTestDisplayString());
```

Expected:
Both APIs should return the same interface type, tuple element names should match. </Description>
        <CreatedDate>21/12/2018</CreatedDate>
        <ClosedDate>12/01/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/MetadataDecoder.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceNamedTypeSymbol_Bases.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTupleTest.cs</File>
      <File>src/Compilers/Core/Portable/InternalUtilities/MultiDictionary.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>32313</IssueID>
    <Title>Finish the project context implementation for the free-threaded project system shims</Title>
    <Description>The handling for determination of project contexts wasn't finished when we merged the work for free-threaded project system shims. This completes the work and fixes a bunch of issues as well.

This should fix the Roslyn side of #21358, but there are also some project system bugs that have been found too that will impact it.

Reviewers are **strongly** encouraged to go commit-by-commit here.

Work remaining:

- [x] Remove the existing hack around skipping locks when we remove projects, since those don't work correctly if just files are removed.

&lt;details&gt;&lt;summary&gt;Ask Mode template&lt;/summary&gt;

### Customer scenario

The customer has a multitargeting SDK project, linked files, or is using shared asset projects. If they try to use the dropdown in the editor to change the context, it won't work reliably or at all.

### Bugs this fixes

#31019
#31365
#21358 (but still needs more fixes from the Visual Studio side, it seems)

### Workarounds, if any

Only workaround would be to use 15.9.

### Risk

Moderate: this is a technical area in the code and interacts with a number of Visual Studio components. In the process of writing this we've discovered at least three bugs in _other_ components, to give a sense of how tricky this area is!

### Performance impact

Better; this also fixes a few memory leaks that would have leaked some project information when projects and solutions were closed.

### Is this a regression from a previous update?

Yes.

### Root cause analysis

This was a known limitation when we merged the original free-threaded project initialization code. This only impacts a subset of our users, and when they do hit it is supremely annoying, but it was best to get all the other stuff in their hands and worry about this later. The existing code already had some bugs too; since we were rewriting all of it meant it was a good opportunity to get it right.

### How was the bug found?

Various bugs reported from customers, but this was tracked internally in our own backlog.

&lt;/details&gt;
</Description>
    <CreatedDate>10/01/2019</CreatedDate>
    <ClosedDate>15/01/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>4467</IssueID>
        <Title>C# file in multiple csproj files in same solution can't be switched between said csprojs in vs editor</Title>
        <Description>_From @FransBouma on August 4, 2017 8:28_

Repro: [CSharpEditorRepro.zip](https://github.com/dotnet/project-system/files/1199694/CSharpEditorRepro.zip)

The attached repro case has two csproj files, one targeting NetFX and one targeting NetStandard2.0. The Netstandard2.0 project references the cs file from the NetFX project. While I know in theory one could use 'multi-targeting', for now I'm not using that due to tooling being in preview state and this allows me to build two artifacts without problems.

The issue is that when I open the C# file in the vs 2017 15.3 prev 7 editor, it will always pick the netstandard project in the top bar: you can't select the NetFX project version, even if you open that solution item. This is particularly problematic when there are conditional compilation directives present, like the one in the example. 

If there's more info needed, let me know. :)

_Copied from original issue: dotnet/project-system#2691_</Description>
        <CreatedDate>08/08/2017</CreatedDate>
        <ClosedDate>14/02/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>31019</IssueID>
        <Title>IWorkspaceProjectContext.Dispose() still has UI thread affinity</Title>
        <Description>@davkean still discovered it's got one icky UI thread requirement here:

```
    Microsoft.CodeAnalysis.Workspaces.dll!Roslyn.Utilities.Contract.ThrowIfFalse(bool condition, string message)    Unknown
    Microsoft.CodeAnalysis.EditorFeatures.dll!Microsoft.CodeAnalysis.Editor.Shared.Utilities.ForegroundThreadAffinitizedObject.AssertIsForeground()    Unknown
    Microsoft.VisualStudio.LanguageServices.dll!Microsoft.VisualStudio.LanguageServices.Implementation.ProjectSystem.VisualStudioWorkspaceImpl.SetDocumentContext(Microsoft.CodeAnalysis.DocumentId documentId)    Unknown
    Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Workspace.ClearOpenDocument(Microsoft.CodeAnalysis.DocumentId documentId, bool isSolutionClosing)    Unknown
    Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Workspace.ClearOpenDocuments(Microsoft.CodeAnalysis.ProjectId projectId)    Unknown
    Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Workspace.ClearProjectData(Microsoft.CodeAnalysis.ProjectId projectId)    Unknown
    Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Workspace.OnProjectRemoved(Microsoft.CodeAnalysis.ProjectId projectId)    Unknown
    Microsoft.VisualStudio.LanguageServices.dll!Microsoft.VisualStudio.LanguageServices.Implementation.ProjectSystem.VisualStudioWorkspaceImpl.OnProjectRemoved(Microsoft.CodeAnalysis.ProjectId projectId)    Unknown
    Microsoft.VisualStudio.LanguageServices.dll!Microsoft.VisualStudio.LanguageServices.Implementation.ProjectSystem.VisualStudioProject.RemoveFromWorkspace.AnonymousMethod__86_0(Microsoft.CodeAnalysis.Workspace w)    Unknown
    Microsoft.VisualStudio.LanguageServices.dll!Microsoft.VisualStudio.LanguageServices.Implementation.ProjectSystem.VisualStudioWorkspaceImpl.ApplyChangeToWorkspace(System.Action&lt;Microsoft.CodeAnalysis.Workspace&gt; action)    Unknown
    Microsoft.VisualStudio.LanguageServices.dll!Microsoft.VisualStudio.LanguageServices.Implementation.ProjectSystem.VisualStudioProject.RemoveFromWorkspace()    Unknown
    Microsoft.VisualStudio.LanguageServices.Implementation.dll!Microsoft.VisualStudio.LanguageServices.Implementation.ProjectSystem.CPS.CPSProject.Dispose()    Unknown
```</Description>
        <CreatedDate>07/11/2018</CreatedDate>
        <ClosedDate>15/01/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>31365</IssueID>
        <Title>Multi-targeting context is broken in 16.0 Preview 1</Title>
        <Description>**Version Used**: 
Version 16.0.0 Preview 1.0 [28321.56.d16.0]

**Steps to Reproduce**:

1. Create a new Console App (.NET Core) and replace contents with:

``` XML
&lt;Project Sdk="Microsoft.NET.Sdk"&gt;

  &lt;PropertyGroup&gt;
    &lt;OutputType&gt;Exe&lt;/OutputType&gt;
    &lt;TargetFrameworks&gt;net45;net46&lt;/TargetFrameworks&gt;
  &lt;/PropertyGroup&gt;

&lt;/Project&gt;
```

2. Reload project
3. In Editor, attempt to change context from net45 -&gt; net46 (or vice versa)
4. Click in editor

**Expected Behavior**:
Context to be changed

**Actual Behavior**:
Context is flipped back to the previous context.

This is a regression from 15.9.
</Description>
        <CreatedDate>26/11/2018</CreatedDate>
        <ClosedDate>15/01/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>4467</IssueID>
        <Title>C# file in multiple csproj files in same solution can't be switched between said csprojs in vs editor</Title>
        <Description>_From @FransBouma on August 4, 2017 8:28_

Repro: [CSharpEditorRepro.zip](https://github.com/dotnet/project-system/files/1199694/CSharpEditorRepro.zip)

The attached repro case has two csproj files, one targeting NetFX and one targeting NetStandard2.0. The Netstandard2.0 project references the cs file from the NetFX project. While I know in theory one could use 'multi-targeting', for now I'm not using that due to tooling being in preview state and this allows me to build two artifacts without problems.

The issue is that when I open the C# file in the vs 2017 15.3 prev 7 editor, it will always pick the netstandard project in the top bar: you can't select the NetFX project version, even if you open that solution item. This is particularly problematic when there are conditional compilation directives present, like the one in the example. 

If there's more info needed, let me know. :)

_Copied from original issue: dotnet/project-system#2691_</Description>
        <CreatedDate>08/08/2017</CreatedDate>
        <ClosedDate>14/02/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Interactive/EditorFeatures/Core/Implementation/Interactive/InteractiveWorkspace.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/RuleSets/VisualStudioRuleSetManager.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/VisualStudioProjectOptionsProcessor.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/VisualStudioWorkspaceImpl.OpenFileTracker.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/VisualStudioWorkspaceImpl.cs</File>
      <File>src/Workspaces/Core/Portable/Utilities/ICacheEntry.cs</File>
      <File>src/Workspaces/Core/Portable/Utilities/ReferenceCountedDisposableCache.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/Workspace.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/Workspace_Editor.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>32306</IssueID>
    <Title>Avoid retrying work after the queue is cancelled</Title>
    <Description>Fixes #28062

&lt;details&gt;&lt;summary&gt;Ask Mode&lt;/summary&gt;

### Customer scenario

No direct reproducer is known.

### Bugs this fixes

#28062

### Workarounds, if any

None.

### Risk

Very low. This change avoids scheduling work items in three specific queues after global shutdown is requested.

### Performance impact

This change may improve test performance, but is unlikely to have an observable impact elsewhere.

### Is this a regression from a previous update?

No.

### Root cause analysis

If project or document processing was cancelled because the workspace was shut down, items could be rescheduled for execution and never actually execute.

### How was the bug found?

Caught by automated testing.

### Test documentation updated?

N/A

&lt;/details&gt;</Description>
    <CreatedDate>09/01/2019</CreatedDate>
    <ClosedDate>14/01/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>28062</IssueID>
        <Title>Microsoft.CodeAnalysis.Editor.UnitTests.Diagnostics.DiagnosticsSquiggleTaggerProviderTests.Test_TagSourceDiffer is flaky</Title>
        <Description>Example failure: https://ci.dot.net/job/dotnet_roslyn/job/master/view/Official%20Builds/job/windows_debug_unit32/2431/

```
MESSAGE:
System.TimeoutException : Failed to clean up listeners in a timely manner.\r\n ReenqueueWorkItem WorkCoordinator.NormalPriorityProcessor.cs 359\r\n---- System.OperationCanceledException : The operation was canceled.
+++++++++++++++++++
STACK TRACE:
at Microsoft.CodeAnalysis.Test.Utilities.UseExportProviderAttribute.After(MethodInfo methodUnderTest) ----- Inner Stack Trace ----- at System.Threading.CancellationToken.ThrowOperationCanceledException() at System.Threading.CancellationToken.ThrowIfCancellationRequested() at Roslyn.Test.Utilities.TaskJoinExtensions.JoinUsingDispatcherNoResult(Task task, CancellationToken cancellationToken) at Roslyn.Test.Utilities.TaskJoinExtensions.JoinUsingDispatcher(Task task, CancellationToken cancellationToken) at Microsoft.CodeAnalysis.Test.Utilities.UseExportProviderAttribute.After(MethodInfo methodUnderTest)
```

@heejaechang , @sharwell and @jinujoseph can this get quickly looked at? Hit a few of my PRs and other partner teams too.</Description>
        <CreatedDate>21/06/2018</CreatedDate>
        <ClosedDate>14/01/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>28062</IssueID>
        <Title>Microsoft.CodeAnalysis.Editor.UnitTests.Diagnostics.DiagnosticsSquiggleTaggerProviderTests.Test_TagSourceDiffer is flaky</Title>
        <Description>Example failure: https://ci.dot.net/job/dotnet_roslyn/job/master/view/Official%20Builds/job/windows_debug_unit32/2431/

```
MESSAGE:
System.TimeoutException : Failed to clean up listeners in a timely manner.\r\n ReenqueueWorkItem WorkCoordinator.NormalPriorityProcessor.cs 359\r\n---- System.OperationCanceledException : The operation was canceled.
+++++++++++++++++++
STACK TRACE:
at Microsoft.CodeAnalysis.Test.Utilities.UseExportProviderAttribute.After(MethodInfo methodUnderTest) ----- Inner Stack Trace ----- at System.Threading.CancellationToken.ThrowOperationCanceledException() at System.Threading.CancellationToken.ThrowIfCancellationRequested() at Roslyn.Test.Utilities.TaskJoinExtensions.JoinUsingDispatcherNoResult(Task task, CancellationToken cancellationToken) at Roslyn.Test.Utilities.TaskJoinExtensions.JoinUsingDispatcher(Task task, CancellationToken cancellationToken) at Microsoft.CodeAnalysis.Test.Utilities.UseExportProviderAttribute.After(MethodInfo methodUnderTest)
```

@heejaechang , @sharwell and @jinujoseph can this get quickly looked at? Hit a few of my PRs and other partner teams too.</Description>
        <CreatedDate>21/06/2018</CreatedDate>
        <ClosedDate>14/01/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Features/Core/Portable/SolutionCrawler/WorkCoordinator.HighPriorityProcessor.cs</File>
      <File>src/Features/Core/Portable/SolutionCrawler/WorkCoordinator.LowPriorityProcessor.cs</File>
      <File>src/Features/Core/Portable/SolutionCrawler/WorkCoordinator.NormalPriorityProcessor.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>32286</IssueID>
    <Title>Fix formatting of positional patterns</Title>
    <Description>Closes #27268 

&lt;details&gt;&lt;summary&gt;Ask Mode&lt;/summary&gt;

### Customer scenario

A customer uses the new C# 8 recursive patterns feature with a positional pattern. The IDE ignores the users code style preferences for formatting the new construct, and by default does not follow the default recommended style for these patterns.

### Bugs this fixes

#27268

### Workarounds, if any

None.

### Risk

Low. This change only impacts the formatting of positional patterns, and tests are included to show the expected behavior is followed for both default and customized scenarios.

### Performance impact

Negligible.

### Is this a regression from a previous update?

No.

### Root cause analysis

Reported during feature development, but work to correct it waited for the feature to land in the main development branch.

### How was the bug found?

Reported by feature author.

### Test documentation updated?

No.

&lt;/details&gt;</Description>
    <CreatedDate>09/01/2019</CreatedDate>
    <ClosedDate>29/01/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>27268</IssueID>
        <Title>Formatting for positional pattern should drop a space</Title>
        <Description>current formatting rule is to put a space between type and positional sub-pattern. I think it should be formatted like an invocation instead (ie. no space).

For example, given
``` c#
    Point p = new Point(3, 4);
```
you should write
``` c#
    if (p is Point(3, 4)) ...
```
rather than
``` c#
    if (p is Point (3, 4)) ...
```

The reason I suggest there should be no space is that the syntax was designed to mirror the construction syntax for objects (i.e. a constructor invocation), where there is no space.</Description>
        <CreatedDate>30/05/2018</CreatedDate>
        <ClosedDate>29/01/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>27268</IssueID>
        <Title>Formatting for positional pattern should drop a space</Title>
        <Description>current formatting rule is to put a space between type and positional sub-pattern. I think it should be formatted like an invocation instead (ie. no space).

For example, given
``` c#
    Point p = new Point(3, 4);
```
you should write
``` c#
    if (p is Point(3, 4)) ...
```
rather than
``` c#
    if (p is Point (3, 4)) ...
```

The reason I suggest there should be no space is that the syntax was designed to mirror the construction syntax for objects (i.e. a constructor invocation), where there is no space.</Description>
        <CreatedDate>30/05/2018</CreatedDate>
        <ClosedDate>29/01/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/Formatting/FormattingEngineTests.cs</File>
      <File>src/Workspaces/CSharp/Portable/Formatting/FormattingHelpers.cs</File>
      <File>src/Workspaces/CSharp/Portable/Formatting/Rules/SpacingFormattingRule.cs</File>
      <File>src/Workspaces/CSharpTest/Formatting/FormattingTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>32277</IssueID>
    <Title>Add ITypeSymbol.IsUnmanagedType and ITypeSymbol.IsRefLikeType</Title>
    <Description>Fixes #30427
Fixes #30426</Description>
    <CreatedDate>09/01/2019</CreatedDate>
    <ClosedDate>10/01/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>30427</IssueID>
        <Title>Expose IsManagedType on INameTypeSymbol</Title>
        <Description>Useful information that I don't know how to dig out using existing API.</Description>
        <CreatedDate>10/10/2018</CreatedDate>
        <ClosedDate>10/01/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>30426</IssueID>
        <Title>Expose IsByRefLikeType on INameTypeSymbol</Title>
        <Description>Useful information that I don't know how to dig out using existing API.
</Description>
        <CreatedDate>10/10/2018</CreatedDate>
        <ClosedDate>10/01/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder.ValueChecks.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Expressions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Patterns.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Statements.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/Conversions/Conversions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/UsingStatementBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/NullableWalker.cs</File>
      <File>src/Compilers/CSharp/Portable/SymbolDisplay/SymbolDisplayVisitor.Types.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/AnonymousTypes/PublicSymbols/AnonymousType.TypePublicSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/AnonymousTypes/SynthesizedSymbols/AnonymousType.TemplateSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ArrayTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/DynamicTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ErrorTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PENamedTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/PointerTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceMemberContainerSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceMemberFieldSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceNamedTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceNamedTypeSymbol_Bases.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourcePropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedContainer.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedEmbeddedAttributeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/TypeParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/TypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/TypeSymbolExtensions.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Wrapped/WrappedNamedTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Attributes/AttributeTests_IsByRefLike.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/RefEscapingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/UnsafeTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/SymbolDisplay/SymbolDisplayTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/MockNamedTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/ReadOnlyStructs.cs</File>
      <File>src/Compilers/Core/Portable/Symbols/ITypeSymbol.cs</File>
      <File>src/Compilers/Test/Utilities/CSharp/CSharpTestBase.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Source/ExpressionCompiler/Symbols/EENamedTypeSymbol.cs</File>
      <File>src/Features/Core/Portable/MetadataAsSource/AbstractMetadataAsSourceService.WrappedNamedTypeSymbol.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/Symbols/CodeGenerationAbstractNamedTypeSymbol.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/Symbols/CodeGenerationTypeSymbol.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>31607</IssueID>
    <Title>Remove remaining artifacts of symbol-centric NonNullTypes context.</Title>
    <Description>Closes #30171.
Closes #29838.</Description>
    <CreatedDate>07/12/2018</CreatedDate>
    <ClosedDate>10/12/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>30171</IssueID>
        <Title>Binders used by SemanticModel are not guaranteed to use proper NonNullTypes context</Title>
        <Description>```
        [Fact]
        public void NonNullTypesContext_01()
        {
            var source =
@"
using System.Runtime.CompilerServices;

class A
{
    [NonNullTypes(false)]
    B[] F1;

    [NonNullTypes(true)]
    C[] F2;
}

class B {}
class C {}
";
            var comp = CreateCompilation(new[] { source });


            var f1 = comp.GetMember&lt;FieldSymbol&gt;("A.F1");
            Assert.Equal("B[]", f1.Type.ToTestDisplayString(includeNonNullable: true));

            var f2 = comp.GetMember&lt;FieldSymbol&gt;("A.F2");
            Assert.Equal("C![]!", f2.Type.ToTestDisplayString(includeNonNullable: true));

            var tree = comp.SyntaxTrees.First();
            var model = comp.GetSemanticModel(tree);
            var arrays = tree.GetRoot().DescendantNodes().OfType&lt;ArrayTypeSyntax&gt;().ToArray();

            Assert.Equal(2, arrays.Length);

            Assert.Equal("B[]", model.GetTypeInfo(arrays[0]).Type.ToTestDisplayString(includeNonNullable: true));
            // !!! Expected "C![]"
            Assert.Equal("C[]", model.GetTypeInfo(arrays[1]).Type.ToTestDisplayString(includeNonNullable: true));
        }
```

Right now Binder.NonNullTypesContext is driven by the Binder.ContainingMember, which is not always set by Microsoft.CodeAnalysis.CSharp.BinderFactory to what would be necessary to properly reflect the NonNullTypes context. Often, this behavior of the BinderFactory is driven by the intent to avoid creating symbols for members and looking up members whenever possible, which helps IDE performance. I think that implementation of the BinderFactory should be adjusted to make sure it produces binders with the right context (the way "unsafe" context is handled can be  used as an example). However, given that the context is defined by attributes, that is likely to have negative effect on performance of the factory.</Description>
        <CreatedDate>27/09/2018</CreatedDate>
        <ClosedDate>10/12/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>29838</IssueID>
        <Title>SymbolDisplay should respect ```SymbolDisplayCompilerInternalOptions.IncludeNonNullableTypeModifier``` for ```class``` constraint </Title>
        <Description>When ```SymbolDisplayCompilerInternalOptions.IncludeNonNullableTypeModifier``` is set and "TypeParameterSymbol.ReferenceTypeConstraintIsNullable == true", the ```class``` constraint should have an ExclamationToken. I.e. the output should look like ```class!```.

Relevant code is in ```private void AddTypeParameterConstraints(ImmutableArray&lt;ITypeSymbol&gt; typeArguments)```.
</Description>
        <CreatedDate>13/09/2018</CreatedDate>
        <ClosedDate>10/12/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder.NamespaceOrTypeOrAliasSymbolWithAnnotations.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Constraints.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Deconstruct.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Patterns.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Symbols.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_TupleOperators.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/BuckStopsHereBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/INonNullTypesContext.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/WithNullableContextBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/OutDeconstructVarPendingInference.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/UnboundLambda.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/VariablePendingInference.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/CSharpSemanticModel.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/LazyMissingNonNullTypesContextDiagnosticInfo.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/LazyNullAsNonNullableDiagnosticInfo.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/LazyNullableContraintChecksDiagnosticInfo.cs</File>
      <File>src/Compilers/CSharp/Portable/SymbolDisplay/SymbolDisplayVisitor.Types.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ErrorTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/EventSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/FieldSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/LocalSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PEEventSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PEFieldSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PEMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PEModuleSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PENamedTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PEPropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/SymbolFactory.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/MethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/MissingModuleSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/NamedTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/PropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Retargeting/RetargetingEventSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Retargeting/RetargetingFieldSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Retargeting/RetargetingMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Retargeting/RetargetingModuleSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Retargeting/RetargetingNamedTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Retargeting/RetargetingPropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/SignatureOnlyMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/FieldSymbolWithAttributesAndModifiers.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/GlobalExpressionVariable.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/LambdaSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceAssemblySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceComplexParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceConstructorSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceDelegateMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceEventAccessorSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceEventSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceMemberFieldSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceMemberMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceModuleSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceNamedTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourcePropertyAccessorSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourcePropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceTypeParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/TypeParameterConstraintClause.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/SubstitutedMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/SubstitutedNamedTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Symbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedEntryPointSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedImplementationMethod.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedInteractiveInitializerMethod.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Tuples/TupleMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/TypeMap.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/TypeParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/TypeSymbolWithAnnotations.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/NullableReferenceTypesTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>31602</IssueID>
    <Title>Unmanaged constructed types tests</Title>
    <Description>Related to #31374 and dotnet/csharplang#1744

Seeing an interesting test failure in the new verification test in 
7b278f4. Anything come to mind on how to address this @jaredpar @agocke?

```
System.Exception : Verification failed
---- Roslyn.Test.Utilities.Desktop.RuntimePeVerifyException : 
PeVerify failed for assembly 'C:\Users\rigibson\AppData\Local\Temp\RoslynTests':
[ : MyStruct`1[T]::get_Item][mdToken=0x6000002][offset 0x0000000F][found unmanaged pointer] Expected numeric type on the stack.
[ : C::Main][mdToken=0x6000003][offset 0x00000012][found address of Single] Expected numeric type on the stack.


Stack Trace:
  C:\Users\rigibson\src\roslyn\src\Test\Utilities\Portable\Platform\Desktop\DesktopRuntimeEnvironment.cs(320,0): at Roslyn.Test.Utilities.Desktop.DesktopRuntimeEnvironment.Verify(Verification verification)
  C:\Users\rigibson\src\roslyn\src\Test\Utilities\Portable\CompilationVerifier.cs(160,0): at Microsoft.CodeAnalysis.Test.Utilities.CompilationVerifier.Emit(String expectedOutput, Nullable`1 expectedReturnCode, String[] args, IEnumerable`1 manifestResources, EmitOptions emitOptions, Verification peVerify, SignatureDescription[] expectedSignatures)
  C:\Users\rigibson\src\roslyn\src\Test\Utilities\Portable\CommonTestBase.cs(154,0): at Microsoft.CodeAnalysis.Test.Utilities.CommonTestBase.Emit(Compilation compilation, IEnumerable`1 dependencies, IEnumerable`1 manifestResources, SignatureDescription[] expectedSignatures, String expectedOutput, Nullable`1 expectedReturnCode, String[] args, Action`1 assemblyValidator, Action`1 symbolValidator, EmitOptions emitOptions, Verification verify)
  C:\Users\rigibson\src\roslyn\src\Test\Utilities\Portable\CommonTestBase.cs(68,0): at Microsoft.CodeAnalysis.Test.Utilities.CommonTestBase.CompileAndVerifyCommon(Compilation compilation, IEnumerable`1 manifestResources, IEnumerable`1 dependencies, Action`1 sourceSymbolValidator, Action`1 assemblyValidator, Action`1 symbolValidator, SignatureDescription[] expectedSignatures, String expectedOutput, Nullable`1 expectedReturnCode, String[] args, EmitOptions emitOptions, Verification verify)
  C:\Users\rigibson\src\roslyn\src\Compilers\Test\Utilities\CSharp\CSharpTestBase.cs(605,0): at Microsoft.CodeAnalysis.CSharp.Test.Utilities.CSharpTestBase.CompileAndVerify(Compilation compilation, IEnumerable`1 manifestResources, IEnumerable`1 dependencies, Action`1 sourceSymbolValidator, Action`1 validator, Action`1 symbolValidator, SignatureDescription[] expectedSignatures, String expectedOutput, Nullable`1 expectedReturnCode, String[] args, EmitOptions emitOptions, Verification verify)
  C:\Users\rigibson\src\roslyn\src\Compilers\Test\Utilities\CSharp\CSharpTestBase.cs(564,0): at Microsoft.CodeAnalysis.CSharp.Test.Utilities.CSharpTestBase.CompileAndVerify(CSharpTestSource source, IEnumerable`1 references, IEnumerable`1 manifestResources, IEnumerable`1 dependencies, Action`1 sourceSymbolValidator, Action`1 assemblyValidator, Action`1 symbolValidator, SignatureDescription[] expectedSignatures, String expectedOutput, Nullable`1 expectedReturnCode, String[] args, CSharpCompilationOptions options, CSharpParseOptions parseOptions, EmitOptions emitOptions, TargetFramework targetFramework, Verification verify)
  C:\Users\rigibson\src\roslyn\src\Compilers\CSharp\Test\Semantic\Semantics\GenericConstraintsTests.cs(3659,0): at Microsoft.CodeAnalysis.CSharp.Semantic.UnitTests.Semantics.GenericConstraintsTests.NestedGenericStructContainingPointer()
  ----- Inner Stack Trace -----
  C:\Users\rigibson\src\roslyn\src\Test\Utilities\Portable\Platform\Desktop\RuntimeAssemblyManager.cs(455,0): at Roslyn.Test.Utilities.Desktop.RuntimeAssemblyManager.PeVerifyModules(String[] modulesToVerify, Boolean throwOnError)
     at Roslyn.Test.Utilities.Desktop.RuntimeAssemblyManager.PeVerifyModules(String[] modulesToVerify, Boolean throwOnError)
  C:\Users\rigibson\src\roslyn\src\Test\Utilities\Portable\Platform\Desktop\DesktopRuntimeEnvironment.cs(310,0): at Roslyn.Test.Utilities.Desktop.DesktopRuntimeEnvironment.Verify(Verification verification)

```

Umbrella issue for unmanaged constructed types: https://github.com/dotnet/roslyn/issues/31374</Description>
    <CreatedDate>07/12/2018</CreatedDate>
    <ClosedDate>11/01/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>31374</IssueID>
        <Title>Test plan for "unmanaged generic structs"</Title>
        <Description>Proposal: https://github.com/dotnet/csharplang/issues/1744

This issue is a place to collect test ideas and track their validation. Use the [compiler test plan](https://github.com/dotnet/roslyn/blob/master/docs/contributing/Compiler%20Test%20Plan.md) as a tool for brainstorming.

- [x] validate with LangVersion 7.3
- [x] test with tuple type ([SO](https://stackoverflow.com/questions/53992855/how-do-a-struct-containing-valuetuple-can-satisfy-unmanaged-constraint-but-valu) thread) #32103 
- [x] write speclet (contained under Design section of proposal)
- ~~[ ] update compiler test plan~~ (doesn't appear to be anything to add)
- [x] test public API `IsUnmanagedType` in new scenarios
- [x] Test for ref structs
- [x] Test the IsManagedType API as suggested by Julien
- [x] Test moveability (existing rules should be sufficient)
- [x] Have at least one test spit some IL to look at and have a few tests run with "expected output" to make sure the CLR can handle the code.
- [x] Stackalloc array of items
- [x] (Mutually) Recursive struct definition
  - [x] Also check the IsUnmanagedType API for these
- [x] Fixed-size buffer inside generic struct
- [x] Also check across metadata (metadata struct definition has private object or unmanaged field)
  - [x] Also private `T` field
- [x] For all places unmanaged type is required, we should have a test that covers that code path and ensures that the required feature diagnostic is produced at language version &lt; 8.0
  - [x] addressOf `&amp;`
  - [x] `fixed` with address of field
  - [x] `fixed` with array of generic structs
  - [x] `sizeof`
  - [x] `stackalloc` with size
  - [x] implicit `stackalloc` with initializer
  - [x] field of type pointer to unmanaged generic struct
  - [x] unmanaged constraint</Description>
        <CreatedDate>26/11/2018</CreatedDate>
        <ClosedDate>30/01/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>1744</IssueID>
        <Title>Incomplete catch block in lambda doesn't show Add Using quick fix</Title>
        <Description>Source:

``` C#
class A {
    System.Action a = () =&gt; {
        try {
        }
        catch (Exception
    };
}
```

The Add Using/Qualify Name quick fix will not appear until after adding `) {`.
</Description>
        <CreatedDate>01/04/2015</CreatedDate>
        <ClosedDate>28/04/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Expressions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Operators.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Statements.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Symbols.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Imports.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/OverloadResolution/OverloadResolution.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/OverloadResolution/OverloadResolutionResult.cs</File>
      <File>src/Compilers/CSharp/Portable/CSharpResources.Designer.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/MessageID.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/AliasSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ArrayTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/BaseTypeAnalysis.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ConstraintsHelper.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/DynamicTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/NamedTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/PointerTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceCustomEventSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceEventSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceMemberContainerSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceMemberFieldSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceNamedTypeSymbol_Bases.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceOrdinaryMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourcePropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceTypeParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceUserDefinedOperatorSymbolBase.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedEmbeddedAttributeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Tuples/TupleTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/TypeParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/TypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/TypeSymbolWithAnnotations.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/GenericConstraintsTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/NullableReferenceTypesTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/UnsafeTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/MockNamedTypeSymbol.cs</File>
      <File>src/Compilers/Core/Portable/Symbols/ManagedKind.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>31595</IssueID>
    <Title>Fix couple of bugs in unused private members analyzer</Title>
    <Description>1. https://github.com/dotnet/roslyn/commit/1196711c981829ba53e4ef307cf79f25b3b0bff2: Fixes #31572. Fix detection of entry point methods to account for `int` return type.

2. https://github.com/dotnet/roslyn/commit/9cc8b0c5388bff6453c0807b2fbe96f7ef6f0dc8: Fixes #31581. Add a workaround for #19965 to detect references to method/property from method group/property group argument to `nameof` operator. We also provide a different diagnostic message for private methods that have name-only references.</Description>
    <CreatedDate>06/12/2018</CreatedDate>
    <ClosedDate>12/12/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>31572</IssueID>
        <Title>VS2019 thinks `int Main` is unused</Title>
        <Description>**Version Used**: 

Microsoft Visual Studio Enterprise 2019 Preview
Version 16.0.0 Preview 1.0

**Steps to Reproduce**:

1. Create a new .NET Core console project
2. Possibly unrelated, but set language version to 8.0 and enable NRT with `&lt;NullableReferenceTypes&gt;true&lt;/NullableReferenceTypes&gt;` in the csproj.
3. Build the following code:

```csharp
using System;

namespace ConsoleApp1
{
    class Program
    {
        static int Main(string[] args)
        {
            if (args.Length == 0)
            {
                Console.WriteLine("Usage: ConsoleApp1 &lt;text&gt;");
                return -1;
            }

            foreach (var arg in args)
            {
                Console.WriteLine(arg);
            }
            return 0;
        }
    }
}
```

**Expected Behavior**:

No diagnostics

**Actual Behavior**:

IDE0051 Private member 'Program.Main' is unused.
</Description>
        <CreatedDate>06/12/2018</CreatedDate>
        <ClosedDate>12/12/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>31581</IssueID>
        <Title>IDE0051 should not be reported when methods are referenced in nameof() expressions</Title>
        <Description>**Version Used**: VS 16.0 Preview 1

**Steps to Reproduce**:

1. Copy the code into a C# file.

```c#
public string P =&gt; nameof(M);
private void M() { }
```

**Expected Behavior**: IDE0051 is not reported for `M`.

**Actual Behavior**: IDE0051 is reported for `M`. The code fix breaks any code that references `M`.</Description>
        <CreatedDate>06/12/2018</CreatedDate>
        <ClosedDate>12/12/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19965</IssueID>
        <Title>IOperation - IOperation API for BoundMethodGroup and BoundPropertyGroup</Title>
        <Description>Would be valuable for things like INameOfExpression: https://github.com/dotnet/roslyn/issues/19954

Probably also want this for IBadInvocationExpression where the member group can specify the members that the compiler considered.</Description>
        <CreatedDate>01/06/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/RemoveUnusedMembers/RemoveUnusedMembersTests.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/DiagnosticHelper.cs</File>
      <File>src/Features/Core/Portable/FeaturesResources.Designer.cs</File>
      <File>src/Features/Core/Portable/RemoveUnusedMembers/AbstractRemoveUnusedMembersDiagnosticAnalyzer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>31534</IssueID>
    <Title> Editor completion: tests for non-block for completion items</Title>
    <Description>Fixes #29112 
Fixes #31287 

Tagging @AmadeusW as well

Let us agree how BlockForCompletionItems = false works in the new completion:
1. It does not block GetCompletionContextAsync, Update and Filter.
2. It blocks UIThread when executing CommitIfUnique

Please review TestNoBlockOnCompletionItems* (1-4) tests and let me know if either scenario or tests should be corrected.

Please let me know if you see a better approach for validation rather than one thread waiting for another.

Let us agree here and then include TypeScript and F# for review as well.</Description>
    <CreatedDate>04/12/2018</CreatedDate>
    <ClosedDate>15/01/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>29112</IssueID>
        <Title>Editor Completion -- Support CompletionOptions.BlockForCompletionItems to enable TestNoBlockOnCompletionItems* tests [impacts TypeScript and F#]</Title>
        <Description>**Version Used**: 

**Steps to Reproduce**:

1. 
2. 
3. 

**Expected Behavior**:

**Actual Behavior**:
</Description>
        <CreatedDate>06/08/2018</CreatedDate>
        <ClosedDate>23/01/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>31287</IssueID>
        <Title>async completion: revisit AssertNoCompletionSession for non-blocking scenarios</Title>
        <Description>Wait for 5 seconds looks suspicious.</Description>
        <CreatedDate>20/11/2018</CreatedDate>
        <ClosedDate>15/01/2019</ClosedDate>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>31509</IssueID>
    <Title>completion: some suffixes scenarios</Title>
    <Description>Fixes #30097 and #31504
</Description>
    <CreatedDate>04/12/2018</CreatedDate>
    <ClosedDate>04/12/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>30097</IssueID>
        <Title>Completion MRU alternates two most recently used items</Title>
        <Description>**Version Used**: 
branch `asynccompletion` at ` https://github.com/ivanbasov/roslyn`

**Steps to Reproduce**:

`public double Ma(double m) =&gt; m;`
type the following on the keyboard: `M(M(M(M(`

**Expected Behavior**:

![image](https://user-images.githubusercontent.com/1673956/45902685-17fffb80-bd9c-11e8-97e4-28e0b1a15a07.png)

**Actual Behavior**:

The two MRU items don't alternate, and I get `Ma(Ma(Ma(Ma(` with `Ma` selected as the top completion item</Description>
        <CreatedDate>21/09/2018</CreatedDate>
        <ClosedDate>04/12/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>31504</IssueID>
        <Title>Editor completion: add suffix to display text when sending to editor completion and review prefixes as well</Title>
        <Description>https://github.com/dotnet/roslyn/pull/27694#issuecomment-443890041

&gt; &gt; I should concatenate Roslyn suffixes to the display text here: https://github.com/dotnet/roslyn/blob/master-vs-deps/src/EditorFeatures/Core/Implementation/IntelliSense/AsyncCompletion/CompletionSource.cs#L274
&gt; and do not fill the suffix parameter 4 lines below.
&gt; 
&gt; Yes.  Note: this is only necessary if we don't do the `Completion5.InlineDescription` approach.  I personally think we should take that appraoch as i think there is a case to be made that a suffix is not the same thing as a description.  But i don't feel strongly about it.
&gt; 
&gt; --
&gt; 
&gt; Note: where are you handling DisplayTextPrefix in that code?</Description>
        <CreatedDate>03/12/2018</CreatedDate>
        <ClosedDate>04/12/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/AsyncCompletion/CommitManager.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/AsyncCompletion/CompletionSource.cs</File>
      <File>src/Features/CSharp/Portable/Completion/CompletionProviders/NamedParameterCompletionProvider.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>31025</IssueID>
    <Title>Add CFG based dataflow analysis framework to the Workspaces layer</Title>
    <Description>This PR extracts out the flow-analysis component from #30777 for easier code review.

Support added in this PR:
1. Core dataflow walker to walk the control flow graph and compute/track custom analysis data (CustomDataFlowAnalysis).
2. Internal API (DataFlowAnalyzer) to implement custom dataflow analysis on top of the above walker.
3. Implementation of a SymbolUsageAnalysis dataflow analyzer to compute read/write usages for local and parameter symbols
4. Implementation of a test-only BasicBlockReachabilityDataFlowAnalyzer to compute and validate basic block reachability on all CFGs generated in compiler's flow analysis unit tests.

Please refer to #30777 for the unit tests for SymbolUsageAnalysis. This PR is targeting a feature branch, which will get unit tests from #30777 before it gets merged into master or dev16.0-preview2 branch.</Description>
    <CreatedDate>07/11/2018</CreatedDate>
    <ClosedDate>16/11/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>30777</IssueID>
        <Title>Dataflow analysis based analyzer/fixer to identify unused expression values and parameters</Title>
        <Description>1. **Analyzer** to report unused expression values and parameters. It flags the following cases:
    1. **Expression statements that drop computed value**, for example, `Computation();`. These should either be removed (redundant computation) or should be replaced with explicit assignment to discard variable OR an unused local variable, i.e. `_ = Computation();` or `var unused = Computation();`
    2. **Value assignments to locals/parameters that are never used on any control flow path**. For example, value assigned to 'x' in first statement below is unused and will be flagged:
    ```
        x = Computation();
        if (...)
            x = Computation2();
        else
            Computation3(out x);
        ... = x;
    ```
    Just as for case 1 above, these should either be removed (redundant computation) or should be replaced with explicit assignment to discard variable OR an unused local i.e. `_ = Computation();` or `var unused = Computation();`

     3. **Redundant/unused parameters** that fall into one of the following two categories:
         1. Have no references in the executable code block(s) for it's containing method symbol.
         2. Have one or more references but it's initial value at start of code block is never used. For example, if 'x' in the example for case 2. above was a parameter symbol with `RefKind.None` and `x = Computation();` is the first statement in the method body, then it's initial value is never used. Such a parameter should be removed and 'x' should be converted into a local.
       We provide additional information in the diagnostic message to clarify the above two categories and also detect and mention about potential breaking change if the containing method is a public API. Currently, we do not provide any code fix for removing unused parameters as it needs fixing the call sites and any automated fix can lead to subtle overload resolution differences, though this may change in future.

2. **Code fixer** for unused expression value diagnostics reported by this analyzer providing following code fixes:
    1. If the unused value assigned to a local/parameter has no side-effects, we **recommend removing the assignment**. We consider an expression value to have no side effects if one of the following is true:
        1. Value is a compile time constant.
        2. Value is a local or parameter reference.
        3. Value is a field reference with no or implicit this instance.
    2. Otherwise, if user preference is set to Discard Variable, and project's language version supports discard variable, we **recommend assigning the value to discard**.
    3. Otherwise, we **recommend assigning the value to a new unused local variable which has no reads**.

3. **Implementation details:**
    1. Refactor and generalize the currently implemented reachability dataflow analysis in the compiler layer that works on internal CFG builder data types so that it works with custom data and public BasicBlock and ControlFlowBranch types.
    2. Move the above analysis into separate files that can be linked into both the Compiler and Workspaces layer to enable writing custom dataflow analysis in the IDE layer.
    3. The two primary (internal) types for implementing custom dataflow analysis are:
         1. `IDataFlowAnalyzer`: The dataflow analyzer type defines the custom data being tracked per basic block, the transfer and merge functions for dataflow across blocks and AnalyzeBlock and AnalyzerXXXBranch functions for analyzing dataflow within basic blocks and control flow branches.
         2. `CustomDataFlowAnalysis`: This types exposes a static method that runs dataflow analysis on the given control flow graph using the given dataflow analyzer, until fix point is reached and returns the analysis data at the end of the Exit block.
    4. Use the above dataflow framework to implement a custom reaching definition dataflow analysis to compute the set of reaching definitions (value writes) for local/parameter symbols in a method body, along with a boolean indicating whether or not each definition may be read on at least one possible control flow path, false indicating an unused/redundant definition that is flagged by the analyzer.
    
**TODO:** Finalize the editorconfig options for the analyzer/code fix and implement the Tools/Options UI for the same.</Description>
        <CreatedDate>26/10/2018</CreatedDate>
        <ClosedDate>27/11/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>30777</IssueID>
        <Title>Dataflow analysis based analyzer/fixer to identify unused expression values and parameters</Title>
        <Description>1. **Analyzer** to report unused expression values and parameters. It flags the following cases:
    1. **Expression statements that drop computed value**, for example, `Computation();`. These should either be removed (redundant computation) or should be replaced with explicit assignment to discard variable OR an unused local variable, i.e. `_ = Computation();` or `var unused = Computation();`
    2. **Value assignments to locals/parameters that are never used on any control flow path**. For example, value assigned to 'x' in first statement below is unused and will be flagged:
    ```
        x = Computation();
        if (...)
            x = Computation2();
        else
            Computation3(out x);
        ... = x;
    ```
    Just as for case 1 above, these should either be removed (redundant computation) or should be replaced with explicit assignment to discard variable OR an unused local i.e. `_ = Computation();` or `var unused = Computation();`

     3. **Redundant/unused parameters** that fall into one of the following two categories:
         1. Have no references in the executable code block(s) for it's containing method symbol.
         2. Have one or more references but it's initial value at start of code block is never used. For example, if 'x' in the example for case 2. above was a parameter symbol with `RefKind.None` and `x = Computation();` is the first statement in the method body, then it's initial value is never used. Such a parameter should be removed and 'x' should be converted into a local.
       We provide additional information in the diagnostic message to clarify the above two categories and also detect and mention about potential breaking change if the containing method is a public API. Currently, we do not provide any code fix for removing unused parameters as it needs fixing the call sites and any automated fix can lead to subtle overload resolution differences, though this may change in future.

2. **Code fixer** for unused expression value diagnostics reported by this analyzer providing following code fixes:
    1. If the unused value assigned to a local/parameter has no side-effects, we **recommend removing the assignment**. We consider an expression value to have no side effects if one of the following is true:
        1. Value is a compile time constant.
        2. Value is a local or parameter reference.
        3. Value is a field reference with no or implicit this instance.
    2. Otherwise, if user preference is set to Discard Variable, and project's language version supports discard variable, we **recommend assigning the value to discard**.
    3. Otherwise, we **recommend assigning the value to a new unused local variable which has no reads**.

3. **Implementation details:**
    1. Refactor and generalize the currently implemented reachability dataflow analysis in the compiler layer that works on internal CFG builder data types so that it works with custom data and public BasicBlock and ControlFlowBranch types.
    2. Move the above analysis into separate files that can be linked into both the Compiler and Workspaces layer to enable writing custom dataflow analysis in the IDE layer.
    3. The two primary (internal) types for implementing custom dataflow analysis are:
         1. `IDataFlowAnalyzer`: The dataflow analyzer type defines the custom data being tracked per basic block, the transfer and merge functions for dataflow across blocks and AnalyzeBlock and AnalyzerXXXBranch functions for analyzing dataflow within basic blocks and control flow branches.
         2. `CustomDataFlowAnalysis`: This types exposes a static method that runs dataflow analysis on the given control flow graph using the given dataflow analyzer, until fix point is reached and returns the analysis data at the end of the Exit block.
    4. Use the above dataflow framework to implement a custom reaching definition dataflow analysis to compute the set of reaching definitions (value writes) for local/parameter symbols in a method body, along with a boolean indicating whether or not each definition may be read on at least one possible control flow path, false indicating an unused/redundant definition that is flagged by the analyzer.
    
**TODO:** Finalize the editorconfig options for the analyzer/code fix and implement the Tools/Options UI for the same.</Description>
        <CreatedDate>26/10/2018</CreatedDate>
        <ClosedDate>27/11/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>30777</IssueID>
        <Title>Dataflow analysis based analyzer/fixer to identify unused expression values and parameters</Title>
        <Description>1. **Analyzer** to report unused expression values and parameters. It flags the following cases:
    1. **Expression statements that drop computed value**, for example, `Computation();`. These should either be removed (redundant computation) or should be replaced with explicit assignment to discard variable OR an unused local variable, i.e. `_ = Computation();` or `var unused = Computation();`
    2. **Value assignments to locals/parameters that are never used on any control flow path**. For example, value assigned to 'x' in first statement below is unused and will be flagged:
    ```
        x = Computation();
        if (...)
            x = Computation2();
        else
            Computation3(out x);
        ... = x;
    ```
    Just as for case 1 above, these should either be removed (redundant computation) or should be replaced with explicit assignment to discard variable OR an unused local i.e. `_ = Computation();` or `var unused = Computation();`

     3. **Redundant/unused parameters** that fall into one of the following two categories:
         1. Have no references in the executable code block(s) for it's containing method symbol.
         2. Have one or more references but it's initial value at start of code block is never used. For example, if 'x' in the example for case 2. above was a parameter symbol with `RefKind.None` and `x = Computation();` is the first statement in the method body, then it's initial value is never used. Such a parameter should be removed and 'x' should be converted into a local.
       We provide additional information in the diagnostic message to clarify the above two categories and also detect and mention about potential breaking change if the containing method is a public API. Currently, we do not provide any code fix for removing unused parameters as it needs fixing the call sites and any automated fix can lead to subtle overload resolution differences, though this may change in future.

2. **Code fixer** for unused expression value diagnostics reported by this analyzer providing following code fixes:
    1. If the unused value assigned to a local/parameter has no side-effects, we **recommend removing the assignment**. We consider an expression value to have no side effects if one of the following is true:
        1. Value is a compile time constant.
        2. Value is a local or parameter reference.
        3. Value is a field reference with no or implicit this instance.
    2. Otherwise, if user preference is set to Discard Variable, and project's language version supports discard variable, we **recommend assigning the value to discard**.
    3. Otherwise, we **recommend assigning the value to a new unused local variable which has no reads**.

3. **Implementation details:**
    1. Refactor and generalize the currently implemented reachability dataflow analysis in the compiler layer that works on internal CFG builder data types so that it works with custom data and public BasicBlock and ControlFlowBranch types.
    2. Move the above analysis into separate files that can be linked into both the Compiler and Workspaces layer to enable writing custom dataflow analysis in the IDE layer.
    3. The two primary (internal) types for implementing custom dataflow analysis are:
         1. `IDataFlowAnalyzer`: The dataflow analyzer type defines the custom data being tracked per basic block, the transfer and merge functions for dataflow across blocks and AnalyzeBlock and AnalyzerXXXBranch functions for analyzing dataflow within basic blocks and control flow branches.
         2. `CustomDataFlowAnalysis`: This types exposes a static method that runs dataflow analysis on the given control flow graph using the given dataflow analyzer, until fix point is reached and returns the analysis data at the end of the Exit block.
    4. Use the above dataflow framework to implement a custom reaching definition dataflow analysis to compute the set of reaching definitions (value writes) for local/parameter symbols in a method body, along with a boolean indicating whether or not each definition may be read on at least one possible control flow path, false indicating an unused/redundant definition that is flagged by the analyzer.
    
**TODO:** Finalize the editorconfig options for the analyzer/code fix and implement the Tools/Options UI for the same.</Description>
        <CreatedDate>26/10/2018</CreatedDate>
        <ClosedDate>27/11/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/Core/Portable/Operations/ControlFlowGraphBuilder.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/ControlFlowGraphVerifier.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/FlowAnalysis/BasicBlockReachabilityDataFlowAnalyzer.cs</File>
      <File>src/Workspaces/Core/Portable/Extensions/BasicBlockExtensions.cs</File>
      <File>src/Workspaces/Core/Portable/Extensions/ControlFlowGraphExtensions.cs</File>
      <File>src/Workspaces/Core/Portable/Extensions/ControlFlowRegionExtensions.cs</File>
      <File>src/Workspaces/Core/Portable/Extensions/OperationExtensions.cs</File>
      <File>src/Workspaces/Core/Portable/FlowAnalysis/CustomDataFlowAnalysis.cs</File>
      <File>src/Workspaces/Core/Portable/FlowAnalysis/DataFlowAnalyzer.cs</File>
      <File>src/Workspaces/Core/Portable/FlowAnalysis/LValueFlowCaptureProvider.cs</File>
      <File>src/Workspaces/Core/Portable/FlowAnalysis/SymbolUsageAnalysis/SymbolUsageAnalysis.AnalysisData.cs</File>
      <File>src/Workspaces/Core/Portable/FlowAnalysis/SymbolUsageAnalysis/SymbolUsageAnalysis.BasicBlockAnalysisData.cs</File>
      <File>src/Workspaces/Core/Portable/FlowAnalysis/SymbolUsageAnalysis/SymbolUsageAnalysis.DataFlowAnalyzer.FlowGraphAnalysisData.cs</File>
      <File>src/Workspaces/Core/Portable/FlowAnalysis/SymbolUsageAnalysis/SymbolUsageAnalysis.DataFlowAnalyzer.cs</File>
      <File>src/Workspaces/Core/Portable/FlowAnalysis/SymbolUsageAnalysis/SymbolUsageAnalysis.OperationTreeAnalysisData.cs</File>
      <File>src/Workspaces/Core/Portable/FlowAnalysis/SymbolUsageAnalysis/SymbolUsageAnalysis.Walker.cs</File>
      <File>src/Workspaces/Core/Portable/FlowAnalysis/SymbolUsageAnalysis/SymbolUsageAnalysis.cs</File>
      <File>src/Workspaces/Core/Portable/FlowAnalysis/SymbolUsageAnalysis/SymbolUsageResult.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>30980</IssueID>
    <Title>Workaround in RemoveUnusedMembersDiagnosticAnalyzer for VB handles cl…</Title>
    <Description>…ause

Fixes #30895

This analyzer does not function correctly in presence of VB handles clause due to IOperation bugs #30978 and #30979. This change adds a temporary workaround to the analyzer to handle this case specially.

~~TODO: File a bug to track reverting the temporary workaround once #30978 and #30979 are fixed.~~ Filed https://github.com/dotnet/roslyn/issues/30981</Description>
    <CreatedDate>06/11/2018</CreatedDate>
    <ClosedDate>08/11/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>30895</IssueID>
        <Title>IDE0052 fires on WithEvents that are used by Handles</Title>
        <Description>``` VB
Private WithEvents _buildEvents As EnvDTE.BuildEvents
[...]

Private Sub BuildBegin(scope As EnvDTE.vsBuildScope, action As EnvDTE.vsBuildAction) Handles _buildEvents.OnBuildBegin

End Sub

```

Expected: No warning
Actual:

```
Severity	Code	Description	Project	Project Rank	File	Line	Category	Suppression State	Tool
Message	IDE0052	Private member 'ResourceEditorRootDesigner._buildEvents' can be removed as the value assigned to it is never read.	Microsoft.VisualStudio.Editors	3	E:\project-system2\src\Microsoft.VisualStudio.Editors\ResourceEditor\ResourceEditorRootDesigner.vb	70	Code Quality	Active	Compiler
```</Description>
        <CreatedDate>01/11/2018</CreatedDate>
        <ClosedDate>08/11/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>30978</IssueID>
        <Title>SemanticModel.GetOperation fails for any node within the VB handles clause sub-tree</Title>
        <Description>Invoking `SemanticModel.GetOperation` on any node within the `HandlesClauseSyntax` returns null. For example, consider the below code:

```
Public Interface I
    Event M()
End Interface

Public Class C
    Private WithEvents _field1 As I

    Private Sub M() Handles _field1.M
    End Sub
End Class
```

![image](https://user-images.githubusercontent.com/10605811/48068201-0ffeee00-e187-11e8-99d2-f7c7096004f1.png)

This leads to no `IMemberReferenceOperation` generated for references to members within the handles clause, causing incorrect functioning for IOperation analyzers analyzing references to members. For example, see https://github.com/dotnet/roslyn/issues/30895

Investigating further, I found that this is due to the fact VB uses a special binder to [bind the handles clause](http://source.roslyn.io/#Microsoft.CodeAnalysis.VisualBasic/Symbols/Source/SourceMemberMethodSymbol.vb,584), which is not part of the binder chain, and there is no corresponding member semantic model for positions within the handles clause.</Description>
        <CreatedDate>06/11/2018</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>30979</IssueID>
        <Title>AnalyzerDriver does should add executable code blocks for VB handles clause</Title>
        <Description>There are couple of compiler/analyzer issues related to IOperations in regards to VB handles clause:

1. https://github.com/dotnet/roslyn/issues/30978: Core bug in `GetOperation` causing the compiler to never return operations within VB handles clause.
2. `VisualBasicDeclarationComputer.vb` never marks nodes within VB handles clause as executable code, which leads to the analyzer driver never attempting to invoke GetOperation within these nodes, and hence never making analyzer callbacks for operations within handles clause. https://github.com/mavasani/roslyn/commit/8e3e8e83751f2118c27bd866b4785b1f347d7658 fixes this issue, but needs to go in after https://github.com/dotnet/roslyn/issues/30978 has been fixed.

This bug tracks issue 2. above in the VB declaration computer.</Description>
        <CreatedDate>06/11/2018</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>30978</IssueID>
        <Title>SemanticModel.GetOperation fails for any node within the VB handles clause sub-tree</Title>
        <Description>Invoking `SemanticModel.GetOperation` on any node within the `HandlesClauseSyntax` returns null. For example, consider the below code:

```
Public Interface I
    Event M()
End Interface

Public Class C
    Private WithEvents _field1 As I

    Private Sub M() Handles _field1.M
    End Sub
End Class
```

![image](https://user-images.githubusercontent.com/10605811/48068201-0ffeee00-e187-11e8-99d2-f7c7096004f1.png)

This leads to no `IMemberReferenceOperation` generated for references to members within the handles clause, causing incorrect functioning for IOperation analyzers analyzing references to members. For example, see https://github.com/dotnet/roslyn/issues/30895

Investigating further, I found that this is due to the fact VB uses a special binder to [bind the handles clause](http://source.roslyn.io/#Microsoft.CodeAnalysis.VisualBasic/Symbols/Source/SourceMemberMethodSymbol.vb,584), which is not part of the binder chain, and there is no corresponding member semantic model for positions within the handles clause.</Description>
        <CreatedDate>06/11/2018</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>30979</IssueID>
        <Title>AnalyzerDriver does should add executable code blocks for VB handles clause</Title>
        <Description>There are couple of compiler/analyzer issues related to IOperations in regards to VB handles clause:

1. https://github.com/dotnet/roslyn/issues/30978: Core bug in `GetOperation` causing the compiler to never return operations within VB handles clause.
2. `VisualBasicDeclarationComputer.vb` never marks nodes within VB handles clause as executable code, which leads to the analyzer driver never attempting to invoke GetOperation within these nodes, and hence never making analyzer callbacks for operations within handles clause. https://github.com/mavasani/roslyn/commit/8e3e8e83751f2118c27bd866b4785b1f347d7658 fixes this issue, but needs to go in after https://github.com/dotnet/roslyn/issues/30978 has been fixed.

This bug tracks issue 2. above in the VB declaration computer.</Description>
        <CreatedDate>06/11/2018</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Features/Core/Portable/RemoveUnusedMembers/AbstractRemoveUnusedMembersDiagnosticAnalyzer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>30969</IssueID>
    <Title>Add regression test for attribute with async delegate parameter</Title>
    <Description>Resolves #30833 

This test should prevent the error described in #30833 from recurring. It **passes on master** but on the **15.9 branch** it produces the following error:

```
Microsoft.CodeAnalysis.CSharp.UnitTests.AttributeTests.AttributeWithTaskDelegateParameter [FAIL]
    System.AggregateException : One or more errors occurred.
    ---- System.AggregateException : One or more errors occurred.
    -------- System.NullReferenceException : Object reference not set to an instance of an object.
    Stack Trace:
        at System.Threading.Tasks.Task.ThrowIfExceptional(Boolean includeTaskCanceledExceptions)
        at System.Threading.Tasks.Task.Wait(Int32 millisecondsTimeout, CancellationToken cancellationToken)
        at System.Threading.Tasks.Parallel.ForWorker[TLocal](Int32 fromInclusive, Int32 toExclusive, ParallelOptions parallelOptions, Action`1 body, Action`2 bodyWithState, Func`4 bodyWithLocal, Func`1 localInit, Action`1 localFinally)
        at System.Threading.Tasks.Parallel.For(Int32 fromInclusive, Int32 toExclusive, ParallelOptions parallelOptions, Action`1 body)
    src\Compilers\CSharp\Portable\Symbols\Source\SourceNamespaceSymbol_Completion.cs(53,0): at Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamespaceSymbol.ForceComplete(SourceLocation locationOpt, CancellationToken cancellationToken)
    src\Compilers\CSharp\Portable\Symbols\Source\SourceModuleSymbol.cs(258,0): at Microsoft.CodeAnalysis.CSharp.Symbols.SourceModuleSymbol.ForceComplete(SourceLocation locationOpt, CancellationToken cancellationToken)
    src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs(908,0): at Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol.ForceComplete(SourceLocation locationOpt, CancellationToken cancellationToken)
    src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs(2308,0): at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetSourceDeclarationDiagnostics(SyntaxTree syntaxTree, Nullable`1 filterSpanWithinTree, Func`4 locationFilterOpt, CancellationToken cancellationToken)
    src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs(2195,0): at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnostics(CompilationStage stage, Boolean includeEarlierStages, DiagnosticBag diagnostics, CancellationToken cancellationToken)
    src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs(2131,0): at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnostics(CompilationStage stage, Boolean includeEarlierStages, CancellationToken cancellationToken)
    src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs(2125,0): at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnostics(CancellationToken cancellationToken)
    src\Test\Utilities\Portable\Diagnostics\DiagnosticExtensions.cs(98,0): at Microsoft.CodeAnalysis.DiagnosticExtensions.VerifyDiagnostics[TCompilation](TCompilation c, DiagnosticDescription[] expected)
    src\Compilers\CSharp\Test\Emit\Attributes\AttributeTests.cs(8948,0): at Microsoft.CodeAnalysis.CSharp.UnitTests.AttributeTests.AttributeWithTaskDelegateParameter()
    ----- Inner Stack Trace -----
        at System.Threading.Tasks.Task.ThrowIfExceptional(Boolean includeTaskCanceledExceptions)
        at System.Threading.Tasks.Task.Wait(Int32 millisecondsTimeout, CancellationToken cancellationToken)
        at System.Threading.Tasks.Parallel.ForWorker[TLocal](Int32 fromInclusive, Int32 toExclusive, ParallelOptions parallelOptions, Action`1 body, Action`2 bodyWithState, Func`4 bodyWithLocal, Func`1 localInit, Action`1 localFinally)
        at System.Threading.Tasks.Parallel.For(Int32 fromInclusive, Int32 toExclusive, ParallelOptions parallelOptions, Action`1 body)
    src\Compilers\CSharp\Portable\Symbols\Source\SourceNamespaceSymbol_Completion.cs(53,0): at Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamespaceSymbol.ForceComplete(SourceLocation locationOpt, CancellationToken cancellationToken)
    src\Compilers\CSharp\Portable\Symbols\Symbol.cs(712,0): at Microsoft.CodeAnalysis.CSharp.Symbol.ForceCompleteMemberByLocation(SourceLocation locationOpt, Symbol member, CancellationToken cancellationToken)
    src\Compilers\CSharp\Portable\Symbols\Source\SourceNamespaceSymbol_Completion.cs(56,0): at Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamespaceSymbol.&lt;&gt;c__DisplayClass47_1.&lt;ForceComplete&gt;b__0(Int32 i)
    src\Compilers\Core\Portable\InternalUtilities\UICultureUtilities.cs(166,0): at Roslyn.Utilities.UICultureUtilities.&lt;&gt;c__DisplayClass6_0`1.&lt;WithCurrentUICulture&gt;b__0(T param)
        at System.Threading.Tasks.Parallel.&lt;&gt;c__DisplayClass17_0`1.&lt;ForWorker&gt;b__1()
        at System.Threading.Tasks.Task.InnerInvokeWithArg(Task childTask)
        at System.Threading.Tasks.Task.&lt;&gt;c__DisplayClass176_0.&lt;ExecuteSelfReplicating&gt;b__0(Object )
    ----- Inner Stack Trace -----
    src\Compilers\CSharp\Portable\Symbols\Source\SourceOrdinaryMethodSymbol.cs(686,0): at Microsoft.CodeAnalysis.CSharp.Symbols.SourceOrdinaryMethodSymbol.get_ReturnTypeCustomModifiers()
    src\Compilers\CSharp\Portable\Symbols\SymbolExtensions.cs(381,0): at Microsoft.CodeAnalysis.CSharp.Symbols.SymbolExtensions.GetTypeOrReturnType(Symbol symbol, RefKind&amp; refKind, TypeSymbol&amp; returnType, ImmutableArray`1&amp; returnTypeCustomModifiers, ImmutableArray`1&amp; refCustomModifiers)
    src\Compilers\CSharp\Portable\Symbols\SymbolExtensions.cs(360,0): at Microsoft.CodeAnalysis.CSharp.Symbols.SymbolExtensions.GetTypeOrReturnType(Symbol symbol)
    src\Compilers\CSharp\Portable\Binder\Binder_Conversions.cs(653,0): at Microsoft.CodeAnalysis.CSharp.Binder.MemberGroupFinalValidationAccessibilityChecks(BoundExpression receiverOpt, Symbol memberSymbol, SyntaxNode node, DiagnosticBag diagnostics, Boolean invokedAsExtensionMethod)
    src\Compilers\CSharp\Portable\Binder\Binder_Conversions.cs(499,0): at Microsoft.CodeAnalysis.CSharp.Binder.MemberGroupFinalValidation(BoundExpression receiverOpt, MethodSymbol methodSymbol, SyntaxNode node, DiagnosticBag diagnostics, Boolean invokedAsExtensionMethod)
    src\Compilers\CSharp\Portable\Binder\Binder_Conversions.cs(812,0): at Microsoft.CodeAnalysis.CSharp.Binder.MethodGroupConversionHasErrors(SyntaxNode syntax, Conversion conversion, BoundExpression receiverOpt, Boolean isExtensionMethod, NamedTypeSymbol delegateType, DiagnosticBag diagnostics)
    src\Compilers\CSharp\Portable\Binder\Binder_Conversions.cs(314,0): at Microsoft.CodeAnalysis.CSharp.Binder.CreateMethodGroupConversion(SyntaxNode syntax, BoundExpression source, Conversion conversion, Boolean isCast, TypeSymbol destination, DiagnosticBag diagnostics)
    src\Compilers\CSharp\Portable\Binder\Binder_Conversions.cs(90,0): at Microsoft.CodeAnalysis.CSharp.Binder.CreateConversion(SyntaxNode syntax, BoundExpression source, Conversion conversion, Boolean isCast, Boolean wasCompilerGenerated, TypeSymbol destination, DiagnosticBag diagnostics)
    src\Compilers\CSharp\Portable\Binder\Binder_Conversions.cs(46,0): at Microsoft.CodeAnalysis.CSharp.Binder.CreateConversion(SyntaxNode syntax, BoundExpression source, Conversion conversion, Boolean isCast, TypeSymbol destination, DiagnosticBag diagnostics)
    src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs(2539,0): at Microsoft.CodeAnalysis.CSharp.Binder.CoerceArguments[TMember](MemberResolutionResult`1 methodResult, ArrayBuilder`1 arguments, DiagnosticBag diagnostics)
    src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs(4983,0): at Microsoft.CodeAnalysis.CSharp.Binder.TryPerformConstructorOverloadResolution(NamedTypeSymbol typeContainingConstructors, AnalyzedArguments analyzedArguments, String errorName, Location errorLocation, Boolean suppressResultDiagnostics, DiagnosticBag diagnostics, MemberResolutionResult`1&amp; memberResolutionResult, ImmutableArray`1&amp; candidateConstructors, Boolean allowProtectedConstructorsOfBaseType)
    src\Compilers\CSharp\Portable\Binder\Binder_Attributes.cs(498,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindAttributeConstructor(AttributeSyntax node, NamedTypeSymbol attributeType, AnalyzedArguments boundConstructorArguments, DiagnosticBag diagnostics, LookupResultKind&amp; resultKind, Boolean suppressErrors, HashSet`1&amp; useSiteDiagnostics)
    src\Compilers\CSharp\Portable\Binder\Binder_Attributes.cs(152,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindAttributeCore(AttributeSyntax node, NamedTypeSymbol attributeType, DiagnosticBag diagnostics)
    src\Compilers\CSharp\Portable\Binder\Binder_Attributes.cs(105,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindAttribute(AttributeSyntax node, NamedTypeSymbol attributeType, DiagnosticBag diagnostics)
    src\Compilers\CSharp\Portable\Binder\Binder_Attributes.cs(98,0): at Microsoft.CodeAnalysis.CSharp.Binder.GetAttribute(AttributeSyntax node, NamedTypeSymbol boundAttributeType, DiagnosticBag diagnostics)
    src\Compilers\CSharp\Portable\Binder\Binder_Attributes.cs(74,0): at Microsoft.CodeAnalysis.CSharp.Binder.GetAttributes(ImmutableArray`1 binders, ImmutableArray`1 attributesToBind, ImmutableArray`1 boundAttributeTypes, CSharpAttributeData[] attributesBuilder, DiagnosticBag diagnostics)
    src\Compilers\CSharp\Portable\Symbols\Symbol_Attributes.cs(317,0): at Microsoft.CodeAnalysis.CSharp.Symbol.LoadAndValidateAttributes(OneOrMany`1 attributesSyntaxLists, CustomAttributesBag`1&amp; lazyCustomAttributesBag, AttributeLocation symbolPart, Boolean earlyDecodingOnly, Binder binderOpt, Func`2 attributeMatchesOpt)
    src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs(1010,0): at Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberMethodSymbol.GetAttributesBag(CustomAttributesBag`1&amp; lazyCustomAttributesBag, Boolean forReturnType)
    src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs(968,0): at Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberMethodSymbol.GetAttributesBag()
    src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs(931,0): at Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberMethodSymbol.GetDecodedWellKnownAttributeData()
    src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs(1597,0): at Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberMethodSymbol.get_ImplementationAttributes()
    src\Compilers\CSharp\Portable\Symbols\Source\SourceOrdinaryMethodSymbol.cs(434,0): at Microsoft.CodeAnalysis.CSharp.Symbols.SourceOrdinaryMethodSymbol.LazyAsyncMethodChecks(CancellationToken cancellationToken)
    src\Compilers\CSharp\Portable\Symbols\Source\SourceOrdinaryMethodSymbol.cs(292,0): at Microsoft.CodeAnalysis.CSharp.Symbols.SourceOrdinaryMethodSymbol.MethodChecks(MethodDeclarationSyntax syntax, Binder withTypeParamsBinder, DiagnosticBag diagnostics)
    src\Compilers\CSharp\Portable\Symbols\Source\SourceOrdinaryMethodSymbol.cs(472,0): at Microsoft.CodeAnalysis.CSharp.Symbols.SourceOrdinaryMethodSymbol.MethodChecks(DiagnosticBag diagnostics)
    src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs(293,0): at Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberMethodSymbol.LazyMethodChecks()
    src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs(743,0): at Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberMethodSymbol.get_OverriddenOrHiddenMembers()
    src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol_ImplementationChecks.cs(392,0): at Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.CheckMembersAgainstBaseType(DiagnosticBag diagnostics, CancellationToken cancellationToken)
    src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol_ImplementationChecks.cs(31,0): at Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.GetSynthesizedExplicitImplementations(CancellationToken cancellationToken)
    src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs(499,0): at Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.ForceComplete(SourceLocation locationOpt, CancellationToken cancellationToken)
    src\Compilers\CSharp\Portable\Symbols\Symbol.cs(712,0): at Microsoft.CodeAnalysis.CSharp.Symbol.ForceCompleteMemberByLocation(SourceLocation locationOpt, Symbol member, CancellationToken cancellationToken)
    src\Compilers\CSharp\Portable\Symbols\Source\SourceNamespaceSymbol_Completion.cs(56,0): at Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamespaceSymbol.&lt;&gt;c__DisplayClass47_1.&lt;ForceComplete&gt;b__0(Int32 i)
    src\Compilers\Core\Portable\InternalUtilities\UICultureUtilities.cs(166,0): at Roslyn.Utilities.UICultureUtilities.&lt;&gt;c__DisplayClass6_0`1.&lt;WithCurrentUICulture&gt;b__0(T param)
        at System.Threading.Tasks.Parallel.&lt;&gt;c__DisplayClass17_0`1.&lt;ForWorker&gt;b__1()
        at System.Threading.Tasks.Task.InnerInvokeWithArg(Task childTask)
        at System.Threading.Tasks.Task.&lt;&gt;c__DisplayClass176_0.&lt;ExecuteSelfReplicating&gt;b__0(Object )
```

Note that this doesn't actually test emit because attributes can't actually take delegate arguments. This is kind of an attribute test, though, and it seems independent from the GetSymbolInfo API. Where should this actually go?</Description>
    <CreatedDate>05/11/2018</CreatedDate>
    <ClosedDate>06/11/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>30833</IssueID>
        <Title>VS crash with specifically crafted attributes</Title>
        <Description>**Version Used**: VS 15.7.1 

**Steps to Reproduce**:

Paste this into Visual Studio and let it analyze it
```
using System;
using System.Collections.Generic;
using System.Text;

namespace a
{
    class Class1
    {
		[AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]
		class CommandAttribute : Attribute
		{
			public delegate Task FxCommand();

			public CommandAttribute(FxCommand Fx)
			{
				this.Fx = Fx;
			}

			public FxCommand Fx { get; set; }
		}
		
		[Command(UserInfo)]
		public static async Task UserInfo()
		{
			
		}
	}
}
```

**Expected Behavior**:

Error or something

**Actual Behavior**:

Visual studio crashes</Description>
        <CreatedDate>29/10/2018</CreatedDate>
        <ClosedDate>06/11/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>30833</IssueID>
        <Title>VS crash with specifically crafted attributes</Title>
        <Description>**Version Used**: VS 15.7.1 

**Steps to Reproduce**:

Paste this into Visual Studio and let it analyze it
```
using System;
using System.Collections.Generic;
using System.Text;

namespace a
{
    class Class1
    {
		[AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]
		class CommandAttribute : Attribute
		{
			public delegate Task FxCommand();

			public CommandAttribute(FxCommand Fx)
			{
				this.Fx = Fx;
			}

			public FxCommand Fx { get; set; }
		}
		
		[Command(UserInfo)]
		public static async Task UserInfo()
		{
			
		}
	}
}
```

**Expected Behavior**:

Error or something

**Actual Behavior**:

Visual studio crashes</Description>
        <CreatedDate>29/10/2018</CreatedDate>
        <ClosedDate>06/11/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Test/Emit/Attributes/AttributeTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>30961</IssueID>
    <Title>Ensure PinnedRemotableDataScope is disposed</Title>
    <Description>Fixes #30271

### Customer scenario

Under unknown situations, the IDE crashes due to a failure to clean up a database resource.

### Bugs this fixes

#30271 
https://devdiv.visualstudio.com/DevDiv/_workitems/edit/671157

### Workarounds, if any

None.

### Risk

Low. This pull request cannot alter execution behavior except on a code path which was certain to crash the IDE.

### Performance impact

N/A

### Is this a regression from a previous update?

No.

### Root cause analysis

Found by Watson. The steps to reproduce this issue are unknown.

### How was the bug found?

Watson.

### Test documentation updated?

N/A

</Description>
    <CreatedDate>05/11/2018</CreatedDate>
    <ClosedDate>06/11/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>30271</IssueID>
        <Title>Fix failure to dispose 'scope' after failure to dispose 'connection'</Title>
        <Description>In the following code, an exception during the call to `connection.Dispose` will result in `scope` not getting disposed. This eventually leads to an exception in the finalizer of `PinnedRemotableDataScope`.

https://github.com/dotnet/roslyn/blob/1f082e40860963edcd81d1567069aae924d9369f/src/Workspaces/Core/Portable/Remote/RemoteHostSessionHelpers.cs#L43-L46

:link: https://devdiv.visualstudio.com/DevDiv/_workitems/edit/671157</Description>
        <CreatedDate>02/10/2018</CreatedDate>
        <ClosedDate>08/11/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>30271</IssueID>
        <Title>Fix failure to dispose 'scope' after failure to dispose 'connection'</Title>
        <Description>In the following code, an exception during the call to `connection.Dispose` will result in `scope` not getting disposed. This eventually leads to an exception in the finalizer of `PinnedRemotableDataScope`.

https://github.com/dotnet/roslyn/blob/1f082e40860963edcd81d1567069aae924d9369f/src/Workspaces/Core/Portable/Remote/RemoteHostSessionHelpers.cs#L43-L46

:link: https://devdiv.visualstudio.com/DevDiv/_workitems/edit/671157</Description>
        <CreatedDate>02/10/2018</CreatedDate>
        <ClosedDate>08/11/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Workspaces/Core/Portable/Remote/RemoteHostSessionHelpers.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>30916</IssueID>
    <Title>Allow VisualStudioExperimentationService to initialize on a background thread</Title>
    <Description>Fixes #30892 

### Customer scenario

When the first Roslyn document opened in the editor is opened via the Navigate To feature, the Roslyn package fails to load and its IDE features are missing substantial functionality.

### Bugs this fixes

#30892
https://devdiv.visualstudio.com/DevDiv/_workitems/edit/725190

### Workarounds, if any

Open a source document before using Navigate To.

### Risk

Low. In the event other initialization code has bugs (fails to follow required threading rules of the host application), the IDE could hang (deadlock) during the test scenario. However, this is unlikely to result in loss of data because changes cannot be made to most source documents prior to opening the first source document.

### Performance impact

Code paths are not altered outside of the broken scenario.

### Is this a regression from a previous update?

Unknown.

### Root cause analysis

Manual testing scenarios should be updated to cover this case.

### How was the bug found?

Internal report.

### Test documentation updated?

Not yet.
</Description>
    <CreatedDate>01/11/2018</CreatedDate>
    <ClosedDate>08/11/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>30892</IssueID>
        <Title>Package load failure when trying to lauch Navigate To after opening a solution</Title>
        <Description>**Version Used**: VS 16.0 P1 build 28231.51.d16.0

**Steps to Reproduce**:

1. Open a solution in VS without any files open in the editor
2. Ctrl + , to launch Navigate To
3. Search for some type

Note: Problem does not repro if you already had some files from the solution open in the editor at the point where Navigate To was launched.

**Expected Behavior**: Should succeed

**Actual Behavior**: Following package load failure error -

![image](https://user-images.githubusercontent.com/10579684/47826323-7d002700-dd34-11e8-874d-0213e1d24703.png)

On debugging the underlying issue appears to be that `AbstractNavigateToSearchService` is trying to instantiate `VisualStudioExperimentationService` from the background thread resulting in an `InvalidOperationException` from the following `Contract.ThrowIfFalse()` call.

**Dump file**: Available at `\\&lt;internalshare&gt;\\&lt;myfolder&gt;\Dumps\RoslynPackageLoad`

```
      Microsoft.CodeAnalysis.Workspaces.dll!Roslyn.Utilities.Contract.ThrowIfFalse(bool condition, string message) Line 32  C#
Microsoft.CodeAnalysis.EditorFeatures.dll!Microsoft.CodeAnalysis.Editor.Shared.Utilities.ForegroundThreadAffinitizedObject.AssertIsForeground() Line 56   C#
Microsoft.CodeAnalysis.EditorFeatures.dll!Microsoft.CodeAnalysis.Editor.Shared.Utilities.ForegroundThreadAffinitizedObject.ForegroundThreadAffinitizedObject(Microsoft.CodeAnalysis.Editor.Shared.Utilities.IThreadingContext threadingContext, bool assertIsForeground) Line 34   C#
&gt; Microsoft.VisualStudio.LanguageServices.dll!Microsoft.VisualStudio.LanguageServices.Experimentation.VisualStudioExperimentationService.VisualStudioExperimentationService(Microsoft.CodeAnalysis.Editor.Shared.Utilities.IThreadingContext threadingContext, Microsoft.VisualStudio.Shell.SVsServiceProvider serviceProvider) Line 27   C#
              [Native to Managed Transition]      
              [Managed to Native Transition]      
Microsoft.VisualStudio.Composition.dll!Microsoft.VisualStudio.Composition.ReflectionHelpers.Instantiate(System.Reflection.MethodBase ctorOrFactoryMethod, object[] arguments) Line 595  C#
Microsoft.VisualStudio.Composition.dll!Microsoft.VisualStudio.Composition.RuntimeExportProviderFactory.RuntimeExportProvider.RuntimePartLifecycleTracker.CreateValue() Line 517 C#
Microsoft.VisualStudio.Composition.dll!Microsoft.VisualStudio.Composition.ExportProvider.PartLifecycleTracker.Create() Line 1160             C#
Microsoft.VisualStudio.Composition.dll!Microsoft.VisualStudio.Composition.ExportProvider.PartLifecycleTracker.MoveNext(Microsoft.VisualStudio.Composition.ExportProvider.PartLifecycleState nextState) Line 1255          C#
Microsoft.VisualStudio.Composition.dll!Microsoft.VisualStudio.Composition.ExportProvider.PartLifecycleTracker.MoveToState(Microsoft.VisualStudio.Composition.ExportProvider.PartLifecycleState requiredState) Line 1336   C#
Microsoft.VisualStudio.Composition.dll!Microsoft.VisualStudio.Composition.ExportProvider.PartLifecycleTracker.GetValueReadyToExpose() Line 1061             C#
Microsoft.VisualStudio.Composition.dll!Microsoft.VisualStudio.Composition.ExportProvider.CreateExport.AnonymousMethod__0() Line 461 C#
              mscorlib.dll!System.Lazy&lt;object&gt;.CreateValue() Line 437         C#
              mscorlib.dll!System.Lazy&lt;object&gt;.LazyInitValue() Line 388       C#
              mscorlib.dll!System.Lazy&lt;object&gt;.Value.get() Line 339             C#
Microsoft.VisualStudio.Composition.dll!Microsoft.VisualStudio.Composition.NetFxAdapters.MefV1ExportProvider.UnwrapExport.AnonymousMethod__1() Line 246 C#
System.ComponentModel.Composition.dll!System.ComponentModel.Composition.Primitives.Export.GetExportedValueCore() Line 247 C#
System.ComponentModel.Composition.dll!System.ComponentModel.Composition.Primitives.Export.Value.get() Line 207 C#
System.ComponentModel.Composition.dll!System.ComponentModel.Composition.ExportServices.GetCastedExportedValue&lt;Microsoft.CodeAnalysis.Host.IWorkspaceService&gt;(System.ComponentModel.Composition.Primitives.Export export) Line 135  C#
System.ComponentModel.Composition.dll!System.ComponentModel.Composition.ExportServices.CreateStronglyTypedLazyOfTM.AnonymousMethod__1() Line 88   C#
mscorlib.dll!System.Lazy&lt;Microsoft.CodeAnalysis.Host.IWorkspaceService&gt;.CreateValue() Line 437 C#
mscorlib.dll!System.Lazy&lt;Microsoft.CodeAnalysis.Host.IWorkspaceService&gt;.LazyInitValue() Line 359 C#
mscorlib.dll!System.Lazy&lt;Microsoft.CodeAnalysis.Host.IWorkspaceService&gt;.Value.get() Line 339 C#
Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Host.Mef.MefWorkspaceServices.GetService&lt;Microsoft.CodeAnalysis.Experiments.IExperimentationService&gt;() Line 49   C#
Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Remote.RemoteHostClientExtensions.IsOutOfProcessEnabled(Microsoft.CodeAnalysis.Workspace workspace, Microsoft.CodeAnalysis.Options.Option&lt;bool&gt; featureOption) Line 129              C#
Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Remote.RemoteHostClientExtensions.TryGetRemoteHostClientAsync(Microsoft.CodeAnalysis.Workspace workspace, Microsoft.CodeAnalysis.Options.Option&lt;bool&gt; featureOption, System.Threading.CancellationToken cancellationToken) Line 135         C#
Microsoft.CodeAnalysis.Features.dll!Microsoft.CodeAnalysis.NavigateTo.AbstractNavigateToSearchService.TryGetRemoteHostClientAsync(Microsoft.CodeAnalysis.Project project, System.Threading.CancellationToken cancellationToken) Line 47           C#
Microsoft.CodeAnalysis.Features.dll!Microsoft.CodeAnalysis.NavigateTo.AbstractNavigateToSearchService.SearchProjectAsync(Microsoft.CodeAnalysis.Project project, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Document&gt; priorityDocuments, string searchPattern, System.Collections.Immutable.IImmutableSet&lt;string&gt; kinds, System.Threading.CancellationToken cancellationToken)        C#
Microsoft.CodeAnalysis.EditorFeatures.Wpf.dll!Microsoft.CodeAnalysis.Editor.Implementation.NavigateTo.NavigateToItemProvider.Searcher.SearchAsyncWorker(Microsoft.CodeAnalysis.Project project, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Document&gt; priorityDocuments) Line 189           C#
Microsoft.CodeAnalysis.EditorFeatures.Wpf.dll!Microsoft.CodeAnalysis.Editor.Implementation.NavigateTo.NavigateToItemProvider.Searcher.SearchAsync(Microsoft.CodeAnalysis.Project project, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Document&gt; priorityDocuments)           C#
Microsoft.CodeAnalysis.EditorFeatures.Wpf.dll!Microsoft.CodeAnalysis.Editor.Implementation.NavigateTo.NavigateToItemProvider.Searcher.SearchProjectsInPriorityOrder.AnonymousMethod__5() Line 146 C#
mscorlib.dll!System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;.InnerInvoke() Line 680 C#
              mscorlib.dll!System.Threading.Tasks.Task.Execute() Line 2498 C#
              mscorlib.dll!System.Threading.Tasks.Task.ExecutionContextCallback(object obj) Line 2861      C#
mscorlib.dll!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state, bool preserveSyncCtx) Line 954 C#
mscorlib.dll!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state, bool preserveSyncCtx) Line 902 C#
              mscorlib.dll!System.Threading.Tasks.Task.ExecuteWithThreadLocal(ref System.Threading.Tasks.Task currentTaskSlot) Line 2827         C#
              mscorlib.dll!System.Threading.Tasks.Task.ExecuteEntry(bool bPreventDoubleExecution) Line 2756            C#
mscorlib.dll!System.Threading.Tasks.Task.System.Threading.IThreadPoolWorkItem.ExecuteWorkItem() Line 2704             C#
              mscorlib.dll!System.Threading.ThreadPoolWorkQueue.Dispatch() Line 820              C#
           mscorlib.dll!System.Threading._ThreadPoolWaitCallback.PerformWaitCallback() Line 1161             C#
```</Description>
        <CreatedDate>01/11/2018</CreatedDate>
        <ClosedDate>09/11/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>30892</IssueID>
        <Title>Package load failure when trying to lauch Navigate To after opening a solution</Title>
        <Description>**Version Used**: VS 16.0 P1 build 28231.51.d16.0

**Steps to Reproduce**:

1. Open a solution in VS without any files open in the editor
2. Ctrl + , to launch Navigate To
3. Search for some type

Note: Problem does not repro if you already had some files from the solution open in the editor at the point where Navigate To was launched.

**Expected Behavior**: Should succeed

**Actual Behavior**: Following package load failure error -

![image](https://user-images.githubusercontent.com/10579684/47826323-7d002700-dd34-11e8-874d-0213e1d24703.png)

On debugging the underlying issue appears to be that `AbstractNavigateToSearchService` is trying to instantiate `VisualStudioExperimentationService` from the background thread resulting in an `InvalidOperationException` from the following `Contract.ThrowIfFalse()` call.

**Dump file**: Available at `\\&lt;internalshare&gt;\\&lt;myfolder&gt;\Dumps\RoslynPackageLoad`

```
      Microsoft.CodeAnalysis.Workspaces.dll!Roslyn.Utilities.Contract.ThrowIfFalse(bool condition, string message) Line 32  C#
Microsoft.CodeAnalysis.EditorFeatures.dll!Microsoft.CodeAnalysis.Editor.Shared.Utilities.ForegroundThreadAffinitizedObject.AssertIsForeground() Line 56   C#
Microsoft.CodeAnalysis.EditorFeatures.dll!Microsoft.CodeAnalysis.Editor.Shared.Utilities.ForegroundThreadAffinitizedObject.ForegroundThreadAffinitizedObject(Microsoft.CodeAnalysis.Editor.Shared.Utilities.IThreadingContext threadingContext, bool assertIsForeground) Line 34   C#
&gt; Microsoft.VisualStudio.LanguageServices.dll!Microsoft.VisualStudio.LanguageServices.Experimentation.VisualStudioExperimentationService.VisualStudioExperimentationService(Microsoft.CodeAnalysis.Editor.Shared.Utilities.IThreadingContext threadingContext, Microsoft.VisualStudio.Shell.SVsServiceProvider serviceProvider) Line 27   C#
              [Native to Managed Transition]      
              [Managed to Native Transition]      
Microsoft.VisualStudio.Composition.dll!Microsoft.VisualStudio.Composition.ReflectionHelpers.Instantiate(System.Reflection.MethodBase ctorOrFactoryMethod, object[] arguments) Line 595  C#
Microsoft.VisualStudio.Composition.dll!Microsoft.VisualStudio.Composition.RuntimeExportProviderFactory.RuntimeExportProvider.RuntimePartLifecycleTracker.CreateValue() Line 517 C#
Microsoft.VisualStudio.Composition.dll!Microsoft.VisualStudio.Composition.ExportProvider.PartLifecycleTracker.Create() Line 1160             C#
Microsoft.VisualStudio.Composition.dll!Microsoft.VisualStudio.Composition.ExportProvider.PartLifecycleTracker.MoveNext(Microsoft.VisualStudio.Composition.ExportProvider.PartLifecycleState nextState) Line 1255          C#
Microsoft.VisualStudio.Composition.dll!Microsoft.VisualStudio.Composition.ExportProvider.PartLifecycleTracker.MoveToState(Microsoft.VisualStudio.Composition.ExportProvider.PartLifecycleState requiredState) Line 1336   C#
Microsoft.VisualStudio.Composition.dll!Microsoft.VisualStudio.Composition.ExportProvider.PartLifecycleTracker.GetValueReadyToExpose() Line 1061             C#
Microsoft.VisualStudio.Composition.dll!Microsoft.VisualStudio.Composition.ExportProvider.CreateExport.AnonymousMethod__0() Line 461 C#
              mscorlib.dll!System.Lazy&lt;object&gt;.CreateValue() Line 437         C#
              mscorlib.dll!System.Lazy&lt;object&gt;.LazyInitValue() Line 388       C#
              mscorlib.dll!System.Lazy&lt;object&gt;.Value.get() Line 339             C#
Microsoft.VisualStudio.Composition.dll!Microsoft.VisualStudio.Composition.NetFxAdapters.MefV1ExportProvider.UnwrapExport.AnonymousMethod__1() Line 246 C#
System.ComponentModel.Composition.dll!System.ComponentModel.Composition.Primitives.Export.GetExportedValueCore() Line 247 C#
System.ComponentModel.Composition.dll!System.ComponentModel.Composition.Primitives.Export.Value.get() Line 207 C#
System.ComponentModel.Composition.dll!System.ComponentModel.Composition.ExportServices.GetCastedExportedValue&lt;Microsoft.CodeAnalysis.Host.IWorkspaceService&gt;(System.ComponentModel.Composition.Primitives.Export export) Line 135  C#
System.ComponentModel.Composition.dll!System.ComponentModel.Composition.ExportServices.CreateStronglyTypedLazyOfTM.AnonymousMethod__1() Line 88   C#
mscorlib.dll!System.Lazy&lt;Microsoft.CodeAnalysis.Host.IWorkspaceService&gt;.CreateValue() Line 437 C#
mscorlib.dll!System.Lazy&lt;Microsoft.CodeAnalysis.Host.IWorkspaceService&gt;.LazyInitValue() Line 359 C#
mscorlib.dll!System.Lazy&lt;Microsoft.CodeAnalysis.Host.IWorkspaceService&gt;.Value.get() Line 339 C#
Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Host.Mef.MefWorkspaceServices.GetService&lt;Microsoft.CodeAnalysis.Experiments.IExperimentationService&gt;() Line 49   C#
Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Remote.RemoteHostClientExtensions.IsOutOfProcessEnabled(Microsoft.CodeAnalysis.Workspace workspace, Microsoft.CodeAnalysis.Options.Option&lt;bool&gt; featureOption) Line 129              C#
Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Remote.RemoteHostClientExtensions.TryGetRemoteHostClientAsync(Microsoft.CodeAnalysis.Workspace workspace, Microsoft.CodeAnalysis.Options.Option&lt;bool&gt; featureOption, System.Threading.CancellationToken cancellationToken) Line 135         C#
Microsoft.CodeAnalysis.Features.dll!Microsoft.CodeAnalysis.NavigateTo.AbstractNavigateToSearchService.TryGetRemoteHostClientAsync(Microsoft.CodeAnalysis.Project project, System.Threading.CancellationToken cancellationToken) Line 47           C#
Microsoft.CodeAnalysis.Features.dll!Microsoft.CodeAnalysis.NavigateTo.AbstractNavigateToSearchService.SearchProjectAsync(Microsoft.CodeAnalysis.Project project, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Document&gt; priorityDocuments, string searchPattern, System.Collections.Immutable.IImmutableSet&lt;string&gt; kinds, System.Threading.CancellationToken cancellationToken)        C#
Microsoft.CodeAnalysis.EditorFeatures.Wpf.dll!Microsoft.CodeAnalysis.Editor.Implementation.NavigateTo.NavigateToItemProvider.Searcher.SearchAsyncWorker(Microsoft.CodeAnalysis.Project project, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Document&gt; priorityDocuments) Line 189           C#
Microsoft.CodeAnalysis.EditorFeatures.Wpf.dll!Microsoft.CodeAnalysis.Editor.Implementation.NavigateTo.NavigateToItemProvider.Searcher.SearchAsync(Microsoft.CodeAnalysis.Project project, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Document&gt; priorityDocuments)           C#
Microsoft.CodeAnalysis.EditorFeatures.Wpf.dll!Microsoft.CodeAnalysis.Editor.Implementation.NavigateTo.NavigateToItemProvider.Searcher.SearchProjectsInPriorityOrder.AnonymousMethod__5() Line 146 C#
mscorlib.dll!System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;.InnerInvoke() Line 680 C#
              mscorlib.dll!System.Threading.Tasks.Task.Execute() Line 2498 C#
              mscorlib.dll!System.Threading.Tasks.Task.ExecutionContextCallback(object obj) Line 2861      C#
mscorlib.dll!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state, bool preserveSyncCtx) Line 954 C#
mscorlib.dll!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state, bool preserveSyncCtx) Line 902 C#
              mscorlib.dll!System.Threading.Tasks.Task.ExecuteWithThreadLocal(ref System.Threading.Tasks.Task currentTaskSlot) Line 2827         C#
              mscorlib.dll!System.Threading.Tasks.Task.ExecuteEntry(bool bPreventDoubleExecution) Line 2756            C#
mscorlib.dll!System.Threading.Tasks.Task.System.Threading.IThreadPoolWorkItem.ExecuteWorkItem() Line 2704             C#
              mscorlib.dll!System.Threading.ThreadPoolWorkQueue.Dispatch() Line 820              C#
           mscorlib.dll!System.Threading._ThreadPoolWaitCallback.PerformWaitCallback() Line 1161             C#
```</Description>
        <CreatedDate>01/11/2018</CreatedDate>
        <ClosedDate>09/11/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/VisualStudio/Core/Def/Experimentation/VisualStudioExperimentationService.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>30914</IssueID>
    <Title>Target NetStandard 2.0 and .NET Framework 4.7.2</Title>
    <Description>Retargets Roslyn projects to netstandard2.0 and net472.

Moves most code from Workspaces.Desktop to Workspaces, except for MEF V1 implementation.
Removes dependencies on Workspaces.Desktop.
Removes Workspaces.Desktop from Micrososft.CodeAnalysis.Workspaces.Common package.

Removes PortableFacades.vsix.

Enables more scripting tests on Core.

Fixes #29292 (Cleanup Microsoft.CodeAnalysis.Workspaces packages)
Fixes #18479 (Scripting Tuples test has broken references between desktop/coreclr tests)

Implements IBC optimization data embedding.

</Description>
    <CreatedDate>01/11/2018</CreatedDate>
    <ClosedDate>01/11/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>29292</IssueID>
        <Title>Cleanup Microsoft.CodeAnalysis.Workspaces packages</Title>
        <Description>We package Microsoft.CodeAnalysis.Workspaces and Microsoft.CodeAnalysis.Workspaces.Desktop in the same package, which is an unusal pattern that's not supported by NuGet Pack and needs a custom NuSpec file. Remove the custom NuSpec once we target netstandard2.0 and merge these two assemblies. 

When referencing Microsoft.CodeAnalysis.Workspaces.Desktop.csproj from other project that produce packages we need to do so with `PrivateAssets="all"` since the actual Microsoft.CodeAnalysis.Workspaces.Common package reference is added via reference to Microsoft.CodeAnalysis.Workspaces.csproj.</Description>
        <CreatedDate>14/08/2018</CreatedDate>
        <ClosedDate>05/04/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>18479</IssueID>
        <Title>Scripting Tuples test has broken references between desktop/coreclr tests</Title>
        <Description>The test is Microsoft.CodeAnalysis.CSharp.Scripting.UnitTests.CommandLineRunnerTests.Tuples

On CoreCLR System.ValueTuple is in the runtime corlib, meaning that if System.ValueTuple is passed to the scripting compilation, compilations fail due to duplicate tuple types.

On the other hand, if the reference is removed, compilations fail on Desktop since the current corlib does not have System.ValueTuple.</Description>
        <CreatedDate>05/04/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Test/CommandLine/CommandLineTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Attributes/EmitTestStrongNameProvider.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Attributes/InternalsVisibleToAndStrongNameTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTupleTest.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Emit/CompilationEmitTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Emit/DesktopStrongNameProviderTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Emit/EditAndContinue/EditAndContinueTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Emit/NoPiaEmbedTypes.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/PDB/PDBUsingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/PrivateProtected.cs</File>
      <File>src/Compilers/CSharp/csc/Program.cs</File>
      <File>src/Compilers/Core/CodeAnalysisTest/AnalyzerFileReferenceTests.cs</File>
      <File>src/Compilers/Core/CodeAnalysisTest/DesktopAnalyzerAssemblyLoaderTests.cs</File>
      <File>src/Compilers/Core/CodeAnalysisTest/MetadataReferences/AssemblyIdentityComparerTests.cs</File>
      <File>src/Compilers/Core/CodeAnalysisTest/MetadataReferences/AssemblyIdentityDisplayNameTests.cs</File>
      <File>src/Compilers/Core/CodeAnalysisTest/MetadataReferences/AssemblyIdentityTests.cs</File>
      <File>src/Compilers/Core/CodeAnalysisTest/MetadataReferences/AssemblyPortabilityPolicyTests.cs</File>
      <File>src/Compilers/Core/CodeAnalysisTest/MetadataReferences/FusionAssemblyIdentityTests.cs</File>
      <File>src/Compilers/Core/CodeAnalysisTest/MetadataReferences/MetadataReferenceTests.cs</File>
      <File>src/Compilers/Core/CodeAnalysisTest/MetadataReferences/ModuleMetadataTests.cs</File>
      <File>src/Compilers/Core/Portable/FileSystem/FileUtilities.cs</File>
      <File>src/Compilers/Extension/AssemblyRedirects.cs</File>
      <File>src/Compilers/Server/VBCSCompiler/NamedPipeClientConnection.cs</File>
      <File>src/Compilers/Server/VBCSCompiler/VBCSCompiler.cs</File>
      <File>src/Compilers/Server/VBCSCompilerTests/CompilerServerTests.cs</File>
      <File>src/Compilers/Server/VBCSCompilerTests/DesktopBuildClientTests.cs</File>
      <File>src/Compilers/Shared/BuildClient.cs</File>
      <File>src/Compilers/Shared/BuildServerConnection.cs</File>
      <File>src/Compilers/Shared/DesktopAnalyzerAssemblyLoader.cs</File>
      <File>src/Compilers/Shared/GlobalAssemblyCacheHelpers/ClrGlobalAssemblyCache.cs</File>
      <File>src/Compilers/Shared/GlobalAssemblyCacheHelpers/FusionAssemblyIdentity.cs</File>
      <File>src/Compilers/Shared/ShadowCopyAnalyzerAssemblyLoader.cs</File>
      <File>src/Compilers/Test/Resources/Core/TestKeys.cs</File>
      <File>src/Compilers/VisualBasic/vbc/Program.cs</File>
      <File>src/EditorFeatures/CSharpTest/ConvertForEachToFor/ConvertForEachToForTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/RemoveUnusedVariable/RemoveUnusedVariableTests.cs</File>
      <File>src/EditorFeatures/Core/EditorFeaturesResources.Designer.cs</File>
      <File>src/EditorFeatures/Test/CodeGeneration/AbstractCodeGenerationTests.cs</File>
      <File>src/EditorFeatures/Test/Diagnostics/DiagnosticAnalyzerServiceTests.cs</File>
      <File>src/EditorFeatures/Test/Preview/PreviewWorkspaceTests.cs</File>
      <File>src/EditorFeatures/TestUtilities/Workspaces/TestWorkspace.cs</File>
      <File>src/Scripting/CSharp/Hosting/ObjectFormatter/CSharpObjectFormatterImpl.cs</File>
      <File>src/Scripting/CSharpTest/CommandLineRunnerTests.cs</File>
      <File>src/Scripting/CSharpTest/ScriptTests.cs</File>
      <File>src/Scripting/Core/Hosting/ObjectFormatter/CommonObjectFormatter.cs</File>
      <File>src/Scripting/Core/ScriptOptions.cs</File>
      <File>src/Scripting/CoreTest/ScriptOptionsTests.cs</File>
      <File>src/Setup/DevDivPackages/Debugger/Program.cs</File>
      <File>src/Test/Utilities/Portable/Assert/UseCultureAttribute.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/RuntimeUtilities.cs</File>
      <File>src/Test/Utilities/Portable/CompilationVerifier.cs</File>
      <File>src/Test/Utilities/Portable/FX/EnsureEnglishUICulture.cs</File>
      <File>src/Test/Utilities/Portable/FX/EnsureInvariantCulture.cs</File>
      <File>src/Test/Utilities/Portable/Mocks/TestReferences.cs</File>
      <File>src/Test/Utilities/Portable/Platform/Custom/MetadataSignatureHelper.cs</File>
      <File>src/Test/Utilities/Portable/Platform/Custom/OSVersion.cs</File>
      <File>src/Test/Utilities/Portable/Platform/Custom/SigningTestHelpers.cs</File>
      <File>src/Test/Utilities/Portable/Platform/Desktop/AppDomainAssemblyCache.cs</File>
      <File>src/Test/Utilities/Portable/Platform/Desktop/AppDomainUtils.cs</File>
      <File>src/Test/Utilities/Portable/Platform/Desktop/CLRHelpers.cs</File>
      <File>src/Test/Utilities/Portable/Platform/Desktop/ConditionalFactAttribute.cs</File>
      <File>src/Test/Utilities/Portable/Platform/Desktop/DesktopRuntimeEnvironment.cs</File>
      <File>src/Test/Utilities/Portable/Platform/Desktop/DesktopRuntimeEnvironmentFactory.cs</File>
      <File>src/Test/Utilities/Portable/Platform/Desktop/DesktopRuntimeUtil.cs</File>
      <File>src/Test/Utilities/Portable/Platform/Desktop/ErrorDiagnostics.cs</File>
      <File>src/Test/Utilities/Portable/Platform/Desktop/Exceptions.cs</File>
      <File>src/Test/Utilities/Portable/Platform/Desktop/Extensions.cs</File>
      <File>src/Test/Utilities/Portable/Platform/Desktop/RuntimeAssemblyManager.cs</File>
      <File>src/Test/Utilities/Portable/Platform/Desktop/RuntimeModuleData.cs</File>
      <File>src/Test/Utilities/Portable/Platform/Desktop/TestHelpers.cs</File>
      <File>src/Tools/BuildBoss/CompilerNuGetCheckerUtil.cs</File>
      <File>src/Tools/BuildBoss/ProjectCheckerUtil.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/GenerateType/GenerateTypeDialogViewModel.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/MetadataReferences/VisualStudioMetadataReferenceManager.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/MiscellaneousFilesWorkspace.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/VisualStudioMefHostServices.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/VisualStudioWorkspaceImpl.cs</File>
      <File>src/VisualStudio/Core/Impl/Options/AbstractOptionPreviewViewModel.cs</File>
      <File>src/VisualStudio/Core/Impl/RoslynVisualStudioWorkspace.cs</File>
      <File>src/VisualStudio/Core/Test.Next/Mocks/TestHostServices.cs</File>
      <File>src/VisualStudio/Setup.Dependencies/AssemblyRedirects.cs</File>
      <File>src/VisualStudio/Setup/AssemblyRedirects.cs</File>
      <File>src/Workspaces/Core/Desktop/Utilities/ReferencePathUtilities_Desktop.cs</File>
      <File>src/Workspaces/Core/Desktop/Workspace/CommandLineProject.cs</File>
      <File>src/Workspaces/Core/Desktop/Workspace/Host/Mef/DesktopMefHostServices.cs</File>
      <File>src/Workspaces/Core/Desktop/Workspace/Host/Mef/MefV1HostServices.cs</File>
      <File>src/Workspaces/Core/Desktop/WorkspaceDesktopResources.Designer.cs</File>
      <File>src/Workspaces/Core/MSBuild/Host/SimpleAnalyzerAssemblyLoaderService.cs</File>
      <File>src/Workspaces/Core/Portable/Execution/Desktop/DesktopReferenceSerializationServiceFactory.cs</File>
      <File>src/Workspaces/Core/Portable/Execution/Desktop/SerializationAnalyzerAssemblyLoader.cs</File>
      <File>src/Workspaces/Core/Portable/Execution/Desktop/SimpleAnalyzerAssemblyLoaderService.cs</File>
      <File>src/Workspaces/Core/Portable/Log/EtwLogger.cs</File>
      <File>src/Workspaces/Core/Portable/Log/RoslynEventSource.cs</File>
      <File>src/Workspaces/Core/Portable/Log/TraceLogger.cs</File>
      <File>src/Workspaces/Core/Portable/SolutionSize/ISolutionSizeTracker.cs</File>
      <File>src/Workspaces/Core/Portable/SolutionSize/SolutionSizeTracker.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/AbstractPersistentStorageService.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/PersistenceStorageServiceFactory.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/SQLite/Interop/OpenFlags.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/SQLite/Interop/ResettableSqlStatement.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/SQLite/Interop/Result.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/SQLite/Interop/SqlConnection.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/SQLite/Interop/SqlException.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/SQLite/Interop/SqlStatement.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/SQLite/PooledConnection.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/SQLite/SQLitePersistentStorage.Accessor.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/SQLite/SQLitePersistentStorage.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/SQLite/SQLitePersistentStorageService.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/SQLite/SQLitePersistentStorage_BulkPopulateIds.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/SQLite/SQLitePersistentStorage_DocumentIds.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/SQLite/SQLitePersistentStorage_DocumentSerialization.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/SQLite/SQLitePersistentStorage_Helpers.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/SQLite/SQLitePersistentStorage_ProjectIds.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/SQLite/SQLitePersistentStorage_ProjectSerialization.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/SQLite/SQLitePersistentStorage_SolutionSerialization.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/SQLite/SQLitePersistentStorage_StringIds.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/SQLite/SQLitePersistentStorage_WriteBatching.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/StorageDatabase.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/StorageDatabaseLogger.cs</File>
      <File>src/Workspaces/Core/Portable/Storage/StorageOptions.cs</File>
      <File>src/Workspaces/Core/Portable/TemporaryStorage/TemporaryStorageServiceFactory.MemoryMappedInfo.cs</File>
      <File>src/Workspaces/Core/Portable/TemporaryStorage/TemporaryStorageServiceFactory.cs</File>
      <File>src/Workspaces/CoreTest/SolutionTests/SolutionTests.cs</File>
      <File>src/Workspaces/CoreTest/WorkspaceTests/AdhocWorkspaceTests.cs</File>
      <File>src/Workspaces/CoreTestUtilities/MEF/ExportProviderCache.cs</File>
      <File>src/Workspaces/CoreTestUtilities/MEF/UseExportProviderAttribute.cs</File>
      <File>src/Workspaces/DesktopTest/CommandLineProjectTests.cs</File>
      <File>src/Workspaces/DesktopTest/CommandLineProjectWorkspaceTests.cs</File>
      <File>src/Workspaces/DesktopTest/UseMefV1ExportProviderAttribute.cs</File>
      <File>src/Workspaces/MSBuildTest/MSBuildWorkspaceTestBase.cs</File>
      <File>src/Workspaces/MSBuildTest/MSBuildWorkspaceTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>30847</IssueID>
    <Title>Discard pattern versus symbol named `_`</Title>
    <Description>- A discard pattern is not accepted at the top level in a switch statement. In that case `_` binds to a constant in scope with a warning WRN_CaseConstantNamedUnderscore that is included in a warning wave.
- A discard pattern is not accepted at the top level in an is-expression. In that case `_` binds to a type in scope with a warning WRN_IsTypeNamedUnderscore that is included in a warning wave.
- Elsewhere a pattern `_` is a discard without warning no matter what definition for `_` might be in scope.

Fixes #30650
See also #30846</Description>
    <CreatedDate>30/10/2018</CreatedDate>
    <ClosedDate>06/11/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>30650</IssueID>
        <Title>Discard pattern in switch and is</Title>
        <Description>From https://github.com/dotnet/csharplang/issues/1054

Is the discard pattern permitted at the top level of a switch statement? If so, it could change the meaning of existing code. I suggest we require you write `case var _` to avoid any ambiguity.

**Resolution 2018-10-10**: A discard pattern in the presence of a constant will bind to the constant only in a switch statement case, with a warning given under a warning wave. Elsewhere in a pattern it is a discard pattern. A discard pattern in an is-expression in the presence of a type will bind to the type, with a warning under a warning wave.
</Description>
        <CreatedDate>22/10/2018</CreatedDate>
        <ClosedDate>06/11/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>30846</IssueID>
        <Title>New warnings for `is _` and `case _` should be in a warning wave</Title>
        <Description>The following two new warnings for existing source when compiled in C# 8 and above should (by LDM decree) be included in a warning wave once the warning wave machinery is available.

- `WRN_CaseConstantNamedUnderscore`
- `WRN_IsTypeNamedUnderscore`
</Description>
        <CreatedDate>30/10/2018</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Operators.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Patterns.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/SwitchBinder_Patterns.cs</File>
      <File>src/Compilers/CSharp/Portable/CSharpResources.Designer.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/ErrorCode.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/ErrorFacts.cs</File>
      <File>src/Compilers/CSharp/Portable/Generated/ErrorFacts.Generated.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/LanguageParser_Patterns.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenDeconstructTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests2.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests4.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Diagnostics/DiagnosticTest.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/PatternParsingTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>30844</IssueID>
    <Title>Restore `CreateSignatureHelpItems` overload that an extension was relying on</Title>
    <Description>Fixes #30829

Consumers of this API should consider their scenario and decide if they should provide a `selectedItem` to take advantage of this new ability, but we also shouldn't break them. 

This PR has been validated by the partner team as fixing their crash.

**Customer scenario**
A crash when I use Signature Help in IntelliCode.

**Bugs this fixes**
#30829 

**Workarounds, if any**
The extension author could call the new alternative overload and ship an update, but existing installations of their extension would keep crashing.

**Risk**
Very low. This restores an internal overload with no known call sites other than the one we're fixing this for, and this restored overload simply forwards to a new version of that method that takes an `int?` for which it already handles null.

**Performance impact**
None.

**Is this a regression from a previous update?**
No.

**Root cause analysis**
IntelliCode depends on internal API's and we did not validate this scenario when the method signature was changed.

**How was the bug found?**
Partner team testing

**Test documentation updated?**
N/A</Description>
    <CreatedDate>30/10/2018</CreatedDate>
    <ClosedDate>31/10/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>30829</IssueID>
        <Title>Changed SignatureHelp overload broke a partner team</Title>
        <Description>They expect the version of https://github.com/dotnet/roslyn/blob/6c6855c982600a0bf154b2ac6970524eede1304d/src/Features/Core/Portable/SignatureHelp/AbstractSignatureHelpProvider.cs#L38 without the `selectedItem` parameter.</Description>
        <CreatedDate>29/10/2018</CreatedDate>
        <ClosedDate>02/11/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>30829</IssueID>
        <Title>Changed SignatureHelp overload broke a partner team</Title>
        <Description>They expect the version of https://github.com/dotnet/roslyn/blob/6c6855c982600a0bf154b2ac6970524eede1304d/src/Features/Core/Portable/SignatureHelp/AbstractSignatureHelpProvider.cs#L38 without the `selectedItem` parameter.</Description>
        <CreatedDate>29/10/2018</CreatedDate>
        <ClosedDate>02/11/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Features/Core/Portable/SignatureHelp/AbstractSignatureHelpProvider.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>30820</IssueID>
    <Title>Use ImmutableInterlocked instead of lock on a highly contended path</Title>
    <Description>These methods were showing 50% of the overall CPU in contention for #30819.

See #30819

### Customer scenario

A customer uses the formatting diagnostic analyzer on a machine with a large number of cores (test machine used 64 logical processors). The CPU is pegged but the operation takes a long time to complete.

### Bugs this fixes

N/A

### Workarounds, if any

Use a machine with fewer cores.

### Risk

Very low. The operation uses an existing primitive operation on `ImmutableDictionary&lt;TKey, TValue&gt;` to perform an update without using a `lock` construct.

### Performance impact

In most cases, the performance difference is not observable. In the primary impacted case (testing for #30819), the update is required before meaningful progress can be made on the underlying issue.

### Is this a regression from a previous update?

No

### Root cause analysis

This is the first time running targeted performance evaluations on machines with this many cores.

### How was the bug found?

Manual testing as described in this pull request and #30819.

### Test documentation updated?

N/A</Description>
    <CreatedDate>28/10/2018</CreatedDate>
    <ClosedDate>31/10/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>30819</IssueID>
        <Title>Manual performance testing: FormattingDiagnosticAnalyzer on Roslyn.sln</Title>
        <Description>**Version Used**: e7608094aaa6dda6a92272080cf134e2a9bab4f7

**Steps to Reproduce**:

1. Open Roslyn.sln in Visual Studio
2. Set the current configuration to **Release**
3. Modify **AnalyzerRunner.csproj** to prefer 32-bit
4. Modify **app.config** to disable the server GC. This step is required for tests using a 32-core processor since the threads for the server GC will run out of 32-bit address space.
5. Run AnalyzerRunner on Roslyn.sln with the following launch configuration:

    ```json
    {
      "profiles": {
        "Profile FormattingDiagnosticAnalyzer": {
          "commandName": "Project",
          "commandLineArgs": "$(SolutionDir)Binaries\\$(Configuration)\\Exes\\AnalyzerRunner $(SolutionDir)Roslyn.sln /iter:2 /stats /a FormattingDiagnosticAnalyzer"
        }
      }
    }
    ```
</Description>
        <CreatedDate>28/10/2018</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>30819</IssueID>
        <Title>Manual performance testing: FormattingDiagnosticAnalyzer on Roslyn.sln</Title>
        <Description>**Version Used**: e7608094aaa6dda6a92272080cf134e2a9bab4f7

**Steps to Reproduce**:

1. Open Roslyn.sln in Visual Studio
2. Set the current configuration to **Release**
3. Modify **AnalyzerRunner.csproj** to prefer 32-bit
4. Modify **app.config** to disable the server GC. This step is required for tests using a 32-core processor since the threads for the server GC will run out of 32-bit address space.
5. Run AnalyzerRunner on Roslyn.sln with the following launch configuration:

    ```json
    {
      "profiles": {
        "Profile FormattingDiagnosticAnalyzer": {
          "commandName": "Project",
          "commandLineArgs": "$(SolutionDir)Binaries\\$(Configuration)\\Exes\\AnalyzerRunner $(SolutionDir)Roslyn.sln /iter:2 /stats /a FormattingDiagnosticAnalyzer"
        }
      }
    }
    ```
</Description>
        <CreatedDate>28/10/2018</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>30819</IssueID>
        <Title>Manual performance testing: FormattingDiagnosticAnalyzer on Roslyn.sln</Title>
        <Description>**Version Used**: e7608094aaa6dda6a92272080cf134e2a9bab4f7

**Steps to Reproduce**:

1. Open Roslyn.sln in Visual Studio
2. Set the current configuration to **Release**
3. Modify **AnalyzerRunner.csproj** to prefer 32-bit
4. Modify **app.config** to disable the server GC. This step is required for tests using a 32-core processor since the threads for the server GC will run out of 32-bit address space.
5. Run AnalyzerRunner on Roslyn.sln with the following launch configuration:

    ```json
    {
      "profiles": {
        "Profile FormattingDiagnosticAnalyzer": {
          "commandName": "Project",
          "commandLineArgs": "$(SolutionDir)Binaries\\$(Configuration)\\Exes\\AnalyzerRunner $(SolutionDir)Roslyn.sln /iter:2 /stats /a FormattingDiagnosticAnalyzer"
        }
      }
    }
    ```
</Description>
        <CreatedDate>28/10/2018</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>30819</IssueID>
        <Title>Manual performance testing: FormattingDiagnosticAnalyzer on Roslyn.sln</Title>
        <Description>**Version Used**: e7608094aaa6dda6a92272080cf134e2a9bab4f7

**Steps to Reproduce**:

1. Open Roslyn.sln in Visual Studio
2. Set the current configuration to **Release**
3. Modify **AnalyzerRunner.csproj** to prefer 32-bit
4. Modify **app.config** to disable the server GC. This step is required for tests using a 32-core processor since the threads for the server GC will run out of 32-bit address space.
5. Run AnalyzerRunner on Roslyn.sln with the following launch configuration:

    ```json
    {
      "profiles": {
        "Profile FormattingDiagnosticAnalyzer": {
          "commandName": "Project",
          "commandLineArgs": "$(SolutionDir)Binaries\\$(Configuration)\\Exes\\AnalyzerRunner $(SolutionDir)Roslyn.sln /iter:2 /stats /a FormattingDiagnosticAnalyzer"
        }
      }
    }
    ```
</Description>
        <CreatedDate>28/10/2018</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Workspaces/Core/Portable/Options/OptionServiceFactory.cs</File>
      <File>src/Workspaces/Core/Portable/Options/WorkspaceOptionSet.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>30774</IssueID>
    <Title>User-defined operator checks should ignore differences in tuple member names</Title>
    <Description>- [x] Resolves #30668 
- [x] Resolves #30659 
</Description>
    <CreatedDate>26/10/2018</CreatedDate>
    <ClosedDate>30/10/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>30668</IssueID>
        <Title>It feels like Microsoft.CodeAnalysis.CSharp.Symbols.SourceUserDefinedOperatorSymbolBase.CheckIncrementDecrementSignature should ignore tuple names when type symbols are compared</Title>
        <Description>```
            else if (!this.ReturnType.TypeSymbol.EffectiveTypeNoUseSiteDiagnostics.IsEqualToOrDerivedFrom(parameterType, TypeCompareKind.ConsiderEverything, useSiteDiagnostics: ref useSiteDiagnostics))
            {
                // CS0448: The return type for ++ or -- operator must match the parameter type
                //         or be derived from the parameter type
                diagnostics.Add(ErrorCode.ERR_BadIncDecRetType, this.Locations[0]);
            }
```</Description>
        <CreatedDate>23/10/2018</CreatedDate>
        <ClosedDate>30/10/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>30659</IssueID>
        <Title>It feels like Microsoft.CodeAnalysis.CSharp.Symbols.SourceUserDefinedOperatorSymbolBase.CheckUserDefinedConversionSignature Should ignore tuple names when type symbols are compared</Title>
        <Description>```
            // SPEC: * S0 and T0 are different types:

            if ((ContainingType.SpecialType == SpecialType.System_Nullable_T) ? source == target : source0 == target0)
```

```
            if (source0 == this.ContainingType)
            {
                same = source;
                different = target;
            }
            else
            {
                same = target;
                different = source;
            }

```</Description>
        <CreatedDate>23/10/2018</CreatedDate>
        <ClosedDate>30/10/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceUserDefinedOperatorSymbolBase.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/OperatorTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>30761</IssueID>
    <Title>Merge 'features/NullableReferenceTypes' into 'dev16.0.x'</Title>
    <Description>### Customer scenario

Nullable feature is not working as expected in number of scenarios when generics are involved.

### Bugs this fixes

Fixes #28684.
Fixes #29837.
Fixes #30001.
Fixes #30052.
Fixes #30054.
Fixes #30068.
Fixes #30072.
Fixes #30178.
Fixes #30220.

### Workarounds, if any

No.

### Risk

In between of Low and Medium

### Performance impact

None.

### Is this a regression from a previous update?

Nullable is a new feature.

### Root cause analysis

Nullable is a new feature.

### How was the bug found?

Feature testing.

VSO Bug: https://devdiv.visualstudio.com/DefaultCollection/DevDiv/_workitems/edit/718172
 </Description>
    <CreatedDate>25/10/2018</CreatedDate>
    <ClosedDate>26/10/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>28684</IssueID>
        <Title>Annotations are ignored when comparing overridden method with [NonNullTypes(false)]</Title>
        <Description>No warnings are reported for `B.F` and `B.G` even though the annotations do not match the overridden methods in `A`.

See `Overriding_23`:

```c#
using System.Runtime.CompilerServices;
namespace System.Runtime.CompilerServices
{
    public sealed class NonNullTypesAttribute : Attribute
    {
        public NonNullTypesAttribute(bool flag) { }
    }
}
[NonNullTypes(true)]
abstract class A
{
    internal abstract string F();
    internal abstract object?[] G();
}
[NonNullTypes(false)]
abstract class B : A
{
    internal override abstract string? F(); // does not match string
    internal override abstract object[] G(); // does not match object?[]
}
```</Description>
        <CreatedDate>19/07/2018</CreatedDate>
        <ClosedDate>23/10/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>29837</IssueID>
        <Title>Return type of constructed method has unknown nullability</Title>
        <Description>The return type of `F2(x)` is `I&lt;object!&gt;~` rather than `I&lt;object!&gt;!`:
```c#
[module: System.Runtime.CompilerServices.NonNullTypes]
interface I&lt;T&gt; { }
class C
{
    static I&lt;object&gt; F1&lt;T&gt;(T arg) =&gt; throw null;
    static I&lt;T&gt; F2&lt;T&gt;(T arg) =&gt; throw null;
    static void M(object x)
    {
        F1(x) // I&lt;object!&gt;!
        F2(x) // I&lt;object!&gt;~
    }
}
```</Description>
        <CreatedDate>13/09/2018</CreatedDate>
        <ClosedDate>23/10/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>30001</IssueID>
        <Title>NonNullTypes(true) context is getting dropped from unannotated type during construction, causing missing diagnostics</Title>
        <Description>```
        [Fact]
        public void ConstraintCyclesFromMetadata_01()
        {
            var source0 =
@"using System;
public class A0&lt;T&gt; where T : IEquatable&lt;T&gt; { }
public class A1&lt;T&gt; where T : class, IEquatable&lt;T&gt; { }

public class A3&lt;T&gt; where T : struct, IEquatable&lt;T&gt; { }
public class A4&lt;T&gt; where T : struct, IEquatable&lt;T?&gt; { }
public class A5&lt;T&gt; where T : IEquatable&lt;string?&gt; { }
public class A6&lt;T&gt; where T : IEquatable&lt;int?&gt; { }";
            var source =
@"class B
{
    static void Main()
    {
        new A0&lt;string?&gt;(); // 1
        new A0&lt;string&gt;();


        new A5&lt;string?&gt;(); // 4
        new A5&lt;string&gt;(); // 5
    }
}";
            // No [NullNullTypes]
            var comp0 = CreateCompilation(source0);
            var ref0 = comp0.EmitToImageReference();
            var comp = CreateCompilation(source, references: new[] { ref0 });

            var expectedDiagnostics = new[]
            {
                // (5,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '[NonNullTypes(true)]' context.
                //         new A0&lt;string?&gt;(); // 1
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(5, 22),
                // (9,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '[NonNullTypes(true)]' context.
                //         new A5&lt;string?&gt;(); // 4
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(9, 22)
            };

            comp.VerifyDiagnostics(expectedDiagnostics);
            verifyTypeParameterConstraint("A0", "System.IEquatable&lt;T&gt;");
            verifyTypeParameterConstraint("A1", "System.IEquatable&lt;T&gt;");
            verifyTypeParameterConstraint("A3", "System.IEquatable&lt;T&gt;");
            verifyTypeParameterConstraint("A4", "System.IEquatable&lt;T?&gt;");
            verifyTypeParameterConstraint("A5", "System.IEquatable&lt;System.String?&gt;");
            verifyTypeParameterConstraint("A6", "System.IEquatable&lt;System.Int32?&gt;");

            // [NullNullTypes(false)]
            comp0 = CreateCompilation(new[] { source0, NonNullTypesFalse, NonNullTypesAttributesDefinition });
            ref0 = comp0.EmitToImageReference();
            comp = CreateCompilation(source, references: new[] { ref0 });
            comp.VerifyDiagnostics(expectedDiagnostics);
            verifyTypeParameterConstraint("A0", "System.IEquatable&lt;T&gt;");
            verifyTypeParameterConstraint("A1", "System.IEquatable&lt;T&gt;");
            verifyTypeParameterConstraint("A3", "System.IEquatable&lt;T&gt;");
            verifyTypeParameterConstraint("A4", "System.IEquatable&lt;T?&gt;");
            verifyTypeParameterConstraint("A5", "System.IEquatable&lt;System.String?&gt;");
            verifyTypeParameterConstraint("A6", "System.IEquatable&lt;System.Int32?&gt;");

            // [NullNullTypes(true)]
            comp0 = CreateCompilation(new[] { source0, NonNullTypesTrue, NonNullTypesAttributesDefinition });
            ref0 = comp0.EmitToImageReference();
            comp = CreateCompilation(source, references: new[] { ref0 });
            // PROTOTYPE(NullableReferenceTypes): Should report a nullability mismatch warning for A0&lt;string?&gt;().
            comp.VerifyDiagnostics(
                // (5,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '[NonNullTypes(true)]' context.
                //         new A0&lt;string?&gt;(); // 1
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(5, 22),
                // (9,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '[NonNullTypes(true)]' context.
                //         new A5&lt;string?&gt;(); // 4
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(9, 22),
                // (9,16): warning CS8631: The type 'string?' cannot be used as type parameter 'T' in the generic type or method 'A5&lt;T&gt;'. Nullability of type argument 'string?' doesn't match constraint type 'System.IEquatable&lt;string?&gt;'.
                //         new A5&lt;string?&gt;(); // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "string?").WithArguments("A5&lt;T&gt;", "System.IEquatable&lt;string?&gt;", "T", "string?").WithLocation(9, 16)
                );
            verifyTypeParameterConstraint("A0", "System.IEquatable&lt;T&gt;");
            verifyTypeParameterConstraint("A1", "System.IEquatable&lt;T&gt;");
            verifyTypeParameterConstraint("A3", "System.IEquatable&lt;T&gt;");
            verifyTypeParameterConstraint("A4", "System.IEquatable&lt;T?&gt;");
            verifyTypeParameterConstraint("A5", "System.IEquatable&lt;System.String?&gt;");
            verifyTypeParameterConstraint("A6", "System.IEquatable&lt;System.Int32?&gt;");

            void verifyTypeParameterConstraint(string typeName, string expected)
            {
                var type = comp.GetMember&lt;NamedTypeSymbol&gt;(typeName);
                var constraintType = type.TypeParameters[0].ConstraintTypesNoUseSiteDiagnostics[0];
                Assert.Equal(expected, constraintType.ToTestDisplayString());
            }
        }
```</Description>
        <CreatedDate>18/09/2018</CreatedDate>
        <ClosedDate>23/10/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>30052</IssueID>
        <Title>Should follow up on PROTOTYPE comments in TypeSymbolWithAnnotations.SubstituteTypeCore</Title>
        <Description>```
        internal TypeSymbolWithAnnotations SubstituteTypeCore(AbstractTypeMap typeMap, bool withTupleUnification)
        {
            var newCustomModifiers = typeMap.SubstituteCustomModifiers(this.CustomModifiers);
            var newTypeWithModifiers = typeMap.SubstituteType(this.TypeSymbol, withTupleUnification);
            bool newIsAnnotated = this.IsAnnotated || newTypeWithModifiers.IsAnnotated;

            // PROTOTYPE(NullableReferenceTypes): Can we use Equals instead?
            if (this.TypeSymbolEquals(newTypeWithModifiers, TypeCompareKind.CompareNullableModifiersForReferenceTypes) &amp;&amp;
                newTypeWithModifiers.CustomModifiers.IsEmpty &amp;&amp;
                newIsAnnotated == this.IsAnnotated &amp;&amp;
                newCustomModifiers == this.CustomModifiers)
            {
                // PROTOTYPE(NullableReferenceTypes): We're dropping newTypeWithModifiers.NonNullTypes!
                return this; // substitution had no effect on the type or modifiers
            }

            bool newIsNullableType = newTypeWithModifiers.TypeSymbol.IsNullableType();
            if (newIsNullableType)
            {
                if (newCustomModifiers.IsEmpty)
                {
                    return newTypeWithModifiers;
                }
                newIsAnnotated = newTypeWithModifiers.IsAnnotated;
                Debug.Assert(newIsAnnotated);
            }
            else if (newCustomModifiers.IsEmpty &amp;&amp; newTypeWithModifiers.IsAnnotated == newIsAnnotated)
            {
                return newTypeWithModifiers;
            }

            return CreateNonLazyType(
                newTypeWithModifiers.TypeSymbol,
                newTypeWithModifiers.NonNullTypesContext,
                isAnnotated: newIsAnnotated,
                newTypeWithModifiers._treatPossiblyNullableReferenceTypeTypeParameterAsNullable,
                newCustomModifiers.Concat(newTypeWithModifiers.CustomModifiers));
        }
```</Description>
        <CreatedDate>20/09/2018</CreatedDate>
        <ClosedDate>23/10/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>30054</IssueID>
        <Title>Address issues with implementations of Extensions.TypeSymbolWithAnnotations.Is API</Title>
        <Description>```
            // PROTOTYPE(NullableReferenceTypes): This implementation looks
            // incorrect since a type parameter cannot be Nullable&lt;T&gt;.
            internal override bool Is(TypeSymbol typeSymbol, TypeParameterSymbol other)
            {
                if (!other.IsNullableType())
                {
                    return false;
                }

                var resolvedType = GetResolvedType();
                return resolvedType.Equals(other, TypeCompareKind.CompareNullableModifiersForReferenceTypes);
            }

            // PROTOTYPE(NullableReferenceTypes): Use WithCustomModifiers.Is() =&gt; false
            // and set IsNullable=null always for GetTypeParametersAsTypeArguments.
            internal override bool Is(TypeSymbol typeSymbol, TypeParameterSymbol other) =&gt;
                typeSymbol.Equals(other, TypeCompareKind.CompareNullableModifiersForReferenceTypes) &amp;&amp; _customModifiers.IsEmpty;
```
</Description>
        <CreatedDate>20/09/2018</CreatedDate>
        <ClosedDate>23/10/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>30068</IssueID>
        <Title>Figure out proper behavior of NamedTypeSymbol.GetTypeParametersAsTypeArguments API with regard to nullable reference types</Title>
        <Description>```
        internal ImmutableArray&lt;TypeSymbolWithAnnotations&gt; GetTypeParametersAsTypeArguments()
        {
            // PROTOTYPE(NullableReferenceTypes): Set IsNullable=null always, even in C#8,
            // and set TypeSymbolWithAnnotations.WithCustomModifiers.Is() =&gt; false.
            return this.TypeParameters.SelectAsArray((typeParameter, module) =&gt; TypeSymbolWithAnnotations.Create(nonNullTypesContext: module, typeParameter), ContainingModule);
        }
```</Description>
        <CreatedDate>20/09/2018</CreatedDate>
        <ClosedDate>23/10/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>30072</IssueID>
        <Title>Figure out what AbstractTypeMap.SubstituteType method should do about NonNullTypes context</Title>
        <Description>```
        internal TypeSymbolWithAnnotations SubstituteType(TypeSymbol previous)
        {
            if (ReferenceEquals(previous, null))
                return default(TypeSymbolWithAnnotations);

            TypeSymbol result;

            switch (previous.Kind)
            {
                case SymbolKind.NamedType:
                    result = SubstituteNamedType((NamedTypeSymbol)previous);
                    break;
                case SymbolKind.TypeParameter:
                    return SubstituteTypeParameter((TypeParameterSymbol)previous);
                case SymbolKind.ArrayType:
                    result = SubstituteArrayType((ArrayTypeSymbol)previous);
                    break;
                case SymbolKind.PointerType:
                    result = SubstitutePointerType((PointerTypeSymbol)previous);
                    break;
                case SymbolKind.DynamicType:
                    result = SubstituteDynamicType();
                    break;
                case SymbolKind.ErrorType:
                    return ((ErrorTypeSymbol)previous).Substitute(this);
                default:
                    result = previous;
                    break;
            }

            // PROTOTYPE(NullableReferenceTypes): we're dropping annotation and context
            return TypeSymbolWithAnnotations.Create(result);
        }
```</Description>
        <CreatedDate>20/09/2018</CreatedDate>
        <ClosedDate>23/10/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>30178</IssueID>
        <Title>Generic type substitution machinery "drops" non-nullable nature of types</Title>
        <Description>```
        [Fact]
        public void GenericSubstitution_01()
        {
            var source =
@"
using System.Runtime.CompilerServices;

[NonNullTypes(true)]
class A&lt;T&gt; where T : class
{
    T F;

    [NonNullTypes(false)]
    class B : A&lt;T&gt;
    {
        [NonNullTypes(true)]
        void M1()
        {
            F = null; // 1
        }
    }

    void M2()
    {
        F = null; // 2
    }

    [NonNullTypes(false)]
    class C : A&lt;C&gt;
    {
        [NonNullTypes(true)]
        void M3()
        {
            F = null; // 3
        }
    }
}
";
            var comp = CreateCompilation(new[] { source });

            // Missing warning for "F = null; // 3"
            comp.VerifyDiagnostics(
                // (5,7): warning CS8618: Non-nullable field 'F' is uninitialized.
                // class A&lt;T&gt; where T : class
                Diagnostic(ErrorCode.WRN_UninitializedNonNullableField, "A").WithArguments("field", "F").WithLocation(5, 7),
                // (7,7): warning CS0414: The field 'A&lt;T&gt;.F' is assigned but its value is never used
                //     T F;
                Diagnostic(ErrorCode.WRN_UnreferencedFieldAssg, "F").WithArguments("A&lt;T&gt;.F").WithLocation(7, 7),
                // (15,17): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //             F = null; // 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(15, 17),
                // (21,13): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F = null; // 2
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(21, 13)
                );

            var b = comp.GetTypeByMetadataName("A`1+B");
            Assert.NotNull(b);
            Assert.True(b.BaseTypeNoUseSiteDiagnostics.IsDefinition);
        }

        [Fact]
        public void GenericSubstitution_07()
        {
            var source =
@"
using System.Runtime.CompilerServices;

[NonNullTypes(true)]
class A&lt;T&gt; where T : class
{
    [NonNullTypes(false)]
    T F;

    class B : A&lt;T&gt;
    {
        void M1()
        {
            F = null; // 1
        }
    }

    class C : A&lt;C&gt;
    {
        void M3()
        {
            F = null; // 3
        }
    }
}
";
            var comp = CreateCompilation(new[] { source });

            // Missing warning for "F = null; // 1"
            comp.VerifyDiagnostics(
                // (8,7): warning CS0414: The field 'A&lt;T&gt;.F' is assigned but its value is never used
                //     T F;
                Diagnostic(ErrorCode.WRN_UnreferencedFieldAssg, "F").WithArguments("A&lt;T&gt;.F").WithLocation(8, 7),
                // (22,17): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //             F = null; // 3
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(22, 17)
                );

            var b = comp.GetTypeByMetadataName("A`1+B");
            Assert.NotNull(b);
            Assert.True(b.BaseTypeNoUseSiteDiagnostics.IsDefinition); // Should be false
        }
```

</Description>
        <CreatedDate>27/09/2018</CreatedDate>
        <ClosedDate>23/10/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>30220</IssueID>
        <Title>Missing WRN_NullabilityMismatchInTypeParameterConstraint warning when a non-nullable type parameter used as a constraint is declared in a different NonNullTypes context</Title>
        <Description>```
        [Fact]
        public void ObliviousTypeParameter_02()
        {
            var source =
$@"
#pragma warning disable {(int)ErrorCode.WRN_UnreferencedVar}
"
+
@"
using System.Runtime.CompilerServices;

[NonNullTypes(true)]
class A&lt;T1&gt; where T1 : class
{
    [NonNullTypes(false)]
    class B&lt;T2&gt; where T2 : T1 
    {
    }

    [NonNullTypes(true)]
    void M1()
    {
        B&lt;T1&gt; a1;
        B&lt;T1?&gt; b1;
        A&lt;T1&gt;.B&lt;T1&gt; c1;
        A&lt;T1&gt;.B&lt;T1?&gt; d1;
        A&lt;C&gt;.B&lt;C&gt; e1;
        A&lt;C&gt;.B&lt;C?&gt; f1;
    }
}

class C {}
";
            var comp = CreateCompilation(new[] { source });
            comp.VerifyDiagnostics(
                // (22,16): warning CS8631: The type 'C?' cannot be used as type parameter 'T2' in the generic type or method 'A&lt;C&gt;.B&lt;T2&gt;'. Nullability of type argument 'C?' doesn't match constraint type 'C'.
                //         A&lt;C&gt;.B&lt;C?&gt; f1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "C?").WithArguments("A&lt;C&gt;.B&lt;T2&gt;", "C", "T2", "C?").WithLocation(22, 16)
                );
        }
```

Expected WRN_NullabilityMismatchInTypeParameterConstraint warnings for: ```B&lt;T1?&gt; b1;``` and ```A&lt;T1&gt;.B&lt;T1?&gt; d1;```.</Description>
        <CreatedDate>28/09/2018</CreatedDate>
        <ClosedDate>23/10/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/INonNullTypesContext.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/OverloadResolution/MethodTypeInference.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/UnboundLambda.cs</File>
      <File>src/Compilers/CSharp/Portable/Emitter/Model/SymbolAdapter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/SynthesizedClosureMethod.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/MethodToClassRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/AbstractTypeMap.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/AbstractTypeParameterMap.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Compilation_WellKnownMembers.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ConstraintsHelper.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ErrorTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/EventSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/FieldSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/MemberSignatureComparer.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/MemberRefMetadataDecoder.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PENamedTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/SymbolFactory.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/MethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/NamedTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/PropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ReducedExtensionMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/LambdaSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceOrdinaryMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceTypeParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/SubstitutedMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/SubstitutedNamedTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedContainer.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedImplementationMethod.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Tuples/TupleMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/TypeMap.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/TypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/TypeSymbolWithAnnotations.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/NullableReferenceTypesTests.cs</File>
      <File>src/Compilers/Test/Utilities/CSharp/CompilationTestUtils.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Source/ExpressionCompiler/CompilationContext.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Source/ExpressionCompiler/Symbols/EEMethodSymbol.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Source/ExpressionCompiler/Symbols/EENamedTypeSymbol.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>30640</IssueID>
    <Title>Adding refactorings to split and merge if statements</Title>
    <Description>Fixes #29347
Fixes #30114

1. Splitting &amp; merging into nested if statements on `&amp;&amp;`
![splitif1](https://user-images.githubusercontent.com/11444821/47272690-98776f00-d589-11e8-85ef-c2e31d7b0212.gif)
2. Splitting &amp; merging into consecutive if statements on `||`:
![splitif2](https://user-images.githubusercontent.com/11444821/47272692-9b725f80-d589-11e8-9e5e-01c2cca914a3.gif)
a special case on `||` where we can leave out the `else`:
![splitif3](https://user-images.githubusercontent.com/11444821/47272694-9d3c2300-d589-11e8-97f7-6c10dfc6f394.gif)

cc @jnm2</Description>
    <CreatedDate>21/10/2018</CreatedDate>
    <ClosedDate>17/01/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>29347</IssueID>
        <Title>Add refactorings to split and merge nested if statements</Title>
        <Description>I frequently need to adjust complex if statements and miss some refactorings that could speed up this process.

For example I would like to be able to invoke a quick action on the first `&amp;&amp;` to split
```C#
if (con1
    &amp;&amp; (con2 || !con3)
    &amp;&amp; !con4)
{

}
```
into
```C#
if (con1)
{
    if ((con2 || !con3)
        &amp;&amp; !con4))
    {

    }
}
```

And a refactoring on the nested `if` to do the reverse.</Description>
        <CreatedDate>16/08/2018</CreatedDate>
        <ClosedDate>17/01/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>30114</IssueID>
        <Title>Add refactorings to split and merge consecutive if statements</Title>
        <Description>Very similar to #29347, but the `||` version:

```c#
if (a) return;
if (b) return;
```

Refactoring:

```c#
if (a || b) return;
```

And vice versa. I probably use this during refactoring the same amount as #29347.</Description>
        <CreatedDate>24/09/2018</CreatedDate>
        <ClosedDate>17/01/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/MoveDeclarationNearReference/MoveDeclarationNearReferenceTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/RemoveUnusedParametersAndValues/RemoveUnusedValueAssignmentTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/RemoveUnusedVariable/RemoveUnusedVariableTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/SplitOrMergeIfStatements/MergeConsecutiveIfStatementsTests_ElseIf_Middle.cs</File>
      <File>src/EditorFeatures/CSharpTest/SplitOrMergeIfStatements/MergeConsecutiveIfStatementsTests_ElseIf_WithNext.cs</File>
      <File>src/EditorFeatures/CSharpTest/SplitOrMergeIfStatements/MergeConsecutiveIfStatementsTests_ElseIf_WithPrevious.cs</File>
      <File>src/EditorFeatures/CSharpTest/SplitOrMergeIfStatements/MergeConsecutiveIfStatementsTests_Statements_Middle.cs</File>
      <File>src/EditorFeatures/CSharpTest/SplitOrMergeIfStatements/MergeConsecutiveIfStatementsTests_Statements_WithNext.cs</File>
      <File>src/EditorFeatures/CSharpTest/SplitOrMergeIfStatements/MergeConsecutiveIfStatementsTests_Statements_WithPrevious.cs</File>
      <File>src/EditorFeatures/CSharpTest/SplitOrMergeIfStatements/MergeNestedIfStatementsTests_WithNested.cs</File>
      <File>src/EditorFeatures/CSharpTest/SplitOrMergeIfStatements/MergeNestedIfStatementsTests_WithOuter.cs</File>
      <File>src/EditorFeatures/CSharpTest/SplitOrMergeIfStatements/SplitIntoConsecutiveIfStatementsTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/SplitOrMergeIfStatements/SplitIntoNestedIfStatementsTests.cs</File>
      <File>src/Features/CSharp/Portable/SplitOrMergeIfStatements/CSharpIfLikeStatementGenerator.cs</File>
      <File>src/Features/CSharp/Portable/SplitOrMergeIfStatements/CSharpMergeConsecutiveIfStatementsCodeRefactoringProvider.cs</File>
      <File>src/Features/CSharp/Portable/SplitOrMergeIfStatements/CSharpMergeNestedIfStatementsCodeRefactoringProvider.cs</File>
      <File>src/Features/CSharp/Portable/SplitOrMergeIfStatements/CSharpSplitIntoConsecutiveIfStatementsCodeRefactoringProvider.cs</File>
      <File>src/Features/CSharp/Portable/SplitOrMergeIfStatements/CSharpSplitIntoNestedIfStatementsCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/CodeRefactorings/PredefinedCodeRefactoringProviderNames.cs</File>
      <File>src/Features/Core/Portable/FeaturesResources.Designer.cs</File>
      <File>src/Features/Core/Portable/SplitOrMergeIfStatements/AbstractMergeIfStatementsCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/SplitOrMergeIfStatements/AbstractSplitIfStatementCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/SplitOrMergeIfStatements/Consecutive/AbstractMergeConsecutiveIfStatementsCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/SplitOrMergeIfStatements/Consecutive/AbstractSplitIntoConsecutiveIfStatementsCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/SplitOrMergeIfStatements/IIfLikeStatementGenerator.cs</File>
      <File>src/Features/Core/Portable/SplitOrMergeIfStatements/Nested/AbstractMergeNestedIfStatementsCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/SplitOrMergeIfStatements/Nested/AbstractSplitIntoNestedIfStatementsCodeRefactoringProvider.cs</File>
      <File>src/Test/Utilities/Portable/Traits/Traits.cs</File>
      <File>src/Workspaces/CSharp/Portable/CodeGeneration/CSharpSyntaxGenerator.cs</File>
      <File>src/Workspaces/CSharp/Portable/LanguageServices/CSharpSyntaxFactsService.cs</File>
      <File>src/Workspaces/CSharp/Portable/LanguageServices/CSharpSyntaxKindsService.cs</File>
      <File>src/Workspaces/Core/Portable/Editing/SyntaxGenerator.cs</File>
      <File>src/Workspaces/Core/Portable/LanguageServices/SyntaxFactsService/ISyntaxFactsService.cs</File>
      <File>src/Workspaces/Core/Portable/LanguageServices/SyntaxFactsService/ISyntaxKindsService.cs</File>
      <File>src/Workspaces/Core/Portable/Shared/Extensions/ObjectExtensions.TypeSwitch.cs</File>
      <File>src/Workspaces/Core/Portable/Shared/Extensions/SyntaxEditorExtensions.cs</File>
      <File>src/Workspaces/Core/Portable/Shared/Extensions/TextSpanExtensions.cs</File>
      <File>src/Workspaces/Core/Portable/Utilities/IReadOnlyListExtensions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>30639</IssueID>
    <Title>Add support for ??= compound operator to the UseCompound fix</Title>
    <Description>Only enabled for C#8 or above to avoid suggesting fixes that
break compilation.
See #30009 for info.</Description>
    <CreatedDate>21/10/2018</CreatedDate>
    <ClosedDate>23/10/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>8</IssueID>
        <Title>Feature request: Async stream generators</Title>
        <Description>Currenty C# supports pull based sequence generators. 
As IObservable&amp;lt;T&amp;gt; and IObserver&amp;lt;T&amp;gt; are now in mscorlib and Rx is such a success not only in .NET but in other languages and runtimes  why not to add to C# ability to easily create async push based stream generators.

It could look like this:

``` C#
private async IObservable&lt;string&gt; GetData()
{ 
    var data = await MakeRequest();
    yield return data;
    yield return await MakeAnotherRequest();
}
```

It would complete language support in the matrix of generators:

|  | sync | async |
| --- | --- | --- |
| **single** | T | Task&amp;lt;T&amp;gt; |
| **multiple** | IEnumerable&amp;lt;T&amp;gt; | IObservable&amp;lt;T&amp;gt; |
</Description>
        <CreatedDate>15/01/2015</CreatedDate>
        <ClosedDate>29/01/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>30009</IssueID>
        <Title>UseCompoundAssignment refactoring should support `??=` operator</Title>
        <Description>The null-coalescing compound operator is being merged to master (https://github.com/dotnet/roslyn/pull/30006).

Once that is done and [UseCompoundAssignment](https://github.com/dotnet/roslyn/pull/29919) is merged, then it can be used for `??=` too. </Description>
        <CreatedDate>18/09/2018</CreatedDate>
        <ClosedDate>31/10/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/UseCompoundAssignment/UseCompoundAssignmentTests.cs</File>
      <File>src/Features/CSharp/Portable/UseCompoundAssignment/CSharpUseCompoundAssignmentDiagnosticAnalyzer.cs</File>
      <File>src/Features/CSharp/Portable/UseCompoundAssignment/Utilities.cs</File>
      <File>src/Features/Core/Portable/UseCompoundAssignment/AbstractUseCompoundAssignmentDiagnosticAnalyzer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>30616</IssueID>
    <Title>Address a number of issues around generic type substitution and nullability.</Title>
    <Description>Fixes #28684.
Fixes #29837.
Fixes #30001.
Fixes #30052.
Fixes #30054.
Fixes #30068.
Fixes #30072.
Fixes #30178.
Fixes #30220.</Description>
    <CreatedDate>19/10/2018</CreatedDate>
    <ClosedDate>23/10/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>28684</IssueID>
        <Title>Annotations are ignored when comparing overridden method with [NonNullTypes(false)]</Title>
        <Description>No warnings are reported for `B.F` and `B.G` even though the annotations do not match the overridden methods in `A`.

See `Overriding_23`:

```c#
using System.Runtime.CompilerServices;
namespace System.Runtime.CompilerServices
{
    public sealed class NonNullTypesAttribute : Attribute
    {
        public NonNullTypesAttribute(bool flag) { }
    }
}
[NonNullTypes(true)]
abstract class A
{
    internal abstract string F();
    internal abstract object?[] G();
}
[NonNullTypes(false)]
abstract class B : A
{
    internal override abstract string? F(); // does not match string
    internal override abstract object[] G(); // does not match object?[]
}
```</Description>
        <CreatedDate>19/07/2018</CreatedDate>
        <ClosedDate>23/10/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>29837</IssueID>
        <Title>Return type of constructed method has unknown nullability</Title>
        <Description>The return type of `F2(x)` is `I&lt;object!&gt;~` rather than `I&lt;object!&gt;!`:
```c#
[module: System.Runtime.CompilerServices.NonNullTypes]
interface I&lt;T&gt; { }
class C
{
    static I&lt;object&gt; F1&lt;T&gt;(T arg) =&gt; throw null;
    static I&lt;T&gt; F2&lt;T&gt;(T arg) =&gt; throw null;
    static void M(object x)
    {
        F1(x) // I&lt;object!&gt;!
        F2(x) // I&lt;object!&gt;~
    }
}
```</Description>
        <CreatedDate>13/09/2018</CreatedDate>
        <ClosedDate>23/10/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>30001</IssueID>
        <Title>NonNullTypes(true) context is getting dropped from unannotated type during construction, causing missing diagnostics</Title>
        <Description>```
        [Fact]
        public void ConstraintCyclesFromMetadata_01()
        {
            var source0 =
@"using System;
public class A0&lt;T&gt; where T : IEquatable&lt;T&gt; { }
public class A1&lt;T&gt; where T : class, IEquatable&lt;T&gt; { }

public class A3&lt;T&gt; where T : struct, IEquatable&lt;T&gt; { }
public class A4&lt;T&gt; where T : struct, IEquatable&lt;T?&gt; { }
public class A5&lt;T&gt; where T : IEquatable&lt;string?&gt; { }
public class A6&lt;T&gt; where T : IEquatable&lt;int?&gt; { }";
            var source =
@"class B
{
    static void Main()
    {
        new A0&lt;string?&gt;(); // 1
        new A0&lt;string&gt;();


        new A5&lt;string?&gt;(); // 4
        new A5&lt;string&gt;(); // 5
    }
}";
            // No [NullNullTypes]
            var comp0 = CreateCompilation(source0);
            var ref0 = comp0.EmitToImageReference();
            var comp = CreateCompilation(source, references: new[] { ref0 });

            var expectedDiagnostics = new[]
            {
                // (5,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '[NonNullTypes(true)]' context.
                //         new A0&lt;string?&gt;(); // 1
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(5, 22),
                // (9,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '[NonNullTypes(true)]' context.
                //         new A5&lt;string?&gt;(); // 4
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(9, 22)
            };

            comp.VerifyDiagnostics(expectedDiagnostics);
            verifyTypeParameterConstraint("A0", "System.IEquatable&lt;T&gt;");
            verifyTypeParameterConstraint("A1", "System.IEquatable&lt;T&gt;");
            verifyTypeParameterConstraint("A3", "System.IEquatable&lt;T&gt;");
            verifyTypeParameterConstraint("A4", "System.IEquatable&lt;T?&gt;");
            verifyTypeParameterConstraint("A5", "System.IEquatable&lt;System.String?&gt;");
            verifyTypeParameterConstraint("A6", "System.IEquatable&lt;System.Int32?&gt;");

            // [NullNullTypes(false)]
            comp0 = CreateCompilation(new[] { source0, NonNullTypesFalse, NonNullTypesAttributesDefinition });
            ref0 = comp0.EmitToImageReference();
            comp = CreateCompilation(source, references: new[] { ref0 });
            comp.VerifyDiagnostics(expectedDiagnostics);
            verifyTypeParameterConstraint("A0", "System.IEquatable&lt;T&gt;");
            verifyTypeParameterConstraint("A1", "System.IEquatable&lt;T&gt;");
            verifyTypeParameterConstraint("A3", "System.IEquatable&lt;T&gt;");
            verifyTypeParameterConstraint("A4", "System.IEquatable&lt;T?&gt;");
            verifyTypeParameterConstraint("A5", "System.IEquatable&lt;System.String?&gt;");
            verifyTypeParameterConstraint("A6", "System.IEquatable&lt;System.Int32?&gt;");

            // [NullNullTypes(true)]
            comp0 = CreateCompilation(new[] { source0, NonNullTypesTrue, NonNullTypesAttributesDefinition });
            ref0 = comp0.EmitToImageReference();
            comp = CreateCompilation(source, references: new[] { ref0 });
            // PROTOTYPE(NullableReferenceTypes): Should report a nullability mismatch warning for A0&lt;string?&gt;().
            comp.VerifyDiagnostics(
                // (5,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '[NonNullTypes(true)]' context.
                //         new A0&lt;string?&gt;(); // 1
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(5, 22),
                // (9,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '[NonNullTypes(true)]' context.
                //         new A5&lt;string?&gt;(); // 4
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(9, 22),
                // (9,16): warning CS8631: The type 'string?' cannot be used as type parameter 'T' in the generic type or method 'A5&lt;T&gt;'. Nullability of type argument 'string?' doesn't match constraint type 'System.IEquatable&lt;string?&gt;'.
                //         new A5&lt;string?&gt;(); // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "string?").WithArguments("A5&lt;T&gt;", "System.IEquatable&lt;string?&gt;", "T", "string?").WithLocation(9, 16)
                );
            verifyTypeParameterConstraint("A0", "System.IEquatable&lt;T&gt;");
            verifyTypeParameterConstraint("A1", "System.IEquatable&lt;T&gt;");
            verifyTypeParameterConstraint("A3", "System.IEquatable&lt;T&gt;");
            verifyTypeParameterConstraint("A4", "System.IEquatable&lt;T?&gt;");
            verifyTypeParameterConstraint("A5", "System.IEquatable&lt;System.String?&gt;");
            verifyTypeParameterConstraint("A6", "System.IEquatable&lt;System.Int32?&gt;");

            void verifyTypeParameterConstraint(string typeName, string expected)
            {
                var type = comp.GetMember&lt;NamedTypeSymbol&gt;(typeName);
                var constraintType = type.TypeParameters[0].ConstraintTypesNoUseSiteDiagnostics[0];
                Assert.Equal(expected, constraintType.ToTestDisplayString());
            }
        }
```</Description>
        <CreatedDate>18/09/2018</CreatedDate>
        <ClosedDate>23/10/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>30052</IssueID>
        <Title>Should follow up on PROTOTYPE comments in TypeSymbolWithAnnotations.SubstituteTypeCore</Title>
        <Description>```
        internal TypeSymbolWithAnnotations SubstituteTypeCore(AbstractTypeMap typeMap, bool withTupleUnification)
        {
            var newCustomModifiers = typeMap.SubstituteCustomModifiers(this.CustomModifiers);
            var newTypeWithModifiers = typeMap.SubstituteType(this.TypeSymbol, withTupleUnification);
            bool newIsAnnotated = this.IsAnnotated || newTypeWithModifiers.IsAnnotated;

            // PROTOTYPE(NullableReferenceTypes): Can we use Equals instead?
            if (this.TypeSymbolEquals(newTypeWithModifiers, TypeCompareKind.CompareNullableModifiersForReferenceTypes) &amp;&amp;
                newTypeWithModifiers.CustomModifiers.IsEmpty &amp;&amp;
                newIsAnnotated == this.IsAnnotated &amp;&amp;
                newCustomModifiers == this.CustomModifiers)
            {
                // PROTOTYPE(NullableReferenceTypes): We're dropping newTypeWithModifiers.NonNullTypes!
                return this; // substitution had no effect on the type or modifiers
            }

            bool newIsNullableType = newTypeWithModifiers.TypeSymbol.IsNullableType();
            if (newIsNullableType)
            {
                if (newCustomModifiers.IsEmpty)
                {
                    return newTypeWithModifiers;
                }
                newIsAnnotated = newTypeWithModifiers.IsAnnotated;
                Debug.Assert(newIsAnnotated);
            }
            else if (newCustomModifiers.IsEmpty &amp;&amp; newTypeWithModifiers.IsAnnotated == newIsAnnotated)
            {
                return newTypeWithModifiers;
            }

            return CreateNonLazyType(
                newTypeWithModifiers.TypeSymbol,
                newTypeWithModifiers.NonNullTypesContext,
                isAnnotated: newIsAnnotated,
                newTypeWithModifiers._treatPossiblyNullableReferenceTypeTypeParameterAsNullable,
                newCustomModifiers.Concat(newTypeWithModifiers.CustomModifiers));
        }
```</Description>
        <CreatedDate>20/09/2018</CreatedDate>
        <ClosedDate>23/10/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>30054</IssueID>
        <Title>Address issues with implementations of Extensions.TypeSymbolWithAnnotations.Is API</Title>
        <Description>```
            // PROTOTYPE(NullableReferenceTypes): This implementation looks
            // incorrect since a type parameter cannot be Nullable&lt;T&gt;.
            internal override bool Is(TypeSymbol typeSymbol, TypeParameterSymbol other)
            {
                if (!other.IsNullableType())
                {
                    return false;
                }

                var resolvedType = GetResolvedType();
                return resolvedType.Equals(other, TypeCompareKind.CompareNullableModifiersForReferenceTypes);
            }

            // PROTOTYPE(NullableReferenceTypes): Use WithCustomModifiers.Is() =&gt; false
            // and set IsNullable=null always for GetTypeParametersAsTypeArguments.
            internal override bool Is(TypeSymbol typeSymbol, TypeParameterSymbol other) =&gt;
                typeSymbol.Equals(other, TypeCompareKind.CompareNullableModifiersForReferenceTypes) &amp;&amp; _customModifiers.IsEmpty;
```
</Description>
        <CreatedDate>20/09/2018</CreatedDate>
        <ClosedDate>23/10/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>30068</IssueID>
        <Title>Figure out proper behavior of NamedTypeSymbol.GetTypeParametersAsTypeArguments API with regard to nullable reference types</Title>
        <Description>```
        internal ImmutableArray&lt;TypeSymbolWithAnnotations&gt; GetTypeParametersAsTypeArguments()
        {
            // PROTOTYPE(NullableReferenceTypes): Set IsNullable=null always, even in C#8,
            // and set TypeSymbolWithAnnotations.WithCustomModifiers.Is() =&gt; false.
            return this.TypeParameters.SelectAsArray((typeParameter, module) =&gt; TypeSymbolWithAnnotations.Create(nonNullTypesContext: module, typeParameter), ContainingModule);
        }
```</Description>
        <CreatedDate>20/09/2018</CreatedDate>
        <ClosedDate>23/10/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>30072</IssueID>
        <Title>Figure out what AbstractTypeMap.SubstituteType method should do about NonNullTypes context</Title>
        <Description>```
        internal TypeSymbolWithAnnotations SubstituteType(TypeSymbol previous)
        {
            if (ReferenceEquals(previous, null))
                return default(TypeSymbolWithAnnotations);

            TypeSymbol result;

            switch (previous.Kind)
            {
                case SymbolKind.NamedType:
                    result = SubstituteNamedType((NamedTypeSymbol)previous);
                    break;
                case SymbolKind.TypeParameter:
                    return SubstituteTypeParameter((TypeParameterSymbol)previous);
                case SymbolKind.ArrayType:
                    result = SubstituteArrayType((ArrayTypeSymbol)previous);
                    break;
                case SymbolKind.PointerType:
                    result = SubstitutePointerType((PointerTypeSymbol)previous);
                    break;
                case SymbolKind.DynamicType:
                    result = SubstituteDynamicType();
                    break;
                case SymbolKind.ErrorType:
                    return ((ErrorTypeSymbol)previous).Substitute(this);
                default:
                    result = previous;
                    break;
            }

            // PROTOTYPE(NullableReferenceTypes): we're dropping annotation and context
            return TypeSymbolWithAnnotations.Create(result);
        }
```</Description>
        <CreatedDate>20/09/2018</CreatedDate>
        <ClosedDate>23/10/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>30178</IssueID>
        <Title>Generic type substitution machinery "drops" non-nullable nature of types</Title>
        <Description>```
        [Fact]
        public void GenericSubstitution_01()
        {
            var source =
@"
using System.Runtime.CompilerServices;

[NonNullTypes(true)]
class A&lt;T&gt; where T : class
{
    T F;

    [NonNullTypes(false)]
    class B : A&lt;T&gt;
    {
        [NonNullTypes(true)]
        void M1()
        {
            F = null; // 1
        }
    }

    void M2()
    {
        F = null; // 2
    }

    [NonNullTypes(false)]
    class C : A&lt;C&gt;
    {
        [NonNullTypes(true)]
        void M3()
        {
            F = null; // 3
        }
    }
}
";
            var comp = CreateCompilation(new[] { source });

            // Missing warning for "F = null; // 3"
            comp.VerifyDiagnostics(
                // (5,7): warning CS8618: Non-nullable field 'F' is uninitialized.
                // class A&lt;T&gt; where T : class
                Diagnostic(ErrorCode.WRN_UninitializedNonNullableField, "A").WithArguments("field", "F").WithLocation(5, 7),
                // (7,7): warning CS0414: The field 'A&lt;T&gt;.F' is assigned but its value is never used
                //     T F;
                Diagnostic(ErrorCode.WRN_UnreferencedFieldAssg, "F").WithArguments("A&lt;T&gt;.F").WithLocation(7, 7),
                // (15,17): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //             F = null; // 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(15, 17),
                // (21,13): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F = null; // 2
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(21, 13)
                );

            var b = comp.GetTypeByMetadataName("A`1+B");
            Assert.NotNull(b);
            Assert.True(b.BaseTypeNoUseSiteDiagnostics.IsDefinition);
        }

        [Fact]
        public void GenericSubstitution_07()
        {
            var source =
@"
using System.Runtime.CompilerServices;

[NonNullTypes(true)]
class A&lt;T&gt; where T : class
{
    [NonNullTypes(false)]
    T F;

    class B : A&lt;T&gt;
    {
        void M1()
        {
            F = null; // 1
        }
    }

    class C : A&lt;C&gt;
    {
        void M3()
        {
            F = null; // 3
        }
    }
}
";
            var comp = CreateCompilation(new[] { source });

            // Missing warning for "F = null; // 1"
            comp.VerifyDiagnostics(
                // (8,7): warning CS0414: The field 'A&lt;T&gt;.F' is assigned but its value is never used
                //     T F;
                Diagnostic(ErrorCode.WRN_UnreferencedFieldAssg, "F").WithArguments("A&lt;T&gt;.F").WithLocation(8, 7),
                // (22,17): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //             F = null; // 3
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(22, 17)
                );

            var b = comp.GetTypeByMetadataName("A`1+B");
            Assert.NotNull(b);
            Assert.True(b.BaseTypeNoUseSiteDiagnostics.IsDefinition); // Should be false
        }
```

</Description>
        <CreatedDate>27/09/2018</CreatedDate>
        <ClosedDate>23/10/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>30220</IssueID>
        <Title>Missing WRN_NullabilityMismatchInTypeParameterConstraint warning when a non-nullable type parameter used as a constraint is declared in a different NonNullTypes context</Title>
        <Description>```
        [Fact]
        public void ObliviousTypeParameter_02()
        {
            var source =
$@"
#pragma warning disable {(int)ErrorCode.WRN_UnreferencedVar}
"
+
@"
using System.Runtime.CompilerServices;

[NonNullTypes(true)]
class A&lt;T1&gt; where T1 : class
{
    [NonNullTypes(false)]
    class B&lt;T2&gt; where T2 : T1 
    {
    }

    [NonNullTypes(true)]
    void M1()
    {
        B&lt;T1&gt; a1;
        B&lt;T1?&gt; b1;
        A&lt;T1&gt;.B&lt;T1&gt; c1;
        A&lt;T1&gt;.B&lt;T1?&gt; d1;
        A&lt;C&gt;.B&lt;C&gt; e1;
        A&lt;C&gt;.B&lt;C?&gt; f1;
    }
}

class C {}
";
            var comp = CreateCompilation(new[] { source });
            comp.VerifyDiagnostics(
                // (22,16): warning CS8631: The type 'C?' cannot be used as type parameter 'T2' in the generic type or method 'A&lt;C&gt;.B&lt;T2&gt;'. Nullability of type argument 'C?' doesn't match constraint type 'C'.
                //         A&lt;C&gt;.B&lt;C?&gt; f1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "C?").WithArguments("A&lt;C&gt;.B&lt;T2&gt;", "C", "T2", "C?").WithLocation(22, 16)
                );
        }
```

Expected WRN_NullabilityMismatchInTypeParameterConstraint warnings for: ```B&lt;T1?&gt; b1;``` and ```A&lt;T1&gt;.B&lt;T1?&gt; d1;```.</Description>
        <CreatedDate>28/09/2018</CreatedDate>
        <ClosedDate>23/10/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/INonNullTypesContext.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/OverloadResolution/MethodTypeInference.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/UnboundLambda.cs</File>
      <File>src/Compilers/CSharp/Portable/Emitter/Model/SymbolAdapter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/SynthesizedClosureMethod.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/MethodToClassRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/AbstractTypeMap.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/AbstractTypeParameterMap.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Compilation_WellKnownMembers.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ConstraintsHelper.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ErrorTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/EventSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/FieldSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/MemberSignatureComparer.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/MemberRefMetadataDecoder.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PENamedTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/SymbolFactory.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/MethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/NamedTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/PropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ReducedExtensionMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/LambdaSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceOrdinaryMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceTypeParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/SubstitutedMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/SubstitutedNamedTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedContainer.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedImplementationMethod.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Tuples/TupleMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/TypeMap.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/TypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/TypeSymbolWithAnnotations.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/NullableReferenceTypesTests.cs</File>
      <File>src/Compilers/Test/Utilities/CSharp/CompilationTestUtils.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Source/ExpressionCompiler/CompilationContext.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Source/ExpressionCompiler/Symbols/EEMethodSymbol.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Source/ExpressionCompiler/Symbols/EENamedTypeSymbol.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>29802</IssueID>
    <Title>Do not convert mutable value type fields to properties</Title>
    <Description>Fixes #28511 

**Customer scenario**
Customer has struct with mutable value type fields, and the use auto property code fix offered by our IDE analyzer/fixer silently changes semantics of the code.

**Bugs this fixes**
Fixes #28511 

**Workarounds, if any**
Suppress or ignore the recommendation

**Risk**
Low risk - we already handle this in MakeFieldReadOnlyDiagnosticAnalyzer in the IDE, this just extends the same check to this analyzer as well.

**Performance impact**
None

**Is this a regression from a previous update?**
No - this has been there since initial analyzer implementation in Dev15

**Root cause analysis**
Missed this scenario during unit tests.</Description>
    <CreatedDate>12/09/2018</CreatedDate>
    <ClosedDate>19/10/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>28511</IssueID>
        <Title>code fix for IDE0032 analyser (Use auto property) creates broken code</Title>
        <Description>The code fix for IDE0032 analyser (Use auto property) creates broken code. Please check the following example:

```csharp
using System.Windows;
using FluentAssertions;
using Xunit;

namespace CleanupBug
{
    public class CleanupClass
    {
        private Rect bounds = Rect.Empty;

        public Rect Bounds =&gt; this.bounds;

        public void Setup()
        {
            this.bounds = new Rect(new Point(10, 10), new Point(20, 20));
            this.bounds.Offset(10, 10);
        }
    }

    public class TestClass
    {
        [Fact]
        public void Test()
        {
            var sut = new CleanupClass();
            sut.Bounds.Should().BeEquivalentTo(Rect.Empty);

            sut.Setup();

            sut.Bounds.Should().BeEquivalentTo(new Rect(new Point(20, 20), new Point(30, 30)));
        }
    }
}
```

In VS2017 (15.7.4) the field &amp;quot;bounds&amp;quot; will be identified to be convertible to auto property.
Before applying the code fix the UnitTest succeed.
After applying the code fix the UnitTest fails.

The reason - I think - is that the Rect data will be copied when accessing the auto property with the Offset method, because Rect is a struct.
So, the original data will NOT be modified.

Either the analyzer should not get struct fields or the code fix should take care modifying access.

_This issue has been moved from https://developercommunity.visualstudio.com/content/problem/289507/code-fix-for-ide0032-analyser-use-auto-property-cr.html
VSTS ticketId: 644840_
_These are the original issue comments:_
(no comments)
_These are the original issue solutions:_
(no solutions)</Description>
        <CreatedDate>13/07/2018</CreatedDate>
        <ClosedDate>19/10/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>28511</IssueID>
        <Title>code fix for IDE0032 analyser (Use auto property) creates broken code</Title>
        <Description>The code fix for IDE0032 analyser (Use auto property) creates broken code. Please check the following example:

```csharp
using System.Windows;
using FluentAssertions;
using Xunit;

namespace CleanupBug
{
    public class CleanupClass
    {
        private Rect bounds = Rect.Empty;

        public Rect Bounds =&gt; this.bounds;

        public void Setup()
        {
            this.bounds = new Rect(new Point(10, 10), new Point(20, 20));
            this.bounds.Offset(10, 10);
        }
    }

    public class TestClass
    {
        [Fact]
        public void Test()
        {
            var sut = new CleanupClass();
            sut.Bounds.Should().BeEquivalentTo(Rect.Empty);

            sut.Setup();

            sut.Bounds.Should().BeEquivalentTo(new Rect(new Point(20, 20), new Point(30, 30)));
        }
    }
}
```

In VS2017 (15.7.4) the field &amp;quot;bounds&amp;quot; will be identified to be convertible to auto property.
Before applying the code fix the UnitTest succeed.
After applying the code fix the UnitTest fails.

The reason - I think - is that the Rect data will be copied when accessing the auto property with the Offset method, because Rect is a struct.
So, the original data will NOT be modified.

Either the analyzer should not get struct fields or the code fix should take care modifying access.

_This issue has been moved from https://developercommunity.visualstudio.com/content/problem/289507/code-fix-for-ide0032-analyser-use-auto-property-cr.html
VSTS ticketId: 644840_
_These are the original issue comments:_
(no comments)
_These are the original issue solutions:_
(no solutions)</Description>
        <CreatedDate>13/07/2018</CreatedDate>
        <ClosedDate>19/10/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/MakeFieldReadonly/MakeFieldReadonlyTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseAutoProperty/UseAutoPropertyTests.cs</File>
      <File>src/Features/Core/Portable/MakeFieldReadonly/MakeFieldReadonlyDiagnosticAnalyzer.cs</File>
      <File>src/Features/Core/Portable/UseAutoProperty/AbstractUseAutoPropertyAnalyzer.cs</File>
      <File>src/Workspaces/Core/Portable/Shared/Extensions/ITypeSymbolExtensions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>29798</IssueID>
    <Title>Do not use SQLITE_OPEN_SHAREDCACHE</Title>
    <Description>This flag can only be used when the application manages concurrency for database write operations to ensure no more than one connection is writing data at any given point. Roslyn only provides the weaker
guarantee that each connection is only used from one thread at a time, but may be used for reading or writing.

Fixes #29599

### Customer scenario

The customer impact is not completely clear from #29599, but it's my understanding that larger solutions occasionally face errors during operations that rely on the database.

### Bugs this fixes

Fixes #29599

### Workarounds, if any

None

### Risk

Well-understood, but severity is up for discussion. See Performance impact section, below.

### Performance impact

The overall runtime behavior and most performance characteristics related to SQLite connections are not changed. This change is likely to increase native memory usage by a small amount; the worst case bound for this is defined by the following:

&gt; Memory usage will get impacted. The additional caches will consume 478.125KiB\*(*n*-1), where *n* is the maximum number of thread pool threads executing code concurrently and holding an `SqlConnection` at any point in the application life.

As an example of the "large end" of the spectrum, an instance of Roslyn.sln currently running on a machine with 28 logical processors has 38 pooled connections allocated, which amounts to 17.74MiB memory. In my opinion, these numbers are enough to seriously investigate limits on the number of connections for the 16.0 release, but not enough to cover the risk/complexity of introducing the limits before that time.

### Is this a regression from a previous update?

Yes, introduced in #21532.

### Root cause analysis

It's not clear why the situation was never observed in Visual Studio. Regression prevention in SQLite connection usage relies on a general apprehension to make changes in the area without strong compelling evidence, as seen in this pull request.

### How was the bug found?

Reported by Visual Studio for Mac development team.

### Test documentation updated?

No.</Description>
    <CreatedDate>12/09/2018</CreatedDate>
    <ClosedDate>13/09/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>29599</IssueID>
        <Title>Possible multi-threading issue in Roslyn's sqlite usage</Title>
        <Description>**Version Used**: 
2.9.0-beta4-63001-02

**Steps to Reproduce**:

1. Not sure about the steps to reproduce, it happens seemingly random in VSMac

**Expected Behavior**:

Thread-safety is well defined for SQLite usage.

**Actual Behavior**:
Thread-safety is not well defined in some cases.

Looking at the value of `SQLitePCL.raw.sqlite3_threadsafe ()` advised [here](https://www.sqlite.org/c3ref/threadsafe.html), we get `1` back, which means that we get full thread safety via [Serialized](https://www.sqlite.org/compile.html#threadsafe).

So far so good, that means sqlite will handle synchronization.

The [SqlConnection](http://source.roslyn.io/#Microsoft.CodeAnalysis.Workspaces.Desktop/Workspace/SQLite/Interop/SqlConnection.cs,56) to the database used is done using `SQLITE_OPEN_NOMUTEX`, which is not the equivalent of the default, `Serialized`, but [Multi-threaded](https://www.sqlite.org/c3ref/open.html), so it does not handle mutexes on the prepared statements.

The locked database is not the same as a busy database, as per [the docs](https://www.sqlite.org/cvstrac/wiki?p=DatabaseIsLocked). This means that we're doing hitting case 3 from that link, which is running 2 selects in parallel with no mutexes.

```
ERROR [2018-08-30 08:32:59Z]: Roslyn error: StorageDatabase_Exceptions Kind=Microsoft.CodeAnalysis.SQLite.Interop.SqlException|Reason=Microsoft.CodeAnalysis.SQLite.Interop.SqlException: database table is locked: SolutionData1
database table is locked
  at Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection.Throw (SQLitePCL.sqlite3 handle, Microsoft.CodeAnalysis.SQLite.Interop.Result result) [0x00000] in /_/src/Workspaces/Core/Desktop/Workspace/SQLite/Interop/SqlConnection.cs:284 
  at Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection.ThrowIfNotOk (SQLitePCL.sqlite3 handle, Microsoft.CodeAnalysis.SQLite.Interop.Result result) [0x00003] in /_/src/Workspaces/Core/Desktop/Workspace/SQLite/Interop/SqlConnection.cs:276 
  at Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection.ThrowIfNotOk (Microsoft.CodeAnalysis.SQLite.Interop.Result result) [0x00000] in /_/src/Workspaces/Core/Desktop/Workspace/SQLite/Interop/SqlConnection.cs:270 
  at Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection.ThrowIfNotOk (System.Int32 result) [0x00000] in /_/src/Workspaces/Core/Desktop/Workspace/SQLite/Interop/SqlConnection.cs:267 
  at Microsoft.CodeAnalysis.SQLite.Interop.SqlStatement.Reset () [0x00000] in /_/src/Workspaces/Core/Desktop/Workspace/SQLite/Interop/SqlStatement.cs:43 
  at Microsoft.CodeAnalysis.SQLite.Interop.ResettableSqlStatement.Dispose () [0x00000] in /_/src/Workspaces/Core/Desktop/Workspace/SQLite/Interop/ResettableSqlStatement.cs:34 
  at Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage+Accessor`3[TKey,TWriteQueueKey,TDatabaseId].TryGetRowIdWorker (Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection connection, TDatabaseId dataId, System.Int64&amp; rowId) [0x00047] in /_/src/Workspaces/Core/Desktop/Workspace/SQLite/SQLitePersistentStorage.Accessor.cs:209 
  at Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage+Accessor`3[TKey,TWriteQueueKey,TDatabaseId].TryGetRowId (Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection connection, TDatabaseId dataId, System.Int64&amp; rowId) [0x00000] in /_/src/Workspaces/Core/Desktop/Workspace/SQLite/SQLitePersistentStorage.Accessor.cs:183 
  at Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage+Accessor`3[TKey,TWriteQueueKey,TDatabaseId].ReadBlob (Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection connection, TDatabaseId dataId) [0x00000] in /_/src/Workspaces/Core/Desktop/Workspace/SQLite/SQLitePersistentStorage.Accessor.cs:142 
  at Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage+Accessor`3+&lt;ReadStreamAsync&gt;d__11[TKey,TWriteQueueKey,TDatabaseId].MoveNext () [0x000f6] in /_/src/Workspaces/Core/Desktop/Workspace/SQLite/SQLitePersistentStorage.Accessor.cs:82 
```
</Description>
        <CreatedDate>30/08/2018</CreatedDate>
        <ClosedDate>13/09/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>29599</IssueID>
        <Title>Possible multi-threading issue in Roslyn's sqlite usage</Title>
        <Description>**Version Used**: 
2.9.0-beta4-63001-02

**Steps to Reproduce**:

1. Not sure about the steps to reproduce, it happens seemingly random in VSMac

**Expected Behavior**:

Thread-safety is well defined for SQLite usage.

**Actual Behavior**:
Thread-safety is not well defined in some cases.

Looking at the value of `SQLitePCL.raw.sqlite3_threadsafe ()` advised [here](https://www.sqlite.org/c3ref/threadsafe.html), we get `1` back, which means that we get full thread safety via [Serialized](https://www.sqlite.org/compile.html#threadsafe).

So far so good, that means sqlite will handle synchronization.

The [SqlConnection](http://source.roslyn.io/#Microsoft.CodeAnalysis.Workspaces.Desktop/Workspace/SQLite/Interop/SqlConnection.cs,56) to the database used is done using `SQLITE_OPEN_NOMUTEX`, which is not the equivalent of the default, `Serialized`, but [Multi-threaded](https://www.sqlite.org/c3ref/open.html), so it does not handle mutexes on the prepared statements.

The locked database is not the same as a busy database, as per [the docs](https://www.sqlite.org/cvstrac/wiki?p=DatabaseIsLocked). This means that we're doing hitting case 3 from that link, which is running 2 selects in parallel with no mutexes.

```
ERROR [2018-08-30 08:32:59Z]: Roslyn error: StorageDatabase_Exceptions Kind=Microsoft.CodeAnalysis.SQLite.Interop.SqlException|Reason=Microsoft.CodeAnalysis.SQLite.Interop.SqlException: database table is locked: SolutionData1
database table is locked
  at Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection.Throw (SQLitePCL.sqlite3 handle, Microsoft.CodeAnalysis.SQLite.Interop.Result result) [0x00000] in /_/src/Workspaces/Core/Desktop/Workspace/SQLite/Interop/SqlConnection.cs:284 
  at Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection.ThrowIfNotOk (SQLitePCL.sqlite3 handle, Microsoft.CodeAnalysis.SQLite.Interop.Result result) [0x00003] in /_/src/Workspaces/Core/Desktop/Workspace/SQLite/Interop/SqlConnection.cs:276 
  at Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection.ThrowIfNotOk (Microsoft.CodeAnalysis.SQLite.Interop.Result result) [0x00000] in /_/src/Workspaces/Core/Desktop/Workspace/SQLite/Interop/SqlConnection.cs:270 
  at Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection.ThrowIfNotOk (System.Int32 result) [0x00000] in /_/src/Workspaces/Core/Desktop/Workspace/SQLite/Interop/SqlConnection.cs:267 
  at Microsoft.CodeAnalysis.SQLite.Interop.SqlStatement.Reset () [0x00000] in /_/src/Workspaces/Core/Desktop/Workspace/SQLite/Interop/SqlStatement.cs:43 
  at Microsoft.CodeAnalysis.SQLite.Interop.ResettableSqlStatement.Dispose () [0x00000] in /_/src/Workspaces/Core/Desktop/Workspace/SQLite/Interop/ResettableSqlStatement.cs:34 
  at Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage+Accessor`3[TKey,TWriteQueueKey,TDatabaseId].TryGetRowIdWorker (Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection connection, TDatabaseId dataId, System.Int64&amp; rowId) [0x00047] in /_/src/Workspaces/Core/Desktop/Workspace/SQLite/SQLitePersistentStorage.Accessor.cs:209 
  at Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage+Accessor`3[TKey,TWriteQueueKey,TDatabaseId].TryGetRowId (Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection connection, TDatabaseId dataId, System.Int64&amp; rowId) [0x00000] in /_/src/Workspaces/Core/Desktop/Workspace/SQLite/SQLitePersistentStorage.Accessor.cs:183 
  at Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage+Accessor`3[TKey,TWriteQueueKey,TDatabaseId].ReadBlob (Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection connection, TDatabaseId dataId) [0x00000] in /_/src/Workspaces/Core/Desktop/Workspace/SQLite/SQLitePersistentStorage.Accessor.cs:142 
  at Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage+Accessor`3+&lt;ReadStreamAsync&gt;d__11[TKey,TWriteQueueKey,TDatabaseId].MoveNext () [0x000f6] in /_/src/Workspaces/Core/Desktop/Workspace/SQLite/SQLitePersistentStorage.Accessor.cs:82 
```
</Description>
        <CreatedDate>30/08/2018</CreatedDate>
        <ClosedDate>13/09/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>29599</IssueID>
        <Title>Possible multi-threading issue in Roslyn's sqlite usage</Title>
        <Description>**Version Used**: 
2.9.0-beta4-63001-02

**Steps to Reproduce**:

1. Not sure about the steps to reproduce, it happens seemingly random in VSMac

**Expected Behavior**:

Thread-safety is well defined for SQLite usage.

**Actual Behavior**:
Thread-safety is not well defined in some cases.

Looking at the value of `SQLitePCL.raw.sqlite3_threadsafe ()` advised [here](https://www.sqlite.org/c3ref/threadsafe.html), we get `1` back, which means that we get full thread safety via [Serialized](https://www.sqlite.org/compile.html#threadsafe).

So far so good, that means sqlite will handle synchronization.

The [SqlConnection](http://source.roslyn.io/#Microsoft.CodeAnalysis.Workspaces.Desktop/Workspace/SQLite/Interop/SqlConnection.cs,56) to the database used is done using `SQLITE_OPEN_NOMUTEX`, which is not the equivalent of the default, `Serialized`, but [Multi-threaded](https://www.sqlite.org/c3ref/open.html), so it does not handle mutexes on the prepared statements.

The locked database is not the same as a busy database, as per [the docs](https://www.sqlite.org/cvstrac/wiki?p=DatabaseIsLocked). This means that we're doing hitting case 3 from that link, which is running 2 selects in parallel with no mutexes.

```
ERROR [2018-08-30 08:32:59Z]: Roslyn error: StorageDatabase_Exceptions Kind=Microsoft.CodeAnalysis.SQLite.Interop.SqlException|Reason=Microsoft.CodeAnalysis.SQLite.Interop.SqlException: database table is locked: SolutionData1
database table is locked
  at Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection.Throw (SQLitePCL.sqlite3 handle, Microsoft.CodeAnalysis.SQLite.Interop.Result result) [0x00000] in /_/src/Workspaces/Core/Desktop/Workspace/SQLite/Interop/SqlConnection.cs:284 
  at Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection.ThrowIfNotOk (SQLitePCL.sqlite3 handle, Microsoft.CodeAnalysis.SQLite.Interop.Result result) [0x00003] in /_/src/Workspaces/Core/Desktop/Workspace/SQLite/Interop/SqlConnection.cs:276 
  at Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection.ThrowIfNotOk (Microsoft.CodeAnalysis.SQLite.Interop.Result result) [0x00000] in /_/src/Workspaces/Core/Desktop/Workspace/SQLite/Interop/SqlConnection.cs:270 
  at Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection.ThrowIfNotOk (System.Int32 result) [0x00000] in /_/src/Workspaces/Core/Desktop/Workspace/SQLite/Interop/SqlConnection.cs:267 
  at Microsoft.CodeAnalysis.SQLite.Interop.SqlStatement.Reset () [0x00000] in /_/src/Workspaces/Core/Desktop/Workspace/SQLite/Interop/SqlStatement.cs:43 
  at Microsoft.CodeAnalysis.SQLite.Interop.ResettableSqlStatement.Dispose () [0x00000] in /_/src/Workspaces/Core/Desktop/Workspace/SQLite/Interop/ResettableSqlStatement.cs:34 
  at Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage+Accessor`3[TKey,TWriteQueueKey,TDatabaseId].TryGetRowIdWorker (Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection connection, TDatabaseId dataId, System.Int64&amp; rowId) [0x00047] in /_/src/Workspaces/Core/Desktop/Workspace/SQLite/SQLitePersistentStorage.Accessor.cs:209 
  at Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage+Accessor`3[TKey,TWriteQueueKey,TDatabaseId].TryGetRowId (Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection connection, TDatabaseId dataId, System.Int64&amp; rowId) [0x00000] in /_/src/Workspaces/Core/Desktop/Workspace/SQLite/SQLitePersistentStorage.Accessor.cs:183 
  at Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage+Accessor`3[TKey,TWriteQueueKey,TDatabaseId].ReadBlob (Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection connection, TDatabaseId dataId) [0x00000] in /_/src/Workspaces/Core/Desktop/Workspace/SQLite/SQLitePersistentStorage.Accessor.cs:142 
  at Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage+Accessor`3+&lt;ReadStreamAsync&gt;d__11[TKey,TWriteQueueKey,TDatabaseId].MoveNext () [0x000f6] in /_/src/Workspaces/Core/Desktop/Workspace/SQLite/SQLitePersistentStorage.Accessor.cs:82 
```
</Description>
        <CreatedDate>30/08/2018</CreatedDate>
        <ClosedDate>13/09/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>21532</IssueID>
        <Title>3 product changes and 1 test change on sqlite persisted storage</Title>
        <Description>#1. made persisted storage exclusive to 1 process. like before, second VS with same solution will not use persisted storage.
#2, tweaked sqlite to share cache between connections like esent. (this is supposed to use less memory since same cache will be re-used by all connection rather than each connection having its own cache)
#3, made VS and OOP to use different db files (we can make them to share if we want to, but for now, nobody requires it so we create 2 different db)

..

made OOP mock to enable persisted service.
</Description>
        <CreatedDate>15/08/2017</CreatedDate>
        <ClosedDate>16/08/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Workspaces/Core/Desktop/Workspace/SQLite/Interop/OpenFlags.cs</File>
      <File>src/Workspaces/Core/Desktop/Workspace/SQLite/Interop/SqlConnection.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>29794</IssueID>
    <Title>Add parameter CodefixProvider: Fix argument list handling of local functions </Title>
    <Description>Fixes #29752
Fixes #29753

Note to reviewers:
The diff shows a lot of changes for CSharpSyntaxGenerator.cs which are actually only whitespace related. 
You should turn on *[Hide whitespace changes](https://github.com/dotnet/roslyn/pull/29794/files?utf8=%E2%9C%93&amp;diff=unified&amp;w=1)* in the diff settings.</Description>
    <CreatedDate>12/09/2018</CreatedDate>
    <ClosedDate>01/10/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>29752</IssueID>
        <Title>Action to add a new parameter to a local function actually replaces existing one</Title>
        <Description>**Version Used**: 

Microsoft Visual Studio Professional 2017 
Version 15.8.2
VisualStudio.15.Release/15.8.2+28010.2016
Microsoft .NET Framework
Version 4.7.03056

**Steps to Reproduce**:

Paste the following code into VS:
```cs
class Rsrp
{
  public void M()
  {
    Local("ignore this", mynewparameter: true);
    void Local(string whatever)
    {
      
    }
  }
}
```

Execute 'Add parameter to Local(string)' action from the 'mynewparameter' identifier.

**Expected Behavior**:

New parameter is created in the local function.

**Actual Behavior**:

Existing parameter is replaced.

![image](https://user-images.githubusercontent.com/5566206/45312484-e6359c00-b534-11e8-8a18-8aca305bb0eb.png)
</Description>
        <CreatedDate>10/09/2018</CreatedDate>
        <ClosedDate>01/10/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>29753</IssueID>
        <Title>ArgumentOutOfRangeException from 'add parameter' code fix</Title>
        <Description>**Version Used**: 

Microsoft Visual Studio Professional 2017
Version 15.8.2
VisualStudio.15.Release/15.8.2+28010.2016
Microsoft .NET Framework
Version 4.7.03056

**Steps to Reproduce**:

Paste the following code into VS:
```cs
class Rsrp
{
  public void M()
  {
    Local("ignore this", true);
    void Local(string whatever)
    {
      
    }
  }
}
```

Place the caret on the `Local` function invocation and open bulb items menu.

**Expected Behavior**:

No exceptions.

**Actual Behavior**:

```
System.ArgumentOutOfRangeException : Specified argument was out of the range of valid values.
Parameter name: index
   at Roslyn.Utilities.SpecializedCollections.Empty.List`1.get_Item(Int32 index)
   at async Microsoft.CodeAnalysis.AddParameter.AbstractAddParameterCodeFixProvider`6.FixAsync[TArgumentSyntax,TAttributeArgumentSyntax,TArgumentListSyntax,TAttributeArgumentListSyntax,TInvocationExpressionSyntax,TObjectCreationExpressionSyntax](&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeActions.CodeAction.ComputeOperationsAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeActions.CodeAction.GetPreviewOperationsAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.Editor.Implementation.Suggestions.SuggestedAction.GetPreviewResultAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.Editor.Implementation.Suggestions.SuggestedActionWithNestedFlavors.&lt;&gt;c__DisplayClass11_0.&lt;GetPreviewAsync&gt;b__0(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.Extensions.IExtensionManagerExtensions.PerformFunctionAsync[T](&lt;Unknown Parameters&gt;)
```
</Description>
        <CreatedDate>10/09/2018</CreatedDate>
        <ClosedDate>01/10/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/AddParameter/AddParameterTests.cs</File>
      <File>src/Workspaces/CSharp/Portable/CodeGeneration/CSharpSyntaxGenerator.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>29309</IssueID>
    <Title>Require JoinableTaskContext be provided in the MEF container for EditorFeatures</Title>
    <Description>This requirement was inherited from other dependencies, and does not introduce new requirements for downstream components. The dependency requirement is leveraged to simplify code on production code paths.

Fixes #29278
Closes #29279</Description>
    <CreatedDate>15/08/2018</CreatedDate>
    <ClosedDate>23/01/2019</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>29278</IssueID>
        <Title>Eliminate ForegroundThreadDataKind</Title>
        <Description>From #28781:

&gt; Eliminate `ForegroundThreadDataKind`, and gut or eliminate `ForegroundThreadAffinitizedObject` https://github.com/dotnet/roslyn/pull/28781#discussion_r208386101</Description>
        <CreatedDate>14/08/2018</CreatedDate>
        <ClosedDate>23/01/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>29279</IssueID>
        <Title>Consider making JoinableTaskContext a required import</Title>
        <Description>From https://github.com/dotnet/roslyn/pull/28781#discussion_r208386283:

&gt; Consider making `JoinableTaskContext` a required import for `ThreadingContext`</Description>
        <CreatedDate>14/08/2018</CreatedDate>
        <ClosedDate>23/01/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/Core/Shared/Utilities/ThreadingContext.cs</File>
      <File>src/Workspaces/Core/Portable/Utilities/ForegroundThreadDataKind.cs</File>
      <File>src/Workspaces/CoreTestUtilities/MEF/UseExportProviderAttribute.cs</File>
      <File>src/Workspaces/CoreTestUtilities/TestExportJoinableTaskContext+DenyExecutionSynchronizationContext.cs</File>
      <File>src/Workspaces/CoreTestUtilities/TestExportJoinableTaskContext.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>29243</IssueID>
    <Title>Avoid reentrancy in ConditionalWeakTable</Title>
    <Description>Fixes #28256 

### Customer scenario

Runs Visual Studio for Mac on Mono.

### Bugs this fixes

#28256

### Workarounds, if any

None

### Risk

Low. A call sequence is split to break recursion without changing the overall algorithm.

### Performance impact

Negligible.

### Is this a regression from a previous update?

No.

### Root cause analysis

The .NET Framework supports the case in question without causing problems. The bug only appears in certain cases when running on Mono.

### How was the bug found?

Reported by @KirillOsenkov from a review of Visual Studio for Mac customer reports.

### Test documentation updated?

N/A

&lt;/details&gt;</Description>
    <CreatedDate>13/08/2018</CreatedDate>
    <ClosedDate>15/08/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>28256</IssueID>
        <Title>Reentrancy in SnapshotSourceText.From() causes exception on Mono</Title>
        <Description>See Mono Runtime bug https://github.com/mono/mono/issues/8700

Roslyn has a situation where the delegate used to create the value when ConditionalWeakTable.GetValue returns false goes ahead and reentrantly adds the same value to the weak table, so by the time the delegate returns and the ConditionalWeakTable wants to add the result, it is already there, causing this line to throw:
https://github.com/mono/mono/blob/217a1424ee083283f53ccda4b8be8ff87d62463f/mcs/class/corlib/System.Runtime.CompilerServices/ConditionalWeakTable.cs#L201

While we work with the Mono runtime team to try to fix this bug, it would be nice to see if the Roslyn team can find a workaround that would avoid reentrancy here. Maybe a simple lock as a temporary workaround. Even if the runtime team fixes the bug, it will take time for the fixed version of Mono to propagate around, so ideally we'd need a fix in Roslyn.</Description>
        <CreatedDate>03/07/2018</CreatedDate>
        <ClosedDate>15/08/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>28256</IssueID>
        <Title>Reentrancy in SnapshotSourceText.From() causes exception on Mono</Title>
        <Description>See Mono Runtime bug https://github.com/mono/mono/issues/8700

Roslyn has a situation where the delegate used to create the value when ConditionalWeakTable.GetValue returns false goes ahead and reentrantly adds the same value to the weak table, so by the time the delegate returns and the ConditionalWeakTable wants to add the result, it is already there, causing this line to throw:
https://github.com/mono/mono/blob/217a1424ee083283f53ccda4b8be8ff87d62463f/mcs/class/corlib/System.Runtime.CompilerServices/ConditionalWeakTable.cs#L201

While we work with the Mono runtime team to try to fix this bug, it would be nice to see if the Roslyn team can find a workaround that would avoid reentrancy here. Maybe a simple lock as a temporary workaround. Even if the runtime team fixes the bug, it will take time for the fixed version of Mono to propagate around, so ideally we'd need a fix in Roslyn.</Description>
        <CreatedDate>03/07/2018</CreatedDate>
        <ClosedDate>15/08/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/Text/Extensions.SnapshotSourceText.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>29243</IssueID>
    <Title>Avoid reentrancy in ConditionalWeakTable</Title>
    <Description>Fixes #28256 

### Customer scenario

Runs Visual Studio for Mac on Mono.

### Bugs this fixes

#28256

### Workarounds, if any

None

### Risk

Low. A call sequence is split to break recursion without changing the overall algorithm.

### Performance impact

Negligible.

### Is this a regression from a previous update?

No.

### Root cause analysis

The .NET Framework supports the case in question without causing problems. The bug only appears in certain cases when running on Mono.

### How was the bug found?

Reported by @KirillOsenkov from a review of Visual Studio for Mac customer reports.

### Test documentation updated?

N/A

&lt;/details&gt;</Description>
    <CreatedDate>13/08/2018</CreatedDate>
    <ClosedDate>15/08/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>28256</IssueID>
        <Title>Reentrancy in SnapshotSourceText.From() causes exception on Mono</Title>
        <Description>See Mono Runtime bug https://github.com/mono/mono/issues/8700

Roslyn has a situation where the delegate used to create the value when ConditionalWeakTable.GetValue returns false goes ahead and reentrantly adds the same value to the weak table, so by the time the delegate returns and the ConditionalWeakTable wants to add the result, it is already there, causing this line to throw:
https://github.com/mono/mono/blob/217a1424ee083283f53ccda4b8be8ff87d62463f/mcs/class/corlib/System.Runtime.CompilerServices/ConditionalWeakTable.cs#L201

While we work with the Mono runtime team to try to fix this bug, it would be nice to see if the Roslyn team can find a workaround that would avoid reentrancy here. Maybe a simple lock as a temporary workaround. Even if the runtime team fixes the bug, it will take time for the fixed version of Mono to propagate around, so ideally we'd need a fix in Roslyn.</Description>
        <CreatedDate>03/07/2018</CreatedDate>
        <ClosedDate>15/08/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>28256</IssueID>
        <Title>Reentrancy in SnapshotSourceText.From() causes exception on Mono</Title>
        <Description>See Mono Runtime bug https://github.com/mono/mono/issues/8700

Roslyn has a situation where the delegate used to create the value when ConditionalWeakTable.GetValue returns false goes ahead and reentrantly adds the same value to the weak table, so by the time the delegate returns and the ConditionalWeakTable wants to add the result, it is already there, causing this line to throw:
https://github.com/mono/mono/blob/217a1424ee083283f53ccda4b8be8ff87d62463f/mcs/class/corlib/System.Runtime.CompilerServices/ConditionalWeakTable.cs#L201

While we work with the Mono runtime team to try to fix this bug, it would be nice to see if the Roslyn team can find a workaround that would avoid reentrancy here. Maybe a simple lock as a temporary workaround. Even if the runtime team fixes the bug, it will take time for the fixed version of Mono to propagate around, so ideally we'd need a fix in Roslyn.</Description>
        <CreatedDate>03/07/2018</CreatedDate>
        <ClosedDate>15/08/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/Text/Extensions.SnapshotSourceText.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>28983</IssueID>
    <Title>Fix IntroduceVariable when the textSpan is whitespace</Title>
    <Description>If the textSpan is a span of whitespace that is itself surrounded by
whitespace, trying to recover by getting the next token and creating a
new textSpan will result in a gold bar. This change prevents the gold bar by
checking the proposed newStart position and returning if it is past
the end position.

This fixes #27949 and fixes #28665.</Description>
    <CreatedDate>31/07/2018</CreatedDate>
    <ClosedDate>02/08/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>27949</IssueID>
        <Title>IntroduceVariableCodeRefactoringProviderSystem.ArgumentOutOfRangeException : 'end' must not be less than 'start'</Title>
        <Description>Had the following invalid code while refactoring:

``` C#

        public static ImageMoniker ApplicationPrivate = return new ImageMoniker { Guid = s_manifestGuid, Id = 0 };
        public static ImageMoniker ApplicationWarning = return new ImageMoniker { Guid = s_manifestGuid, Id = 1 };

        public static ImageMoniker CodeInformationPrivate = return new ImageMoniker { Guid = s_manifestGuid, Id = 2 };

        public static ImageMoniker CodeInformationWarning = return new ImageMoniker { Guid = s_manifestGuid, Id = 3 };

        public static ImageMoniker Component = return new ImageMoniker { Guid = s_manifestGuid, Id = 4 };

        public static ImageMoniker ComponentPrivate = return new ImageMoniker { Guid = s_manifestGuid, Id = 5 };

        public static ImageMoniker ComponentWarning = return new ImageMoniker { Guid = s_manifestGuid, Id = 6 };
        public static ImageMoniker ErrorSmall = return new ImageMoniker { Guid = s_manifestGuid, Id = 7 };
```


```
System.ArgumentOutOfRangeException : 'end' must not be less than 'start'
Parameter name: end
   at Microsoft.CodeAnalysis.Text.TextSpan.FromBounds(Int32 start,Int32 end)
   at Microsoft.CodeAnalysis.IntroduceVariable.AbstractIntroduceVariableService`6.State.GetExpressionUnderSpan(SyntaxTree tree,TextSpan textSpan,CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.IntroduceVariable.AbstractIntroduceVariableService`6.State.TryInitialize(TextSpan textSpan,CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.IntroduceVariable.AbstractIntroduceVariableService`6.State.Generate(TService service,SemanticDocument document,TextSpan textSpan,CancellationToken cancellationToken)
   at async Microsoft.CodeAnalysis.IntroduceVariable.AbstractIntroduceVariableService`6.IntroduceVariableAsync[TService,TExpressionSyntax,TTypeSyntax,TTypeDeclarationSyntax,TQueryExpressionSyntax,TNameSyntax](&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.IntroduceVariable.IntroduceVariableCodeRefactoringProvider.ComputeRefactoringsAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringService.GetRefactoringFromProviderAsync(&lt;Unknown Parameters&gt;)
   at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject)
```</Description>
        <CreatedDate>18/06/2018</CreatedDate>
        <ClosedDate>02/08/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>28665</IssueID>
        <Title>IntroduceVariableCodeRefactoringProvider throws ArgumentOutOfRangeException when highlighting whitespace between attribute arguments</Title>
        <Description>
1. Replace the $$$$ with whitespace, and highlight the same location with mouse 

``` C#
public partial class AbstractEvaluationCommandLineHandlerTests
{
    [InlineData("A.cs;B.cs;C.cs",     $$$$     "B.cs;C.cs", "D.cs;E.cs", @"C:\Project\A.cs;C:\Project\D.cs;C:\Project\E.cs")]
    public void ApplyEvaluationChanges_WithExistingDesignTimeChanges_CanRenameItem(string currentFiles, string originalNames, string newNames, string expected)
    {
    }
}
```

```
System.ArgumentOutOfRangeException : 'end' must not be less than 'start'
Parameter name: end
   at Microsoft.CodeAnalysis.Text.TextSpan.FromBounds(Int32 start,Int32 end)
   at Microsoft.CodeAnalysis.IntroduceVariable.AbstractIntroduceVariableService`6.State.GetExpressionUnderSpan(SyntaxTree tree,TextSpan textSpan,CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.IntroduceVariable.AbstractIntroduceVariableService`6.State.TryInitialize(TextSpan textSpan,CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.IntroduceVariable.AbstractIntroduceVariableService`6.State.Generate(TService service,SemanticDocument document,TextSpan textSpan,CancellationToken cancellationToken)
   at async Microsoft.CodeAnalysis.IntroduceVariable.AbstractIntroduceVariableService`6.IntroduceVariableAsync[TService,TExpressionSyntax,TTypeSyntax,TTypeDeclarationSyntax,TQueryExpressionSyntax,TNameSyntax](&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.IntroduceVariable.IntroduceVariableCodeRefactoringProvider.ComputeRefactoringsAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringService.GetRefactoringFromProviderAsync(&lt;Unknown Parameters&gt;)
   at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject)
```</Description>
        <CreatedDate>18/07/2018</CreatedDate>
        <ClosedDate>02/08/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/CodeActions/IntroduceVariable/IntroduceVariableTests.cs</File>
      <File>src/Features/Core/Portable/IntroduceVariable/AbstractIntroduceVariableService.State.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>28969</IssueID>
    <Title>Permit stackalloc in nested contexts.</Title>
    <Description>Permit stackalloc in nested contexts.
Fixes #26759
Additional tests are needed before integration into a product branch;
    tracked by https://github.com/dotnet/roslyn/issues/28968

The championed feature is dotnet/csharplang#1412</Description>
    <CreatedDate>31/07/2018</CreatedDate>
    <ClosedDate>14/08/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>26759</IssueID>
        <Title>Permit stackalloc in nested expressions</Title>
        <Description>Implement https://github.com/dotnet/csharplang/issues/1412 by permitting `stackalloc` expressions to be used in nested expressions rather than only at the top-level.</Description>
        <CreatedDate>10/05/2018</CreatedDate>
        <ClosedDate>14/08/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>1412</IssueID>
        <Title>New icons for rules are too small and very hard to see</Title>
        <Description>I have to squint to tell the difference between error and disabled.

(For some reason when I attach the below screenshot to the issue it seems to get magnified a little. But the real icons I see on the screen (and in my local copy of this screenshot) are even smaller. I wonder if this is because of high DPI or some such.)

![capture](https://cloud.githubusercontent.com/assets/10579684/6746601/791271e8-ce88-11e4-931e-28c8e5134718.PNG)
</Description>
        <CreatedDate>20/03/2015</CreatedDate>
        <ClosedDate>30/04/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Expressions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Statements.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/Conversions/Conversions.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/BoundSpillSequence.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/Formatting.cs</File>
      <File>src/Compilers/CSharp/Portable/CSharpResources.Designer.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/MessageID.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_Await.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_BinaryOperator.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_StackAlloc.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/SyntaxNodeExtensions.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenAsyncLocalsTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/BindingAsyncTasklikeMoreTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/StackAllocInitializerTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/StackAllocSpanExpressionsTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/UnsafeTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/Source/PropertyTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/ParserErrorMessageTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>28929</IssueID>
    <Title>Don't fire IDE0009 incorrectly in List initializers</Title>
    <Description>When analyzing Invocation expressions, don't check `InstanceReferenceKind.ImplicitReceiver` as it shouldn't be qualified.
Because it's an invocation expression when it's used to determine which qualifier setting to use it tries to use the setting for methods.

Added test cases that I believe covers the relevant scenarios for the future.
See #28509, and this also solves #28091</Description>
    <CreatedDate>28/07/2018</CreatedDate>
    <ClosedDate>16/08/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>28509</IssueID>
        <Title>IDE0009 Add 'this' or 'Me' qualification incorrectly reported</Title>
        <Description>Starting with Visual Studio 15.8.0 Preview 3, Visual Studio has started incorrectly reporting that a variable should be prefixes with `this.` when `dotnet_style_qualification_for_method` is set to true and you are using the variable in curly braces.

For example, the following shows up with errors in my IDE for `value` and `foo` inside of the curly braces due to them not being prefix'ed with `this.` which would cause this code to be invalid.

```csharp
public List&lt;String&gt; Foo(String value)
{
    var foo = "foo";
    return new List&lt;string&gt; { value, foo };
}
```

_This issue has been moved from https://developercommunity.visualstudio.com/content/problem/288604/ide0009-add-this-or-me-qualification-incorrectly-r-1.html
VSTS ticketId: 644505_
_These are the original issue comments:_
(no comments)
_These are the original issue solutions:_
(no solutions)</Description>
        <CreatedDate>13/07/2018</CreatedDate>
        <ClosedDate>16/08/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>28091</IssueID>
        <Title>IDE0009 misfires when using dictionary initializer syntax within LINQ expression</Title>
        <Description>Similar to #23381, except related to dictionary initializer instead of object initializer.

**Version Used**: VS 15.8.0 Preview 3 (27821.2.d15.8)

**Steps to Reproduce**:

```cmd
git clone https://github.com/AArnott/Nerdbank.GitVersioning.git
cd Nerdbank.GitVersioning
src\Nerdbank.GitVersioning.sln
```

Open the Nerdbank.GitVersioning.Tasks/SetCloudBuildVariables.cs file and check out the error list.

**Expected Behavior**:

No warnings.

**Actual Behavior**:

![image](https://user-images.githubusercontent.com/3548/41822764-b70121e8-77a9-11e8-9d87-c6d49c1bfbce.png)

https://github.com/AArnott/Nerdbank.GitVersioning/blob/e0ccd4cf350a11df24d73dd3a06c225f17eb9474/src/Nerdbank.GitVersioning.Tasks/SetCloudBuildVariables.cs#L57-L59
</Description>
        <CreatedDate>24/06/2018</CreatedDate>
        <ClosedDate>16/08/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/QualifyMemberAccess/QualifyMemberAccessTests.cs</File>
      <File>src/Features/Core/Portable/QualifyMemberAccess/AbstractQualifyMemberAccessDiagnosticAnalyzer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>28781</IssueID>
    <Title>Migrate to Microsoft.VisualStudio.Threading</Title>
    <Description>This change implements the first step towards Roslyn working in applications using vs-threading with reduced risk of concurrency bugs. Recommend reviewing by commit after looking at the full list to get an idea for the overall direction.

Most of the work in this change involves internal propagation of the `IThreadingContext` instance, which provides access to the `JoinableTaskFactory` used in Roslyn code.

Following this pull request, several diagnostics remain disabled.

* VSTHRD002 (Avoid problematic synchronous waits): Many of the violations reported by this can be fixed by a code fix, but the code fix is a bit buggy and I'm waiting for Microsoft/vs-threading#338 so it's easier to prepare the fixes.
* VSTHRD103 (Call async methods when in an async method): This will be sent as a follow-up pull request. The analysis will be improved by Microsoft/vs-threading#331, but I didn't see any reason why it would block our use of the analyzer.
* VSTHRD110 (Observe result of async calls): We need to establish the "Roslyn desired practice for `FileAndForget`" before enabling this diagnostic.
* VSTHRD200 (Use "Async" suffix for async methods): Will send a follow-up PR to enable this and fix all cases that aren't exposed (public API and/or IVT). It affected too many files to include here.
* VSTHRD010 (Invoke single-threaded types on Main thread): This diagnostic is enabled, but its accuracy relies heavily on configuration files provided separately. The configuration for VSSDK types ships with the VSSDK analyzers, which are not yet enabled for the full Roslyn build.

Known follow-up issues (GitHub issues will be linked here once they are available):

* Enable VSTHRD002 (see above)
* Enable VSTHRD103 (see above)
* Enable VSTHRD110 (see above)
* Enable VSTHRD200 (see above)
* Configure `WaitAndGetResult` and `WaitAndGetResult_CanCallOnBackground` as problematic synchronous waits (blocked on Microsoft/vs-threading#344)
* Review code for additional methods to consider legacy thread switching APIs (blocked on Microsoft/vs-threading#332)
* Update VSSDK analyzers to enable VSTHRD010 (see above)
* Eliminate `ForegroundThreadDataKind`, and gut or eliminate `ForegroundThreadAffinitizedObject` https://github.com/dotnet/roslyn/pull/28781#discussion_r208386101
* Consider making `JoinableTaskContext` a required import for `ThreadingContext` https://github.com/dotnet/roslyn/pull/28781#discussion_r208386283
* Eliminate `JoinableTaskFactoryTaskScheduler`, or at least add it to the set of legacy thread switching types https://github.com/dotnet/roslyn/pull/28781#discussion_r208393493
* **PERF:** Improve **CPSProject_IWorkspaceProjectContext.cs** https://github.com/dotnet/roslyn/pull/28781#discussion_r208393997
* Design, implement, and uniformly use a main thread check/assert method https://github.com/dotnet/roslyn/pull/28781#discussion_r208405703
* **PERF:** Remove `AbstractPackage.ForegroundObject`, and its costly initialization https://github.com/dotnet/roslyn/pull/28781#discussion_r208391862
* Test devenv /build https://github.com/dotnet/roslyn/pull/28781#discussion_r208392896
* Audit uses of `ContinueWith`, `SafeContinueWith`, `StartNew`, `SafeStartNew`, and `Task.Run` to identify cases where simpler approaches are viable https://github.com/dotnet/roslyn/pull/28781#discussion_r208378244
* Inconsistent use of `TestWorkspace.GetService&lt;T&gt;` and `TestWorkspace.ExportProvider.GetExportedValue&lt;T&gt;` https://github.com/dotnet/roslyn/pull/28781#discussion_r208962835

### Customer scenario

This is an internal code change that allows dotnet/roslyn to be more easily incorporated into applications that involve user interfaces and leverage the Microsoft.VisualStudio.Threading library for deadlock and reentrancy mitigation and overall best practices.

### Bugs this fixes

N/A

### Workarounds, if any

Fixing bugs as they occur.

### Risk

This change has moderate risk, but I believe it's *relatively* low risk considering its scope since existing behaviors were preserved where possible. The primary points where I see risk are the following:

* Not all portions of code were updated to follow the [Three threading rules](https://github.com/Microsoft/vs-threading/blob/master/doc/threading_rules.md), and incremental adoption of vs-threading runs a risk of deadlocks when code does not follow these rules.
* While the documented precondition of `WaitAndGetResult` was weakened, the debug assertion it contained was strengthened substantially. This code does not affect release builds, but despite the work in this pull request it may continue to affect debug pull request builds.

### Performance impact

Performance should not change substantially as a direct result of this pull request. Over time, performance should improve by allowing more code to use asynchronous operations and more efficient task continuations.

### Is this a regression from a previous update?

N/A

### Root cause analysis

N/A

### How was the bug found?

N/A

### Test documentation updated?

N/A
</Description>
    <CreatedDate>23/07/2018</CreatedDate>
    <ClosedDate>13/08/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>338</IssueID>
        <Title>Create new projects for System.Runtime.Analyzers</Title>
        <Description>This is the start of work to split up the FxCop analyzers into multiple packages that can ship with the APIs that they address.

Move rule CA1001 to this project. Rewrite the codefixer for it to be based on DocumentEditor and hence language agnostic.

Fix for CA1001 shouldn't generate a dispose method if there is already one in the type. Instead modify that method to make it the interface implementation. Adding some tests.
</Description>
        <CreatedDate>09/02/2015</CreatedDate>
        <ClosedDate>11/02/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>331</IssueID>
        <Title>Allow 'is' for static classes for compatibility</Title>
        <Description>but continue to report the diagnostic if "strict" mode is requested.
Fixes #324

&lt;!---
@huboard:{"order":324.25,"milestone_order":331,"custom_state":""}
--&gt;
</Description>
        <CreatedDate>09/02/2015</CreatedDate>
        <ClosedDate>10/02/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>344</IssueID>
        <Title>Roslyn (like the native compiler) allows default(StaticType), array of static type</Title>
        <Description>The following program shows that the Roslyn compiler (like the native compiler) allows `default(StaticType)` and allows you to create an array of a static type too. All of these break with things that the C# specification mandates. I don't think this could be fixed because that would be a breaking change, though if anyone is doing this accidentally they'd probably like to know about it.

``` cs
class Program
{
    static void Main(string[] args)
    {
        object o = default(C);
        object[] x = new [] { default(C) };
    }
}

static class C
{
}
```

&lt;!---
@huboard:{"order":3.28125,"milestone_order":344.0,"custom_state":""}
--&gt;
</Description>
        <CreatedDate>10/02/2015</CreatedDate>
        <ClosedDate>20/02/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>332</IssueID>
        <Title>Remove cancellation token from NavigateTo</Title>
        <Description>NavigateTo doesn't support cancellation when computing the display properties so the cancellation token is getting removed rather than having to manually handle an OperationCanceledException.
</Description>
        <CreatedDate>09/02/2015</CreatedDate>
        <ClosedDate>09/02/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharp/AutomaticCompletion/CSharpBraceCompletionSessionProvider.cs</File>
      <File>src/EditorFeatures/CSharp/FindUsages/CSharpFindUsagesService.cs</File>
      <File>src/EditorFeatures/CSharp/Formatting/CSharpEditorFormattingService.cs</File>
      <File>src/EditorFeatures/CSharp/Formatting/Indentation/SmartTokenFormatter.cs</File>
      <File>src/EditorFeatures/CSharp/GoToDefinition/CSharpGoToSymbolService.cs</File>
      <File>src/EditorFeatures/CSharpTest/Classification/SemanticClassifierTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Classification/SyntacticTaggerTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/CodeActions/Preview/PreviewExceptionTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/Suppression/SuppressionTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Formatting/Indentation/SmartTokenFormatterFormatRangeTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Interactive/BraceMatching/InteractiveBraceHighlightingTests.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Adornments/AbstractAdornmentManagerProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Adornments/AdornmentManager.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Completion/Presentation/CompletionPresenter.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Completion/Presentation/CompletionPresenterSession.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Completion/Presentation/CompletionSource.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Completion/Presentation/RoslynCompletionSet.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Completion/Presentation/ToolTipProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/IWpfDifferenceViewerExtensions.cs</File>
      <File>src/EditorFeatures/Core.Wpf/IWpfTextViewExtensions.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/InlineRenameService.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/InlineRenameSession.OpenTextBufferManager.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/InlineRenameSession.cs</File>
      <File>src/EditorFeatures/Core.Wpf/LineSeparators/LineSeparatorAdornmentManagerProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/LineSeparators/LineSeparatorTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/NavigateTo/NavigateToItemProvider.Searcher.cs</File>
      <File>src/EditorFeatures/Core.Wpf/NavigateTo/NavigateToItemProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Preview/PreviewFactoryService.cs</File>
      <File>src/EditorFeatures/Core.Wpf/QuickInfo/Converters/ProjectionBufferDeferredContentConverter.cs</File>
      <File>src/EditorFeatures/Core.Wpf/QuickInfo/Presentation/QuickInfoPresenter.QuickInfoPresenterSession.cs</File>
      <File>src/EditorFeatures/Core.Wpf/QuickInfo/Presentation/QuickInfoPresenter.QuickInfoSource.cs</File>
      <File>src/EditorFeatures/Core.Wpf/QuickInfo/Presentation/QuickInfoPresenter.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Structure/AbstractStructureTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Structure/BlockContextProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Structure/BlockTagState.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Structure/RoslynBlockTag.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Structure/RoslynOutliningRegionTag.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Structure/VisualStudio14StructureTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Structure/VisualStudio15StructureTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Suggestions/PreviewChanges/PreviewChangesSuggestedAction.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Suggestions/SuggestedActionWithNestedActions.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Suggestions/SuggestedActionWithNestedFlavors.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Suggestions/SuggestedActions/CodeFixSuggestedAction.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Suggestions/SuggestedActions/CodeRefactoringSuggestedAction.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Suggestions/SuggestedActions/FixAllSuggestedAction.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Suggestions/SuggestedActions/SuggestedAction.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Suggestions/SuggestedActionsSource.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Suggestions/SuggestedActionsSourceProvider.cs</File>
      <File>src/EditorFeatures/Core/CommandHandlers/AbstractCompletionCommandHandler.cs</File>
      <File>src/EditorFeatures/Core/CommandHandlers/CompletionCommandHandler.cs</File>
      <File>src/EditorFeatures/Core/CommandHandlers/QuickInfoCommandHandlerAndSourceProvider.cs</File>
      <File>src/EditorFeatures/Core/CommandHandlers/SignatureHelpCommandHandler.cs</File>
      <File>src/EditorFeatures/Core/FindReferences/FindReferencesCommandHandler.cs</File>
      <File>src/EditorFeatures/Core/FindUsages/AbstractFindUsagesService.ProgressAdapter.cs</File>
      <File>src/EditorFeatures/Core/FindUsages/AbstractFindUsagesService.cs</File>
      <File>src/EditorFeatures/Core/GoToDefinition/AbstractGoToSymbolService.cs</File>
      <File>src/EditorFeatures/Core/Implementation/AutomaticCompletion/AbstractEditorBraceCompletionSessionFactory.cs</File>
      <File>src/EditorFeatures/Core/Implementation/AutomaticCompletion/BraceCompletionSessionProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/BraceMatching/BraceHighlightingViewTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Classification/SemanticClassificationBufferTaggerProvider.Tagger.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Classification/SemanticClassificationBufferTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Classification/SemanticClassificationViewTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Classification/SyntacticClassificationTaggerProvider.TagComputer.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Classification/SyntacticClassificationTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/CodeActions/CodeActionEditHandlerService.cs</File>
      <File>src/EditorFeatures/Core/Implementation/CodeFixes/CodeFixService.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Diagnostics/AbstractDiagnosticsAdornmentTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Diagnostics/AbstractDiagnosticsTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Diagnostics/DiagnosticsClassificationTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Diagnostics/DiagnosticsSquiggleTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Diagnostics/DiagnosticsSuggestionTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/EditAndContinue/ActiveStatementTagger.cs</File>
      <File>src/EditorFeatures/Core/Implementation/EditAndContinue/ActiveStatementTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/EditAndContinue/ActiveStatementTrackingService.cs</File>
      <File>src/EditorFeatures/Core/Implementation/EditAndContinue/ReadOnlyDocumentTracker.cs</File>
      <File>src/EditorFeatures/Core/Implementation/ForegroundNotification/ForegroundNotificationService.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Formatting/FormatCommandHandler.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/AbstractController.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/Completion/AsyncCompletionService.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/Completion/Controller.Session_ComputeModel.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/Completion/Controller.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/Completion/Controller_CommitUniqueCompletionListItem.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/IDocumentProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/ModelComputation.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/QuickInfo/Controller.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/Session.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/SignatureHelp/Controller.Session.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/SignatureHelp/Controller.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/SignatureHelp/Presentation/SignatureHelpPresenter.SignatureHelpPresenterSession.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/SignatureHelp/Presentation/SignatureHelpPresenter.SignatureHelpSource.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/SignatureHelp/Presentation/SignatureHelpPresenter.cs</File>
      <File>src/EditorFeatures/Core/Implementation/KeywordHighlighting/HighlighterViewTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/NavigationBar/NavigationBarController.cs</File>
      <File>src/EditorFeatures/Core/Implementation/NavigationBar/NavigationBarControllerFactoryService.cs</File>
      <File>src/EditorFeatures/Core/Implementation/NavigationBar/NavigationBarController_ModelComputation.cs</File>
      <File>src/EditorFeatures/Core/Implementation/RenameTracking/RenameTrackingDiagnosticAnalyzer.cs</File>
      <File>src/EditorFeatures/Core/Implementation/RenameTracking/RenameTrackingTaggerProvider.RenameTrackingCommitter.cs</File>
      <File>src/EditorFeatures/Core/Implementation/RenameTracking/RenameTrackingTaggerProvider.StateMachine.cs</File>
      <File>src/EditorFeatures/Core/Implementation/RenameTracking/RenameTrackingTaggerProvider.TrackingSession.cs</File>
      <File>src/EditorFeatures/Core/Implementation/RenameTracking/RenameTrackingTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/SolutionPreviewResult.cs</File>
      <File>src/EditorFeatures/Core/ReferenceHighlighting/ReferenceHighlightingViewTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Shared/Preview/PreviewSolutionCrawlerRegistrationService.cs</File>
      <File>src/EditorFeatures/Core/Shared/Tagging/EventSources/TaggerEventSources.SemanticChangedEventSource.cs</File>
      <File>src/EditorFeatures/Core/Shared/Tagging/EventSources/TaggerEventSources.ViewSpanChangedEventSource.cs</File>
      <File>src/EditorFeatures/Core/Shared/Tagging/EventSources/TaggerEventSources.cs</File>
      <File>src/EditorFeatures/Core/Shared/Threading/AsynchronousSerialWorkQueue.cs</File>
      <File>src/EditorFeatures/Core/Shared/Utilities/ForegroundThreadAffinitizedObject.cs</File>
      <File>src/EditorFeatures/Core/Shared/Utilities/IThreadingContext.cs</File>
      <File>src/EditorFeatures/Core/Shared/Utilities/MainThreadAwaitableExtensions.cs</File>
      <File>src/EditorFeatures/Core/Shared/Utilities/ResettableDelay.cs</File>
      <File>src/EditorFeatures/Core/Shared/Utilities/ThreadingContext+DenyExecutionSynchronizationContext.cs</File>
      <File>src/EditorFeatures/Core/Shared/Utilities/ThreadingContext.cs</File>
      <File>src/EditorFeatures/Core/Tagging/AbstractAsynchronousTaggerProvider.BatchChangeNotifier.cs</File>
      <File>src/EditorFeatures/Core/Tagging/AbstractAsynchronousTaggerProvider.TagSource.cs</File>
      <File>src/EditorFeatures/Core/Tagging/AbstractAsynchronousTaggerProvider.Tagger.cs</File>
      <File>src/EditorFeatures/Core/Tagging/AbstractAsynchronousTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Tagging/AsynchronousTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Tagging/AsynchronousViewTaggerProvider.cs</File>
      <File>src/EditorFeatures/Test/CodeFixes/CodeFixServiceTests.cs</File>
      <File>src/EditorFeatures/Test/Diagnostics/DiagnosticsSquiggleTaggerProviderTests.cs</File>
      <File>src/EditorFeatures/Test/LineSeparators/AdornmentManagerTests.cs</File>
      <File>src/EditorFeatures/Test/Preview/PreviewWorkspaceTests.cs</File>
      <File>src/EditorFeatures/Test/RenameTracking/RenameTrackingTestState.cs</File>
      <File>src/EditorFeatures/Test/Structure/StructureTaggerTests.cs</File>
      <File>src/EditorFeatures/Test/Tagging/AsynchronousTaggerTests.cs</File>
      <File>src/EditorFeatures/Test/Threading/AsynchronousWorkerTests.cs</File>
      <File>src/EditorFeatures/Test/Threading/ForegroundNotificationServiceTests.cs</File>
      <File>src/EditorFeatures/TestUtilities/Async/WaitHelper.cs</File>
      <File>src/EditorFeatures/TestUtilities/AutomaticCompletion/AbstractAutomaticBraceCompletionTests.cs</File>
      <File>src/EditorFeatures/TestUtilities/BraceHighlighting/AbstractBraceHighlightingTests.cs</File>
      <File>src/EditorFeatures/TestUtilities/Diagnostics/DiagnosticTaggerWrapper.cs</File>
      <File>src/EditorFeatures/TestUtilities/EditorFactory.cs</File>
      <File>src/EditorFeatures/TestUtilities/MinimalTestExportProvider.cs</File>
      <File>src/EditorFeatures/TestUtilities/StubVsEditorAdaptersFactoryService.cs</File>
      <File>src/EditorFeatures/TestUtilities/TestExportJoinableTaskContext.cs</File>
      <File>src/EditorFeatures/TestUtilities/TestExportProvider.cs</File>
      <File>src/EditorFeatures/TestUtilities/Threading/SynchronizationContextTaskScheduler.cs</File>
      <File>src/EditorFeatures/TestUtilities/Threading/WpfTestRunner.cs</File>
      <File>src/EditorFeatures/TestUtilities/Workspaces/TestHostDocument.cs</File>
      <File>src/EditorFeatures/TestUtilities/Workspaces/TestWorkspace.cs</File>
      <File>src/Features/CSharp/Portable/ChangeSignature/CSharpChangeSignatureService.cs</File>
      <File>src/Features/Core/Portable/ChangeSignature/DelegateInvokeMethodReferenceFinder.cs</File>
      <File>src/Features/Core/Portable/Completion/Providers/AbstractMemberInsertingCompletionProvider.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/DiagnosticAnalyzerService_UpdateSource.cs</File>
      <File>src/Features/Core/Portable/ExtractInterface/AbstractExtractInterfaceService.cs</File>
      <File>src/Interactive/EditorFeatures/CSharp/Interactive/CSharpInteractiveEvaluator.cs</File>
      <File>src/Interactive/EditorFeatures/Core/CommandHandlers/InteractiveCompletionCommandHandler.cs</File>
      <File>src/Interactive/EditorFeatures/Core/Extensibility/Interactive/InteractiveEvaluator.cs</File>
      <File>src/Interactive/EditorFeatures/Core/Implementation/Completion/Presentation/CompletionPresenter.cs</File>
      <File>src/Interactive/Features/Interactive/Core/InteractiveHost.RemoteService.cs</File>
      <File>src/Scripting/CSharpTest/ScriptTests.cs</File>
      <File>src/Test/Diagnostics/TestingOnly_WaitingService.cs</File>
      <File>src/Test/Utilities/Portable/Diagnostics/CommonDiagnosticAnalyzers.cs</File>
      <File>src/VisualStudio/CSharp/Impl/EventHookup/EventHookupCommandHandler.cs</File>
      <File>src/VisualStudio/CSharp/Impl/EventHookup/EventHookupSessionManager.cs</File>
      <File>src/VisualStudio/CSharp/Impl/EventHookup/EventHookupSessionManager_EventHookupSession.cs</File>
      <File>src/VisualStudio/CSharp/Impl/LanguageService/CSharpOptionPageService.cs</File>
      <File>src/VisualStudio/CSharp/Impl/LanguageService/HACK_CSharpCreateServicesOnUIThread.cs</File>
      <File>src/VisualStudio/CSharp/Impl/ObjectBrowser/CSharpSyncClassViewCommandHandler.cs</File>
      <File>src/VisualStudio/CSharp/Impl/Progression/CSharpGraphProvider.cs</File>
      <File>src/VisualStudio/CSharp/Impl/ProjectSystemShim/CSharpProjectShim.cs</File>
      <File>src/VisualStudio/CSharp/Impl/Snippets/CSharpSnippetInfoService.cs</File>
      <File>src/VisualStudio/CSharp/Impl/Snippets/SnippetCommandHandler.cs</File>
      <File>src/VisualStudio/CSharp/Impl/Snippets/SnippetExpansionClient.cs</File>
      <File>src/VisualStudio/CSharp/Repl/CSharpVsInteractiveWindowProvider.cs</File>
      <File>src/VisualStudio/CSharp/Test/CodeModel/FileCodeModelTestHelpers.cs</File>
      <File>src/VisualStudio/CSharp/Test/EventHookup/EventHookupTestState.cs</File>
      <File>src/VisualStudio/Core/Def/Experimentation/VisualStudioExperimentationService.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/DesignerAttribute/DesignerAttributeIncrementalAnalyzer.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/DesignerAttribute/DesignerAttributeIncrementalAnalyzerProvider.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/EditAndContinue/VsENCRebuildableProjectImpl.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/EditAndContinue/VsReadOnlyDocumentTracker.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Experimentation/AnalyzerVsixSuggestedActionCallback.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Experimentation/KeybindingResetDetector.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/FindReferences/Entries/DocumentSpanEntry.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/FindReferences/StreamingFindUsagesPresenter.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/FindReferences/ToolTips/LazyToolTip.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/InfoBar/VisualStudioInfoBarService.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Interop/CleanableWeakComHandleTable.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/LanguageService/AbstractPackage.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/LanguageService/HACK_AbstractCreateServicesOnUiThread.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Library/ClassView/AbstractSyncClassViewCommandHandler.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Library/ObjectBrowser/AbstractObjectBrowserLibraryManager.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Options/LanguageSettingsPersister.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Options/LocalUserRegistryOptionPersister.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Options/RoamingVisualStudioProfileOptionPersister.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Preview/AbstractChange.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Preview/ChangeList.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Preview/PreviewEngine.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Preview/PreviewService.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Preview/PreviewUpdater.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/PreviewPane/PreviewPaneService.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Progression/GraphNavigatorExtension.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Progression/GraphProvider.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/AbstractProject.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/DocumentProvider.StandardTextDocument.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/DocumentProvider.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/Legacy/AbstractLegacyProject.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/LinkedFileUtilities.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/MetadataReferences/VisualStudioFrameworkAssemblyPathResolverFactory.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/MiscellaneousFilesWorkspace.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/VisualStudioProjectManagementService.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/VisualStudioProjectTracker.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/VisualStudioWorkspaceImpl.DeferredInitialization.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/VisualStudioWorkspaceImpl.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/VisualStudioWorkspaceImpl_IVsSolutionLoadEvents.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Remote/RemoteHostClientServiceFactory.RemoteHostClientService.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Remote/RemoteHostClientServiceFactory.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Snippets/AbstractSnippetCommandHandler.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Snippets/AbstractSnippetExpansionClient.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Snippets/AbstractSnippetInfoService.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Venus/ContainedDocument.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Venus/ContainedLanguage.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/VirtualMemoryNotificationListener.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/VsRefactorNotifyService.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Workspace/GlobalUndoServiceFactory.WorkspaceGlobalUndoTransaction.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Workspace/GlobalUndoServiceFactory.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Workspace/VisualStudioDocumentNavigationService.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Workspace/VisualStudioDocumentNavigationServiceFactory.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Workspace/VisualStudioSymbolNavigationService.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Workspace/VisualStudioTaskSchedulerFactory.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Workspace/WorkspaceFailureOutputPane.cs</File>
      <File>src/VisualStudio/Core/Def/Packaging/PackageInstallerServiceFactory.cs</File>
      <File>src/VisualStudio/Core/Def/RoslynPackage.cs</File>
      <File>src/VisualStudio/Core/Def/Shared/VisualStudioImageMonikerService.cs</File>
      <File>src/VisualStudio/Core/Def/Storage/VisualStudioPersistentStorageLocationService.cs</File>
      <File>src/VisualStudio/Core/Def/SymbolSearch/AbstractDelayStartedService.cs</File>
      <File>src/VisualStudio/Core/Def/SymbolSearch/VisualStudioSymbolSearchService.LogService.cs</File>
      <File>src/VisualStudio/Core/Def/SymbolSearch/VisualStudioSymbolSearchService.cs</File>
      <File>src/VisualStudio/Core/Impl/CodeModel/CodeModelProjectCache.cs</File>
      <File>src/VisualStudio/Core/Impl/CodeModel/CodeModelState.cs</File>
      <File>src/VisualStudio/Core/Impl/CodeModel/FileCodeModel.cs</File>
      <File>src/VisualStudio/Core/Impl/CodeModel/ProjectCodeModel.cs</File>
      <File>src/VisualStudio/Core/Impl/ProjectSystem/CPS/CPSProject.cs</File>
      <File>src/VisualStudio/Core/Impl/ProjectSystem/CPS/CPSProjectFactory.cs</File>
      <File>src/VisualStudio/Core/Impl/ProjectSystem/CPS/CPSProject_IWorkspaceProjectContext.cs</File>
      <File>src/VisualStudio/Core/Test.Next/Remote/RemoteHostClientServiceFactoryTests.cs</File>
      <File>src/VisualStudio/IntegrationTest/TestUtilities/InProcess/InProcComponent.cs</File>
      <File>src/Workspaces/Core/Portable/Formatting/Formatter.cs</File>
      <File>src/Workspaces/Core/Portable/Utilities/ForegroundThreadDataKind.cs</File>
      <File>src/Workspaces/Core/Portable/Utilities/TaskExtensions.cs</File>
      <File>src/Workspaces/CoreTestUtilities/DispatcherExtensions.cs</File>
      <File>src/Workspaces/CoreTestUtilities/TestExportJoinableTaskContext.cs</File>
      <File>src/Workspaces/CoreTestUtilities/UseExportProviderAttribute.cs</File>
      <File>src/Workspaces/MSBuildTest/MSBuildWorkspaceTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>28849</IssueID>
    <Title>Use explicit date format provider to avoid tests breaking in different locales</Title>
    <Description>When running the test `TestDuplicateConstantAttributesMetadata` for VB it fails when the system locale is set to Swedish. See issue #28830 for more details.

It would also be possible solve this by removing the explicit `ToString()` call in the VB test to match the C# test that passes. I feel this is the wrong way to go as it still leaves things to chance, better to be explicit.
&lt;details&gt;&lt;summary&gt;Ask Mode template not completed&lt;/summary&gt;

&lt;!-- This template is not always required. If you aren't sure about whether it's needed or want help filling out the sections,
submit the pull request and then ask us for help. :) --&gt;

### Customer scenario

What does the customer do to get into this situation, and why do we think this
is common enough to address for this release.  (Granted, sometimes this will be
obvious "Open project, VS crashes" but in general, I need to understand how
common a scenario is)

### Bugs this fixes
#28830 
(either VSO or GitHub links)

### Workarounds, if any

Also, why we think they are insufficient for RC vs. RC2, RC3, or RTW

### Risk
Low or none, only affects tests
This is generally a measure our how central the affected code is to adjacent
scenarios and thus how likely your fix is to destabilize a broader area of code

### Performance impact
Low or none, only affects tests
(with a brief justification for that assessment (e.g. "Low perf impact because no extra allocations/no complexity changes" vs. "Low")

### Is this a regression from a previous update?

### Root cause analysis

How did we miss it?  What tests are we adding to guard against it in the future?

### How was the bug found?
Found when working on another issue and running the test suite.
(E.g. customer reported it vs. ad hoc testing)

### Test documentation updated?

If this is a new non-compiler feature or a significant improvement to an existing feature, update https://github.com/dotnet/roslyn/wiki/Manual-Testing once you know which release it is targeting.

&lt;/details&gt;
</Description>
    <CreatedDate>26/07/2018</CreatedDate>
    <ClosedDate>27/07/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>28830</IssueID>
        <Title>VB version of TestDuplicateConstantAttributesMetadata is locale dependent</Title>
        <Description>**Version Used**: Master

**Steps to Reproduce**:

1. Set Windows to use Swedish locale for date/time and number settings
2. restore.cmd
3. build.cmd
4. test.cmd
Alternatively
2. restore.cmd
3. build in VS
4. Run the VB test `TestDuplicateConstantAttributesMetadata` only

**Expected Behavior**:
Test should pass like the C# version does.
**Actual Behavior**:
 Test fails with the following
```
Test Name:	Microsoft.CodeAnalysis.VisualBasic.UnitTests.Emit.OptionalArgumentsTests.TestDuplicateConstantAttributesMetadata
Test FullName:	Microsoft.CodeAnalysis.VisualBasic.UnitTests.Emit.OptionalArgumentsTests.TestDuplicateConstantAttributesMetadata
Test Source:	C:\code\roslyn\src\Compilers\VisualBasic\Test\Emit\Emit\OptionalArgumentsTests.vb : line 735
Test Outcome:	Failed
Test Duration:	0:00:03,188

Result StackTrace:	
at Roslyn.Test.Utilities.Desktop.DesktopRuntimeEnvironment.Execute(String moduleName, String[] args, String expectedOutput) in C:\code\roslyn\src\Test\Utilities\Portable\Platform\Desktop\DesktopRuntimeEnvironment.cs:line 245
   at Microsoft.CodeAnalysis.Test.Utilities.CompilationVerifier.Emit(String expectedOutput, Nullable`1 expectedReturnCode, String[] args, IEnumerable`1 manifestResources, EmitOptions emitOptions, Verification peVerify, SignatureDescription[] expectedSignatures) in C:\code\roslyn\src\Test\Utilities\Portable\CompilationVerifier.cs:line 114
   at Microsoft.CodeAnalysis.Test.Utilities.CommonTestBase.Emit(Compilation compilation, IEnumerable`1 dependencies, IEnumerable`1 manifestResources, SignatureDescription[] expectedSignatures, String expectedOutput, Nullable`1 expectedReturnCode, String[] args, Action`1 assemblyValidator, Action`1 symbolValidator, EmitOptions emitOptions, Verification verify) in C:\code\roslyn\src\Test\Utilities\Portable\CommonTestBase.cs:line 154
   at Microsoft.CodeAnalysis.Test.Utilities.CommonTestBase.CompileAndVerifyCommon(Compilation compilation, IEnumerable`1 manifestResources, IEnumerable`1 dependencies, Action`1 sourceSymbolValidator, Action`1 assemblyValidator, Action`1 symbolValidator, SignatureDescription[] expectedSignatures, String expectedOutput, Nullable`1 expectedReturnCode, String[] args, EmitOptions emitOptions, Verification verify) in C:\code\roslyn\src\Test\Utilities\Portable\CommonTestBase.cs:line 68
   at Microsoft.CodeAnalysis.VisualBasic.UnitTests.BasicTestBase.CompileAndVerify(Compilation compilation, IEnumerable`1 manifestResources, IEnumerable`1 dependencies, Action`1 sourceSymbolValidator, Action`1 validator, Action`1 symbolValidator, SignatureDescription[] expectedSignatures, String expectedOutput, Nullable`1 expectedReturnCode, String[] args, EmitOptions emitOptions, Verification verify) in C:\code\roslyn\src\Compilers\Test\Utilities\VisualBasic\BasicTestBase.vb:line 73
   at Microsoft.CodeAnalysis.VisualBasic.UnitTests.BasicTestBase.CompileAndVerify(Compilation compilation, XCData expectedOutput, String[] args, IEnumerable`1 manifestResources, IEnumerable`1 dependencies, Action`1 sourceSymbolValidator, Action`1 validator, Action`1 symbolValidator, SignatureDescription[] expectedSignatures, EmitOptions emitOptions, Verification verify) in C:\code\roslyn\src\Compilers\Test\Utilities\VisualBasic\BasicTestBase.vb:line 101
   at Microsoft.CodeAnalysis.VisualBasic.UnitTests.Emit.OptionalArgumentsTests.TestDuplicateConstantAttributesMetadata() in C:\code\roslyn\src\Compilers\VisualBasic\Test\Emit\Emit\OptionalArgumentsTests.vb:line 826
Result Message:	
Roslyn.Test.Utilities.ExecutionException : 
Execution failed for assembly 'C:\Users\Perbj\AppData\Local\Temp\RoslynTests'.
Expected: 
System.Reflection.Missing: System.Reflection.Missing
System.DateTime: 01/01/0001 00:00:00
System.DateTime: 01/01/0001 00:00:00
System.DateTime: 01/01/0001 00:00:00
System.Int32: 0
System.Int64: 3
System.Decimal: 3

Actual:   System.Reflection.Missing: System.Reflection.Missing
System.DateTime: 01-01-0001 00:00:00
System.DateTime: 01-01-0001 00:00:00
System.DateTime: 01-01-0001 00:00:00
System.Int32: 0
System.Int64: 3
System.Decimal: 3
```
Notice the different separators used in the date format.
</Description>
        <CreatedDate>25/07/2018</CreatedDate>
        <ClosedDate>09/09/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>28830</IssueID>
        <Title>VB version of TestDuplicateConstantAttributesMetadata is locale dependent</Title>
        <Description>**Version Used**: Master

**Steps to Reproduce**:

1. Set Windows to use Swedish locale for date/time and number settings
2. restore.cmd
3. build.cmd
4. test.cmd
Alternatively
2. restore.cmd
3. build in VS
4. Run the VB test `TestDuplicateConstantAttributesMetadata` only

**Expected Behavior**:
Test should pass like the C# version does.
**Actual Behavior**:
 Test fails with the following
```
Test Name:	Microsoft.CodeAnalysis.VisualBasic.UnitTests.Emit.OptionalArgumentsTests.TestDuplicateConstantAttributesMetadata
Test FullName:	Microsoft.CodeAnalysis.VisualBasic.UnitTests.Emit.OptionalArgumentsTests.TestDuplicateConstantAttributesMetadata
Test Source:	C:\code\roslyn\src\Compilers\VisualBasic\Test\Emit\Emit\OptionalArgumentsTests.vb : line 735
Test Outcome:	Failed
Test Duration:	0:00:03,188

Result StackTrace:	
at Roslyn.Test.Utilities.Desktop.DesktopRuntimeEnvironment.Execute(String moduleName, String[] args, String expectedOutput) in C:\code\roslyn\src\Test\Utilities\Portable\Platform\Desktop\DesktopRuntimeEnvironment.cs:line 245
   at Microsoft.CodeAnalysis.Test.Utilities.CompilationVerifier.Emit(String expectedOutput, Nullable`1 expectedReturnCode, String[] args, IEnumerable`1 manifestResources, EmitOptions emitOptions, Verification peVerify, SignatureDescription[] expectedSignatures) in C:\code\roslyn\src\Test\Utilities\Portable\CompilationVerifier.cs:line 114
   at Microsoft.CodeAnalysis.Test.Utilities.CommonTestBase.Emit(Compilation compilation, IEnumerable`1 dependencies, IEnumerable`1 manifestResources, SignatureDescription[] expectedSignatures, String expectedOutput, Nullable`1 expectedReturnCode, String[] args, Action`1 assemblyValidator, Action`1 symbolValidator, EmitOptions emitOptions, Verification verify) in C:\code\roslyn\src\Test\Utilities\Portable\CommonTestBase.cs:line 154
   at Microsoft.CodeAnalysis.Test.Utilities.CommonTestBase.CompileAndVerifyCommon(Compilation compilation, IEnumerable`1 manifestResources, IEnumerable`1 dependencies, Action`1 sourceSymbolValidator, Action`1 assemblyValidator, Action`1 symbolValidator, SignatureDescription[] expectedSignatures, String expectedOutput, Nullable`1 expectedReturnCode, String[] args, EmitOptions emitOptions, Verification verify) in C:\code\roslyn\src\Test\Utilities\Portable\CommonTestBase.cs:line 68
   at Microsoft.CodeAnalysis.VisualBasic.UnitTests.BasicTestBase.CompileAndVerify(Compilation compilation, IEnumerable`1 manifestResources, IEnumerable`1 dependencies, Action`1 sourceSymbolValidator, Action`1 validator, Action`1 symbolValidator, SignatureDescription[] expectedSignatures, String expectedOutput, Nullable`1 expectedReturnCode, String[] args, EmitOptions emitOptions, Verification verify) in C:\code\roslyn\src\Compilers\Test\Utilities\VisualBasic\BasicTestBase.vb:line 73
   at Microsoft.CodeAnalysis.VisualBasic.UnitTests.BasicTestBase.CompileAndVerify(Compilation compilation, XCData expectedOutput, String[] args, IEnumerable`1 manifestResources, IEnumerable`1 dependencies, Action`1 sourceSymbolValidator, Action`1 validator, Action`1 symbolValidator, SignatureDescription[] expectedSignatures, EmitOptions emitOptions, Verification verify) in C:\code\roslyn\src\Compilers\Test\Utilities\VisualBasic\BasicTestBase.vb:line 101
   at Microsoft.CodeAnalysis.VisualBasic.UnitTests.Emit.OptionalArgumentsTests.TestDuplicateConstantAttributesMetadata() in C:\code\roslyn\src\Compilers\VisualBasic\Test\Emit\Emit\OptionalArgumentsTests.vb:line 826
Result Message:	
Roslyn.Test.Utilities.ExecutionException : 
Execution failed for assembly 'C:\Users\Perbj\AppData\Local\Temp\RoslynTests'.
Expected: 
System.Reflection.Missing: System.Reflection.Missing
System.DateTime: 01/01/0001 00:00:00
System.DateTime: 01/01/0001 00:00:00
System.DateTime: 01/01/0001 00:00:00
System.Int32: 0
System.Int64: 3
System.Decimal: 3

Actual:   System.Reflection.Missing: System.Reflection.Missing
System.DateTime: 01-01-0001 00:00:00
System.DateTime: 01-01-0001 00:00:00
System.DateTime: 01-01-0001 00:00:00
System.Int32: 0
System.Int64: 3
System.Decimal: 3
```
Notice the different separators used in the date format.
</Description>
        <CreatedDate>25/07/2018</CreatedDate>
        <ClosedDate>09/09/2019</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Test/Emit/Emit/OptionalArgumentsTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>28311</IssueID>
    <Title>Use default constant value for synthesized local reference for LockTa…</Title>
    <Description>…ken variable in CFG

Fixes #28301

&lt;details&gt;&lt;summary&gt;Ask Mode template&lt;/summary&gt;

### Customer scenario

When an analyzer using the new ControlFlowGraph compiler APIs tries to request and analyze a flow graph for source code containing a `lock` statement, we return a corrupt graph. This can cause analsysis to fail in various ways (throws exception(s), fires assert(s), produce incorrect analysis result, etc.). In fact, attempting to move the features/dataflow branch on https://github.com/dotnet/roslyn-analyzers to the latest Microsoft.CodeAnalysis NuGet package is causing all the lock related tests to fail with asserts.

### Bugs this fixes

Fixes #28301

### Workarounds, if any

All CFG based analyzers have to explicitly identify and handle such corrupt cases.

### Risk

Low. This only affects analyzers based on new CFG APIs, which need to be executed under an experimental feature flag. The fix is also pretty trivial.

### Performance impact

None

### Is this a regression from a previous update?

No, this is a new public API.

### Root cause analysis

Missed it while reviewing the tests.

### How was the bug found?

Attempting to move roslyn-analyzers repo to latest Microsoft.CodeAnalysis NuGet pacakge

### Test documentation updated?

N/A

&lt;/details&gt;</Description>
    <CreatedDate>05/07/2018</CreatedDate>
    <ClosedDate>12/07/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>28301</IssueID>
        <Title>Invalid ConstantValue for the ILocalReferenceOperation generated for LockTaken variable reference in CFG</Title>
        <Description>Look at any of the flow tests for ILockStatement, for example http://source.roslyn.io/#Roslyn.Compilers.CSharp.Semantic.UnitTests/IOperation/IOperationTests_ILockStatement.cs,455:

```
ILocalReferenceOperation:  (IsDeclaration: True) (OperationKind.LocalReference, Type: System.Boolean, Constant: null, IsImplicit) (Syntax: 'source1 ?? source2')
```

Note that the local reference operation is of type `bool`, but it has a constant value of `null` instead of having no constant value. Issue seems to be at couple of places in the CFG builder where we synthesize LocalReferenceExpression [here](http://source.roslyn.io/#Microsoft.CodeAnalysis/Operations/ControlFlowGraphBuilder.cs,3757) and [here](http://source.roslyn.io/#Microsoft.CodeAnalysis/Operations/ControlFlowGraphBuilder.cs,3797), we incorrectly use `constantValue: null` instead of `constantValue: default`.</Description>
        <CreatedDate>05/07/2018</CreatedDate>
        <ClosedDate>13/07/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>28301</IssueID>
        <Title>Invalid ConstantValue for the ILocalReferenceOperation generated for LockTaken variable reference in CFG</Title>
        <Description>Look at any of the flow tests for ILockStatement, for example http://source.roslyn.io/#Roslyn.Compilers.CSharp.Semantic.UnitTests/IOperation/IOperationTests_ILockStatement.cs,455:

```
ILocalReferenceOperation:  (IsDeclaration: True) (OperationKind.LocalReference, Type: System.Boolean, Constant: null, IsImplicit) (Syntax: 'source1 ?? source2')
```

Note that the local reference operation is of type `bool`, but it has a constant value of `null` instead of having no constant value. Issue seems to be at couple of places in the CFG builder where we synthesize LocalReferenceExpression [here](http://source.roslyn.io/#Microsoft.CodeAnalysis/Operations/ControlFlowGraphBuilder.cs,3757) and [here](http://source.roslyn.io/#Microsoft.CodeAnalysis/Operations/ControlFlowGraphBuilder.cs,3797), we incorrectly use `constantValue: null` instead of `constantValue: default`.</Description>
        <CreatedDate>05/07/2018</CreatedDate>
        <ClosedDate>13/07/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_ILockStatement.cs</File>
      <File>src/Compilers/Core/Portable/Operations/ControlFlowGraphBuilder.cs</File>
      <File>src/Compilers/Core/Portable/Operations/Operation.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>28252</IssueID>
    <Title>Track enclosing symbol in data flow analysis, which might be a field or property.</Title>
    <Description>Code used to assume it was (and typed it as) a method.
Fixes #19845
Fixes #27969

@dotnet/roslyn-compiler May I please have a couple of reviews?

&lt;details&gt;

&lt;!-- This template is not always required. If you aren't sure about whether it's needed or want help filling out the sections,
submit the pull request and then ask us for help. :) --&gt;

### Customer scenario

Code containing a reference to a property in an initializer undergoes region analysis. The compiler crashes.

### Bugs this fixes

Fixes #19845
Fixes #27969

### Workarounds, if any

None known.

### Risk

Low. This is a localized correction that widens the type of a field so that we can track the enclosing symbol when it is not a method.

### Performance impact

None expected.

### Is this a regression from a previous update?

Probably.

### Root cause analysis

### How was the bug found?

Customer reported.

### Test documentation updated?

N/A

&lt;/details&gt;
</Description>
    <CreatedDate>03/07/2018</CreatedDate>
    <ClosedDate>03/07/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>19845</IssueID>
        <Title>ExtractMethodCodeRefactoringProvider throws on property reference in initializer</Title>
        <Description>**Version Used**:  15.2 (26430.6) Release

```C#
class C {
    static int X { get; set; }
    int Y = X;
}
```

Select the second `X` and press Ctrl+Dot.

````
System.NullReferenceException : Object reference not set to an instance of an object.
   at Microsoft.CodeAnalysis.CSharp.Binder.AccessingAutoPropertyFromConstructor(BoundExpression receiver,PropertySymbol propertySymbol,Symbol fromMember)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.VisitPropertyAccess(BoundPropertyAccess node)
   at Microsoft.CodeAnalysis.CSharp.BoundPropertyAccess.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth,BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Scan(Boolean&amp; badRegion)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.Scan(Boolean&amp; badRegion)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Analyze(Boolean&amp; badRegion)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.Analyze(Boolean&amp; badRegion,DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.UnassignedVariablesWalker.Analyze(CSharpCompilation compilation,Symbol member,BoundNode node,Boolean convertInsufficientExecutionStackExceptionToCancelledByStackGuardException)
   at Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.get_UnassignedVariables()
   at Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.get_DataFlowsIn()
   at Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.get_Succeeded()
   at Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.AnalyzeReadWrite()
   at Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.get_Captured()
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GenerateVariableInfoMap(SemanticModel model,DataFlowAnalysis dataFlowAnalysisData,Dictionary`2 symbolMap)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.AnalyzeAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.ExtractMethodAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.ExtractMethodAsync[TValidator,TExtractor,TResult](&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.GetCodeActionAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.ComputeRefactoringsAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringService.GetRefactoringFromProviderAsync(&lt;Unknown Parameters&gt;)
   at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject)
```</Description>
        <CreatedDate>29/05/2017</CreatedDate>
        <ClosedDate>03/07/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>27969</IssueID>
        <Title>Crash in DataFlowAnalysis</Title>
        <Description>**Version Used**: 
Microsoft.CodeAnalysis v2.8.2

**Steps to Reproduce**:
Consider the next program, which runs data flow analysis on lambda expression `x =&gt; true`:
```csharp
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace RoslynDataFlowCrash
{
    class Program
    {
        static void Main()
        {
            const string source = @"
class C
{
    object P { get; } = Create(nameof(P), x =&gt; true);

    static object Create(string name, Func&lt;string, bool&gt; f) =&gt; throw null;
}
";

            SyntaxTree tree = CSharpSyntaxTree.ParseText(source);
            var compilation = CSharpCompilation.Create("test.dll", new[] { tree });
            var model = compilation.GetSemanticModel(tree);

            SimpleLambdaExpressionSyntax lambdaSyntax = tree.GetRoot().DescendantNodes().OfType&lt;SimpleLambdaExpressionSyntax&gt;().First();

            DataFlowAnalysis dataFlowAnalysis = model.AnalyzeDataFlow(lambdaSyntax.Body);

            bool succeeded = dataFlowAnalysis.Succeeded; // NullReferenceException
        }
    }
}
```

**Expected Behavior**:
No exception.

**Actual Behavior**:
`NullReferenceException`. Full stack trace:
```
System.NullReferenceException
  HResult=0x80004003
  Message=Object reference not set to an instance of an object.
  Source=Microsoft.CodeAnalysis.CSharp
  StackTrace:
   at Microsoft.CodeAnalysis.CSharp.Binder.AccessingAutoPropertyFromConstructor(BoundExpression receiver, PropertySymbol propertySymbol, Symbol fromMember)
   at Microsoft.CodeAnalysis.CSharp.Binder.AccessingAutoPropertyFromConstructor(BoundPropertyAccess propertyAccess, Symbol fromMember)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.VisitPropertyAccess(BoundPropertyAccess node)
   at Microsoft.CodeAnalysis.CSharp.BoundPropertyAccess.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitNameOfOperator(BoundNameOfOperator node)
   at Microsoft.CodeAnalysis.CSharp.BoundNameOfOperator.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitArguments(ImmutableArray`1 arguments, ImmutableArray`1 refKindsOpt, MethodSymbol method)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitCall(BoundCall node)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.VisitCall(BoundCall node)
   at Microsoft.CodeAnalysis.CSharp.BoundCall.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Scan(Boolean&amp; badRegion)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.Scan(Boolean&amp; badRegion)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Analyze(Boolean&amp; badRegion)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.Analyze(Boolean&amp; badRegion, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.UnassignedVariablesWalker.Analyze(CSharpCompilation compilation, Symbol member, BoundNode node, Boolean convertInsufficientExecutionStackExceptionToCancelledByStackGuardException)
   at Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.get_UnassignedVariables()
   at Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.get_DataFlowsIn()
   at Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.get_Succeeded()
   at RoslynDataFlowCrash.Program.Main() in E:\Bart\Source\Visual Studio 2017\RoslynDataFlowCrash\RoslynDataFlowCrash\Program.cs:line 29
```</Description>
        <CreatedDate>18/06/2018</CreatedDate>
        <ClosedDate>03/07/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19845</IssueID>
        <Title>ExtractMethodCodeRefactoringProvider throws on property reference in initializer</Title>
        <Description>**Version Used**:  15.2 (26430.6) Release

```C#
class C {
    static int X { get; set; }
    int Y = X;
}
```

Select the second `X` and press Ctrl+Dot.

````
System.NullReferenceException : Object reference not set to an instance of an object.
   at Microsoft.CodeAnalysis.CSharp.Binder.AccessingAutoPropertyFromConstructor(BoundExpression receiver,PropertySymbol propertySymbol,Symbol fromMember)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.VisitPropertyAccess(BoundPropertyAccess node)
   at Microsoft.CodeAnalysis.CSharp.BoundPropertyAccess.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth,BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Scan(Boolean&amp; badRegion)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.Scan(Boolean&amp; badRegion)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Analyze(Boolean&amp; badRegion)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.Analyze(Boolean&amp; badRegion,DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.UnassignedVariablesWalker.Analyze(CSharpCompilation compilation,Symbol member,BoundNode node,Boolean convertInsufficientExecutionStackExceptionToCancelledByStackGuardException)
   at Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.get_UnassignedVariables()
   at Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.get_DataFlowsIn()
   at Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.get_Succeeded()
   at Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.AnalyzeReadWrite()
   at Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.get_Captured()
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GenerateVariableInfoMap(SemanticModel model,DataFlowAnalysis dataFlowAnalysisData,Dictionary`2 symbolMap)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.AnalyzeAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.ExtractMethodAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.ExtractMethodAsync[TValidator,TExtractor,TResult](&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.GetCodeActionAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.ComputeRefactoringsAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringService.GetRefactoringFromProviderAsync(&lt;Unknown Parameters&gt;)
   at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject)
```</Description>
        <CreatedDate>29/05/2017</CreatedDate>
        <ClosedDate>03/07/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>27969</IssueID>
        <Title>Crash in DataFlowAnalysis</Title>
        <Description>**Version Used**: 
Microsoft.CodeAnalysis v2.8.2

**Steps to Reproduce**:
Consider the next program, which runs data flow analysis on lambda expression `x =&gt; true`:
```csharp
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace RoslynDataFlowCrash
{
    class Program
    {
        static void Main()
        {
            const string source = @"
class C
{
    object P { get; } = Create(nameof(P), x =&gt; true);

    static object Create(string name, Func&lt;string, bool&gt; f) =&gt; throw null;
}
";

            SyntaxTree tree = CSharpSyntaxTree.ParseText(source);
            var compilation = CSharpCompilation.Create("test.dll", new[] { tree });
            var model = compilation.GetSemanticModel(tree);

            SimpleLambdaExpressionSyntax lambdaSyntax = tree.GetRoot().DescendantNodes().OfType&lt;SimpleLambdaExpressionSyntax&gt;().First();

            DataFlowAnalysis dataFlowAnalysis = model.AnalyzeDataFlow(lambdaSyntax.Body);

            bool succeeded = dataFlowAnalysis.Succeeded; // NullReferenceException
        }
    }
}
```

**Expected Behavior**:
No exception.

**Actual Behavior**:
`NullReferenceException`. Full stack trace:
```
System.NullReferenceException
  HResult=0x80004003
  Message=Object reference not set to an instance of an object.
  Source=Microsoft.CodeAnalysis.CSharp
  StackTrace:
   at Microsoft.CodeAnalysis.CSharp.Binder.AccessingAutoPropertyFromConstructor(BoundExpression receiver, PropertySymbol propertySymbol, Symbol fromMember)
   at Microsoft.CodeAnalysis.CSharp.Binder.AccessingAutoPropertyFromConstructor(BoundPropertyAccess propertyAccess, Symbol fromMember)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.VisitPropertyAccess(BoundPropertyAccess node)
   at Microsoft.CodeAnalysis.CSharp.BoundPropertyAccess.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitNameOfOperator(BoundNameOfOperator node)
   at Microsoft.CodeAnalysis.CSharp.BoundNameOfOperator.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitArguments(ImmutableArray`1 arguments, ImmutableArray`1 refKindsOpt, MethodSymbol method)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitCall(BoundCall node)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.VisitCall(BoundCall node)
   at Microsoft.CodeAnalysis.CSharp.BoundCall.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Scan(Boolean&amp; badRegion)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.Scan(Boolean&amp; badRegion)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Analyze(Boolean&amp; badRegion)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.Analyze(Boolean&amp; badRegion, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.UnassignedVariablesWalker.Analyze(CSharpCompilation compilation, Symbol member, BoundNode node, Boolean convertInsufficientExecutionStackExceptionToCancelledByStackGuardException)
   at Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.get_UnassignedVariables()
   at Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.get_DataFlowsIn()
   at Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.get_Succeeded()
   at RoslynDataFlowCrash.Program.Main() in E:\Bart\Source\Visual Studio 2017\RoslynDataFlowCrash\RoslynDataFlowCrash\Program.cs:line 29
```</Description>
        <CreatedDate>18/06/2018</CreatedDate>
        <ClosedDate>03/07/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/DataFlowPass.LocalFunctions.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/DataFlowPass.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/ReadWriteWalker.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/FlowAnalysis/RegionAnalysisTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>28250</IssueID>
    <Title>Added more tests to ref assignment to invalid expressions</Title>
    <Description>Closes #28238
Responds to additional feedback from #28118

cc @dotnet/roslyn-compiler for review.
cc @agocke for original feedback.</Description>
    <CreatedDate>02/07/2018</CreatedDate>
    <ClosedDate>07/07/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>28238</IssueID>
        <Title>Visual Studio crashed when type { object = ref</Title>
        <Description>**Version Used**: 
15.7.4

**Steps to Reproduce**:
open any method, or C# interactive and start writing:
var temp = new { object = ref

**Expected Behavior**:
Error that "object" appears.

**Actual Behavior**:
Visual Studio crashed
</Description>
        <CreatedDate>02/07/2018</CreatedDate>
        <ClosedDate>07/07/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>28118</IssueID>
        <Title>Ref-assigning to array elements should produce an error</Title>
        <Description>Fixes #28087 </Description>
        <CreatedDate>26/06/2018</CreatedDate>
        <ClosedDate>02/07/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/RefLocalsAndReturnsTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>28217</IssueID>
    <Title>Enable refactorings which were unintentionally removed by 'none' severity</Title>
    <Description>### Customer scenario

A customer creates a .editorconfig file with `none` severity for rules they do not wish to enforce. After updating to Visual Studio 2017 version 15.8 Preview 3, some manual refactorings related to these rules stop working as well. The impacted refactorings are:

* Use implicit type
* Use explicit type
* Use expression body
* Use block body

### Bugs this fixes

N/A

### Workarounds, if any

Update the .editorconfig to specify `silent` instead of `none`.

### Risk

The risk is relatively low.

### Performance impact

None relative to 15.8 Preview 2 and earlier. The refactoring is now evaluated in the same manner and locations it was prior to the change in meaning of `none` severity in .editorconfig.

### Is this a regression from a previous update?

Yes, introduced by #27220.

### Root cause analysis

Currently we test the diagnostic analyzers separately from the refactorings, even when the two are operating on the same underlying feature in code. Each set of tests assumes behavior about the other in order to test the remaining cases. #27720 caused the analyzer to no longer operate under one of these scenarios where the refactoring tests continued to assume the diagnostic would provide a code fix.

The ideal fix is implementing a new test strategy that enables multiple analyzers and/or code fixes known to operate on the same body of code, and make assertions about the combined impact from the user's perspective. These assertions would more accurately reflect the behavior of the application in production, and detect two specific situations that are currently undetected by tests:

1. Tests would fail if the analyzer stopped providing a code fix and the refactoring was not updated to offer it (and vice versa)
2. Tests would fail if the analyzer started offering a code fix and the refactoring was not updated to exclude it (and vice versa)

I have filed #28216 to improve this situation in the future.

### How was the bug found?

Dogfooding.

### Test documentation updated?

No.
</Description>
    <CreatedDate>29/06/2018</CreatedDate>
    <ClosedDate>02/07/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>27220</IssueID>
        <Title>Map 'none' in .editorconfig to ReportDiagnostic.Suppress</Title>
        <Description>Fixes #26972 

:memo: This is an intentionally constrained change.

* Each commit is a unit of work (single topic, complete, all tests passing). I **strongly encourage** reviewing each commit separately after a quick look to understand the overall direction.
* All *known* breaking (or possibly breaking) changes, except for those described in the design for #26972, are called out in comments.
* The inconsistent handling of `DiagnosticSeverity.Hidden` is preserved for all current diagnostics. Given the new ability to differentiate between `ReportDiagnostic.Hidden` and `ReportDiagnostic.Suppress`, we will likely want to revisit this behavior and make all diagnostics consistent.

&lt;details&gt;&lt;summary&gt;Ask Mode template not completed&lt;/summary&gt;

&lt;!-- This template is not always required. If you aren't sure about whether it's needed or want help filling out the sections,
submit the pull request and then ask us for help. :) --&gt;

### Customer scenario

What does the customer do to get into this situation, and why do we think this
is common enough to address for this release.  (Granted, sometimes this will be
obvious "Open project, VS crashes" but in general, I need to understand how
common a scenario is)

### Bugs this fixes

(either VSO or GitHub links)

### Workarounds, if any

Also, why we think they are insufficient for RC vs. RC2, RC3, or RTW

### Risk

This is generally a measure our how central the affected code is to adjacent
scenarios and thus how likely your fix is to destabilize a broader area of code

### Performance impact

(with a brief justification for that assessment (e.g. "Low perf impact because no extra allocations/no complexity changes" vs. "Low")

### Is this a regression from a previous update?

### Root cause analysis

How did we miss it?  What tests are we adding to guard against it in the future?

### How was the bug found?

(E.g. customer reported it vs. ad hoc testing)

### Test documentation updated?

If this is a new non-compiler feature or a significant improvement to an existing feature, update https://github.com/dotnet/roslyn/wiki/Manual-Testing once you know which release it is targeting.

&lt;/details&gt;
</Description>
        <CreatedDate>29/05/2018</CreatedDate>
        <ClosedDate>11/06/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>27720</IssueID>
        <Title>build -pack does not work</Title>
        <Description>In master branch, in a clean repository, repro as follows:

``` none
cd Roslyn
restore
build -pack
```

![image](https://user-images.githubusercontent.com/3804346/41251846-0d794940-6d70-11e8-8674-fa170918645b.png)

This is blocking our attempt to diagnose #27523 

</Description>
        <CreatedDate>11/06/2018</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>28216</IssueID>
        <Title>Create combined tests for diagnostic/refactoring pairs</Title>
        <Description>Currently analyzers and refactorings are tested separately, which leaves the test suite unable to detect certain regressions. See the root cause analysis in #28217 for details.</Description>
        <CreatedDate>29/06/2018</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/CodeActions/UseExplicitType/UseExplicitTypeRefactoringTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/CodeActions/UseImplicitType/UseImplicitTypeRefactoringTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/CodeRefactorings/UseExplicitOrImplicitType/AbstractUseTypeRefactoringTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/CodeRefactorings/UseExplicitOrImplicitType/UseExplicitTypeRefactoringTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/CodeRefactorings/UseExplicitOrImplicitType/UseImplicitTypeRefactoringTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseExpressionBody/Refactoring/UseExpressionBodyForAccessorsRefactoringTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseExpressionBody/Refactoring/UseExpressionBodyForConstructorsRefactoringTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseExpressionBody/Refactoring/UseExpressionBodyForConversionOperatorsRefactoringTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseExpressionBody/Refactoring/UseExpressionBodyForIndexersRefactoringTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseExpressionBody/Refactoring/UseExpressionBodyForMethodsRefactoringTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseExpressionBody/Refactoring/UseExpressionBodyForOperatorsRefactoringTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseExpressionBody/Refactoring/UseExpressionBodyForPropertiesRefactoringTests.cs</File>
      <File>src/Features/CSharp/Portable/CodeRefactorings/UseExplicitOrImplicitType/AbstractUseTypeCodeRefactoringProvider.cs</File>
      <File>src/Features/CSharp/Portable/UseExpressionBody/Helpers/UseExpressionBodyHelper`1.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>28090</IssueID>
    <Title>Fix NRE when handling multiline documentation comments in C#</Title>
    <Description>Fixes #25746.  
Fixes #27223.

This is a small fix: the extension method that caused the exception/crash now returns `false` when the parameter is `null`.

Side note: I don't know whether the current behaviour (insert exterior trivia text on the next line in both cases) is the expected behaviour, but it's in line with VB's behaviour.

### Customer scenario

After pressing &lt;kbd&gt;Enter&lt;/kbd&gt; on a line starting with `///`, a gold bar (or error dialog) is shown alerting the user to a problem running an internal command.

### Bugs this fixes

Fixes #25746.  
Fixes #27223.

### Workarounds, if any

Enter the text using a different order.

### Risk

Low.

### Performance impact

None significant.

### Is this a regression from a previous update?

No.

### Root cause analysis

Two edge cases related to handling &lt;kbd&gt;Enter&lt;/kbd&gt; within documentation comments (or comments that *look* like documentation comments were identified. Tests were added to prevent regressing these cases in the future.

### How was the bug found?

Multiple but rare reports from internal and external customers.

### Test documentation updated?

No.
</Description>
    <CreatedDate>23/06/2018</CreatedDate>
    <ClosedDate>12/07/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>25746</IssueID>
        <Title>NullReferenceException in DocumentationCommentExtensions.IsMultilineDocComment</Title>
        <Description>Originally posted by @Jehoel in DotNetAnalyzers/StyleCopAnalyzers#2648

&gt; While a editing C# Console project and typing "//////" on an empty line line inside my `void Main` I got a message informing me an Editor Extension had crashed.
&gt; 
&gt; Here's the message logged in `ActivityLog.xml`:
&gt; 
&gt; ```
&gt; System.NullReferenceException: Object reference not set to an instance of an object.
&gt;    at Microsoft.CodeAnalysis.CSharp.Extensions.DocumentationCommentExtensions.IsMultilineDocComment(DocumentationCommentTriviaSyntax documentationComment)
&gt;    at Microsoft.CodeAnalysis.Editor.CSharp.DocumentationComments.DocumentationCommentCommandHandler.IsMultilineDocComment(DocumentationCommentTriviaSyntax documentationComment)
&gt;    at Microsoft.CodeAnalysis.Editor.Implementation.DocumentationComments.AbstractDocumentationCommentCommandHandler`2.TryGenerateExteriorTriviaAfterEnter(SyntaxTree syntaxTree, SourceText text, Int32 position, Int32 originalPosition, ITextBuffer subjectBuffer, ITextView textView, DocumentOptionSet options, CancellationToken cancellationToken)
&gt;    at Microsoft.CodeAnalysis.Editor.Implementation.DocumentationComments.AbstractDocumentationCommentCommandHandler`2.InsertOnEnterTyped(SyntaxTree syntaxTree, SourceText text, Int32 position, Int32 originalPosition, ITextBuffer subjectBuffer, ITextView textView, DocumentOptionSet options, CancellationToken cancellationToken)
&gt;    at Microsoft.CodeAnalysis.Editor.Implementation.DocumentationComments.AbstractDocumentationCommentCommandHandler`2.CompleteComment(ITextBuffer subjectBuffer, ITextView textView, Int32 originalCaretPosition, Func`9 insertAction, CancellationToken cancellationToken)
&gt;    at Microsoft.CodeAnalysis.Editor.Implementation.DocumentationComments.AbstractDocumentationCommentCommandHandler`2.ExecuteCommand(ReturnKeyCommandArgs args, CommandExecutionContext context)
&gt;    at Microsoft.VisualStudio.Commanding.CommandHandlerExtensions.ExecuteCommand[T](ICommandHandler commandHandler, T args, Action nextCommandHandler, CommandExecutionContext executionContext)
&gt;    at Microsoft.VisualStudio.UI.Text.Commanding.Implementation.EditorCommandHandlerService.&lt;&gt;c__DisplayClass14_1`1.&lt;Execute&gt;b__1()
&gt;    at Microsoft.VisualStudio.Text.Utilities.GuardedOperations.CallExtensionPoint(Object errorSource, Action call)
&gt; --- End of stack trace from previous location where exception was thrown ---
&gt;    at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject)
&gt; ```
&gt; 
&gt; Repro steps:
&gt; 
&gt; 1. Open an existing C# console project in VS 2017 (15.6.4)
&gt; 2. On an empty line inside a method type "/////" (several forward-slashes)
&gt; 3. VS will display the extension crash warning dialog. The above stack-trace will be written to `ActivityLog.xml`.
</Description>
        <CreatedDate>27/03/2018</CreatedDate>
        <ClosedDate>12/07/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>27223</IssueID>
        <Title>NRE from DocumentationCommentExtensions.IsMultilineDocComment</Title>
        <Description>[VS Feedback issue](https://developercommunity.visualstudio.com/content/problem/229613/nullreferenceexception-in-ismultilinedoccomment.html)

Repro:

Create a console app, place cursor in line 10 between `&lt;summary&gt;` and `&lt;/summary&gt;`, hit enter.

```C#
namespace ConsoleApp
{
    class Program
    {
        static void Main(string[] args)
        {
            const string code = @"
class Program
{
    /// &lt;summary&gt;&lt;/summary&gt;
    static void Main(string[] args)
    {
    }
}
";
        }
    }
}
```

Stack trace:

```
System.NullReferenceException: Object reference not set to an instance of an object.
 at Microsoft.CodeAnalysis.CSharp.Extensions.DocumentationCommentExtensions.IsMultilineDocComment(DocumentationCommentTriviaSyntax documentationComment)
 at Microsoft.CodeAnalysis.Editor.CSharp.DocumentationComments.DocumentationCommentCommandHandler.IsMultilineDocComment(DocumentationCommentTriviaSyntax documentationComment)
 at Microsoft.CodeAnalysis.Editor.Implementation.DocumentationComments.AbstractDocumentationCommentCommandHandler`2.TryGenerateExteriorTriviaAfterEnter(SyntaxTree syntaxTree, SourceText text, Int32 position, Int32 originalPosition, ITextBuffer subjectBuffer, ITextView textView, DocumentOptionSet options, CancellationToken cancellationToken)
 at Microsoft.CodeAnalysis.Editor.Implementation.DocumentationComments.AbstractDocumentationCommentCommandHandler`2.InsertOnEnterTyped(SyntaxTree syntaxTree, SourceText text, Int32 position, Int32 originalPosition, ITextBuffer subjectBuffer, ITextView textView, DocumentOptionSet options, CancellationToken cancellationToken)
 at Microsoft.CodeAnalysis.Editor.Implementation.DocumentationComments.AbstractDocumentationCommentCommandHandler`2.CompleteComment(ITextBuffer subjectBuffer, ITextView textView, Int32 originalCaretPosition, Func`9 insertAction, CancellationToken cancellationToken)
 at Microsoft.CodeAnalysis.Editor.Implementation.DocumentationComments.AbstractDocumentationCommentCommandHandler`2.ExecuteCommand(ReturnKeyCommandArgs args, CommandExecutionContext context)
 at Microsoft.VisualStudio.Commanding.CommandHandlerExtensions.ExecuteCommand[T](ICommandHandler commandHandler, T args, Action nextCommandHandler, CommandExecutionContext executionContext)
 at Microsoft.VisualStudio.UI.Text.Commanding.Implementation.EditorCommandHandlerService.&lt;&gt;c__DisplayClass14_1`1.&lt;Execute&gt;b__1()
 at Microsoft.VisualStudio.Text.Utilities.GuardedOperations.CallExtensionPoint(Object errorSource, Action call)
 --- End of stack trace from previous location where exception was thrown ---
 at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject) 
```</Description>
        <CreatedDate>29/05/2018</CreatedDate>
        <ClosedDate>12/07/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>25746</IssueID>
        <Title>NullReferenceException in DocumentationCommentExtensions.IsMultilineDocComment</Title>
        <Description>Originally posted by @Jehoel in DotNetAnalyzers/StyleCopAnalyzers#2648

&gt; While a editing C# Console project and typing "//////" on an empty line line inside my `void Main` I got a message informing me an Editor Extension had crashed.
&gt; 
&gt; Here's the message logged in `ActivityLog.xml`:
&gt; 
&gt; ```
&gt; System.NullReferenceException: Object reference not set to an instance of an object.
&gt;    at Microsoft.CodeAnalysis.CSharp.Extensions.DocumentationCommentExtensions.IsMultilineDocComment(DocumentationCommentTriviaSyntax documentationComment)
&gt;    at Microsoft.CodeAnalysis.Editor.CSharp.DocumentationComments.DocumentationCommentCommandHandler.IsMultilineDocComment(DocumentationCommentTriviaSyntax documentationComment)
&gt;    at Microsoft.CodeAnalysis.Editor.Implementation.DocumentationComments.AbstractDocumentationCommentCommandHandler`2.TryGenerateExteriorTriviaAfterEnter(SyntaxTree syntaxTree, SourceText text, Int32 position, Int32 originalPosition, ITextBuffer subjectBuffer, ITextView textView, DocumentOptionSet options, CancellationToken cancellationToken)
&gt;    at Microsoft.CodeAnalysis.Editor.Implementation.DocumentationComments.AbstractDocumentationCommentCommandHandler`2.InsertOnEnterTyped(SyntaxTree syntaxTree, SourceText text, Int32 position, Int32 originalPosition, ITextBuffer subjectBuffer, ITextView textView, DocumentOptionSet options, CancellationToken cancellationToken)
&gt;    at Microsoft.CodeAnalysis.Editor.Implementation.DocumentationComments.AbstractDocumentationCommentCommandHandler`2.CompleteComment(ITextBuffer subjectBuffer, ITextView textView, Int32 originalCaretPosition, Func`9 insertAction, CancellationToken cancellationToken)
&gt;    at Microsoft.CodeAnalysis.Editor.Implementation.DocumentationComments.AbstractDocumentationCommentCommandHandler`2.ExecuteCommand(ReturnKeyCommandArgs args, CommandExecutionContext context)
&gt;    at Microsoft.VisualStudio.Commanding.CommandHandlerExtensions.ExecuteCommand[T](ICommandHandler commandHandler, T args, Action nextCommandHandler, CommandExecutionContext executionContext)
&gt;    at Microsoft.VisualStudio.UI.Text.Commanding.Implementation.EditorCommandHandlerService.&lt;&gt;c__DisplayClass14_1`1.&lt;Execute&gt;b__1()
&gt;    at Microsoft.VisualStudio.Text.Utilities.GuardedOperations.CallExtensionPoint(Object errorSource, Action call)
&gt; --- End of stack trace from previous location where exception was thrown ---
&gt;    at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject)
&gt; ```
&gt; 
&gt; Repro steps:
&gt; 
&gt; 1. Open an existing C# console project in VS 2017 (15.6.4)
&gt; 2. On an empty line inside a method type "/////" (several forward-slashes)
&gt; 3. VS will display the extension crash warning dialog. The above stack-trace will be written to `ActivityLog.xml`.
</Description>
        <CreatedDate>27/03/2018</CreatedDate>
        <ClosedDate>12/07/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>27223</IssueID>
        <Title>NRE from DocumentationCommentExtensions.IsMultilineDocComment</Title>
        <Description>[VS Feedback issue](https://developercommunity.visualstudio.com/content/problem/229613/nullreferenceexception-in-ismultilinedoccomment.html)

Repro:

Create a console app, place cursor in line 10 between `&lt;summary&gt;` and `&lt;/summary&gt;`, hit enter.

```C#
namespace ConsoleApp
{
    class Program
    {
        static void Main(string[] args)
        {
            const string code = @"
class Program
{
    /// &lt;summary&gt;&lt;/summary&gt;
    static void Main(string[] args)
    {
    }
}
";
        }
    }
}
```

Stack trace:

```
System.NullReferenceException: Object reference not set to an instance of an object.
 at Microsoft.CodeAnalysis.CSharp.Extensions.DocumentationCommentExtensions.IsMultilineDocComment(DocumentationCommentTriviaSyntax documentationComment)
 at Microsoft.CodeAnalysis.Editor.CSharp.DocumentationComments.DocumentationCommentCommandHandler.IsMultilineDocComment(DocumentationCommentTriviaSyntax documentationComment)
 at Microsoft.CodeAnalysis.Editor.Implementation.DocumentationComments.AbstractDocumentationCommentCommandHandler`2.TryGenerateExteriorTriviaAfterEnter(SyntaxTree syntaxTree, SourceText text, Int32 position, Int32 originalPosition, ITextBuffer subjectBuffer, ITextView textView, DocumentOptionSet options, CancellationToken cancellationToken)
 at Microsoft.CodeAnalysis.Editor.Implementation.DocumentationComments.AbstractDocumentationCommentCommandHandler`2.InsertOnEnterTyped(SyntaxTree syntaxTree, SourceText text, Int32 position, Int32 originalPosition, ITextBuffer subjectBuffer, ITextView textView, DocumentOptionSet options, CancellationToken cancellationToken)
 at Microsoft.CodeAnalysis.Editor.Implementation.DocumentationComments.AbstractDocumentationCommentCommandHandler`2.CompleteComment(ITextBuffer subjectBuffer, ITextView textView, Int32 originalCaretPosition, Func`9 insertAction, CancellationToken cancellationToken)
 at Microsoft.CodeAnalysis.Editor.Implementation.DocumentationComments.AbstractDocumentationCommentCommandHandler`2.ExecuteCommand(ReturnKeyCommandArgs args, CommandExecutionContext context)
 at Microsoft.VisualStudio.Commanding.CommandHandlerExtensions.ExecuteCommand[T](ICommandHandler commandHandler, T args, Action nextCommandHandler, CommandExecutionContext executionContext)
 at Microsoft.VisualStudio.UI.Text.Commanding.Implementation.EditorCommandHandlerService.&lt;&gt;c__DisplayClass14_1`1.&lt;Execute&gt;b__1()
 at Microsoft.VisualStudio.Text.Utilities.GuardedOperations.CallExtensionPoint(Object errorSource, Action call)
 --- End of stack trace from previous location where exception was thrown ---
 at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject) 
```</Description>
        <CreatedDate>29/05/2018</CreatedDate>
        <ClosedDate>12/07/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/DocumentationComments/DocumentationCommentTests.cs</File>
      <File>src/Workspaces/CSharp/Portable/Extensions/DocumentationCommentExtensions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>27993</IssueID>
    <Title>Fix generating types into an existing file</Title>
    <Description>An errant refactoring changed a property being consumed by XAML during binding from a property to a method, which isn't going to work. Change this back.

&lt;details&gt;&lt;summary&gt;Ask Mode template&lt;/summary&gt;

### Customer scenario

User tries to invoke "generate type" into an existing file with our dialog, but the list of files to generate into is unpopulated.

### Bugs this fixes

Bug not filed; discovered this while testing #27973.

### Workarounds, if any

Nope, feature is totally broken.

### Risk

Very low -- unbreaking code that is 100% broken.

### Performance impact

None.

### Is this a regression from a previous update?

Yes; this was regressed about a year or so ago, so this may have not been working during all of Dev15.

### Root cause analysis

A large refactoring changed a property to a method in a XAML view model. This isn't supported in binding so it broke.

### How was the bug found?

While testing #27973.

&lt;/details&gt;
</Description>
    <CreatedDate>19/06/2018</CreatedDate>
    <ClosedDate>12/07/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>27973</IssueID>
        <Title>Stop calling IVsHerarchy.ParseCanonicalName if we don't need it</Title>
        <Description>We were calling IVsHierarchy.ParseCanonicalName to get the item ID of a file, to then turn around and use that to get the folder names. In some cases, we already had the folder names so this was just silly.

Note: I update a compatibility overload for TypeScript here. They had since moved off of the compatibility overload, so updating it and repurposing it is safe to do.

**Remaining Work**

- [x] Test TypeScript
- [x] Test F#
- [x] Test the code actions that consume this data in CPS projects
- [x] Test the code actions that consume this data in legacy projects
- [x] Verify we are getting the expected performance

&lt;details&gt;&lt;summary&gt;Ask Mode template not completed&lt;/summary&gt;

&lt;!-- This template is not always required. If you aren't sure about whether it's needed or want help filling out the sections,
submit the pull request and then ask us for help. :) --&gt;

### Customer scenario

What does the customer do to get into this situation, and why do we think this
is common enough to address for this release.  (Granted, sometimes this will be
obvious "Open project, VS crashes" but in general, I need to understand how
common a scenario is)

### Bugs this fixes

(either VSO or GitHub links)

### Workarounds, if any

Also, why we think they are insufficient for RC vs. RC2, RC3, or RTW

### Risk

This is generally a measure our how central the affected code is to adjacent
scenarios and thus how likely your fix is to destabilize a broader area of code

### Performance impact

(with a brief justification for that assessment (e.g. "Low perf impact because no extra allocations/no complexity changes" vs. "Low")

### Is this a regression from a previous update?

### Root cause analysis

How did we miss it?  What tests are we adding to guard against it in the future?

### How was the bug found?

(E.g. customer reported it vs. ad hoc testing)

### Test documentation updated?

If this is a new non-compiler feature or a significant improvement to an existing feature, update https://github.com/dotnet/roslyn/wiki/Manual-Testing once you know which release it is targeting.

&lt;/details&gt;</Description>
        <CreatedDate>19/06/2018</CreatedDate>
        <ClosedDate>22/06/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>27973</IssueID>
        <Title>Stop calling IVsHerarchy.ParseCanonicalName if we don't need it</Title>
        <Description>We were calling IVsHierarchy.ParseCanonicalName to get the item ID of a file, to then turn around and use that to get the folder names. In some cases, we already had the folder names so this was just silly.

Note: I update a compatibility overload for TypeScript here. They had since moved off of the compatibility overload, so updating it and repurposing it is safe to do.

**Remaining Work**

- [x] Test TypeScript
- [x] Test F#
- [x] Test the code actions that consume this data in CPS projects
- [x] Test the code actions that consume this data in legacy projects
- [x] Verify we are getting the expected performance

&lt;details&gt;&lt;summary&gt;Ask Mode template not completed&lt;/summary&gt;

&lt;!-- This template is not always required. If you aren't sure about whether it's needed or want help filling out the sections,
submit the pull request and then ask us for help. :) --&gt;

### Customer scenario

What does the customer do to get into this situation, and why do we think this
is common enough to address for this release.  (Granted, sometimes this will be
obvious "Open project, VS crashes" but in general, I need to understand how
common a scenario is)

### Bugs this fixes

(either VSO or GitHub links)

### Workarounds, if any

Also, why we think they are insufficient for RC vs. RC2, RC3, or RTW

### Risk

This is generally a measure our how central the affected code is to adjacent
scenarios and thus how likely your fix is to destabilize a broader area of code

### Performance impact

(with a brief justification for that assessment (e.g. "Low perf impact because no extra allocations/no complexity changes" vs. "Low")

### Is this a regression from a previous update?

### Root cause analysis

How did we miss it?  What tests are we adding to guard against it in the future?

### How was the bug found?

(E.g. customer reported it vs. ad hoc testing)

### Test documentation updated?

If this is a new non-compiler feature or a significant improvement to an existing feature, update https://github.com/dotnet/roslyn/wiki/Manual-Testing once you know which release it is targeting.

&lt;/details&gt;</Description>
        <CreatedDate>19/06/2018</CreatedDate>
        <ClosedDate>22/06/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/VisualStudio/Core/Def/Implementation/GenerateType/GenerateTypeDialogViewModel.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>27882</IssueID>
    <Title>Ref-like type parameters can return safely to external scope by ref</Title>
    <Description>Fixes #27874 
Fixes #27972</Description>
    <CreatedDate>15/06/2018</CreatedDate>
    <ClosedDate>28/06/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>27874</IssueID>
        <Title>Returning ref-like ref parameter types by ref should be allowed</Title>
        <Description>From @tessenr in #27357

Similar problem exists with parameters' ref escape scopes:
```cs
class C
{
  static ref Span&lt;int&gt; M1(ref Span&lt;int&gt; x)
  {
    ref Span&lt;int&gt; q = ref x;
    return ref q; // error cannot be returned by reference
  }

  static ref Span&lt;int&gt; M2(ref Span&lt;int&gt; x)
  {
    return ref x; // OK
  }
}
```

In this case it's caused by discrepancy between [GetRefEscape](http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Binder/Binder.ValueChecks.cs,604613d82bb46358) and  [CheckParameterRefEscape](http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Binder/Binder.ValueChecks.cs,376ab6d77b1940ea) methods' logic

`GetRefEscape` defines parameters' with escape scope as `TopLevelScope` for `ByRefLike` types
```cs
                    // byval parameters can escape to method's top level.
                    // others can be escape further, unless they are ref-like.
                    // NOTE: "method" here means nearest containing method, lambda or nested method
                    return parameter.RefKind == RefKind.None || parameter.Type?.IsByRefLikeType == true ?
                        Binder.TopLevelScope :
                        Binder.ExternalScope;
```

`CheckParameterRefEscape` on the other hand allows `ref/out/in` parameters to escape to any scope regardless of whether they are `ByRefLike` or not:
```cs
        private static bool CheckParameterRefEscape(SyntaxNode node, BoundParameter parameter, uint escapeTo, bool checkingReceiver, DiagnosticBag diagnostics)
        {
            ParameterSymbol parameterSymbol = parameter.ParameterSymbol;
 
            // byval parameters can escape to method's top level.
            // others can be escape further, unless they are ref-like.
            if (escapeTo == Binder.ExternalScope &amp;&amp; parameterSymbol.RefKind == RefKind.None)
            {
                if (checkingReceiver)
                {
                    Error(diagnostics, ErrorCode.ERR_RefReturnParameter2, parameter.Syntax, parameterSymbol.Name);
                }
                else
                {
                    Error(diagnostics, ErrorCode.ERR_RefReturnParameter, node, parameterSymbol.Name);
                }
                return false;
            }
 
            // can ref-escape to any scope otherwise
            return true;
        }
```

I believe that these two methods were intended to be consistent and have similar logic.</Description>
        <CreatedDate>14/06/2018</CreatedDate>
        <ClosedDate>28/06/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>27972</IssueID>
        <Title>Escape scope errors are not consistent for different parameter types</Title>
        <Description>Escape scope errors are not consistent for different parameter types. Example:

```csharp
class C
{
    void M(ref int arg)
    {
        int local = default;
        arg = ref local;   // error CS8374: Cannot ref-assign 'local' to 'arg' because 'local' has a narrower escape scope than 'arg'.

    }
    
    void M(ref string arg)
    {
        string local = default;
        arg = ref local;   // error CS8374: Cannot ref-assign 'local' to 'arg' because 'local' has a narrower escape scope than 'arg'.
    }
    
    void M(ref S arg)
    {
        S local = default;
        arg = ref local;   // No errors
    }
}

ref struct S { }
```</Description>
        <CreatedDate>19/06/2018</CreatedDate>
        <ClosedDate>28/06/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder.ValueChecks.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/RefLocalsAndReturnsTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/SpanStackSafetyTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>27865</IssueID>
    <Title>Implement INavigateToItemProvider2 with filtering</Title>
    <Description>Fixes #27850
Closes #20591

&lt;details&gt;&lt;summary&gt;Ask Mode template not completed&lt;/summary&gt;

&lt;!-- This template is not always required. If you aren't sure about whether it's needed or want help filling out the sections,
submit the pull request and then ask us for help. :) --&gt;

### Customer scenario

What does the customer do to get into this situation, and why do we think this
is common enough to address for this release.  (Granted, sometimes this will be
obvious "Open project, VS crashes" but in general, I need to understand how
common a scenario is)

### Bugs this fixes

(either VSO or GitHub links)

### Workarounds, if any

Also, why we think they are insufficient for RC vs. RC2, RC3, or RTW

### Risk

This is generally a measure our how central the affected code is to adjacent
scenarios and thus how likely your fix is to destabilize a broader area of code

### Performance impact

(with a brief justification for that assessment (e.g. "Low perf impact because no extra allocations/no complexity changes" vs. "Low")

### Is this a regression from a previous update?

### Root cause analysis

How did we miss it?  What tests are we adding to guard against it in the future?

### How was the bug found?

(E.g. customer reported it vs. ad hoc testing)

### Test documentation updated?

If this is a new non-compiler feature or a significant improvement to an existing feature, update https://github.com/dotnet/roslyn/wiki/Manual-Testing once you know which release it is targeting.

&lt;/details&gt;
</Description>
    <CreatedDate>14/06/2018</CreatedDate>
    <ClosedDate>20/06/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>27850</IssueID>
        <Title>NavigateToItemProvider hurts Go To File performance by providing irrelevant results</Title>
        <Description>**Version Used**: 
27813.1 d15.8 (latest dogfood build) 

**Steps to Reproduce**:

1. Open big solution like Rolslyn
2. Invoke Go To File (Ctrl+Shift+T)
3. Type a file name to find

**Expected Behavior**:
Matching file names displayed and search has finished

**Actual Behavior**:
Matching file names displayed but search progress bar is going on because Roslyn's NavigateToItemProvider doesn't realize user is searching for a file and provides symbol results, whoch are being silently ignored.

The fix is to implement INavigateToItemProvider2, which lets providers express what kind of search they support and know what kind of search user initiated. </Description>
        <CreatedDate>14/06/2018</CreatedDate>
        <ClosedDate>20/06/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>20591</IssueID>
        <Title>SymbolFilter parameter to AbstractNavigateToSearchService methods</Title>
        <Description>**Version Used**: 
0f658a492302a11277348d1fd1ef2e1d0a0e4130

**Expected Behavior**:
Being able to pass in a SymbolFilter parameter to pre-filter results before passing them to the caller

**Actual Behavior**:
All symbol kinds are passed in

In VS4Mac, we have the ability of tagging the kind of symbols to match (i.e. `type:`, `event:`, `method:`, `member:`)

Providing ways to pre-filter results at this API level would mean that `type:` requests would become way faster instead of post-filtering many possible matches.</Description>
        <CreatedDate>30/06/2017</CreatedDate>
        <ClosedDate>20/06/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/Core.Wpf/NavigateTo/NavigateToItemProvider.Searcher.cs</File>
      <File>src/EditorFeatures/Core.Wpf/NavigateTo/NavigateToItemProvider.cs</File>
      <File>src/Features/Core/Portable/NavigateTo/AbstractNavigateToSearchService.InProcess.cs</File>
      <File>src/Features/Core/Portable/NavigateTo/AbstractNavigateToSearchService.Remote.cs</File>
      <File>src/Features/Core/Portable/NavigateTo/AbstractNavigateToSearchService.cs</File>
      <File>src/Features/Core/Portable/NavigateTo/INavigateToSearchService.cs</File>
      <File>src/Features/Core/Portable/NavigateTo/IRemoteNavigateToSearchService.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Services/CodeAnalysisService_NavigateTo.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>27790</IssueID>
    <Title>Consolidate diagnostics IDs for "use builtin/framework types".</Title>
    <Description>Fixes https://github.com/dotnet/roslyn/issues/27042.

This is a followup to https://github.com/dotnet/roslyn/pull/26578 and https://github.com/dotnet/roslyn/pull/26825.  I personally think those should go in first.  However, @sharwell made a reasonable case that we might want to just deliver this all in one go.

### Customer scenario

Completes the approved design from #27042. If we do not take this change, 15.8 Preview 4 will change the meaning of some diagnostic IDs related to this feature to a regression state which was never intended to ship.

### Bugs this fixes

#27042

### Workarounds, if any

None.

### Risk

N/A. This was part of the design work in #26578 and cannot be separated from it.

### Performance impact

N/A. This was part of the design work in #26578 and cannot be separated from it.

### Is this a regression from a previous update?

Failure to include this change will introduce a regression.

### Root cause analysis

Infrastructure stability problems leading to higher approval mode delayed a pull request which was expected to merge several days earlier.

### How was the bug found?

N/A (known tracked issue)

### Test documentation updated?

No.
</Description>
    <CreatedDate>13/06/2018</CreatedDate>
    <ClosedDate>29/06/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>27042</IssueID>
        <Title>Consolidate diagnostic IDs for predefined types</Title>
        <Description>**Version Used**: The proposal is an implementation detail of #26578 which is called to the surface.

:memo: This change has since been removed from #26578, but is still under consideration as an independent change.

**Current behavior:**

Currently diagnostics related to predefined types have four diagnostic IDs. Suppose a user wishes to use `string` when declaring a variable with this type, but `String` when referring to static members. The following code would produce the two diagnostics:

```csharp
String value // IDE0012
  = string.Empty; // IDE0015
```

Based on the configuration selected by the user, only two distinct IDs can appear in any given file (.editorconfig allows different configurations to apply to different source files, so it's possible a project or solution could reveal all four).

**Proposed behavior:**

The proposed behavior would consolidate all four situations to use the same diagnostic ID. This diagnostic ID would be a different ID from the previous ones, and the current IDs would be retired. The configuration functionality would not change *at all*. The benefit of this change is it allows Fix All operations to fix *all* situations related to this configuration in a single pass, rather than requiring users to make up to four passes to fix everything.

**Breaking change:**

This is a breaking change for cases where diagnostics are suppressed. However, this is a relatively low risk change because the impacted analyzers were never shipped as NuGet packages and thus have never had an impact on the actual build outcome.</Description>
        <CreatedDate>22/05/2018</CreatedDate>
        <ClosedDate>29/06/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>27042</IssueID>
        <Title>Consolidate diagnostic IDs for predefined types</Title>
        <Description>**Version Used**: The proposal is an implementation detail of #26578 which is called to the surface.

:memo: This change has since been removed from #26578, but is still under consideration as an independent change.

**Current behavior:**

Currently diagnostics related to predefined types have four diagnostic IDs. Suppose a user wishes to use `string` when declaring a variable with this type, but `String` when referring to static members. The following code would produce the two diagnostics:

```csharp
String value // IDE0012
  = string.Empty; // IDE0015
```

Based on the configuration selected by the user, only two distinct IDs can appear in any given file (.editorconfig allows different configurations to apply to different source files, so it's possible a project or solution could reveal all four).

**Proposed behavior:**

The proposed behavior would consolidate all four situations to use the same diagnostic ID. This diagnostic ID would be a different ID from the previous ones, and the current IDs would be retired. The configuration functionality would not change *at all*. The benefit of this change is it allows Fix All operations to fix *all* situations related to this configuration in a single pass, rather than requiring users to make up to four passes to fix everything.

**Breaking change:**

This is a breaking change for cases where diagnostics are suppressed. However, this is a relatively low risk change because the impacted analyzers were never shipped as NuGet packages and thus have never had an impact on the actual build outcome.</Description>
        <CreatedDate>22/05/2018</CreatedDate>
        <ClosedDate>29/06/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>26578</IssueID>
        <Title>Simplify impl of 'prefer predefined type'</Title>
        <Description>Similar to the work done to simplify the impl of "remove unnecessary cast".  however, a lot less work this time around as most of the code is already good.

One of the biggest benefits is simply moving to SyntaxEditor batch fixing so we can fix up the tree at once instead of having to merge N textual edits during a fix all.</Description>
        <CreatedDate>03/05/2018</CreatedDate>
        <ClosedDate>21/06/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>26578</IssueID>
        <Title>Simplify impl of 'prefer predefined type'</Title>
        <Description>Similar to the work done to simplify the impl of "remove unnecessary cast".  however, a lot less work this time around as most of the code is already good.

One of the biggest benefits is simply moving to SyntaxEditor batch fixing so we can fix up the tree at once instead of having to merge N textual edits during a fix all.</Description>
        <CreatedDate>03/05/2018</CreatedDate>
        <ClosedDate>21/06/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/PreferFrameworkType/PreferFrameworkTypeTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/PreferFrameworkType/PreferFrameworkTypeTests_FixAllTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Formatting/CodeCleanupTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/SimplifyTypeNames/SimplifyTypeNamesTests.cs</File>
      <File>src/Features/CSharp/Portable/CodeCleanup/CSharpCodeCleanupService.cs</File>
      <File>src/Features/CSharp/Portable/Diagnostics/Analyzers/CSharpPreferFrameworkTypeDiagnosticAnalyzer.cs</File>
      <File>src/Features/CSharp/Portable/Diagnostics/Analyzers/CSharpSimplifyTypeNamesDiagnosticAnalyzer.cs</File>
      <File>src/Features/CSharp/Portable/SimplifyTypeNames/SimplifyTypeNamesCodeFixProvider.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/Analyzers/IDEDiagnosticIds.cs</File>
      <File>src/Features/Core/Portable/PreferFrameworkType/PreferFrameworkTypeCodeFixProvider.cs</File>
      <File>src/Features/Core/Portable/PreferFrameworkType/PreferFrameworkTypeConstants.cs</File>
      <File>src/Features/Core/Portable/PreferFrameworkType/PreferFrameworkTypeDiagnosticAnalyzerBase.cs</File>
      <File>src/Features/Core/Portable/SimplifyTypeNames/AbstractSimplifyTypeNamesCodeFixProvider.cs</File>
      <File>src/Features/Core/Portable/SimplifyTypeNames/SimplifyTypeNamesDiagnosticAnalyzerBase.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>27331</IssueID>
    <Title>Fix handling of unrecognized naming style values</Title>
    <Description>* The first commit implements https://github.com/dotnet/roslyn/issues/20907#issuecomment-385058210
* The second commit fixes #18121, fixes #23336, fixes #23709, and closes #24248
* The third commit implements https://github.com/dotnet/roslyn/issues/20907#issuecomment-387071711, which closes #20907

## Screenshots

### Baseline (15.8 Preview 2)

![image](https://user-images.githubusercontent.com/1408396/40858499-0e92adea-65a4-11e8-9a86-1f721bb35159.png)

![image](https://user-images.githubusercontent.com/1408396/40858714-ddd5617e-65a4-11e8-8a22-fe51f4d92f9d.png)

### Baseline (current master branch e3dcf8c76dc2c228f61b9de8af92f1ec0275f5f8)

![image](https://user-images.githubusercontent.com/1408396/40859044-045e011a-65a6-11e8-8406-658be7dbf87a.png)

![image](https://user-images.githubusercontent.com/1408396/40859029-f434155e-65a5-11e8-9a30-01a80936d9b5.png)

### After second commit

![image](https://user-images.githubusercontent.com/1408396/40858824-3c41ab3c-65a5-11e8-8697-ef87a46813e3.png)

![image](https://user-images.githubusercontent.com/1408396/40858852-520398e0-65a5-11e8-90ba-ff8c14529064.png)

### After third commit

![image](https://user-images.githubusercontent.com/1408396/40859431-6ca56992-65a7-11e8-9c4f-360062f3c13b.png)

![image](https://user-images.githubusercontent.com/1408396/40859477-95cac344-65a7-11e8-85df-4ee664162921.png)

### Customer scenario

A user attempts to create a naming rule in .editorconfig for a symbol type added in a recent release of Roslyn. Old versions treat the rule as apply to *all* symbols when it should apply to *no* symbols. A similar situation applies for accessibilities.

In addition, some of our documented member kinds (namespace and type_parameter) do not work as documented.

### Bugs this fixes

#18121
#20907
#23336
#23709
#24248

### Workarounds, if any

Don't use the new feature.

### Risk

This change is relatively low risk for Preview 3. It builds on other new feature work in Preview 3, and helps ensure that a consistent experience is provided for the new feature now and in future releases.

### Performance impact

Low. Existing working patterns were used for the new analysis.

### Is this a regression from a previous update?

No.

### Root cause analysis

This is a supporting change for feature work already in Preview 3. It was intended for inclusion in the "mop-up" on Monday, but infrastructure and test problems delayed the work. Now that we see the tests working again with this pull request we are ready to submit it.

### How was the bug found?

Customer and internal customer reported.

### Test documentation updated?

No, but many new tests are added.
</Description>
    <CreatedDate>01/06/2018</CreatedDate>
    <ClosedDate>19/06/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>18121</IssueID>
        <Title>Cannot create naming rules for type parameters and local variables</Title>
        <Description>In trying to configure naming rules in an .editorconfig, I've found that the current implementation of naming rules lacks the ability to target certain symbol kinds. In my scenario I need the ability to target type parameters and local variables.

Type parameters and variables should be supported symbol kinds both through the options UI in VS and through .editorconfig files.
</Description>
        <CreatedDate>23/03/2017</CreatedDate>
        <ClosedDate>19/06/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23336</IssueID>
        <Title>EditorConfig Naming : type_parameter is typed to namespace?</Title>
        <Description>Was working on building out some naming conventions and realized that something fishy is going on with the symbols `type_parameter` and `namespace`. `namespace` doesn't seem to be a recognized symbol and rules defined for `type_parameters` run on namespace symbols (rather than parameters).

```
# Style Definitions
dotnet_naming_style.pascal_case_style.capitalization            = pascal_case
dotnet_naming_style.camel_case_style.capitalization             = camel_case

# Classes, structs, methods, enums, events, properties, namespaces, delegates must be PascalCase
dotnet_naming_rule.general_naming.severity                  = suggestion
dotnet_naming_rule.general_naming.symbols                   = general
dotnet_naming_rule.general_naming.style                     = pascal_case_style
dotnet_naming_symbols.general.applicable_kinds              = class, namespace
dotnet_naming_symbols.general.applicable_accessibilities    = *

# Everything else is camelCase
dotnet_naming_rule.everything_else_naming.severity                  = suggestion
dotnet_naming_rule.everything_else_naming.symbols                   = everything_else
dotnet_naming_rule.everything_else_naming.style                     = camel_case_style
dotnet_naming_symbols.everything_else.applicable_kinds              = type_parameter
dotnet_naming_symbols.everything_else.applicable_accessibilities       = *
```</Description>
        <CreatedDate>21/11/2017</CreatedDate>
        <ClosedDate>19/06/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23709</IssueID>
        <Title>Cannot refer to "private protected" in "applicable_accessibilities"</Title>
        <Description>```
dotnet_naming_rule.externally_visible_members_must_be_pascal_cased.symbols                                      = externally_visible_symbols
dotnet_naming_rule.externally_visible_members_must_be_pascal_cased.style                                        = pascal_case_style
dotnet_naming_rule.externally_visible_members_must_be_pascal_cased.severity                                     = warning

# Symbols
dotnet_naming_symbols.externally_visible_symbols.applicable_kinds                                               = field
dotnet_naming_symbols.externally_visible_symbols.applicable_accessibilities                                     = private_protected

# Styles
dotnet_naming_style.pascal_case_style.capitalization                                                            = pascal_case
```

``` C#
    class Program
    {
        private protected string fooBar;
    }
```

Expected: Warning on the naming
Actual: No warning</Description>
        <CreatedDate>11/12/2017</CreatedDate>
        <ClosedDate>19/06/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>24248</IssueID>
        <Title>.editorconfig some values aren't recognizable/supported by VS</Title>
        <Description>**Version Used**: Visual Studio Community 2017 v15.5.3

1. `flush_left` is documented [here](https://github.com/MicrosoftDocs/visualstudio-docs/blob/master/docs/ide/editorconfig-code-style-settings-reference.md) but [here](https://gist.github.com/jmarolf/0e165b27a498b49e3b3512004ea9d8b8) it's documented as `left_most` and yet VS doesn't recognize either of these values.

2. `type_parameter` and `namespace` they are documented [here](https://gist.github.com/jmarolf/0e165b27a498b49e3b3512004ea9d8b8) but are not documented anywhere else. @jmarolf does VS really support these values?

3. &lt;s&gt;`when_on_single_line` is documented [here](https://github.com/MicrosoftDocs/visualstudio-docs/blob/master/docs/ide/editorconfig-code-style-settings-reference.md) but it's not mentioned [here](https://gist.github.com/jmarolf/0e165b27a498b49e3b3512004ea9d8b8) and VS doesn't recognize it.&lt;/s&gt; Resolved.

It can be really confusing because you don't know whether VS supports these values or they are just aren't recognizable by the IDE and these values are important to my style of coding, probably to others too.







</Description>
        <CreatedDate>15/01/2018</CreatedDate>
        <ClosedDate>19/06/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>20907</IssueID>
        <Title>Editorconfig backwards compatibility dilemma</Title>
        <Description>We have a bit of a dilemma. If you don't fix this in 15.0–15.2, it will still get in the way and totally break the experience for anyone using 15.0–15.2 if we ever use `type_parameter` in an OSS project's .editorconfig.

Imagine that 15.3 is out with support for `type_parameter` and we want to enforce a `T` prefix followed by pascal case:
```ini
dotnet_naming_style.type_parameter.required_prefix = T
dotnet_naming_style.type_parameter.capitalization = pascal_case 
dotnet_naming_symbols.type_parameters.applicable_kinds = type_parameter
dotnet_naming_rule.type_parameters.severity = error
dotnet_naming_rule.type_parameters.symbols = type_parameters
dotnet_naming_rule.type_parameters.style = type_parameter
```

The problem is that this same block of settings in VS15.0–15.2 acts as though you had said `applicable_kinds = *`. This is a problem because suddenly every identifier ever is required by VS15.0–15.2 to begin with `T`.

This is a very similar problem to[ https://github.com/dotnet/roslyn/issues/20891](dotnet_naming_rule.*.symbols).

The only fix I can see is to push a fix to VS15.0–15.2 that
 1. splits the line by commas
 2. **removes the items it doesn't recognize**
 3. **If the line exists and the list of recognized items is empty, apply the rule to nothing instead of applying the rule to everything.**

For `applicable_kinds`, you have 1 and 2 correct but you can verify that you don't have 3 correct because `type_parameter, event` acts as `event` but `type_parameter` acts as `*`.

For `dotnet_naming_rule.*.symbols`, as far as I can tell, you have all three parts wrong for backwards compatibility.

Otherwise, as you version this very useful and attractive system, how is anyone supposed to adopt new features without forcing everyone in the codebase to upgrade to the very latest VS before continuing any work, or bear through a flood of erroneous squiggles?

Thanks for considering.</Description>
        <CreatedDate>15/07/2017</CreatedDate>
        <ClosedDate>19/06/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>18121</IssueID>
        <Title>Cannot create naming rules for type parameters and local variables</Title>
        <Description>In trying to configure naming rules in an .editorconfig, I've found that the current implementation of naming rules lacks the ability to target certain symbol kinds. In my scenario I need the ability to target type parameters and local variables.

Type parameters and variables should be supported symbol kinds both through the options UI in VS and through .editorconfig files.
</Description>
        <CreatedDate>23/03/2017</CreatedDate>
        <ClosedDate>19/06/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>20907</IssueID>
        <Title>Editorconfig backwards compatibility dilemma</Title>
        <Description>We have a bit of a dilemma. If you don't fix this in 15.0–15.2, it will still get in the way and totally break the experience for anyone using 15.0–15.2 if we ever use `type_parameter` in an OSS project's .editorconfig.

Imagine that 15.3 is out with support for `type_parameter` and we want to enforce a `T` prefix followed by pascal case:
```ini
dotnet_naming_style.type_parameter.required_prefix = T
dotnet_naming_style.type_parameter.capitalization = pascal_case 
dotnet_naming_symbols.type_parameters.applicable_kinds = type_parameter
dotnet_naming_rule.type_parameters.severity = error
dotnet_naming_rule.type_parameters.symbols = type_parameters
dotnet_naming_rule.type_parameters.style = type_parameter
```

The problem is that this same block of settings in VS15.0–15.2 acts as though you had said `applicable_kinds = *`. This is a problem because suddenly every identifier ever is required by VS15.0–15.2 to begin with `T`.

This is a very similar problem to[ https://github.com/dotnet/roslyn/issues/20891](dotnet_naming_rule.*.symbols).

The only fix I can see is to push a fix to VS15.0–15.2 that
 1. splits the line by commas
 2. **removes the items it doesn't recognize**
 3. **If the line exists and the list of recognized items is empty, apply the rule to nothing instead of applying the rule to everything.**

For `applicable_kinds`, you have 1 and 2 correct but you can verify that you don't have 3 correct because `type_parameter, event` acts as `event` but `type_parameter` acts as `*`.

For `dotnet_naming_rule.*.symbols`, as far as I can tell, you have all three parts wrong for backwards compatibility.

Otherwise, as you version this very useful and attractive system, how is anyone supposed to adopt new features without forcing everyone in the codebase to upgrade to the very latest VS before continuing any work, or bear through a flood of erroneous squiggles?

Thanks for considering.</Description>
        <CreatedDate>15/07/2017</CreatedDate>
        <ClosedDate>19/06/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23336</IssueID>
        <Title>EditorConfig Naming : type_parameter is typed to namespace?</Title>
        <Description>Was working on building out some naming conventions and realized that something fishy is going on with the symbols `type_parameter` and `namespace`. `namespace` doesn't seem to be a recognized symbol and rules defined for `type_parameters` run on namespace symbols (rather than parameters).

```
# Style Definitions
dotnet_naming_style.pascal_case_style.capitalization            = pascal_case
dotnet_naming_style.camel_case_style.capitalization             = camel_case

# Classes, structs, methods, enums, events, properties, namespaces, delegates must be PascalCase
dotnet_naming_rule.general_naming.severity                  = suggestion
dotnet_naming_rule.general_naming.symbols                   = general
dotnet_naming_rule.general_naming.style                     = pascal_case_style
dotnet_naming_symbols.general.applicable_kinds              = class, namespace
dotnet_naming_symbols.general.applicable_accessibilities    = *

# Everything else is camelCase
dotnet_naming_rule.everything_else_naming.severity                  = suggestion
dotnet_naming_rule.everything_else_naming.symbols                   = everything_else
dotnet_naming_rule.everything_else_naming.style                     = camel_case_style
dotnet_naming_symbols.everything_else.applicable_kinds              = type_parameter
dotnet_naming_symbols.everything_else.applicable_accessibilities       = *
```</Description>
        <CreatedDate>21/11/2017</CreatedDate>
        <ClosedDate>19/06/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23709</IssueID>
        <Title>Cannot refer to "private protected" in "applicable_accessibilities"</Title>
        <Description>```
dotnet_naming_rule.externally_visible_members_must_be_pascal_cased.symbols                                      = externally_visible_symbols
dotnet_naming_rule.externally_visible_members_must_be_pascal_cased.style                                        = pascal_case_style
dotnet_naming_rule.externally_visible_members_must_be_pascal_cased.severity                                     = warning

# Symbols
dotnet_naming_symbols.externally_visible_symbols.applicable_kinds                                               = field
dotnet_naming_symbols.externally_visible_symbols.applicable_accessibilities                                     = private_protected

# Styles
dotnet_naming_style.pascal_case_style.capitalization                                                            = pascal_case
```

``` C#
    class Program
    {
        private protected string fooBar;
    }
```

Expected: Warning on the naming
Actual: No warning</Description>
        <CreatedDate>11/12/2017</CreatedDate>
        <ClosedDate>19/06/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>24248</IssueID>
        <Title>.editorconfig some values aren't recognizable/supported by VS</Title>
        <Description>**Version Used**: Visual Studio Community 2017 v15.5.3

1. `flush_left` is documented [here](https://github.com/MicrosoftDocs/visualstudio-docs/blob/master/docs/ide/editorconfig-code-style-settings-reference.md) but [here](https://gist.github.com/jmarolf/0e165b27a498b49e3b3512004ea9d8b8) it's documented as `left_most` and yet VS doesn't recognize either of these values.

2. `type_parameter` and `namespace` they are documented [here](https://gist.github.com/jmarolf/0e165b27a498b49e3b3512004ea9d8b8) but are not documented anywhere else. @jmarolf does VS really support these values?

3. &lt;s&gt;`when_on_single_line` is documented [here](https://github.com/MicrosoftDocs/visualstudio-docs/blob/master/docs/ide/editorconfig-code-style-settings-reference.md) but it's not mentioned [here](https://gist.github.com/jmarolf/0e165b27a498b49e3b3512004ea9d8b8) and VS doesn't recognize it.&lt;/s&gt; Resolved.

It can be really confusing because you don't know whether VS supports these values or they are just aren't recognizable by the IDE and these values are important to my style of coding, probably to others too.







</Description>
        <CreatedDate>15/01/2018</CreatedDate>
        <ClosedDate>19/06/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/Completion/CompletionProviders/DeclarationNameCompletionProviderTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Completion/CompletionProviders/DeclarationNameCompletionProviderTests_NameDeclarationInfoTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/ConvertAutoPropertyToFullProperty/ConvertAutoPropertyToFullPropertyTests_OptionSets.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/NamingStyles/EditorConfigNamingStyleParserTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/NamingStyles/NamingStylesTests.cs</File>
      <File>src/EditorFeatures/TestUtilities/Diagnostics/NamingStyles/NamingStylesTestOptionSets.cs</File>
      <File>src/Features/CSharp/Portable/Completion/CompletionProviders/DeclarationNameCompletionProvider.DeclarationInfo.cs</File>
      <File>src/Features/CSharp/Portable/Completion/CompletionProviders/DeclarationNameCompletionProvider.cs</File>
      <File>src/Features/CSharp/Portable/Completion/CompletionProviders/DeclarationNameCompletionProvider_BuiltInStyles.cs</File>
      <File>src/Features/CSharp/Portable/ConvertAutoPropertyToFullProperty/CSharpConvertAutoPropertyToFullPropertyCodeRefactoringProvider.cs</File>
      <File>src/Features/CSharp/Portable/Diagnostics/Analyzers/CSharpNamingStyleDiagnosticAnalyzer.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/Analyzers/NamingStyleDiagnosticAnalyzerBase.cs</File>
      <File>src/VisualStudio/Core/Impl/Options/Style/NamingPreferences/SymbolSpecification/SymbolSpecificationViewModel.cs</File>
      <File>src/Workspaces/Core/Portable/NamingStyles/EditorConfig/EditorConfigNamingStyleParser_SymbolSpec.cs</File>
      <File>src/Workspaces/Core/Portable/NamingStyles/Serialization/AccessibilityExtensions.cs</File>
      <File>src/Workspaces/Core/Portable/NamingStyles/Serialization/SymbolSpecification.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>27280</IssueID>
    <Title>EditorConfig full refresh</Title>
    <Description>Fixes #15003 (no document edits required for refresh)
Fixes #19089

This pull request implements the IDE side of the complete .editorconfig experience. This implementation is a workaround since we were not able to unify the compiler, IDE, and project system to a single API which is currently under development. However, the user-facing behavior provided by this pull request should be difficult to distinguish from the final desired state.

&lt;details&gt;&lt;summary&gt;Ask Mode template not completed&lt;/summary&gt;

&lt;!-- This template is not always required. If you aren't sure about whether it's needed or want help filling out the sections,
submit the pull request and then ask us for help. :) --&gt;

### Customer scenario

What does the customer do to get into this situation, and why do we think this
is common enough to address for this release.  (Granted, sometimes this will be
obvious "Open project, VS crashes" but in general, I need to understand how
common a scenario is)

### Bugs this fixes

(either VSO or GitHub links)

### Workarounds, if any

Also, why we think they are insufficient for RC vs. RC2, RC3, or RTW

### Risk

This is generally a measure our how central the affected code is to adjacent
scenarios and thus how likely your fix is to destabilize a broader area of code

### Performance impact

(with a brief justification for that assessment (e.g. "Low perf impact because no extra allocations/no complexity changes" vs. "Low")

### Is this a regression from a previous update?

### Root cause analysis

How did we miss it?  What tests are we adding to guard against it in the future?

### How was the bug found?

(E.g. customer reported it vs. ad hoc testing)

### Test documentation updated?

If this is a new non-compiler feature or a significant improvement to an existing feature, update https://github.com/dotnet/roslyn/wiki/Manual-Testing once you know which release it is targeting.

&lt;/details&gt;
</Description>
    <CreatedDate>31/05/2018</CreatedDate>
    <ClosedDate>11/06/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>15003</IssueID>
        <Title>Newly added .editorconfig only applied after reloading files</Title>
        <Description>Create a new C# console app.
Open `program.cs`
Right click -&gt; add new item -&gt; text file.
Rename the file to `.editorconfig` 
Paste the following into the file and save
```
[*.cs]
indent_style = tab
indent_size = 10
```
Switch to the `program.cs` tab and invoke `Edit.FormatDocument`.

Expected:
The document is formatted to use tabs and a wider indent.
Actual: Nothing happens
After closing and reopening program.cs, `Edit.FormatDocument` applies the new formattnig settings.</Description>
        <CreatedDate>04/11/2016</CreatedDate>
        <ClosedDate>11/06/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19089</IssueID>
        <Title>Fix All operations ignore .editorconfig</Title>
        <Description>**Version Used**: Latest master branch

**Steps to Reproduce**:

1. Use Tools&amp;rarr;Options to configure a preference to never use expression bodied properties, with severity Suggestion

1. Add a **.editorconfig** with the following line to override the one in Tools&amp;rarr;Options

    ```
    csharp_style_expression_bodied_properties = true:suggestion
    ```

1. Add the following to a document

    ```csharp
    internal class MyExample
    {
        public int X
        {
            get
            {
                return 3;
            }
        }

        public int Y =&gt; 5;
    }
    ```

1. On the line with `return 3`, use the light bulb to Fix All in Document.

**Expected Behavior**:

```csharp
internal class MyExample
{
    public int X =&gt; 3;

    public int Y =&gt; 5;
}
```

**Actual Behavior**:

```csharp
internal class MyExample
{
    public int X
    {
        get
        {
            return 3;
        }
    }

    public int Y { get =&gt; 5; }
}
```</Description>
        <CreatedDate>28/04/2017</CreatedDate>
        <ClosedDate>11/06/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/Core.Wpf/Options/EditorConfigDocumentOptionsProvider.Ide.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Options/EditorConfigDocumentOptionsProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Options/EditorConfigDocumentOptionsProviderFactory.cs</File>
      <File>src/Test/Utilities/Portable/Traits/Traits.cs</File>
      <File>src/VisualStudio/IntegrationTest/IntegrationTests/CSharp/CSharpCodeActions.cs</File>
      <File>src/VisualStudio/IntegrationTest/IntegrationTests/CSharp/CSharpFormatting.cs</File>
      <File>src/VisualStudio/IntegrationTest/TestUtilities/OutOfProcess/Editor_OutOfProc.cs</File>
      <File>src/VisualStudio/IntegrationTest/TestUtilities/OutOfProcess/VisualStudioWorkspace_OutOfProc.cs</File>
      <File>src/VisualStudio/IntegrationTest/TestUtilities/WellKnownCommandNames.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/Solution/Solution.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/Solution/SolutionState.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/Workspace_Editor.cs</File>
      <File>src/Workspaces/Remote/Core/Services/Options/FileWatcher.cs</File>
      <File>src/Workspaces/Remote/Core/Services/RemoteWorkspace.cs</File>
      <File>src/Workspaces/Remote/Core/Services/RoslynServices.cs</File>
      <File>src/Workspaces/Remote/Core/Services/TemporaryWorkspaceOptionsServiceFactory.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>27229</IssueID>
    <Title> Consolidate parentheses to two options</Title>
    <Description>⚠️ This pull request builds on #27220, and the review will be dramatically simplified once that is merged. The commit(s) unique to this pull request can be seen at the following permalink: https://github.com/dotnet/roslyn/compare/ee8eefa8358db3031b2f7215b32a3bef1681757b...12017375f93f27a5ba001992c2a9c814fde3a468

Fixes #27038

&lt;details&gt;&lt;summary&gt;Ask Mode template not completed&lt;/summary&gt;

&lt;!-- This template is not always required. If you aren't sure about whether it's needed or want help filling out the sections,
submit the pull request and then ask us for help. :) --&gt;

### Customer scenario

What does the customer do to get into this situation, and why do we think this
is common enough to address for this release.  (Granted, sometimes this will be
obvious "Open project, VS crashes" but in general, I need to understand how
common a scenario is)

### Bugs this fixes

(either VSO or GitHub links)

### Workarounds, if any

Also, why we think they are insufficient for RC vs. RC2, RC3, or RTW

### Risk

This is generally a measure our how central the affected code is to adjacent
scenarios and thus how likely your fix is to destabilize a broader area of code

### Performance impact

(with a brief justification for that assessment (e.g. "Low perf impact because no extra allocations/no complexity changes" vs. "Low")

### Is this a regression from a previous update?

### Root cause analysis

How did we miss it?  What tests are we adding to guard against it in the future?

### How was the bug found?

(E.g. customer reported it vs. ad hoc testing)

### Test documentation updated?

If this is a new non-compiler feature or a significant improvement to an existing feature, update https://github.com/dotnet/roslyn/wiki/Manual-Testing once you know which release it is targeting.

&lt;/details&gt;
</Description>
    <CreatedDate>29/05/2018</CreatedDate>
    <ClosedDate>11/06/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>27220</IssueID>
        <Title>Map 'none' in .editorconfig to ReportDiagnostic.Suppress</Title>
        <Description>Fixes #26972 

:memo: This is an intentionally constrained change.

* Each commit is a unit of work (single topic, complete, all tests passing). I **strongly encourage** reviewing each commit separately after a quick look to understand the overall direction.
* All *known* breaking (or possibly breaking) changes, except for those described in the design for #26972, are called out in comments.
* The inconsistent handling of `DiagnosticSeverity.Hidden` is preserved for all current diagnostics. Given the new ability to differentiate between `ReportDiagnostic.Hidden` and `ReportDiagnostic.Suppress`, we will likely want to revisit this behavior and make all diagnostics consistent.

&lt;details&gt;&lt;summary&gt;Ask Mode template not completed&lt;/summary&gt;

&lt;!-- This template is not always required. If you aren't sure about whether it's needed or want help filling out the sections,
submit the pull request and then ask us for help. :) --&gt;

### Customer scenario

What does the customer do to get into this situation, and why do we think this
is common enough to address for this release.  (Granted, sometimes this will be
obvious "Open project, VS crashes" but in general, I need to understand how
common a scenario is)

### Bugs this fixes

(either VSO or GitHub links)

### Workarounds, if any

Also, why we think they are insufficient for RC vs. RC2, RC3, or RTW

### Risk

This is generally a measure our how central the affected code is to adjacent
scenarios and thus how likely your fix is to destabilize a broader area of code

### Performance impact

(with a brief justification for that assessment (e.g. "Low perf impact because no extra allocations/no complexity changes" vs. "Low")

### Is this a regression from a previous update?

### Root cause analysis

How did we miss it?  What tests are we adding to guard against it in the future?

### How was the bug found?

(E.g. customer reported it vs. ad hoc testing)

### Test documentation updated?

If this is a new non-compiler feature or a significant improvement to an existing feature, update https://github.com/dotnet/roslyn/wiki/Manual-Testing once you know which release it is targeting.

&lt;/details&gt;
</Description>
        <CreatedDate>29/05/2018</CreatedDate>
        <ClosedDate>11/06/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>27038</IssueID>
        <Title>Consolidate options behavior for new parentheses analyzer</Title>
        <Description>**Version Used**: c190e84617b4b5e1d01b8bf1424b46709f326428

This is a proposal for a minor modification to simplify the available options for the new parentheses analyzer (#26013, #26710).

#### Current behavior:

* Two of the options allow the user to select **Require for clarity** or **Remove if unnecessary**. The **Ignore** option is handled implicitly by specifying an option and then selecting **None** as the severity.
* Two other options allow the user to select **Ignore** or **Remove if unnecessary**. The **Ignore** option is included to avoid a situation where the combo box only has one option.
* The .editorconfig support maps to the above options, so users need to understand the limitations to avoid creating a configuration which looks supported but internally will not parse.

#### Proposed behavior

* All options are updated to allow the user to select **Require for clarity** or **Remove if unnecessary**
* For the one option where **Require for clarity** does not currently make sense (the 'Other' category), the preview text for this option simply shows a statement that parentheses will be ignored, but a future release may add parentheses validation if a new operator is created which benefits from explicit parentheses

#### Design review notes

This proposal was created during a review with a subset of the design team, and is pending acceptance from the full team before implementation.</Description>
        <CreatedDate>22/05/2018</CreatedDate>
        <ClosedDate>11/06/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/Core/Portable/InternalUtilities/ExceptionUtilities.cs</File>
      <File>src/EditorFeatures/CSharpTest/AddRequiredParentheses/AddRequiredParenthesesTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/CodeActions/EncapsulateField/EncapsulateFieldTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/CodeActions/ExtractMethod/ExtractMethodTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/CodeActions/ReplaceMethodWithProperty/ReplaceMethodWithPropertyTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/CodeActions/UseExplicitType/UseExplicitTypeRefactoringTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/CodeActions/UseImplicitType/UseImplicitTypeRefactoringTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Completion/CompletionProviders/DeclarationNameCompletionProviderTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Completion/CompletionProviders/OverrideCompletionProviderTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Completion/CompletionProviders/PartialMethodCompletionProviderTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/ConvertAutoPropertyToFullProperty/ConvertAutoPropertyToFullPropertyTests_OptionSets.cs</File>
      <File>src/EditorFeatures/CSharpTest/ConvertForEachToFor/ConvertForEachToForTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/ConvertForToForEach/ConvertForToForEachTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/GenerateMethod/GenerateConversionTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/GenerateMethod/GenerateMethodTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/NamingStyles/EditorConfigNamingStyleParserTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/SimplifyTypeNames/SimplifyTypeNamesTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/UseImplicitOrExplicitType/UseExplicitTypeTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/UseImplicitOrExplicitType/UseImplicitTypeTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/EncapsulateField/EncapsulateFieldTestState.cs</File>
      <File>src/EditorFeatures/CSharpTest/GenerateConstructor/GenerateConstructorTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/GenerateFromMembers/GenerateConstructorFromMembers/GenerateConstructorFromMembersTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/GenerateFromMembers/GenerateEqualsAndGetHashCodeFromMembers/GenerateEqualsAndGetHashCodeFromMembersTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/ImplementAbstractClass/ImplementAbstractClassTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/ImplementInterface/ImplementInterfaceTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/InitializeParameter/AddParameterCheckTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/QualifyMemberAccess/QualifyMemberAccessTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseConditionalExpression/UseConditionalExpressionForAssignmentTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseExpressionBody/Analyzer/UseExpressionBodyForConstructorsAnalyzerTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseExpressionBody/Analyzer/UseExpressionBodyForConversionOperatorsAnalyzerTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseExpressionBody/Analyzer/UseExpressionBodyForIndexersAnalyzerTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseExpressionBody/Analyzer/UseExpressionBodyForMethodsAnalyzerTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseExpressionBody/Analyzer/UseExpressionBodyForOperatorsAnalyzerTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseExpressionBody/Analyzer/UseExpressionBodyForPropertiesAnalyzerTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseExpressionBody/Refactoring/UseExpressionBodyForAccessorsRefactoringTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseExpressionBody/Refactoring/UseExpressionBodyForConstructorsRefactoringTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseExpressionBody/Refactoring/UseExpressionBodyForConversionOperatorsRefactoringTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseExpressionBody/Refactoring/UseExpressionBodyForIndexersRefactoringTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseExpressionBody/Refactoring/UseExpressionBodyForMethodsRefactoringTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseExpressionBody/Refactoring/UseExpressionBodyForOperatorsRefactoringTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseExpressionBody/Refactoring/UseExpressionBodyForPropertiesRefactoringTests.cs</File>
      <File>src/EditorFeatures/Test/CodeGeneration/CodeGenerationTests.CSharp.cs</File>
      <File>src/EditorFeatures/TestUtilities/Diagnostics/AbstractDiagnosticProviderBasedUserDiagnosticTest.cs</File>
      <File>src/EditorFeatures/TestUtilities/Diagnostics/NamingStyles/NamingStylesTestOptionSets.cs</File>
      <File>src/Features/CSharp/Portable/AddAccessibilityModifiers/CSharpAddAccessibilityModifiersDiagnosticAnalyzer.cs</File>
      <File>src/Features/CSharp/Portable/AddBraces/CSharpAddBracesDiagnosticAnalyzer.cs</File>
      <File>src/Features/CSharp/Portable/CodeRefactorings/UseExplicitOrImplicitType/AbstractUseTypeCodeRefactoringProvider.cs</File>
      <File>src/Features/CSharp/Portable/Completion/CompletionProviders/DeclarationNameCompletionProvider_BuiltInStyles.cs</File>
      <File>src/Features/CSharp/Portable/ConvertAutoPropertyToFullProperty/CSharpConvertAutoPropertyToFullPropertyCodeRefactoringProvider.cs</File>
      <File>src/Features/CSharp/Portable/Diagnostics/Analyzers/CSharpTypeStyleDiagnosticAnalyzerBase.cs</File>
      <File>src/Features/CSharp/Portable/InlineDeclaration/CSharpInlineDeclarationDiagnosticAnalyzer.cs</File>
      <File>src/Features/CSharp/Portable/InvokeDelegateWithConditionalAccess/InvokeDelegateWithConditionalAccessAnalyzer.cs</File>
      <File>src/Features/CSharp/Portable/OrderModifiers/CSharpOrderModifiersDiagnosticAnalyzer.cs</File>
      <File>src/Features/CSharp/Portable/RemoveUnreachableCode/CSharpRemoveUnreachableCodeDiagnosticAnalyzer.cs</File>
      <File>src/Features/CSharp/Portable/UseDeconstruction/CSharpUseDeconstructionDiagnosticAnalyzer.cs</File>
      <File>src/Features/CSharp/Portable/UseDefaultLiteral/CSharpUseDefaultLiteralDiagnosticAnalyzer.cs</File>
      <File>src/Features/CSharp/Portable/UseExpressionBody/UseExpressionBodyDiagnosticAnalyzer.cs</File>
      <File>src/Features/CSharp/Portable/UseInferredMemberName/CSharpUseInferredMemberNameDiagnosticAnalyzer.cs</File>
      <File>src/Features/CSharp/Portable/UseLocalFunction/CSharpUseLocalFunctionCodeFixProvider.cs</File>
      <File>src/Features/CSharp/Portable/UseLocalFunction/CSharpUseLocalFunctionDiagnosticAnalyzer.cs</File>
      <File>src/Features/CSharp/Portable/UsePatternMatching/CSharpAsAndNullCheckDiagnosticAnalyzer.cs</File>
      <File>src/Features/CSharp/Portable/UsePatternMatching/CSharpIsAndCastCheckDiagnosticAnalyzer.cs</File>
      <File>src/Features/CSharp/Portable/UsePatternMatching/CSharpIsAndCastCheckWithoutNameDiagnosticAnalyzer.cs</File>
      <File>src/Features/Core/Portable/AddRequiredParentheses/AbstractAddRequiredParenthesesDiagnosticAnalyzer.cs</File>
      <File>src/Features/Core/Portable/CodeStyle/AbstractCodeStyleDiagnosticAnalyzer.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/AnalyzerHelper.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/Analyzers/NamingStyleDiagnosticAnalyzerBase.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/Analyzers/PreferFrameworkTypeDiagnosticAnalyzerBase.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/Analyzers/SimplifyTypeNamesDiagnosticAnalyzerBase.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/DiagnosticHelper.cs</File>
      <File>src/Features/Core/Portable/InitializeParameter/AbstractInitializeMemberFromParameterCodeRefactoringProviderMemberCreation.cs</File>
      <File>src/Features/Core/Portable/MakeFieldReadonly/AbstractMakeFieldReadonlyDiagnosticAnalyzer.cs</File>
      <File>src/Features/Core/Portable/OrderModifiers/AbstractOrderModifiersDiagnosticAnalyzer.cs</File>
      <File>src/Features/Core/Portable/PopulateSwitch/PopulateSwitchDiagnosticAnalyzer.cs</File>
      <File>src/Features/Core/Portable/QualifyMemberAccess/AbstractQualifyMemberAccessDiagnosticAnalyzer.cs</File>
      <File>src/Features/Core/Portable/RemoveUnnecessaryParentheses/AbstractRemoveUnnecessaryParenthesesDiagnosticAnalyzer.cs</File>
      <File>src/Features/Core/Portable/UseAutoProperty/AbstractUseAutoPropertyAnalyzer.cs</File>
      <File>src/Features/Core/Portable/UseCoalesceExpression/AbstractUseCoalesceExpressionDiagnosticAnalyzer.cs</File>
      <File>src/Features/Core/Portable/UseCoalesceExpression/AbstractUseCoalesceExpressionForNullableDiagnosticAnalyzer.cs</File>
      <File>src/Features/Core/Portable/UseCollectionInitializer/AbstractUseCollectionInitializerDiagnosticAnalyzer.cs</File>
      <File>src/Features/Core/Portable/UseConditionalExpression/AbstractUseConditionalExpressionDiagnosticAnalyzer.cs</File>
      <File>src/Features/Core/Portable/UseExplicitTupleName/UseExplicitTupleNameDiagnosticAnalyzer.cs</File>
      <File>src/Features/Core/Portable/UseIsNullCheck/AbstractUseIsNullDiagnosticAnalyzer.cs</File>
      <File>src/Features/Core/Portable/UseNullPropagation/AbstractUseNullPropagationDiagnosticAnalyzer.cs</File>
      <File>src/Features/Core/Portable/UseObjectInitializer/AbstractUseObjectInitializerDiagnosticAnalyzer.cs</File>
      <File>src/Features/Core/Portable/UseThrowExpression/AbstractUseThrowExpressionDiagnosticAnalyzer.cs</File>
      <File>src/VisualStudio/CSharp/Impl/Options/Formatting/StyleViewModel.cs</File>
      <File>src/VisualStudio/CSharp/Test/EventHookup/EventHookupCommandHandlerTests.cs</File>
      <File>src/VisualStudio/Core/Def/ServicesVSResources.Designer.cs</File>
      <File>src/VisualStudio/Core/Impl/Options/AbstractOptionPreviewViewModel.cs</File>
      <File>src/VisualStudio/Core/Impl/Options/CheckBoxWithComboViewModel.cs</File>
      <File>src/VisualStudio/Core/Impl/Options/Style/AbstractCodeStyleOptionViewModel.cs</File>
      <File>src/VisualStudio/Core/Impl/Options/Style/BooleanCodeStyleOptionViewModel.cs</File>
      <File>src/VisualStudio/Core/Impl/Options/Style/EnumCodeStyleOptionViewModel.cs</File>
      <File>src/VisualStudio/Core/Impl/Options/Style/NamingPreferences/NamingStyleOptionPageControl.xaml.cs</File>
      <File>src/VisualStudio/Core/Impl/Options/Style/NamingPreferences/NamingStyleOptionPageViewModel.cs</File>
      <File>src/VisualStudio/Core/Test.Next/Services/VisualStudioDiagnosticAnalyzerExecutorTests.cs</File>
      <File>src/Workspaces/CSharp/Portable/CodeStyle/CSharpCodeStyleOptions.cs</File>
      <File>src/Workspaces/CSharp/Portable/Utilities/CSharpTypeStyleHelper.State.cs</File>
      <File>src/Workspaces/CSharp/Portable/Utilities/CSharpTypeStyleHelper.cs</File>
      <File>src/Workspaces/Core/Portable/CodeStyle/CodeStyleHelpers.cs</File>
      <File>src/Workspaces/Core/Portable/CodeStyle/CodeStyleOption.cs</File>
      <File>src/Workspaces/Core/Portable/CodeStyle/CodeStyleOptions.cs</File>
      <File>src/Workspaces/Core/Portable/CodeStyle/NotificationOption.cs</File>
      <File>src/Workspaces/Core/Portable/CodeStyle/ParenthesesPreference.cs</File>
      <File>src/Workspaces/Core/Portable/Diagnostics/Extensions.cs</File>
      <File>src/Workspaces/Core/Portable/NamingStyles/EditorConfig/EditorConfigNamingStyleParser_NamingRule.cs</File>
      <File>src/Workspaces/Core/Portable/NamingStyles/NamingRule.cs</File>
      <File>src/Workspaces/Core/Portable/NamingStyles/Serialization/SerializableNamingRule.cs</File>
      <File>src/Workspaces/CoreTest/CodeStyle/EditorConfigCodeStyleParserTests.cs</File>
      <File>src/Workspaces/CoreTest/EditorConfigStorageLocation/EditorConfigStorageLocationTests.cs</File>
      <File>src/Workspaces/CoreTest/Execution/SnapshotSerializationTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>27220</IssueID>
    <Title>Map 'none' in .editorconfig to ReportDiagnostic.Suppress</Title>
    <Description>Fixes #26972 

:memo: This is an intentionally constrained change.

* Each commit is a unit of work (single topic, complete, all tests passing). I **strongly encourage** reviewing each commit separately after a quick look to understand the overall direction.
* All *known* breaking (or possibly breaking) changes, except for those described in the design for #26972, are called out in comments.
* The inconsistent handling of `DiagnosticSeverity.Hidden` is preserved for all current diagnostics. Given the new ability to differentiate between `ReportDiagnostic.Hidden` and `ReportDiagnostic.Suppress`, we will likely want to revisit this behavior and make all diagnostics consistent.

&lt;details&gt;&lt;summary&gt;Ask Mode template not completed&lt;/summary&gt;

&lt;!-- This template is not always required. If you aren't sure about whether it's needed or want help filling out the sections,
submit the pull request and then ask us for help. :) --&gt;

### Customer scenario

What does the customer do to get into this situation, and why do we think this
is common enough to address for this release.  (Granted, sometimes this will be
obvious "Open project, VS crashes" but in general, I need to understand how
common a scenario is)

### Bugs this fixes

(either VSO or GitHub links)

### Workarounds, if any

Also, why we think they are insufficient for RC vs. RC2, RC3, or RTW

### Risk

This is generally a measure our how central the affected code is to adjacent
scenarios and thus how likely your fix is to destabilize a broader area of code

### Performance impact

(with a brief justification for that assessment (e.g. "Low perf impact because no extra allocations/no complexity changes" vs. "Low")

### Is this a regression from a previous update?

### Root cause analysis

How did we miss it?  What tests are we adding to guard against it in the future?

### How was the bug found?

(E.g. customer reported it vs. ad hoc testing)

### Test documentation updated?

If this is a new non-compiler feature or a significant improvement to an existing feature, update https://github.com/dotnet/roslyn/wiki/Manual-Testing once you know which release it is targeting.

&lt;/details&gt;
</Description>
    <CreatedDate>29/05/2018</CreatedDate>
    <ClosedDate>11/06/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>26972</IssueID>
        <Title>Map 'none' in .editorconfig to DiagnosticSeverity.None</Title>
        <Description>Currently the .editorconfig severity specifiers `silent` and `none` both map to `DiagnosticSeverity.Hidden`. This makes it difficult to disable the code fixes (and the corresponding Fix All) for diagnostics via .editorconfig alone. I propose leaving `silent` as mapping to `Hidden`, and modifying `None` to map to `None`.

Here is the impacted section of code:

https://github.com/dotnet/roslyn/blob/878ffad23b8b06cb229c9ab31eada7634a473508/src/Workspaces/Core/Portable/NamingStyles/EditorConfig/EditorConfigNamingStyleParser_NamingRule.cs#L52-L54

:memo: The Tools &amp;rarr; Options behavior is outside the scope of this design proposal. Only .editorconfig is directly impacted.

### Motivation

The following scenarios motivated this proposal:

* The Code Cleanup feature allows users to fix diagnostics reported for different code style categories. Since the diagnostics are not filtered by severity, currently .editorconfig does not provide a way to disable analysis and automatic cleanup for its options.
* The design discussions for the recent Add/Remove Parentheses code style feature showed everyone saw 'none' as equivalent to 'ignore', and served to influence the code generation features but not the code cleanup features.

We believe users have already mostly interpreted .editorconfig severities consistent with the proposed design, so the change should not be a surprise. Edge cases where the current behavior is desired will continue to be supported by the `silent` severity and/or by one-off refactoring operations that are exposed when primary diagnostics are disabled.</Description>
        <CreatedDate>18/05/2018</CreatedDate>
        <ClosedDate>11/06/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>26972</IssueID>
        <Title>Map 'none' in .editorconfig to DiagnosticSeverity.None</Title>
        <Description>Currently the .editorconfig severity specifiers `silent` and `none` both map to `DiagnosticSeverity.Hidden`. This makes it difficult to disable the code fixes (and the corresponding Fix All) for diagnostics via .editorconfig alone. I propose leaving `silent` as mapping to `Hidden`, and modifying `None` to map to `None`.

Here is the impacted section of code:

https://github.com/dotnet/roslyn/blob/878ffad23b8b06cb229c9ab31eada7634a473508/src/Workspaces/Core/Portable/NamingStyles/EditorConfig/EditorConfigNamingStyleParser_NamingRule.cs#L52-L54

:memo: The Tools &amp;rarr; Options behavior is outside the scope of this design proposal. Only .editorconfig is directly impacted.

### Motivation

The following scenarios motivated this proposal:

* The Code Cleanup feature allows users to fix diagnostics reported for different code style categories. Since the diagnostics are not filtered by severity, currently .editorconfig does not provide a way to disable analysis and automatic cleanup for its options.
* The design discussions for the recent Add/Remove Parentheses code style feature showed everyone saw 'none' as equivalent to 'ignore', and served to influence the code generation features but not the code cleanup features.

We believe users have already mostly interpreted .editorconfig severities consistent with the proposed design, so the change should not be a surprise. Edge cases where the current behavior is desired will continue to be supported by the `silent` severity and/or by one-off refactoring operations that are exposed when primary diagnostics are disabled.</Description>
        <CreatedDate>18/05/2018</CreatedDate>
        <ClosedDate>11/06/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/Core/Portable/InternalUtilities/ExceptionUtilities.cs</File>
      <File>src/EditorFeatures/CSharpTest/CodeActions/EncapsulateField/EncapsulateFieldTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/CodeActions/ExtractMethod/ExtractMethodTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/CodeActions/ReplaceMethodWithProperty/ReplaceMethodWithPropertyTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/CodeActions/UseExplicitType/UseExplicitTypeRefactoringTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/CodeActions/UseImplicitType/UseImplicitTypeRefactoringTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Completion/CompletionProviders/DeclarationNameCompletionProviderTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Completion/CompletionProviders/OverrideCompletionProviderTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Completion/CompletionProviders/PartialMethodCompletionProviderTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/ConvertAutoPropertyToFullProperty/ConvertAutoPropertyToFullPropertyTests_OptionSets.cs</File>
      <File>src/EditorFeatures/CSharpTest/ConvertForEachToFor/ConvertForEachToForTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/ConvertForToForEach/ConvertForToForEachTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/GenerateMethod/GenerateConversionTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/GenerateMethod/GenerateMethodTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/NamingStyles/EditorConfigNamingStyleParserTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/SimplifyTypeNames/SimplifyTypeNamesTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/UseImplicitOrExplicitType/UseExplicitTypeTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/UseImplicitOrExplicitType/UseImplicitTypeTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/EncapsulateField/EncapsulateFieldTestState.cs</File>
      <File>src/EditorFeatures/CSharpTest/GenerateConstructor/GenerateConstructorTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/GenerateFromMembers/GenerateConstructorFromMembers/GenerateConstructorFromMembersTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/GenerateFromMembers/GenerateEqualsAndGetHashCodeFromMembers/GenerateEqualsAndGetHashCodeFromMembersTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/ImplementAbstractClass/ImplementAbstractClassTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/ImplementInterface/ImplementInterfaceTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/InitializeParameter/AddParameterCheckTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/QualifyMemberAccess/QualifyMemberAccessTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseConditionalExpression/UseConditionalExpressionForAssignmentTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseExpressionBody/Analyzer/UseExpressionBodyForConstructorsAnalyzerTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseExpressionBody/Analyzer/UseExpressionBodyForConversionOperatorsAnalyzerTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseExpressionBody/Analyzer/UseExpressionBodyForIndexersAnalyzerTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseExpressionBody/Analyzer/UseExpressionBodyForMethodsAnalyzerTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseExpressionBody/Analyzer/UseExpressionBodyForOperatorsAnalyzerTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseExpressionBody/Analyzer/UseExpressionBodyForPropertiesAnalyzerTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseExpressionBody/Refactoring/UseExpressionBodyForAccessorsRefactoringTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseExpressionBody/Refactoring/UseExpressionBodyForConstructorsRefactoringTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseExpressionBody/Refactoring/UseExpressionBodyForConversionOperatorsRefactoringTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseExpressionBody/Refactoring/UseExpressionBodyForIndexersRefactoringTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseExpressionBody/Refactoring/UseExpressionBodyForMethodsRefactoringTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseExpressionBody/Refactoring/UseExpressionBodyForOperatorsRefactoringTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseExpressionBody/Refactoring/UseExpressionBodyForPropertiesRefactoringTests.cs</File>
      <File>src/EditorFeatures/Test/CodeGeneration/CodeGenerationTests.CSharp.cs</File>
      <File>src/EditorFeatures/TestUtilities/Diagnostics/NamingStyles/NamingStylesTestOptionSets.cs</File>
      <File>src/Features/CSharp/Portable/AddAccessibilityModifiers/CSharpAddAccessibilityModifiersDiagnosticAnalyzer.cs</File>
      <File>src/Features/CSharp/Portable/AddBraces/CSharpAddBracesDiagnosticAnalyzer.cs</File>
      <File>src/Features/CSharp/Portable/CodeRefactorings/UseExplicitOrImplicitType/AbstractUseTypeCodeRefactoringProvider.cs</File>
      <File>src/Features/CSharp/Portable/Completion/CompletionProviders/DeclarationNameCompletionProvider_BuiltInStyles.cs</File>
      <File>src/Features/CSharp/Portable/ConvertAutoPropertyToFullProperty/CSharpConvertAutoPropertyToFullPropertyCodeRefactoringProvider.cs</File>
      <File>src/Features/CSharp/Portable/Diagnostics/Analyzers/CSharpTypeStyleDiagnosticAnalyzerBase.cs</File>
      <File>src/Features/CSharp/Portable/InlineDeclaration/CSharpInlineDeclarationDiagnosticAnalyzer.cs</File>
      <File>src/Features/CSharp/Portable/InvokeDelegateWithConditionalAccess/InvokeDelegateWithConditionalAccessAnalyzer.cs</File>
      <File>src/Features/CSharp/Portable/OrderModifiers/CSharpOrderModifiersDiagnosticAnalyzer.cs</File>
      <File>src/Features/CSharp/Portable/RemoveUnreachableCode/CSharpRemoveUnreachableCodeDiagnosticAnalyzer.cs</File>
      <File>src/Features/CSharp/Portable/UseDeconstruction/CSharpUseDeconstructionDiagnosticAnalyzer.cs</File>
      <File>src/Features/CSharp/Portable/UseDefaultLiteral/CSharpUseDefaultLiteralDiagnosticAnalyzer.cs</File>
      <File>src/Features/CSharp/Portable/UseExpressionBody/UseExpressionBodyDiagnosticAnalyzer.cs</File>
      <File>src/Features/CSharp/Portable/UseInferredMemberName/CSharpUseInferredMemberNameDiagnosticAnalyzer.cs</File>
      <File>src/Features/CSharp/Portable/UseLocalFunction/CSharpUseLocalFunctionCodeFixProvider.cs</File>
      <File>src/Features/CSharp/Portable/UseLocalFunction/CSharpUseLocalFunctionDiagnosticAnalyzer.cs</File>
      <File>src/Features/CSharp/Portable/UsePatternMatching/CSharpAsAndNullCheckDiagnosticAnalyzer.cs</File>
      <File>src/Features/CSharp/Portable/UsePatternMatching/CSharpIsAndCastCheckDiagnosticAnalyzer.cs</File>
      <File>src/Features/CSharp/Portable/UsePatternMatching/CSharpIsAndCastCheckWithoutNameDiagnosticAnalyzer.cs</File>
      <File>src/Features/Core/Portable/AddRequiredParentheses/AbstractAddRequiredParenthesesDiagnosticAnalyzer.cs</File>
      <File>src/Features/Core/Portable/CodeStyle/AbstractCodeStyleDiagnosticAnalyzer.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/AnalyzerHelper.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/Analyzers/NamingStyleDiagnosticAnalyzerBase.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/Analyzers/PreferFrameworkTypeDiagnosticAnalyzerBase.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/Analyzers/SimplifyTypeNamesDiagnosticAnalyzerBase.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/DiagnosticHelper.cs</File>
      <File>src/Features/Core/Portable/InitializeParameter/AbstractInitializeMemberFromParameterCodeRefactoringProviderMemberCreation.cs</File>
      <File>src/Features/Core/Portable/MakeFieldReadonly/AbstractMakeFieldReadonlyDiagnosticAnalyzer.cs</File>
      <File>src/Features/Core/Portable/OrderModifiers/AbstractOrderModifiersDiagnosticAnalyzer.cs</File>
      <File>src/Features/Core/Portable/PopulateSwitch/PopulateSwitchDiagnosticAnalyzer.cs</File>
      <File>src/Features/Core/Portable/QualifyMemberAccess/AbstractQualifyMemberAccessDiagnosticAnalyzer.cs</File>
      <File>src/Features/Core/Portable/RemoveUnnecessaryParentheses/AbstractRemoveUnnecessaryParenthesesDiagnosticAnalyzer.cs</File>
      <File>src/Features/Core/Portable/UseAutoProperty/AbstractUseAutoPropertyAnalyzer.cs</File>
      <File>src/Features/Core/Portable/UseCoalesceExpression/AbstractUseCoalesceExpressionDiagnosticAnalyzer.cs</File>
      <File>src/Features/Core/Portable/UseCoalesceExpression/AbstractUseCoalesceExpressionForNullableDiagnosticAnalyzer.cs</File>
      <File>src/Features/Core/Portable/UseCollectionInitializer/AbstractUseCollectionInitializerDiagnosticAnalyzer.cs</File>
      <File>src/Features/Core/Portable/UseConditionalExpression/AbstractUseConditionalExpressionDiagnosticAnalyzer.cs</File>
      <File>src/Features/Core/Portable/UseExplicitTupleName/UseExplicitTupleNameDiagnosticAnalyzer.cs</File>
      <File>src/Features/Core/Portable/UseIsNullCheck/AbstractUseIsNullDiagnosticAnalyzer.cs</File>
      <File>src/Features/Core/Portable/UseNullPropagation/AbstractUseNullPropagationDiagnosticAnalyzer.cs</File>
      <File>src/Features/Core/Portable/UseObjectInitializer/AbstractUseObjectInitializerDiagnosticAnalyzer.cs</File>
      <File>src/Features/Core/Portable/UseThrowExpression/AbstractUseThrowExpressionDiagnosticAnalyzer.cs</File>
      <File>src/VisualStudio/CSharp/Test/EventHookup/EventHookupCommandHandlerTests.cs</File>
      <File>src/VisualStudio/Core/Impl/Options/CheckBoxWithComboViewModel.cs</File>
      <File>src/VisualStudio/Core/Impl/Options/Style/AbstractCodeStyleOptionViewModel.cs</File>
      <File>src/VisualStudio/Core/Impl/Options/Style/BooleanCodeStyleOptionViewModel.cs</File>
      <File>src/VisualStudio/Core/Impl/Options/Style/EnumCodeStyleOptionViewModel.cs</File>
      <File>src/VisualStudio/Core/Impl/Options/Style/NamingPreferences/NamingStyleOptionPageControl.xaml.cs</File>
      <File>src/VisualStudio/Core/Impl/Options/Style/NamingPreferences/NamingStyleOptionPageViewModel.cs</File>
      <File>src/VisualStudio/Core/Test.Next/Services/VisualStudioDiagnosticAnalyzerExecutorTests.cs</File>
      <File>src/Workspaces/CSharp/Portable/CodeStyle/CSharpCodeStyleOptions.cs</File>
      <File>src/Workspaces/CSharp/Portable/Utilities/CSharpTypeStyleHelper.State.cs</File>
      <File>src/Workspaces/CSharp/Portable/Utilities/CSharpTypeStyleHelper.cs</File>
      <File>src/Workspaces/Core/Portable/CodeStyle/CodeStyleHelpers.cs</File>
      <File>src/Workspaces/Core/Portable/CodeStyle/CodeStyleOption.cs</File>
      <File>src/Workspaces/Core/Portable/CodeStyle/CodeStyleOptions.cs</File>
      <File>src/Workspaces/Core/Portable/CodeStyle/NotificationOption.cs</File>
      <File>src/Workspaces/Core/Portable/Diagnostics/Extensions.cs</File>
      <File>src/Workspaces/Core/Portable/NamingStyles/EditorConfig/EditorConfigNamingStyleParser_NamingRule.cs</File>
      <File>src/Workspaces/Core/Portable/NamingStyles/NamingRule.cs</File>
      <File>src/Workspaces/Core/Portable/NamingStyles/Serialization/SerializableNamingRule.cs</File>
      <File>src/Workspaces/CoreTest/CodeStyle/EditorConfigCodeStyleParserTests.cs</File>
      <File>src/Workspaces/CoreTest/EditorConfigStorageLocation/EditorConfigStorageLocationTests.cs</File>
      <File>src/Workspaces/CoreTest/Execution/SnapshotSerializationTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>27160</IssueID>
    <Title>Implement GetSymbolInfo for the identifier in a property pattern.</Title>
    <Description>Fixes #9284
Fixes #26607
Fixes #26139

@cston @agocke Please review this pattern-matching change to implement GetSymbolInfo for subpatterns.
/cc @dotnet/roslyn-compiler 
</Description>
    <CreatedDate>25/05/2018</CreatedDate>
    <ClosedDate>05/06/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>9284</IssueID>
        <Title>SymbolInfo for bad property in a property pattern should contain candidate symbols</Title>
        <Description>The `SymbolInfo` returned when there is a bad property in a property pattern (e.g. because it is ambiguous, inaccessible, `static`, etc) should contain any properties that are (improperly) referenced.

See, for example, the test `AmbiguousNamedProperty` in `PatternMatchingTests`.
</Description>
        <CreatedDate>28/02/2016</CreatedDate>
        <ClosedDate>05/06/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>26607</IssueID>
        <Title>Semantic model not working for property sub pattern name.</Title>
        <Description>```c#
class C
{
    void M2()
    {
        object o = null;
        _ = o switch { Blah { X: Y } =&gt; 0, _ =&gt; 0 }; // try GetSymbolInfo on either X or the entire subpattern element
    }

    class Blah
    {
        public int X;
    }
}
```

Expected: get back the field symbol for Blah.X.  
Action: get back no symbol.

Note that Y is not defined.  But that should not impact if we return X or not.</Description>
        <CreatedDate>03/05/2018</CreatedDate>
        <ClosedDate>05/06/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>26139</IssueID>
        <Title>SemanticModel.GetSymbolInfo not working on property pattern names</Title>
        <Description>This is a bug in the `features/recursive-patterns` branch.

/cc @CyrusNajmabadi </Description>
        <CreatedDate>13/04/2018</CreatedDate>
        <ClosedDate>05/06/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Patterns.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/CSharpSemanticModel.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/MemberSemanticModel.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/SyntaxFactory.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/SyntaxFacts.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTestBase.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests2.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests3.cs</File>
      <File>src/EditorFeatures/CSharpTest/GenerateVariable/GenerateVariableTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>27030</IssueID>
    <Title>ToBadExpression() checking incorrect HasAnyErrors API</Title>
    <Description>Fixes #26516 
Fixes #26978

Bound nodes have two APIs to check for errors:
* `HasErrors` which is a fast flag that is set during creating the bound node (if an obvious semantic error). It does not guarentee that there are not other syntactical errors associated with the node.
* `HasAnyErrors` is slower, and used during binding to do a full check on including associated syntax nodes.

When calling the API `Binder.ToBadExpression()`, the caller should expect the returned `BoundBadExpression` to have `HasErrors` as true. However, as an optimization, this method checks the node if it `HasAnyErrors`, and returns it unchanged if so. Because of this mismatch, it will incorrectly return a node with `HasErrors=false` and `HasAnyErrors=true`, which violates the contract.

cc @dotnet/roslyn-compiler </Description>
    <CreatedDate>21/05/2018</CreatedDate>
    <ClosedDate>14/06/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>26516</IssueID>
        <Title>Exception binding bad ref</Title>
        <Description>Consider the following code:

``` c#
using System;
public class C {
    void G() { } 
    public void M() {
        int x = 42;
        G(ref void = ref x);
    }
}
```

This causes a cash in `BindAssignment` because it ends up calling `GetRefKind` on the void expression. 

``` txt
ystem.InvalidOperationException: Unexpected value 'TypeExpression' of type 'Microsoft.CodeAnalysis.CSharp.BoundKind'
   at Microsoft.CodeAnalysis.CSharp.BoundExpressionExtensions.GetRefKind(BoundExpression node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\BoundTree\BoundExpressionExtensions.cs:line 34
   at Microsoft.CodeAnalysis.CSharp.Binder.BindAssignment(AssignmentExpressionSyntax node, DiagnosticBag diagnostics) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 1315
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 404
   at Microsoft.CodeAnalysis.CSharp.Binder.BindArgumentExpression(DiagnosticBag diagnostics, ExpressionSyntax argumentExpression, RefKind refKind, Boolean allowArglist) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 2494
   at Microsoft.CodeAnalysis.CSharp.Binder.BindArgumentValue(DiagnosticBag diagnostics, ArgumentSyntax argumentSyntax, Boolean allowArglist, RefKind refKind) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 2270
   at Microsoft.CodeAnalysis.CSharp.Binder.BindArgumentAndName(AnalyzedArguments result, DiagnosticBag diagnostics, Boolean&amp; hadError, Boolean&amp; hadLangVersionError, ArgumentSyntax argumentSyntax, Boolean allowArglist, Boolean isDelegateCreation) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 2235
   at Microsoft.CodeAnalysis.CSharp.Binder.BindInvocationExpression(InvocationExpressionSyntax node, DiagnosticBag diagnostics) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Invocation.cs:line 148
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 384
```

</Description>
        <CreatedDate>30/04/2018</CreatedDate>
        <ClosedDate>14/06/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>26978</IssueID>
        <Title>Binding DynamicMemberAccess expressions crashes VS</Title>
        <Description>```csharp
class C
{
    void M(dynamic x)
    {
        x.test = ref x;
    }
}
```
Result on latest master:
```
System.InvalidOperationException: Unexpected value 'DynamicMemberAccess' of type 'Microsoft.CodeAnalysis.CSharp.BoundKind'
   at Microsoft.CodeAnalysis.CSharp.BoundExpressionExtensions.GetRefKind(BoundExpression node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\BoundTree\BoundExpressionExtensions.cs:line 34
   at Microsoft.CodeAnalysis.CSharp.Binder.BindAssignment(AssignmentExpressionSyntax node, DiagnosticBag diagnostics) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 1315
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 404
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpression(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 329
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionStatement(CSharpSyntaxNode node, ExpressionSyntax syntax, Boolean allowsAnyExpression, DiagnosticBag diagnostics) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 566
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionStatement(ExpressionStatementSyntax node, DiagnosticBag diagnostics) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 559
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 49
   at Microsoft.CodeAnalysis.CSharp.Binder.BindBlockParts(BlockSyntax node, DiagnosticBag diagnostics) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 1599
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 43
   at Microsoft.CodeAnalysis.CSharp.Binder.BindMethodBody(CSharpSyntaxNode declaration, BlockSyntax blockBody, ArrowExpressionClauseSyntax expressionBody, DiagnosticBag diagnostics) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 3073
   at Microsoft.CodeAnalysis.CSharp.Binder.BindMethodBody(CSharpSyntaxNode syntax, DiagnosticBag diagnostics) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 3021
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.BindMethodBody(MethodSymbol method, TypeCompilationState compilationState, DiagnosticBag diagnostics, ImportChain&amp; importChain, Boolean&amp; originalBodyNested, ValueTuple`3&amp; forSemanticModel) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 1622
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethod(MethodSymbol methodSymbol, Int32 methodOrdinal, ProcessedFieldInitializers&amp; processedInitializers, SynthesizedSubmissionFields previousSubmissionFields, TypeCompilationState compilationState) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 943
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(NamedTypeSymbol containingType) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 494
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.&lt;&gt;c__DisplayClass21_0.&lt;CompileNamedTypeAsTask&gt;b__0() in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 384
   at Roslyn.Utilities.UICultureUtilities.&lt;&gt;c__DisplayClass5_0.&lt;WithCurrentUICulture&gt;b__0() in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\Core\Portable\InternalUtilities\UICultureUtilities.cs:line 136
   at System.Threading.Tasks.Task.InnerInvoke()
   at System.Threading.Tasks.Task.Execute()
```</Description>
        <CreatedDate>18/05/2018</CreatedDate>
        <ClosedDate>14/06/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/BoundTree/BoundExpressionExtensions.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/RefLocalsAndReturnsTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>26997</IssueID>
    <Title>Infer type in get accessor declarations, expression bodied local functions and local functions inside lambda expressions</Title>
    <Description>### Customer scenario

Customer generates a variable or method from within:
- an expression bodied getter
- an expression bodied local function/
- a block bodied location function inside a lambda expression 

and notices type inferences does not work. See the bug below for a code example, or refer to the newly added unit tests.

### Bugs this fixes

#26993 

### Workarounds, if any

Manually fix the type of the generated variable / the return type of the generated method.

### Risk

Risk is limited: this fix is basically an extension to the way similar scenarios (like expression bodies properties) are handled in the same file.

### Performance impact

Low, there's been some minor changes when inferring types in arrow expression clauses and return statements.

### Is this a regression from a previous update?
Not that I know of.

### Root cause analysis

These situations were not covered by unit tests yet. I added these tests now, including some extra unit tests validating situations which were already working as expected to prevent possible regressions in the future.

### How was the bug found?

Customer reported, see #26993.

### Test documentation updated?

No impact on test documentation.
</Description>
    <CreatedDate>20/05/2018</CreatedDate>
    <ClosedDate>04/06/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>26993</IssueID>
        <Title>Type to generate not inferred in expression bodied getter</Title>
        <Description>```c#
class C
{
    int P
    {
        get =&gt; newField;
    }
}
```
Generate field on `newField` creates it with type `object` (which of course results in an error):
```c#
class C
{
    private object newField;

    int P
    {
        get =&gt; newField;
    }
}
```
The type should be `int` as is correctly generated when using an expression bodied property or a block with a return statement instead.</Description>
        <CreatedDate>19/05/2018</CreatedDate>
        <ClosedDate>04/06/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>26993</IssueID>
        <Title>Type to generate not inferred in expression bodied getter</Title>
        <Description>```c#
class C
{
    int P
    {
        get =&gt; newField;
    }
}
```
Generate field on `newField` creates it with type `object` (which of course results in an error):
```c#
class C
{
    private object newField;

    int P
    {
        get =&gt; newField;
    }
}
```
The type should be `int` as is correctly generated when using an expression bodied property or a block with a return statement instead.</Description>
        <CreatedDate>19/05/2018</CreatedDate>
        <ClosedDate>04/06/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/GenerateMethod/GenerateMethodTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/GenerateVariable/GenerateVariableTests.cs</File>
      <File>src/Workspaces/CSharp/Portable/LanguageServices/CSharpTypeInferenceService.TypeInferrer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>26612</IssueID>
    <Title>lower interpolated strings to string concatenation where possible</Title>
    <Description>This PR handles #22594 and is a follow up for #22595.

**Customer scenario**

The user uses string interpolation where concatenation could be used.

**Risk**

This PR modifies code generation of interpolated strings, but only in the case where all fill-ins are strings without alignment or format specifiers.

**Performance impact**

Code generation for interpolated strings will be somewhat slower. The generated code will be significantly faster in the case where all fill-ins in the interpolated string are strings, without alignment or format specifiers. In all other cases, the new implementation has one additional loop over the parts with no memory allocations in it, fairly simple logic and early exit as soon it is determined that the code gen optimization cannot be done.

Given the following declarations:

    const string constantabc = "abc";
    const string constantnull = null;

With `/o`, the following methods compile to the following IL:

    string M1() =&gt; $"";

	IL_0000: ldstr ""
	IL_0005: ret

    string M2() =&gt; $"abc";

	IL_0000: ldstr "abc"
	IL_0005: ret

    string M3() =&gt; $"{constantabc}";

	IL_0000: ldstr "abc"
	IL_0005: ret

    string M4() =&gt; $"{constantnull}";

	IL_0000: ldstr ""
	IL_0005: ret

    string M5() =&gt; $"{constantabc}{constantnull}";

	IL_0000: ldstr "abc"
	IL_0005: ret

    string M6(string a) =&gt; $"{a}";

	IL_0000: ldarg.1
	IL_0001: dup
	IL_0002: brtrue.s IL_000a
	IL_0004: pop
	IL_0005: ldstr ""
	IL_000a: ret

    string M7(string a) =&gt; $"a: {a}";

	IL_0000: ldstr "a: "
	IL_0005: ldarg.1
	IL_0006: call string [mscorlib]System.String::Concat(string, string)
	IL_000b: ret

    string M8(string a, string b) =&gt; $"{a + b}";

	IL_0000: ldarg.1
	IL_0001: ldarg.2
	IL_0002: call string [mscorlib]System.String::Concat(string, string)
	IL_0007: ret

    string M9(string a, string b) =&gt; $"{a}{b}";

	IL_0000: ldarg.1
	IL_0001: ldarg.2
	IL_0002: call string [mscorlib]System.String::Concat(string, string)
	IL_0007: ret

    string M10(string a, string b) =&gt; $"a: {a}, b: {b}";

	IL_0000: ldstr "a: "
	IL_0005: ldarg.1
	IL_0006: ldstr ", b: "
	IL_000b: ldarg.2
	IL_000c: call string [mscorlib]System.String::Concat(string, string, string, string)
	IL_0011: ret

    string M11(object a) =&gt; $"{a}";

	IL_0000: ldstr "{0}"
	IL_0005: ldarg.1
	IL_0006: call string [mscorlib]System.String::Format(string, object)
	IL_000b: ret

    string M12(object a) =&gt; $"a: {a}";

	IL_0000: ldstr "a: {0}"
	IL_0005: ldarg.1
	IL_0006: call string [mscorlib]System.String::Format(string, object)
	IL_000b: ret

    string M13(string a) =&gt; $"{{{a}}}";

	IL_0000: ldstr "{"
	IL_0005: ldarg.1
	IL_0006: ldstr "}"
	IL_000b: call string [mscorlib]System.String::Concat(string, string, string)
	IL_0010: ret

    string M14(string a) =&gt; "a:" + $" {a}";

	IL_0000: ldstr "a: "
	IL_0005: ldarg.1
	IL_0006: call string [mscorlib]System.String::Concat(string, string)
	IL_000b: ret</Description>
    <CreatedDate>03/05/2018</CreatedDate>
    <ClosedDate>01/06/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>22594</IssueID>
        <Title>String interpolation can be optimized</Title>
        <Description>String interpolation has proven to be a very successful feature. Some people even replace efficient concatenation by interpolation, assuming the new syntax is just as efficient. However, that is not the case.

The [LDM of May 21, 2014](https://github.com/dotnet/csharplang/blob/172a371cd929d32cc0ef0344a2cee04745975e9d/meetings/2014/LDM-2014-05-21.md) noted:

&gt; The compiler would be free to not call `String.Format`, if it knows how to do things more optimally. This would typically be the case when there are no format specifiers in the string.

So far, nothing has been done to optimize interpolated strings in this way.

I believe there are five scenarios:

1. The interpolated string has no fill-ins. This case is handled already.
2. None of the fill-ins have alignment or format specifiers, and they are all strings.
3. None of the fill-ins have alignment or format specifiers, and they are all of reference type, some of which are not string (and may or may not implement `IFormattable`).
4. None of the fill-ins have alignment or format specifiers, and some of them are value types.
5. Some of the fill-ins have alignment or format specifiers.

Case 2 is surprisingly common. Last time I counted, Roslyn.sln had 1355 cases. It is also the easiest one to optimize. Basically, the call to `string.Format` can be replaced with string concatenation. That string concatenation is itself then lowered, often to a call to `string.Concat`. That lowering will perform constant folding, so in some cases no call is needed at all. [Performance differences](https://github.com/u2uconsult/codeanalyzers/blob/master/docs/U2U1105.md) can be significant.

I have prepared pull request #22595 to handle this case.</Description>
        <CreatedDate>09/10/2017</CreatedDate>
        <ClosedDate>01/06/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22595</IssueID>
        <Title>lower interpolated strings to string concatenation where possible</Title>
        <Description>This PR handles #22594.

**Customer scenario**

The user uses string interpolation where concatenation could be used.

**Risk**

This PR modifies code generation of interpolated strings, but only in the case where all fill-ins are strings without alignment or format specifiers.

**Performance impact**

Code generation for interpolated strings will be somewhat slower. The generated code will be significantly faster in the case where all fill-ins in the interpolated string are strings, without alignment or format specifiers. In all other cases, the new implementation has one additional loop over the parts with no memory allocations in it, fairly simple logic and early exit as soon it is determined that the code gen optimization cannot be done.

</Description>
        <CreatedDate>09/10/2017</CreatedDate>
        <ClosedDate>19/04/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_NullCoalescingOperator.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_StringInterpolation.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenDeconstructTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenInterpolatedString.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/PDB/PDBTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>26106</IssueID>
    <Title>Fix possible stack overflow in IntegrationHelper (#25313)</Title>
    <Description>Hi, this is my first pull request. I tried to fill the ask mode template as good as i could.

This should fix a possible stack overflow exception in the KillProcess method in IntegrationHelper.cs as reported in #25313 

&lt;details&gt;&lt;summary&gt;Ask Mode template completed&lt;/summary&gt;

&lt;!-- This template is not always required. If you aren't sure about whether it's needed or want help filling out the sections,
submit the pull request and then ask us for help. :) --&gt;

### Customer scenario

Calling KillProcess could result in a StackOverflowException.

### Bugs this fixes
Fixes #25313 

### Workarounds, if any

None

### Risk

Low risk

### Performance impact

Low performance impact. No extra allocations and no extra complexity

### Is this a regression from a previous update?

### Root cause analysis

How did we miss it?  What tests are we adding to guard against it in the future?

### How was the bug found?

Reported via #25313 

### Test documentation updated?

No

&lt;/details&gt;
</Description>
    <CreatedDate>11/04/2018</CreatedDate>
    <ClosedDate>17/06/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>25313</IssueID>
        <Title>Possible stack overflow in IntegrationHelper</Title>
        <Description>Use of an incorrect variable on the following line can produce a stack overflow at runtime:

https://github.com/dotnet/roslyn/blob/e123a4207123d5df8c45fb1caba0fb3acbae0e00/src/VisualStudio/IntegrationTest/TestUtilities/IntegrationHelper.cs#L217</Description>
        <CreatedDate>07/03/2018</CreatedDate>
        <ClosedDate>17/06/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>25313</IssueID>
        <Title>Possible stack overflow in IntegrationHelper</Title>
        <Description>Use of an incorrect variable on the following line can produce a stack overflow at runtime:

https://github.com/dotnet/roslyn/blob/e123a4207123d5df8c45fb1caba0fb3acbae0e00/src/VisualStudio/IntegrationTest/TestUtilities/IntegrationHelper.cs#L217</Description>
        <CreatedDate>07/03/2018</CreatedDate>
        <ClosedDate>17/06/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>25313</IssueID>
        <Title>Possible stack overflow in IntegrationHelper</Title>
        <Description>Use of an incorrect variable on the following line can produce a stack overflow at runtime:

https://github.com/dotnet/roslyn/blob/e123a4207123d5df8c45fb1caba0fb3acbae0e00/src/VisualStudio/IntegrationTest/TestUtilities/IntegrationHelper.cs#L217</Description>
        <CreatedDate>07/03/2018</CreatedDate>
        <ClosedDate>17/06/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/VisualStudio/IntegrationTest/TestUtilities/IntegrationHelper.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>24763</IssueID>
    <Title>Bug fixes and improvements to UseLocalFunction</Title>
    <Description>### Features added:
- **support for anonymous methods**: fixes #24760
- support for split initialization with no initializer - here there used to be a fix offered:
    ```c#
    Action a = null;
    a = () =&gt; { };
    ```
   here there was not (now there is too):
    ```c#
    Action a;
    a = () =&gt; { };
    ```
### Bugs fixed:
Sorry for including a new feature &amp; bug fixes in one PR. I didn't originally set out to fix bugs but I found so many of them while working on the feature:
fixes #24764
https://github.com/dotnet/roslyn/issues/24760#issuecomment-364655480
https://github.com/dotnet/roslyn/issues/24760#issuecomment-364764542
https://github.com/dotnet/roslyn/issues/24760#issuecomment-364807853
https://github.com/dotnet/roslyn/issues/24760#issuecomment-364879443
https://github.com/dotnet/roslyn/issues/24760#issuecomment-364935495
with a lot of tests added to cover these

### Performance impact
Most of the work I did is the code fix (which is invoked on demand), not the analyzer. So I hope none.</Description>
    <CreatedDate>10/02/2018</CreatedDate>
    <ClosedDate>19/06/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>24760</IssueID>
        <Title>'Use local function' should be offered for anonymous methods as well as lambdas</Title>
        <Description>**Steps to Reproduce**:

```c#
Action a = () =&gt; { Console.WriteLine(); };
Action b = delegate () { Console.WriteLine(); };
```

Click on `a`. 'Use local function' is suggested. No such thing on `b`.</Description>
        <CreatedDate>10/02/2018</CreatedDate>
        <ClosedDate>19/06/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>24764</IssueID>
        <Title>'Use local function' breaks code that uses named arguments</Title>
        <Description>**Steps to Reproduce**:

```c#
delegate void MyDelegate(string arg);

void M()
{
    MyDelegate d = s =&gt; { };

    d(arg: "hello");
}
```

after invoking 'Use local function' on `d`:

```c#
void d(string s)
{ }

d(arg: "hello");
```

code doesn't compile because there's no `arg` on `d`.</Description>
        <CreatedDate>10/02/2018</CreatedDate>
        <ClosedDate>19/06/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/UseLocalFunction/UseLocalFunctionTests.cs</File>
      <File>src/Features/CSharp/Portable/UseLocalFunction/CSharpUseLocalFunctionCodeFixProvider.cs</File>
      <File>src/Features/CSharp/Portable/UseLocalFunction/CSharpUseLocalFunctionDiagnosticAnalyzer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>22314</IssueID>
    <Title>AddParameterCodeFixProvider: Add support for method invocations.</Title>
    <Description>**Customer scenario**

Fixes #21446.
Fixes #25143.
Follow up to #17082.

This PR expands the `AddPrarameterCodefixProvider` to also support method invocations.

**Bugs this fixes:**

Fixes #21446.
Follow up to #17082.

**Workarounds, if any**

None.

**Risk**

Code refactoring might break user code.

**Performance impact**

Low. The analyzer is already shipped and this only increases the number of supported diagnostics.

**Is this a regression from a previous update?**

#17082 intentionally left method invocation out, because of the lots of complicated cases.

**Root cause analysis:**

Was intended for future improvement.

**How was the bug found?**

Customer reported. #21446

**Test documentation updated?**

No.</Description>
    <CreatedDate>25/09/2017</CreatedDate>
    <ClosedDate>11/06/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>21446</IssueID>
        <Title>Refactoring: add parameter when an argument is added to the invocation</Title>
        <Description>**Steps to reproduce**:
```cs
void Test(int a, int b, int c) {}

string x = null;
Test(a, b, c);
```
Add an argument to the invocation:
```cs
string x = null;
Test(a, b, c, x); 
```
**Expected Behavior**:

Also، suggest to add parameter "string x" to the existing method "Test".

**Actual Behavior**:

The only option is to add an overload.

![image](https://user-images.githubusercontent.com/3105979/29206956-7106c094-7e99-11e7-8bed-8b5946e18371.png)


</Description>
        <CreatedDate>11/08/2017</CreatedDate>
        <ClosedDate>11/06/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>25143</IssueID>
        <Title>Change Method Signature: add parameter</Title>
        <Description>We have a way to add a parameter to a constructor (https://docs.microsoft.com/en-us/visualstudio/ide/reference/generate-constructor#addparameter) but the only way to do it for a method is to generate an entirely new method.</Description>
        <CreatedDate>01/03/2018</CreatedDate>
        <ClosedDate>11/06/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>17082</IssueID>
        <Title>Preliminary support for the 'Add Parameter' feature.</Title>
        <Description>
        </Description>
        <CreatedDate>10/02/2017</CreatedDate>
        <ClosedDate>08/03/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>21446</IssueID>
        <Title>Refactoring: add parameter when an argument is added to the invocation</Title>
        <Description>**Steps to reproduce**:
```cs
void Test(int a, int b, int c) {}

string x = null;
Test(a, b, c);
```
Add an argument to the invocation:
```cs
string x = null;
Test(a, b, c, x); 
```
**Expected Behavior**:

Also، suggest to add parameter "string x" to the existing method "Test".

**Actual Behavior**:

The only option is to add an overload.

![image](https://user-images.githubusercontent.com/3105979/29206956-7106c094-7e99-11e7-8bed-8b5946e18371.png)


</Description>
        <CreatedDate>11/08/2017</CreatedDate>
        <ClosedDate>11/06/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>17082</IssueID>
        <Title>Preliminary support for the 'Add Parameter' feature.</Title>
        <Description>
        </Description>
        <CreatedDate>10/02/2017</CreatedDate>
        <ClosedDate>08/03/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>17082</IssueID>
        <Title>Preliminary support for the 'Add Parameter' feature.</Title>
        <Description>
        </Description>
        <CreatedDate>10/02/2017</CreatedDate>
        <ClosedDate>08/03/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>21446</IssueID>
        <Title>Refactoring: add parameter when an argument is added to the invocation</Title>
        <Description>**Steps to reproduce**:
```cs
void Test(int a, int b, int c) {}

string x = null;
Test(a, b, c);
```
Add an argument to the invocation:
```cs
string x = null;
Test(a, b, c, x); 
```
**Expected Behavior**:

Also، suggest to add parameter "string x" to the existing method "Test".

**Actual Behavior**:

The only option is to add an overload.

![image](https://user-images.githubusercontent.com/3105979/29206956-7106c094-7e99-11e7-8bed-8b5946e18371.png)


</Description>
        <CreatedDate>11/08/2017</CreatedDate>
        <ClosedDate>11/06/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/AddParameter/AddParameterTests.cs</File>
      <File>src/Features/CSharp/Portable/AddParameter/CSharpAddParameterCodeFixProvider.cs</File>
      <File>src/Features/CSharp/Portable/CodeFixes/GenerateMethod/GenerateMethodCodeFixProvider.cs</File>
      <File>src/Features/CSharp/Portable/GenerateConstructor/GenerateConstructorCodeFixProvider.cs</File>
      <File>src/Features/Core/Portable/AddParameter/AbstractAddParameterCodeFixProvider.cs</File>
      <File>src/Features/Core/Portable/AddParameter/ArgumentInsertPositionData.cs</File>
      <File>src/Features/Core/Portable/AddParameter/CodeFixData.cs</File>
      <File>src/Features/Core/Portable/FeaturesResources.Designer.cs</File>
      <File>src/Workspaces/CSharp/Portable/CodeGeneration/CSharpSyntaxGenerator.cs</File>
      <File>src/Workspaces/Core/Portable/Shared/Extensions/IMethodSymbolExtensions.cs</File>
      <File>src/Workspaces/Core/Portable/Shared/Extensions/ISymbolExtensions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>26522</IssueID>
    <Title>Fix the analyzer driver to make IOperation callbacks for code in cons…</Title>
    <Description>…tructor/destructor expression body

Fixes #26520 

Reported via https://github.com/dotnet/roslyn-analyzers/issues/1606,  https://github.com/dotnet/roslyn-analyzers/issues/1607 and https://github.com/dotnet/roslyn-analyzers/issues/1563.

&lt;details&gt;&lt;summary&gt;Ask Mode template&lt;/summary&gt;

### Customer scenario

Customer uses analyzer package that has an IOperation analyzer and gets false positives and/or false negatives for C# code which has constructor/destructor declarations with an expression body.

### Bugs this fixes

#26520 

### Workarounds, if any

Disable IOperation analyzers or don't use expression body for constructors/destructors.

### Risk

Low, seems like an oversight of the fields of `ConstructorDeclarationSyntax` and `DestructorDeclarationSyntax` nodes.

### Performance impact

Low

### Is this a regression from a previous update?

No, seems this has never worked.

### Root cause analysis

We didn't have test covering this area, now we have a regression test. Verified that added unit test fails prior to this fix.

### How was the bug found?

Yes, reported by customers using FxCop analyzer packages (see https://github.com/dotnet/roslyn-analyzers/issues/1606, https://github.com/dotnet/roslyn-analyzers/issues/1607 and https://github.com/dotnet/roslyn-analyzers/issues/1563)

### Test documentation updated?

N/A

&lt;/details&gt;
</Description>
    <CreatedDate>30/04/2018</CreatedDate>
    <ClosedDate>03/05/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>26520</IssueID>
        <Title>No IOperation callbacks into analyzer for operations in constructor/destructor expression body</Title>
        <Description>**Version Used**: 2.6.0 or later

**Steps to Reproduce**:

See https://github.com/dotnet/roslyn-analyzers/issues/1606 and https://github.com/dotnet/roslyn-analyzers/issues/1607.

**Expected Behavior**:
Below code should cause analyzer action callbacks for `IFieldReferenceOperation` for `flag` within constructor/destructor expression body:

```
internal class C
{
    public bool Flag;
    public C() =&gt; Flag = true;
    ~C() =&gt; Flag = false;    
}
```

**Actual Behavior**:
No analyzer action callbacks.
</Description>
        <CreatedDate>30/04/2018</CreatedDate>
        <ClosedDate>03/05/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>26520</IssueID>
        <Title>No IOperation callbacks into analyzer for operations in constructor/destructor expression body</Title>
        <Description>**Version Used**: 2.6.0 or later

**Steps to Reproduce**:

See https://github.com/dotnet/roslyn-analyzers/issues/1606 and https://github.com/dotnet/roslyn-analyzers/issues/1607.

**Expected Behavior**:
Below code should cause analyzer action callbacks for `IFieldReferenceOperation` for `flag` within constructor/destructor expression body:

```
internal class C
{
    public bool Flag;
    public C() =&gt; Flag = true;
    ~C() =&gt; Flag = false;    
}
```

**Actual Behavior**:
No analyzer action callbacks.
</Description>
        <CreatedDate>30/04/2018</CreatedDate>
        <ClosedDate>03/05/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/CSharpAnalyzerDriver/CSharpDeclarationComputer.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Diagnostics/DiagnosticAnalyzerTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>26517</IssueID>
    <Title>Allow nullable array in parser</Title>
    <Description>Fixes #23272 and #24482.</Description>
    <CreatedDate>30/04/2018</CreatedDate>
    <ClosedDate>01/05/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>23272</IssueID>
        <Title>Crash while typing using nullable reference types preview</Title>
        <Description>**Version Used**: Preview 11152017

```
Application: devenv.exe
Framework Version: v4.0.30319
Description: The application requested process termination through System.Environment.FailFast(string message).
Message: System.NullReferenceException: Object reference not set to an instance of an object.
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxFactsService.GetMemberBodySpanForSpeculativeBinding(SyntaxNode node)
   at Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions.GetSemanticModelForNodeAsync(ISemanticModelService semanticModelService, ISyntaxFactsService syntaxFactService, Document document, SyntaxNode node, TextSpan span, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions.&lt;GetSemanticModelForSpanAsync&gt;d__2.MoveNext()
Stack:
   at System.Environment.FailFast(System.String, System.Exception)
   at Microsoft.CodeAnalysis.FailFast.OnFatalException(System.Exception)
   at Microsoft.CodeAnalysis.ErrorReporting.FatalError.Report(System.Exception, System.Action`1&lt;System.Exception&gt;)
   at Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportUnlessCanceled(System.Exception)
   at Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions+&lt;GetSemanticModelForSpanAsync&gt;d__2.MoveNext()
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxFactsService.GetMemberBodySpanForSpeculativeBinding(Microsoft.CodeAnalysis.SyntaxNode)
   at Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions.GetSemanticModelForNodeAsync(Microsoft.CodeAnalysis.SemanticModelWorkspaceService.ISemanticModelService, Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService, Microsoft.CodeAnalysis.Document, Microsoft.CodeAnalysis.SyntaxNode, Microsoft.CodeAnalysis.Text.TextSpan, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions+&lt;GetSemanticModelForSpanAsync&gt;d__2.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].Start[[Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions+&lt;GetSemanticModelForSpanAsync&gt;d__2, Microsoft.CodeAnalysis.Workspaces, Version=2.7.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;GetSemanticModelForSpanAsync&gt;d__2 ByRef)
   at Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions.GetSemanticModelForSpanAsync(Microsoft.CodeAnalysis.Document, Microsoft.CodeAnalysis.Text.TextSpan, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__5.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__5, Microsoft.CodeAnalysis.Workspaces, Version=2.7.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;AddSemanticClassificationsAsync&gt;d__5 ByRef)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Document, Microsoft.CodeAnalysis.Text.TextSpan, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__2.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Classification.AbstractClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__2, Microsoft.CodeAnalysis.Workspaces, Version=2.7.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;AddSemanticClassificationsAsync&gt;d__2 ByRef)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Document, Microsoft.CodeAnalysis.Text.TextSpan, System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.WorkspaceClassificationDelegationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Classification.IClassificationService, Microsoft.CodeAnalysis.Document, Microsoft.CodeAnalysis.Text.TextSpan, System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ClassifySpansAsync&gt;d__2`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ClassifySpansAsync&gt;d__2`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Microsoft.CodeAnalysis.EditorFeatures, Version=2.7.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;ClassifySpansAsync&gt;d__2`1&lt;System.__Canon&gt; ByRef)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.ClassifySpansAsync[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IClassificationDelegationService`1&lt;System.__Canon&gt;, System.__Canon, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ProduceTagsAsync&gt;d__0`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ProduceTagsAsync&gt;d__0`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Microsoft.CodeAnalysis.EditorFeatures, Version=2.7.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;ProduceTagsAsync&gt;d__0`1&lt;System.__Canon&gt; ByRef)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.ProduceTagsAsync[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IClassificationDelegationService`1&lt;System.__Canon&gt;, System.__Canon, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationViewTaggerProvider.ProduceTagsAsync[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IClassificationDelegationService`1&lt;System.__Canon&gt;)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationViewTaggerProvider.ProduceTagsAsync(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;)
   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].ProduceTagsAsync(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;System.__Canon&gt;)
   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource+&lt;RecomputeTagsAsync&gt;d__73[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource+&lt;RecomputeTagsAsync&gt;d__73[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Microsoft.CodeAnalysis.EditorFeatures, Version=2.7.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;RecomputeTagsAsync&gt;d__73&lt;System.__Canon&gt; ByRef)
   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].RecomputeTagsAsync(System.Object, System.Nullable`1&lt;Microsoft.VisualStudio.Text.SnapshotPoint&gt;, System.Nullable`1&lt;Microsoft.CodeAnalysis.Text.TextChangeRange&gt;, System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan&gt;, System.Collections.Immutable.ImmutableDictionary`2&lt;Microsoft.VisualStudio.Text.ITextBuffer,Microsoft.CodeAnalysis.Editor.Shared.Tagging.TagSpanIntervalTree`1&lt;System.__Canon&gt;&gt;, Boolean, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource+&lt;&gt;c__DisplayClass63_0[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].&lt;RecomputeTagsForeground&gt;b__0(System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.Shared.Threading.AsynchronousSerialWorkQueue+&lt;&gt;c__DisplayClass11_0.&lt;EnqueueBackgroundTask&gt;b__0(System.Threading.Tasks.Task)
   at System.Threading.Tasks.ContinuationResultTaskFromTask`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].InnerInvoke()
   at System.Threading.Tasks.Task.Execute()
   at System.Threading.Tasks.Task.ExecutionContextCallback(System.Object)
   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)
   at System.Threading.Tasks.Task.ExecuteEntry(Boolean)
   at System.Threading.Tasks.Task.System.Threading.IThreadPoolWorkItem.ExecuteWorkItem()
   at System.Threading.ThreadPoolWorkQueue.Dispatch()
   at System.Threading._ThreadPoolWaitCallback.PerformWaitCallback()
```

The crash occurred twice while typing to replace the following lines:

https://github.com/Microsoft/perfview/blob/118f6bc000c9aaaa5e80f98e03fdfedf754b1790/src/FastSerialization/GrowableArray.cs#L359-L360

with this:

```csharp
private static readonly T[] EmptyArray = new T[0];
private T[]? array;
private int arrayLength;
```

working in the following order:

1. Add `?` to array
2. Type the `EmptyArray` field definition
3. Add the `private` accessibility modifiers to the existing fields</Description>
        <CreatedDate>18/11/2017</CreatedDate>
        <ClosedDate>01/05/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>24482</IssueID>
        <Title>Syntax error reported for nullable array cast</Title>
        <Description>```
class Program
{
    static void Main()
    {
        var x = (object[]?)null;
    }
}
```
```
(5,18): error CS1525: Invalid expression term 'object'
(5,25): error CS0443: Syntax error; value expected
```</Description>
        <CreatedDate>26/01/2018</CreatedDate>
        <ClosedDate>01/05/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Parser/LanguageParser.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/IncrementalParsing/IncrementalParsingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/NullableParsingTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>26336</IssueID>
    <Title>Naming style for locals</Title>
    <Description>fixes https://github.com/dotnet/roslyn/issues/22440#issuecomment-333562450 / half of #18121
This PR is separate from #26165 and only contains added support for local variables.

![image](https://user-images.githubusercontent.com/11444821/39136852-7055e066-471c-11e8-8963-b095e0be233b.png)
</Description>
    <CreatedDate>23/04/2018</CreatedDate>
    <ClosedDate>09/05/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>18121</IssueID>
        <Title>Cannot create naming rules for type parameters and local variables</Title>
        <Description>In trying to configure naming rules in an .editorconfig, I've found that the current implementation of naming rules lacks the ability to target certain symbol kinds. In my scenario I need the ability to target type parameters and local variables.

Type parameters and variables should be supported symbol kinds both through the options UI in VS and through .editorconfig files.
</Description>
        <CreatedDate>23/03/2017</CreatedDate>
        <ClosedDate>19/06/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>26165</IssueID>
        <Title>Naming style for local functions</Title>
        <Description>fixes #22440

I added a new option for local functions because it seems that people are divided on whether they should be named as locals or methods. For the same reason, I think we shouldn't give them a default style for now.

They're not even included in the default set of specifications. Users can to either include them with methods or add a new specification.

![image](https://user-images.githubusercontent.com/11444821/38782435-98906f8a-40f3-11e8-87bb-fbe07c184fa7.png)
![image](https://user-images.githubusercontent.com/11444821/38782437-abc6db5c-40f3-11e8-9342-163f96c0498f.png)
</Description>
        <CreatedDate>15/04/2018</CreatedDate>
        <ClosedDate>01/06/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/NamingStyles/EditorConfigNamingStyleParserTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/NamingStyles/NamingStylesTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/NamingStyles/NamingStylesTests_OptionSets.cs</File>
      <File>src/EditorFeatures/TestUtilities/Diagnostics/NamingStyles/NamingStylesTestOptionSets.cs</File>
      <File>src/Features/CSharp/Portable/Diagnostics/Analyzers/CSharpNamingStyleDiagnosticAnalyzer.cs</File>
      <File>src/Features/Core/Portable/CodeFixes/NamingStyle/AbstractNamingStyleCodeFixProvider.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/Analyzers/NamingStyleDiagnosticAnalyzerBase.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/SymbolAnalysisContextExtensions.cs</File>
      <File>src/VisualStudio/Core/Impl/Options/Style/NamingPreferences/SymbolSpecification/SymbolSpecificationViewModel.cs</File>
      <File>src/Workspaces/Core/Portable/NamingStyles/EditorConfig/EditorConfigNamingStyleParser_SymbolSpec.cs</File>
      <File>src/Workspaces/Core/Portable/NamingStyles/Serialization/SymbolSpecification.cs</File>
      <File>src/Workspaces/CoreTest/CodeStyle/EditorConfigCodeStyleParserTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>26135</IssueID>
    <Title>fix UpgradeProject crashes IDE with Unable to check out the files fro…</Title>
    <Description>…m source control #18199

&lt;details&gt;&lt;summary&gt;fix UpgradeProject crashes IDE with Unable to check out the files from source control #18199&lt;/summary&gt;

### Customer scenario
When choose Upgrade all projects to language version 'Latest' from quick fixes, IDE crashes because of "Unable to check out the files from source control" 
The file it tries to checkout are the TemporaryGeneratedFile_xxxx files, which get deleted and generated again when making project wide changes. Therefore the documentId changed and it cannot find the filepath for the old documentId, so it cannot checkout the file.

### Bugs this fixes
https://github.com/dotnet/roslyn/issues/18199

### Workarounds, if any
No

### Risk
Low, just added some null checks

### Performance impact
Low, just added some null checks without extra allocations

### Is this a regression from a previous update?
Not sure

### Root cause analysis

How did we miss it?  What tests are we adding to guard against it in the future?

### How was the bug found?
Customer reported it

### Test documentation updated?
No
&lt;/details&gt;
</Description>
    <CreatedDate>13/04/2018</CreatedDate>
    <ClosedDate>02/05/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>18199</IssueID>
        <Title>UpgradeProject crashes IDE with "Unable to check out the files from source control"</Title>
        <Description>I’m getting a crash when using the UpgradeProject fixer.
It comes from `void EnsureEditableDocuments(IEnumerable&lt;DocumentId&gt; documents)`

The input is a single document, which apparently has a null path.

I see a few possible interpretations, but I don’t know what’s the proper expectations:
1.	We should not be checking this document in the first place
2.	We should check this document, but it should have a path
3.	It’s ok for the check to fail, but the exception should not blow up the IDE

I have a repro project and a minidump if needed.

`[0] = (DocumentId, #15fef80d-55d3-442e-91f5-88ec51476497 - C:\Users\jcouv\AppData\Local\Temp\.NETFramework,Version=v4.6.AssemblyAttributes.cs)`


The result from QueryEditFiles is` -2147467261`.

```
&gt; Microsoft.VisualStudio.LanguageServices.dll!Microsoft.VisualStudio.LanguageServices.Implementation.ProjectSystem.VisualStudioWorkspaceImpl.EnsureEditableDocuments(System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.DocumentId&gt; documents) Line 1111    C#
Microsoft.VisualStudio.LanguageServices.dll!Microsoft.VisualStudio.LanguageServices.Implementation.ProjectSystem.VisualStudioWorkspaceImpl.EnsureEditableDocuments(Microsoft.CodeAnalysis.DocumentId[] documents) Line 1123    C#
Microsoft.VisualStudio.LanguageServices.dll!Microsoft.VisualStudio.LanguageServices.Implementation.ProjectSystem.VisualStudioWorkspaceImpl.ApplyDocumentTextChanged(Microsoft.CodeAnalysis.DocumentId documentId, Microsoft.CodeAnalysis.Text.SourceText newText) Line 855                C#
Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Workspace.ApplyChangedDocument(Microsoft.CodeAnalysis.ProjectChanges projectChanges, Microsoft.CodeAnalysis.DocumentId documentId) Line 1335       C#
Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Workspace.ApplyProjectChanges(Microsoft.CodeAnalysis.ProjectChanges projectChanges) Line 1283           C#
Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution newSolution, Microsoft.CodeAnalysis.Shared.Utilities.IProgressTracker progressTracker) Line 1075             C#
Microsoft.VisualStudio.LanguageServices.dll!Microsoft.VisualStudio.LanguageServices.Implementation.ProjectSystem.VisualStudioWorkspaceImpl.TryApplyChanges(Microsoft.CodeAnalysis.Solution newSolution, Microsoft.CodeAnalysis.Shared.Utilities.IProgressTracker progressTracker) Line 169               C#
Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.CodeActions.ApplyChangesOperation.TryApply(Microsoft.CodeAnalysis.Workspace workspace, Microsoft.CodeAnalysis.Shared.Utilities.IProgressTracker progressTracker, System.Threading.CancellationToken cancellationToken) Line 44 C#
Microsoft.CodeAnalysis.EditorFeatures.dll!Microsoft.CodeAnalysis.Editor.Implementation.CodeActions.CodeActionEditHandlerService.ProcessOperations(Microsoft.CodeAnalysis.Workspace workspace, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.CodeActions.CodeActionOperation&gt; operations, Microsoft.CodeAnalysis.Shared.Utilities.IProgressTracker progressTracker, System.Threading.CancellationToken cancellationToken) Line 258              C#
Microsoft.CodeAnalysis.EditorFeatures.dll!Microsoft.CodeAnalysis.Editor.Implementation.CodeActions.CodeActionEditHandlerService.ApplyAsync(Microsoft.CodeAnalysis.Workspace workspace, Microsoft.CodeAnalysis.Document fromDocument, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.CodeActions.CodeActionOperation&gt; operations, string title, Microsoft.CodeAnalysis.Shared.Utilities.IProgressTracker progressTracker, System.Threading.CancellationToken cancellationToken) Line 164              C#
Microsoft.CodeAnalysis.EditorFeatures.dll!Microsoft.CodeAnalysis.Editor.Implementation.Suggestions.SuggestedAction.InvokeWorker(System.Func&lt;Microsoft.CodeAnalysis.Document&gt; getFromDocument, Microsoft.CodeAnalysis.Shared.Utilities.IProgressTracker progressTracker, System.Threading.CancellationToken cancellationToken) Line 164              C#
Microsoft.CodeAnalysis.EditorFeatures.dll!Microsoft.CodeAnalysis.Editor.Implementation.Suggestions.SuggestedAction.InvokeCore.AnonymousMethod__0() Line 133                C#
Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Extensions.IExtensionManagerExtensions.PerformAction(Microsoft.CodeAnalysis.Extensions.IExtensionManager extensionManager, object extension, System.Action action) Line 22           C#
Microsoft.CodeAnalysis.EditorFeatures.dll!Microsoft.CodeAnalysis.Editor.Implementation.Suggestions.SuggestedAction.InvokeCore(System.Func&lt;Microsoft.CodeAnalysis.Document&gt; getFromDocument, Microsoft.CodeAnalysis.Shared.Utilities.IProgressTracker progressTracker, System.Threading.CancellationToken cancellationToken) Line 131              C#
Microsoft.CodeAnalysis.EditorFeatures.dll!Microsoft.CodeAnalysis.Editor.Implementation.Suggestions.SuggestedAction.InnerInvoke(Microsoft.CodeAnalysis.Shared.Utilities.IProgressTracker progressTracker, System.Threading.CancellationToken cancellationToken) Line 121           C#
Microsoft.CodeAnalysis.EditorFeatures.dll!Microsoft.CodeAnalysis.Editor.Implementation.Suggestions.SuggestedAction.Invoke.AnonymousMethod__0(Microsoft.CodeAnalysis.Editor.Host.IWaitContext waitContext) Line 107     C#
Microsoft.VisualStudio.LanguageServices.dll!Microsoft.VisualStudio.LanguageServices.Implementation.Utilities.VisualStudioWaitIndicator.Wait(string title, string message, bool allowCancel, bool showProgress, System.Action&lt;Microsoft.CodeAnalysis.Editor.Host.IWaitContext&gt; action) Line 43               C#
Microsoft.CodeAnalysis.EditorFeatures.dll!Microsoft.CodeAnalysis.Editor.Implementation.Suggestions.SuggestedAction.Invoke(System.Threading.CancellationToken cancellationToken) Line 103         C#
               [External Code] 

```
</Description>
        <CreatedDate>27/03/2017</CreatedDate>
        <ClosedDate>02/05/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>18199</IssueID>
        <Title>UpgradeProject crashes IDE with "Unable to check out the files from source control"</Title>
        <Description>I’m getting a crash when using the UpgradeProject fixer.
It comes from `void EnsureEditableDocuments(IEnumerable&lt;DocumentId&gt; documents)`

The input is a single document, which apparently has a null path.

I see a few possible interpretations, but I don’t know what’s the proper expectations:
1.	We should not be checking this document in the first place
2.	We should check this document, but it should have a path
3.	It’s ok for the check to fail, but the exception should not blow up the IDE

I have a repro project and a minidump if needed.

`[0] = (DocumentId, #15fef80d-55d3-442e-91f5-88ec51476497 - C:\Users\jcouv\AppData\Local\Temp\.NETFramework,Version=v4.6.AssemblyAttributes.cs)`


The result from QueryEditFiles is` -2147467261`.

```
&gt; Microsoft.VisualStudio.LanguageServices.dll!Microsoft.VisualStudio.LanguageServices.Implementation.ProjectSystem.VisualStudioWorkspaceImpl.EnsureEditableDocuments(System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.DocumentId&gt; documents) Line 1111    C#
Microsoft.VisualStudio.LanguageServices.dll!Microsoft.VisualStudio.LanguageServices.Implementation.ProjectSystem.VisualStudioWorkspaceImpl.EnsureEditableDocuments(Microsoft.CodeAnalysis.DocumentId[] documents) Line 1123    C#
Microsoft.VisualStudio.LanguageServices.dll!Microsoft.VisualStudio.LanguageServices.Implementation.ProjectSystem.VisualStudioWorkspaceImpl.ApplyDocumentTextChanged(Microsoft.CodeAnalysis.DocumentId documentId, Microsoft.CodeAnalysis.Text.SourceText newText) Line 855                C#
Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Workspace.ApplyChangedDocument(Microsoft.CodeAnalysis.ProjectChanges projectChanges, Microsoft.CodeAnalysis.DocumentId documentId) Line 1335       C#
Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Workspace.ApplyProjectChanges(Microsoft.CodeAnalysis.ProjectChanges projectChanges) Line 1283           C#
Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution newSolution, Microsoft.CodeAnalysis.Shared.Utilities.IProgressTracker progressTracker) Line 1075             C#
Microsoft.VisualStudio.LanguageServices.dll!Microsoft.VisualStudio.LanguageServices.Implementation.ProjectSystem.VisualStudioWorkspaceImpl.TryApplyChanges(Microsoft.CodeAnalysis.Solution newSolution, Microsoft.CodeAnalysis.Shared.Utilities.IProgressTracker progressTracker) Line 169               C#
Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.CodeActions.ApplyChangesOperation.TryApply(Microsoft.CodeAnalysis.Workspace workspace, Microsoft.CodeAnalysis.Shared.Utilities.IProgressTracker progressTracker, System.Threading.CancellationToken cancellationToken) Line 44 C#
Microsoft.CodeAnalysis.EditorFeatures.dll!Microsoft.CodeAnalysis.Editor.Implementation.CodeActions.CodeActionEditHandlerService.ProcessOperations(Microsoft.CodeAnalysis.Workspace workspace, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.CodeActions.CodeActionOperation&gt; operations, Microsoft.CodeAnalysis.Shared.Utilities.IProgressTracker progressTracker, System.Threading.CancellationToken cancellationToken) Line 258              C#
Microsoft.CodeAnalysis.EditorFeatures.dll!Microsoft.CodeAnalysis.Editor.Implementation.CodeActions.CodeActionEditHandlerService.ApplyAsync(Microsoft.CodeAnalysis.Workspace workspace, Microsoft.CodeAnalysis.Document fromDocument, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.CodeActions.CodeActionOperation&gt; operations, string title, Microsoft.CodeAnalysis.Shared.Utilities.IProgressTracker progressTracker, System.Threading.CancellationToken cancellationToken) Line 164              C#
Microsoft.CodeAnalysis.EditorFeatures.dll!Microsoft.CodeAnalysis.Editor.Implementation.Suggestions.SuggestedAction.InvokeWorker(System.Func&lt;Microsoft.CodeAnalysis.Document&gt; getFromDocument, Microsoft.CodeAnalysis.Shared.Utilities.IProgressTracker progressTracker, System.Threading.CancellationToken cancellationToken) Line 164              C#
Microsoft.CodeAnalysis.EditorFeatures.dll!Microsoft.CodeAnalysis.Editor.Implementation.Suggestions.SuggestedAction.InvokeCore.AnonymousMethod__0() Line 133                C#
Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Extensions.IExtensionManagerExtensions.PerformAction(Microsoft.CodeAnalysis.Extensions.IExtensionManager extensionManager, object extension, System.Action action) Line 22           C#
Microsoft.CodeAnalysis.EditorFeatures.dll!Microsoft.CodeAnalysis.Editor.Implementation.Suggestions.SuggestedAction.InvokeCore(System.Func&lt;Microsoft.CodeAnalysis.Document&gt; getFromDocument, Microsoft.CodeAnalysis.Shared.Utilities.IProgressTracker progressTracker, System.Threading.CancellationToken cancellationToken) Line 131              C#
Microsoft.CodeAnalysis.EditorFeatures.dll!Microsoft.CodeAnalysis.Editor.Implementation.Suggestions.SuggestedAction.InnerInvoke(Microsoft.CodeAnalysis.Shared.Utilities.IProgressTracker progressTracker, System.Threading.CancellationToken cancellationToken) Line 121           C#
Microsoft.CodeAnalysis.EditorFeatures.dll!Microsoft.CodeAnalysis.Editor.Implementation.Suggestions.SuggestedAction.Invoke.AnonymousMethod__0(Microsoft.CodeAnalysis.Editor.Host.IWaitContext waitContext) Line 107     C#
Microsoft.VisualStudio.LanguageServices.dll!Microsoft.VisualStudio.LanguageServices.Implementation.Utilities.VisualStudioWaitIndicator.Wait(string title, string message, bool allowCancel, bool showProgress, System.Action&lt;Microsoft.CodeAnalysis.Editor.Host.IWaitContext&gt; action) Line 43               C#
Microsoft.CodeAnalysis.EditorFeatures.dll!Microsoft.CodeAnalysis.Editor.Implementation.Suggestions.SuggestedAction.Invoke(System.Threading.CancellationToken cancellationToken) Line 103         C#
               [External Code] 

```
</Description>
        <CreatedDate>27/03/2017</CreatedDate>
        <ClosedDate>02/05/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/UpgradeProject/UpgradeProjectTests.cs</File>
      <File>src/EditorFeatures/TestUtilities/CodeActions/AbstractCodeActionOrUserDiagnosticTest.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/VisualStudioWorkspaceImpl.cs</File>
      <File>src/Workspaces/Core/Portable/CodeActions/CodeAction.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/Solution/Document.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/Solution/DocumentState.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/Solution/ProjectChanges.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/Workspace.cs</File>
      <File>src/Workspaces/CoreTestUtilities/SolutionUtilities.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>26023</IssueID>
    <Title>Update ICSharpCode.Decompiler to version 3.1.0.3652</Title>
    <Description>See release notes: https://github.com/icsharpcode/ILSpy/releases/tag/v3.1-final

### Customer scenario

A user enables the **Navigate to decompiled sources** feature, and the generated code does not appear as expected.

### Bugs this fixes

* Fixes dotnet/roslyn#25251 (Decompilation should simplify "type" usage)
* Fixes dotnet/roslyn#25246 (Decompilation cannot decompile xUnit's `Assert.All`)
* Fixes icsharpcode/ILSpy#1095 (C# decompilation, for flags enums always use hex prefix)

### Workarounds, if any

None.

### Risk

Low. No changes were made to transitive dependencies for the update, and the library is only used as part of an experimental feature which is disabled by default.

### Performance impact

No performance impact outside of the experimental scenario.

### Is this a regression from a previous update?

No.

### Root cause analysis

N/A

### How was the bug found?

Dogfooding, customer reporting

### Test documentation updated?

No.
</Description>
    <CreatedDate>08/04/2018</CreatedDate>
    <ClosedDate>01/05/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>25251</IssueID>
        <Title>Decompilation should simplify "type" usage</Title>
        <Description>Decompilation isn't apply the simplifier on the result of the decompilation, resulting in more complex code:

Current:

``` C#
		public static object Single(IEnumerable collection)
		{
			return Assert.Single(Enumerable.Cast&lt;object&gt;(collection));
		}
```

Expected:

``` C#
		public static object Single(IEnumerable collection)
		{
			return Single(Enumerable.Cast&lt;object&gt;(collection));
		}
```</Description>
        <CreatedDate>06/03/2018</CreatedDate>
        <ClosedDate>01/05/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>25246</IssueID>
        <Title>Decompilation cannot decompile xUnit's `Assert.All`</Title>
        <Description>Attempted to decompile `Assert.All` from xUnit.Assert (2.1.0) and got the following:

``` C#
		public static void All&lt;T&gt;(IEnumerable&lt;T&gt; collection, Action&lt;T&gt; action)
		{
			//IL_0016: Unknown result type (might be due to invalid IL)
			//IL_001b: Unknown result type (might be due to invalid IL)
			//IL_0038: Unknown result type (might be due to invalid IL)
			//IL_004c: Expected Ref, but got Unknown
			//IL_005d: Unknown result type (might be due to invalid IL)
			//IL_005e: Expected Ref, but got Unknown
			//IL_0069: Unknown result type (might be due to invalid IL)
			//IL_006a: Expected Ref, but got Unknown
			Assert.GuardArgumentNotNull("collection", collection);
			Assert.GuardArgumentNotNull("action", action);
			Stack val = new Stack();
			T[] array = collection.ToArray();
			for (int i = 0; i &lt; array.Length; i++)
			{
				try
				{
					action(array[i]);
				}
				catch (Exception item)
				{
					((Stack)(?)val).Push((!0)new Tuple&lt;int, object, Exception&gt;(i, (object)array[i], item));
				}
			}
			if (((Stack)(?)val).get_Count() &lt;= 0)
			{
				return;
			}
			throw new AllException(array.Length, (Tuple&lt;int, object, Exception&gt;[])((Stack)(?)val).ToArray());
		}
```</Description>
        <CreatedDate>06/03/2018</CreatedDate>
        <ClosedDate>01/05/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>1095</IssueID>
        <Title>fix crash due to control following through next statement</Title>
        <Description>I forgot to put "continue" in some places and it made null to pass into next statement.

it looks like I missed this case since I was concentrated on project document case not project case so this call path never exercised.
</Description>
        <CreatedDate>06/03/2015</CreatedDate>
        <ClosedDate>06/03/2015</ClosedDate>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>25622</IssueID>
    <Title>Completion for attributes: searching for attributes recursively</Title>
    <Description>### Customer scenario

A user tries to use code completion to add an attribute using a namespace-qualified name. The namespace doesn't appear in the completion list, and must be typed manually.

### Bugs this fixes

Fixes #25589

### Workarounds, if any

* Type the namespace name manually
* Add a `using` directive

### Risk

Low. The pull request re-implements a change from an earlier release, preserving its performance-improving characteristics and restoring the original behavior.

### Performance impact

We have no indication that this change will degrade performance in an observable manner. The change which led to this regression targeted a performance problem, but ended up making two changes: one of the changes was necessary to address the measured performance problem while the under was an unintended semantics change. This change restores the original semantics while preserving the performance improvement from the recent work.

### Is this a regression from a previous update?

Yes. Introduced as part of #19863.

### Root cause analysis

This situation only occurred when multiple levels of namespace nesting occurred. Tests have been added to prevent future regressions.

### How was the bug found?

Customer reported.

### Test documentation updated?

No.</Description>
    <CreatedDate>20/03/2018</CreatedDate>
    <ClosedDate>04/05/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>25589</IssueID>
        <Title>Intellisense doens't work in Attributes</Title>
        <Description>When typing out an Attribute, Intellisense doesn't include any available Namespaces other than those included in the System namespace.

This makes traversing Namespaces very difficult when specifying an attribute on a member.

To replicate:
Start typing out an Attribute Usage on a Class, Method, Field, Property, etc.
Look through the Intellisense list for a Namespace that you're looking for (other than System). It doesn't appear.

_This issue has been moved from https://developercommunity.visualstudio.com/content/problem/216577/intellisense-doenst-work-in-attributes.html
VSTS ticketId: 584324_
_These are the original issue comments:_
(no comments)
_These are the original issue solutions:_
(no solutions)</Description>
        <CreatedDate>19/03/2018</CreatedDate>
        <ClosedDate>04/05/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19863</IssueID>
        <Title>[Perf] Optimize IsOrContainsAccessibleAttribute</Title>
        <Description>the AbstractRecommendationService does a filter for which symbols should be included. Given this is called from ShouldIncludeSymbol, with this change we gain:
1. Fewer iterations, as an Attribute is a type declaration, so GetMembers -&gt; GetTypeMembers should give us fewer items to work with
2. One less lambda capture by unrolling the foreach loop.

**Customer scenario**

https://gist.github.com/Therzok/4a168d452c6dcd5cd9ac0ee9cf25ae0e

The stacktrace above details how these issues were found.

**Risk**

Risk is low. IsAttribute() can only be true on type members.

**Performance impact**

Improves performance

**Is this a regression from a previous update?**

No.

**Root cause analysis:**

How did we miss it?  What tests are we adding to guard against it in the future?

¯\_(ツ)_/¯, not a functionality change, but an optimization.

**How was the bug found?**

Profiling VSfM.
</Description>
        <CreatedDate>30/05/2017</CreatedDate>
        <ClosedDate>09/06/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/Completion/CompletionProviders/SymbolCompletionProviderTests.cs</File>
      <File>src/Workspaces/Core/Portable/Recommendations/AbstractRecommendationService.cs</File>
      <File>src/Workspaces/Core/Portable/Shared/Extensions/INamespaceOrTypeSymbolExtensions.cs</File>
      <File>src/Workspaces/Core/Portable/Shared/Extensions/INamespaceSymbolExtensions.cs</File>
      <File>src/Workspaces/Core/Portable/Shared/Extensions/ISymbolExtensions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23589</IssueID>
    <Title>Escape curly braces in string literals when converting concatenation to interpolated string</Title>
    <Description>### Customer scenario

Customer has a string concatenation where the string literal contains curly braces. For example:
```cs
var firstExample = "Something {X} = " + 9;
var secondExample = "Something {" + 9 + "}";
```

Using the "Convert to interpolated string" refactoring does not escape the curly braces in the string literal(s). When applying the refactoring, this can lead to compile errors or unmeant escapes:

```cs
// results as of now:
var firstExample = $"Something {X} = {9}"; // compile error: {X} does not exist in context
var secondExample = $"Something {{9}}"; // '9' is escaped when it should not be
```

### Bugs this fixes
#23536 

### Workarounds, if any
Escape the braces manually in the string literal(s) before or after applying the refactoring.

### Risk
The scope of the fix is limited to this specific refactoring.

### Performance impact
Low, the fix only adds two extra string operations (which are only executed if necessary).

### Is this a regression from a previous update?
I don't know.

### Root cause analysis
This specific situation was not covered by unit tests yet. I added these tests now.

### How was the bug found?
Customer reported, see #23536.

### Test documentation updated?
No impact on test documentation.</Description>
    <CreatedDate>05/12/2017</CreatedDate>
    <ClosedDate>09/05/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>23536</IssueID>
        <Title>The "Convert to interpolated string" automated refactoring does not escape curly braces</Title>
        <Description>The refactoring &amp;quot;Convert to interpolated string&amp;quot; does not escape the exisiting curly braces when converting concatenated strings.

Eg. the statements
int number = 9;
string test1 = &amp;quot;Something {X} = &amp;quot; + number;
string test2 = &amp;quot;Something {&amp;quot; + number + &amp;quot;}&amp;quot;;
become
int number = 9;
string test1 = $&amp;quot;Something {X} = {number}&amp;quot;;
string test2 = $&amp;quot;Something {{number}}&amp;quot;;

The correctly converted strings are:
string test1 = $&amp;quot;Something {{X}} = {number}&amp;quot;;
string test2 = $&amp;quot;Something {{{number}}}&amp;quot;;

_This issue has been moved from https://developercommunity.visualstudio.com/content/problem/157181/the-convert-to-interpolated-string-automated-refac.html
VSTS ticketId: 530431_
_These are the original issue comments:_
(no comments)
_These are the original issue solutions:_
(no solutions)</Description>
        <CreatedDate>03/12/2017</CreatedDate>
        <ClosedDate>09/05/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23536</IssueID>
        <Title>The "Convert to interpolated string" automated refactoring does not escape curly braces</Title>
        <Description>The refactoring &amp;quot;Convert to interpolated string&amp;quot; does not escape the exisiting curly braces when converting concatenated strings.

Eg. the statements
int number = 9;
string test1 = &amp;quot;Something {X} = &amp;quot; + number;
string test2 = &amp;quot;Something {&amp;quot; + number + &amp;quot;}&amp;quot;;
become
int number = 9;
string test1 = $&amp;quot;Something {X} = {number}&amp;quot;;
string test2 = $&amp;quot;Something {{number}}&amp;quot;;

The correctly converted strings are:
string test1 = $&amp;quot;Something {{X}} = {number}&amp;quot;;
string test2 = $&amp;quot;Something {{{number}}}&amp;quot;;

_This issue has been moved from https://developercommunity.visualstudio.com/content/problem/157181/the-convert-to-interpolated-string-automated-refac.html
VSTS ticketId: 530431_
_These are the original issue comments:_
(no comments)
_These are the original issue solutions:_
(no solutions)</Description>
        <CreatedDate>03/12/2017</CreatedDate>
        <ClosedDate>09/05/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/ConvertToInterpolatedString/ConvertConcatenationToInterpolatedStringTests.cs</File>
      <File>src/Features/Core/Portable/ConvertToInterpolatedString/AbstractConvertConcatenationToInterpolatedStringRefactoringProvider.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>22673</IssueID>
    <Title>Tuple support for DeclarationNameCompletionProvider (name suggestion)</Title>
    <Description>(note from jcouv: Merge, do not squash this PR, as it includes merge commits from master)

**Customer scenario**

Suggested names support for tuples. 

**Bugs this fixes:**

#22342 (Kind of)

**Workarounds, if any**

No. Feature improvement.

**Risk**

Name suggestion might be triggered in inappropriate circumstances.

**Performance impact**

Editor performance and memory critical.

**Is this a regression from a previous update?**

No. Feature improvement.

**Root cause analysis:**

Tuple support was missing.

**How was the bug found?**

Found by investigating #22342. #22342 reports a (very) special case but more general cases were missing too.

**Test documentation updated?**

No

**Remarks**

It seems [DeclarationNameCompletionProvider](http://source.roslyn.codeplex.com/#Microsoft.CodeAnalysis.CSharp.Features/Completion/CompletionProviders/DeclarationNameCompletionProvider.DeclarationInfo.cs,51) does not handle tuples at all. In the following example none of the occurrence of `name`, `action` and `accessViolationException` is suggested):

```CSharp
static void Main(string[] args)
{
    (Array array, Action action) Test((Array array, AccessViolationException accessViolationException) tuple) =&gt; default;
    (var array, var action) = Test((null, null));
}
```

#22342 suggested that there is support for tuples but there isn't (Just typing `(Array ` suggest *array* because it triggers `IsPossibleVariableOrLocalMethodDeclaration`.).

This PR adds support for the cases above (except `(var array, var action)`).

`TupleElementDefinition1` to `TupleElementDefinition7` test the new tuple support. The remaining two tests fail because 

1. `TupleElementTypeInference` I couldn't get the typeInference to work and 
2. `TupleElementInGenericTypeArgument` The expression tree generated by the code of #22342 `System.Func&lt;(System.Action $$` has nothing to do with tuples at all (combination of LessThan and Parenthesized expression). It's questionable if this really should be supported.

I hardly understand what my call to `IsLastTokenOfType` does. It gives the desired result but reviewers should take a close look whether that call is appropriate.</Description>
    <CreatedDate>12/10/2017</CreatedDate>
    <ClosedDate>25/05/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>22342</IssueID>
        <Title>Suggested names not provided for tuple elements in generic type arguments</Title>
        <Description>**Version Used**: 15.4 Preview 2

**Steps to Reproduce**:

1. Type the following as a local variable declaration

    ```csharp
    Func&lt;(Task task, CancellationToken cancellationToken), Task&gt; funcAsync;
    ```

**Expected Behavior**:

A suggested name is provided for `task` and `cancellationToken`.

**Actual Behavior**:

Suggested names are not provided.

:memo: Note that if you declare a local variable of a tuple type which is *not* a generic type argument, tuple names are provided.</Description>
        <CreatedDate>26/09/2017</CreatedDate>
        <ClosedDate>25/05/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22342</IssueID>
        <Title>Suggested names not provided for tuple elements in generic type arguments</Title>
        <Description>**Version Used**: 15.4 Preview 2

**Steps to Reproduce**:

1. Type the following as a local variable declaration

    ```csharp
    Func&lt;(Task task, CancellationToken cancellationToken), Task&gt; funcAsync;
    ```

**Expected Behavior**:

A suggested name is provided for `task` and `cancellationToken`.

**Actual Behavior**:

Suggested names are not provided.

:memo: Note that if you declare a local variable of a tuple type which is *not* a generic type argument, tuple names are provided.</Description>
        <CreatedDate>26/09/2017</CreatedDate>
        <ClosedDate>25/05/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22342</IssueID>
        <Title>Suggested names not provided for tuple elements in generic type arguments</Title>
        <Description>**Version Used**: 15.4 Preview 2

**Steps to Reproduce**:

1. Type the following as a local variable declaration

    ```csharp
    Func&lt;(Task task, CancellationToken cancellationToken), Task&gt; funcAsync;
    ```

**Expected Behavior**:

A suggested name is provided for `task` and `cancellationToken`.

**Actual Behavior**:

Suggested names are not provided.

:memo: Note that if you declare a local variable of a tuple type which is *not* a generic type argument, tuple names are provided.</Description>
        <CreatedDate>26/09/2017</CreatedDate>
        <ClosedDate>25/05/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22342</IssueID>
        <Title>Suggested names not provided for tuple elements in generic type arguments</Title>
        <Description>**Version Used**: 15.4 Preview 2

**Steps to Reproduce**:

1. Type the following as a local variable declaration

    ```csharp
    Func&lt;(Task task, CancellationToken cancellationToken), Task&gt; funcAsync;
    ```

**Expected Behavior**:

A suggested name is provided for `task` and `cancellationToken`.

**Actual Behavior**:

Suggested names are not provided.

:memo: Note that if you declare a local variable of a tuple type which is *not* a generic type argument, tuple names are provided.</Description>
        <CreatedDate>26/09/2017</CreatedDate>
        <ClosedDate>25/05/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22342</IssueID>
        <Title>Suggested names not provided for tuple elements in generic type arguments</Title>
        <Description>**Version Used**: 15.4 Preview 2

**Steps to Reproduce**:

1. Type the following as a local variable declaration

    ```csharp
    Func&lt;(Task task, CancellationToken cancellationToken), Task&gt; funcAsync;
    ```

**Expected Behavior**:

A suggested name is provided for `task` and `cancellationToken`.

**Actual Behavior**:

Suggested names are not provided.

:memo: Note that if you declare a local variable of a tuple type which is *not* a generic type argument, tuple names are provided.</Description>
        <CreatedDate>26/09/2017</CreatedDate>
        <ClosedDate>25/05/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/Completion/CompletionProviders/DeclarationNameCompletionProviderTests.cs</File>
      <File>src/Features/CSharp/Portable/Completion/CompletionProviders/DeclarationNameCompletionProvider.DeclarationInfo.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>26265</IssueID>
    <Title>Fix race condition in SolutionExplorer_InProc.OpenFile</Title>
    <Description>This change updates the code to use `ProjectItem.Open` instead of relying on the asynchronous File Open command. Prior to the change, the method would occasionally return early, allowing the caller to modify the previous active document before the newly opened document was fully activated.

Fixes #19191
Fixes #26037
Closes #26205</Description>
    <CreatedDate>19/04/2018</CreatedDate>
    <ClosedDate>20/04/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>19191</IssueID>
        <Title>Roslyn.VisualStudio.IntegrationTests.CSharp.CSharpWinForms.ChangeControlProperty [FAIL]</Title>
        <Description>https://ci.dot.net/job/dotnet_roslyn/job/master/job/windows_debug_vs-integration_prtest/3606/consoleFull#6464135312d31e50d-1517-49fc-92b3-2ca637122019

```
Roslyn.VisualStudio.IntegrationTests.CSharp.CSharpWinForms.ChangeControlProperty
      Assert.Contains() Failure
      Not found: this.SomeButton.Text = "NewButtonText"
      In value:  namespace TestProj
      {
          partial class Form1
          {
              /// &lt;summary&gt;
              /// Required designer variable.
              /// &lt;/summary&gt;
              private System.ComponentModel.IContainer components = null;
      
              /// &lt;summary&gt;
              /// Clean up any resources being used.
              /// &lt;/summary&gt;
              /// &lt;param name="disposing"&gt;true if managed resources should be disposed; otherwise, false.&lt;/param&gt;
              protected override void Dispose(bool disposing)
              {
                  if (disposing &amp;&amp; (components != null))
                  {
                      components.Dispose();
                  }
                  base.Dispose(disposing);
              }
      
              #region Windows Form Designer generated code
      
              /// &lt;summary&gt;
              /// Required method for Designer support - do not modify
              /// the contents of this method with the code editor.
              /// &lt;/summary&gt;
              private void InitializeComponent()
              {
                  this.components = new System.ComponentModel.Container();
                  this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
                  this.Text = "Form1";
              }
      
              #endregion
          }
      }
      
      
      Stack Trace:
        q:\roslyn\src\VisualStudio\IntegrationTest\IntegrationTests\CSharp\CSharpWinForms.cs(44,0): at Roslyn.VisualStudio.IntegrationTests.CSharp.CSharpWinForms.ChangeControlProperty()
    Roslyn.VisualStudio.IntegrationTests.CSharp.CSharpWinForms.RemoveEventHandler
    Roslyn.VisualStudio.IntegrationTests.CSharp.CSharpWinForms.ChangeControlPropertyInCode
      Assert.Contains() Failure
      Not found: this.SomeButton.Text = "ButtonTextGoesHere";
      In value:  namespace TestProj
      {
          partial class Form1
          {
              /// &lt;summary&gt;
              /// Required designer variable.
              /// &lt;/summary&gt;
              private System.ComponentModel.IContainer components = null;
      
              /// &lt;summary&gt;
              /// Clean up any resources being used.
              /// &lt;/summary&gt;
              /// &lt;param name="disposing"&gt;true if managed resources should be disposed; otherwise, false.&lt;/param&gt;
              protected override void Dispose(bool disposing)
              {
                  if (disposing &amp;&amp; (components != null))
                  {
                      components.Dispose();
                  }
                  base.Dispose(disposing);
              }
      
              #region Windows Form Designer generated code
      
              /// &lt;summary&gt;
              /// Required method for Designer support - do not modify
              /// the contents of this method with the code editor.
              /// &lt;/summary&gt;
              private void InitializeComponent()
              {
                  this.components = new System.ComponentModel.Container();
                  this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
                  this.Text = "Form1";
              }
      
              #endregion
          }
      }
      
      
      Stack Trace:
        q:\roslyn\src\VisualStudio\IntegrationTest\IntegrationTests\CSharp\CSharpWinForms.cs(62,0): at Roslyn.VisualStudio.IntegrationTests.CSharp.CSharpWinForms.ChangeControlPropertyInCode()
```</Description>
        <CreatedDate>02/05/2017</CreatedDate>
        <ClosedDate>20/04/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>26037</IssueID>
        <Title>Light bulb never appears in integration test</Title>
        <Description>Example:

https://ci.dot.net/job/dotnet_roslyn/job/dev15.7.x/job/windows_release_vs-integration_prtest/356/

```
System.InvalidOperationException: Expected a light bulb session to appear.

Server stack trace: 
   at Microsoft.VisualStudio.IntegrationTest.Utilities.LightBulbHelper.&lt;&gt;c__DisplayClass0_0.&lt;&lt;WaitForLightBulbSessionAsync&gt;b__0&gt;d.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Microsoft.VisualStudio.IntegrationTest.Utilities.Helper.&lt;&gt;c__DisplayClass7_0`1.&lt;&lt;RetryAsync&gt;b__0&gt;d.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Microsoft.VisualStudio.IntegrationTest.Utilities.Helper.&lt;RetryAsyncHelper&gt;d__10`1.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Microsoft.VisualStudio.IntegrationTest.Utilities.InProcess.TextViewWindow_InProc.&lt;&lt;WaitForLightBulbSession&gt;b__3_0&gt;d.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Microsoft.VisualStudio.Threading.JoinableTask.CompleteOnCurrentThread()
   at Microsoft.VisualStudio.IntegrationTest.Utilities.InProcess.TextViewWindow_InProc.WaitForLightBulbSession()
   at System.Runtime.Remoting.Messaging.StackBuilderSink._PrivateProcessMessage(IntPtr md, Object[] args, Object server, Object[]&amp; outArgs)
   at System.Runtime.Remoting.Messaging.StackBuilderSink.SyncProcessMessage(IMessage msg)

Exception rethrown at [0]: 
   at System.Runtime.Remoting.Proxies.RealProxy.HandleReturnMessage(IMessage reqMsg, IMessage retMsg).GetType().Name

Server stack trace: 
   at Microsoft.VisualStudio.IntegrationTest.Utilities.LightBulbHelper.&lt;&gt;c__DisplayClass0_0.&lt;&lt;WaitForLightBulbSessionAsync&gt;b__0&gt;d.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Microsoft.VisualStudio.IntegrationTest.Utilities.Helper.&lt;&gt;c__DisplayClass7_0`1.&lt;&lt;RetryAsync&gt;b__0&gt;d.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Microsoft.VisualStudio.IntegrationTest.Utilities.Helper.&lt;RetryAsyncHelper&gt;d__10`1.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Microsoft.VisualStudio.IntegrationTest.Utilities.InProcess.TextViewWindow_InProc.&lt;&lt;WaitForLightBulbSession&gt;b__3_0&gt;d.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Microsoft.VisualStudio.Threading.JoinableTask.CompleteOnCurrentThread()
   at Microsoft.VisualStudio.IntegrationTest.Utilities.InProcess.TextViewWindow_InProc.WaitForLightBulbSession()
   at System.Runtime.Remoting.Messaging.StackBuilderSink._PrivateProcessMessage(IntPtr md, Object[] args, Object server, Object[]&amp; outArgs)
   at System.Runtime.Remoting.Messaging.StackBuilderSink.SyncProcessMessage(IMessage msg)

Exception rethrown at [0]: 
   at System.Runtime.Remoting.Proxies.RealProxy.HandleReturnMessage(IMessage reqMsg, IMessage retMsg)
```

Based on the screenshot at the time of the failure, this appears to be caused by a failure to correctly initialize the document text:

![image](https://user-images.githubusercontent.com/1408396/38522799-4ce551c4-3c0f-11e8-8d7f-390992fe6e6b.png)
</Description>
        <CreatedDate>09/04/2018</CreatedDate>
        <ClosedDate>20/04/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>26205</IssueID>
        <Title>CSharpToBasic test has recurring failure</Title>
        <Description>Skipping because of recurring failure:
master/job/windows_release_vs-integration/53/testReport/junit/Roslyn.VisualStudio.IntegrationTests.CSharp/CSharpGenerateTypeDialog/CSharpToBasic/</Description>
        <CreatedDate>17/04/2018</CreatedDate>
        <ClosedDate>20/04/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/VisualStudio/IntegrationTest/IntegrationTests/CSharp/CSharpWinForms.cs</File>
      <File>src/VisualStudio/IntegrationTest/IntegrationTests/VisualBasic/BasicWinForms.cs</File>
      <File>src/VisualStudio/IntegrationTest/TestUtilities/InProcess/SolutionExplorer_InProc.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>25963</IssueID>
    <Title>recursive-patterns(17) Improvements when switching on a tuple</Title>
    <Description>This PR is a set of changes intended to improve things for pattern-matching operations on tuples:

- https://github.com/dotnet/roslyn/commit/2f117a4defc3328fa040f194a257c646bbcf8250 Adds a code quality test for switching on a tuple literal. The test exposed some parsing precedence issues for the switch expression which are fixed here. The `=&gt;` following the when clause was being consumed as part of the when expression (as a lambda). Changed the precedence of the when expression to a coalescing expression to forbid a lambda there.
- https://github.com/dotnet/roslyn/commit/ab7a2446cc81bec755fe347d998536690fb8c29f Fixes a bug in the semantic model for switch expressions.
- https://github.com/dotnet/roslyn/commit/cec28aa3bb430ea71cca348fb13129d5faf3ab54 Refactoring some code in preparation for subsequent changes.
- https://github.com/dotnet/roslyn/commit/c15d849a43794a36da5f8af1b4e20bccb05e6896 Introduce BoundPatternBinding rather than using a tuple. Also move the implementation of the is-pattern operator to its own source file.
- https://github.com/dotnet/roslyn/commit/c0953a4ea0387dcc12a7d035fc124858ff919dc9 Refactor the decision dag rewriter so we can reuse it for handling tuples in a subsequent iteration.
- https://github.com/dotnet/roslyn/commit/4fbf77ebb2dabf1e686d9384fd68c21af3c0fa1b Add instrumentation for the switch statement's when clause. This was dropped in a previous PR when we dropped the old lowering code.
- https://github.com/dotnet/roslyn/commit/662deba9748ff71469cb2d960a4a9c4a7a4ed04e Fix the diagnostic argument for "wrong number of subpatterns". This fixes a crash during LDM demo.
- https://github.com/dotnet/roslyn/commit/8b8bc93abc3759cdea5cbe051341701a0e6fe895 Optimizes switch on a tuple literal by saving the elements of the tuple literal and not constructing a tuple object. Fixes #20641
- https://github.com/dotnet/roslyn/commit/170b511b6a147efa1da16dcd4dbfdbb993149914 Permit switching on a tuple literal without redundant parentheses. Fixes dotnet/csharplang#1395 . The syntax change is currently under compat council review.
- https://github.com/dotnet/roslyn/commit/95a9bd8dabdd9580f84ce83eaecde915c3321208 Bind and check the optional "named argument" style names in positional (tuple) patterns. Fixes #25934

@agocke @cston Please review these pattern-matching changes. You might find it easier to do iteration by iteration. I will be happy to do a co-review by Skype or over-the-shoulder if it is easier for you.
@dotnet/roslyn-compiler Additional review most welcome
@dotnet/roslyn-ide Can you suggest additional IDE tests for the changes in https://github.com/dotnet/roslyn/commit/170b511b6a147efa1da16dcd4dbfdbb993149914 ?

Question for reviewers: would you have preferred that I submit a separate PR for each of these changes?
</Description>
    <CreatedDate>05/04/2018</CreatedDate>
    <ClosedDate>11/04/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>20641</IssueID>
        <Title>Pattern matching IL much larger than non-pattern matching equivalent</Title>
        <Description>**Version Used**:
2.3.0.61814 (b7f611db)

**Steps to Reproduce**:
Compile the following program:
```C#
using System.Collections;
using System.Collections.Generic;

class Program
{
    static void Main() { }

    internal static bool TryGetCount1&lt;T&gt;(IEnumerable&lt;T&gt; source, out int count)
    {
        ICollection nonGeneric = source as ICollection;
        if (nonGeneric != null)
        {
            count = nonGeneric.Count;
            return true;
        }

        ICollection&lt;T&gt; generic = source as ICollection&lt;T&gt;;
        if (generic != null)
        {
            count = generic.Count;
            return true;
        }

        count = -1;
        return false;
    }

    internal static bool TryGetCount2&lt;T&gt;(IEnumerable&lt;T&gt; source, out int count)
    {
        switch (source)
        {
            case ICollection nonGeneric:
                count = nonGeneric.Count;
                return true;

            case ICollection&lt;T&gt; generic:
                count = generic.Count;
                return true;

            default:
                count = -1;
                return false;
        }
    }
}
```

**Expected Behavior**:
The IL for TryGetCount1 and TryGetCount2 would be close to identical.

**Actual Behavior**:
The IL for TryGetCount2 is ~28% larger than that for TryGetCount1.
```
.method assembly hidebysig static bool  TryGetCount1&lt;T&gt;(class [mscorlib]System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source,
                                                        [out] int32&amp; count) cil managed
{
  // Code size       45 (0x2d)
  .maxstack  2
  .locals init ([0] class [mscorlib]System.Collections.ICollection nonGeneric,
           [1] class [mscorlib]System.Collections.Generic.ICollection`1&lt;!!T&gt; generic)
  IL_0000:  ldarg.0
  IL_0001:  isinst     [mscorlib]System.Collections.ICollection
  IL_0006:  stloc.0
  IL_0007:  ldloc.0
  IL_0008:  brfalse.s  IL_0014
  IL_000a:  ldarg.1
  IL_000b:  ldloc.0
  IL_000c:  callvirt   instance int32 [mscorlib]System.Collections.ICollection::get_Count()
  IL_0011:  stind.i4
  IL_0012:  ldc.i4.1
  IL_0013:  ret
  IL_0014:  ldarg.0
  IL_0015:  isinst     class [mscorlib]System.Collections.Generic.ICollection`1&lt;!!T&gt;
  IL_001a:  stloc.1
  IL_001b:  ldloc.1
  IL_001c:  brfalse.s  IL_0028
  IL_001e:  ldarg.1
  IL_001f:  ldloc.1
  IL_0020:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.ICollection`1&lt;!!T&gt;::get_Count()
  IL_0025:  stind.i4
  IL_0026:  ldc.i4.1
  IL_0027:  ret
  IL_0028:  ldarg.1
  IL_0029:  ldc.i4.m1
  IL_002a:  stind.i4
  IL_002b:  ldc.i4.0
  IL_002c:  ret
} // end of method Program::TryGetCount1
```
and
```
.method assembly hidebysig static bool  TryGetCount2&lt;T&gt;(class [mscorlib]System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source,
                                                        [out] int32&amp; count) cil managed
{
  // Code size       58 (0x3a)
  .maxstack  2
  .locals init ([0] class [mscorlib]System.Collections.Generic.IEnumerable`1&lt;!!T&gt; V_0,
           [1] class [mscorlib]System.Collections.ICollection V_1,
           [2] class [mscorlib]System.Collections.Generic.ICollection`1&lt;!!T&gt; V_2,
           [3] class [mscorlib]System.Collections.ICollection nonGeneric,
           [4] class [mscorlib]System.Collections.Generic.ICollection`1&lt;!!T&gt; generic)
  IL_0000:  ldarg.0
  IL_0001:  stloc.0
  IL_0002:  ldloc.0
  IL_0003:  brfalse.s  IL_0035
  IL_0005:  ldloc.0
  IL_0006:  isinst     [mscorlib]System.Collections.ICollection
  IL_000b:  dup
  IL_000c:  stloc.1
  IL_000d:  brtrue.s   IL_001b
  IL_000f:  ldloc.0
  IL_0010:  isinst     class [mscorlib]System.Collections.Generic.ICollection`1&lt;!!T&gt;
  IL_0015:  dup
  IL_0016:  stloc.2
  IL_0017:  brfalse.s  IL_0035
  IL_0019:  br.s       IL_0027
  IL_001b:  ldloc.1
  IL_001c:  stloc.3
  IL_001d:  ldarg.1
  IL_001e:  ldloc.3
  IL_001f:  callvirt   instance int32 [mscorlib]System.Collections.ICollection::get_Count()
  IL_0024:  stind.i4
  IL_0025:  ldc.i4.1
  IL_0026:  ret
  IL_0027:  ldloc.2
  IL_0028:  stloc.s    generic
  IL_002a:  ldarg.1
  IL_002b:  ldloc.s    generic
  IL_002d:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.ICollection`1&lt;!!T&gt;::get_Count()
  IL_0032:  stind.i4
  IL_0033:  ldc.i4.1
  IL_0034:  ret
  IL_0035:  ldarg.1
  IL_0036:  ldc.i4.m1
  IL_0037:  stind.i4
  IL_0038:  ldc.i4.0
  IL_0039:  ret
} // end of method Program::TryGetCount2
```</Description>
        <CreatedDate>05/07/2017</CreatedDate>
        <ClosedDate>30/03/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>1395</IssueID>
        <Title>Fix memory leaks in AnalyzerManager</Title>
        <Description>1) Statically created LocalizableString instances by analyzers were holding onto instances of AnalyzerExecutor (which holds onto the compilation on which it executes) for exception reporting, causing us to leak compilations in command line builds. Fixed this by making sure that we unregister these exception handlers during analyzer cleanup in CommonCompiler, we already did so for VisualStudioAnalyzer created in IDE.

2) Switch AnalyzerManager._compilationScopeMap to have a ConditonalWeakTable value. Performance analysis showed that analyzers that capture the CompilationStartAnalysisContext in its RegisterCompilationStartAction via some lambda were rooting the compilation objects.

Above two changes got rid of all the static and dependent handles rooting compilations during command line builds, and I see a perceived reduction in memory used by VBCSCompiler during building Roslyn.

3) Fix the IDE onAnalyzerException delegate to not capture project instance, but instead use the projectId. Otherwise, VSIX analyzers that live for lifetime of VS instance would leak compilations.

While I was at it, I also got rid of functionality added to MetadataCache that was caching and re-using analyzer instances across AnalyzerFileReference instances, we had already decided to instead keep lifetime of analyzer instances bound by lifetime of owning AnalyzerFileReference.

@heejaechang @tmeschter @pharring @srivatsn @JohnHamby can you please review?
</Description>
        <CreatedDate>19/03/2015</CreatedDate>
        <ClosedDate>20/03/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>25934</IssueID>
        <Title>Compiler ignores tuple element names in positional patterns.</Title>
        <Description>The following code compiles without error. It should be an error, because c and d are not defined as elements of the input tuple:

``` c#
        switch ((a: 1, b: 2))
        {
            case (c: 2, d: 3):
                break;
        }
```
</Description>
        <CreatedDate>04/04/2018</CreatedDate>
        <ClosedDate>11/04/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Patterns.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/DecisionDagBuilder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/PatternSwitchBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/SwitchExpressionBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/BoundDagEvaluation.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/BoundDagTemp.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/BoundDecisionDag.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/BoundPatternBinding.cs</File>
      <File>src/Compilers/CSharp/Portable/CSharpResources.Designer.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/MemberSemanticModel.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/ErrorCode.cs</File>
      <File>src/Compilers/CSharp/Portable/Generated/BoundNodes.xml.Generated.cs</File>
      <File>src/Compilers/CSharp/Portable/Generated/Syntax.xml.Internal.Generated.cs</File>
      <File>src/Compilers/CSharp/Portable/Generated/Syntax.xml.Main.Generated.cs</File>
      <File>src/Compilers/CSharp/Portable/Generated/Syntax.xml.Syntax.Generated.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/Instrumentation/DebugInfoInjector.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_BasePatternSwitchLocalRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_IsPatternOperator.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_PatternSwitchStatement.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_Patterns.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_SwitchExpression.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/LanguageParser.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/LanguageParser_Patterns.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/PatternTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/SwitchTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Emit/EditAndContinue/LocalSlotMappingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/PDB/PDBLambdaTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/PDB/PDBLocalFunctionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/PDB/PDBTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests2.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/MissingSpecialMember.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Generated/Syntax.Test.xml.Generated.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/StatementParsingTests.cs</File>
      <File>src/Features/CSharp/Portable/EditAndContinue/BreakpointSpans.cs</File>
      <File>src/Features/CSharp/Portable/EditAndContinue/CSharpEditAndContinueAnalyzer.cs</File>
      <File>src/Features/CSharp/Portable/Structure/Providers/SwitchStatementStructureProvider.cs</File>
      <File>src/Workspaces/CSharp/Portable/CodeGeneration/CSharpSyntaxGenerator.cs</File>
      <File>src/Workspaces/CSharp/Portable/Extensions/SyntaxNodeExtensions.cs</File>
      <File>src/Workspaces/CSharpTest/CodeGeneration/SyntaxGeneratorTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>25917</IssueID>
    <Title>Mark lambda conversions as side-affecting</Title>
    <Description>### Customer scenario

The scenario listed in #22700 demonstrates the problem. The direct cause
of the crash is that local lowering produces two instances of the lambda and 
lamda conversions in the resulting bound nodes. This crashes the closure 
conversion pass since the same lambda cannot appear in two places in the tree. 
However, even if that were allowed, this would violate the language
specification.

Placing a lambda inside an indexer which is nested in a compound
assignment creates two calls which contain the delegate produced by the
lambda expression. Since the delegate produced by the conversion can be 
compared by-reference to any other delegate produced by the same lambda, 
the code must be referentially transparent -- it must produce the same result
when evaluated repeatedly. This could be achieved by spilling the evaluation 
result into a temporary. However, the local lowering only spills if the expression
is side-affecting (which lambda conversions are not), when what it actually
needs is for the expression to be referentially transparent.

The fix is small: mark lambda conversions as side-affecting. There are
certain cases, like the creation of temporaries for out-of-order calls
with named parameters, where the lambda conversion is only required to
be non-side-affecting instead of referentially transparent, but it does
not currently seem worth the implementation effort to split up the code
path.

### Bugs this fixes

#22700

### Workarounds, if any

Manually spill the conversion into a local variable. 

### Risk

Very small, focused change. Introduces a temp, so this is more conservative than alternatives.

### Performance impact

None. No significant amount of new code.

### Is this a regression from a previous update?

No.

### Root cause analysis

Very rare scenario with very little use in the real world.

### How was the bug found?

Customer reported
</Description>
    <CreatedDate>04/04/2018</CreatedDate>
    <ClosedDate>05/04/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>22700</IssueID>
        <Title>ArgumentException (duplicate key) in VisitLambdaOrFunction when using `+=` on an indexer with a lambda argument</Title>
        <Description>**Version Used**:  2.3.2

**Steps to Reproduce**:
```csharp
using System;

public class Test {
    public void M() {
        this[() =&gt; 0] += 1;
    }
    
    public int this[Func&lt;int&gt; f] {
        get { return 0; }
        set {}
    }
}
```
https://sharplab.io/#v2:D4AQDABCCMDcCwAoJIDMUBMEAqBTAzgC4QDeSEFU6IALBALIAUAlKeZR4QBYCW+A2iwgBeAHwQwAXQgBqYRDjsKAXyUQ1aCDwB2xbn34gArAB4dhcQDNpZRBw4BzXMRJQA7BNgRVd+xXzOpD4cPspAA=

**Expected Behavior**:
Code is compiled correctly.

**Actual Behavior**:
```
System.ArgumentException: An item with the same key has already been added.
   at System.ThrowHelper.ThrowArgumentException(ExceptionResource resource)
   at System.Collections.Generic.Dictionary`2.Insert(TKey key, TValue value, Boolean add)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.Analysis.VisitLambdaOrFunction(IBoundLambdaOrFunction node)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.Analysis.VisitLambda(BoundLambda node)
   at Microsoft.CodeAnalysis.CSharp.BoundLambda.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalkerWithStackGuard.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalkerWithStackGuard.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalker.VisitConversion(BoundConversion node)
   at Microsoft.CodeAnalysis.CSharp.BoundConversion.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalkerWithStackGuard.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalkerWithStackGuard.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalker.VisitList[T](ImmutableArray`1 list)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalker.VisitCall(BoundCall node)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.Analysis.VisitCall(BoundCall node)
   at Microsoft.CodeAnalysis.CSharp.BoundCall.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalkerWithStackGuard.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalkerWithStackGuard.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalker.VisitBinaryOperator(BoundBinaryOperator node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalkerWithStackGuardWithoutRecursionOnTheLeftOfBinaryOperator.VisitBinaryOperator(BoundBinaryOperator node)
   at Microsoft.CodeAnalysis.CSharp.BoundBinaryOperator.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalkerWithStackGuard.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalkerWithStackGuard.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalker.VisitList[T](ImmutableArray`1 list)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalker.VisitCall(BoundCall node)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.Analysis.VisitCall(BoundCall node)
   at Microsoft.CodeAnalysis.CSharp.BoundCall.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalkerWithStackGuard.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalkerWithStackGuard.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalker.VisitExpressionStatement(BoundExpressionStatement node)
   at Microsoft.CodeAnalysis.CSharp.BoundExpressionStatement.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalkerWithStackGuard.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalker.VisitSequencePoint(BoundSequencePoint node)
   at Microsoft.CodeAnalysis.CSharp.BoundSequencePoint.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalkerWithStackGuard.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalker.VisitList[T](ImmutableArray`1 list)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.Analysis.VisitBlock(BoundBlock node)
   at Microsoft.CodeAnalysis.CSharp.BoundBlock.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalkerWithStackGuard.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.Analysis.Analyze(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.Rewrite(BoundStatement loweredBody, NamedTypeSymbol thisType, ParameterSymbol thisParameter, MethodSymbol method, Int32 methodOrdinal, MethodSymbol substitutedSourceMethod, ArrayBuilder`1 lambdaDebugInfoBuilder, ArrayBuilder`1 closureDebugInfoBuilder, VariableSlotAllocator slotAllocatorOpt, TypeCompilationState compilationState, DiagnosticBag diagnostics, HashSet`1 assignLocals)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.LowerBodyOrInitializer(MethodSymbol method, Int32 methodOrdinal, BoundStatement body, SynthesizedSubmissionFields previousSubmissionFields, TypeCompilationState compilationState, Boolean instrumentForDynamicAnalysis, DebugDocumentProvider debugDocumentProvider, ImmutableArray`1&amp; dynamicAnalysisSpans, DiagnosticBag diagnostics, VariableSlotAllocator&amp; lazyVariableSlotAllocator, ArrayBuilder`1 lambdaDebugInfoBuilder, ArrayBuilder`1 closureDebugInfoBuilder, StateMachineTypeSymbol&amp; stateMachineTypeOpt)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethod(MethodSymbol methodSymbol, Int32 methodOrdinal, ProcessedFieldInitializers&amp; processedInitializers, SynthesizedSubmissionFields previousSubmissionFields, TypeCompilationState compilationState)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(NamedTypeSymbol containingType)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.&lt;&gt;c__DisplayClass21_0.&lt;CompileNamedTypeAsTask&gt;b__0()
   at Roslyn.Utilities.UICultureUtilities.&lt;&gt;c__DisplayClass5_0.&lt;WithCurrentUICulture&gt;b__0()
   at System.Threading.Tasks.Task.InnerInvoke()
   at System.Threading.Tasks.Task.Execute()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.WaitForWorkers()
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethodBodies(CSharpCompilation compilation, PEModuleBuilder moduleBeingBuiltOpt, Boolean emittingPdb, Boolean emitTestCoverageData, Boolean hasDeclarationErrors, DiagnosticBag diagnostics, Predicate`1 filterOpt, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CompileMethods(CommonPEModuleBuilder moduleBuilder, Boolean emittingPdb, Boolean emitMetadataOnly, Boolean emitTestCoverageData, DiagnosticBag diagnostics, Predicate`1 filterOpt, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Compilation.Emit(Stream peStream, Stream metadataPEStream, Stream pdbStream, Stream xmlDocumentationStream, Stream win32Resources, IEnumerable`1 manifestResources, EmitOptions options, IMethodSymbol debugEntryPoint, Stream sourceLinkStream, IEnumerable`1 embeddedTexts, CompilationTestData testData, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Compilation.Emit(Stream peStream, Stream pdbStream, Stream xmlDocumentationStream, Stream win32Resources, IEnumerable`1 manifestResources, EmitOptions options, IMethodSymbol debugEntryPoint, Stream sourceLinkStream, IEnumerable`1 embeddedTexts, Stream metadataPEStream, CancellationToken cancellationToken)
```

Note that `master` has a different (but similar) error: `System.ArgumentException: adding a duplicate`.
See: https://sharplab.io/#v2:EYLgtghgzgLgpgJwD4AEAMACFBGA3AWACgiUBmLAJgwBU5YMBvIjFrclAFgwFkAKASkbNWImAAsAllADaAjAF4AfBjQBdDAGp5GPMJYBfPRiNkMEgHYwM4qdJQBWADwWYygGbqmhESIDmcKwYsAHYVXAxDbx8WKADGSJFI/SA===
</Description>
        <CreatedDate>15/10/2017</CreatedDate>
        <ClosedDate>06/04/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22700</IssueID>
        <Title>ArgumentException (duplicate key) in VisitLambdaOrFunction when using `+=` on an indexer with a lambda argument</Title>
        <Description>**Version Used**:  2.3.2

**Steps to Reproduce**:
```csharp
using System;

public class Test {
    public void M() {
        this[() =&gt; 0] += 1;
    }
    
    public int this[Func&lt;int&gt; f] {
        get { return 0; }
        set {}
    }
}
```
https://sharplab.io/#v2:D4AQDABCCMDcCwAoJIDMUBMEAqBTAzgC4QDeSEFU6IALBALIAUAlKeZR4QBYCW+A2iwgBeAHwQwAXQgBqYRDjsKAXyUQ1aCDwB2xbn34gArAB4dhcQDNpZRBw4BzXMRJQA7BNgRVd+xXzOpD4cPspAA=

**Expected Behavior**:
Code is compiled correctly.

**Actual Behavior**:
```
System.ArgumentException: An item with the same key has already been added.
   at System.ThrowHelper.ThrowArgumentException(ExceptionResource resource)
   at System.Collections.Generic.Dictionary`2.Insert(TKey key, TValue value, Boolean add)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.Analysis.VisitLambdaOrFunction(IBoundLambdaOrFunction node)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.Analysis.VisitLambda(BoundLambda node)
   at Microsoft.CodeAnalysis.CSharp.BoundLambda.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalkerWithStackGuard.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalkerWithStackGuard.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalker.VisitConversion(BoundConversion node)
   at Microsoft.CodeAnalysis.CSharp.BoundConversion.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalkerWithStackGuard.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalkerWithStackGuard.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalker.VisitList[T](ImmutableArray`1 list)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalker.VisitCall(BoundCall node)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.Analysis.VisitCall(BoundCall node)
   at Microsoft.CodeAnalysis.CSharp.BoundCall.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalkerWithStackGuard.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalkerWithStackGuard.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalker.VisitBinaryOperator(BoundBinaryOperator node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalkerWithStackGuardWithoutRecursionOnTheLeftOfBinaryOperator.VisitBinaryOperator(BoundBinaryOperator node)
   at Microsoft.CodeAnalysis.CSharp.BoundBinaryOperator.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalkerWithStackGuard.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalkerWithStackGuard.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalker.VisitList[T](ImmutableArray`1 list)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalker.VisitCall(BoundCall node)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.Analysis.VisitCall(BoundCall node)
   at Microsoft.CodeAnalysis.CSharp.BoundCall.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalkerWithStackGuard.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalkerWithStackGuard.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalker.VisitExpressionStatement(BoundExpressionStatement node)
   at Microsoft.CodeAnalysis.CSharp.BoundExpressionStatement.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalkerWithStackGuard.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalker.VisitSequencePoint(BoundSequencePoint node)
   at Microsoft.CodeAnalysis.CSharp.BoundSequencePoint.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalkerWithStackGuard.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalker.VisitList[T](ImmutableArray`1 list)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.Analysis.VisitBlock(BoundBlock node)
   at Microsoft.CodeAnalysis.CSharp.BoundBlock.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeWalkerWithStackGuard.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.Analysis.Analyze(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.Rewrite(BoundStatement loweredBody, NamedTypeSymbol thisType, ParameterSymbol thisParameter, MethodSymbol method, Int32 methodOrdinal, MethodSymbol substitutedSourceMethod, ArrayBuilder`1 lambdaDebugInfoBuilder, ArrayBuilder`1 closureDebugInfoBuilder, VariableSlotAllocator slotAllocatorOpt, TypeCompilationState compilationState, DiagnosticBag diagnostics, HashSet`1 assignLocals)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.LowerBodyOrInitializer(MethodSymbol method, Int32 methodOrdinal, BoundStatement body, SynthesizedSubmissionFields previousSubmissionFields, TypeCompilationState compilationState, Boolean instrumentForDynamicAnalysis, DebugDocumentProvider debugDocumentProvider, ImmutableArray`1&amp; dynamicAnalysisSpans, DiagnosticBag diagnostics, VariableSlotAllocator&amp; lazyVariableSlotAllocator, ArrayBuilder`1 lambdaDebugInfoBuilder, ArrayBuilder`1 closureDebugInfoBuilder, StateMachineTypeSymbol&amp; stateMachineTypeOpt)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethod(MethodSymbol methodSymbol, Int32 methodOrdinal, ProcessedFieldInitializers&amp; processedInitializers, SynthesizedSubmissionFields previousSubmissionFields, TypeCompilationState compilationState)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(NamedTypeSymbol containingType)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.&lt;&gt;c__DisplayClass21_0.&lt;CompileNamedTypeAsTask&gt;b__0()
   at Roslyn.Utilities.UICultureUtilities.&lt;&gt;c__DisplayClass5_0.&lt;WithCurrentUICulture&gt;b__0()
   at System.Threading.Tasks.Task.InnerInvoke()
   at System.Threading.Tasks.Task.Execute()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.WaitForWorkers()
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethodBodies(CSharpCompilation compilation, PEModuleBuilder moduleBeingBuiltOpt, Boolean emittingPdb, Boolean emitTestCoverageData, Boolean hasDeclarationErrors, DiagnosticBag diagnostics, Predicate`1 filterOpt, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CompileMethods(CommonPEModuleBuilder moduleBuilder, Boolean emittingPdb, Boolean emitMetadataOnly, Boolean emitTestCoverageData, DiagnosticBag diagnostics, Predicate`1 filterOpt, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Compilation.Emit(Stream peStream, Stream metadataPEStream, Stream pdbStream, Stream xmlDocumentationStream, Stream win32Resources, IEnumerable`1 manifestResources, EmitOptions options, IMethodSymbol debugEntryPoint, Stream sourceLinkStream, IEnumerable`1 embeddedTexts, CompilationTestData testData, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Compilation.Emit(Stream peStream, Stream pdbStream, Stream xmlDocumentationStream, Stream win32Resources, IEnumerable`1 manifestResources, EmitOptions options, IMethodSymbol debugEntryPoint, Stream sourceLinkStream, IEnumerable`1 embeddedTexts, Stream metadataPEStream, CancellationToken cancellationToken)
```

Note that `master` has a different (but similar) error: `System.ArgumentException: adding a duplicate`.
See: https://sharplab.io/#v2:EYLgtghgzgLgpgJwD4AEAMACFBGA3AWACgiUBmLAJgwBU5YMBvIjFrclAFgwFkAKASkbNWImAAsAllADaAjAF4AfBjQBdDAGp5GPMJYBfPRiNkMEgHYwM4qdJQBWADwWYygGbqmhESIDmcKwYsAHYVXAxDbx8WKADGSJFI/SA===
</Description>
        <CreatedDate>15/10/2017</CreatedDate>
        <ClosedDate>06/04/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_Call.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_CompoundAssignmentOperator.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenClosureLambdaTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenExprLambdaTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>25855</IssueID>
    <Title>Added tests for propagating escape errors through array elements</Title>
    <Description>Closes #25485
The bug was already fixed in #25819 
This PR just adds a test to close the bug.

cc @VSadov @dotnet/roslyn-compiler </Description>
    <CreatedDate>31/03/2018</CreatedDate>
    <ClosedDate>04/04/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>25485</IssueID>
        <Title>VS2017 crashes when parsing C#  Span code</Title>
        <Description>**Version Used**: 

Microsoft Visual Studio Enterprise 2017
Version 15.6.2

**Steps to Reproduce**:

1. Create a new Class Library (Classic Desktop) project
2. Add a NuGet package reference to System.Memory (4.5.x pre-release)
3. Modify Class1.cs to contain the following:

```csharp
using System;

namespace ClassLibrary1
{
    public class Class1
    {
        public void Foo(Thing[] first, Thing[] second)
        {
            var x = first[0];
        }
    }

    public struct Thing { }
}
```

4. On line 7, change the first `Thing[]` to `Span&lt;Thing&gt;[]`

**Expected Behavior**:

```error CS0611: Array elements cannot be of type 'Span&lt;Thing&gt;'```

**Actual Behavior**:

Entire Visual Studio IDE locks up and eventually crashes.

Exception:

```
System.InvalidOperationException
  HResult=0x80131509
  Message=Unexpected value 'ArrayAccess expression of System.Span&lt;ClassLibrary1.Thing&gt; type' of type 'System.String'
  Source=Microsoft.CodeAnalysis.CSharp
  StackTrace:
   at Microsoft.CodeAnalysis.CSharp.Binder.GetValEscape(BoundExpression expr, UInt32 scopeOfTheContainingExpression)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindVariableDeclaration(SourceLocalSymbol localSymbol, LocalDeclarationKind kind, Boolean isVar, VariableDeclaratorSyntax declarator, TypeSyntax typeSyntax, TypeSymbol declTypeOpt, AliasSymbol aliasOpt, DiagnosticBag diagnostics, CSharpSyntaxNode associatedSyntaxNode)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindDeclarationStatementParts(LocalDeclarationStatementSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.IncrementalBinder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLowerBoundNode(CSharpSyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node, CSharpSyntaxNode&amp; bindableNode, BoundNode&amp; lowestBoundNode, BoundNode&amp; highestBoundNode, BoundNode&amp; boundParent)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetSymbolInfoWorker(CSharpSyntaxNode node, SymbolInfoOptions options, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetSymbolInfoWorker(CSharpSyntaxNode node, SymbolInfoOptions options, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(ExpressionSyntax expression, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.ClassifyTypeSyntax(NameSyntax name, SemanticModel semanticModel, ArrayBuilder`1 result, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.AddClassifications(SyntaxNode syntax, SemanticModel semanticModel, ArrayBuilder`1 result, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.Worker.ClassifyNode(SyntaxNode syntax)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.Worker.ProcessNodes()
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.Worker.Classify(Workspace workspace, SemanticModel semanticModel, TextSpan textSpan, ArrayBuilder`1 list, Func`2 getNodeClassifiers, Func`2 getTokenClassifiers, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.&lt;AddSemanticClassificationsAsync&gt;d__5.MoveNext()
```</Description>
        <CreatedDate>15/03/2018</CreatedDate>
        <ClosedDate>04/04/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>25819</IssueID>
        <Title>Make escape analysis over unexpected nodes to return conservative results</Title>
        <Description>There are expressions for which ref-struct escape analysis does not make sense. Yet we keep finding ourselves in situations where we have to do it. Generally in error conditions.
So, instead of throwing "unreachable" we will return the most conservative results.

There is still an assert here so that if new bound nodes are added, there will be a chance to think whether there is a need for nontrivial handling of the node.

Fixes:#25398
Fixes:#25485
</Description>
        <CreatedDate>29/03/2018</CreatedDate>
        <ClosedDate>31/03/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/RefEscapingTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>25700</IssueID>
    <Title>"Generate Equals" should ignore indexers and setter-only properties</Title>
    <Description>fixes #25690 
fixes #25707</Description>
    <CreatedDate>24/03/2018</CreatedDate>
    <ClosedDate>14/04/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>25690</IssueID>
        <Title>"Generate Equals" refactorings produce non-compiling code when using indexers</Title>
        <Description>**Version Used**: VS 15.7 Preview 2 (Roslyn 2.8.0.62716, `e205ae18`)

**Steps to Reproduce**:

1. Copy the class below into a C# source file.
2. Invoke the Quick Fix menu at the marked location and select either "Generate Equals(object)…" or "Generate Equals and GetHashCode…".
3. Make sure the indexer "this[int]" is selected in the list. Press OK.

```c#
class Repro
{
	public int this[int index]
	{
		get =&gt; index;
	}
	$$
}
```

**Expected Behavior**: The generated methods are syntactically valid. (Although I don't know how one could use an indexer to implement Equals or GetHashCode.)

**Actual Behavior**: The generated code looks something like this, which is syntactically invalid:

```c#
public override bool Equals(object obj)
{
	var repro = obj as Repro;
	return repro != null &amp;&amp;
		this[] == repro.this[]; // Emits four compiler errors and one warning
}

public override int GetHashCode()
{
	return -529683855 + this[].GetHashCode(); // Emits one compiler error
}
```</Description>
        <CreatedDate>23/03/2018</CreatedDate>
        <ClosedDate>14/04/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>25707</IssueID>
        <Title>"Generate Equals" refactorings should not include set-only properties</Title>
        <Description>**Version Used**: VS 15.7 Preview 2 (Roslyn 2.8.0.62716)

**Steps to Reproduce**:

1. Copy the class below into a C# source file.
2. Invoke the Quick Fix menu at the marked location and select either "Generate Equals" or "Generate Equals and GetHashCode".
3. Make sure SetOnly is marked in the list and press "OK".

```c#
class Repro
{
	int SetOnly { set { } }
	$$
}
```

**Expected Behavior**: The property is not included in the list, and thus doesn't appear in the generated code.

**Actual Behavior**: The generated code looks something like this:

```c#
public override bool Equals(object obj)
{
	var repro = obj as Repro;
	return repro != null &amp;&amp;
		   this.SetOnly == repro.SetOnly; // Emits two CS0154 errors
}

public override int GetHashCode()
{
	return 257811045 + this.SetOnly.GetHashCode(); // Emits one CS0154 error
}
```</Description>
        <CreatedDate>25/03/2018</CreatedDate>
        <ClosedDate>14/04/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/GenerateFromMembers/GenerateConstructorFromMembers/GenerateConstructorFromMembersTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/GenerateFromMembers/GenerateEqualsAndGetHashCodeFromMembers/GenerateEqualsAndGetHashCodeFromMembersTests.cs</File>
      <File>src/Features/Core/Portable/GenerateEqualsAndGetHashCodeFromMembers/GenerateEqualsAndGetHashCodeFromMembersCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/GenerateFromMembers/AbstractGenerateFromMembersService.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>25680</IssueID>
    <Title>Follow up on unmanaged constraint</Title>
    <Description>* Closes #25261
* Closes remaining tests from #25139
 * Enables using local functions with `unmanaged` constraint</Description>
    <CreatedDate>23/03/2018</CreatedDate>
    <ClosedDate>03/04/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>25261</IssueID>
        <Title>Follow up on feeback on #24817</Title>
        <Description>@alekseyts left some feedback on #24817 after it was approved and merged.
Comments should be reviewed. This bugs tracks this for 15.7 so that it doesn't get lost.</Description>
        <CreatedDate>06/03/2018</CreatedDate>
        <ClosedDate>03/04/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>25139</IssueID>
        <Title>Testplan for new constraints.</Title>
        <Description>## Enum constraint ##

The feature removes restrictions on use of `System.Enum` in constraints. 

- [x] langver test.
- [x] constraint is enforced - rejects types that do not derive from `System.Enum`
- [x] constraint can be satisfied - allows enums, `System.Enum` itself and type parameters with `System.Enum` constraint.
- [x] can combine with `class` constraint. Only `System.Enum` satisfies.
(try also an enum, string, int, T:System.Enum)
- [x] can combine with `struct` constraint. Only actual enums and `T:struct, System.Enum` can satisfy. 
(try also an enum, string, int, System.Enum)
- [x] can combine with `new()` constraint. Same result as with `struct` since `System.Enum` has protected ctor.
- [x] test above scenarios via metadata. Not a new scenario, basically a check for metadata emit.
- [x] test constraints on a type parameter symbol (API)
- [x] symbol display test (another indirect test of symbol API) 
- [x] what is `System.Enum` is not available
- [x] bunch of OHI tests 
- [x] test VB

## Delegate/MulticastDelegate constraint ##

The feature removes restrictions on use of `System.Enum` in constraints.
 
- [x] langver test.
- [x] same as above really. Except the [Multicast]Delegate are regular classes and cannot be combined with `class`/`struct`.
- [x] Delegate does not satisfy MulticastDelegate. (just falls out from the inheritance, no new code here).

## `unmanaged` constraint ##

A "pseudo-constraint". It has meaning only in the C# typesystem. (CLR has no idea about it). 
Encapsulates the meaning of `unmanaged type` in the language with all it's quirks and possible future changes.

"unnmanaged" in C# is basically a quality of a type that allows it to be an element of a pointer type. The constraint simply propagates the notion through generics.

Currently type is unmanaged if 
- it is a regular (not generic/constructed) struct
- it has only unmanaged fields
- valuetype primitives and empty structs are unmanaged

We are adding a `T:unmanaged` to this set.

Note: `unmanaged` implies `struct.
Note: `unmanaged` is contextual - like `var`. If may bind to a type `unmanaged`, if such is in scope. 

The greatest risk is metadata representation since we are using some undocumented bits in the metadata. The purpose is that those who do not understand the constraint should not simply ignore it.  
We are using a `System.ValueType` constraint with `modreq(System.Runtime.InteropServices.UnmanagedType)`. 

### Testplan ###

- [x] langver
- [x] metadata tests
	- [x] "standard" set of synthesised/embedded attribute tests for `IsUnmanagedAttribute` 
	(used in addition to `modreq` to ease metadata parsing by 3rd party tools)
	- [x] errors when modreq type is missing or duplicated.
	(we do not synthesize `UnmanagedType`)
	- [x] `modreq` is copied to overrides (compilation/metadata references)
		- [x] virtual
		- [x] abstract
		- [x] interfaces
		- [x] lambdas
	- [x] metadata import 
		- [x] wellformed `unmanaged` form IL is accepted 
		- [x] `IsUnmanagdAttribute` is required 
		- [x] `IsUnmanagdAttribute` without modreq is also invalid (type is not supported error).
		- [x] `modopt` is not accepted
		- [x] unexpected `modreq` types are not accepted
		- [x] unmanaged + `new()`      
		- [x] unmanaged + `SomeType`  
		- [x] unmanaged + `class`  
		- [x] unmanaged without `struct`
	- [x] constraint on a type parameter of a type.    
- [x] lanaguage tests
	- [x] test that constraint is enforced on a method instantiation 
		(construct with managed/unmanaged structs, classes, int, unmanaged/ordinary generic typeparam)  
	- [x] test that constraint is enforced on a type instantiation 
		(construct with managed/unmanaged structs, classes, int, unmanaged/ordinary generic typeparam)
	- [x] test that constraint is enforced on a delegate instantiation 
		(construct with managed/unmanaged structs, classes, int, unmanaged/ordinary generic typeparam)
	- [x] not supported on local functions
	- [x] cannot be mixed with any other constraints (`class`, `struct`, `new`, `SomeType` before/after)
	- [x] pointer operations work with `unmanaged` constrained type params
	- [x] `sizeof` works with `unmanaged` constrained type params (primitives, structs)
	- [x] presence of a type named "unmanaged" - in scope/out of scope. 
	- [x] unmanaged implies `struct`
		- [x] can be passed to `T:struct` 
		- [x] to `T:SomeInterface`
		- [x] to `T:System.Enum`
		- [x] to `T:new()`
		- [x] not to `T:class` 
		- [x] not to `T:SomeClass` 
		- [x] cannot itself be used as a constraint
- [x] missing required types
	- [x] 'System.Runtime.InteropServices.UnmanagedType'
	- [x] 'System.ValueType'
-[x] validate symbol API  (`HasUnmanagedTypeConstraint`)
	- [x] on a method type param
	- [x] on a type type param
- [x] bunch of OHI tests 
- [x] validate our metadata encoding scheme with various languages/tools/runtimes. 
(C++ fixed a crash, otherwise ok)
- [x] test with best betternes when features are combined. - Since we can resolve overloading on constraints now. 
 
### Extra test scenarios that came from testplan review. ###
- [x] check `IsReferenceType` on `T` when constrained to `System.Enum` or `unmanaged`
- [x] check `IsValueType` on `T` when constrained to `System.Enum` or `unmanaged`
- [x] inherit from `System.Enum` in code (which would be an error of some sort). Check if it satisfies `System.Enum` constraint, or not - should not just crash.
- [x] check that code consuming `System.Enum` and `System.Delegate` constraints from metadata correctly still does so even if langver &lt; 7.3
- [x] check that the metadata emitted for `Enum`/`Delegate` constraints is consumable by legacy csc (metadata compat, ok to check manually once)
- [x] `System.Enum` can be combined with `unmanaged` constraint
- [x] `unmanaged` can be combined with Interfaces
- [x] `System.Enum` can be combined with Interfaces (did I miss a test?)
- [x] struct with pointer fields satisfies `unmanaged` 
- [x] enum defined in a generic type should not be considered `unmanaged` (per existing rules), but will satisfy  `System.Enum`/`struct`/`new()`

</Description>
        <CreatedDate>28/02/2018</CreatedDate>
        <ClosedDate>03/04/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Constraints.cs</File>
      <File>src/Compilers/CSharp/Portable/CSharpResources.Designer.cs</File>
      <File>src/Compilers/CSharp/Portable/Emitter/Model/PEModuleBuilder.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/ErrorCode.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ConstraintsHelper.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/LocalFunctionSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceMemberContainerSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceOrdinaryMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceTypeParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Attributes/AttributeTests_IsUnmanaged.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Emit/UnmanagedTypeModifierTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/GenericConstraintsTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/Retargeting/RetargetingTests.cs</File>
      <File>src/Compilers/Core/Portable/MetadataReader/MetadataDecoder.cs</File>
      <File>src/EditorFeatures/CSharpTest/Classification/SemanticClassifierTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Classification/SyntacticClassifierTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Classification/TotalClassifierTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/UpgradeProject/UpgradeProjectTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/QuickInfo/SemanticQuickInfoSourceTests.cs</File>
      <File>src/EditorFeatures/CSharpTest2/Recommendations/UnmanagedKeywordRecommenderTests.cs</File>
      <File>src/EditorFeatures/TestUtilities/Classification/FormattedClassification.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>25431</IssueID>
    <Title> Not offering UseAutoProperty for volatile fields &amp; when field used with ref</Title>
    <Description>fixes #25379
fixes #25429</Description>
    <CreatedDate>12/03/2018</CreatedDate>
    <ClosedDate>06/04/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>25379</IssueID>
        <Title>IDE0032 should not be reported for volatile fields</Title>
        <Description>**Version Used**: Visual Studio Community 15.6.1

**Steps to Reproduce**:
Here is the example code.

```csharp
class Class1
{
    private volatile int _field1;

    public int Property1
    {
        get { return this._field1; }
        set { this._field1 = value; }
    }

    public int Property2 { get; set; }
}
```

`Property1` is a wrapper for `_field1`, which has `volatile` modifier. `Property2` is a normal auto property, which is written for comparison.

Visual Studio says `_field1` can be an auto property.

![Screenshot of Code Action](https://user-images.githubusercontent.com/1000655/37224196-1675352a-2416-11e8-93ef-1df266f81806.png)

**Expected Behavior**: This suggestion should not be shown because the field has `volatile` modifier.

The way to access to volatile fields is different from the way to access to normal fields. Access to volatile fields needs `volatile.` prefix in IL. So the field cannot be an auto property in the present case.</Description>
        <CreatedDate>09/03/2018</CreatedDate>
        <ClosedDate>06/04/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>25429</IssueID>
        <Title>UseAutoProperty generates invalid code when using ref on the field</Title>
        <Description>```c#
class Class
{
    int value;
    int Value
    {
        get { return value; }
    }

    void M()
    {
        ref int x = ref value;
    }
}
```

applying the code fix results in:
```c#
class Class
{
    int Value { get; set; }
    
    void M()
    {
        ref int x = ref Value;
    }
}
```
which doesn't compile because Value doesn't return by ref.</Description>
        <CreatedDate>12/03/2018</CreatedDate>
        <ClosedDate>06/04/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharp/UseAutoProperty/CSharpUseAutoPropertyAnalyzer.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/UseAutoProperty/UseAutoPropertyTests.cs</File>
      <File>src/Features/Core/Portable/UseAutoProperty/AbstractUseAutoPropertyAnalyzer.cs</File>
      <File>src/Workspaces/Core/Portable/Utilities/IGroupingExtensions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>25133</IssueID>
    <Title>Adding missing completion for switch when clause</Title>
    <Description>fixes #25084 
fixes #25293</Description>
    <CreatedDate>28/02/2018</CreatedDate>
    <ClosedDate>04/04/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>25084</IssueID>
        <Title>Missing completion in switch 'when' clause</Title>
        <Description>Version used: Visual Studio 15.6 Preview 6 (same behavior in latest master bits)

Sample code:
```c#
class C
{
    void M()
    {
        var condition = true;

        switch (true)
        {
            case true
        }
    }
}
```
After `case true`, start typing `when`.
Expected behavior: `when` is offered and selected
Actual behavior: it's not offered at all

![image](https://user-images.githubusercontent.com/11444821/36731831-33f8c6ae-1bcc-11e8-948b-91a7b218fe9a.png)

After `when`, start typing `condition`. No completion whatsoever:
![image](https://user-images.githubusercontent.com/11444821/36731918-7718473e-1bcc-11e8-9603-bffcaf684667.png)
</Description>
        <CreatedDate>27/02/2018</CreatedDate>
        <ClosedDate>04/04/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>25293</IssueID>
        <Title>Annoying completion when adding pattern conditional in front of expression</Title>
        <Description>When inserting some code into an existing expression, I find it common to get an annoying completion when trying to type `null`.
For example, if you want to make a declaration into a conditional (from `var x = z;` to `var x = something is null ? y : z;`), `null` is not offered.

![image](https://user-images.githubusercontent.com/12466233/37071882-9b13422c-2173-11e8-8ff0-062696253561.png)

Tagging @Neme12 who is fixing some other completion issues with patterns.</Description>
        <CreatedDate>07/03/2018</CreatedDate>
        <ClosedDate>04/04/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/Completion/CompletionProviders/SymbolCompletionProviderTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Extensions/ContextQuery/IsPossibleDeconstructionDesignationTests.cs</File>
      <File>src/EditorFeatures/CSharpTest2/Recommendations/NullKeywordRecommenderTests.cs</File>
      <File>src/EditorFeatures/CSharpTest2/Recommendations/WhenKeywordRecommenderTests.cs</File>
      <File>src/Features/CSharp/Portable/Completion/KeywordRecommenders/NullKeywordRecommender.cs</File>
      <File>src/Features/CSharp/Portable/Completion/KeywordRecommenders/WhenKeywordRecommender.cs</File>
      <File>src/Workspaces/CSharp/Portable/Extensions/ContextQuery/SyntaxTreeExtensions.cs</File>
      <File>src/Workspaces/CSharp/Portable/Extensions/TypeSyntaxExtensions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>24821</IssueID>
    <Title>Fixing IntroduceVariable for expression bodied void-returning methods, local functions &amp; accessors</Title>
    <Description>fixes #24807 + missing support for new language features: expression bodied constructors, accessors &amp; local functions

fixes #13218

[edited - jcouv]
### Example for #24807
```C#
private void foo()
    =&gt; bar([|100|]);
```
currently refactors to
```C#
private void foo()
{
    const int Baz = 100;
    return bar(Baz); // note the additional return statement
}
```

### Example for #13218

**Code Before**:

``` csharp
public class Foo
{
    public void Bar(string s)
    {
        s = null;

        Bar(string.Empty);

        s = string.Empty;
    }
}
```

**Code After**:

``` csharp
public class Foo
{
    public void Bar(string s)
    {
        s = null; // note: empty line below was removed
        var empty = string.Empty;
        Bar(empty);

        s = empty;
    }
}
```</Description>
    <CreatedDate>13/02/2018</CreatedDate>
    <ClosedDate>27/04/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>24807</IssueID>
        <Title>Introduce Local generates an invalid return statement for void-returning expression methods</Title>
        <Description>**Version Used**:

VS 15.6 Preview 4

**Steps to Reproduce**:

```cs
private void bar(int baz)
{ }

private void foo()
    =&gt; bar(100);
```

Mark the `100` and "Introduce local constant"

**Expected Behavior**:
```cs
private void bar(int baz)
{ }

private void foo()
{
    const int Baz = 100;
    bar(Baz);
}
```

**Actual Behavior**:
```cs
private void bar(int baz)
{ }

private void foo()
{
    const int Baz = 100;
    return bar(Baz); // note the additional return statement
}
```

![introduce-local-return](https://user-images.githubusercontent.com/1947968/36148045-dfa54738-10ba-11e8-9f1c-4a939014035e.gif)
</Description>
        <CreatedDate>13/02/2018</CreatedDate>
        <ClosedDate>27/04/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>13218</IssueID>
        <Title>"IntroduceVariable" refactoring does not preserve empty line above local declaration</Title>
        <Description>**Steps to Reproduce**:
Apply refactoring "Introduce local for all occurrences of 'string.Empty'

**Code Before**:

``` csharp
public class Foo
{
    public void Bar(string s)
    {
        s = null;

        Bar(string.Empty);

        s = string.Empty;
    }
}
```

**Code After**:

``` csharp
public class Foo
{
    public void Bar(string s)
    {
        s = null;
        var empty = string.Empty;
        Bar(empty);

        s = empty;
    }
}
```

**Expected Behavior**:
Empty line above local declaration should be preserved

**Actual Behavior**:
Empty line above local declaration is removed
</Description>
        <CreatedDate>17/08/2016</CreatedDate>
        <ClosedDate>27/04/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>24807</IssueID>
        <Title>Introduce Local generates an invalid return statement for void-returning expression methods</Title>
        <Description>**Version Used**:

VS 15.6 Preview 4

**Steps to Reproduce**:

```cs
private void bar(int baz)
{ }

private void foo()
    =&gt; bar(100);
```

Mark the `100` and "Introduce local constant"

**Expected Behavior**:
```cs
private void bar(int baz)
{ }

private void foo()
{
    const int Baz = 100;
    bar(Baz);
}
```

**Actual Behavior**:
```cs
private void bar(int baz)
{ }

private void foo()
{
    const int Baz = 100;
    return bar(Baz); // note the additional return statement
}
```

![introduce-local-return](https://user-images.githubusercontent.com/1947968/36148045-dfa54738-10ba-11e8-9f1c-4a939014035e.gif)
</Description>
        <CreatedDate>13/02/2018</CreatedDate>
        <ClosedDate>27/04/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>13218</IssueID>
        <Title>"IntroduceVariable" refactoring does not preserve empty line above local declaration</Title>
        <Description>**Steps to Reproduce**:
Apply refactoring "Introduce local for all occurrences of 'string.Empty'

**Code Before**:

``` csharp
public class Foo
{
    public void Bar(string s)
    {
        s = null;

        Bar(string.Empty);

        s = string.Empty;
    }
}
```

**Code After**:

``` csharp
public class Foo
{
    public void Bar(string s)
    {
        s = null;
        var empty = string.Empty;
        Bar(empty);

        s = empty;
    }
}
```

**Expected Behavior**:
Empty line above local declaration should be preserved

**Actual Behavior**:
Empty line above local declaration is removed
</Description>
        <CreatedDate>17/08/2016</CreatedDate>
        <ClosedDate>27/04/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/CodeActions/IntroduceVariable/IntroduceVariableTests.cs</File>
      <File>src/Features/CSharp/Portable/IntroduceVariable/CSharpIntroduceVariableService_IntroduceLocal.cs</File>
      <File>src/Workspaces/CSharp/Portable/Extensions/BasePropertyDeclarationSyntaxExtensions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>21670</IssueID>
    <Title>Major MSBuildWorkspace update</Title>
    <Description>Fixes #5557
Fixes #5668
Fixes #15102

- [x] Remove dependency on old COM-based host objects.
- [x] Add support for SDK-style projects (including multi-TFM projects).
- [ ] Get general buy off on this source breaking change.
- [x] Add a Nuspec for the new Workspaces.MSBuild package.
- [x] Change API to account for the fact that a multi-TFM project will need to be loaded as multiple projects.
- [x] Add design-time batch build logic to improve performance.
- [ ] Document how MSBuildWorkspace can be used by clients.
- [ ] Create sample application that demonstrates how to use MSBuildWorkspace.</Description>
    <CreatedDate>22/08/2017</CreatedDate>
    <ClosedDate>05/04/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>5557</IssueID>
        <Title>Roslyn.Services.UnitTests.dll has a failure in Standalone runs</Title>
        <Description>One unit test is failing inside of this suite. It's is expecting a 6 when receiving a 4. I'm not sure what the numbers refer to. I will be disabling this until we get the testcase fixed.

Failure:
   Microsoft.CodeAnalysis.UnitTests.MSBuildWorkspaceTests.TestOpenProject_WithXaml [FAIL]
      Assert.Equal() Failure\r\nExpected: 6\r\nActual:   4
      Stack Trace:
            at Microsoft.CodeAnalysis.UnitTests.MSBuildWorkspaceTests.TestOpenProject_WithXaml()
</Description>
        <CreatedDate>29/09/2015</CreatedDate>
        <ClosedDate>05/04/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>5668</IssueID>
        <Title>[LOC] Roslyn.Services.UnitTests.dll has extra assert failure for JPN</Title>
        <Description>Run Roslyn.Services.UnitTests.dll on JPN OS, JPN VS, with VSUML installed.

Error is :
   Microsoft.CodeAnalysis.UnitTests.MSBuildWorkspaceTests.TestOpenProject_MetadataReferenceHasDocComments [FAIL]
      Assert.NotEqual() Failure
      Stack Trace:
            êŠ Xunit.Assert.NotEqual[T](T expected, T actual, IEqualityComparer`1 comparer)
            êŠ Microsoft.CodeAnalysis.UnitTests.MSBuildWorkspaceTests.TestOpenProject_MetadataReferenceHasDocCommen
</Description>
        <CreatedDate>02/10/2015</CreatedDate>
        <ClosedDate>05/04/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>15102</IssueID>
        <Title>Some MSBuildWorkspaceTests fail after updating to Dev15 Preview5</Title>
        <Description>After updating our build to target Dev15 Preview5, and updating the `MSBuildWorkspace` to find the MSBuild 15.0 binaries based on the VS location, the following tests still fail:

* Microsoft.CodeAnalysis.UnitTests.MSBuildWorkspaceTests.TestCompilationOptions_VisualBasic_OptionStrict_On
* Microsoft.CodeAnalysis.UnitTests.MSBuildWorkspaceTests.TestOpenProject_MetadataReferenceHasDocComments
* Microsoft.CodeAnalysis.UnitTests.MSBuildWorkspaceTests.TestOpenProject_CSharp_WithoutPrefer32BitAndConsoleApplication
* Microsoft.CodeAnalysis.UnitTests.MSBuildWorkspaceTests.TestOpenProject_CSharp_WithPrefer32BitAndConsoleApplication
* Microsoft.CodeAnalysis.UnitTests.MSBuildWorkspaceTests.TestOpenProject_VisualBasic_WithoutPrefer32BitAndConsoleApplication
* Microsoft.CodeAnalysis.UnitTests.MSBuildWorkspaceTests.TestOpenProject_VisualBasic_WithPrefer32BitAndConsoleApplication
* Microsoft.CodeAnalysis.UnitTests.MSBuildWorkspaceTests.TestOpenProject_WithXaml

During at least some of these test runs we're getting an `InvalidProjectFileException` stating that "The "Csc" task could not be initialized with its input parameters". I'm not sure if that is relevant or not.
</Description>
        <CreatedDate>08/11/2016</CreatedDate>
        <ClosedDate>05/04/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Test/Utilities/Portable/Assert/AssertEx.cs</File>
      <File>src/Test/Utilities/Portable/Traits/Traits.cs</File>
      <File>src/Workspaces/Core/Desktop/TypeForwarders.cs</File>
      <File>src/Workspaces/Core/Desktop/Workspace/MSBuild/CSharp/CSharpProjectFileLoader.CSharpProjectFile.cs</File>
      <File>src/Workspaces/Core/Desktop/Workspace/MSBuild/MSBuildProjectLoader.cs</File>
      <File>src/Workspaces/Core/Desktop/Workspace/MSBuild/ProjectFile/ProjectFile.cs</File>
      <File>src/Workspaces/Core/Desktop/Workspace/MSBuild/ProjectFile/ProjectFileInfo.cs</File>
      <File>src/Workspaces/Core/Desktop/Workspace/MSBuild/ProjectFile/ProjectFileLoader.cs</File>
      <File>src/Workspaces/Core/Desktop/Workspace/MSBuild/ProjectFile/ProjectTypeGuidAttribute.cs</File>
      <File>src/Workspaces/Core/Desktop/Workspace/MSBuild/VisualBasic/VisualBasicProjectFileLoader.cs</File>
      <File>src/Workspaces/Core/Desktop/WorkspaceDesktopResources.Designer.cs</File>
      <File>src/Workspaces/Core/MSBuild/Host/Mef/MSBuildMefHostServices.cs</File>
      <File>src/Workspaces/Core/MSBuild/Host/SimpleAnalyzerAssemblyLoaderService.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/Build/ProjectBuildManager.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/CSharp/CSharpCommandLineArgumentReader.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/CSharp/CSharpProjectFile.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/CSharp/CSharpProjectFileLoader.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/CSharp/CSharpProjectFileLoaderFactory.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/Constants/ItemNames.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/Constants/MetadataNames.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/Constants/PropertyNames.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/Constants/PropertyValues.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/Constants/TargetNames.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/DiagnosticReporter.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/DiagnosticReportingMode.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/DiagnosticReportingOptions.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/Logging/DiagnosticLog.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/Logging/DiagnosticLogItem.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/Logging/MSBuildDiagnosticLogItem.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/Logging/MSBuildDiagnosticLogger.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/MSBuildProjectLoader.Worker.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/MSBuildProjectLoader.Worker_ResolveReferences.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/MSBuildProjectLoader.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/MSBuildWorkspace.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/PathResolver.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/ProjectFile/CommandLineArgumentReader.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/ProjectFile/Conversions.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/ProjectFile/DocumentFileInfo.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/ProjectFile/Extensions.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/ProjectFile/IProjectFile.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/ProjectFile/IProjectFileLoader.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/ProjectFile/ProjectFile.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/ProjectFile/ProjectFileExtensionAttribute.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/ProjectFile/ProjectFileInfo.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/ProjectFile/ProjectFileLoader.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/ProjectFile/ProjectFileLoaderRegistry.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/ProjectFile/ProjectFileReference.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/ProjectLoadOperation.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/ProjectLoadProgress.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/ProjectMap.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/VisualBasic/VisualBasicCommandLineArgumentReader.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/VisualBasic/VisualBasicProjectFile.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/VisualBasic/VisualBasicProjectFileLoader.cs</File>
      <File>src/Workspaces/Core/MSBuild/MSBuild/VisualBasic/VisualBasicProjectFileLoaderFactory.cs</File>
      <File>src/Workspaces/Core/MSBuild/WorkspaceMSBuildResources.Designer.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/FileTextLoader.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/Host/Metadata/WorkspaceMetadataFileReferenceResolver.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/WorkspaceKind.cs</File>
      <File>src/Workspaces/CoreTest/SolutionTests/SolutionTests.cs</File>
      <File>src/Workspaces/CoreTest/WorkspaceTests/MSBuildWorkspaceTestBase.cs</File>
      <File>src/Workspaces/CoreTest/WorkspaceTests/MSBuildWorkspaceTests.cs</File>
      <File>src/Workspaces/CoreTestUtilities/DotNetHelper.cs</File>
      <File>src/Workspaces/CoreTestUtilities/FileSet.cs</File>
      <File>src/Workspaces/CoreTestUtilities/Resources/NetCoreApp2/Program.cs</File>
      <File>src/Workspaces/CoreTestUtilities/Resources/NetCoreApp2AndLibrary/Class1.cs</File>
      <File>src/Workspaces/CoreTestUtilities/Resources/NetCoreApp2AndLibrary/Program.cs</File>
      <File>src/Workspaces/CoreTestUtilities/Resources/NetCoreApp2AndTwoLibraries/Class1.cs</File>
      <File>src/Workspaces/CoreTestUtilities/Resources/NetCoreApp2AndTwoLibraries/Class2.cs</File>
      <File>src/Workspaces/CoreTestUtilities/Resources/NetCoreApp2AndTwoLibraries/Program.cs</File>
      <File>src/Workspaces/CoreTestUtilities/Resources/NetCoreMultiTFM/Program.cs</File>
      <File>src/Workspaces/CoreTestUtilities/Resources/NetCoreMultiTFM_ProjectReference/Class1.cs</File>
      <File>src/Workspaces/CoreTestUtilities/Resources/NetCoreMultiTFM_ProjectReference/Program.cs</File>
      <File>src/Workspaces/CoreTestUtilities/Resources/NetCoreMultiTFM_ProjectReferenceWithReversedTFMs/Class1.cs</File>
      <File>src/Workspaces/CoreTestUtilities/Resources/NetCoreMultiTFM_ProjectReferenceWithReversedTFMs/Program.cs</File>
      <File>src/Workspaces/CoreTestUtilities/Resources/SourceFiles/CSharp/App.xaml.cs</File>
      <File>src/Workspaces/CoreTestUtilities/Resources/SourceFiles/CSharp/AssemblyInfo.cs</File>
      <File>src/Workspaces/CoreTestUtilities/Resources/SourceFiles/CSharp/CSharpClass.cs</File>
      <File>src/Workspaces/CoreTestUtilities/Resources/SourceFiles/CSharp/CSharpClass_WithConditionalAttributes.cs</File>
      <File>src/Workspaces/CoreTestUtilities/Resources/SourceFiles/CSharp/CSharpConsole.cs</File>
      <File>src/Workspaces/CoreTestUtilities/Resources/SourceFiles/CSharp/CSharpExternAlias.cs</File>
      <File>src/Workspaces/CoreTestUtilities/Resources/SourceFiles/CSharp/MainWindow.xaml.cs</File>
      <File>src/Workspaces/CoreTestUtilities/Resources/SourceFiles/CSharp/OtherStuff_Foo.cs</File>
      <File>src/Workspaces/CoreTestUtilities/SolutionTestUtilities.cs</File>
      <File>src/Workspaces/CoreTestUtilities/TestFiles/Resources.cs</File>
      <File>src/Workspaces/CoreTestUtilities/WorkspaceExtensions.cs</File>
      <File>src/Workspaces/CoreTestUtilities/WorkspaceTestBase.cs</File>
      <File>src/Workspaces/MSBuildTest/Interop.cs</File>
      <File>src/Workspaces/MSBuildTest/MSBuildWorkspaceTestBase.cs</File>
      <File>src/Workspaces/MSBuildTest/MSBuildWorkspaceTests.cs</File>
      <File>src/Workspaces/MSBuildTest/NetCoreTests.cs</File>
      <File>src/Workspaces/MSBuildTest/SolutionGeneration.cs</File>
      <File>src/Workspaces/MSBuildTest/VisualStudioMSBuildInstalled.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>25426</IssueID>
    <Title>Key container signing fix</Title>
    <Description>### Customer scenario(s)

There are two signing bugs. In the first, the compiler fails to sign an assembly if signing is specific using the AssemblyKeyContainer attribute and nothing else. Specifically, if key signing is requested using a key file or using a key container but provided through command line or MSBuild option, signing succeeds. In the second, the `-delaysign` option will fully sign an assembly if provided a key file that contains both a public and private key.

### Bugs this fixes

#25340
#25424 

Tracking bug https://devdiv.visualstudio.com/DevDiv/_workitems/edit/580955

### Workarounds, if any

There are three possible workarounds for the key container bug for 15.6:

1. You can switch to using a keyfile instead of a key container.
2. You can enable a fallback mode by putting the following in your MSBuild project files
```
&lt;Features&gt;$(Features);UseLegacyStrongNameProvider&lt;/Features&gt;
```
3. You can move the name of the key container from the AssemblyAttributes C# file to your project file(s) by adding the following property: 
```
&lt;KeyContainerName&gt;the-name-of-your-key-here&lt;/KeyContainerName&gt;
```

For the delaysign bug, you can use the UseLegacyStrongNameProvider flag on Windows, or you can create a key file that contains only the public key, with no private key.

### Risk

This change mostly moves us back to using the old signing behavior. The only change not related is the fix for delaysign on CoreCLR, which is a targeted fix to prevent us from full-signing when it was not requested. This change has been validated by unit tests.

### Performance impact

Almost none -- an additional null check in the working case and only a handful of allocations.

### Is this a regression from a previous update?

This is a regression, but not from another update. Key container signing using attributes previously worked.

### Root cause analysis

The tests only tried to test key containers with the desktop strong name provider, assuming that only a desktop strong name provider would be provided if we require key container signing. This is incorrect. This change moves us back to the old signing code, which has proper tests for these scenarios. For the delaysign fix, appropriate tests have been added for the CoreCLR code.

### How was the bug found?

Customer reported.
</Description>
    <CreatedDate>12/03/2018</CreatedDate>
    <ClosedDate>15/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>25340</IssueID>
        <Title>Strong Name signing with a key installed in a container</Title>
        <Description>After upgrading to respectively installing Visual Studio 2017 Version 15.6 no assemblies will be signed with a strong name.

We are using the AssemblyKeyName Attribute in AssemblyInfo.cs.

Using a KeyFile instead (created from the projects properties) will work.

Am I missing something?

_This issue has been moved from https://developercommunity.visualstudio.com/content/problem/209811/strong-name-signing-with-a-key-installed-in-a-cont.html
VSTS ticketId: 578075_
_These are the original issue comments:_

Matthew Dodds on 3/7/2018, 10:24 AM (12 hours ago): &lt;p&gt;I am also having this problem with using AssemblyKeyName, which is showing up as two different issues. I am using C#, ASP.NET, .NET 4.7.1. Both of these issues were fixed once I reverted to Visual Studio 15.5.7. I also confirmed that using AssemblyKeyFile referencing a .snk instead of using AssemblyKeyName fixed both issues.&lt;/p&gt;&lt;p&gt;First: &lt;/p&gt;&lt;p&gt;Attempting to load the program in IIS results in the exception: "Could not load file or assembly '[redacted], Culture=neutral, PublicKeyToken=928c297f0d8e5e72' or one of its dependencies. The located assembly's manifest definition does not match the assembly reference." &lt;/p&gt;&lt;p&gt;Fusion log contained: "Comparing the assembly name resulted in the mismatch: PUBLIC KEY TOKEN" &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;
Second:&lt;/p&gt;&lt;p&gt;
Building of a solution that references some of our C# libraries built outside of the solution will result in: "Error CS8002: Referenced assembly '[redacted], Version=6.3.0.144, Culture=neutral, PublicKeyToken=null' does not have a strong name." &lt;/p&gt;&lt;p&gt;Building this solution a second time will result it successfully building, but will always fail if telling Visual Studio to rebuild. &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;

_These are the original issue solutions:_
(no solutions)</Description>
        <CreatedDate>08/03/2018</CreatedDate>
        <ClosedDate>16/03/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>25424</IssueID>
        <Title>Roslyn is producing a strong-name signed dll even when DelaySign is set to true</Title>
        <Description>**Version Used**: 2.8.0-beta2-62711-03

**Steps to Reproduce**:

We are trying to get the latest version of Roslyn consumed by corefx so that we can start using the compiler server for non-Windows builds. The problem seems to be that after updating to the latest version, we can't force the compiler to NOT strong-name sign the assemblies. In corefx we need this since we run some post-compilation tools on the dll and we manually sign the binaries after that. Here are the parameters we are passing in to the CSC task:

![image](https://user-images.githubusercontent.com/13854455/37302499-ee658fba-25e8-11e8-93c5-60ed521a0543.png)

**Expected Behavior**: output assembly shouldn't be strong-name signed

**Actual Behavior**: assembly is strong name signed causing a build error when we try to sign it manually after running our tools.

This is currently blocking the adoption of roslyn into corefx so it would be appreciated if addressed soon. cc: @agocke @jaredpar 
</Description>
        <CreatedDate>12/03/2018</CreatedDate>
        <ClosedDate>16/03/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Test/CommandLine/CommandLineTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Attributes/InternalsVisibleToAndStrongNameTests.cs</File>
      <File>src/Compilers/Core/Portable/CommandLine/CommonCommandLineArguments.cs</File>
      <File>src/Compilers/Core/Portable/PEWriter/PeWriter.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>25344</IssueID>
    <Title>Adjust indent block operations used for VB smart indent in argument lists</Title>
    <Description>Fixes #25323

### Customer scenario

Visual Basic argument lists (and other parenthesized lists, like parameter lists and type parameter lists),
have specialized smart indent behavior. Essentially, arguments after the first argument in a list are
indented to the same position as the first argument. Consider the following code.

``` VB
Sub M()
    Console.WriteLine("{0} + {1} = {2}", 19, 23, 19 + 23)
End Sub
```

If the user presses ENTER before the second argument (19), the indentation looks like so.

``` VB
Sub M()
    Console.WriteLine("{0} + {1} = {2}",
                      19, 23, 19 + 23)
End Sub
```

However, this can cause indentation issues if the user wants to ident all subsequent arguments differently. Consider the following scenario.

``` VB
Sub M()
    Console.WriteLine("{0} + {1} = {2}",
        19, 23,
        19 + 23)
End Sub
```

Now, if the user presses ENTER before the third argument (23), the indentation of the first argument will be used, even though the user had indented the second argument differently:

``` VB
Sub M()
    Console.WriteLine("{0} + {1} = {2}",
        19,
                      23,
        19 + 23)
End Sub
```

This problem occurs because a single indent block operation is created for the whole argument list using the indentation of the first argument. This change fixes the issue by creating multiple indent block operations using the indentation of the first argument, and the indentation of any argument that appears on a different line.

### Bugs this fixes

Fixes #25323

### Workarounds, if any

If the user wishes to format their argument lists in the manner described above, there really isn't a good way to workaround the issue. It's an annoyance and the editor will fight against the user's indentation.

### Risk

Low. This change is localized to indentation in argument lists.

### Performance impact

Low performance impact. Any new allocations do not happen in hot paths -- only when the user presses enter in an argument list.

### Is this a regression from a previous update?

No.

### Root cause analysis

I'm surprised we have not heard about this. This problem shows up in very simple cases where a method call has a large number of arguments. However, it is somewhat less common because many users will move the first argument to the next line and indent *all* arguments together at once.

### How was the bug found?

I was reformatting the VB classification unit tests and found this issue to be particularly frustrating.
</Description>
    <CreatedDate>08/03/2018</CreatedDate>
    <ClosedDate>09/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>25323</IssueID>
        <Title>VB: Smart indent issue with argument lists</Title>
        <Description>**Version Used**: 15.7.0 Preview 1.0 [27506.1.d15.7]

The here is that VB smart indent for argument lists is *always* based on the position of the first argument, regardless of where other arguments are positioned.

**Steps to Reproduce**:

1. Create Visual Basic Console App project
2. Add the following line of code to `Main()`:

``` VB
Console.WriteLine("{0} + {1} = {2}", 19, 23, 19 + 23)
```

3. Place the editor caret before the second argument (`19`) and press ENTER. Then, unindent until the remaining arguments start one tab to the left of `Console`:

``` VB
Console.WriteLine("{0} + {1} = {2}",
    19, 23, 19 + 23)
```

4. Place the editor caret before the third argument (`23`) and press ENTER.

**Expected Behavior**:

The indentation should be aligned with the second argument.

``` VB
Console.WriteLine("{0} + {1} = {2}",
    19,
    23, 19 + 23)
```

**Actual Behavior**:

The indentation is always aligned with the first argument, regardless of where subsequent arguments are positioned.

``` VB
Console.WriteLine("{0} + {1} = {2}",
    19, 
                  23, 19 + 23)
```

Note that this happens for every single argument after the first one. If the user wants a different indentation level, the IDE fights them by trying to force every argument to align with the first argument.</Description>
        <CreatedDate>07/03/2018</CreatedDate>
        <ClosedDate>21/03/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>25323</IssueID>
        <Title>VB: Smart indent issue with argument lists</Title>
        <Description>**Version Used**: 15.7.0 Preview 1.0 [27506.1.d15.7]

The here is that VB smart indent for argument lists is *always* based on the position of the first argument, regardless of where other arguments are positioned.

**Steps to Reproduce**:

1. Create Visual Basic Console App project
2. Add the following line of code to `Main()`:

``` VB
Console.WriteLine("{0} + {1} = {2}", 19, 23, 19 + 23)
```

3. Place the editor caret before the second argument (`19`) and press ENTER. Then, unindent until the remaining arguments start one tab to the left of `Console`:

``` VB
Console.WriteLine("{0} + {1} = {2}",
    19, 23, 19 + 23)
```

4. Place the editor caret before the third argument (`23`) and press ENTER.

**Expected Behavior**:

The indentation should be aligned with the second argument.

``` VB
Console.WriteLine("{0} + {1} = {2}",
    19,
    23, 19 + 23)
```

**Actual Behavior**:

The indentation is always aligned with the first argument, regardless of where subsequent arguments are positioned.

``` VB
Console.WriteLine("{0} + {1} = {2}",
    19, 
                  23, 19 + 23)
```

Note that this happens for every single argument after the first one. If the user wants a different indentation level, the IDE fights them by trying to force every argument to align with the first argument.</Description>
        <CreatedDate>07/03/2018</CreatedDate>
        <ClosedDate>21/03/2018</ClosedDate>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>25209</IssueID>
    <Title>Localization test failures Return FormattableString for BoundTupleExpression.Display</Title>
    <Description>### Customer scenario

Running unit test `OverloadResolutionTests.GenericInferenceOnInErrTuples` on non English machines failed due to localization issues. The root cause was that `BoundTupleExpression.Display` returned a string instead of a localizable string. The PR implements the solution proposed by @AlekseyTs in #24603. 
As noted in #24603 `BoundStackAllocArrayCreation.Display` a few lines down needs also to be fixed. This will be done once the fix `BoundTupleExpression.Display` is reviewed as being valid.

### Bugs this fixes

Fixes #24603 

### Workarounds, if any

Ignore test failures.

### Risk

The proposed solution requires to allow `FormattableString` types in `DiagnosticInfo.Arguments`. This might lead to unwanted code patterns in respect to DiagnosticInfo and localizability in the future.

### Performance impact

Low.

### Is this a regression from a previous update?

### Root cause analysis

Localization wasn't tested before.

### How was the bug found?

Contributor reported.

### Test documentation updated?

No.
</Description>
    <CreatedDate>04/03/2018</CreatedDate>
    <ClosedDate>06/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>24603</IssueID>
        <Title>Test localization failures on non english machines: BoundTupleExpression.Display returns a string instead a FormattableString</Title>
        <Description>Extracted from the closed PR #24539 

**Steps to Reproduce**:

Run `Microsoft.CodeAnalysis.CSharp.UnitTests.OverloadResolutionTests.GenericInferenceOnInErrTuples` on a non-english machine.

**Expected Behavior**:

Test passes.

**Actual Behavior**:

Test fails for Diagnostics with a `BoundTupleExpression` because `BoundTupleExpression.Display` returns a localized string (e.g. German during the test run). BoundTupleExpression.Display should return a formattable string instead. There are some more tests that also fail. See the original PR for details.

**History**

The issue was discussed but not resolved in #24539. The relevant sections are:

@Mastr11
The diagnostic is created [here](https://github.com/dotnet/roslyn/blob/master/src/Compilers/CSharp/Portable/Binder/Semantics/OverloadResolution/OverloadResolutionResult.cs#L991) and the argument is created via  `argument.Display` 
The problem here is that the [BoundTupleExpression.Display](https://github.com/dotnet/roslyn/blob/master/src/Compilers/CSharp/Portable/BoundTree/Formatting.cs#L85) uses a stringbuilder. So the argument is a text as opposed to a `LocalizableErrorArgument`. I don't see any straight forward way on how to resolve this. @AlekseyTs I would propose to revert my changes here and let the test fail on non english machines for now. 

@AlekseyTs 
It would be great if you could fix it because you can easily verify the effect, but it is up to you.
I think there is a simple fix for BoundTupleExpression.Display. Instead of building complete string, we can build a format string with argument markers and collect arguments in an array. Then we call to System.Runtime.CompilerServices.FormattableStringFactory.Create and return its result.
There is also an issue with

```CS
    internal partial class BoundStackAllocArrayCreation
    {
        public override object Display
        {
            get { return string.Format(MessageID.IDS_StackAllocExpression.Localize().ToString(), ElementType, Count.Syntax); }
        }
    }
```

This one can be fixed by creating an object that is very similar to LocalizableErrorArgument, that calls Format after getting the string for requested culture.</Description>
        <CreatedDate>02/02/2018</CreatedDate>
        <ClosedDate>06/03/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>24603</IssueID>
        <Title>Test localization failures on non english machines: BoundTupleExpression.Display returns a string instead a FormattableString</Title>
        <Description>Extracted from the closed PR #24539 

**Steps to Reproduce**:

Run `Microsoft.CodeAnalysis.CSharp.UnitTests.OverloadResolutionTests.GenericInferenceOnInErrTuples` on a non-english machine.

**Expected Behavior**:

Test passes.

**Actual Behavior**:

Test fails for Diagnostics with a `BoundTupleExpression` because `BoundTupleExpression.Display` returns a localized string (e.g. German during the test run). BoundTupleExpression.Display should return a formattable string instead. There are some more tests that also fail. See the original PR for details.

**History**

The issue was discussed but not resolved in #24539. The relevant sections are:

@Mastr11
The diagnostic is created [here](https://github.com/dotnet/roslyn/blob/master/src/Compilers/CSharp/Portable/Binder/Semantics/OverloadResolution/OverloadResolutionResult.cs#L991) and the argument is created via  `argument.Display` 
The problem here is that the [BoundTupleExpression.Display](https://github.com/dotnet/roslyn/blob/master/src/Compilers/CSharp/Portable/BoundTree/Formatting.cs#L85) uses a stringbuilder. So the argument is a text as opposed to a `LocalizableErrorArgument`. I don't see any straight forward way on how to resolve this. @AlekseyTs I would propose to revert my changes here and let the test fail on non english machines for now. 

@AlekseyTs 
It would be great if you could fix it because you can easily verify the effect, but it is up to you.
I think there is a simple fix for BoundTupleExpression.Display. Instead of building complete string, we can build a format string with argument markers and collect arguments in an array. Then we call to System.Runtime.CompilerServices.FormattableStringFactory.Create and return its result.
There is also an issue with

```CS
    internal partial class BoundStackAllocArrayCreation
    {
        public override object Display
        {
            get { return string.Format(MessageID.IDS_StackAllocExpression.Localize().ToString(), ElementType, Count.Syntax); }
        }
    }
```

This one can be fixed by creating an object that is very similar to LocalizableErrorArgument, that calls Format after getting the string for requested culture.</Description>
        <CreatedDate>02/02/2018</CreatedDate>
        <ClosedDate>06/03/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>24603</IssueID>
        <Title>Test localization failures on non english machines: BoundTupleExpression.Display returns a string instead a FormattableString</Title>
        <Description>Extracted from the closed PR #24539 

**Steps to Reproduce**:

Run `Microsoft.CodeAnalysis.CSharp.UnitTests.OverloadResolutionTests.GenericInferenceOnInErrTuples` on a non-english machine.

**Expected Behavior**:

Test passes.

**Actual Behavior**:

Test fails for Diagnostics with a `BoundTupleExpression` because `BoundTupleExpression.Display` returns a localized string (e.g. German during the test run). BoundTupleExpression.Display should return a formattable string instead. There are some more tests that also fail. See the original PR for details.

**History**

The issue was discussed but not resolved in #24539. The relevant sections are:

@Mastr11
The diagnostic is created [here](https://github.com/dotnet/roslyn/blob/master/src/Compilers/CSharp/Portable/Binder/Semantics/OverloadResolution/OverloadResolutionResult.cs#L991) and the argument is created via  `argument.Display` 
The problem here is that the [BoundTupleExpression.Display](https://github.com/dotnet/roslyn/blob/master/src/Compilers/CSharp/Portable/BoundTree/Formatting.cs#L85) uses a stringbuilder. So the argument is a text as opposed to a `LocalizableErrorArgument`. I don't see any straight forward way on how to resolve this. @AlekseyTs I would propose to revert my changes here and let the test fail on non english machines for now. 

@AlekseyTs 
It would be great if you could fix it because you can easily verify the effect, but it is up to you.
I think there is a simple fix for BoundTupleExpression.Display. Instead of building complete string, we can build a format string with argument markers and collect arguments in an array. Then we call to System.Runtime.CompilerServices.FormattableStringFactory.Create and return its result.
There is also an issue with

```CS
    internal partial class BoundStackAllocArrayCreation
    {
        public override object Display
        {
            get { return string.Format(MessageID.IDS_StackAllocExpression.Localize().ToString(), ElementType, Count.Syntax); }
        }
    }
```

This one can be fixed by creating an object that is very similar to LocalizableErrorArgument, that calls Format after getting the string for requested culture.</Description>
        <CreatedDate>02/02/2018</CreatedDate>
        <ClosedDate>06/03/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/BoundTree/Formatting.cs</File>
      <File>src/Compilers/CSharp/Portable/CSharpResources.Designer.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/MessageID.cs</File>
      <File>src/Compilers/Core/Portable/Diagnostic/DiagnosticInfo.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>25194</IssueID>
    <Title>Localization test failures VB Fix creation of diagnostic in VisualBasicParseOptions.ValidateOptions</Title>
    <Description>### Customer scenario

Running unit test `Microsoft.CodeAnalysis.VisualBasic.UnitTests.GetDiagnosticsTests.CompilingCodeWithInvalidPreProcessorSymbolsShouldProvideDiagnostics` and about 6 others on non English machines failed due to localization issues. The root cause was that the diagnostic for error `ERR_ConditionalCompilationConstantNotValid` wasn't created properly.

The solution was proposed by @AlekseyTs in #24604 
&gt; Alternatively, for consistency with other places where the same diagnostics is created (that is the approach I would prefer), we should be able to call Diagnostic.Create overload that takes DiagnosticInfo. Like this:

```CS
Diagnostic.Create(ErrorFactory.ErrorInfo(ERRID.ERR_ConditionalCompilationConstantNotValid,
                                            ErrorFactory.ErrorInfo(ERRID.ERR_ExpectedIdentifier),
                                            symbol.Key))
```

With this change in place the unit tests do not fail on a German machine.

### Bugs this fixes

Fixes #24604 

### Workarounds, if any

Ignore test failures.

### Risk

Low. 

### Performance impact

Low.

### Is this a regression from a previous update?

No.

### Root cause analysis

Diagnostics are meant to be localization neutral. This diagnostic was created with eager localized arguments.

### How was the bug found?

Contributor reported.

### Test documentation updated?

No.</Description>
    <CreatedDate>02/03/2018</CreatedDate>
    <ClosedDate>05/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>24604</IssueID>
        <Title>Test localization failures on non english machines: VisualBasicParseOptions.ValidateOptions localizes error argument eager.</Title>
        <Description>Extracted from the closed PR #24539 

**Steps to Reproduce**:

Run `Microsoft.CodeAnalysis.VisualBasic.UnitTests.GetDiagnosticsTests.CompilingCodeWithInvalidPreProcessorSymbolsShouldProvideDiagnostics` on a non-english machine. (There are more tests affected by this bug. See the original PR for details).

**Expected Behavior**:

Test passes.

**Actual Behavior**:

Test fails because [VisualBasicParseOptions.ValidateOptions](https://github.com/dotnet/roslyn/blob/master/src/Compilers/VisualBasic/Portable/VisualBasicParseOptions.vb#L255) localizes the error argument eager.

**History**

The issue was discussed but not resolved in #24539. The relevant sections are:

@Mastr11
The diagnostic under test is created here like so:
`builder.Add(Diagnostic.Create(MessageProvider.Instance, ERRID.ERR_ConditionalCompilationConstantNotValid, VBResources.ERR_ExpectedIdentifier, symbol.Key))`
If I got you you right it should be created like this one:
```CS
diagnostics.Add(
    messageProvider.CreateDiagnostic(code, Location.None, 
        new CodeAnalysisResourcesLocalizableErrorArgument(errorArgumentResourceId)));
```
It seems there isn't a VBResourcesLocalizableErrorArgument class (at least I couldn't find anything suitable).

@AlekseyTs
There is Microsoft.CodeAnalysis.VisualBasic.LocalizableErrorArgument type.
Alternatively, for consistency with other places where the same diagnostics is created (that is the approach I would prefer), we should be able to call Diagnostic.Create overload that takes DiagnosticInfo. Like this:
```CS
Diagnostic.Create(ErrorFactory.ErrorInfo(ERRID.ERR_ConditionalCompilationConstantNotValid,
                                            ErrorFactory.ErrorInfo(ERRID.ERR_ExpectedIdentifier),
                                            symbol.Key))
```</Description>
        <CreatedDate>02/02/2018</CreatedDate>
        <ClosedDate>06/03/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>24604</IssueID>
        <Title>Test localization failures on non english machines: VisualBasicParseOptions.ValidateOptions localizes error argument eager.</Title>
        <Description>Extracted from the closed PR #24539 

**Steps to Reproduce**:

Run `Microsoft.CodeAnalysis.VisualBasic.UnitTests.GetDiagnosticsTests.CompilingCodeWithInvalidPreProcessorSymbolsShouldProvideDiagnostics` on a non-english machine. (There are more tests affected by this bug. See the original PR for details).

**Expected Behavior**:

Test passes.

**Actual Behavior**:

Test fails because [VisualBasicParseOptions.ValidateOptions](https://github.com/dotnet/roslyn/blob/master/src/Compilers/VisualBasic/Portable/VisualBasicParseOptions.vb#L255) localizes the error argument eager.

**History**

The issue was discussed but not resolved in #24539. The relevant sections are:

@Mastr11
The diagnostic under test is created here like so:
`builder.Add(Diagnostic.Create(MessageProvider.Instance, ERRID.ERR_ConditionalCompilationConstantNotValid, VBResources.ERR_ExpectedIdentifier, symbol.Key))`
If I got you you right it should be created like this one:
```CS
diagnostics.Add(
    messageProvider.CreateDiagnostic(code, Location.None, 
        new CodeAnalysisResourcesLocalizableErrorArgument(errorArgumentResourceId)));
```
It seems there isn't a VBResourcesLocalizableErrorArgument class (at least I couldn't find anything suitable).

@AlekseyTs
There is Microsoft.CodeAnalysis.VisualBasic.LocalizableErrorArgument type.
Alternatively, for consistency with other places where the same diagnostics is created (that is the approach I would prefer), we should be able to call Diagnostic.Create overload that takes DiagnosticInfo. Like this:
```CS
Diagnostic.Create(ErrorFactory.ErrorInfo(ERRID.ERR_ConditionalCompilationConstantNotValid,
                                            ErrorFactory.ErrorInfo(ERRID.ERR_ExpectedIdentifier),
                                            symbol.Key))
```</Description>
        <CreatedDate>02/02/2018</CreatedDate>
        <ClosedDate>06/03/2018</ClosedDate>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>25151</IssueID>
    <Title>Enable integration tests</Title>
    <Description>Fixes #17631
Fixes #17634
Fixes #18295

Closes #6587
Closes #17640
Closes #19232
Closes #20219
</Description>
    <CreatedDate>01/03/2018</CreatedDate>
    <ClosedDate>03/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>17631</IssueID>
        <Title>The BasicFindReferences.FindReferencesToSharedField and .FindReferencesToLocals integration tests are flaky.</Title>
        <Description>Most runs are failing with:
```
MESSAGE:
System.AggregateException : One or more errors occurred.\r\n---- System.Runtime.Remoting.RemotingException : Requested Service not found\r\n---- System.Runtime.Remoting.RemotingException : Failed to write to an IPC Port: The pipe is being closed.\r\n
+++++++++++++++++++
STACK TRACE:
----- Inner Stack Trace #1 (System.Runtime.Remoting.RemotingException) ----- Server stack trace: at System.Runtime.Remoting.Channels.BinaryServerFormatterSink.ProcessMessage(IServerChannelSinkStack sinkStack, IMessage requestMsg, ITransportHeaders requestHeaders, Stream requestStream, IMessage&amp; responseMsg, ITransportHeaders&amp; responseHeaders, Stream&amp; responseStream) Exception rethrown at [0]: at System.Runtime.Remoting.Proxies.RealProxy.HandleReturnMessage(IMessage reqMsg, IMessage retMsg) at System.Runtime.Remoting.Proxies.RealProxy.PrivateInvoke(MessageData&amp; msgData, Int32 type) at Microsoft.VisualStudio.IntegrationTest.Utilities.InProcess.FindReferencesWindow_InProc.GetContents(String windowCaption) at Microsoft.VisualStudio.IntegrationTest.Utilities.OutOfProcess.FindReferencesWindow_OutOfProc.GetContents(String windowCaption) at Roslyn.VisualStudio.IntegrationTests.VisualBasic.BasicFindReferences.FindReferencesToSharedField() in q:\roslyn\src\VisualStudio\IntegrationTest\IntegrationTests\VisualBasic\BasicFindReferences.cs:line 87 ----- Inner Stack Trace #2 (System.Runtime.Remoting.RemotingException) ----- Server stack trace: at System.Runtime.Remoting.Channels.Ipc.IpcPort.Write(Byte[] data, Int32 offset, Int32 size) at System.Runtime.Remoting.Channels.Ipc.PipeStream.Write(Byte[] buffer, Int32 offset, Int32 count) at System.Runtime.Remoting.Channels.ChunkedMemoryStream.WriteTo(Stream stream) at System.Runtime.Remoting.Channels.Ipc.IpcClientHandler.SendRequest(IMessage msg, ITransportHeaders headers, Stream contentStream) at System.Runtime.Remoting.Channels.Ipc.IpcClientTransportSink.ProcessMessage(IMessage msg, ITransportHeaders requestHeaders, Stream requestStream, ITransportHeaders&amp; responseHeaders, Stream&amp; responseStream) at System.Runtime.Remoting.Channels.BinaryClientFormatterSink.SyncProcessMessage(IMessage msg) Exception rethrown at [0]: at System.Runtime.Remoting.Proxies.RealProxy.HandleReturnMessage(IMessage reqMsg, IMessage retMsg) at System.Runtime.Remoting.Proxies.RealProxy.PrivateInvoke(MessageData&amp; msgData, Int32 type) at Microsoft.VisualStudio.IntegrationTest.Utilities.InProcess.VisualStudioWorkspace_InProc.CleanUpWaitingService() at Microsoft.VisualStudio.IntegrationTest.Utilities.VisualStudioInstance.CleanUp() at Microsoft.VisualStudio.IntegrationTest.Utilities.VisualStudioInstanceContext.Dispose() at Roslyn.VisualStudio.IntegrationTests.AbstractIntegrationTest.Dispose() in q:\roslyn\src\VisualStudio\IntegrationTest\IntegrationTests\AbstractIntegrationTest.cs:line 20 at ReflectionAbstractionExtensions.DisposeTestClass(ITest test, Object testClass, IMessageBus messageBus, ExecutionTimer timer, CancellationTokenSource cancellationTokenSource) in C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Extensions\ReflectionAbstractionExtensions.cs:line 76
```</Description>
        <CreatedDate>08/03/2017</CreatedDate>
        <ClosedDate>04/03/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>17634</IssueID>
        <Title>RemotingException : Requested Service not found in Integration tests</Title>
        <Description>Tests fail randomly because of that:

1. https://ci.dot.net/job/dotnet_roslyn/job/master/job/windows_release_vs-integration_prtest/932/testReport/junit/Roslyn.VisualStudio.IntegrationTests.VisualBasic/CSharpChangeSignatureDialog/VerifyReorderParameters/
2. https://ci.dot.net/job/dotnet_roslyn/job/master/job/windows_release_vs-integration_prtest/934/testReport/junit/Roslyn.VisualStudio.IntegrationTests.VisualBasic/CSharpChangeSignatureDialog/VerifyReorderParameters/
3. https://ci.dot.net/job/dotnet_roslyn/job/master/job/windows_debug_vs-integration_prtest/953/testReport/junit/Roslyn.VisualStudio.IntegrationTests.VisualBasic/BasicChangeSignatureDialog/VerifyRefactoringCancelled/
4. https://ci.dot.net/job/dotnet_roslyn/job/master/job/windows_debug_vs-integration_prtest/955/testReport/Roslyn.VisualStudio.IntegrationTests.VisualBasic/BasicFindReferences/FindReferencesToSharedField/

Found in #17617</Description>
        <CreatedDate>08/03/2017</CreatedDate>
        <ClosedDate>04/03/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>18295</IssueID>
        <Title>[Flaky Test] Roslyn.VisualStudio.IntegrationTests.CSharp.CSharpCodeActions.GenerateMethodInClosedFile</Title>
        <Description>https://ci.dot.net/job/dotnet_roslyn/job/master/job/windows_release_vs-integration/633/testReport/junit/Roslyn.VisualStudio.IntegrationTests.CSharp/CSharpCodeActions/GenerateMethodInClosedFile/

```
Assert.Equal() Failure
 ↓ (pos 2)
Expected: \\r\\nusing System;\\r\\n\\r\\npublic class Foo\\r\\n{\\r\\n ···
Actual:     \\r\\npublic class Foo\\r\\n{\\r\\n}\\r\\n
 ↑ (pos 2)
```</Description>
        <CreatedDate>29/03/2017</CreatedDate>
        <ClosedDate>18/04/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>6587</IssueID>
        <Title>Add Imports not offered after first submission</Title>
        <Description>1. `#r "System.Xml"`
2. `typeof(ArrayList)`

Expected: Lightbulb offering to import `System.Collections`
Actual: No lightbulb
</Description>
        <CreatedDate>05/11/2015</CreatedDate>
        <ClosedDate>05/03/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>17640</IssueID>
        <Title>CSharpChangeSignatureDialog.VerifyReorderParameters is failing</Title>
        <Description>https://ci.dot.net/job/dotnet_roslyn/job/master/job/windows_debug_vs-integration_prtest/968/testReport/junit/Roslyn.VisualStudio.IntegrationTests.VisualBasic/CSharpChangeSignatureDialog/VerifyReorderParameters/
https://ci.dot.net/job/dotnet_roslyn/job/dev16/job/windows_release_vs-integration_prtest/24/
</Description>
        <CreatedDate>08/03/2017</CreatedDate>
        <ClosedDate>07/04/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19232</IssueID>
        <Title>CSharpInteractive.TypingHelpDirectiveWorks   is flaky</Title>
        <Description>reported as flaky
</Description>
        <CreatedDate>04/05/2017</CreatedDate>
        <ClosedDate>04/03/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>20219</IssueID>
        <Title>Integration test failures due to `AnnotationTagger`</Title>
        <Description>Dump at `https://ci.dot.net/job/dotnet_roslyn/job/master/job/windows_debug_vs-integration/1160/artifact/Binaries/Debug/`

This appears to affect REPL and possibly other projection scenarios.

```
System.NullReferenceException: Object reference not set to an instance of an object.
   at Microsoft.VisualStudio.Editor.Implementation.AnnotationTagger.&lt;GetTags&gt;d__10.MoveNext()
   at Microsoft.VisualStudio.Text.Tagging.Implementation.TagAggregator`1.&lt;GetTagsForBuffer&gt;d__39.MoveNext()
```</Description>
        <CreatedDate>14/06/2017</CreatedDate>
        <ClosedDate>24/05/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/VisualStudio/IntegrationTest/IntegrationTests/AbstractIntegrationTest.cs</File>
      <File>src/VisualStudio/IntegrationTest/IntegrationTests/CSharp/CSharpChangeSignatureDialog.cs</File>
      <File>src/VisualStudio/IntegrationTest/IntegrationTests/CSharp/CSharpCodeActions.cs</File>
      <File>src/VisualStudio/IntegrationTest/IntegrationTests/CSharp/CSharpFindReferences.cs</File>
      <File>src/VisualStudio/IntegrationTest/IntegrationTests/CSharp/CSharpInteractive.cs</File>
      <File>src/VisualStudio/IntegrationTest/IntegrationTests/CSharp/CSharpReplIdeFeatures.cs</File>
      <File>src/VisualStudio/IntegrationTest/IntegrationTests/VisualBasic/BasicFindReferences.cs</File>
      <File>src/VisualStudio/IntegrationTest/TestUtilities/DialogHelpers.cs</File>
      <File>src/VisualStudio/IntegrationTest/TestUtilities/InProcess/TextViewWindow_InProc.cs</File>
      <File>src/VisualStudio/IntegrationTest/TestUtilities/OutOfProcess/ChangeSignatureDialog_OutOfProc.cs</File>
      <File>src/VisualStudio/IntegrationTest/TestUtilities/OutOfProcess/ExtractInterfaceDialog_OutOfProc.cs</File>
      <File>src/VisualStudio/IntegrationTest/TestUtilities/OutOfProcess/GenerateTypeDialog_OutOfProc.cs</File>
      <File>src/VisualStudio/IntegrationTest/TestUtilities/OutOfProcess/TextViewWindow_OutOfProc.Verifier.cs</File>
      <File>src/VisualStudio/IntegrationTest/TestUtilities/VisualStudioInstance.cs</File>
      <File>src/Workspaces/Core/Portable/Log/KeyValueLogMessage.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>25150</IssueID>
    <Title>Localization test failures VB CodeGenRefReturnTests.RefReturnLateBoundCall</Title>
    <Description>### Customer scenario

Running unit test CodeGenRefReturnTests.RefReturnLateBoundCall on non English machines fails due to localization issues. The recommended fix by @AlekseyTs was:

&gt; Modify code in the Main function above to change to invariant culture and restore at the end. The same way as it is done in Spilling_ExceptionInArrayAccess unit test for example.

This PR fixes the test as proposed with the deviation that it sets and restores the `CurrentThread.CurrentCulture` instead of `CurrentThread.CurrentUICulture`. See also #24602 for more details.

With this change in place the unit test does not fail on a German machine.

### Bugs this fixes

#24602 

### Workarounds, if any

Ignore test failure.

### Risk

Low. Test only change.

### Performance impact

None. Test only.

### Is this a regression from a previous update?

No.

### Root cause analysis

Test only fails on non English machines. 

### How was the bug found?

Reported by contributor

### Test documentation updated?

No.
</Description>
    <CreatedDate>01/03/2018</CreatedDate>
    <ClosedDate>01/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>24602</IssueID>
        <Title>Test localization failures on non english machines: CodeGenRefReturnTests.RefReturnLateBoundCall</Title>
        <Description>Extracted from the closed PR #24539 

**Steps to Reproduce**:

Run `Microsoft.CodeAnalysis.VisualBasic.UnitTests.CodeGenRefReturnTests.RefReturnLateBoundCall` on a non-english machine.

**Expected Behavior**:

Test passes.

**Actual Behavior**:

Test fails because the `expectedOutput:="Public member 'G' on type 'A' not found."` is culture dependent.

**History**

The issue was discussed but not resolved in #24539. The relevant sections are:

```
' This test failes on non english machines. 
' The expected output is generated by the runtime and is localized with the culture of the current machine. 
' Localized StringRessources of the runtime are not part of the Roslyn solution. 
' Setting DefaultThreadCurrentCulture to en-US does not help because CompileAndVerify starts an AppDomain. 
```

@AlekseyTs:

&gt; Modify code in the Main function above to change to invariant culture and restore at the end. The same way as it is done in Spilling_ExceptionInArrayAccess unit test for example.</Description>
        <CreatedDate>02/02/2018</CreatedDate>
        <ClosedDate>02/03/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>24602</IssueID>
        <Title>Test localization failures on non english machines: CodeGenRefReturnTests.RefReturnLateBoundCall</Title>
        <Description>Extracted from the closed PR #24539 

**Steps to Reproduce**:

Run `Microsoft.CodeAnalysis.VisualBasic.UnitTests.CodeGenRefReturnTests.RefReturnLateBoundCall` on a non-english machine.

**Expected Behavior**:

Test passes.

**Actual Behavior**:

Test fails because the `expectedOutput:="Public member 'G' on type 'A' not found."` is culture dependent.

**History**

The issue was discussed but not resolved in #24539. The relevant sections are:

```
' This test failes on non english machines. 
' The expected output is generated by the runtime and is localized with the culture of the current machine. 
' Localized StringRessources of the runtime are not part of the Roslyn solution. 
' Setting DefaultThreadCurrentCulture to en-US does not help because CompileAndVerify starts an AppDomain. 
```

@AlekseyTs:

&gt; Modify code in the Main function above to change to invariant culture and restore at the end. The same way as it is done in Spilling_ExceptionInArrayAccess unit test for example.</Description>
        <CreatedDate>02/02/2018</CreatedDate>
        <ClosedDate>02/03/2018</ClosedDate>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>25131</IssueID>
    <Title>Check generic construction diagnostics for stackalloc to span conversions</Title>
    <Description>Closes #25086
Closes #25038

There is a bug in C# 15.5, where during the conversion of a `stackalloc` expression to a `Span&lt;T&gt;` object creation, the type parameter construction and constraints matching were not checked during binding.

Fixing this for 15.7 is a breaking change, because an expression of `stackalloc T [count]` would be legal even if `T` was not legal to initialize `Span&lt;T&gt;` with. We would previously emit IL even if it would cause run time exceptions. do believe that the scope is small enough for us to take the breaking change though.</Description>
    <CreatedDate>28/02/2018</CreatedDate>
    <ClosedDate>06/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>25086</IssueID>
        <Title>Test Span&lt;T&gt; with constraint on T</Title>
        <Description>From https://github.com/dotnet/roslyn/pull/25035#issuecomment-368637816
A comment from Aleksey in another PR made me think of this: what if you create a custom Span&lt;T&gt; type with some constraints on T. Do we properly check and report on such constraints?
See BindStackAllocArrayCreationExpression line 3130 (type = spanType.Construct(elementType);).</Description>
        <CreatedDate>27/02/2018</CreatedDate>
        <ClosedDate>06/03/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>25038</IssueID>
        <Title>Span&lt;RefStruct&gt; is permitted through an implicitly-typed variable</Title>
        <Description>**Version Used**: https://github.com/dotnet/roslyn/commit/37e71921d2f539854ec3a5ebd45cdda5a1a5eccf head of `features/compilers`

**Steps to Reproduce**:

```cs
ref struct S {}

void M(bool c) {
  // ERROR: The type 'S' may not be used as a type argument
  Span&lt;S&gt; x = c ? stackalloc S[2] : stackalloc S[3]; 

  // OK?
  var y = c ? stackalloc S[2] : stackalloc S[3]; 
}
```

**Expected Behavior**: error in both cases

**Actual Behavior**: error only if `S` is spelt out
</Description>
        <CreatedDate>24/02/2018</CreatedDate>
        <ClosedDate>06/03/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Expressions.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/StackAllocSpanExpressionsTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>25105</IssueID>
    <Title>Switch to UIAComWrapper for integration test interop</Title>
    <Description>Fixes #17680
Fixes #21154
Fixes #25097
Fixes #25120

Improves #17393</Description>
    <CreatedDate>27/02/2018</CreatedDate>
    <ClosedDate>02/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>17680</IssueID>
        <Title>Many dialog-based integration tests are failing</Title>
        <Description>https://github.com/dotnet/roslyn/pull/17655#issuecomment-285482257
https://github.com/dotnet/roslyn/pull/17654#issuecomment-285496301
https://github.com/dotnet/roslyn/issues/17640</Description>
        <CreatedDate>10/03/2017</CreatedDate>
        <ClosedDate>02/03/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>21154</IssueID>
        <Title>VS test hangs in GenerateTypeDialog</Title>
        <Description>Lots of the hangs have this as their cause...</Description>
        <CreatedDate>26/07/2017</CreatedDate>
        <ClosedDate>02/03/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>25097</IssueID>
        <Title>Modal Dialog Showing during refactoring tests</Title>
        <Description>A number of integration tests have been hanging because of a change signature modal dialog popping up. I copied a couple of dumps from test runs to "\\mlangfs1\public\frsilb\dumps\devenv_modal_test_hang" for investigation. FYI @jasonmalinowski. @jinujoseph, can you assign this to someone to take a look?</Description>
        <CreatedDate>27/02/2018</CreatedDate>
        <ClosedDate>02/03/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>25120</IssueID>
        <Title>CSharpEncapsulateField.EncapsulateThroughCommand Failure</Title>
        <Description>```
Roslyn.VisualStudio.IntegrationTests.CSharp.CSharpEncapsulateField.EncapsulateThroughCommand
      System.Windows.Automation.ElementNotAvailableException : Unrecognized error.
      Stack Trace:
           at MS.Internal.Automation.UiaCoreApi.CheckError(Int32 hr)
           at MS.Internal.Automation.UiaCoreApi.UiaGetUpdatedCache(SafeNodeHandle hnode, UiaCacheRequest request, NormalizeState normalize, Condition customCondition)
           at System.Windows.Automation.AutomationElement.FromHandle(IntPtr hwnd)
           at Microsoft.VisualStudio.IntegrationTest.Utilities.DialogHelpers.FindDialogByPropertyWorker(Int32 visualStudioHWnd, String propertyValue, AutomationProperty nameProperty)
           at Microsoft.VisualStudio.IntegrationTest.Utilities.DialogHelpers.FindDialogByNameWorker(Int32 visualStudioHWnd, String dialogName)
           at Microsoft.VisualStudio.IntegrationTest.Utilities.DialogHelpers.&lt;&gt;c__DisplayClass2_0.&lt;FindDialogByName&gt;b__0()
           at Microsoft.VisualStudio.IntegrationTest.Utilities.DialogHelpers.Retry[T](Func`1 action, Func`2 stoppingCondition, TimeSpan delay)
           at Microsoft.VisualStudio.IntegrationTest.Utilities.DialogHelpers.FindDialogByName(Int32 visualStudioHWnd, String dialogName, Boolean isOpen)
        /_/src/VisualStudio/IntegrationTest/IntegrationTests/CSharp/CSharpEncapsulateField.cs(43,0): at Roslyn.VisualStudio.IntegrationTests.CSharp.CSharpEncapsulateField.EncapsulateThroughCommand()
```
Failed on this line: https://github.com/dotnet/roslyn/blob/6b99a66af076f94ce05bfb6c8a3b2c36e95f6f20/src/VisualStudio/IntegrationTest/IntegrationTests/CSharp/CSharpEncapsulateField.cs#L43

Screenshot:
![image](https://user-images.githubusercontent.com/2371880/36806409-c96a5b96-1c74-11e8-93fb-c9db2310ab8c.png)
</Description>
        <CreatedDate>28/02/2018</CreatedDate>
        <ClosedDate>02/03/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>17393</IssueID>
        <Title>BasicChangeSignatureDialog.VerifyCodeRefactoringOffered fails on jenkins</Title>
        <Description>
        </Description>
        <CreatedDate>26/02/2017</CreatedDate>
        <ClosedDate>14/02/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/VisualStudio/IntegrationTest/IntegrationTests/AbstractEditorTest.cs</File>
      <File>src/VisualStudio/IntegrationTest/IntegrationTests/CSharp/CSharpChangeSignatureDialog.cs</File>
      <File>src/VisualStudio/IntegrationTest/IntegrationTests/CSharp/CSharpExtractMethod.cs</File>
      <File>src/VisualStudio/IntegrationTest/IntegrationTests/CSharp/CSharpGenerateTypeDialog.cs</File>
      <File>src/VisualStudio/IntegrationTest/IntegrationTests/VisualBasic/BasicGenerateTypeDialog.cs</File>
      <File>src/VisualStudio/IntegrationTest/TestUtilities/DialogHelpers.cs</File>
      <File>src/VisualStudio/IntegrationTest/TestUtilities/InProcess/InteractiveWindow_InProc.cs</File>
      <File>src/VisualStudio/IntegrationTest/TestUtilities/OutOfProcess/ChangeSignatureDialog_OutOfProc.cs</File>
      <File>src/VisualStudio/IntegrationTest/TestUtilities/OutOfProcess/Dialog_OutOfProc.cs</File>
      <File>src/VisualStudio/IntegrationTest/TestUtilities/OutOfProcess/ExtractInterfaceDialog_OutOfProc.cs</File>
      <File>src/VisualStudio/IntegrationTest/TestUtilities/OutOfProcess/GenerateTypeDialog_OutOfProc.cs</File>
      <File>src/VisualStudio/IntegrationTest/TestUtilities/OutOfProcess/PreviewChangesDialog_OutOfProc.cs</File>
      <File>src/VisualStudio/IntegrationTest/TestUtilities/OutOfProcess/TextViewWindow_OutOfProc.Verifier.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>25101</IssueID>
    <Title>Cover test plan for "stackalloc initializers"</Title>
    <Description>tracking issues: #24699 and #24983</Description>
    <CreatedDate>27/02/2018</CreatedDate>
    <ClosedDate>05/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>24699</IssueID>
        <Title>Test plan for "stackalloc initializers"</Title>
        <Description>This is a place to collect test ideas and track work items.
Relates to https://github.com/dotnet/csharplang/pull/1122

- [ ] optimization and endianess issue
- [ ] Test `GetOperation`
- [ ] Test [IDE scenarios](https://github.com/dotnet/roslyn/wiki/Manual-Testing)

Tagging @alrz 

</Description>
        <CreatedDate>07/02/2018</CreatedDate>
        <ClosedDate>01/03/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>24983</IssueID>
        <Title>Testplan for stackalloc initializers</Title>
        <Description>I have added a testplan for stackalloc initializers.

Normally we would just create an issue with checkboxes, but I think issues are not all-editable, while docs can be changed in PRs.

Let me know if there is a better way.

The doc is - https://github.com/dotnet/roslyn/blob/features/stackalloc-init/docs/compilers/CSharp/testplans/stackalloc_initializers.md
</Description>
        <CreatedDate>22/02/2018</CreatedDate>
        <ClosedDate>01/03/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Expressions.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/StackAllocInitializerTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/StackAllocInitializerTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>25087</IssueID>
    <Title>Use IsNullable=null for types from unannotated assemblies</Title>
    <Description>Treat reference types from unannotated assemblies (and from compilations compiled with C#7) as "null oblivious".

`IsNullable` is set to `null` for reference types in member signatures for PE symbols and for source symbols compiled when `LanguageVersion &lt; Latest`. 

Many of the changes in the PR are simply passing the `ContainingModule` to `TypeSymbolWithAnnotations.Create()` so that method can determine whether to set `IsNullable` for the resulting type.

There are still several cases where reference types have `IsNullable` set (incorrectly) in member signatures when `LanguageVersion &lt; Latest`:
- Type parameter constraint types
- Type arguments in parameter and return types for explicit implementations
- Type arguments in parameter and return types of overridden generic methods

The incorrect `IsNullable` state is not observable within that project (nullable warnings are not generated if feature is not enabled), and it is not observable when referencing the generated assembly in another project (no `[Nullable]` attributes are emitted). But it is observable when referencing such a project from a C#8 project through a project-to-project reference.
</Description>
    <CreatedDate>27/02/2018</CreatedDate>
    <ClosedDate>01/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>7</IssueID>
        <Title>Feature: Parameter Name Aliasing</Title>
        <Description>The human meaning of parameters may vary from method caller's perspective.

It would be useful if the language provides an ability to assign aliases to the parameters.

``` C#
[Alias({second: [secondAndHalf, quarterToThree], first: [Initial]})] 
public static void Member1(string first, string second) { 
  // Here the user will always use the given names: first and second.
  // which means the user cannot use the param by its nickname
  // inside the method scope.
}

private static void Caller1() {
  Member1(secondAndHalf: "secondly, this is not a bad idea after all",
          Initial: "Initially it sounded moot... :)  ");
}

private static void Caller2() {
  Member1(first: "1st",
          quarterToThree: "almost there");
}

private static void Caller3() {
  Member1("one", "two");
}
```

vs. this current approach:

``` c#
public static void Member1(string first, string second) {  }

public static void Member1(string first, string secondAndHalf, string devNull = null) { 
  Member1(first, secondAndHalf);
}
```

Note: the parameter `devNull` may violate [CA1026](http://msdn.microsoft.com/en-us/library/ms182135.aspx), in case of `overridden` methods. On the flip side, setting `devNull` as non-default parameter would yield "unused parameter".

Related / Real world example: https://github.com/madskristensen/WebEssentials2013/pull/380#issuecomment-31402391
</Description>
        <CreatedDate>15/01/2015</CreatedDate>
        <ClosedDate>26/08/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>8</IssueID>
        <Title>Feature request: Async stream generators</Title>
        <Description>Currenty C# supports pull based sequence generators. 
As IObservable&amp;lt;T&amp;gt; and IObserver&amp;lt;T&amp;gt; are now in mscorlib and Rx is such a success not only in .NET but in other languages and runtimes  why not to add to C# ability to easily create async push based stream generators.

It could look like this:

``` C#
private async IObservable&lt;string&gt; GetData()
{ 
    var data = await MakeRequest();
    yield return data;
    yield return await MakeAnotherRequest();
}
```

It would complete language support in the matrix of generators:

|  | sync | async |
| --- | --- | --- |
| **single** | T | Task&amp;lt;T&amp;gt; |
| **multiple** | IEnumerable&amp;lt;T&amp;gt; | IObservable&amp;lt;T&amp;gt; |
</Description>
        <CreatedDate>15/01/2015</CreatedDate>
        <ClosedDate>29/01/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Patterns.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Symbols.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/VariablePendingInference.cs</File>
      <File>src/Compilers/CSharp/Portable/Emitter/Model/PEAssemblyBuilder.cs</File>
      <File>src/Compilers/CSharp/Portable/Emitter/Model/PEModuleBuilder.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/LambdaRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/SymbolDisplay/SymbolDisplayVisitor.Types.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/AbstractTypeMap.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/AnonymousTypes/SynthesizedSymbols/AnonymousType.TemplateSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ConstructedNamedTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ErrorTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/NullableTypeDecoder.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PEEventSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PEFieldSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PEModuleSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PENamedTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PEParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PEPropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PETypeParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/NamedTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Retargeting/RetargetingNamedTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/CustomModifierUtils.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/GlobalExpressionVariable.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceConstructorSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceDelegateMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceEventAccessorSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceMemberFieldSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceModuleSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceNamedTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourcePropertyAccessorSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Symbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/SymbolWithAnnotations.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedContainer.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedEntryPointSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedInstanceConstructor.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedInteractiveInitializerMethod.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedStaticConstructor.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Tuples/TupleTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Test/CommandLine/CommandLineTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Attributes/AttributeTests_Nullable.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IArgument.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/OutVarTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/StaticNullChecking.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/StaticNullChecking_FlowAnalysis.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/StaticNullChecking_TypeInference.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/SymbolDisplay/SymbolDisplayTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/GenericConstraintTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/Source/CompletionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/TypeTests.cs</File>
      <File>src/Compilers/Core/Portable/MetadataReader/PEModule.cs</File>
      <File>src/Compilers/Core/Portable/SymbolDisplay/SymbolDisplayCompilerInternalOptions.cs</File>
      <File>src/Compilers/Core/Portable/SymbolDisplay/SymbolDisplayFormat.cs</File>
      <File>src/Compilers/Test/Utilities/CSharp/CSharpTestBase.cs</File>
      <File>src/Compilers/Test/Utilities/CSharp/UsesIsNullableVisitor.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/Iterator/AddYieldTests.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Test/ExpressionCompiler/ExpressionCompilerTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>24621</IssueID>
    <Title>Refer directly to static data when ReadOnlySpan wraps arrays of bytes.</Title>
    <Description>Refer directly to static data when ReadOnlySpan wraps strings or arrays of primitive literals.
No need to allocate anything in this case.

Fixes:#23358
Related:dotnet/corefx#25413

&lt;details&gt;&lt;summary&gt;Ask Mode template not completed&lt;/summary&gt;

&lt;!-- This template is not always required. If you aren't sure about whether it's needed or want help filling out the sections,
submit the pull request and then ask us for help. :) --&gt;

### Customer scenario

What does the customer do to get into this situation, and why do we think this
is common enough to address for this release.  (Granted, sometimes this will be
obvious "Open project, VS crashes" but in general, I need to understand how
common a scenario is)

### Bugs this fixes

(either VSO or GitHub links)

### Workarounds, if any

Also, why we think they are insufficient for RC vs. RC2, RC3, or RTW

### Risk

This is generally a measure our how central the affected code is to adjacent
scenarios and thus how likely your fix is to destabilize a broader area of code

### Performance impact

(with a brief justification for that assessment (e.g. "Low perf impact because no extra allocations/no complexity changes" vs. "Low")

### Is this a regression from a previous update?

### Root cause analysis

How did we miss it?  What tests are we adding to guard against it in the future?

### How was the bug found?

(E.g. customer reported it vs. ad hoc testing)

### Test documentation updated?

If this is a new non-compiler feature or a significant improvement to an existing feature, update https://github.com/dotnet/roslyn/wiki/Manual-Testing once you know which release it is targeting.

&lt;/details&gt;
</Description>
    <CreatedDate>03/02/2018</CreatedDate>
    <ClosedDate>05/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>23358</IssueID>
        <Title>Optimize implicit casts from string literals to ReadOnlySpan&lt;char&gt;</Title>
        <Description>If possible, we should just point to the underlying data of the string.

Ideally there is a helper that takes a string token or something like that - to avoid directly dealing with pointers, which us formally unsafe.

realted to: https://github.com/dotnet/corefx/issues/25413
</Description>
        <CreatedDate>22/11/2017</CreatedDate>
        <ClosedDate>06/03/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>25413</IssueID>
        <Title>Merge ref reassignment into 15.7</Title>
        <Description>The test plan for ref-reassignment is at https://github.com/dotnet/roslyn/issues/22466 and has already been reviewed. The blocking issues were

- Language version checks for ref in for &amp; foreach
- Additional tests around ++ and ref assignment expressions
- Tests for ?., IDisposable, and ref assignment expressions
- Additional semantic model tests
- Additional IOperation tests

as well as the IDE checklist. These have all been completed, therefore this should be ready to merge.</Description>
        <CreatedDate>12/03/2018</CreatedDate>
        <ClosedDate>12/03/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/CodeGen/EmitArrayInitializer.cs</File>
      <File>src/Compilers/CSharp/Portable/CodeGen/EmitConversion.cs</File>
      <File>src/Compilers/CSharp/Portable/CodeGen/EmitExpression.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_Conversion.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Compilation_WellKnownMembers.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenReadOnlySpanConstructionTest.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/ForeachTest.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/MissingSpecialMember.cs</File>
      <File>src/Compilers/Core/Portable/CodeGen/ILBuilderEmit.cs</File>
      <File>src/Compilers/Core/Portable/WellKnownMember.cs</File>
      <File>src/Compilers/Core/Portable/WellKnownMembers.cs</File>
      <File>src/Compilers/Test/Utilities/CSharp/CSharpTestBase.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>24022</IssueID>
    <Title>Ambiguous type codefix provider (using alias)</Title>
    <Description>### Customer scenario

Codefix for `CS0104 'reference' is an ambiguous reference between 'identifier' and 'identifier'` (BC30561 in VB). 

Before:
```C#
using N1;
using N2;

namespace N1
{
    public class AmbiguousClass { }
}
namespace N2
{
    public class AmbiguousClass { }
}
namespace NTest
{
    public class Test: AmbiguousClass //CS0104
    {
    }
}
```
After
```C#
using N1;
using N2;
using AmbiguousClass = N1.AmbiguousClass; // Fix

namespace N1
{
    public class AmbiguousClass { }
}
namespace N2
{
    public class AmbiguousClass { }
}
namespace NTest
{
    public class Test: AmbiguousClass
    {
    }
}
```

![2018-01-03 20_31_22-](https://user-images.githubusercontent.com/24472128/34536366-28c61dcc-f0c5-11e7-9ced-452894c3e672.png)

### Bugs this fixes

Feature request #23373.

### Workarounds, if any

Fully qualify type.

### Risk

Golden bar from failing code fix provider.

### Performance impact

Low. Code fix is only triggered by one diagnostic (CS0104 or BC30561)

### Is this a regression from a previous update?

New feature.

### Root cause analysis

User request to get closer to parity with Resharper.

### How was the bug found?

Customer reported #23373. 

### Test documentation updated?

No.

### Remarks

Update 8/1/18: This is resolved:
~I tried to use `class GroupingCodeAction : CodeAction.CodeActionWithNestedActions` to group the re-factorings like [here](https://github.com/dotnet/roslyn/blob/19001be93af8a5e6422899c0b3e0c736fde67482/src/Features/Core/Portable/FullyQualify/AbstractFullyQualifyCodeFixProvider.cs#L81) but then all tests were failing and in VS it didn't made a difference whether I use `CodeActionWithNestedActions` or register a code fix per ambiguous type. The FeaturesResources.Alias_ambiguous_type_0 text template was created to work with `CodeActionWithNestedActions` and therefore the text template is inadequate in the context it is used now.~
</Description>
    <CreatedDate>03/01/2018</CreatedDate>
    <ClosedDate>13/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>23373</IssueID>
        <Title>Ambiguous type reference should suggest adding a using alias</Title>
        <Description>(Following the pattern of reporting my most frequent ReSharper quick actions with the goal of being able to use vanilla VS one day.)

Most times that I have an ambiguous type reference I don't want to resolve it by fully qualifying. It can appear many files in a file. My resolution of choice is to add `using TypeName = The.Namespace.I.Want.TypeName`.</Description>
        <CreatedDate>24/11/2017</CreatedDate>
        <ClosedDate>27/03/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23373</IssueID>
        <Title>Ambiguous type reference should suggest adding a using alias</Title>
        <Description>(Following the pattern of reporting my most frequent ReSharper quick actions with the goal of being able to use vanilla VS one day.)

Most times that I have an ambiguous type reference I don't want to resolve it by fully qualifying. It can appear many files in a file. My resolution of choice is to add `using TypeName = The.Namespace.I.Want.TypeName`.</Description>
        <CreatedDate>24/11/2017</CreatedDate>
        <ClosedDate>27/03/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/AliasAmbiguousType/AliasAmbiguousTypeTests.cs</File>
      <File>src/EditorFeatures/TestUtilities/Traits.cs</File>
      <File>src/Features/CSharp/Portable/AliasAmbiguousType/CSharpAliasAmbiguousTypeCodeFixProvider.cs</File>
      <File>src/Features/Core/Portable/AliasAmbiguousType/AbstractAliasAmbiguousTypeCodeFixProvider.cs</File>
      <File>src/Features/Core/Portable/CodeFixes/PredefinedCodeFixProviderNames.cs</File>
      <File>src/Features/Core/Portable/FeaturesResources.Designer.cs</File>
      <File>src/Workspaces/CSharp/Portable/CodeGeneration/CSharpSyntaxGenerator.cs</File>
      <File>src/Workspaces/Core/Portable/Editing/SyntaxGenerator.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23587</IssueID>
    <Title>Add parentheses around conditional expression in interpolated string code fix provider</Title>
    <Description>### Customer scenario

Code fix for a conditional expression in interpolated string. Adds parenthesis around the expression.

Before (invalid code with compiler error CS8361):
```CSharp
$"{1 / Environment.TickCount == 0 ? 1 : 2}"
```
After:
```CSharp
$"{(1 / Environment.TickCount == 0 ? 1 : 2 )}"
```
This is a code fix for compiler error ERR_ConditionalInInterpolation = CS8361 introduced in  #23265.

### Bugs this fixes

#23323 

### Workarounds, if any

Add parenthesis by hand.

### Risk

Low. Specialized code fix for a very narrow compiler error.

### Performance impact

Low. Specialized code fix for a very narrow compiler error.

### Is this a regression from a previous update?

No.

### Root cause analysis

New feature.

### How was the bug found?

The need to add parenthesis caused confusion in the past. CS8361 was therefore introduced to improve the story. This is a follow up to further enhance the situation.

### Test documentation updated?</Description>
    <CreatedDate>05/12/2017</CreatedDate>
    <ClosedDate>05/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>23265</IssueID>
        <Title>Improve the syntax error when a conditional expression used in an interpolated string</Title>
        <Description>**Customer scenario**

When using a conditional expression `e1 ? e2 : e3` inside of an interpolated string `$"{e1 ? e2 : e3}"` the compiler interprets the colon as the end of the interpolation and the beginning of the format string. That is by design and intentional. However, the error message for this situation is confusing: the syntax error points at the colon token and reports that a colon was expected. We need a more clear diagnostic. After this fix, the error message will be
`error CS8361: A conditional expression cannot be used directly in a string interpolation because the ':' ends the interpolation. Parenthesize the conditional expression.`

**Bugs this fixes:**

Fixes #12214

**Workarounds, if any**

Parenthesize the interpolated string fill-in.

**Risk**

Low. The fix is straightforward and merely changes the diagnostic under this particular circumstance.

**Performance impact**

None expected.

**Is this a regression from a previous update?**

No.

**Root cause analysis:**

We simply did not have time to do a good job on the diagnostic for this situation when interpolated strings were first introduced.

**How was the bug found?**

This was a known shortcoming of the implementation.

**Test documentation updated?**

N/A

@dotnet/roslyn-compiler Please review.
</Description>
        <CreatedDate>17/11/2017</CreatedDate>
        <ClosedDate>21/11/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23323</IssueID>
        <Title>Would like code fix that fixes conditional expression in an interpolation</Title>
        <Description>See https://github.com/dotnet/roslyn/issues/12214#issuecomment-345451129

When an interpolation in an interpolated string contains a conditional expression, the colon is considered to be a delimiter that begins the format string. Thus the conditional expression will be a syntax error. We give a nice syntax error that is specific to this situation. It would be nice to have a code fixer that implements the suggested fix of parenthesizing the conditional expression.</Description>
        <CreatedDate>21/11/2017</CreatedDate>
        <ClosedDate>08/03/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/ConditionalExpressionInStringInterpolation/CSharpAddParenthesesAroundConditionalExpressionInInterpolatedStringCodeFixProviderTests.cs</File>
      <File>src/EditorFeatures/TestUtilities/Traits.cs</File>
      <File>src/Features/CSharp/Portable/CSharpFeaturesResources.Designer.cs</File>
      <File>src/Features/CSharp/Portable/CodeFixes/ConditionalExpressionInStringInterpolation/CSharpAddParenthesesAroundConditionalExpressionInInterpolatedStringCodeFixProvider.cs</File>
      <File>src/Features/Core/Portable/CodeFixes/PredefinedCodeFixProviderNames.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23049</IssueID>
    <Title>Support GotoDefinition in LINQ query syntax</Title>
    <Description>**Customer scenario**

Support *GotoDefinition* for LINQ query syntax. Enables Ctrl+Click and tool-tip info for LINQ query clauses. Proposal #23394.

*GotoDefinition* and *QuickInfo* are finding the right overloads in `System.Linq.Enumerable`,  `System.Linq.Queryable` and the  [query expression pattern](https://github.com/ljw1004/csharpspec/blob/gh-pages/expressions.md#the-query-expression-pattern) depending on the source.

![gotodefinitionlinq](https://user-images.githubusercontent.com/24472128/33327545-0d2bb59c-d458-11e7-9aaf-0ad7e030cf5f.gif)

(Use [gif-explode](http://gif-explode.com/?explode=https://user-images.githubusercontent.com/24472128/33327545-0d2bb59c-d458-11e7-9aaf-0ad7e030cf5f.gif) to view the single frames).

**Bugs this fixes:**

Feature request #22096 by @dpoeschl.

**Workarounds, if any**

New feature.

**Risk**

Performance degradation in the editor. VS crashes.

**Performance impact**

Unknown.

**Is this a regression from a previous update?**

No.

**Root cause analysis:**

Support for LINQ query syntax was already included but was missing some features (only `select` and `group by` was supported and `UnoptimizedForm` of the query was not taken into account as fall-back).

**How was the bug found?**

Feature request #22096 and proposal #23394.

**Test documentation updated?**

No.</Description>
    <CreatedDate>07/11/2017</CreatedDate>
    <ClosedDate>21/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>23394</IssueID>
        <Title>Proposal: Support QuickInfo and GotoDefinition in LINQ query syntax </Title>
        <Description>Implementation started #23049 (This proposal is extracted from the discussion there. Remarks by @sharwell are incorporated)

Objective: Enhance the support for GotoDefinition and QuickInfo for [LINQ query syntax](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/expressions#query-expressions) by exposing the underlying transformations (QuickInfo and GotoDefinition are already working for a limited set of clauses. This proposal describes a coherent behavior for all clauses and transformations).

As a general guidance for the proposal I tried to stay close to the [query expressions section of the C# spec](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/expressions#query-expressions). That means quick info should show the actual method mapping after all the transformations are completed.

Some general rules:
* Quick info for parameter info is kept as is
* Quick info for clauses that directly map to methods is enhanced
* For those clauses that don't directly map to a method a hint is shown: "This clause isn't mapped to an method call due to optimizations." or if this is not possible no quick info is shown.
* Goto definition is only supported for clauses that directly map to a method

These clauses map directly to method calls (**bold** are the clauses that show quick info).

| ID | Topic      | Example                                                                  | Quick info               | Goto definition | 
|----|------------|--------------------------------------------------------------------------|--------------------------|-----------------| 
| 1  | SelectMany | from l1 in l&lt;br&gt; **from** l2 **in** l1                                   | SelectMany method            | yes             | 
| 2  | Where      | from l1 in l&lt;br&gt; **where** true                                          | Where method             | yes             | 
| 3  | Group by   | from l1 in l&lt;br&gt; **group** l1 **by** l.Item1 into g                      | Group method             | yes             | 
| 4  | Join       | from l1 in l&lt;br&gt; **join** n **in** numbers **on** l1 **equals** n into g | Join or GroupJoin method | Yes             | 
| 5  | Select (only if mapped to a Select method)    | from l1 in l&lt;br&gt;**select** l1         | Select method (see also below) | Yes       |
| 6  | Select for let | from l1 in l&lt;br&gt;**let** v=true&lt;br&gt;select v                           | Select method (see also below) | Yes       |
| 7  | From variable types | **from** double d **in** l1                           | Cast method              | Yes             |
| 8  | Join variable types | join T x **in** e on k1 equals k2            | Cast method (The clauses join, on, equals are mapped to GroupJoin) | Yes  |
| 9  | From variable types for SelectMany | from l1 in l&lt;br&gt; from T l2 **in** l1            | Cast method (The from clause is mapped to SelectMany) | Yes  |

### [Degenerated methods](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/expressions#degenerate-query-expressions)

e.g.

from i in l
where true
**select** i

Quick info for `select` shows "This clause isn't mapped to an method call due to optimizations." or nothing at all. Goto definition is not available.

### select clause preceded by a join clause and other similar clauses 

e.g.

from x1 in e1
join x2 in e2 on k1 equals k2
**select** v

Quick info for `select` shows "This clause isn't mapped to an method call due to optimizations." or nothing at all. Goto definition is not available.

### orderby clause

Quick info and goto definition are available for parameters with an corresponding `orderby`, `ascending` or `descending` clause. If no `ascending` or `descending` clause is present then
* if it is the first parameter the orderby clause is used for the mapping
* otherwise the separating comma left to the parameter is used for the mapping

| Clause                                   | This method call mapping is shown                                        |
|------------------------------------------|--------------------------------------------------------------------------| 
| **orderby** a                            | mapping for parameter a                                                  | 
| orderby a **ascending**                  | mapping for parameter a                                                  | 
| **orderby** a **,** b                    | mapping for parameter a, mapping for parameter b to ThenBy is available on the comma | 
| **orderby** a, b **ascending**           | mapping for parameter a and b                                            | 
| orderby a **ascending**, b **ascending** | mapping for parameter a and b                                            | 

### let clause

Quick info reveals some transformation internals here (See also *Transparent identifiers* below). On the one hand side this is a bad thing because it unveils some intermediate types that are not really useful for the end user. But on the other side it illustrates that the let clause is nothing but a fancy select. (I do remember searching for a `Let` extension method on `Enumerable` when I used `let` for the first time.) Quick info would lighten up what is going on under the hood.

### Explicit range variable types (see cases 7, 8 and 9)

Explicit range variable are translated into a call to `Cast`. The mapping to the Cast method interferes with other mappings. The following table shows how the Cast method is mapped to the `in` clause in overlapping cases:

| Variation | Mapping | **Bold** mapping | *Italic* mapping    | Remarks |
|-----------|------------------|-------------------------|-----------------| ---|
| Simple from | **from** T i **in** l | **Cast** method                | -                | The `from` clause is not mapped to another method and the Cast can be mapped |
| SelectMany  | from i1 in l&lt;br&gt;*from* T i2 **in** i1 | **Cast** method | *SelectMany* method | The `from` clause is mapped to SelectMany and the `in` token is used to show the mapping to Cast |
| Join        | from i1 in l1 &lt;br&gt;*join* T i2 **in** l2 *on* i1 *equals* i2 | **Cast** method| *Join* method | All token are used to map to the Join method except `in` |


### Transparent identifiers

Transparent identifiers are leaking through. While the names of the transparent identifiers are not revealed they leave traces as there are anonymous types visible in quick info and so the end user gets a glimpse at the magic that is going on. In the (slightly altered) sample from the spec:
```
var lookup = new int[][] { };
var q = from i1 in lookup
        from i2 in i1
        orderby i2.ToString().Length
        select new { i1.Length, i2 };
```

The anonymous type a { int[] i1, int i2 } returned from SelectMany is visible in quick info on several occasions:

![2017-11-21 16_16_35-](https://user-images.githubusercontent.com/24472128/33080126-9bef47fc-ced7-11e7-8da3-5530629bb394.png)

![2017-11-21 16_17_15-](https://user-images.githubusercontent.com/24472128/33080112-9372d8dc-ced7-11e7-97e6-b7e851c461c0.png)

Implementation status
- [x] select (mappable)
- [x] select (unmappable)
- [x] let
- [x] where
- [x] orderby, ascending, descending
- [x] orderby mapping on comma
- [x] from, in (SelectMany)
- [x] group, by
- [x] join, in, on, equals
- [x] from in (Simple range variable)
- [x] Range variables with overlapping clauses (SelectMany and Join)

Test coverage C# Quick info
- [x] select (mappable)
- [x] select (unmappable)
- [x] let
- [x] where
- [x] orderby, ascending, descending
- [x] orderby mapping on comma
- [x] from, in (SelectMany)
- [x] group, by
- [x] join, in, on, equals
- [x] from in (Simple range variable)
- [x] Range variables with overlapping clauses (SelectMany and Join)

Test coverage C# Goto definition
- [x] select (mappable)
- [x] select (unmappable)
- [x] let
- [x] where
- [x] orderby, ascending, descending
- [x] orderby mapping on comma
- [x] from, in (SelectMany)
- [x] group, by
- [x] join, in, on, equals
- [x] from in (Simple range variable)
- [x] Range variables with overlapping clauses (SelectMany and Join)

Status VB:
No proposal, implementation and tests. Support for VB should be addressed in a follow up proposal.
</Description>
        <CreatedDate>27/11/2017</CreatedDate>
        <ClosedDate>21/03/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22096</IssueID>
        <Title>C# Ctrl-Click should be enabled for other LINQ operators</Title>
        <Description>From: https://developercommunity.visualstudio.com/content/problem/111673/c-ctrl-click-should-be-enabled-for-other-linq-oper.html

1. Try Ctrl-Click on LINQ query operator keywords

Seems only `select` has link and goes to `public interface IEnumerable&lt;out T&gt; : IEnumerable`

it would be great to navigate to `Select()` method.

Other keywords do not work: where, orderby, join, etc. </Description>
        <CreatedDate>13/09/2017</CreatedDate>
        <ClosedDate>21/03/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22096</IssueID>
        <Title>C# Ctrl-Click should be enabled for other LINQ operators</Title>
        <Description>From: https://developercommunity.visualstudio.com/content/problem/111673/c-ctrl-click-should-be-enabled-for-other-linq-oper.html

1. Try Ctrl-Click on LINQ query operator keywords

Seems only `select` has link and goes to `public interface IEnumerable&lt;out T&gt; : IEnumerable`

it would be great to navigate to `Select()` method.

Other keywords do not work: where, orderby, join, etc. </Description>
        <CreatedDate>13/09/2017</CreatedDate>
        <ClosedDate>21/03/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23394</IssueID>
        <Title>Proposal: Support QuickInfo and GotoDefinition in LINQ query syntax </Title>
        <Description>Implementation started #23049 (This proposal is extracted from the discussion there. Remarks by @sharwell are incorporated)

Objective: Enhance the support for GotoDefinition and QuickInfo for [LINQ query syntax](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/expressions#query-expressions) by exposing the underlying transformations (QuickInfo and GotoDefinition are already working for a limited set of clauses. This proposal describes a coherent behavior for all clauses and transformations).

As a general guidance for the proposal I tried to stay close to the [query expressions section of the C# spec](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/expressions#query-expressions). That means quick info should show the actual method mapping after all the transformations are completed.

Some general rules:
* Quick info for parameter info is kept as is
* Quick info for clauses that directly map to methods is enhanced
* For those clauses that don't directly map to a method a hint is shown: "This clause isn't mapped to an method call due to optimizations." or if this is not possible no quick info is shown.
* Goto definition is only supported for clauses that directly map to a method

These clauses map directly to method calls (**bold** are the clauses that show quick info).

| ID | Topic      | Example                                                                  | Quick info               | Goto definition | 
|----|------------|--------------------------------------------------------------------------|--------------------------|-----------------| 
| 1  | SelectMany | from l1 in l&lt;br&gt; **from** l2 **in** l1                                   | SelectMany method            | yes             | 
| 2  | Where      | from l1 in l&lt;br&gt; **where** true                                          | Where method             | yes             | 
| 3  | Group by   | from l1 in l&lt;br&gt; **group** l1 **by** l.Item1 into g                      | Group method             | yes             | 
| 4  | Join       | from l1 in l&lt;br&gt; **join** n **in** numbers **on** l1 **equals** n into g | Join or GroupJoin method | Yes             | 
| 5  | Select (only if mapped to a Select method)    | from l1 in l&lt;br&gt;**select** l1         | Select method (see also below) | Yes       |
| 6  | Select for let | from l1 in l&lt;br&gt;**let** v=true&lt;br&gt;select v                           | Select method (see also below) | Yes       |
| 7  | From variable types | **from** double d **in** l1                           | Cast method              | Yes             |
| 8  | Join variable types | join T x **in** e on k1 equals k2            | Cast method (The clauses join, on, equals are mapped to GroupJoin) | Yes  |
| 9  | From variable types for SelectMany | from l1 in l&lt;br&gt; from T l2 **in** l1            | Cast method (The from clause is mapped to SelectMany) | Yes  |

### [Degenerated methods](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/expressions#degenerate-query-expressions)

e.g.

from i in l
where true
**select** i

Quick info for `select` shows "This clause isn't mapped to an method call due to optimizations." or nothing at all. Goto definition is not available.

### select clause preceded by a join clause and other similar clauses 

e.g.

from x1 in e1
join x2 in e2 on k1 equals k2
**select** v

Quick info for `select` shows "This clause isn't mapped to an method call due to optimizations." or nothing at all. Goto definition is not available.

### orderby clause

Quick info and goto definition are available for parameters with an corresponding `orderby`, `ascending` or `descending` clause. If no `ascending` or `descending` clause is present then
* if it is the first parameter the orderby clause is used for the mapping
* otherwise the separating comma left to the parameter is used for the mapping

| Clause                                   | This method call mapping is shown                                        |
|------------------------------------------|--------------------------------------------------------------------------| 
| **orderby** a                            | mapping for parameter a                                                  | 
| orderby a **ascending**                  | mapping for parameter a                                                  | 
| **orderby** a **,** b                    | mapping for parameter a, mapping for parameter b to ThenBy is available on the comma | 
| **orderby** a, b **ascending**           | mapping for parameter a and b                                            | 
| orderby a **ascending**, b **ascending** | mapping for parameter a and b                                            | 

### let clause

Quick info reveals some transformation internals here (See also *Transparent identifiers* below). On the one hand side this is a bad thing because it unveils some intermediate types that are not really useful for the end user. But on the other side it illustrates that the let clause is nothing but a fancy select. (I do remember searching for a `Let` extension method on `Enumerable` when I used `let` for the first time.) Quick info would lighten up what is going on under the hood.

### Explicit range variable types (see cases 7, 8 and 9)

Explicit range variable are translated into a call to `Cast`. The mapping to the Cast method interferes with other mappings. The following table shows how the Cast method is mapped to the `in` clause in overlapping cases:

| Variation | Mapping | **Bold** mapping | *Italic* mapping    | Remarks |
|-----------|------------------|-------------------------|-----------------| ---|
| Simple from | **from** T i **in** l | **Cast** method                | -                | The `from` clause is not mapped to another method and the Cast can be mapped |
| SelectMany  | from i1 in l&lt;br&gt;*from* T i2 **in** i1 | **Cast** method | *SelectMany* method | The `from` clause is mapped to SelectMany and the `in` token is used to show the mapping to Cast |
| Join        | from i1 in l1 &lt;br&gt;*join* T i2 **in** l2 *on* i1 *equals* i2 | **Cast** method| *Join* method | All token are used to map to the Join method except `in` |


### Transparent identifiers

Transparent identifiers are leaking through. While the names of the transparent identifiers are not revealed they leave traces as there are anonymous types visible in quick info and so the end user gets a glimpse at the magic that is going on. In the (slightly altered) sample from the spec:
```
var lookup = new int[][] { };
var q = from i1 in lookup
        from i2 in i1
        orderby i2.ToString().Length
        select new { i1.Length, i2 };
```

The anonymous type a { int[] i1, int i2 } returned from SelectMany is visible in quick info on several occasions:

![2017-11-21 16_16_35-](https://user-images.githubusercontent.com/24472128/33080126-9bef47fc-ced7-11e7-8da3-5530629bb394.png)

![2017-11-21 16_17_15-](https://user-images.githubusercontent.com/24472128/33080112-9372d8dc-ced7-11e7-97e6-b7e851c461c0.png)

Implementation status
- [x] select (mappable)
- [x] select (unmappable)
- [x] let
- [x] where
- [x] orderby, ascending, descending
- [x] orderby mapping on comma
- [x] from, in (SelectMany)
- [x] group, by
- [x] join, in, on, equals
- [x] from in (Simple range variable)
- [x] Range variables with overlapping clauses (SelectMany and Join)

Test coverage C# Quick info
- [x] select (mappable)
- [x] select (unmappable)
- [x] let
- [x] where
- [x] orderby, ascending, descending
- [x] orderby mapping on comma
- [x] from, in (SelectMany)
- [x] group, by
- [x] join, in, on, equals
- [x] from in (Simple range variable)
- [x] Range variables with overlapping clauses (SelectMany and Join)

Test coverage C# Goto definition
- [x] select (mappable)
- [x] select (unmappable)
- [x] let
- [x] where
- [x] orderby, ascending, descending
- [x] orderby mapping on comma
- [x] from, in (SelectMany)
- [x] group, by
- [x] join, in, on, equals
- [x] from in (Simple range variable)
- [x] Range variables with overlapping clauses (SelectMany and Join)

Status VB:
No proposal, implementation and tests. Support for VB should be addressed in a follow up proposal.
</Description>
        <CreatedDate>27/11/2017</CreatedDate>
        <ClosedDate>21/03/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/QuickInfo/SemanticQuickInfoSourceTests.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/QuickInfo/Providers/AbstractSemanticQuickInfoProvider.cs</File>
      <File>src/Workspaces/CSharp/Portable/LanguageServices/CSharpSemanticFactsService.cs</File>
      <File>src/Workspaces/CSharp/Portable/LanguageServices/CSharpSyntaxFactsService.cs</File>
      <File>src/Workspaces/Core/Portable/LanguageServices/SemanticsFactsService/ISemanticFactsService.cs</File>
      <File>src/Workspaces/Core/Portable/LanguageServices/SyntaxFactsService/ISyntaxFactsService.cs</File>
      <File>src/Workspaces/Core/Portable/Shared/Extensions/SemanticModelExtensions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>22612</IssueID>
    <Title>restrict keywords that trigger &lt;see langword&gt; tag and don't offer tag inside XML attribute</Title>
    <Description>Fixes #22278 by restricting the keywords that will trigger the `&lt;see langword=" "&gt;`  refactoring.  Also, prevents the doc comment tags from being offered when already in an XML attribute

**Customer scenario**
When a user types a keyword in a doc comments section, they are offered a refactoring to insert a `&lt;see langword="  "&gt;` tag.  This fix restricts the keywords that trigger the refactoring to only the most likely candidates so it isn't triggered on more common words like `is`, `as`, `for`, etc...  It also prevents the refactoring from being offered when the cursor is already in an XML attribute.

**Bugs this fixes:**
#22278 

**Workarounds, if any**
n/a

**Risk**
low, this only affects the ReplaceDocCommentTextWithTag refactoring code

**Performance impact**
low since it reduces the scenarios in which this refactoring is offered.

**Is this a regression from a previous update?**
no

**Root cause analysis:**
initial design of this feature allowed all keywords in any part of the doc comments to trigger this refactoring.  

How did we miss it?  What tests are we adding to guard against it in the future?
Tests have been updated and added to cover the new scenarios

**How was the bug found?**
internal test team

**Test documentation updated?**
n/a

If this is a new non-compiler feature or a significant improvement to an existing feature, update https://github.com/dotnet/roslyn/wiki/Manual-Testing once you know which release it is targeting.
</Description>
    <CreatedDate>09/10/2017</CreatedDate>
    <ClosedDate>13/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>22278</IssueID>
        <Title>'is' keyword can be converted to "see langword" tag when it is already part of a "see langword" tag </Title>
        <Description>**Version Used**: 
VSUML 26920.4001
**Steps to Reproduce**:
1.  Create a new VB console app
2. At the start of the file, above module, add summary comments. Inside them add the text: "test 1 is"
3. Select 'is' in the comment, open up quick actions and choose "`Use &lt;see langword= "is"/&gt;`
4. Select is from inside the resulting see tag, and open up quick actions again. As you can see you can make a second tag inside the first tag.
**Expected Behavior**:
Either 'is' shouldn't be selectable at all for this action as 'is' isn't present elsewhere in the code file, or 'is' shouldn't be selectable when it is already in the tag.
**Actual Behavior**:
You're able to make a second `&lt;see langword="is"/&gt;` inside the first.
![image](https://user-images.githubusercontent.com/10537189/30723099-e3e433c4-9ee9-11e7-8cdb-767b7bd1722c.png)


</Description>
        <CreatedDate>21/09/2017</CreatedDate>
        <ClosedDate>13/03/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22278</IssueID>
        <Title>'is' keyword can be converted to "see langword" tag when it is already part of a "see langword" tag </Title>
        <Description>**Version Used**: 
VSUML 26920.4001
**Steps to Reproduce**:
1.  Create a new VB console app
2. At the start of the file, above module, add summary comments. Inside them add the text: "test 1 is"
3. Select 'is' in the comment, open up quick actions and choose "`Use &lt;see langword= "is"/&gt;`
4. Select is from inside the resulting see tag, and open up quick actions again. As you can see you can make a second tag inside the first tag.
**Expected Behavior**:
Either 'is' shouldn't be selectable at all for this action as 'is' isn't present elsewhere in the code file, or 'is' shouldn't be selectable when it is already in the tag.
**Actual Behavior**:
You're able to make a second `&lt;see langword="is"/&gt;` inside the first.
![image](https://user-images.githubusercontent.com/10537189/30723099-e3e433c4-9ee9-11e7-8cdb-767b7bd1722c.png)


</Description>
        <CreatedDate>21/09/2017</CreatedDate>
        <ClosedDate>13/03/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/ReplaceDocCommentTextWithTag/ReplaceDocCommentTextWithTagTests.cs</File>
      <File>src/Features/CSharp/Portable/ReplaceDocCommentTextWithTag/CSharpReplaceDocCommentTextWithTagCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/ReplaceDocCommentTextWithTag/AbstractReplaceDocCommentTextWithTagCodeRefactoringProvider.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>20743</IssueID>
    <Title>#20630 Cast is redundant on attribute with params fix</Title>
    <Description>**Customer scenario**

False positive on IDE0004 "Cast is redundant" analyzer


**Bugs this fixes:**

Fixes #20630

**Workarounds, if any**

Disable IDE0004

**Risk**

Code fix changes behavior.

**Performance impact**

Low.

**Is this a regression from a previous update?**

Variation of: #18978
Related: #20741 #20742

**Root cause analysis:**

Analyzer misses test for prams in attribute constructor calls.

**How was the bug found?**

Customer reported
</Description>
    <CreatedDate>10/07/2017</CreatedDate>
    <ClosedDate>28/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>20630</IssueID>
        <Title>Wrong IDE0004 Cast is redundant when applying attribute with params argument</Title>
        <Description>**Version Used**: 
First seen in VS2015. Subsequently reproduced on:

&gt; VS2017, version 15.2 (26430.14) Release

**Steps to Reproduce**:

Use this complete Console app:

```csharp
using System;
using System.Reflection;

class MarkAttribute : Attribute
{
  public readonly string[] Arr;

  public MarkAttribute(params string[] arr)
  {
    Arr = arr;
  }
}

[Mark((string)null)]   // wrong instance of: IDE0004 Cast is redundant.
static class Program
{
  static void Main()
  {
    var arr = typeof(Program).GetCustomAttribute&lt;MarkAttribute&gt;().Arr;
    Console.WriteLine(arr?.Length ?? int.MinValue);
  }
}
```

When compiled and run, correctly writes 1 to the console.

**Expected Behavior**:

No suggestion to remove cast syntax on null literal in attribute specification on class Program.

**Actual Behavior**:

Cast to string is in a pale text color, and a light bulb suggests, "Remove Unnecessary Cast". If the bad suggestion is followed, program behavior changes from writing 1 into writing -2147483648.

Obviously, the issue is with a params constructor that can apply in either normal form or expanded form.

While this seems _similar_ to other issues, like #18978, I do not know if it is a duplicate of any issue.</Description>
        <CreatedDate>04/07/2017</CreatedDate>
        <ClosedDate>28/03/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>18978</IssueID>
        <Title>IDE0004 "Cast is redundant" when casting `object[]` to `object` calling a method that takes `params object[]` changes behavior</Title>
        <Description>**Version Used**: VS2017 15.1 (26403.7)

**Steps to Reproduce**:
```
public static void Main(string[] args)
{
    var takesArgs = new[] { "Hello", "World" };
    TakesParams(takesArgs);
    TakesParams((object)takesArgs);
}

private static void TakesParams(params object[] foo)
{
    Console.WriteLine(foo.Length);
}
```

This correctly prints:
&gt;2
&gt;1

Following the "Cast is redundant" refactoring:
```
public static void Main(string[] args)
{
    var takesArgs = new[] { "Hello", "World" };
    TakesParams(takesArgs);
    TakesParams(takesArgs);
}

private static void TakesParams(params object[] foo)
{
    Console.WriteLine(foo.Length);
}
```

Produces:
&gt;2
&gt;2</Description>
        <CreatedDate>25/04/2017</CreatedDate>
        <ClosedDate>25/05/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>20741</IssueID>
        <Title>C# Named params argument in attribute constructor gets assigned wrong.</Title>
        <Description>**Version Used**: 
Visual Studio 15.1 (26403.7)
**Steps to Reproduce**:

Using named arguments in conjunction with params arguments seems to assign the wrong parameter in attribute constructor calls.

```CSharp
using System;
using System.Reflection;

sealed class MarkAttribute : Attribute
{
    public MarkAttribute(bool otherArg, params object[] args)
    {
        Args = args;
        OtherArg = otherArg;
    }
    public object[] Args { get;  }
    public bool OtherArg { get; }
}

[Mark(args: new string[] { "Hello", "World" }, otherArg: true)]
static class Program
{
    private static void Test(bool otherArg, params object[] args)
        =&gt; PrintOutArgsInfo(args);

    public static void Main()
    {
        Console.WriteLine("Method call");
        Test(args: new string[] { "Hello", "World" }, otherArg: true);

        var attr = typeof(Program).GetCustomAttribute&lt;MarkAttribute&gt;();
        Console.WriteLine("\nAttribute constructor call");
        PrintOutArgsInfo(attr.Args);
    }

    private static void PrintOutArgsInfo(object[] args)
    {
        Console.WriteLine($"Length: { args.Length } ");
        Console.WriteLine($"Value of Arr[0]: { args[0] } ");
        Console.WriteLine($"Type of Value[0]: { args[0].GetType().ToString() } ");
    }
}
```
**Expected Behavior**:
Does not compile or print out:
```
Method call
Length: 2
Value of Arr[0]: Hello
Type of Value[0]: System.String

Attribute constructor call
Length: 2
Value of Arr[0]: Hello
Type of Value[0]: System.String
```

**Actual Behavior**:
```
Method call
Length: 2
Value of Arr[0]: Hello
Type of Value[0]: System.String

Attribute constructor call
Length: 1
Value of Arr[0]: True
Type of Value[0]: System.Boolean
```

Discovered during working on #20630.</Description>
        <CreatedDate>10/07/2017</CreatedDate>
        <ClosedDate>29/09/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>20742</IssueID>
        <Title>IDE0004 "Cast is redundant" when casting `object[]` to `object` calling a method that takes `params object[]` and named arguments changes behavior.</Title>
        <Description>**Version Used**: 

Visual Studio 15.1  (26403.7)

**Steps to Reproduce**:

```CSharp
static class Program
{
    public static void Main(string[] args)
    {
        var takesArgs = new[] { "Hello", "World" };
        TakesParams(bar: (object)takesArgs, foo: true); //before IDE0004 is applied
        TakesParams(bar: takesArgs, foo: true); // after IDE0004 is applied
    }

    private static void TakesParams(bool foo, params object[] bar)
    {
        System.Console.WriteLine(bar.Length);
    }
}
```
Output:
&gt; 1
&gt; 2

**Expected Behavior**:
Don't offer IDE0004.
**Actual Behavior**:
Offers IDE0004.

This is a variation of #18978 that is still present after #19619.
Caused by:
https://github.com/dotnet/roslyn/blob/master/src/Workspaces/CSharp/Portable/Extensions/CastExpressionSyntaxExtensions.cs#L167-L177
This code assumes that the params argument is the last parameter in the call which isn't true for named arguments.

Test for:
roslyn\src\EditorFeatures\CSharpTest\Diagnostics\RemoveUnnecessaryCast\RemoveUnnecessaryCastTests.cs

```CSharp
        [WorkItem(20742, "https://github.com/dotnet/roslyn/issues/20742")]
        [Fact, Trait(Traits.Feature, Traits.Features.CodeActionsRemoveUnnecessaryCast)]
        public async Task DontRemoveCastOnCallToMethodWithParamsArgsAndNamedArgs()
        {
            await TestMissingInRegularAndScriptAsync(
@"
static class Program
{
    public static void Main(string[] args)
    {
        var takesArgs = new[] { ""Hello"", ""World"" };
        TakesParams(bar: [|(object)|]takesArgs, foo: true);
    }

    private static void TakesParams(bool foo, params object[] bar)
    {
        System.Console.WriteLine(bar.Length);
    }
}");
        }
```</Description>
        <CreatedDate>10/07/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/RemoveUnnecessaryCast/RemoveUnnecessaryCastTests.cs</File>
      <File>src/Workspaces/CSharp/Portable/Extensions/AttributeArgumentSyntaxExtensions.cs</File>
      <File>src/Workspaces/CSharp/Portable/Extensions/CastExpressionSyntaxExtensions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>24564</IssueID>
    <Title>Fix problems associated with analyzer timing</Title>
    <Description>### Customer scenario

A customer runs the compiler with analyzer timing enabled (either through the API or with a compiler flag on the command line). The timing operations incur substantial overhead on concurrent builds, and when one or more analyzers allocates large amounts of data, the timing results are inaccurate.

### Bugs this fixes

[DevDiv 560657](https://devdiv.visualstudio.com/DevDiv/_workitems/edit/560657) (internal mirror of this pull request)

### Workarounds, if any

* Disable analyzer timing
* Disable concurrent builds

### Risk

Low.

### Performance impact

Performance for intense analyzer scenarios can be improved by 20%. In addition, timing error rates of over 150% were observed for some analyzers.

### Is this a regression from a previous update?

No, but the work to reduce overhead in this scenario revealed another problem at the same location. This bug is limiting our ability to observe the expected gains from previous work.

### Root cause analysis

The previous work in this area was focused on allocation reductions (#23582), which were achieved as expected by #23621. The problem corrected by this pull request is a CPU time problem revealed by profiling execution times (#23583).

### How was the bug found?

Profiling per #23583.

### Test documentation updated?

N/A</Description>
    <CreatedDate>31/01/2018</CreatedDate>
    <ClosedDate>02/02/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>23582</IssueID>
        <Title>Manual allocation performance testing: AnalyzerRunner for IDE analyzers on Orchard.sln</Title>
        <Description>### Scenario details

This test executes the C# analyzers defined in the **CSharpFeatures** project, which includes the majority of IDE analyzers that ship with Visual Studio. The test stresses the following code path on its inner loop, and the measurement is a sampling of GC allocations over a fixed work unit.

https://github.com/dotnet/roslyn/blob/184ab3ea74581b8e0b3cde2da97237ac05301af3/src/Tools/AnalyzerRunner/Program.cs#L429-L434

### Steps to run the test:

1. Check out a Roslyn branch for AnalyzerRunner testing
    * Make sure #23087 is merged in the local branch
    * Make sure #23457 is merged in the local branch
1. Check out OrchardCMS/Orchard@024eaff854fc9bff81e05b17d4fdca3a978ac4e0 into an **Orchard** directory next to your existing **roslyn** directory
1. Run Roslyn's AnalyzerRunner tool (release configuration, no debugger) with the following options:

    &gt; $(SolutionDir)Binaries\\$(Configuration)\\Exes\\AnalyzerRunner\\Microsoft.CodeAnalysis.CSharp.Features.dll $(SolutionDir)..\\Orchard\\src\\Orchard.sln /concurrent /iter:4 /stats

1. Start PerfView GC-only profiling during the 5 second delay before project analysis starts
    * Make sure to use a circular buffer large enough to hold the complete result data
1. Stop profiling when the AnalyzerRunner completes</Description>
        <CreatedDate>05/12/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23621</IssueID>
        <Title>Pool the Stopwatch instance used in the analyzer driver</Title>
        <Description>### Customer scenario

Running analyzer during a build is slower than it should be, with the analyzer driver contributing substantial overhead even when the analyzers themselves are lightweight.

### Bugs this fixes

N/A

### Workarounds, if any

None needed

### Risk

Low. A `PerformanceSensitive` attribute is added to aid in preventing regressions.

### Performance impact

AnalyzerRunner on an FXCop scenario indicates overall allocation savings of 7-8%. About 1% is due to the `Stopwatch` instance itself, while the rest is due to the closure and delegate which can now be cached.

### Is this a regression from a previous update?

No.

### Root cause analysis

AnalyzerRunner is a new tool for helping us test analyzer performance in isolation.

### How was the bug found?

AnalyzerRunner.

### Test documentation updated?

No.</Description>
        <CreatedDate>06/12/2017</CreatedDate>
        <ClosedDate>08/12/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23583</IssueID>
        <Title>Manual performance testing: AnalyzerRunner for IDE analyzers on Orchard.sln</Title>
        <Description>Steps to run the test:

1. Check out a Roslyn branch for AnalyzerRunner testing
    * Make sure #23087 is merged in the local branch
    * Make sure #23457 is merged in the local branch
1. Check out OrchardCMS/Orchard@024eaff854fc9bff81e05b17d4fdca3a978ac4e0 into an **Orchard** directory next to your existing **roslyn** directory
1. Run Roslyn's AnalyzerRunner tool (release configuration, no debugger) with the following options:

    &gt; $(SolutionDir)Binaries\\$(Configuration)\\Exes\\AnalyzerRunner\\Microsoft.CodeAnalysis.CSharp.Features.dll $(SolutionDir)..\\Orchard\\src\\Orchard.sln /concurrent /iter:2 /stats

1. Start PerfView profiling during the 5 second delay before project analysis starts
    * Make sure to use a circular buffer large enough to hold the complete result data
1. Stop profiling when the AnalyzerRunner completes</Description>
        <CreatedDate>05/12/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23583</IssueID>
        <Title>Manual performance testing: AnalyzerRunner for IDE analyzers on Orchard.sln</Title>
        <Description>Steps to run the test:

1. Check out a Roslyn branch for AnalyzerRunner testing
    * Make sure #23087 is merged in the local branch
    * Make sure #23457 is merged in the local branch
1. Check out OrchardCMS/Orchard@024eaff854fc9bff81e05b17d4fdca3a978ac4e0 into an **Orchard** directory next to your existing **roslyn** directory
1. Run Roslyn's AnalyzerRunner tool (release configuration, no debugger) with the following options:

    &gt; $(SolutionDir)Binaries\\$(Configuration)\\Exes\\AnalyzerRunner\\Microsoft.CodeAnalysis.CSharp.Features.dll $(SolutionDir)..\\Orchard\\src\\Orchard.sln /concurrent /iter:2 /stats

1. Start PerfView profiling during the 5 second delay before project analysis starts
    * Make sure to use a circular buffer large enough to hold the complete result data
1. Stop profiling when the AnalyzerRunner completes</Description>
        <CreatedDate>05/12/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/Core/Portable/DiagnosticAnalyzer/AnalyzerExecutor.cs</File>
      <File>src/Dependencies/PooledObjects/PooledStopwatch.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>24547</IssueID>
    <Title>Fix `is` and pattern-matching behavior in presence of implicit UD conversion</Title>
    <Description>Fix `is` and pattern-matching behavior in presence of implicit UD conversion
and also an explicit reference conversion between the same types.
User-defined conversions should never be considered for `is` and pattern-matching.

### Customer scenario

See #24522 

### Bugs this fixes

Fixes #24522

### Workarounds, if any

Casting the left-hand-side to `object` is often a work-around.

### Risk

Low, as the fix is quite localized.

### Performance impact

Should be slight performance improvement, as we now only check built-in conversions for certain type-check operations.

### Is this a regression from a previous update?

Yes. C#6 did not have this bug.

### Root cause analysis

We did not realize that it is possible for an implicit user-defined operator to be present when an explicit reference conversion applies.

We now have tests for the ways that symptoms can arise.

### How was the bug found?

Customer reported.

### Test documentation updated?

N/A
</Description>
    <CreatedDate>31/01/2018</CreatedDate>
    <ClosedDate>06/02/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>24522</IssueID>
        <Title>is operator not working if implicit conversion operator exists on generic type</Title>
        <Description>**Version Used**: 7.2

**Steps to Reproduce**:

    class Base&lt;T&gt;
    {
        //without implicit operator everything works as expected
        public static implicit operator Derived(Base&lt;T&gt; obj)
        {
            return new Derived();
        }
    }

    class Derived : Base&lt;object&gt;
    {

    }

    class Program
    {
        static void Main(string[] args)
        {
            Base&lt;object&gt; x = new Derived();
            if (x is Derived) //Problem: this is always false!!
            {

            }
        }
    }

**Expected Behavior**: (x is Derived) should be true in this case (it worked like that in the old csc.exe).

**Actual Behavior**: (x is Derived) is always false.
</Description>
        <CreatedDate>29/01/2018</CreatedDate>
        <ClosedDate>06/02/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>24522</IssueID>
        <Title>is operator not working if implicit conversion operator exists on generic type</Title>
        <Description>**Version Used**: 7.2

**Steps to Reproduce**:

    class Base&lt;T&gt;
    {
        //without implicit operator everything works as expected
        public static implicit operator Derived(Base&lt;T&gt; obj)
        {
            return new Derived();
        }
    }

    class Derived : Base&lt;object&gt;
    {

    }

    class Program
    {
        static void Main(string[] args)
        {
            Base&lt;object&gt; x = new Derived();
            if (x is Derived) //Problem: this is always false!!
            {

            }
        }
    }

**Expected Behavior**: (x is Derived) should be true in this case (it worked like that in the old csc.exe).

**Actual Behavior**: (x is Derived) is always false.
</Description>
        <CreatedDate>29/01/2018</CreatedDate>
        <ClosedDate>06/02/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>6</IssueID>
        <Title>Corrected documentation on FullSpan and Span</Title>
        <Description>As per the [Incorrect Docs on FullSpan/Span properties](http://roslyn.codeplex.com/workitem/260) issue, the documentation was reversed on a few of these pairs.

&lt;!---
@huboard:{"order":8.0}
--&gt;
</Description>
        <CreatedDate>15/01/2015</CreatedDate>
        <ClosedDate>09/02/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Operators.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Patterns.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_Patterns.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/SyntheticBoundNodeFactory.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/PatternTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>24424</IssueID>
    <Title>Localization test failures 2</Title>
    <Description>Fix for #23837.
Follow up for #24407.

This is the second of a series of PRs meant to resolve the unit test failures caused by missing localizations.

This PR includes test related to expression compiler

### Roslyn.ExpressionEvaluator.CSharp.ExpressionCompiler.UnitTests 
Done. Tested local (de-DE) and CI (en-US).
### Roslyn.ExpressionEvaluator.VisualBasic.ExpressionCompiler.UnitTests
Done. Tested local (de-DE) and CI (en-US).
</Description>
    <CreatedDate>24/01/2018</CreatedDate>
    <ClosedDate>14/02/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>23837</IssueID>
        <Title>Running Test.cmd on a non english machine causes lots of unit tests to fail</Title>
        <Description>**Version Used**: 

Latest master at commit  69e99a8

**Steps to Reproduce**:

Run `Test.cmd` with a non english locale.

**Expected Behavior**:

All tests pass without errors.

**Actual Behavior**:

26 out of 41 test assemblies fail with errors. There were already about five failing tests in the past because of localization problems but since the introduction of xlf the situation got unbearable with hundreds of failing tests. I'm not sure but I think PR #23744 is to blame.
Attached you can find the [UnitTestResults.zip](https://github.com/dotnet/roslyn/files/1568759/UnitTestResults.zip)
In the current situation I'm not able to run all tests locally to find regressions before committing. Maybe xUnit should be forced to use the [en-US locale](https://stackoverflow.com/a/42880541).

</Description>
        <CreatedDate>18/12/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>24407</IssueID>
        <Title>Localization test failures 1</Title>
        <Description>Fix for #23837.

This is the first of a series of PRs meant to resolve the unit test failures caused by missing localizations.

This PR includes test related to csi.exe and interactive scripting:

### Microsoft.CodeAnalysis.CSharp.Scripting.UnitTests
Done. Tested local (de-DE) and CI (en-US).
### Microsoft.CodeAnalysis.CSharp.Scripting.Desktop.UnitTests
Done. Tested local (de-DE) and CI (en-US).
### Microsoft.CodeAnalysis.VisualBasic.Scripting.UnitTests
Done. Tested local (de-DE) and CI (en-US).
### Roslyn.InteractiveHost.UnitTests 
Done. Tested local (de-DE) and CI (en-US).</Description>
        <CreatedDate>23/01/2018</CreatedDate>
        <ClosedDate>14/02/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/ExpressionEvaluator/CSharp/Test/ExpressionCompiler/CompileExpressionsTests.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Test/ExpressionCompiler/MissingAssemblyTests.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Test/ExpressionCompiler/ReferencedModulesTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>24291</IssueID>
    <Title>Locate implementations for reference assemblies using the GAC</Title>
    <Description>This pull request partially implements the "locate the runtime assembly" feature described in #24349, specifically for cases where the metadata reference resolves to a reference assembly (i.e. an assembly which does not contain IL for method bodies). Reference assemblies do not produce meaningful results when decompiled, and currently all references to the .NET Framework assemblies fall into this category. For common assemblies already located in the GAC, including the .NET Framework assemblies, this pull request allows the Navigate to Decompiled Sources feature to provide meaningful results.

Fixes #24185 (other related limitations will become separate bugs)

### Customer scenario

A user attempts to use the Navigate to Decompiled Sources feature to navigate to a member defined as part of the .NET Framework. The feature does not work as expected, because the decompiled source file shows the code for a reference assembly, which does not have any contents in the bodies of members.

### Bugs this fixes

Fixes #24185

### Workarounds, if any

None.

### Risk

Low. This only impacts the Navigate to Decompiled Sources feature, which is disabled by default and only exposed as an experimental option in the Advanced page of C# settings.

### Performance impact

This code is only in effect on the code paths where it is required.

### Is this a regression from a previous update?

No.

### Root cause analysis

Known limitation of a new feature.

### How was the bug found?

Known limitation of a new feature.

### Test documentation updated?

Yes.
</Description>
    <CreatedDate>17/01/2018</CreatedDate>
    <ClosedDate>05/02/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>24349</IssueID>
        <Title>Expected behavior for Go To Definition for metadata references</Title>
        <Description>The Navigate to Decompiled Sources feature recently added is the first step towards a better &lt;kbd&gt;F12&lt;/kbd&gt; experience. This issue describes the more complete picture for how this experience should eventually look.

⚠️ This workflow is currently just a draft

1. Start with the metadata reference
2. Locate the correct runtime assembly from the metadata reference (accounting for execution environment and assembly binding redirection)
3. Locate the symbols for the runtime assembly
4. Using the symbol file and/or symbol server, locate the original source file(s) for the symbol getting decompiled
5. If step 3 or 4 fails, decompile the symbol from the runtime assembly using ILSpy
6. If step 2 fails, attempt steps 3-5 using the metadata reference instead of the runtime assembly
7. Otherwise, don't attempt to decompile</Description>
        <CreatedDate>19/01/2018</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>24185</IssueID>
        <Title>Navigate to decompiled sources: Reference assemblies are not supported</Title>
        <Description>For example, in Roslyn i went to Debug.Assert, and this is what i got:

```c#
		[Conditional("DEBUG")]
		public static void Assert(bool condition)
		{
		}
```

Now, my guess is this is because of reference assemblies.  However, it's hard to tell what's going on.  The top of the file is just:

![image](https://user-images.githubusercontent.com/4564579/34843308-ea760d3a-f6c2-11e7-9168-6d5526838b79.png)

Perhaps a comment could be added that's similar to what we get with normal metadata-as-source:

```c#
#region Assembly System.Collections.Immutable, Version=1.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a
// C:\Users\cyrus\.nuget\packages\system.collections.immutable\1.3.1\lib\netstandard1.0\System.Collections.Immutable.dll
#endregion
```</Description>
        <CreatedDate>11/01/2018</CreatedDate>
        <ClosedDate>13/02/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>24185</IssueID>
        <Title>Navigate to decompiled sources: Reference assemblies are not supported</Title>
        <Description>For example, in Roslyn i went to Debug.Assert, and this is what i got:

```c#
		[Conditional("DEBUG")]
		public static void Assert(bool condition)
		{
		}
```

Now, my guess is this is because of reference assemblies.  However, it's hard to tell what's going on.  The top of the file is just:

![image](https://user-images.githubusercontent.com/4564579/34843308-ea760d3a-f6c2-11e7-9168-6d5526838b79.png)

Perhaps a comment could be added that's similar to what we get with normal metadata-as-source:

```c#
#region Assembly System.Collections.Immutable, Version=1.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a
// C:\Users\cyrus\.nuget\packages\system.collections.immutable\1.3.1\lib\netstandard1.0\System.Collections.Immutable.dll
#endregion
```</Description>
        <CreatedDate>11/01/2018</CreatedDate>
        <ClosedDate>13/02/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/Shared/GlobalAssemblyCacheHelpers/FusionAssemblyIdentity.cs</File>
      <File>src/EditorFeatures/Core/Implementation/MetadataAsSource/MetadataAsSourceFileService.cs</File>
      <File>src/Interactive/EditorFeatures/Core/Completion/GlobalAssemblyCacheCompletionHelper.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>24173</IssueID>
    <Title>Suppress 'IDE0041 Null check can be simplified' for unconstraint generic parameters.</Title>
    <Description>### Customer scenario

`IDE0041 Null check can be simplified` is shown for the `ReferenceEquals` method and a fix is offered. The fix generates code which might have the compiler error 'Can not convert null to type parameter T because it could be a non-nullable value type.'. This fix suppresses IDE0041 if the parameter passed to ReferenceEquals is ~an unconstraint generic type parameter~ Update 01/17/2018: a value type constraint generic type parameter.

### Bugs this fixes

#23581

### Workarounds, if any

Suppress IDE0041 with a pragma or change the generated code from `(value is null)`to `(value == null)`.

### Risk

Low. Small additional check.

### Performance impact

Low. Syntax and semantic analysis has already been done by other checks on the code path before. This adds some more checks.

### Is this a regression from a previous update?

/

### Root cause analysis

/

### How was the bug found?

Customer reported #23581

### Test documentation updated?

/
</Description>
    <CreatedDate>11/01/2018</CreatedDate>
    <ClosedDate>14/02/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>23581</IssueID>
        <Title> IDE0041 Null check can be simplified is shown for Reference Equals of all generic parameters</Title>
        <Description>IDE0041 should only be shown if the type is nullable or the generic parameter is constrained to a nullable type.
Executing the codefix will create invalid code.

**Version Used**: 
Visual Studio Enterprise 2017 15.5 RTM
**Steps to Reproduce**:

1. Use repro snippet from below
2. Build
3. Look at messages

**Expected Behavior**:
Not shown
**Actual Behavior**:
Message: IDE0041	Null check can be simplified is shown for the Reference Equals

Repro:
```csharp
public static void NotNull&lt;T&gt;(T value, string parameterName)
{
    if (ReferenceEquals(value, null)) // IDE0041 not valid here
    {
        throw new ArgumentNullException(parameterName);
    }
}
``` 

</Description>
        <CreatedDate>05/12/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23581</IssueID>
        <Title> IDE0041 Null check can be simplified is shown for Reference Equals of all generic parameters</Title>
        <Description>IDE0041 should only be shown if the type is nullable or the generic parameter is constrained to a nullable type.
Executing the codefix will create invalid code.

**Version Used**: 
Visual Studio Enterprise 2017 15.5 RTM
**Steps to Reproduce**:

1. Use repro snippet from below
2. Build
3. Look at messages

**Expected Behavior**:
Not shown
**Actual Behavior**:
Message: IDE0041	Null check can be simplified is shown for the Reference Equals

Repro:
```csharp
public static void NotNull&lt;T&gt;(T value, string parameterName)
{
    if (ReferenceEquals(value, null)) // IDE0041 not valid here
    {
        throw new ArgumentNullException(parameterName);
    }
}
``` 

</Description>
        <CreatedDate>05/12/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/UseIsNullCheck/UseIsNullCheckTests.cs</File>
      <File>src/Features/CSharp/Portable/UseIsNullCheck/CSharpUseIsNullCheckCodeFixProvider.cs</File>
      <File>src/Features/Core/Portable/UseIsNullCheck/AbstractUseIsNullCodeFixProvider.cs</File>
      <File>src/Features/Core/Portable/UseIsNullCheck/AbstractUseIsNullDiagnosticAnalyzer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>22114</IssueID>
    <Title>Class view should show nested private types if source code is available.</Title>
    <Description>**Customer scenario**

Class view should show nested private types if source code is available. See #21329 for the motivation of the request. 

Implementation remarks:
The new method `IncludeTypeMember` has the about the same structure as the existing method `IncludeMemberSymbol`. Most changes are related to the tests.

**Bugs this fixes:**

Fixes #21329

**Workarounds, if any**

None.

**Risk**

Might break class view or shows types in class view that are not relevant to the user.

**Performance impact**

Low.

**Is this a regression from a previous update?**

No.

**Root cause analysis:**

Private type members were considered but private types were not.

**How was the bug found?**

Customer reported.

**Test documentation updated?**

Maybe https://msdn.microsoft.com/en-us/library/whks02wf.aspx needs to be adopted.</Description>
    <CreatedDate>14/09/2017</CreatedDate>
    <ClosedDate>14/02/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>21329</IssueID>
        <Title>Class View should show non-public nested types.</Title>
        <Description>**Version Used**: 

Visual Studio 2017 Community (v15.2)

**Steps to Reproduce**:

Type the following VB code into any kind of project (e.g. a console project)

```vb
Public Class OuterClass
  Public Class PublicInnerClass
  End Class

  Private Class PrivateInnerClass
  End Class

  Protected Class ProtectedInnerClass
  End Class
End Class
```

...or the following C# code:

```csharp
  class OuterClass
  {
    public class PublicInnerClass { }
    private class PrivateInnerClass { }
    protected class ProtectedInnerClass { }

  }
```

Now open Class View directly (or put the caret on `PrivateInnerClass` and execute the `View.SynchronizeClassView` command, e.g. from the Immediate window).

**Expected Behavior**:

The Class View should show all classes (the outer class and all the nested inner classes with different visibility modifiers). If you use the `View.SynchronizeClassView` command on a non-public nested class, that should also jump to said class.

**Actual Behavior**:

Class View only shows `OuterClass` and `OuterClass.PublicInnerClass`. It does not show the `PrivateInnerClass` and `ProtectedInnerClass` and as a result, the `View.SynchronizeClassView` command also fails to navigate to those non-public nested classes. Ticking all the various "Show..." options in that Class View gear icon doesn't help.

I think the problem is that the nested types are non-public, because the same problem happens if you try this with non-public enum/struct/interface types.

I say this is a bug because if Class View can show me `OuterClass` for which I have the source code, it makes no sense to not show me `PrivateInnerClass` and `ProtectedInnerClass` as they are (by definition) also available in the same source code.</Description>
        <CreatedDate>04/08/2017</CreatedDate>
        <ClosedDate>14/02/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>21329</IssueID>
        <Title>Class View should show non-public nested types.</Title>
        <Description>**Version Used**: 

Visual Studio 2017 Community (v15.2)

**Steps to Reproduce**:

Type the following VB code into any kind of project (e.g. a console project)

```vb
Public Class OuterClass
  Public Class PublicInnerClass
  End Class

  Private Class PrivateInnerClass
  End Class

  Protected Class ProtectedInnerClass
  End Class
End Class
```

...or the following C# code:

```csharp
  class OuterClass
  {
    public class PublicInnerClass { }
    private class PrivateInnerClass { }
    protected class ProtectedInnerClass { }

  }
```

Now open Class View directly (or put the caret on `PrivateInnerClass` and execute the `View.SynchronizeClassView` command, e.g. from the Immediate window).

**Expected Behavior**:

The Class View should show all classes (the outer class and all the nested inner classes with different visibility modifiers). If you use the `View.SynchronizeClassView` command on a non-public nested class, that should also jump to said class.

**Actual Behavior**:

Class View only shows `OuterClass` and `OuterClass.PublicInnerClass`. It does not show the `PrivateInnerClass` and `ProtectedInnerClass` and as a result, the `View.SynchronizeClassView` command also fails to navigate to those non-public nested classes. Ticking all the various "Show..." options in that Class View gear icon doesn't help.

I think the problem is that the nested types are non-public, because the same problem happens if you try this with non-public enum/struct/interface types.

I say this is a bug because if Class View can show me `OuterClass` for which I have the source code, it makes no sense to not show me `PrivateInnerClass` and `ProtectedInnerClass` as they are (by definition) also available in the same source code.</Description>
        <CreatedDate>04/08/2017</CreatedDate>
        <ClosedDate>14/02/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/VisualStudio/Core/Def/Implementation/Library/ObjectBrowser/AbstractListItemFactory.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>20554</IssueID>
    <Title>New Quick Info API</Title>
    <Description>This is a PR to create a new public Quick Info API (#11103)

- [x] Move @mattwar's original PR (#13623) forward to the latest master bits and get it building.
- [x] Get all tests passing and ensure Quick Info actually still works.
- [x] Update with @CyrusNajmabadi's comments on the original PR (#13623).
- [x] Close #13623.
- [x] Finalize public API surface area.

cc @dotnet/roslyn-ide </Description>
    <CreatedDate>29/06/2017</CreatedDate>
    <ClosedDate>16/02/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>11103</IssueID>
        <Title>Make QuickInfo API public</Title>
        <Description>Needs to be moved to Features layer and redesigned for better separation between model and view.

Follow model for Completion API.

IQuickInfoProvider, needs to be divorced from WPF dependencies, needs consumption API
</Description>
        <CreatedDate>05/05/2016</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>13623</IssueID>
        <Title>Quick info api2</Title>
        <Description>@DustinCampbell @jasonmalinowski @Pilchie @dpoeschl @CyrusNajmabadi   please review

Here is my proposal for the new public QuickInfo API...  (note: the API as presented is not yet public.)

This is the "simple" form of the API, not the "almost as complicated as XML" form that I describe a few weeks ago.  It has one API to get the QuickInfoItem for a position in document, and that item simply lays out the data/text that we typically display for C# and VB.  It also includes information we use in the syntactic c# provider (that shows ranges of the original document where the matching open braces are).  The presenter then choses what to do with it.  There is no customization of the presenter on the editor side.

If other languages need different information and different presentation, the plan is to add those extra data times to the one QuickInfoItem class and change the single presenter to account for it.   Worst case scenario if we decide we want something drastically different in the future, then we invent QuickInfo2.
</Description>
        <CreatedDate>06/09/2016</CreatedDate>
        <ClosedDate>05/12/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>13623</IssueID>
        <Title>Quick info api2</Title>
        <Description>@DustinCampbell @jasonmalinowski @Pilchie @dpoeschl @CyrusNajmabadi   please review

Here is my proposal for the new public QuickInfo API...  (note: the API as presented is not yet public.)

This is the "simple" form of the API, not the "almost as complicated as XML" form that I describe a few weeks ago.  It has one API to get the QuickInfoItem for a position in document, and that item simply lays out the data/text that we typically display for C# and VB.  It also includes information we use in the syntactic c# provider (that shows ranges of the original document where the matching open braces are).  The presenter then choses what to do with it.  There is no customization of the presenter on the editor side.

If other languages need different information and different presentation, the plan is to add those extra data times to the one QuickInfoItem class and change the single presenter to account for it.   Worst case scenario if we decide we want something drastically different in the future, then we invent QuickInfo2.
</Description>
        <CreatedDate>06/09/2016</CreatedDate>
        <ClosedDate>05/12/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>13623</IssueID>
        <Title>Quick info api2</Title>
        <Description>@DustinCampbell @jasonmalinowski @Pilchie @dpoeschl @CyrusNajmabadi   please review

Here is my proposal for the new public QuickInfo API...  (note: the API as presented is not yet public.)

This is the "simple" form of the API, not the "almost as complicated as XML" form that I describe a few weeks ago.  It has one API to get the QuickInfoItem for a position in document, and that item simply lays out the data/text that we typically display for C# and VB.  It also includes information we use in the syntactic c# provider (that shows ranges of the original document where the matching open braces are).  The presenter then choses what to do with it.  There is no customization of the presenter on the editor side.

If other languages need different information and different presentation, the plan is to add those extra data times to the one QuickInfoItem class and change the single presenter to account for it.   Worst case scenario if we decide we want something drastically different in the future, then we invent QuickInfo2.
</Description>
        <CreatedDate>06/09/2016</CreatedDate>
        <ClosedDate>05/12/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharp/QuickInfo/SemanticQuickInfoProvider.cs</File>
      <File>src/EditorFeatures/CSharpTest/QuickInfo/SemanticQuickInfoSourceTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/QuickInfo/SyntacticQuickInfoSourceTests.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Completion/Presentation/CustomCommitCompletion.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Completion/Presentation/ImageMonikers.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Completion/Presentation/RoslynIntellisenseFilter.cs</File>
      <File>src/EditorFeatures/Core.Wpf/QuickInfo/Converters/ClassifiableDeferredContentConverter.cs</File>
      <File>src/EditorFeatures/Core.Wpf/QuickInfo/Converters/DocumentationCommentDeferredContentConverter.cs</File>
      <File>src/EditorFeatures/Core.Wpf/QuickInfo/Converters/IDeferredQuickInfoContentToFrameworkElementConverter.cs</File>
      <File>src/EditorFeatures/Core.Wpf/QuickInfo/Converters/ProjectionBufferDeferredContentConverter.cs</File>
      <File>src/EditorFeatures/Core.Wpf/QuickInfo/Converters/QuickInfoConverterMetadataAttribute.cs</File>
      <File>src/EditorFeatures/Core.Wpf/QuickInfo/Converters/QuickInfoDisplayDeferredContentConverter.cs</File>
      <File>src/EditorFeatures/Core.Wpf/QuickInfo/Converters/SymbolGlyphDeferredContentConverter.cs</File>
      <File>src/EditorFeatures/Core.Wpf/QuickInfo/DeferredContentFrameworkElementFactory.cs</File>
      <File>src/EditorFeatures/Core.Wpf/QuickInfo/Presentation/QuickInfoPresenter.QuickInfoPresenterSession.cs</File>
      <File>src/EditorFeatures/Core.Wpf/QuickInfo/Presentation/QuickInfoPresenter.QuickInfoSource.cs</File>
      <File>src/EditorFeatures/Core.Wpf/QuickInfo/Presentation/QuickInfoPresenter.cs</File>
      <File>src/EditorFeatures/Core.Wpf/QuickInfo/ProjectionBufferContent.cs</File>
      <File>src/EditorFeatures/Core.Wpf/QuickInfo/QuickInfoDisplayPanel.cs</File>
      <File>src/EditorFeatures/Core.Wpf/QuickInfo/TextBlockElement.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Tags/DefaultImageMonikerService.cs</File>
      <File>src/EditorFeatures/Core.Wpf/WpfClassificationExtensions.cs</File>
      <File>src/EditorFeatures/Core/CommandHandlers/QuickInfoCommandHandlerAndSourceProvider.cs</File>
      <File>src/EditorFeatures/Core/Extensibility/QuickInfo/IDeferredQuickInfoContent.cs</File>
      <File>src/EditorFeatures/Core/Extensibility/QuickInfo/IQuickInfoPresenterSession.cs</File>
      <File>src/EditorFeatures/Core/Extensibility/QuickInfo/IQuickInfoProvider.cs</File>
      <File>src/EditorFeatures/Core/Extensibility/QuickInfo/PredefinedQuickInfoSourceProviderNames.cs</File>
      <File>src/EditorFeatures/Core/Extensibility/QuickInfo/QuickInfoItem.cs</File>
      <File>src/EditorFeatures/Core/Extensibility/QuickInfo/QuickInfoUtilities.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/QuickInfo/Controller.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/QuickInfo/DeferredContent/ClassifiableDeferredContent.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/QuickInfo/DeferredContent/ProjectionBufferDeferredContent.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/QuickInfo/DeferredContent/QuickInfoDisplayDeferredContent.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/QuickInfo/DeferredContent/SymbolGlyphDeferredContent.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/QuickInfo/Model.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/QuickInfo/Providers/AbstractQuickInfoProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/QuickInfo/Providers/DocumentationCommentDeferredContent.cs</File>
      <File>src/EditorFeatures/Core/Shared/Extensions/GlyphExtensions.cs</File>
      <File>src/EditorFeatures/TestUtilities/CodeActions/AbstractCodeActionOrUserDiagnosticTest.cs</File>
      <File>src/EditorFeatures/TestUtilities/QuickInfo/AbstractQuickInfoSourceTests.cs</File>
      <File>src/EditorFeatures/TestUtilities/QuickInfo/AbstractSemanticQuickInfoSourceTests.cs</File>
      <File>src/Features/CSharp/Portable/QuickInfo/CSharpQuickInfoSevice.cs</File>
      <File>src/Features/CSharp/Portable/QuickInfo/CSharpSemanticQuickInfoProvider.cs</File>
      <File>src/Features/CSharp/Portable/QuickInfo/CSharpSyntacticQuickInfoProvider.cs</File>
      <File>src/Features/CSharp/Portable/RemoveUnusedVariable/CSharpRemoveUnusedVariableCodeFixProvider.cs</File>
      <File>src/Features/Core/Portable/Common/GlyphExtensions.cs</File>
      <File>src/Features/Core/Portable/Common/GlyphTags.cs</File>
      <File>src/Features/Core/Portable/Completion/CommonCompletionItem.cs</File>
      <File>src/Features/Core/Portable/Completion/CommonCompletionService.cs</File>
      <File>src/Features/Core/Portable/Completion/CompletionHelper.cs</File>
      <File>src/Features/Core/Portable/Completion/CompletionItem.cs</File>
      <File>src/Features/Core/Portable/Completion/CompletionItemFilter.cs</File>
      <File>src/Features/Core/Portable/Completion/CompletionTags.cs</File>
      <File>src/Features/Core/Portable/Completion/Providers/AbstractKeywordCompletionProvider.cs</File>
      <File>src/Features/Core/Portable/FeaturesResources.Designer.cs</File>
      <File>src/Features/Core/Portable/FindUsages/DefinitionItem.cs</File>
      <File>src/Features/Core/Portable/QuickInfo/CommonQuickInfoProvider.cs</File>
      <File>src/Features/Core/Portable/QuickInfo/CommonSemanticQuickInfoProvider.ErrorVisitor.cs</File>
      <File>src/Features/Core/Portable/QuickInfo/CommonSemanticQuickInfoProvider.SymbolComparer.cs</File>
      <File>src/Features/Core/Portable/QuickInfo/CommonSemanticQuickInfoProvider.cs</File>
      <File>src/Features/Core/Portable/QuickInfo/ExportQuickInfoProviderAttribute.cs</File>
      <File>src/Features/Core/Portable/QuickInfo/IndentationHelper.cs</File>
      <File>src/Features/Core/Portable/QuickInfo/LinkedFileDiscrepancyException.cs</File>
      <File>src/Features/Core/Portable/QuickInfo/QuickInfoContext.cs</File>
      <File>src/Features/Core/Portable/QuickInfo/QuickInfoItem.cs</File>
      <File>src/Features/Core/Portable/QuickInfo/QuickInfoProvider.cs</File>
      <File>src/Features/Core/Portable/QuickInfo/QuickInfoProviderMetadata.cs</File>
      <File>src/Features/Core/Portable/QuickInfo/QuickInfoProviderNames.cs</File>
      <File>src/Features/Core/Portable/QuickInfo/QuickInfoSection.cs</File>
      <File>src/Features/Core/Portable/QuickInfo/QuickInfoSectionKinds.cs</File>
      <File>src/Features/Core/Portable/QuickInfo/QuickInfoService.cs</File>
      <File>src/Features/Core/Portable/QuickInfo/QuickInfoServiceWithProviders.cs</File>
      <File>src/VisualStudio/CSharp/Impl/EventHookup/EventHookupQuickInfoSourceProvider.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/FindReferences/Entries/DocumentSpanEntry.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/FindReferences/Entries/Entry.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/FindReferences/RoslynDefinitionBucket.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/FindReferences/StreamingFindUsagesPresenter.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Library/FindResults/LibraryManager_FindReferences.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Library/FindResults/TreeItems/DefinitionTreeItem.cs</File>
      <File>src/VisualStudio/Core/Def/Shared/VisualStudioImageMonikerService.cs</File>
      <File>src/Workspaces/Core/Portable/Shared/Extensions/TextLineExtensions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23930</IssueID>
    <Title>Fix two bugs in async lifting analysis which results in unnecessarily lifted locals.</Title>
    <Description>The first issue is that we did not properly track the unreachable state in lifting analysis. I believe we did so to work around a bug that has since been fixed.
The second issue is that an assignment in a conditional branch condition was not treated as conditional.

Since VB does not have an assignment expression, I do not have a repro for user locals, but the fix results in some temps no longer being unnecessarily lifted (as shown by changes in existing tests)

### Customer scenario

Async methods have more IL for their bodies, and more locals lifted, than necessary.

### Bugs this fixes

Fixes #13759

### Workarounds, if any

None known.

### Risk

The fix is simple. On the other hand, flow analysis is subtle and the reasons that we tracked unreachable state the way we did is lost in prehistory.

### Performance impact

Changes are simple and local, so no performance impact expected.

### Is this a regression from a previous update?

No.

### Root cause analysis

We do not have extensive testing for which locals are lifted in async code under what circumstances. Too much lifting is generally only a performance (not correctness) problem, so we did not prioritize it.

### How was the bug found?

Customer reported.

### Test documentation updated?

It would be good to add supporting test infrastructure and tests for which locals are lifted for various uses of language constructs. Once that is in place, we could add it as an item to check off for testing new features. This suggestion is recorded in #23929.
</Description>
    <CreatedDate>26/12/2017</CreatedDate>
    <ClosedDate>09/01/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>13759</IssueID>
        <Title>Unnecessarily lifted field in async state machine</Title>
        <Description>**Version Used**: 
2.0.0.60620

**Steps to Reproduce**:
Compile this code:

``` C#
using System.IO;
using System.Threading.Tasks;

class Program
{
    public static void Main() { }

    public static async Task Repro1(Stream source, Stream destination)
    {
        byte[] buffer = new byte[0x1000];
        int bytesRead;
        while ((bytesRead = await source.ReadAsync(buffer, 0, buffer.Length)) != 0)
        {
            await destination.WriteAsync(buffer, 0, bytesRead);
        }
    }

    public static async Task Repro2(Stream source, Stream destination)
    {
        byte[] buffer = new byte[0x1000];
        while (true)
        {
            int bytesRead = await source.ReadAsync(buffer, 0, buffer.Length);
            if (bytesRead == 0) break;
            await destination.WriteAsync(buffer, 0, bytesRead);
        }
    }
}
```

**Expected Behavior**:
The async state machine does not have a field for `bytesRead`.

**Actual Behavior**:
In Repro2, as expected, the async state machine does not lift `bytesRead` to the state machine.  But in Repro1, it does lift `bytesRead` to the state machine, even though the value of `bytesRead` doesn't need to be preserved across an await.
</Description>
        <CreatedDate>13/09/2016</CreatedDate>
        <ClosedDate>09/01/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23929</IssueID>
        <Title>Add tests for lifted variables in async/iterator code</Title>
        <Description>We do not have many tests that verify the set of variables lifted in async or iterator code. It would be good to add a bit of testing infrastructure to make that easy, and add tests. Also, this could be added to the checklist for new features.</Description>
        <CreatedDate>26/12/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/PreciseAbstractFlowPass.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/StateMachineRewriter/IteratorAndAsyncCaptureWalker.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenAsyncTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23448</IssueID>
    <Title>Simplify diagnostic tagging by making it use the standard tagging model.</Title>
    <Description>### Customer scenario

User is working on a big solution and switching between git branches multiple times or close and reopen solutions multiple times. and on some unfortunate cases, VS will crash with out of memory exception. 

### Bugs this fixes

Fixes #24055
Fixes [DevDiv 512757](https://devdiv.visualstudio.com/DevDiv/_workitems/edit/512757)

Supersedes #22920, #23377, #23409, #23411

### Workarounds, if any

after each git branch switching or solution open/close, give VS sometimes to process pending works enqueued by the operation.

### Risk

this simplify our diagnostic tagger dramatically. so there is a risk where behavior might not exactly same as before. but we believe this is right direction to go. 

### Performance impact

this should remove OOM due to too many pending UI work items completely. that is source of most of our OOM crash.

### Is this a regression from a previous update?

No

### Root cause analysis

previously, diagnostic service didn't support pull model for all diagnostics source. so, tagger used event (push model) to hold onto last reported diagnostics and later use that to report tags. and that made us to use custom logic for the tagger which ends up forcing us to use UI thread to synchronize many states to remove potential race. and that caused us to push too many work items to UI thread in certain case such as git branch switching.

now, diagnostic service fully supporting pull model for all sources, this moves diagnostic taggers to follow our tagger framework which doesn't require UI thread for state synchronization. removing the root cause of OOM from the picture completely.

### How was the bug found?

MemoryWatson

....

more dev detail.

From a conversation with @heejaechang https://github.com/dotnet/roslyn/pull/23409#issuecomment-347675771 

A while back the diagnostics subsystem had a limitation where you could only hear about some diagnostics if you explicitly listened for diagnostic events.  i.e. if you weren't listenting and capturing those events, you couldn't go back and ask for those diagnostics later.  This meant that we couldn't do diagnostic tagging (squiggles/fading/suggestions) like we did normal tagging. Normal tagging hears about events, pauses a bit, then goes and gets all the data necessary later to produce the tags.  Because that data wasn't available 'later', diagnostic tagging had to aggregate the info and contort things to fit into the tagging infrastructure.

This restriction from the diagnostics service no longer exists. THat means we can great simplify how we do our tagging computation.  </Description>
    <CreatedDate>28/11/2017</CreatedDate>
    <ClosedDate>16/01/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>24055</IssueID>
        <Title>Microsoft CodeAnalysis OOM Exception </Title>
        <Description>Ported from https://github.com/dotnet/roslyn-analyzers/issues/1503

-----------------------------
@chillryan

I've reported this issue through the visual studio feedback tool [see link](https://developercommunity.visualstudio.com/content/problem/174842/visual-studio-155-crashes-when-switching-git-branc.html) but figured I'd try my chances posting here.

I'm using the Code Analysis 2017 extension for VS 2017 15.5. In looking at the stack trace, I can only assume that since the extension is running inside the devenv process, when its analysis a loaded solution, it hits the OOM. 

Since I've hit this situation a very frequent basis, I've disabled solution analysis for C# projects hoping that will help. I'll report back here if there are any changes or comment on the visual studio feedback link posted prior.
  </Description>
        <CreatedDate>04/01/2018</CreatedDate>
        <ClosedDate>16/01/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22920</IssueID>
        <Title>reduce diagnostic tagger's usages of UI thread for synchronization</Title>
        <Description>**Customer scenario**

Customer is working on a VS. doing code fix and watching previews, applying fix all and etc, and suddenly VS crash due to OOM.

**Bugs this fixes:**

https://devdiv.visualstudio.com/DevDiv/_workitems/edit/512757

**Workarounds, if any**

there is no easy workaround.

**Risk**

I don't see risk of crash, but since it is highly visible area (tagger), we probably want more dogfooding time for this.

**Performance impact**

it should move more work to background thread, and reduce need for UI thread. in turn, improving responsiveness and memory.

**Is this a regression from a previous update?**

Yes.

**Root cause analysis:**

this one is hard to pin point to 1 issue. but caused by several different fixes. 

first, we made all state management to happen on UI thread to remove any potential race. and that caused us to use more FG than before.

second, we merged preview only tagger with regular diagnostic tagger, making preview tagger to be as expansive as normal diagnostic tagger meaning it uses same amount of UI threads since it now has same states tracking as normal ones.

third, along with that, some filtering on BG got removed which was there to reduce work on FG since all those are changed to be done on FG. 

forth, diagnostic tagger didn't pass cancellation token all the way through, leaving already cancelled works in the UI work queue.

fifth, foreground work queue cleaned up cancelled works too lazily and let cancelled work to pile up.

..

this reduces demand for UI thread, but due to the fact that UI thread can be blocked (due to exclusive operation running such as Fix All, or model dialog box or Wait dialog box and more), we can't completely get rid of pending requests for UI threads. but with this change, we should have way less chance to hit 2.1 million pending UI requests.

**How was the bug found?**

MemoryWatson
</Description>
        <CreatedDate>31/10/2017</CreatedDate>
        <ClosedDate>29/11/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23377</IssueID>
        <Title>Batch up and flatten diagnostic updates.</Title>
        <Description>In response to https://github.com/dotnet/roslyn/pull/22920#issuecomment-346950158

This is a tweak to the diagnostic taggers to improve how they respond to a flood of notifications from the underlying diagnostic services.  There are a few improvements as part of this PR.  

1. We batch up diagnostic notifications over a 50ms window and process them all at once, instead of enqueing and processing each notification on the UI thread individually.
2. Because we're batching, we can do a lot of preprocessing of the notifications to throw out information that has been superceded.  For example, if we get a notification that we're actually removing all the diagnostics for a provider, we can just ignore all previous diagnostic-creates that we haven't processed yet.  Also, any more diagnostic creations we hear about will supercede previous diagnostic creations for that provider.  
</Description>
        <CreatedDate>26/11/2017</CreatedDate>
        <ClosedDate>16/01/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23409</IssueID>
        <Title>Batch up and flatten diagnostic updates, second approach.</Title>
        <Description>This is a followup to https://github.com/dotnet/roslyn/pull/23377.  The primary difference between this PR and that one is that we also do filtering of diagnostic events on teh BG (acknowledging that this is racey, but just as racey as before).</Description>
        <CreatedDate>28/11/2017</CreatedDate>
        <ClosedDate>16/01/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23411</IssueID>
        <Title>Batch up and flatten diagnostic updates, third approach.</Title>
        <Description>Followup to https://github.com/dotnet/roslyn/pull/23409.

But with a simpler batching model where we only have to store the latest args for any id+doc pair.  </Description>
        <CreatedDate>28/11/2017</CreatedDate>
        <ClosedDate>16/01/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/Core/Implementation/Diagnostics/AbstractDiagnosticsAdornmentTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Diagnostics/AbstractDiagnosticsTaggerProvider.AggregatingTagger.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Diagnostics/AbstractDiagnosticsTaggerProvider.TaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Diagnostics/AbstractDiagnosticsTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Diagnostics/DiagnosticsClassificationTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Diagnostics/DiagnosticsSquiggleTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Diagnostics/DiagnosticsSuggestionTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Tagging/TaggerContext.cs</File>
      <File>src/Workspaces/Core/Portable/Diagnostics/DiagnosticData.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>22100</IssueID>
    <Title>Make analyzer diagnostics independent of the current warning level</Title>
    <Description>Fixes #20377

**Customer scenario**

Sets the C# compiler warning level to 1, 2, or 3 (instead of the default 4). Several IDE features stop working, including fading out unused `using` directives and all "suggestion" level editor hints.

**Bugs this fixes:**

Fixes #20377.

**Workarounds, if any**

Set the compiler warning level to 4, then manually disable warnings it introduces. This works, and warning level 4 is certainly recommended, but users are not likely to understand why the IDE is "not working" when the warning level changes.

**Risk**

Low.

* The behavior in default and overwhelming majority scenarios does not change
* The behavior the edge case where `/warn:0` is used for the compiler to only show "true" errors is retained
* Diagnostic severity is not tied to diagnostic warning level, so the change is not even observable in most cases

**Performance impact**

For most users, performance will not change at all. For users with customized warning levels, performance could drop, but only because we would now be showing diagnostic results which were previously suppressed at the filtering stage.

**Is this a regression from a previous update?**

No.

**Root cause analysis:**

Almost no one uses warning level 3.

**How was the bug found?**

Observed broken functionality in [Microsoft/perfview](https://github.com/Microsoft/perfview).

**Test documentation updated?**

Unknown

&lt;!-- If this is a new non-compiler feature or a significant improvement to an existing feature, update https://github.com/dotnet/roslyn/wiki/Manual-Testing once you know which release it is targeting. --&gt;
</Description>
    <CreatedDate>13/09/2017</CreatedDate>
    <ClosedDate>16/01/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>20377</IssueID>
        <Title>Warning Level 3 breaks Remove Unused Usings and Simplify Type Name</Title>
        <Description>**Version Used**: 15.3 Preview 2.1

**Steps to Reproduce**:

1. Set C# warning level to 3
2. Add the following code

    ```csharp
    using System;
    using System.Threading;

    class Class
    {
      System.Action _action = (Action)(() =&gt; { });
    }
    ```

**Expected Behavior**:

1. `System.Threading` is indicated as an unused using directive, and the light bulb allows its removal
2. The `System.` qualification in `System.Action` is marked as unnecessary, and the light bulb allows the type to be simplified to `Action`

**Actual Behavior**:

1. Both using directives are indicated as used
2. `System.Action` is not indicated as overly qualified

Neither the light bulb nor the Remove and Sort Usings command may be used to make the desired corrections.</Description>
        <CreatedDate>21/06/2017</CreatedDate>
        <ClosedDate>16/01/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>20377</IssueID>
        <Title>Warning Level 3 breaks Remove Unused Usings and Simplify Type Name</Title>
        <Description>**Version Used**: 15.3 Preview 2.1

**Steps to Reproduce**:

1. Set C# warning level to 3
2. Add the following code

    ```csharp
    using System;
    using System.Threading;

    class Class
    {
      System.Action _action = (Action)(() =&gt; { });
    }
    ```

**Expected Behavior**:

1. `System.Threading` is indicated as an unused using directive, and the light bulb allows its removal
2. The `System.` qualification in `System.Action` is marked as unnecessary, and the light bulb allows the type to be simplified to `Action`

**Actual Behavior**:

1. Both using directives are indicated as used
2. `System.Action` is not indicated as overly qualified

Neither the light bulb nor the Remove and Sort Usings command may be used to make the desired corrections.</Description>
        <CreatedDate>21/06/2017</CreatedDate>
        <ClosedDate>16/01/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Test/Semantic/Diagnostics/GetDiagnosticsTests.cs</File>
      <File>src/Compilers/Core/Portable/Diagnostic/Diagnostic.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/SimplifyTypeNames/SimplifyTypeNamesTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/RemoveUnnecessaryImports/RemoveUnnecessaryImportsTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23794</IssueID>
    <Title>Do not allow source suppression for VS/host diagnostics</Title>
    <Description>This fixes the UI delay from force binding all assembly attributes during solution load.
Fixes #23775

&lt;details&gt;&lt;summary&gt;Ask Mode template&lt;/summary&gt;

### Customer scenario

Customer loads a solution that has more than one analyzer with conflicting dependency contents. This leads to analyzer conflict diagnostics getting reported during solution load. Reporting these diagnostic force completes binding of all assembly attributes in the compilation on the UI thread, causing a very large UI delay.

### Bugs this fixes

#23775

### Workarounds, if any

N/A

### Risk

Low. We are not executing a bunch of code that force completes the attributes to check for source suppressions. Users are recommended to suppress analyzer conflict diagnostics through compilation options.

### Performance impact

This should improve solution load performance in presence of analyzer dependency conflict diagnostics.

### Is this a regression from a previous update?

No.

### Root cause analysis

This was a known issue for a while, but we thought it was pretty rare, and something that would go away with us moving to new project system doing this work on a background thread.

### How was the bug found?

Dogfooding.

### Test documentation updated?

N/A

&lt;/details&gt;
</Description>
    <CreatedDate>14/12/2017</CreatedDate>
    <ClosedDate>15/12/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>23775</IssueID>
        <Title>AnalyzerDependencyCheckingService.CheckForConflictsAsync results in 15 seconds of blocked UI opening Roslyn</Title>
        <Description>**Version Used**: 
Visual Studio 2017 version 15.5

**Steps to Reproduce**:
1. Open a large solution where there are analyzer diagnostics in a "leaf" project.

**Expected Behavior**:
Solution should open in a reasonable time

**Actual Behavior**:
It's very slow, because creating the diagnostic requires a full compilation to be built and then examined for source level suppressions, and this happens synchronously on the UI thread as part of solution load.


`microsoft.visualstudio.languageservices   &lt;&lt;microsoft.visualstudio.languageservices!Microsoft.VisualStudio.LanguageServices.Implementation.AnalyzerDependencyCheckingService+&lt;CheckForConflictsAsync&gt;d__14.MoveNext()&gt;&gt; | 11.2 | 9,363.414 | 4,087`



</Description>
        <CreatedDate>14/12/2017</CreatedDate>
        <ClosedDate>15/12/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23775</IssueID>
        <Title>AnalyzerDependencyCheckingService.CheckForConflictsAsync results in 15 seconds of blocked UI opening Roslyn</Title>
        <Description>**Version Used**: 
Visual Studio 2017 version 15.5

**Steps to Reproduce**:
1. Open a large solution where there are analyzer diagnostics in a "leaf" project.

**Expected Behavior**:
Solution should open in a reasonable time

**Actual Behavior**:
It's very slow, because creating the diagnostic requires a full compilation to be built and then examined for source level suppressions, and this happens synchronously on the UI thread as part of solution load.


`microsoft.visualstudio.languageservices   &lt;&lt;microsoft.visualstudio.languageservices!Microsoft.VisualStudio.LanguageServices.Implementation.AnalyzerDependencyCheckingService+&lt;CheckForConflictsAsync&gt;d__14.MoveNext()&gt;&gt; | 11.2 | 9,363.414 | 4,087`



</Description>
        <CreatedDate>14/12/2017</CreatedDate>
        <ClosedDate>15/12/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/Core/Portable/Diagnostic/Diagnostic.cs</File>
      <File>src/Workspaces/Core/Portable/Diagnostics/DiagnosticData.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23610</IssueID>
    <Title>Fix UseNullPropagation codefix doesn't recognize `x is null ? null : x.y` pattern</Title>
    <Description>Fixes #23043. This should handle both the `x is null` and the `ReferenceEquals(x, null)` scenarios.

### Customer scenario

Visual Studio 2017 contains a "Use Null Propagation" analyzer and code fix that helps users convert conditional code (`if` statements and ternary expressions) into the new `?.` syntax. While the analysis already supports the most common styles of null checks, there were two specific cases that were simply ignored:

* Conditions based on the new pattern syntax: `x is null`
* Conditions based on calls to `object.ReferenceEquals`

### Bugs this fixes

Fixes #23043 

### Workarounds, if any

None needed

### Risk

Low¹. Changes are restricted to a single analyzer/fix, and tests² are added for all newly supported cases.

¹ ✔️ I need to apply a Fix All on Roslyn before and after this change to review the difference for bugs. (Confirmed via https://github.com/dotnet/roslyn/pull/23610#issuecomment-350328171)
² ✔️ Negative tests would be good as well. I am requesting them in review. (Confirmed via https://github.com/dotnet/roslyn/pull/23610#issuecomment-350294478)

### Performance impact

Should be low. The code was reviewed with consideration for known performance sensitivities in analyzers, and will be run through AnalyzerRunner prior to final release.

### Is this a regression from a previous update?

No.

### Root cause analysis

Previously identified optional work from a prior feature.

### How was the bug found?

Spec review of the original feature.

### Test documentation updated?

No.</Description>
    <CreatedDate>06/12/2017</CreatedDate>
    <ClosedDate>08/12/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>23043</IssueID>
        <Title>UseNullPropagation codefix doesn't recognize `x is null ? null : x.y` pattern</Title>
        <Description>Also, `ReferenceEquals(foo, null) ? null : foo.y`

```C#
        [Fact, Trait(Traits.Feature, Traits.Features.CodeActionsUseNullPropagation)]
        public async Task TestWithNullableTypeAndIsNull()
        {
            await TestInRegularAndScriptAsync(
@"
class C
{
    public int? f;
    void M(C c)
    {
        int? x = [||]c is null ? null : c.f;
    }
}",
@"
class C
{
    public int? f;
    void M(C c)
    {
        int? x = c?.f;
    }
}");
        }
```</Description>
        <CreatedDate>07/11/2017</CreatedDate>
        <ClosedDate>08/12/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23043</IssueID>
        <Title>UseNullPropagation codefix doesn't recognize `x is null ? null : x.y` pattern</Title>
        <Description>Also, `ReferenceEquals(foo, null) ? null : foo.y`

```C#
        [Fact, Trait(Traits.Feature, Traits.Features.CodeActionsUseNullPropagation)]
        public async Task TestWithNullableTypeAndIsNull()
        {
            await TestInRegularAndScriptAsync(
@"
class C
{
    public int? f;
    void M(C c)
    {
        int? x = [||]c is null ? null : c.f;
    }
}",
@"
class C
{
    public int? f;
    void M(C c)
    {
        int? x = c?.f;
    }
}");
        }
```</Description>
        <CreatedDate>07/11/2017</CreatedDate>
        <ClosedDate>08/12/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/UseNullPropagation/UseNullPropagationTests.cs</File>
      <File>src/Features/CSharp/Portable/UseNullPropagation/CSharpUseNullPropagationDiagnosticAnalyzer.cs</File>
      <File>src/Features/Core/Portable/UseNullPropagation/AbstractUseNullPropagationCodeFixProvider.cs</File>
      <File>src/Features/Core/Portable/UseNullPropagation/AbstractUseNullPropagationDiagnosticAnalyzer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23570</IssueID>
    <Title>Disallow use of 'out var' in __arglist.</Title>
    <Description>Fixes #23378.
Also, preserve and adjust arguments passed to 'new T'.

### Customer scenario

Type the following C# code ```__arglist(out var x)``` and observe a crash in a compiler.

### Bugs this fixes

#23378.

### Workarounds, if any

Do not use 'out var' as an argument for __arglist.

### Risk

Low

### Performance impact

Low perf impact because no extra allocations/no complexity changes

### Is this a regression from a previous update?

No

### Root cause analysis

There was a test gap. Added unit-tests.

### How was the bug found?

Customer reported 

### Test documentation updated?

N/A</Description>
    <CreatedDate>05/12/2017</CreatedDate>
    <ClosedDate>05/12/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>23378</IssueID>
        <Title>Using __arglist with `out var` causes Visual Studio to crash</Title>
        <Description>**Version Used**: 15.4.4 and 15.5.0 Preview 4

**Steps to Reproduce**:

1. Create a new console application targeting .NET Framework v4.7.1
2. Replace the entire contents of `Program.cs` with the following:
```cs
namespace ArgListOutVar
{
    public class Program
    {
        public static void Main(string[] args)
        {
            // __arglist(out var x);
            __arglist(out int y);
        }
    }
}
```
3. Remove a single `/` from line 7.

**Expected Behavior**: Visual Studio should not crash.

**Actual Behavior**: Visual Studio crashes. Below is the stack trace from debugging an instance of VS while reproducing this issue.

&lt;details&gt;
&lt;summary&gt;Exception Details&lt;/summary&gt;

```
System.InvalidOperationException
  HResult=0x80131509
  Message=This program location is thought to be unreachable.
  Source=Microsoft.CodeAnalysis.CSharp
  StackTrace:
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitOutVariablePendingInference(OutVariablePendingInference node)
   at Microsoft.CodeAnalysis.CSharp.OutVariablePendingInference.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitConversion(BoundConversion node)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.VisitConversion(BoundConversion node)
   at Microsoft.CodeAnalysis.CSharp.BoundConversion.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitLvalue(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitArguments(ImmutableArray`1 arguments, ImmutableArray`1 refKindsOpt, MethodSymbol method)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitArgListOperator(BoundArgListOperator node)
   at Microsoft.CodeAnalysis.CSharp.BoundArgListOperator.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitBadExpression(BoundBadExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundBadExpression.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitBinaryOperatorChildren(BoundBinaryOperator node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitBinaryOperator(BoundBinaryOperator node)
   at Microsoft.CodeAnalysis.CSharp.BoundBinaryOperator.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitExpressionStatement(BoundExpressionStatement node)
   at Microsoft.CodeAnalysis.CSharp.BoundExpressionStatement.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitStatement(BoundStatement statement)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.VisitStatementsWithLocalFunctions(BoundBlock block)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.VisitBlock(BoundBlock node)
   at Microsoft.CodeAnalysis.CSharp.BoundBlock.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Scan(Boolean&amp; badRegion)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.Scan(Boolean&amp; badRegion)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Analyze(Boolean&amp; badRegion)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.Analyze(Boolean&amp; badRegion, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.Analyze(CSharpCompilation compilation, Symbol member, BoundNode node, DiagnosticBag diagnostics, Boolean requireOutParamsAssigned)
   at Microsoft.CodeAnalysis.CSharp.FlowAnalysisPass.Rewrite(MethodSymbol method, BoundBlock block, DiagnosticBag diagnostics, Boolean hasTrailingExpression, Boolean originalBodyNested)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethod(MethodSymbol methodSymbol, Int32 methodOrdinal, ProcessedFieldInitializers&amp; processedInitializers, SynthesizedSubmissionFields previousSubmissionFields, TypeCompilationState compilationState)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(NamedTypeSymbol containingType)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.VisitNamedType(NamedTypeSymbol symbol, TypeCompilationState arg)
   at Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.Accept[TArgument,TResult](CSharpSymbolVisitor`2 visitor, TArgument argument)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamespace(NamespaceSymbol symbol)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.VisitNamespace(NamespaceSymbol symbol, TypeCompilationState arg)
   at Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol.Accept[TArgument,TResult](CSharpSymbolVisitor`2 visitor, TArgument argument)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamespace(NamespaceSymbol symbol)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethodBodies(CSharpCompilation compilation, PEModuleBuilder moduleBeingBuiltOpt, Boolean emittingPdb, Boolean emitTestCoverageData, Boolean hasDeclarationErrors, DiagnosticBag diagnostics, Predicate`1 filterOpt, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnosticsForMethodBodiesInTree(SyntaxTree tree, Nullable`1 span, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnosticsForSyntaxTree(CompilationStage stage, SyntaxTree syntaxTree, Nullable`1 filterSpanWithinTree, Boolean includeEarlierStages, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDiagnostics(Nullable`1 span, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.GenerateCompilationEvents(AnalysisScope analysisScope, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.&lt;GenerateCompilationEventsAndPopulateEventsCacheAsync&gt;d__58.MoveNext()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
```

&lt;/details&gt;
</Description>
        <CreatedDate>26/11/2017</CreatedDate>
        <ClosedDate>05/12/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23378</IssueID>
        <Title>Using __arglist with `out var` causes Visual Studio to crash</Title>
        <Description>**Version Used**: 15.4.4 and 15.5.0 Preview 4

**Steps to Reproduce**:

1. Create a new console application targeting .NET Framework v4.7.1
2. Replace the entire contents of `Program.cs` with the following:
```cs
namespace ArgListOutVar
{
    public class Program
    {
        public static void Main(string[] args)
        {
            // __arglist(out var x);
            __arglist(out int y);
        }
    }
}
```
3. Remove a single `/` from line 7.

**Expected Behavior**: Visual Studio should not crash.

**Actual Behavior**: Visual Studio crashes. Below is the stack trace from debugging an instance of VS while reproducing this issue.

&lt;details&gt;
&lt;summary&gt;Exception Details&lt;/summary&gt;

```
System.InvalidOperationException
  HResult=0x80131509
  Message=This program location is thought to be unreachable.
  Source=Microsoft.CodeAnalysis.CSharp
  StackTrace:
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitOutVariablePendingInference(OutVariablePendingInference node)
   at Microsoft.CodeAnalysis.CSharp.OutVariablePendingInference.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitConversion(BoundConversion node)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.VisitConversion(BoundConversion node)
   at Microsoft.CodeAnalysis.CSharp.BoundConversion.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitLvalue(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitArguments(ImmutableArray`1 arguments, ImmutableArray`1 refKindsOpt, MethodSymbol method)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitArgListOperator(BoundArgListOperator node)
   at Microsoft.CodeAnalysis.CSharp.BoundArgListOperator.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitBadExpression(BoundBadExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundBadExpression.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitBinaryOperatorChildren(BoundBinaryOperator node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitBinaryOperator(BoundBinaryOperator node)
   at Microsoft.CodeAnalysis.CSharp.BoundBinaryOperator.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitExpressionStatement(BoundExpressionStatement node)
   at Microsoft.CodeAnalysis.CSharp.BoundExpressionStatement.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitStatement(BoundStatement statement)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.VisitStatementsWithLocalFunctions(BoundBlock block)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.VisitBlock(BoundBlock node)
   at Microsoft.CodeAnalysis.CSharp.BoundBlock.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Scan(Boolean&amp; badRegion)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.Scan(Boolean&amp; badRegion)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Analyze(Boolean&amp; badRegion)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.Analyze(Boolean&amp; badRegion, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.Analyze(CSharpCompilation compilation, Symbol member, BoundNode node, DiagnosticBag diagnostics, Boolean requireOutParamsAssigned)
   at Microsoft.CodeAnalysis.CSharp.FlowAnalysisPass.Rewrite(MethodSymbol method, BoundBlock block, DiagnosticBag diagnostics, Boolean hasTrailingExpression, Boolean originalBodyNested)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethod(MethodSymbol methodSymbol, Int32 methodOrdinal, ProcessedFieldInitializers&amp; processedInitializers, SynthesizedSubmissionFields previousSubmissionFields, TypeCompilationState compilationState)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(NamedTypeSymbol containingType)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.VisitNamedType(NamedTypeSymbol symbol, TypeCompilationState arg)
   at Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.Accept[TArgument,TResult](CSharpSymbolVisitor`2 visitor, TArgument argument)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamespace(NamespaceSymbol symbol)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.VisitNamespace(NamespaceSymbol symbol, TypeCompilationState arg)
   at Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol.Accept[TArgument,TResult](CSharpSymbolVisitor`2 visitor, TArgument argument)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamespace(NamespaceSymbol symbol)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethodBodies(CSharpCompilation compilation, PEModuleBuilder moduleBeingBuiltOpt, Boolean emittingPdb, Boolean emitTestCoverageData, Boolean hasDeclarationErrors, DiagnosticBag diagnostics, Predicate`1 filterOpt, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnosticsForMethodBodiesInTree(SyntaxTree tree, Nullable`1 span, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnosticsForSyntaxTree(CompilationStage stage, SyntaxTree syntaxTree, Nullable`1 filterSpanWithinTree, Boolean includeEarlierStages, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDiagnostics(Nullable`1 span, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.GenerateCompilationEvents(AnalysisScope analysisScope, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.&lt;GenerateCompilationEventsAndPopulateEventsCacheAsync&gt;d__58.MoveNext()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
```

&lt;/details&gt;
</Description>
        <CreatedDate>26/11/2017</CreatedDate>
        <ClosedDate>05/12/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Expressions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Invocation.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IConversionExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/ObjectAndCollectionInitializerTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/OutVarTests.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/OperationTreeVerifier.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23505</IssueID>
    <Title>Reduce the number of attributes that should be bound in order to determine if there are NoPia local types explicitly defined in code.</Title>
    <Description>Fixes #23179.

### Customer scenario

Today compilers bind all attributes on all top level types in order to determine if there are NoPia local types explicitly defined in code. This information is necessary every time a project to project reference is created. NoPia local types explicitly defined in code are extremely uncommon, but attributes binding can be expensive if there are a lot of them. We have a customer that apparently experiences IDE performance and/or reliability problems because of that.

### Bugs this fixes

#23179

### Workarounds, if any

None

### Risk

Low

### Performance impact

Low perf impact because in a common scenario we will be doing less work than before.

### Is this a regression from a previous update?

No

### Root cause analysis

Unit-tests added.

### How was the bug found?

Customer reported

### Test documentation updated?

N/A</Description>
    <CreatedDate>30/11/2017</CreatedDate>
    <ClosedDate>07/12/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>23179</IssueID>
        <Title>SourceModuleSymbol.ContainsExplicitDefinitionOfNoPiaLocalTypes forces expensive binding</Title>
        <Description>`SourceModuleSymbol.ContainsExplicitDefinitionOfNoPiaLocalTypes` forces all attributes to be bound, resulting in extreme performance and/or reliability problems when using the IDE.

https://github.com/dotnet/roslyn/blob/a604cefecd2cba10803a872c580cfb7a9e0883ad/src/Compilers/CSharp/Portable/Symbols/Source/SourceModuleSymbol.cs#L146-L150

🔗 [Slowdown and then crash](https://developercommunity.visualstudio.com/content/problem/136307/slowdown-and-then-crash.html) ([Internal feedback ticket](https://devdiv.visualstudio.com/DevDiv/_workitems/edit/513336))
:link: [Slowdown and Crash #3](https://developercommunity.visualstudio.com/content/problem/136317/slowdown-and-crash-3.html) ([Internal feedback ticket](https://devdiv.visualstudio.com/DevDiv/_workitems/edit/513345))</Description>
        <CreatedDate>15/11/2017</CreatedDate>
        <ClosedDate>07/12/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23179</IssueID>
        <Title>SourceModuleSymbol.ContainsExplicitDefinitionOfNoPiaLocalTypes forces expensive binding</Title>
        <Description>`SourceModuleSymbol.ContainsExplicitDefinitionOfNoPiaLocalTypes` forces all attributes to be bound, resulting in extreme performance and/or reliability problems when using the IDE.

https://github.com/dotnet/roslyn/blob/a604cefecd2cba10803a872c580cfb7a9e0883ad/src/Compilers/CSharp/Portable/Symbols/Source/SourceModuleSymbol.cs#L146-L150

🔗 [Slowdown and then crash](https://developercommunity.visualstudio.com/content/problem/136307/slowdown-and-then-crash.html) ([Internal feedback ticket](https://devdiv.visualstudio.com/DevDiv/_workitems/edit/513336))
:link: [Slowdown and Crash #3](https://developercommunity.visualstudio.com/content/problem/136317/slowdown-and-crash-3.html) ([Internal feedback ticket](https://devdiv.visualstudio.com/DevDiv/_workitems/edit/513345))</Description>
        <CreatedDate>15/11/2017</CreatedDate>
        <ClosedDate>07/12/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/BuckStopsHereBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/InContainerBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/QuickTypeIdentifierAttributeChecker.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceModuleSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceNamedTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/TypeTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23491</IssueID>
    <Title>Avoid allocations in IsDefinedInSourceTree hot paths</Title>
    <Description>Fixes #23462

:memo: This is an alternate approach to the one seen in #23490. This approach has more code duplication, but further reduces memory usage and can't increase memory footprint due to caching.

### Customer scenario

Running analyzer during a build is slower than it should be, with the analyzer driver contributing substantial overhead even when the analyzers themselves are lightweight.

### Bugs this fixes

Fixes #23462

### Workarounds, if any

None needed

### Risk

This poses a small maintainability risk by duplicating an existing algorithm into a new form for the sole benefit of reducing allocations. The risk is partially mitigated by comment(s) in the source code, and justified by AnalyzerRunner indicating the code lies on a particularly hot path.

### Performance impact

6% reduction in allocations for running IDE analyzers.

### Is this a regression from a previous update?

No.

### Root cause analysis

AnalyzerRunner is a new tool for helping us test analyzer performance in isolation.

### How was the bug found?

AnalyzerRunner.

### Test documentation updated?

No.

</Description>
    <CreatedDate>30/11/2017</CreatedDate>
    <ClosedDate>01/12/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>23462</IssueID>
        <Title>Optimize allocations in IsDefinedInSourceTree hot paths</Title>
        <Description>AnalyzerRunner is showing a few allocation hot paths in `IsDefinedInSourceTree`. The primary cases are:

* 677MB (3.5%): `Symbol.IsDefinedInSourceTree` &amp;rarr; `SourceMemberContainerTypeSymbol.DeclaringSyntaxReferences` &amp;rarr; `MergedTypeDeclaration.SyntaxReferences`
    * 677MB: `SyntaxReference[]`
* 475MB (2.5%): `SourceNamespaceSymbol.IsDefinedInSourceTree` &amp;rarr; `SourceNamespaceSymbol.DeclaringSyntaxReferences`
    * 372MB: `NamespaceDeclarationSyntaxReference`
    * 103MB: `SyntaxReference[]`</Description>
        <CreatedDate>29/11/2017</CreatedDate>
        <ClosedDate>01/12/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23490</IssueID>
        <Title>Optimize allocations in IsDefinedInSourceTree hot paths </Title>
        <Description>Fix for #23462
This solutions lazy caches the SyntaxReferences array in the same way the [Children](http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Declarations/MergedTypeDeclaration.cs,196) property is cached a few lines down in the same class.

If this is the way to got the same solution can be adopted for the other property (SourceNamespaceSymbol.DeclaringSyntaxReferences) mentioned in the issue.

No additional tests are provided. See performance impact below for details on how I measured the impact of the change.

### Customer scenario

Avoid array allocations in hot path.

### Bugs this fixes

#23462

### Workarounds, if any

No.

### Risk

This solution avoids allocations by caching SyntaxReferences. The cache may increase memory usage. The cached array should be small (❓  0 to 1 references are the common case. More references are only stored for partial definitions).

### Performance impact

The performance impact was measured on solution load of a console app with only Program.cs and 100 lines of code (VS start -&gt; Load Solution -&gt; Wait a minute for warmup).
Before:
1.300 allocating calls of the now removed line
`return _declarations.SelectAsArray(r =&gt; r.SyntaxReference);` 
After:
2 allocating calls
```
    if (_lazySyntaxReferences.IsDefault) 
    {
        // Number of calls measured on next line
        ImmutableInterlocked.InterlockedInitialize(ref _lazySyntaxReferences, _declarations.SelectAsArray(r =&gt; r.SyntaxReference)); 
    } 
    return _lazySyntaxReferences; 
```

### Is this a regression from a previous update?

I don't know.

### Root cause analysis

I don't know.

### How was the bug found?

via Watson and AnalyzerWatcher. See #23462 and ask @sharwell for details.

### Test documentation updated?
</Description>
        <CreatedDate>30/11/2017</CreatedDate>
        <ClosedDate>01/12/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23462</IssueID>
        <Title>Optimize allocations in IsDefinedInSourceTree hot paths</Title>
        <Description>AnalyzerRunner is showing a few allocation hot paths in `IsDefinedInSourceTree`. The primary cases are:

* 677MB (3.5%): `Symbol.IsDefinedInSourceTree` &amp;rarr; `SourceMemberContainerTypeSymbol.DeclaringSyntaxReferences` &amp;rarr; `MergedTypeDeclaration.SyntaxReferences`
    * 677MB: `SyntaxReference[]`
* 475MB (2.5%): `SourceNamespaceSymbol.IsDefinedInSourceTree` &amp;rarr; `SourceNamespaceSymbol.DeclaringSyntaxReferences`
    * 372MB: `NamespaceDeclarationSyntaxReference`
    * 103MB: `SyntaxReference[]`</Description>
        <CreatedDate>29/11/2017</CreatedDate>
        <ClosedDate>01/12/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceMemberContainerSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceNamespaceSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/NamespaceDeclarationSyntaxReference.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23458</IssueID>
    <Title>Perform a lightweight syntax check before getting document options</Title>
    <Description>### Customer scenario

A user has the Validate String Format analyzer enabled, and it uses more CPU than it needs to.

### Bugs this fixes

N/A

### Workarounds, if any

None needed.

### Risk

Low. The analysis conditions are not changed, but are simply reordered so a check that generally fails quickly executes before one that takes longer to complete.

### Performance impact

Improves performance. Times are in milliseconds running the analyzers on OrchardCMS/Orchard@941c6912ae2eaba60896758cc60f1dc54c142be4, and the compiler at 2b39919ba6eebb6b22524db11a537fe247ee8a79+#23087+#23457.

|  | Options first | Syntax first (this PR) |
| --- | --- | --- |
| **Non-concurrent** | 1262 | 1000 |
| **Concurrent** (#23423) | 1262 | 775 |

### Is this a regression from a previous update?

No.

### Root cause analysis

AnalyzerRunner was not available previously.

### How was the bug found?

AnalyzerRunner.

### Test documentation updated?

No.</Description>
    <CreatedDate>29/11/2017</CreatedDate>
    <ClosedDate>07/12/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>23087</IssueID>
        <Title>Analyzer Runner tool</Title>
        <Description>This is a draft version of the analyzer runner tool which should be used for execution analyzers against a given solution and measuring their performance.

The code is based on [StyleCopAnalyzers](https://github.com/DotNetAnalyzers/StyleCopAnalyzers/)

Closes #23104</Description>
        <CreatedDate>09/11/2017</CreatedDate>
        <ClosedDate>19/05/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23457</IssueID>
        <Title>Avoid skewing analysis time when logging analyzer times</Title>
        <Description>### Customer scenario

A user attempts to run analyzers through the Roslyn API for performance testing. The measured performance overhead is significantly greater than the observed overhead for the analyzer in other cases.

### Bugs this fixes

N/A

### Workarounds, if any

None

### Risk

Low. The code was only intended to add stability to analyzer performance testing. After running the code through AnalyzerRunner, measurements indicated that the approach caused substantial performance overhead which obscured the true performance of the analyzers. The issue was most apparent during document edit testing (#23104).

### Performance impact

For applications like Visual Studio, no change in performance. For some applications using the Roslyn API, e.g. AnalyzerRunner, performance is either unchanged or improved.

### Is this a regression from a previous update?

No.

### Root cause analysis

Analyzer performance was only tested in limited scenarios previously.

### How was the bug found?

AnalyzerRunner

### Test documentation updated?

No.</Description>
        <CreatedDate>29/11/2017</CreatedDate>
        <ClosedDate>06/01/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23423</IssueID>
        <Title>Enable concurrent execution for all built-in C# analyzers</Title>
        <Description>Eliminates a large amount of unnecessary performance overhead due to serializing analyzers when running in the OOP host.

### Customer scenario

A user attempts to use a Fix All operation, and the initial analysis phase to find all diagnostics to fix is very slow. Alternately, a user turns on Full Solution Analysis, and the time taken to run the analyzers is very slow.

### Bugs this fixes

N/A

### Workarounds, if any

* Wait longer
* Leave Full Solution Analysis disabled

### Risk

Low:

1. All of our analyzers were designed to be stateless so concurrent analysis *could* be enabled.
2. The primary performance concern - overwhelming devenv.exe with analysis operations - is not likely to result in problems because the in-process analyzer driver never uses multiple threads.

### Performance impact

Improves performance by reducing monitor contention. The difference is most apparent on analyzers that are register callbacks for a large number of syntax nodes, but have an early return fast path that applies to the majority of cases. The performance improvement was measured at up to 30% for some lightweight analyzers.

Note that for some analysis situations, performance is not improved by this change in isolation. This tends to impact cases where large numbers of analyzers are used in a manner that causes substantial GC overhead. Profiling indicates that these are "downstream" issues and I would not consider them a contraindication for this change.

### Is this a regression from a previous update?

No.

### Root cause analysis

* No performance testing of analyzers at scale.
* No unit tests to ensure analyzers are registered as concurrent.

### How was the bug found?

Found with AnalyzerRunner, verified with profiling.

### Test documentation updated?

N/A
</Description>
        <CreatedDate>28/11/2017</CreatedDate>
        <ClosedDate>29/11/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/Core/Portable/InternalUtilities/PerformanceSensitiveAttribute.cs</File>
      <File>src/Features/Core/Portable/ValidateFormatString/AbstractValidateFormatStringDiagnosticAnalyzer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23438</IssueID>
    <Title>Several small bug fixes related to readonly references.</Title>
    <Description>Fixes some bugs related to readonly references.

Fixes:#23422
Null-conditional operators should not be allowed with members that return restricted or ref-like types.
Similarly to unconstrained generics or pointers - these types cannot be used to form nullables.
Allowing such types result in crashes at run time or even at compile time, depending on scenario.

Fixes:#23338
Consider special members of `Nullable&lt;T&gt;` nonmutating. 
Example: Not doing defensive copies when invoking `GetValueOrDefault` on readonly variables.
Related to: https://github.com/dotnet/corefx/issues/24900

Fixes:#23166
Removes unused parameters in CheckFieldRefEscape and CheckEventRefEscape


### Customer scenario

- Customer uses null conditional operator `obj?.Member()` where `Member()` returns stack-only type such as `Span&lt;T&gt;` or `TypedReference`. The code should result in compiler error since it would lead to `Nullable&lt;Span&lt;T&gt;&gt;` or `Nullable&lt;TypedReference&gt;` and that is disallowed by JIT/CLR. 
Instead C# compiler crashes and VB compiler successfully compiles IL that fails to JIT.

- Customer uses code that performs some lifted operations with  `readonly` variable (like a field) that has `Nullable` type. 
In such scenario compiler frequently emits calls to special methods on `Nullable` such as `GetValueOrDefault`. The codegen of such calls is suboptimial. The calls are performed on copies, because compiler conservatively treat these helpers as potentially mutating the value.
We know for sure that these members are not mutating. That is required for their correctness and for soundness of `Nullable` operations. We do not need defensive copies.

- there are couple of redundant parameters found by an  "unused parameters" analyzer. 

### Bugs this fixes

Fixes:#23422
Fixes:#23338
Fixes:#23166

### Workarounds, if any

User must be careful to not use `?.` with stack-only types. 
No workaround for extra nullable copy.

### Risk

Very low. We are just adding some simple conditions to already existing functionality.

### Performance impact

Very low for the same reason.

### Is this a regression from a previous update?

No.

### Root cause analysis

The "?." crashing bug is actually fairly old. Now easier to expose with ref-like types such as `Span`

### How was the bug found?

Reported by external customers.

### Test documentation updated?

N/A</Description>
    <CreatedDate>28/11/2017</CreatedDate>
    <ClosedDate>05/12/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>23422</IssueID>
        <Title>Unexpected value 'NullCoalescingOperator expression of System.Span&lt;byte&gt; type' of type 'System.String'</Title>
        <Description>**Version Used**: 
![image](https://user-images.githubusercontent.com/95136/33313758-71ffab54-d3e0-11e7-916d-b428514f369a.png)

**Steps to Reproduce**:

```C#
public class Foo
{
   public Span&lt;byte&gt; Span =&gt; Span&lt;byte&gt;.Empty;
}

public void Method()
{
   Foo foo = null;
   var span = foo?.Span ?? Span&lt;byte&gt;.Empty;
}

```

**Expected Behavior**:
No Crash

**Actual Behavior**:
Crash

```
Log Name:      Application
Source:        .NET Runtime
Date:          11/28/2017 2:01:22 AM
Event ID:      1025
Task Category: None
Level:         Error
Keywords:      Classic
User:          N/A
Description:
Application: devenv.exe
Framework Version: v4.0.30319
Description: The application requested process termination through System.Environment.FailFast(string message).
Message: System.InvalidOperationException: Unexpected value 'NullCoalescingOperator expression of System.Span&lt;byte&gt; type' of type 'System.String'
   at Microsoft.CodeAnalysis.CSharp.Binder.GetValEscape(BoundExpression expr, UInt32 scopeOfTheContainingExpression)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindVariableDeclaration(SourceLocalSymbol localSymbol, LocalDeclarationKind kind, Boolean isVar, VariableDeclaratorSyntax declarator, TypeSyntax typeSyntax, TypeSymbol declTypeOpt, AliasSymbol aliasOpt, DiagnosticBag diagnostics, CSharpSyntaxNode associatedSyntaxNode)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindDeclarationStatementParts(LocalDeclarationStatementSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.IncrementalBinder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLowerBoundNode(CSharpSyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node, CSharpSyntaxNode&amp; bindableNode, BoundNode&amp; lowestBoundNode, BoundNode&amp; highestBoundNode, BoundNode&amp; boundParent)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetSymbolInfoWorker(CSharpSyntaxNode node, SymbolInfoOptions options, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(ExpressionSyntax expression, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.ClassifyTypeSyntax(NameSyntax name, SemanticModel semanticModel, ArrayBuilder`1 result, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.AddClassifications(SyntaxNode syntax, SemanticModel semanticModel, ArrayBuilder`1 result, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.Worker.ClassifyNode(SyntaxNode syntax)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.Worker.ProcessNodes()
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.Worker.Classify(Workspace workspace, SemanticModel semanticModel, TextSpan textSpan, ArrayBuilder`1 list, Func`2 getNodeClassifiers, Func`2 getTokenClassifiers, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.&lt;AddSemanticClassificationsAsync&gt;d__5.MoveNext()
Stack:
   at System.Environment.FailFast(System.String, System.Exception)
   at Microsoft.CodeAnalysis.FailFast.OnFatalException(System.Exception)
   at Microsoft.CodeAnalysis.ErrorReporting.FatalError.Report(System.Exception, System.Action`1&lt;System.Exception&gt;)
   at Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportUnlessCanceled(System.Exception)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__5.MoveNext()
   at Microsoft.CodeAnalysis.CSharp.Binder.GetValEscape(Microsoft.CodeAnalysis.CSharp.BoundExpression, UInt32)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindVariableDeclaration(Microsoft.CodeAnalysis.CSharp.Symbols.SourceLocalSymbol, Microsoft.CodeAnalysis.CSharp.Symbols.LocalDeclarationKind, Boolean, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax, Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, Microsoft.CodeAnalysis.CSharp.Symbols.AliasSymbol, Microsoft.CodeAnalysis.DiagnosticBag, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindDeclarationStatementParts(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel+IncrementalBinder.BindStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Bind(Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.Bind(Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLowerBoundNode(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetSymbolInfoWorker(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, SymbolInfoOptions, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.ClassifyTypeSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax, Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.AddClassifications(Microsoft.CodeAnalysis.SyntaxNode, Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+Worker.ClassifyNode(Microsoft.CodeAnalysis.SyntaxNode)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+Worker.ProcessNodes()
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+Worker.Classify(Microsoft.CodeAnalysis.Workspace, Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.Text.TextSpan, Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__5.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__5, Microsoft.CodeAnalysis.Workspaces, Version=2.6.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;AddSemanticClassificationsAsync&gt;d__5 ByRef)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Document, Microsoft.CodeAnalysis.Text.TextSpan, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__2.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Classification.AbstractClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__2, Microsoft.CodeAnalysis.Workspaces, Version=2.6.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;AddSemanticClassificationsAsync&gt;d__2 ByRef)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Document, Microsoft.CodeAnalysis.Text.TextSpan, System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.WorkspaceClassificationDelegationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Classification.IClassificationService, Microsoft.CodeAnalysis.Document, Microsoft.CodeAnalysis.Text.TextSpan, System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ClassifySpansAsync&gt;d__2`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ClassifySpansAsync&gt;d__2`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Microsoft.CodeAnalysis.EditorFeatures, Version=2.6.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;ClassifySpansAsync&gt;d__2`1&lt;System.__Canon&gt; ByRef)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.ClassifySpansAsync[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IClassificationDelegationService`1&lt;System.__Canon&gt;, System.__Canon, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;TryClassifyContainingMemberSpan&gt;d__1`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].Start[[Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;TryClassifyContainingMemberSpan&gt;d__1`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Microsoft.CodeAnalysis.EditorFeatures, Version=2.6.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;TryClassifyContainingMemberSpan&gt;d__1`1&lt;System.__Canon&gt; ByRef)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.TryClassifyContainingMemberSpan[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IClassificationDelegationService`1&lt;System.__Canon&gt;, System.__Canon, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ProduceTagsAsync&gt;d__0`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ProduceTagsAsync&gt;d__0`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Microsoft.CodeAnalysis.EditorFeatures, Version=2.6.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;ProduceTagsAsync&gt;d__0`1&lt;System.__Canon&gt; ByRef)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.ProduceTagsAsync[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IClassificationDelegationService`1&lt;System.__Canon&gt;, System.__Canon, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationViewTaggerProvider.ProduceTagsAsync[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IClassificationDelegationService`1&lt;System.__Canon&gt;)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationViewTaggerProvider.ProduceTagsAsync(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;)
   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].ProduceTagsAsync(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;System.__Canon&gt;)
   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource+&lt;RecomputeTagsAsync&gt;d__73[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource+&lt;RecomputeTagsAsync&gt;d__73[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Microsoft.CodeAnalysis.EditorFeatures, Version=2.6.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;RecomputeTagsAsync&gt;d__73&lt;System.__Canon&gt; ByRef)
   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].RecomputeTagsAsync(System.Object, System.Nullable`1&lt;Microsoft.VisualStudio.Text.SnapshotPoint&gt;, System.Nullable`1&lt;Microsoft.CodeAnalysis.Text.TextChangeRange&gt;, System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan&gt;, System.Collections.Immutable.ImmutableDictionary`2&lt;Microsoft.VisualStudio.Text.ITextBuffer,Microsoft.CodeAnalysis.Editor.Shared.Tagging.TagSpanIntervalTree`1&lt;System.__Canon&gt;&gt;, Boolean, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource+&lt;&gt;c__DisplayClass63_0[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].&lt;RecomputeTagsForeground&gt;b__0(System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.Shared.Threading.AsynchronousSerialWorkQueue+&lt;&gt;c__DisplayClass11_0.&lt;EnqueueBackgroundTask&gt;b__0(System.Threading.Tasks.Task)
   at System.Threading.Tasks.ContinuationResultTaskFromTask`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].InnerInvoke()
   at System.Threading.Tasks.Task.Execute()
   at System.Threading.Tasks.Task.ExecutionContextCallback(System.Object)
   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)
   at System.Threading.Tasks.Task.ExecuteEntry(Boolean)
   at System.Threading.Tasks.Task.System.Threading.IThreadPoolWorkItem.ExecuteWorkItem()
   at System.Threading.ThreadPoolWorkQueue.Dispatch()
   at System.Threading._ThreadPoolWaitCallback.PerformWaitCallback()
```

/cc @VSadov </Description>
        <CreatedDate>28/11/2017</CreatedDate>
        <ClosedDate>05/12/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23338</IssueID>
        <Title>Unnecessary defensive copy of an `in` parameter is created, whose type is nullable readonly struct</Title>
        <Description>**Version Used**: 

Version 15.5.0 Preview 4.0
VisualStudio.15.Preview/15.5.0-pre.4.0+27110.0

Visual C# 2017 00369-60000-00001-AA127
Microsoft Visual C# 2017

C# 7.2

**Steps to Reproduce**:

Compile and inspect IL:
```
using System;

readonly struct S
{
    readonly decimal d;

    public S(decimal d)
    {
        this.d = d;
    }
}

class P
{
    static void Foo(in S? x)
    {
        Console.WriteLine(x.GetValueOrDefault());
    }
    
    static void Main()
    {
        S? y = new S(5m);
        Foo(y);
    }
}
```
**Actual Behavior**:
The `in` parameter `x` in the method  `Foo` is copied to a compiler-generated local before `GetValueOrDefault()` is invoked.

**Expected Behavior**:
This copy is unnecessary and should be elided. No method or property of a nullable value type can mutate it if the underlying type is a readonly struct.</Description>
        <CreatedDate>21/11/2017</CreatedDate>
        <ClosedDate>05/12/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23166</IssueID>
        <Title>Unused parameter in Microsoft.CodeAnalysis.CSharp.Binder.CheckFieldRefEscape (potential bug?)</Title>
        <Description>Enabling CA1801 (unused parameter rule) fires it for [CheckFieldRefEscape](http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Binder/Binder.ValueChecks.cs,a204c04b97fd2e6c) and [CheckFieldLikeEventRefEscape](http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Binder/Binder.ValueChecks.cs,09e0b3ce0e53064a) for parameter `checkingReceiver` being unused. We should either use this parameter or remove it from the signature.</Description>
        <CreatedDate>14/11/2017</CreatedDate>
        <ClosedDate>05/12/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23422</IssueID>
        <Title>Unexpected value 'NullCoalescingOperator expression of System.Span&lt;byte&gt; type' of type 'System.String'</Title>
        <Description>**Version Used**: 
![image](https://user-images.githubusercontent.com/95136/33313758-71ffab54-d3e0-11e7-916d-b428514f369a.png)

**Steps to Reproduce**:

```C#
public class Foo
{
   public Span&lt;byte&gt; Span =&gt; Span&lt;byte&gt;.Empty;
}

public void Method()
{
   Foo foo = null;
   var span = foo?.Span ?? Span&lt;byte&gt;.Empty;
}

```

**Expected Behavior**:
No Crash

**Actual Behavior**:
Crash

```
Log Name:      Application
Source:        .NET Runtime
Date:          11/28/2017 2:01:22 AM
Event ID:      1025
Task Category: None
Level:         Error
Keywords:      Classic
User:          N/A
Description:
Application: devenv.exe
Framework Version: v4.0.30319
Description: The application requested process termination through System.Environment.FailFast(string message).
Message: System.InvalidOperationException: Unexpected value 'NullCoalescingOperator expression of System.Span&lt;byte&gt; type' of type 'System.String'
   at Microsoft.CodeAnalysis.CSharp.Binder.GetValEscape(BoundExpression expr, UInt32 scopeOfTheContainingExpression)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindVariableDeclaration(SourceLocalSymbol localSymbol, LocalDeclarationKind kind, Boolean isVar, VariableDeclaratorSyntax declarator, TypeSyntax typeSyntax, TypeSymbol declTypeOpt, AliasSymbol aliasOpt, DiagnosticBag diagnostics, CSharpSyntaxNode associatedSyntaxNode)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindDeclarationStatementParts(LocalDeclarationStatementSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.IncrementalBinder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLowerBoundNode(CSharpSyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node, CSharpSyntaxNode&amp; bindableNode, BoundNode&amp; lowestBoundNode, BoundNode&amp; highestBoundNode, BoundNode&amp; boundParent)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetSymbolInfoWorker(CSharpSyntaxNode node, SymbolInfoOptions options, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(ExpressionSyntax expression, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.ClassifyTypeSyntax(NameSyntax name, SemanticModel semanticModel, ArrayBuilder`1 result, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.AddClassifications(SyntaxNode syntax, SemanticModel semanticModel, ArrayBuilder`1 result, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.Worker.ClassifyNode(SyntaxNode syntax)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.Worker.ProcessNodes()
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.Worker.Classify(Workspace workspace, SemanticModel semanticModel, TextSpan textSpan, ArrayBuilder`1 list, Func`2 getNodeClassifiers, Func`2 getTokenClassifiers, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.&lt;AddSemanticClassificationsAsync&gt;d__5.MoveNext()
Stack:
   at System.Environment.FailFast(System.String, System.Exception)
   at Microsoft.CodeAnalysis.FailFast.OnFatalException(System.Exception)
   at Microsoft.CodeAnalysis.ErrorReporting.FatalError.Report(System.Exception, System.Action`1&lt;System.Exception&gt;)
   at Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportUnlessCanceled(System.Exception)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__5.MoveNext()
   at Microsoft.CodeAnalysis.CSharp.Binder.GetValEscape(Microsoft.CodeAnalysis.CSharp.BoundExpression, UInt32)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindVariableDeclaration(Microsoft.CodeAnalysis.CSharp.Symbols.SourceLocalSymbol, Microsoft.CodeAnalysis.CSharp.Symbols.LocalDeclarationKind, Boolean, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax, Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, Microsoft.CodeAnalysis.CSharp.Symbols.AliasSymbol, Microsoft.CodeAnalysis.DiagnosticBag, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindDeclarationStatementParts(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel+IncrementalBinder.BindStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Bind(Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.Bind(Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLowerBoundNode(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetSymbolInfoWorker(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, SymbolInfoOptions, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.ClassifyTypeSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax, Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.AddClassifications(Microsoft.CodeAnalysis.SyntaxNode, Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+Worker.ClassifyNode(Microsoft.CodeAnalysis.SyntaxNode)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+Worker.ProcessNodes()
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+Worker.Classify(Microsoft.CodeAnalysis.Workspace, Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.Text.TextSpan, Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__5.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__5, Microsoft.CodeAnalysis.Workspaces, Version=2.6.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;AddSemanticClassificationsAsync&gt;d__5 ByRef)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Document, Microsoft.CodeAnalysis.Text.TextSpan, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__2.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Classification.AbstractClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__2, Microsoft.CodeAnalysis.Workspaces, Version=2.6.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;AddSemanticClassificationsAsync&gt;d__2 ByRef)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Document, Microsoft.CodeAnalysis.Text.TextSpan, System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.WorkspaceClassificationDelegationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Classification.IClassificationService, Microsoft.CodeAnalysis.Document, Microsoft.CodeAnalysis.Text.TextSpan, System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ClassifySpansAsync&gt;d__2`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ClassifySpansAsync&gt;d__2`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Microsoft.CodeAnalysis.EditorFeatures, Version=2.6.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;ClassifySpansAsync&gt;d__2`1&lt;System.__Canon&gt; ByRef)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.ClassifySpansAsync[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IClassificationDelegationService`1&lt;System.__Canon&gt;, System.__Canon, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;TryClassifyContainingMemberSpan&gt;d__1`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].Start[[Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;TryClassifyContainingMemberSpan&gt;d__1`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Microsoft.CodeAnalysis.EditorFeatures, Version=2.6.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;TryClassifyContainingMemberSpan&gt;d__1`1&lt;System.__Canon&gt; ByRef)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.TryClassifyContainingMemberSpan[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IClassificationDelegationService`1&lt;System.__Canon&gt;, System.__Canon, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ProduceTagsAsync&gt;d__0`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ProduceTagsAsync&gt;d__0`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Microsoft.CodeAnalysis.EditorFeatures, Version=2.6.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;ProduceTagsAsync&gt;d__0`1&lt;System.__Canon&gt; ByRef)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.ProduceTagsAsync[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IClassificationDelegationService`1&lt;System.__Canon&gt;, System.__Canon, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationViewTaggerProvider.ProduceTagsAsync[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IClassificationDelegationService`1&lt;System.__Canon&gt;)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationViewTaggerProvider.ProduceTagsAsync(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;)
   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].ProduceTagsAsync(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;System.__Canon&gt;)
   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource+&lt;RecomputeTagsAsync&gt;d__73[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource+&lt;RecomputeTagsAsync&gt;d__73[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Microsoft.CodeAnalysis.EditorFeatures, Version=2.6.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;RecomputeTagsAsync&gt;d__73&lt;System.__Canon&gt; ByRef)
   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].RecomputeTagsAsync(System.Object, System.Nullable`1&lt;Microsoft.VisualStudio.Text.SnapshotPoint&gt;, System.Nullable`1&lt;Microsoft.CodeAnalysis.Text.TextChangeRange&gt;, System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan&gt;, System.Collections.Immutable.ImmutableDictionary`2&lt;Microsoft.VisualStudio.Text.ITextBuffer,Microsoft.CodeAnalysis.Editor.Shared.Tagging.TagSpanIntervalTree`1&lt;System.__Canon&gt;&gt;, Boolean, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource+&lt;&gt;c__DisplayClass63_0[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].&lt;RecomputeTagsForeground&gt;b__0(System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.Shared.Threading.AsynchronousSerialWorkQueue+&lt;&gt;c__DisplayClass11_0.&lt;EnqueueBackgroundTask&gt;b__0(System.Threading.Tasks.Task)
   at System.Threading.Tasks.ContinuationResultTaskFromTask`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].InnerInvoke()
   at System.Threading.Tasks.Task.Execute()
   at System.Threading.Tasks.Task.ExecutionContextCallback(System.Object)
   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)
   at System.Threading.Tasks.Task.ExecuteEntry(Boolean)
   at System.Threading.Tasks.Task.System.Threading.IThreadPoolWorkItem.ExecuteWorkItem()
   at System.Threading.ThreadPoolWorkQueue.Dispatch()
   at System.Threading._ThreadPoolWaitCallback.PerformWaitCallback()
```

/cc @VSadov </Description>
        <CreatedDate>28/11/2017</CreatedDate>
        <ClosedDate>05/12/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23338</IssueID>
        <Title>Unnecessary defensive copy of an `in` parameter is created, whose type is nullable readonly struct</Title>
        <Description>**Version Used**: 

Version 15.5.0 Preview 4.0
VisualStudio.15.Preview/15.5.0-pre.4.0+27110.0

Visual C# 2017 00369-60000-00001-AA127
Microsoft Visual C# 2017

C# 7.2

**Steps to Reproduce**:

Compile and inspect IL:
```
using System;

readonly struct S
{
    readonly decimal d;

    public S(decimal d)
    {
        this.d = d;
    }
}

class P
{
    static void Foo(in S? x)
    {
        Console.WriteLine(x.GetValueOrDefault());
    }
    
    static void Main()
    {
        S? y = new S(5m);
        Foo(y);
    }
}
```
**Actual Behavior**:
The `in` parameter `x` in the method  `Foo` is copied to a compiler-generated local before `GetValueOrDefault()` is invoked.

**Expected Behavior**:
This copy is unnecessary and should be elided. No method or property of a nullable value type can mutate it if the underlying type is a readonly struct.</Description>
        <CreatedDate>21/11/2017</CreatedDate>
        <ClosedDate>05/12/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23166</IssueID>
        <Title>Unused parameter in Microsoft.CodeAnalysis.CSharp.Binder.CheckFieldRefEscape (potential bug?)</Title>
        <Description>Enabling CA1801 (unused parameter rule) fires it for [CheckFieldRefEscape](http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Binder/Binder.ValueChecks.cs,a204c04b97fd2e6c) and [CheckFieldLikeEventRefEscape](http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Binder/Binder.ValueChecks.cs,09e0b3ce0e53064a) for parameter `checkingReceiver` being unused. We should either use this parameter or remove it from the signature.</Description>
        <CreatedDate>14/11/2017</CreatedDate>
        <ClosedDate>05/12/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder.ValueChecks.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Expressions.cs</File>
      <File>src/Compilers/CSharp/Portable/CodeGen/EmitExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenInParametersTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenShortCircuitOperatorTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/NullableTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/SemanticErrorTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23430</IssueID>
    <Title>Go To Disassembly</Title>
    <Description>I was asked by @sharwell to submit this as PR, I took most of the code from https://github.com/dotnet/roslyn/compare/master...rchande:go-to-disassembly and replaced the 2.x version of ICSharpCode.Decompiler with 3.0.0.3367-beta3.

Notes:

a) not sure if the template is needed, please help! ;-)
b) I had to manually add `ICSharpCode.Decompiler.dll` and `Mono.Cecil.dll` to `devenv.exe.config`, despite having added the following attributes to `\src\VisualStudio\Setup\AssemblyRedirects.cs`

```
[assembly: ProvideCodeBase(CodeBase = @"$PackageFolder$\Mono.Cecil.dll")]
[assembly: ProvideCodeBase(CodeBase = @"$PackageFolder$\ICSharpCode.Decompiler.dll")]
```

Could you help me with that?

c) the `Go To Disassembly` command is not implemented yet.

### Customer scenario

A customer uses **Go To Definition** on a symbol defined in metadata, and is taken to a file with stubs instead of the actual implementation.

### Bugs this fixes

Related to #16540
Related to icsharpcode/ILSpy#791

### Workarounds, if any

None.

### Risk

Low. The feature is behind a feature flag and a legal notice. The original code path is used by default during the experimental phase of this feature. The original code path is used if the new feature fails for any reason aside from a stack overflow.

### Performance impact

Non-deterministic, but only pay for play.

### Is this a regression from a previous update?

No.

### Root cause analysis

N/A (new feature)

### How was the bug found?

Customer request

### Test documentation updated?

No (left as a required item for moving this feature from experimental to stable).
</Description>
    <CreatedDate>28/11/2017</CreatedDate>
    <ClosedDate>08/12/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>16540</IssueID>
        <Title>Public API for IMetadataAsSourceService</Title>
        <Description>I have just found [`IMetadataAsSourceService`](http://source.roslyn.io/#Microsoft.CodeAnalysis.Features/MetadataAsSource/IMetadataAsSourceService.cs,efa3025f7d523cd9) interface that enables me to replace default metadata view with decompiled code from ILSpy in about 50LOC - see https://github.com/icsharpcode/ILSpy/pull/791 It is sooo cool :), but the interface is internal so I had to hack it a bit. Would it be possible to make it an official extensibility point?
</Description>
        <CreatedDate>16/01/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>791</IssueID>
        <Title>VS crashes with ArgumentOutOfRangeException: "startIndex cannot be larger than length" for unclosed /* comment in C# source</Title>
        <Description>Ported from TFS WorkItem: **1108049**

---

**Repro Steps:**

Paste this C# code into ETA (or VS):
`/*`

System.ArgumentOutOfRangeException: startIndex cannot be larger than length of string.

&amp;nbsp; at string.Substring(int startIndex)

&amp;nbsp; at M.CA.Editor.CSharp.Outlining.CSharpOutliningHelpers.CreateCommentBannerTextWithPrefix(string text = "", string prefix = "/*")

&amp;nbsp;

The call stack is attached.

See the dump at [\mlangfs1\public\vladres\78c676647ef347a7917a0b954666544a](file://\mlangfs1publicvladres78c676647ef347a7917a0b954666544a)

---

**Revisions:**

1) Created By Vladimir Reshetnikov (1/14/2015 2:23:48 PM)

---

2) Edited By Kevin Pilch-Bisson (1/15/2015 10:26:03 AM)

Leaving in RTM, because it has to be a a file with less than 2 characters after the /*.

---
</Description>
        <CreatedDate>23/02/2015</CreatedDate>
        <ClosedDate>24/02/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/Core/IMetadataAsSourceFileService.cs</File>
      <File>src/EditorFeatures/Core/Implementation/MetadataAsSource/MetadataAsSourceFileService.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Peek/DefinitionPeekableItem.cs</File>
      <File>src/EditorFeatures/Core/Shared/Options/FeatureOnOffOptions.cs</File>
      <File>src/EditorFeatures/Test/MetadataAsSource/AbstractMetadataAsSourceTests.TestContext.cs</File>
      <File>src/VisualStudio/CSharp/Impl/Options/AdvancedOptionPageControl.xaml.cs</File>
      <File>src/VisualStudio/CSharp/Impl/Options/AdvancedOptionPageStrings.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Workspace/VisualStudioSymbolNavigationService.cs</File>
      <File>src/VisualStudio/Core/Def/ServicesVSResources.Designer.cs</File>
      <File>src/VisualStudio/Setup/AssemblyRedirects.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23397</IssueID>
    <Title>Making sure that "in" matches exactly in method group conversions.</Title>
    <Description>It looks like method group conversions apply regular method overload resolution when resolving target method group.
However we know that in such scenario, unlike the regular argument passing, "byval" cannot match "in".

We should reject candidates with in/val mismatches when doing overload resolution for group conversion purposes. Otherwise we may encounter false ambiguity errors or even pick wrong candidates that crash at run time.

Fixes:#23319

### Customer scenario

Customer uses code that converts a method group with `in` parameters to a delegate that uses ordinary byval parameters in the same positions. 
It is expected that C# compiler rejects such assignment ans it is not permitted by CLR. (ref and val parameters are not compatible, during delegate creation).

Because of the bug, code compiles and crashes at run time.

### Bugs this fixes

Fixes:#23319

### Workarounds, if any

Not using the described scenario that results in broken code.

### Risk

Low. 
The change is mostly about propagating "isMethodConversion" further, so that conversion machinery could reject candidates with `in` --&gt; `byval` parameter match when performing resolution for the purpose of method group conversions. 

### Performance impact

Low.

### Is this a regression from a previous update?

No.

### Root cause analysis

Similar rules govern lambda conversions and were implemented and tested. The case with method group conversions goes on a different path (since it needs to do overload resolution form multiple candidates) and thus the scenario was missed.

### How was the bug found?

Reported by external customer.

### Test documentation updated?

N/A</Description>
    <CreatedDate>27/11/2017</CreatedDate>
    <ClosedDate>04/12/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>23319</IssueID>
        <Title>C# compiler allows unsafe conversions from method groups to delegates with mismatching `in` modifier</Title>
        <Description>**Version Used**: 
Version 15.5.0 Preview 4.0
VisualStudio.15.Preview/15.5.0-pre.4.0+27110.0

Visual C# 2017   00369-60000-00001-AA127
Microsoft Visual C# 2017

C# 7.2

**Steps to Reproduce**:

Compile and run:

```
using System;

class Program
{
    static void F(in DateTime x)
    {
        Console.WriteLine(x);
    }

    static void Main()
    {
        Action&lt;DateTime&gt; a = F;
        a(DateTime.MaxValue);
    }
}
```

**Expected Behavior**:
A compile-time error.

**Actual Behavior**:
The program compiles successfully, but fails at runtime:
&gt; Unhandled Exception: System.AccessViolationException: Attempted to read or write protected memory. This is often an indication that other memory is corrupt.
   at Program.F(DateTime&amp; x) in Program.cs:line 7</Description>
        <CreatedDate>21/11/2017</CreatedDate>
        <ClosedDate>04/12/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23319</IssueID>
        <Title>C# compiler allows unsafe conversions from method groups to delegates with mismatching `in` modifier</Title>
        <Description>**Version Used**: 
Version 15.5.0 Preview 4.0
VisualStudio.15.Preview/15.5.0-pre.4.0+27110.0

Visual C# 2017   00369-60000-00001-AA127
Microsoft Visual C# 2017

C# 7.2

**Steps to Reproduce**:

Compile and run:

```
using System;

class Program
{
    static void F(in DateTime x)
    {
        Console.WriteLine(x);
    }

    static void Main()
    {
        Action&lt;DateTime&gt; a = F;
        a(DateTime.MaxValue);
    }
}
```

**Expected Behavior**:
A compile-time error.

**Actual Behavior**:
The program compiles successfully, but fails at runtime:
&gt; Unhandled Exception: System.AccessViolationException: Attempted to read or write protected memory. This is often an indication that other memory is corrupt.
   at Program.F(DateTime&amp; x) in Program.cs:line 7</Description>
        <CreatedDate>21/11/2017</CreatedDate>
        <ClosedDate>04/12/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Conversions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/OverloadResolution/OverloadResolution.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/OverloadResolutionTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23315</IssueID>
    <Title>Handle parentheses in explicit VB delegate creation scenarios.</Title>
    <Description>This updates our implementation to handle cases such as `DirectCast(((Sub() Console.WriteLine())), Action)`. Previously, we would have an Identity conversion as the top node, alternating IParenthesizedOperation and IConversionOperations down the tree, until we got to an explicit IConversion on top of the lambda or addressof. These final nodes shared a syntax node and both were explicit. This removes the alternating IConversionOperations from the tree, so we only have 2 conversion, one at the top and one at the bottom. When we encounter this scenario, we remove the lower conversion from the tree, and use it's characteristics for the upper conversion (which becomes an IDelegateCreationExpression). Fixes #22988, fixes #22879.

Ask Mode Template:
### Customer scenario

When an analyzer runs on VB code that has parenthesis inside an explicit conversion (CType, DirectCast, TryCast), the IOperation tree contains bogus nodes and is incorrect. This scenario can also violate our invariant of no duplicate explicit syntax nodes in some of these scenarios.

### Bugs this fixes

https://github.com/dotnet/roslyn/issues/22988
https://github.com/dotnet/roslyn/issues/22879

### Workarounds, if any

None

### Risk

Minimal. We're slightly modifying the bound nodes that get generated in this scenario, but these were already ignored later in the compiler.

### Performance impact

Minimal. This will add a few functions calls to generating VB IOperation trees involving this specific scenario, but doesn't affect any other scenarios.

### Is this a regression from a previous update?

No, bug in original implementation.

### Root cause analysis

Added a number of new tests around nested delegates to cover this.

### How was the bug found?

Internal testing.</Description>
    <CreatedDate>20/11/2017</CreatedDate>
    <ClosedDate>13/12/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>22988</IssueID>
        <Title>Lambda conversion when argument is parenthesized fails in VB.</Title>
        <Description>```VB.NET
CType((Sub()
       End Sub), Action)
```
Fails with a duplicate explicit syntax node expression. This is because it's not considered a delegate creation conversion, as the operand is a BoundParenthesizedExpression.
</Description>
        <CreatedDate>02/11/2017</CreatedDate>
        <ClosedDate>13/12/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22879</IssueID>
        <Title>Assert about multiple explicit operation nodes with same syntax in VB</Title>
        <Description>I tried to add following VB test as part of https://github.com/dotnet/roslyn/pull/22846 without doing any source changes and I see the following assert fire: `Assert.False(true, $"Duplicate explicit node for syntax ({operation.Syntax.RawKind}): {operation.Syntax.ToString()}");` where both IDelegateCreation and IAnonymousObjectCreation have same syntax

```
        &lt;CompilerTrait(CompilerFeature.IOperation)&gt;
        &lt;Fact&gt;
        Public Sub TestParenthesizedDelegateCreationParent()
            Dim source = &lt;![CDATA[
Class P
    Private Shared Function M1() As Object
        Return CType((Sub() System.Console.WriteLine()), System.Action)'BIND:"CType((Sub() System.Console.WriteLine()), System.Action)"
    End Function
End Class]]&gt;.Value

            Dim expectedOperationTree = &lt;![CDATA[
]]&gt;.Value

            Dim expectedDiagnostics = String.Empty

            VerifyOperationTreeAndDiagnosticsForTest(Of CTypeExpressionSyntax)(source, expectedOperationTree, expectedDiagnostics)
        End Sub
```</Description>
        <CreatedDate>26/10/2017</CreatedDate>
        <ClosedDate>13/12/2017</ClosedDate>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>23484</IssueID>
    <Title>Skip IOperation test GroupBy_Lookup1 until it is investigated</Title>
    <Description>This PR skips a single test that has been failing frequently in code flow from master to other branches. See, for example, 

- https://github.com/dotnet/roslyn/pull/23419
- https://github.com/dotnet/roslyn/pull/23420
- https://github.com/dotnet/roslyn/pull/23454
- https://github.com/dotnet/roslyn/pull/23455

Issue #23483 has been filed to investigate the underlying failure.

### Risk

No product code change.

### Performance impact

No product code change.

### Root cause analysis

#23483 has been filed to analyze the root cause.

### How was the bug found?

Automated testing of integration branches.

### Test documentation updated?

N/A

@dotnet/roslyn-compiler @dotnet/roslyn-infrastructure May I please have a review of this?
</Description>
    <CreatedDate>30/11/2017</CreatedDate>
    <ClosedDate>30/11/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>23483</IssueID>
        <Title>Flaky test Microsoft.CodeAnalysis.VisualBasic.UnitTests.GetExtendedSemanticInfoTests.GroupBy_Lookup1</Title>
        <Description>The test `Microsoft.CodeAnalysis.VisualBasic.UnitTests.GetExtendedSemanticInfoTests.GroupBy_Lookup1` is failing frequently on merges from `master` to other branches. It isn't clear what the failure is (I tried testing the affected branch and did not see the failure).

The test is skipped to unblock the code flow. It needs to be investigated and unskipped.

Here is the output from the failing test:

``` none
Failed

Microsoft.CodeAnalysis.VisualBasic.UnitTests.GetExtendedSemanticInfoTests.GroupBy_Lookup1 (from Roslyn.Compilers.VisualBasic.Semantic.UnitTests)

MESSAGE:
  | Expected and actual were different.\r\nExpected:\r\nITranslatedQueryOperation (OperationKind.TranslatedQuery, Type: ?, IsInvalid) (Syntax: 'From s1 In ... in qi Group')\r\n Expression: \r\n IInvalidOperation (OperationKind.Invalid, Type: ?, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\n Children(4):\r\n IInvalidOperation (OperationKind.Invalid, Type: ?, IsImplicit) (Syntax: 's2 in qi')\r\n Children(3):\r\n ILocalReferenceOperation: qi (OperationKind.LocalReference, Type: QueryAble, IsInvalid) (Syntax: 'qi')\r\n IAnonymousFunctionOperation (Symbol: Function (s1 As System.Int32) As ?) (OperationKind.AnonymousFunction, Type: null, IsImplicit) (Syntax: 'qi')\r\n IBlockOperation (1 statements) (OperationKind.Block, Type: null, IsImplicit) (Syntax: 'qi')\r\n IReturnOperation (OperationKind.Return, Type: null, IsImplicit) (Syntax: 'qi')\r\n ReturnedValue: \r\n ILocalReferenceOperation: qi (OperationKind.LocalReference, Type: QueryAble) (Syntax: 'qi')\r\n IAnonymousFunctionOperation (Symbol: Function (s1 As System.Int32, s2 As System.Int32) As &amp;lt;anonymous type: Key s1 As System.Int32, Key s2 As System.Int32&gt;) (OperationKind.AnonymousFunction, Type: null, IsInvalid, IsImplicit) (Syntax: 'From s1 In qi, s2 in qi')\r\n IBlockOperation (1 statements) (OperationKind.Block, Type: null, IsInvalid, IsImplicit) (Syntax: 'From s1 In qi, s2 in qi')\r\n IReturnOperation (OperationKind.Return, Type: null, IsInvalid, IsImplicit) (Syntax: 'From s1 In qi, s2 in qi')\r\n ReturnedValue: \r\n IAnonymousObjectCreationOperation (OperationKind.AnonymousObjectCreation, Type: &amp;lt;anonymous type: Key s1 As System.Int32, Key s2 As System.Int32&gt;, IsImplicit) (Syntax: 's2 in qi')\r\n Initializers(2):\r\n IParameterReferenceOperation: s1 (OperationKind.ParameterReference, Type: System.Int32, IsImplicit) (Syntax: 's1')\r\n IParameterReferenceOperation: s2 (OperationKind.ParameterReference, Type: System.Int32, IsImplicit) (Syntax: 's2')\r\n IAnonymousFunctionOperation (Symbol: Function ($VB$It As &amp;lt;anonymous type: Key s1 As System.Int32, Key s2 As System.Int32&gt;) As ?) (OperationKind.AnonymousFunction, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n IBlockOperation (1 statements) (OperationKind.Block, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n IReturnOperation (OperationKind.Return, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n ReturnedValue: \r\n IInvalidOperation (OperationKind.Invalid, Type: null, IsInvalid) (Syntax: '')\r\n Children(0)\r\n IAnonymousFunctionOperation (Symbol: Function ($VB$It As &amp;lt;anonymous type: Key s1 As System.Int32, Key s2 As System.Int32&gt;) As ?) (OperationKind.AnonymousFunction, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n IBlockOperation (1 statements) (OperationKind.Block, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n IReturnOperation (OperationKind.Return, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n ReturnedValue: \r\n IInvalidOperation (OperationKind.Invalid, Type: null, IsInvalid) (Syntax: '')\r\n Children(0)\r\n IAnonymousFunctionOperation (Symbol: Function ($315 As ?, $VB$ItAnonymous As ?) As &amp;lt;anonymous type: Key $315 As ?, Key $315 As ?&gt;) (OperationKind.AnonymousFunction, Type: null, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\n IBlockOperation (1 statements) (OperationKind.Block, Type: null, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\n IReturnOperation (OperationKind.Return, Type: null, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\n ReturnedValue: \r\n IAnonymousObjectCreationOperation (OperationKind.AnonymousObjectCreation, Type: &amp;lt;anonymous type: Key $315 As ?, Key $315 As ?&gt;, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\n Initializers(2):\r\n IOperation: (OperationKind.None, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n IInvalidOperation (OperationKind.Invalid, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n Children(1):\r\n IParameterReferenceOperation: $VB$ItAnonymous (OperationKind.ParameterReference, Type: ?, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\nActual:\r\nITranslatedQueryOperation (OperationKind.TranslatedQuery, Type: ?, IsInvalid) (Syntax: 'From s1 In ... in qi Group')\r\n Expression: \r\n IInvalidOperation (OperationKind.Invalid, Type: ?, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\n Children(4):\r\n IInvalidOperation (OperationKind.Invalid, Type: ?, IsImplicit) (Syntax: 's2 in qi')\r\n Children(3):\r\n ILocalReferenceOperation: qi (OperationKind.LocalReference, Type: QueryAble, IsInvalid) (Syntax: 'qi')\r\n IAnonymousFunctionOperation (Symbol: Function (s1 As System.Int32) As ?) (OperationKind.AnonymousFunction, Type: null, IsImplicit) (Syntax: 'qi')\r\n IBlockOperation (1 statements) (OperationKind.Block, Type: null, IsImplicit) (Syntax: 'qi')\r\n IReturnOperation (OperationKind.Return, Type: null, IsImplicit) (Syntax: 'qi')\r\n ReturnedValue: \r\n ILocalReferenceOperation: qi (OperationKind.LocalReference, Type: QueryAble) (Syntax: 'qi')\r\n IAnonymousFunctionOperation (Symbol: Function (s1 As System.Int32, s2 As System.Int32) As &amp;lt;anonymous type: Key s1 As System.Int32, Key s2 As System.Int32&gt;) (OperationKind.AnonymousFunction, Type: null, IsInvalid, IsImplicit) (Syntax: 'From s1 In qi, s2 in qi')\r\n IBlockOperation (1 statements) (OperationKind.Block, Type: null, IsInvalid, IsImplicit) (Syntax: 'From s1 In qi, s2 in qi')\r\n IReturnOperation (OperationKind.Return, Type: null, IsInvalid, IsImplicit) (Syntax: 'From s1 In qi, s2 in qi')\r\n ReturnedValue: \r\n IAnonymousObjectCreationOperation (OperationKind.AnonymousObjectCreation, Type: &amp;lt;anonymous type: Key s1 As System.Int32, Key s2 As System.Int32&gt;, IsImplicit) (Syntax: 's2 in qi')\r\n Initializers(2):\r\n IParameterReferenceOperation: s1 (OperationKind.ParameterReference, Type: System.Int32, IsImplicit) (Syntax: 's1')\r\n IParameterReferenceOperation: s2 (OperationKind.ParameterReference, Type: System.Int32, IsImplicit) (Syntax: 's2')\r\n IAnonymousFunctionOperation (Symbol: Function ($VB$It As &amp;lt;anonymous type: Key s1 As System.Int32, Key s2 As System.Int32&gt;) As ?) (OperationKind.AnonymousFunction, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n IBlockOperation (1 statements) (OperationKind.Block, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n IReturnOperation (OperationKind.Return, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n ReturnedValue: \r\n IInvalidOperation (OperationKind.Invalid, Type: null, IsInvalid) (Syntax: '')\r\n Children(0)\r\n IAnonymousFunctionOperation (Symbol: Function ($VB$It As &amp;lt;anonymous type: Key s1 As System.Int32, Key s2 As System.Int32&gt;) As ?) (OperationKind.AnonymousFunction, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n IBlockOperation (1 statements) (OperationKind.Block, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n IReturnOperation (OperationKind.Return, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n ReturnedValue: \r\n IInvalidOperation (OperationKind.Invalid, Type: null, IsInvalid) (Syntax: '')\r\n Children(0)\r\n IAnonymousFunctionOperation (Symbol: Function ($315 As ?, $VB$ItAnonymous As ?) As &amp;lt;anonymous type: Key $315 As ?, Key $315 As ?&gt;) (OperationKind.AnonymousFunction, Type: null, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\n IBlockOperation (1 statements) (OperationKind.Block, Type: null, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\n IReturnOperation (OperationKind.Return, Type: null, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\n ReturnedValue: \r\n IAnonymousObjectCreationOperation (OperationKind.AnonymousObjectCreation, Type: &amp;lt;anonymous type: Key $315 As ?, Key $315 As ?&gt;, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\n Initializers(2):\r\n IParameterReferenceOperation: $315 (OperationKind.ParameterReference, Type: ?, IsInvalid, IsImplicit) (Syntax: '')\r\n IInvalidOperation (OperationKind.Invalid, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n Children(1):\r\n IParameterReferenceOperation: $VB$ItAnonymous (OperationKind.ParameterReference, Type: ?, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\n
  | +++++++++++++++++++
  | STACK TRACE:
  | at Roslyn.Test.Utilities.AssertEx.Fail(String message) at Roslyn.Test.Utilities.AssertEx.AreEqual[T](T expected, T actual, String message, IEqualityComparer`1 comparer) at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.Verify(String expectedOperationTree, String actualOperationTree) at Microsoft.CodeAnalysis.Test.Utilities.CompilationExtensions.VerifyOperationTree(Compilation compilation, SyntaxNode node, String expectedOperationTree) at Microsoft.CodeAnalysis.VisualBasic.UnitTests.GetExtendedSemanticInfoTests.GroupBy_Lookup1()
```
</Description>
        <CreatedDate>30/11/2017</CreatedDate>
        <ClosedDate>06/12/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23483</IssueID>
        <Title>Flaky test Microsoft.CodeAnalysis.VisualBasic.UnitTests.GetExtendedSemanticInfoTests.GroupBy_Lookup1</Title>
        <Description>The test `Microsoft.CodeAnalysis.VisualBasic.UnitTests.GetExtendedSemanticInfoTests.GroupBy_Lookup1` is failing frequently on merges from `master` to other branches. It isn't clear what the failure is (I tried testing the affected branch and did not see the failure).

The test is skipped to unblock the code flow. It needs to be investigated and unskipped.

Here is the output from the failing test:

``` none
Failed

Microsoft.CodeAnalysis.VisualBasic.UnitTests.GetExtendedSemanticInfoTests.GroupBy_Lookup1 (from Roslyn.Compilers.VisualBasic.Semantic.UnitTests)

MESSAGE:
  | Expected and actual were different.\r\nExpected:\r\nITranslatedQueryOperation (OperationKind.TranslatedQuery, Type: ?, IsInvalid) (Syntax: 'From s1 In ... in qi Group')\r\n Expression: \r\n IInvalidOperation (OperationKind.Invalid, Type: ?, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\n Children(4):\r\n IInvalidOperation (OperationKind.Invalid, Type: ?, IsImplicit) (Syntax: 's2 in qi')\r\n Children(3):\r\n ILocalReferenceOperation: qi (OperationKind.LocalReference, Type: QueryAble, IsInvalid) (Syntax: 'qi')\r\n IAnonymousFunctionOperation (Symbol: Function (s1 As System.Int32) As ?) (OperationKind.AnonymousFunction, Type: null, IsImplicit) (Syntax: 'qi')\r\n IBlockOperation (1 statements) (OperationKind.Block, Type: null, IsImplicit) (Syntax: 'qi')\r\n IReturnOperation (OperationKind.Return, Type: null, IsImplicit) (Syntax: 'qi')\r\n ReturnedValue: \r\n ILocalReferenceOperation: qi (OperationKind.LocalReference, Type: QueryAble) (Syntax: 'qi')\r\n IAnonymousFunctionOperation (Symbol: Function (s1 As System.Int32, s2 As System.Int32) As &amp;lt;anonymous type: Key s1 As System.Int32, Key s2 As System.Int32&gt;) (OperationKind.AnonymousFunction, Type: null, IsInvalid, IsImplicit) (Syntax: 'From s1 In qi, s2 in qi')\r\n IBlockOperation (1 statements) (OperationKind.Block, Type: null, IsInvalid, IsImplicit) (Syntax: 'From s1 In qi, s2 in qi')\r\n IReturnOperation (OperationKind.Return, Type: null, IsInvalid, IsImplicit) (Syntax: 'From s1 In qi, s2 in qi')\r\n ReturnedValue: \r\n IAnonymousObjectCreationOperation (OperationKind.AnonymousObjectCreation, Type: &amp;lt;anonymous type: Key s1 As System.Int32, Key s2 As System.Int32&gt;, IsImplicit) (Syntax: 's2 in qi')\r\n Initializers(2):\r\n IParameterReferenceOperation: s1 (OperationKind.ParameterReference, Type: System.Int32, IsImplicit) (Syntax: 's1')\r\n IParameterReferenceOperation: s2 (OperationKind.ParameterReference, Type: System.Int32, IsImplicit) (Syntax: 's2')\r\n IAnonymousFunctionOperation (Symbol: Function ($VB$It As &amp;lt;anonymous type: Key s1 As System.Int32, Key s2 As System.Int32&gt;) As ?) (OperationKind.AnonymousFunction, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n IBlockOperation (1 statements) (OperationKind.Block, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n IReturnOperation (OperationKind.Return, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n ReturnedValue: \r\n IInvalidOperation (OperationKind.Invalid, Type: null, IsInvalid) (Syntax: '')\r\n Children(0)\r\n IAnonymousFunctionOperation (Symbol: Function ($VB$It As &amp;lt;anonymous type: Key s1 As System.Int32, Key s2 As System.Int32&gt;) As ?) (OperationKind.AnonymousFunction, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n IBlockOperation (1 statements) (OperationKind.Block, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n IReturnOperation (OperationKind.Return, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n ReturnedValue: \r\n IInvalidOperation (OperationKind.Invalid, Type: null, IsInvalid) (Syntax: '')\r\n Children(0)\r\n IAnonymousFunctionOperation (Symbol: Function ($315 As ?, $VB$ItAnonymous As ?) As &amp;lt;anonymous type: Key $315 As ?, Key $315 As ?&gt;) (OperationKind.AnonymousFunction, Type: null, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\n IBlockOperation (1 statements) (OperationKind.Block, Type: null, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\n IReturnOperation (OperationKind.Return, Type: null, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\n ReturnedValue: \r\n IAnonymousObjectCreationOperation (OperationKind.AnonymousObjectCreation, Type: &amp;lt;anonymous type: Key $315 As ?, Key $315 As ?&gt;, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\n Initializers(2):\r\n IOperation: (OperationKind.None, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n IInvalidOperation (OperationKind.Invalid, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n Children(1):\r\n IParameterReferenceOperation: $VB$ItAnonymous (OperationKind.ParameterReference, Type: ?, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\nActual:\r\nITranslatedQueryOperation (OperationKind.TranslatedQuery, Type: ?, IsInvalid) (Syntax: 'From s1 In ... in qi Group')\r\n Expression: \r\n IInvalidOperation (OperationKind.Invalid, Type: ?, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\n Children(4):\r\n IInvalidOperation (OperationKind.Invalid, Type: ?, IsImplicit) (Syntax: 's2 in qi')\r\n Children(3):\r\n ILocalReferenceOperation: qi (OperationKind.LocalReference, Type: QueryAble, IsInvalid) (Syntax: 'qi')\r\n IAnonymousFunctionOperation (Symbol: Function (s1 As System.Int32) As ?) (OperationKind.AnonymousFunction, Type: null, IsImplicit) (Syntax: 'qi')\r\n IBlockOperation (1 statements) (OperationKind.Block, Type: null, IsImplicit) (Syntax: 'qi')\r\n IReturnOperation (OperationKind.Return, Type: null, IsImplicit) (Syntax: 'qi')\r\n ReturnedValue: \r\n ILocalReferenceOperation: qi (OperationKind.LocalReference, Type: QueryAble) (Syntax: 'qi')\r\n IAnonymousFunctionOperation (Symbol: Function (s1 As System.Int32, s2 As System.Int32) As &amp;lt;anonymous type: Key s1 As System.Int32, Key s2 As System.Int32&gt;) (OperationKind.AnonymousFunction, Type: null, IsInvalid, IsImplicit) (Syntax: 'From s1 In qi, s2 in qi')\r\n IBlockOperation (1 statements) (OperationKind.Block, Type: null, IsInvalid, IsImplicit) (Syntax: 'From s1 In qi, s2 in qi')\r\n IReturnOperation (OperationKind.Return, Type: null, IsInvalid, IsImplicit) (Syntax: 'From s1 In qi, s2 in qi')\r\n ReturnedValue: \r\n IAnonymousObjectCreationOperation (OperationKind.AnonymousObjectCreation, Type: &amp;lt;anonymous type: Key s1 As System.Int32, Key s2 As System.Int32&gt;, IsImplicit) (Syntax: 's2 in qi')\r\n Initializers(2):\r\n IParameterReferenceOperation: s1 (OperationKind.ParameterReference, Type: System.Int32, IsImplicit) (Syntax: 's1')\r\n IParameterReferenceOperation: s2 (OperationKind.ParameterReference, Type: System.Int32, IsImplicit) (Syntax: 's2')\r\n IAnonymousFunctionOperation (Symbol: Function ($VB$It As &amp;lt;anonymous type: Key s1 As System.Int32, Key s2 As System.Int32&gt;) As ?) (OperationKind.AnonymousFunction, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n IBlockOperation (1 statements) (OperationKind.Block, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n IReturnOperation (OperationKind.Return, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n ReturnedValue: \r\n IInvalidOperation (OperationKind.Invalid, Type: null, IsInvalid) (Syntax: '')\r\n Children(0)\r\n IAnonymousFunctionOperation (Symbol: Function ($VB$It As &amp;lt;anonymous type: Key s1 As System.Int32, Key s2 As System.Int32&gt;) As ?) (OperationKind.AnonymousFunction, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n IBlockOperation (1 statements) (OperationKind.Block, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n IReturnOperation (OperationKind.Return, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n ReturnedValue: \r\n IInvalidOperation (OperationKind.Invalid, Type: null, IsInvalid) (Syntax: '')\r\n Children(0)\r\n IAnonymousFunctionOperation (Symbol: Function ($315 As ?, $VB$ItAnonymous As ?) As &amp;lt;anonymous type: Key $315 As ?, Key $315 As ?&gt;) (OperationKind.AnonymousFunction, Type: null, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\n IBlockOperation (1 statements) (OperationKind.Block, Type: null, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\n IReturnOperation (OperationKind.Return, Type: null, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\n ReturnedValue: \r\n IAnonymousObjectCreationOperation (OperationKind.AnonymousObjectCreation, Type: &amp;lt;anonymous type: Key $315 As ?, Key $315 As ?&gt;, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\n Initializers(2):\r\n IParameterReferenceOperation: $315 (OperationKind.ParameterReference, Type: ?, IsInvalid, IsImplicit) (Syntax: '')\r\n IInvalidOperation (OperationKind.Invalid, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n Children(1):\r\n IParameterReferenceOperation: $VB$ItAnonymous (OperationKind.ParameterReference, Type: ?, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\n
  | +++++++++++++++++++
  | STACK TRACE:
  | at Roslyn.Test.Utilities.AssertEx.Fail(String message) at Roslyn.Test.Utilities.AssertEx.AreEqual[T](T expected, T actual, String message, IEqualityComparer`1 comparer) at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.Verify(String expectedOperationTree, String actualOperationTree) at Microsoft.CodeAnalysis.Test.Utilities.CompilationExtensions.VerifyOperationTree(Compilation compilation, SyntaxNode node, String expectedOperationTree) at Microsoft.CodeAnalysis.VisualBasic.UnitTests.GetExtendedSemanticInfoTests.GroupBy_Lookup1()
```
</Description>
        <CreatedDate>30/11/2017</CreatedDate>
        <ClosedDate>06/12/2017</ClosedDate>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>23414</IssueID>
    <Title>Make anonymous type's GetHashCode not depend on compilation environment</Title>
    <Description>We stop calling string.GetHashCode() at compile time and placing the value in the
generated code because that is not deterministic. Instead we use FNV1a hash code.

For VB, which does not have this bug, we update the implementation to use a more
reliable case-mapping method (see #2116)

### Customer scenario

Compile source code in two different compilation environments, expecting the result to be the same. But the generated GetHashCode varies from one to another because it depends on string.GetHashCode in the compilation environment. When compiling in an environment with [randomized string hashing](https://docs.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element), the compiler will produce a different assembly nearly every time.

### Bugs this fixes

Fixes #23020

### Workarounds, if any

Don't compile in different environments and expect deterministic compiler output.

### Risk

Very low. Replaces one hash code computation with another.

### Performance impact

Very low for the same reason.

### Is this a regression from a previous update?

No.

### Root cause analysis

We've been improving our determinism since we started working on it a couple of years ago. This particular issue was detected and diagnosed by a customer.

### How was the bug found?

Customer reported.

### Test documentation updated?

N/A

@dotnet/roslyn-compiler Please review.</Description>
    <CreatedDate>28/11/2017</CreatedDate>
    <ClosedDate>30/11/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>2116</IssueID>
        <Title>Change VB's case-mapping rules to use a more recent Unicode version</Title>
        <Description>VB's current case-mapping rules for identifier equivalence uses a pretty old version of the Unicode spec, and has bugs. Specifically we use the "invariant" locale, which because it is invariant will never change to be updated as the Unicode spec evolves.

We should instead use a "neutral" culture for the case-mapping, such as the "en" locale, which follows the Unicode case-mapping rules and has no locale-specific exceptions.

&lt;!---
@huboard:{"order":1968.0,"milestone_order":2116,"custom_state":""}
--&gt;
</Description>
        <CreatedDate>20/04/2015</CreatedDate>
        <ClosedDate>27/04/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23020</IssueID>
        <Title>Generation of the GetHashCode method of anonymous types is not deterministic</Title>
        <Description>**Version Used**: 
Commit 72b8f88b0d

**Steps to Reproduce**:

1. Create the following .cs file:
```
class Program
{
    static void Main()
    {
        var a = new { a = 4 };
    }
}
```
2. Compile it with core MSBuild
3. Copy the output .dll elsewhere and compile it again
4. Alternatively, use csc and set the `deterministic` flag:
`dotnet csc.dll Program.cs /target:library /deterministic /noconfig /reference:"C:\Program Files\dotnet\sdk\NuGetFallbackFolder\microsoft.netcore.app\2.0.0\ref\netcoreapp2.0\System.Collections.dll" /reference:"C:\Program Files\dotnet\sdk\NuGetFallbackFolder\microsoft.netcore.app\2.0.0\ref\netcoreapp2.0\System.Runtime.dll"`

**Expected Behavior**:
The compiler should produce the exact same output both times.

**Actual Behavior**:
The compiler's output differs every time.
If the net46 csc build is used, the compiler produces the same output each time it is run.

**Reason**:
The difference comes from the GetHashCode method of the created anonymous type. Here's the IL from two separate compiles.
```
  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    // Code size       29 (0x1d)
    .maxstack  8
    IL_0000:  ldc.i4     0x1af3bd32
    IL_0005:  ldc.i4     0xa5555529
    IL_000a:  mul
```
```
.method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    // Code size       29 (0x1d)
    .maxstack  8
    IL_0000:  ldc.i4     0xc61810dc
    IL_0005:  ldc.i4     0xa5555529
    IL_000a:  mul
```

One of the constants used in the hash method changes every time. This is because Roslyn uses the hash codes of the backing fields of anonymous types to generate the above constant. ([Code here](https://github.com/dotnet/roslyn/blob/72b8f88b0daf42e1a8b1d6687cbfc9ccbb0cc21a/src/Compilers/CSharp/Portable/Compiler/AnonymousTypeMethodBodySynthesizer.cs#L190))

This isn't a problem in .NET Framework because [randomized string hashing](https://docs.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element) is disabled by default. However, it's enabled by default in coreclr, so identical strings will give different hash codes each time the process is run, creating non-deterministic IL code.</Description>
        <CreatedDate>06/11/2017</CreatedDate>
        <ClosedDate>30/11/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Compiler/AnonymousTypeMethodBodySynthesizer.cs</File>
      <File>src/Compilers/CSharp/Test/WinRT/AnonymousTypesSymbolTests.cs</File>
      <File>src/Compilers/Core/Portable/InternalUtilities/Hash.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23412</IssueID>
    <Title>Fix for #22690 NRE in GetAttributeSyntaxNodeOfToken</Title>
    <Description>:memo: This is a back-port of #22961 to **dev15.5.x**. The template below is copied from that issue.

**Customer scenario**

An NRE in AbstractInternalsVisibleToCompletionProvider causes a crash of VS. The NRE was not reproducible and seemed only to occur in the C# intermediate window. No tests are provided (see #22690 why).

**Bugs this fixes:**

Fixes #22690 
[DevDiv 525354](https://devdiv.visualstudio.com/DevDiv/_workitems/edit/525354)

**Workarounds, if any**

None.

**Risk**

Bug was not reproducible and therefore no tests are given. The fix is a best guess effort and is based on looking at possible NRE places in the stacktrace given by #22690:

* `IsStringLiteralExpression` is only called at on place in `AbstractInternalsVisibleToCompletionProvider.GetAttributeSyntaxNodeOfToken`
* `CSharpSyntaxFactsService.IsStringLiteralExpression`  is defined as `=&gt; node.Kind() == SyntaxKind.StringLiteralExpression;`
* `node.Kind()` causes the NRE most likely here: `var rawKind = node.RawKind;` if node is null.

If this analysis is not correct there might still be a bug that causes VS to crash.

**Performance impact**

None.

**Is this a regression from a previous update?**

No. New feature. Bug found in VS 15.5 Preview 1

**Root cause analysis:**

`var node = token.Parent;` returns `null` in some rare circumstances. This was discovered in VS 15.5 Preview 1.

**How was the bug found?**

Reported by @tmat in #22690.

**Test documentation updated?**

No.</Description>
    <CreatedDate>28/11/2017</CreatedDate>
    <ClosedDate>29/11/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>22961</IssueID>
        <Title>Fix for #22690 NRE in GetAttributeSyntaxNodeOfToken in AbstractInternalsVisibleToCompletionProvider</Title>
        <Description>**Customer scenario**

An NRE in AbstractInternalsVisibleToCompletionProvider causes a crash of VS. The NRE was not reproducible and seemed only to occur in the C# intermediate window. No tests are provided (see #22690 why).

**Bugs this fixes:**

Fixes #22690 

**Workarounds, if any**

None.

**Risk**

Bug was not reproducible and therefore no tests are given. The fix is a best guess effort and is based on looking at possible NRE places in the stacktrace given by #22690:

* `IsStringLiteralExpression` is only called at on place in `AbstractInternalsVisibleToCompletionProvider.GetAttributeSyntaxNodeOfToken`
* `CSharpSyntaxFactsService.IsStringLiteralExpression`  is defined as `=&gt; node.Kind() == SyntaxKind.StringLiteralExpression;`
* `node.Kind()` causes the NRE most likely here: `var rawKind = node.RawKind;` if node is null.

If this analysis is not correct there might still be a bug that causes VS to crash.

**Performance impact**

None.

**Is this a regression from a previous update?**

No. New feature. Bug found in VS 15.5 Preview 1

**Root cause analysis:**

`var node = token.Parent;` returns `null` in some rare circumstances. This was discovered in VS 15.5 Preview 1.

**How was the bug found?**

Reported by @tmat in #22690.

**Test documentation updated?**

No.</Description>
        <CreatedDate>01/11/2017</CreatedDate>
        <ClosedDate>22/11/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22690</IssueID>
        <Title>VS crash: AbstractInternalsVisibleToCompletionProvider.GetAttributeSyntaxNodeOfToken throws NRE</Title>
        <Description>```
   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(SyntaxNode node) in E:\A\_work\24\s\src\Compilers\CSharp\Portable\CSharpExtensions.cs:line 161
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxFactsService.IsStringLiteralExpression(SyntaxNode node) in E:\A\_work\24\s\src\Workspaces\CSharp\Portable\LanguageServices\CSharpSyntaxFactsService.cs:line 1314
   at Microsoft.CodeAnalysis.Completion.Providers.AbstractInternalsVisibleToCompletionProvider.GetAttributeSyntaxNodeOfToken(ISyntaxFactsService syntaxFactsService, SyntaxToken token) in E:\A\_work\24\s\src\Features\Core\Portable\Completion\Providers\AbstractInternalsVisibleToCompletionProvider.cs:line 78
   at Microsoft.CodeAnalysis.Completion.Providers.AbstractInternalsVisibleToCompletionProvider.&lt;ProvideCompletionsAsync&gt;d__4.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\Providers\AbstractInternalsVisibleToCompletionProvider.cs:line 55
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders.&lt;GetContextAsync&gt;d__31.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionServiceWithProviders.cs:line 449
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders.&lt;ComputeNonEmptyCompletionContextsAsync&gt;d__24.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionServiceWithProviders.cs:line 311
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders.&lt;GetCompletionsAsync&gt;d__22.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionServiceWithProviders.cs:line 241
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionService.&lt;GetCompletionsAndSetItemDocumentAsync&gt;d__11.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionService.cs:line 183
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Editor.Implementation.IntelliSense.Completion.Controller.Session.ModelComputer.&lt;DoInBackgroundAsync&gt;d__13.MoveNext() in E:\A\_work\24\s\src\EditorFeatures\Core\Implementation\IntelliSense\Completion\Controller.Session_ComputeModel.cs:line 103
```

Crash dump: %internal_share%\public\tomat\Bugs\22690

VS build: 15.5.0 P1 (26927.1)
</Description>
        <CreatedDate>13/10/2017</CreatedDate>
        <ClosedDate>22/11/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22690</IssueID>
        <Title>VS crash: AbstractInternalsVisibleToCompletionProvider.GetAttributeSyntaxNodeOfToken throws NRE</Title>
        <Description>```
   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(SyntaxNode node) in E:\A\_work\24\s\src\Compilers\CSharp\Portable\CSharpExtensions.cs:line 161
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxFactsService.IsStringLiteralExpression(SyntaxNode node) in E:\A\_work\24\s\src\Workspaces\CSharp\Portable\LanguageServices\CSharpSyntaxFactsService.cs:line 1314
   at Microsoft.CodeAnalysis.Completion.Providers.AbstractInternalsVisibleToCompletionProvider.GetAttributeSyntaxNodeOfToken(ISyntaxFactsService syntaxFactsService, SyntaxToken token) in E:\A\_work\24\s\src\Features\Core\Portable\Completion\Providers\AbstractInternalsVisibleToCompletionProvider.cs:line 78
   at Microsoft.CodeAnalysis.Completion.Providers.AbstractInternalsVisibleToCompletionProvider.&lt;ProvideCompletionsAsync&gt;d__4.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\Providers\AbstractInternalsVisibleToCompletionProvider.cs:line 55
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders.&lt;GetContextAsync&gt;d__31.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionServiceWithProviders.cs:line 449
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders.&lt;ComputeNonEmptyCompletionContextsAsync&gt;d__24.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionServiceWithProviders.cs:line 311
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders.&lt;GetCompletionsAsync&gt;d__22.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionServiceWithProviders.cs:line 241
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionService.&lt;GetCompletionsAndSetItemDocumentAsync&gt;d__11.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionService.cs:line 183
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Editor.Implementation.IntelliSense.Completion.Controller.Session.ModelComputer.&lt;DoInBackgroundAsync&gt;d__13.MoveNext() in E:\A\_work\24\s\src\EditorFeatures\Core\Implementation\IntelliSense\Completion\Controller.Session_ComputeModel.cs:line 103
```

Crash dump: %internal_share%\public\tomat\Bugs\22690

VS build: 15.5.0 P1 (26927.1)
</Description>
        <CreatedDate>13/10/2017</CreatedDate>
        <ClosedDate>22/11/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22690</IssueID>
        <Title>VS crash: AbstractInternalsVisibleToCompletionProvider.GetAttributeSyntaxNodeOfToken throws NRE</Title>
        <Description>```
   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(SyntaxNode node) in E:\A\_work\24\s\src\Compilers\CSharp\Portable\CSharpExtensions.cs:line 161
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxFactsService.IsStringLiteralExpression(SyntaxNode node) in E:\A\_work\24\s\src\Workspaces\CSharp\Portable\LanguageServices\CSharpSyntaxFactsService.cs:line 1314
   at Microsoft.CodeAnalysis.Completion.Providers.AbstractInternalsVisibleToCompletionProvider.GetAttributeSyntaxNodeOfToken(ISyntaxFactsService syntaxFactsService, SyntaxToken token) in E:\A\_work\24\s\src\Features\Core\Portable\Completion\Providers\AbstractInternalsVisibleToCompletionProvider.cs:line 78
   at Microsoft.CodeAnalysis.Completion.Providers.AbstractInternalsVisibleToCompletionProvider.&lt;ProvideCompletionsAsync&gt;d__4.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\Providers\AbstractInternalsVisibleToCompletionProvider.cs:line 55
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders.&lt;GetContextAsync&gt;d__31.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionServiceWithProviders.cs:line 449
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders.&lt;ComputeNonEmptyCompletionContextsAsync&gt;d__24.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionServiceWithProviders.cs:line 311
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders.&lt;GetCompletionsAsync&gt;d__22.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionServiceWithProviders.cs:line 241
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionService.&lt;GetCompletionsAndSetItemDocumentAsync&gt;d__11.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionService.cs:line 183
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Editor.Implementation.IntelliSense.Completion.Controller.Session.ModelComputer.&lt;DoInBackgroundAsync&gt;d__13.MoveNext() in E:\A\_work\24\s\src\EditorFeatures\Core\Implementation\IntelliSense\Completion\Controller.Session_ComputeModel.cs:line 103
```

Crash dump: %internal_share%\public\tomat\Bugs\22690

VS build: 15.5.0 P1 (26927.1)
</Description>
        <CreatedDate>13/10/2017</CreatedDate>
        <ClosedDate>22/11/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22690</IssueID>
        <Title>VS crash: AbstractInternalsVisibleToCompletionProvider.GetAttributeSyntaxNodeOfToken throws NRE</Title>
        <Description>```
   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(SyntaxNode node) in E:\A\_work\24\s\src\Compilers\CSharp\Portable\CSharpExtensions.cs:line 161
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxFactsService.IsStringLiteralExpression(SyntaxNode node) in E:\A\_work\24\s\src\Workspaces\CSharp\Portable\LanguageServices\CSharpSyntaxFactsService.cs:line 1314
   at Microsoft.CodeAnalysis.Completion.Providers.AbstractInternalsVisibleToCompletionProvider.GetAttributeSyntaxNodeOfToken(ISyntaxFactsService syntaxFactsService, SyntaxToken token) in E:\A\_work\24\s\src\Features\Core\Portable\Completion\Providers\AbstractInternalsVisibleToCompletionProvider.cs:line 78
   at Microsoft.CodeAnalysis.Completion.Providers.AbstractInternalsVisibleToCompletionProvider.&lt;ProvideCompletionsAsync&gt;d__4.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\Providers\AbstractInternalsVisibleToCompletionProvider.cs:line 55
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders.&lt;GetContextAsync&gt;d__31.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionServiceWithProviders.cs:line 449
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders.&lt;ComputeNonEmptyCompletionContextsAsync&gt;d__24.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionServiceWithProviders.cs:line 311
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders.&lt;GetCompletionsAsync&gt;d__22.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionServiceWithProviders.cs:line 241
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionService.&lt;GetCompletionsAndSetItemDocumentAsync&gt;d__11.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionService.cs:line 183
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Editor.Implementation.IntelliSense.Completion.Controller.Session.ModelComputer.&lt;DoInBackgroundAsync&gt;d__13.MoveNext() in E:\A\_work\24\s\src\EditorFeatures\Core\Implementation\IntelliSense\Completion\Controller.Session_ComputeModel.cs:line 103
```

Crash dump: %internal_share%\public\tomat\Bugs\22690

VS build: 15.5.0 P1 (26927.1)
</Description>
        <CreatedDate>13/10/2017</CreatedDate>
        <ClosedDate>22/11/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Features/Core/Portable/Completion/Providers/AbstractInternalsVisibleToCompletionProvider.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23390</IssueID>
    <Title>Fixed 'Qualify member access' analyzer for object initializer</Title>
    <Description>Fixes #22776
Fixes #23016

Regression from 15.4

VSO bug : [link](https://devdiv.visualstudio.com/DevDiv/NET%20Developer%20Experience%20Productivity/_workitems/edit/529870)</Description>
    <CreatedDate>27/11/2017</CreatedDate>
    <ClosedDate>28/11/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>22776</IssueID>
        <Title>Incorrect "Add 'this.'" diagnostic for class initializers</Title>
        <Description>This is reported in a few Developer Community feedback items, I will link them as they're processed.
-  https://developercommunity.visualstudio.com/content/problem/131432/add-this-or-me-qualification-for-class-initializer.html
- https://developercommunity.visualstudio.com/content/problem/129705/incorrect-ide0009-in-object-initializer.html
- https://developercommunity.visualstudio.com/content/problem/161932/ide0009-add-this-or-me-qualification-incorrectly-r.html

I have not been able to reproduce this locally using the settings in the Tools | Options. Maybe it requires the editorconfig? That doesn't make much sense but I haven't been able to come up with anything else.</Description>
        <CreatedDate>19/10/2017</CreatedDate>
        <ClosedDate>21/12/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23016</IssueID>
        <Title>Add this or me qualification rule triggered incorrectly in return statement</Title>
        <Description>Have the following code:

            return new UserSession
            {
                UserId = subject
            };

Where UserSession is a simple class with property UserId. I'm getting green squiggles under the UserId in that statement, suggesting I add this or me qualification.

_This issue has been moved from https://developercommunity.visualstudio.com/content/problem/126539/add-this-or-me-qualification-rule-triggered-incorr.html
VSTS ticketId: 505612_
_These are the original issue comments:_

David Poeschl [MSFT] on ‎10‎/‎18‎/‎2017, 00:37 PM (17 days ago): &lt;p&gt;Thank you for your feedback! I've so far been unable to reproduce this problem. I tried with the following code:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;class C&lt;/p&gt;&lt;p&gt;\{&lt;/p&gt;&lt;p&gt;  static UserSession M()&lt;/p&gt;&lt;p&gt;  \{&lt;/p&gt;&lt;p&gt;    object subject = null;&lt;/p&gt;&lt;p&gt;    return new UserSession&lt;/p&gt;&lt;p&gt;    \{&lt;/p&gt;&lt;p&gt;      UserId = subject&lt;/p&gt;&lt;p&gt;    };&lt;/p&gt;&lt;p&gt;  }&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;internal class UserSession&lt;/p&gt;&lt;p&gt;\{&lt;/p&gt;&lt;p&gt;  public object UserId \{ get; set; }&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;And under &amp;quot;Text Editor | C# | Code Style | General | 'this.' preferences&amp;quot; I've set everything to &amp;quot;Prefer 'this.'&amp;quot; with &amp;quot;Warning&amp;quot; severity. Am I missing a step that you can tell? Thanks!&lt;/p&gt;

_These are the original issue solutions:_
(no solutions)</Description>
        <CreatedDate>05/11/2017</CreatedDate>
        <ClosedDate>09/01/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/QualifyMemberAccess/QualifyMemberAccessTests.cs</File>
      <File>src/Features/CSharp/Portable/QualifyMemberAccess/CSharpQualifyMemberAccessDiagnosticAnalyzer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23343</IssueID>
    <Title>Address a number of IOperation issues for VB</Title>
    <Description>Related to #22548 and #22229.
</Description>
    <CreatedDate>21/11/2017</CreatedDate>
    <ClosedDate>27/11/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>22548</IssueID>
        <Title>Follow up on isImplicit mismatch </Title>
        <Description>Address feedback from https://github.com/dotnet/roslyn/pull/22309 </Description>
        <CreatedDate>05/10/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22229</IssueID>
        <Title>IsImplicit for multiple operation nodes with same syntax</Title>
        <Description>we want to make sure there is only one explicit IOperation when multiple IOperations are pointing to same syntax node.

right now, we have case such as this (https://github.com/dotnet/roslyn/pull/21857#pullrequestreview-64081939 or https://github.com/dotnet/roslyn/pull/21857#issuecomment-330950924) where InvalidExpression is pointing to same syntax node as its child. or ExpressionStatement pointing to same syntax node as its expression (ex, expression lambda body)

we need to decide whether we want to mark those as implicit or not. if we do, those IOperation will not be returned by GetOperation. but user can still get to that operation through parent and children.
</Description>
        <CreatedDate>20/09/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>23284</IssueID>
    <Title>Fix System.InvalidOperationException in IOperation factory for an Option statement inside a method body</Title>
    <Description>Fixes #23283.

**Customer scenario**

Request IOperation tree for an Option statement like the one below:
```
    Sub Method()
        Option Strict On 'BIND:"Option Strict On"
    End Sub
```

An InvalidOperationException is thrown by IOperation factory.

**Bugs this fixes:**

Fixes #23283.

**Workarounds, if any**

No

**Risk**

Low

**Performance impact**

Low perf impact because no extra allocations/no complexity changes

**Is this a regression from a previous update?**

No

**Root cause analysis:**

A test gap. Unit-tests are added.

**How was the bug found?**

Running existing compiler tests with IOperation validation test hook enabled.
</Description>
    <CreatedDate>20/11/2017</CreatedDate>
    <ClosedDate>20/11/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>23283</IssueID>
        <Title>IOperation factory throws System.InvalidOperationException for an Option statement inside a method body</Title>
        <Description>```
        &lt;CompilerTrait(CompilerFeature.IOperation)&gt;
        &lt;Fact()&gt;
        Public Sub TestOptionStatement_01()
            Dim source = &lt;![CDATA[
Imports System

Class Test
    Sub Method()
        Option Strict On 'BIND:"Option Strict On"
    End Sub
End Class]]&gt;.Value

            Dim expectedOperationTree = &lt;![CDATA[
]]&gt;.Value

            Dim expectedDiagnostics = &lt;![CDATA[
BC30024: Statement is not valid inside a method.
        Option Strict On 'BIND:"Option Strict On"
        ~~~~~~~~~~~~~~~~
]]&gt;.Value

            VerifyOperationTreeAndDiagnosticsForTest(Of StatementSyntax)(source, expectedOperationTree, expectedDiagnostics)
        End Sub
```

Observed:
```
System.InvalidOperationException: Unexpected value 'OptionStatement' of type 'Microsoft.CodeAnalysis.VisualBasic.SyntaxKind'
   at Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.IsStandaloneStatement(StatementSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.GetBindingRoot(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.GetOperationWorker(VisualBasicSyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.GetOperationWorker(VisualBasicSyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetOperationCore(SyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.SemanticModel.GetOperation(SyntaxNode node, CancellationToken cancellationToken)
```</Description>
        <CreatedDate>20/11/2017</CreatedDate>
        <ClosedDate>20/11/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23283</IssueID>
        <Title>IOperation factory throws System.InvalidOperationException for an Option statement inside a method body</Title>
        <Description>```
        &lt;CompilerTrait(CompilerFeature.IOperation)&gt;
        &lt;Fact()&gt;
        Public Sub TestOptionStatement_01()
            Dim source = &lt;![CDATA[
Imports System

Class Test
    Sub Method()
        Option Strict On 'BIND:"Option Strict On"
    End Sub
End Class]]&gt;.Value

            Dim expectedOperationTree = &lt;![CDATA[
]]&gt;.Value

            Dim expectedDiagnostics = &lt;![CDATA[
BC30024: Statement is not valid inside a method.
        Option Strict On 'BIND:"Option Strict On"
        ~~~~~~~~~~~~~~~~
]]&gt;.Value

            VerifyOperationTreeAndDiagnosticsForTest(Of StatementSyntax)(source, expectedOperationTree, expectedDiagnostics)
        End Sub
```

Observed:
```
System.InvalidOperationException: Unexpected value 'OptionStatement' of type 'Microsoft.CodeAnalysis.VisualBasic.SyntaxKind'
   at Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.IsStandaloneStatement(StatementSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.GetBindingRoot(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.GetOperationWorker(VisualBasicSyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.GetOperationWorker(VisualBasicSyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetOperationCore(SyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.SemanticModel.GetOperation(SyntaxNode node, CancellationToken cancellationToken)
```</Description>
        <CreatedDate>20/11/2017</CreatedDate>
        <ClosedDate>20/11/2017</ClosedDate>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>23238</IssueID>
    <Title>Fix an InvalidCastException in IOperation factory for an ambiguous user-defined short-circuiting operator</Title>
    <Description>Fixes #23232.
Also fixes incorrect calculation of BinaryOperatorKind for the same node.

**Customer scenario**

Request IOperation tree for an ambiguous user-defined short-circuiting operator like the one below:
```
Option Strict Off

Imports System

Module Module1

    Class B2
        Public Shared Operator And(x As B3, y As B2) As B2
            Return Nothing
        End Operator

        Public Shared Operator Or(x As B3, y As B2) As B2
            Return Nothing
        End Operator
    End Class

    Class B3
        Public Shared Operator And(x As B3, y As B2) As B3
            Return Nothing
        End Operator

        Public Shared Operator Or(x As B3, y As B2) As B3
            Return Nothing
        End Operator
    End Class

    Sub Main()
        Dim x As Object

        x = New B3() AndAlso New B2() 'BIND1:"New B3() AndAlso New B2()"
    End Sub
End Module
```

An InvalidCastException is thrown by IOperation factory.

**Bugs this fixes:**

Fixes #23232.

**Workarounds, if any**

No

**Risk**

Low

**Performance impact**

Low perf impact because no extra allocations/no complexity changes

**Is this a regression from a previous update?**

No

**Root cause analysis:**

A test gap. Unit-tests are added.

**How was the bug found?**

Running existing compiler tests with IOperation validation test hook enabled.
</Description>
    <CreatedDate>17/11/2017</CreatedDate>
    <ClosedDate>17/11/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>23232</IssueID>
        <Title>An InvalidCastException is thrown for an ambiguous user-defined short-circuiting operator</Title>
        <Description>```
        &lt;CompilerTrait(CompilerFeature.IOperation)&gt;
        &lt;Fact&gt;
        Public Sub ShortCircuiting5()
            Dim compilationDef =
&lt;compilation name="SimpleTest1"&gt;
    &lt;file name="a.vb"&gt;&lt;![CDATA[
Option Strict Off

Imports System

Module Module1

    Class B2
        Public Shared Operator And(x As B3, y As B2) As B2
            Return Nothing
        End Operator

        Public Shared Operator Or(x As B3, y As B2) As B2
            Return Nothing
        End Operator
    End Class

    Class B3
        Public Shared Operator And(x As B3, y As B2) As B3
            Return Nothing
        End Operator

        Public Shared Operator Or(x As B3, y As B2) As B3
            Return Nothing
        End Operator
    End Class

    Sub Main()
        Dim x As Object

        x = New B3() AndAlso New B2() 'BIND1:"New B3() AndAlso New B2()"
        x = New B3() OrElse New B2() 'BIND2:"New B3() OrElse New B2()"
    End Sub
End Module
    ]]&gt;&lt;/file&gt;
&lt;/compilation&gt;

            Dim compilation = CreateCompilationWithMscorlibAndVBRuntime(compilationDef)

            CompilationUtils.AssertTheseDiagnostics(compilation,
&lt;expected&gt;
BC30521: Overload resolution failed because no accessible 'And' is most specific for these arguments:
    'Public Shared Operator Module1.B3.And(x As Module1.B3, y As Module1.B2) As Module1.B3': Not most specific.
    'Public Shared Operator Module1.B2.And(x As Module1.B3, y As Module1.B2) As Module1.B2': Not most specific.
        x = New B3() AndAlso New B2() 'BIND1:"New B3() AndAlso New B2()"
            ~~~~~~~~~~~~~~~~~~~~~~~~~
BC30521: Overload resolution failed because no accessible 'Or' is most specific for these arguments:
    'Public Shared Operator Module1.B3.Or(x As Module1.B3, y As Module1.B2) As Module1.B3': Not most specific.
    'Public Shared Operator Module1.B2.Or(x As Module1.B3, y As Module1.B2) As Module1.B2': Not most specific.
        x = New B3() OrElse New B2() 'BIND2:"New B3() OrElse New B2()"
            ~~~~~~~~~~~~~~~~~~~~~~~~
&lt;/expected&gt;)
   
            compilation.VerifyOperationTree(CompilationUtils.FindBindingText(Of ExpressionSyntax)(compilation, "a.vb", 1), expectedOperationTree:=
            &lt;![CDATA[
]]&gt;.Value)

            compilation.VerifyOperationTree(CompilationUtils.FindBindingText(Of ExpressionSyntax)(compilation, "a.vb", 2), expectedOperationTree:=
            &lt;![CDATA[
]]&gt;.Value)
        End Sub
```

Observed:
```
Test 'Microsoft.CodeAnalysis.VisualBasic.UnitTests.Semantics.UserDefinedBinaryOperators.ShortCircuiting5' failed: Microsoft.CodeAnalysis.ThrowingTraceListener+DebugAssertFailureException : 
System.InvalidCastException: Unable to cast object of type 'Microsoft.CodeAnalysis.VisualBasic.BoundBadExpression' to type 'Microsoft.CodeAnalysis.VisualBasic.BoundCall'.
   at Microsoft.CodeAnalysis.VisualBasic.BoundUserDefinedBinaryOperator.get_Call()
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.CreateBoundUserDefinedShortCircuitingOperatorOperation(BoundUserDefinedShortCircuitingOperator boundUserDefinedShortCircuitingOperator)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.CreateInternal(BoundNode boundNode)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory._Lambda$__3-0(BoundNode n)
   at System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(TKey key, Func`2 valueFactory)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.Create(BoundNode boundNode)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory._Closure$__121-0._Lambda$__2()
   at System.Lazy`1.CreateValue()
   at System.Lazy`1.LazyInitValue()
   at System.Lazy`1.get_Value()
   at Microsoft.CodeAnalysis.VisualBasic.LazyVisualBasicConversionExpression.get_OperandImpl()
   at Microsoft.CodeAnalysis.Operations.BaseConversionExpression.get_Operand()
   at Microsoft.CodeAnalysis.Operations.BaseConversionExpression.&lt;get_Children&gt;d__14.MoveNext()
   at Microsoft.CodeAnalysis.Operations.OperationExtensions.&lt;Descendants&gt;d__3.MoveNext()
   at System.Linq.Enumerable.FirstOrDefault[TSource](IEnumerable`1 source, Func`2 predicate)
   at Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.GetOperationWorker(VisualBasicSyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.GetOperationWorker(VisualBasicSyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetOperationCore(SyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.SemanticModel.GetOperation(SyntaxNode node, CancellationToken cancellationToken)

	at Microsoft.CodeAnalysis.ThrowingTraceListener.Fail(String message, String detailMessage)
	at System.Diagnostics.TraceListener.Fail(String message)
	at System.Diagnostics.TraceInternal.Fail(String message)
	at System.Diagnostics.Debug.Assert(Boolean condition, String message)
	at Microsoft.CodeAnalysis.SemanticModel.GetOperation(SyntaxNode node, CancellationToken cancellationToken)
	at Microsoft.CodeAnalysis.Test.Utilities.CompilationExtensions.AppendOperationTree(SemanticModel model, SyntaxNode node, StringBuilder actualTextBuilder, Int32 initialIndent)
	at Microsoft.CodeAnalysis.Test.Utilities.CompilationExtensions.VerifyOperationTree(Compilation compilation, SyntaxNode node, String expectedOperationTree)
	F:\GitHub\roslyn\src\Compilers\VisualBasic\Test\Semantic\Semantics\UserDefinedBinaryOperators.vb(590,0): at Microsoft.CodeAnalysis.VisualBasic.UnitTests.Semantics.UserDefinedBinaryOperators.ShortCircuiting5()
```
</Description>
        <CreatedDate>17/11/2017</CreatedDate>
        <ClosedDate>20/11/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23232</IssueID>
        <Title>An InvalidCastException is thrown for an ambiguous user-defined short-circuiting operator</Title>
        <Description>```
        &lt;CompilerTrait(CompilerFeature.IOperation)&gt;
        &lt;Fact&gt;
        Public Sub ShortCircuiting5()
            Dim compilationDef =
&lt;compilation name="SimpleTest1"&gt;
    &lt;file name="a.vb"&gt;&lt;![CDATA[
Option Strict Off

Imports System

Module Module1

    Class B2
        Public Shared Operator And(x As B3, y As B2) As B2
            Return Nothing
        End Operator

        Public Shared Operator Or(x As B3, y As B2) As B2
            Return Nothing
        End Operator
    End Class

    Class B3
        Public Shared Operator And(x As B3, y As B2) As B3
            Return Nothing
        End Operator

        Public Shared Operator Or(x As B3, y As B2) As B3
            Return Nothing
        End Operator
    End Class

    Sub Main()
        Dim x As Object

        x = New B3() AndAlso New B2() 'BIND1:"New B3() AndAlso New B2()"
        x = New B3() OrElse New B2() 'BIND2:"New B3() OrElse New B2()"
    End Sub
End Module
    ]]&gt;&lt;/file&gt;
&lt;/compilation&gt;

            Dim compilation = CreateCompilationWithMscorlibAndVBRuntime(compilationDef)

            CompilationUtils.AssertTheseDiagnostics(compilation,
&lt;expected&gt;
BC30521: Overload resolution failed because no accessible 'And' is most specific for these arguments:
    'Public Shared Operator Module1.B3.And(x As Module1.B3, y As Module1.B2) As Module1.B3': Not most specific.
    'Public Shared Operator Module1.B2.And(x As Module1.B3, y As Module1.B2) As Module1.B2': Not most specific.
        x = New B3() AndAlso New B2() 'BIND1:"New B3() AndAlso New B2()"
            ~~~~~~~~~~~~~~~~~~~~~~~~~
BC30521: Overload resolution failed because no accessible 'Or' is most specific for these arguments:
    'Public Shared Operator Module1.B3.Or(x As Module1.B3, y As Module1.B2) As Module1.B3': Not most specific.
    'Public Shared Operator Module1.B2.Or(x As Module1.B3, y As Module1.B2) As Module1.B2': Not most specific.
        x = New B3() OrElse New B2() 'BIND2:"New B3() OrElse New B2()"
            ~~~~~~~~~~~~~~~~~~~~~~~~
&lt;/expected&gt;)
   
            compilation.VerifyOperationTree(CompilationUtils.FindBindingText(Of ExpressionSyntax)(compilation, "a.vb", 1), expectedOperationTree:=
            &lt;![CDATA[
]]&gt;.Value)

            compilation.VerifyOperationTree(CompilationUtils.FindBindingText(Of ExpressionSyntax)(compilation, "a.vb", 2), expectedOperationTree:=
            &lt;![CDATA[
]]&gt;.Value)
        End Sub
```

Observed:
```
Test 'Microsoft.CodeAnalysis.VisualBasic.UnitTests.Semantics.UserDefinedBinaryOperators.ShortCircuiting5' failed: Microsoft.CodeAnalysis.ThrowingTraceListener+DebugAssertFailureException : 
System.InvalidCastException: Unable to cast object of type 'Microsoft.CodeAnalysis.VisualBasic.BoundBadExpression' to type 'Microsoft.CodeAnalysis.VisualBasic.BoundCall'.
   at Microsoft.CodeAnalysis.VisualBasic.BoundUserDefinedBinaryOperator.get_Call()
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.CreateBoundUserDefinedShortCircuitingOperatorOperation(BoundUserDefinedShortCircuitingOperator boundUserDefinedShortCircuitingOperator)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.CreateInternal(BoundNode boundNode)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory._Lambda$__3-0(BoundNode n)
   at System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(TKey key, Func`2 valueFactory)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.Create(BoundNode boundNode)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory._Closure$__121-0._Lambda$__2()
   at System.Lazy`1.CreateValue()
   at System.Lazy`1.LazyInitValue()
   at System.Lazy`1.get_Value()
   at Microsoft.CodeAnalysis.VisualBasic.LazyVisualBasicConversionExpression.get_OperandImpl()
   at Microsoft.CodeAnalysis.Operations.BaseConversionExpression.get_Operand()
   at Microsoft.CodeAnalysis.Operations.BaseConversionExpression.&lt;get_Children&gt;d__14.MoveNext()
   at Microsoft.CodeAnalysis.Operations.OperationExtensions.&lt;Descendants&gt;d__3.MoveNext()
   at System.Linq.Enumerable.FirstOrDefault[TSource](IEnumerable`1 source, Func`2 predicate)
   at Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.GetOperationWorker(VisualBasicSyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.GetOperationWorker(VisualBasicSyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetOperationCore(SyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.SemanticModel.GetOperation(SyntaxNode node, CancellationToken cancellationToken)

	at Microsoft.CodeAnalysis.ThrowingTraceListener.Fail(String message, String detailMessage)
	at System.Diagnostics.TraceListener.Fail(String message)
	at System.Diagnostics.TraceInternal.Fail(String message)
	at System.Diagnostics.Debug.Assert(Boolean condition, String message)
	at Microsoft.CodeAnalysis.SemanticModel.GetOperation(SyntaxNode node, CancellationToken cancellationToken)
	at Microsoft.CodeAnalysis.Test.Utilities.CompilationExtensions.AppendOperationTree(SemanticModel model, SyntaxNode node, StringBuilder actualTextBuilder, Int32 initialIndent)
	at Microsoft.CodeAnalysis.Test.Utilities.CompilationExtensions.VerifyOperationTree(Compilation compilation, SyntaxNode node, String expectedOperationTree)
	F:\GitHub\roslyn\src\Compilers\VisualBasic\Test\Semantic\Semantics\UserDefinedBinaryOperators.vb(590,0): at Microsoft.CodeAnalysis.VisualBasic.UnitTests.Semantics.UserDefinedBinaryOperators.ShortCircuiting5()
```
</Description>
        <CreatedDate>17/11/2017</CreatedDate>
        <ClosedDate>20/11/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/Core/Portable/Compilation/SemanticModel.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23237</IssueID>
    <Title>Change the 'Use auto property' code fixer to not be a 'compilation end' analyzer.</Title>
    <Description>Fixes #23216
Fixes #23215
Fixes #20855
Closes #23217

This PR changes the 'use auto property' code fixer to work as a Semantic-Model-Analyzer, instead of a Compilation-End analyzer.  Compilation-End-Analyzers are basically an unusable part of the analyzer API for code that wants to run in VS.  They are too expensive, and users can't interact with their results in a timely manner, like they can with normal analyzers.

As part of making this happen, I had to make a small change to the functionality of the feature.  Specifically, we used to determine if it was safe to make the change by analyzing all usages of a the field-to-remove in the project the feature was analyzing.  This was very expensive, but was necessary in case some code was using the field in an unexpected manner.  Now, we limit the feature to only private fields.  This means we can do that analysis in a timely manner, as we only have to examine the type it is contained in.  

This should have very little end user impact as the majority of user fields are private (esp. the ones that are paired with a property that you'd want ot make an auto prop out of).
</Description>
    <CreatedDate>17/11/2017</CreatedDate>
    <ClosedDate>20/11/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>23216</IssueID>
        <Title>IDE0032 (Use Auto Property) Fix All does not work</Title>
        <Description>**Version Used**: 15.5 Preview 3

🔗 Observed while investigating [this community report](https://developercommunity.visualstudio.com/content/problem/150002/ide0032-performs-less-than-ideal.html).

### Steps to Reproduce

1. Attempt to apply a Fix All operation to IDE0032 (Use Auto Property)

### Expected Behavior

Fix All, when available, fixes all instances of an issue within the specified context.

### Actual Behavior

Only one instance is fixed.

### Additional Details

* This behavior is observed even when Full Solution Analysis is enabled (see #23215)
* This behavior is observed even when IDE0032 is set to Warning severity</Description>
        <CreatedDate>16/11/2017</CreatedDate>
        <ClosedDate>20/11/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23215</IssueID>
        <Title>IDE0032 (Use Auto Property) does not work when full solution analysis is disabled</Title>
        <Description>**Version Used**: 15.5 Preview 3

🔗 Observed while investigating [this community report](https://developercommunity.visualstudio.com/content/problem/150002/ide0032-performs-less-than-ideal.html).

### Steps to Reproduce

1. Add a property:

    ```csharp
    private string _text;

    public string Text
    {
      get { return _text; }
      set { _text = value; }
    }
    ```

### Expected Behavior

The `_text` field is grayed (unnecessary code), and a code fix is provided to convert the field to an auto property.

### Actual Behavior

No suggestion is given.

### Additional details

If **Full Solution Analysis** is enabled, the feature works as expected. However, this feature is disabled both by default and by recommendation, with no plans to enable it. IDE analyzers cannot rely on this feature being enabled.</Description>
        <CreatedDate>16/11/2017</CreatedDate>
        <ClosedDate>20/11/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>20855</IssueID>
        <Title>IDE0032 Use Auto Property code fix mangles code in preexisting property with getter</Title>
        <Description>**Version Used**: d15rel 26711.00

**Steps to Reproduce**:

```
git clone https://github.com/microsoft/vs-threading.git
cd vs-threading
git checkout 0404d41776090ad54fd892081dcd1bd2b9165698
cd src
MSBuild /t:restore
.\Microsoft.VisualStudio.Threading.sln
```

1. Once in VS with the solution open, navigate to AsyncQueue.cs.
1. (I had netstandard1.1 selected as the language service context)
1. When the language service fades out the first field in the class (`syncObject`) activate the "Use Auto Property" code fix.

**Expected Behavior**:

No compile errors and no incorrect changes to code.

**Actual Behavior**:

The `SyncRoot` property which exposed the `syncObject` property is badly mangled. It was this:

```csharp
        protected object SyncRoot
        {
            get { return this.syncObject; }
        }
```

And was changed to this (including the comments, invalid syntax, etc.):

```csharp
        protected object SyncRoot {
/* Unmerged change from project 'Microsoft.VisualStudio.Threading(netstandard1.1)'
Before:
            get { return this.syncObject; }
After:
            get { return set; }
*/
 get; private this.SyncRoot; }
```

Note that there are absolutely no `#if` directives anywhere in the file. But this file is in a project that has 3 target frameworks.</Description>
        <CreatedDate>13/07/2017</CreatedDate>
        <ClosedDate>20/11/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23217</IssueID>
        <Title>Disable IDE0032 until it works</Title>
        <Description>**Version Used**: 15.5 Preview 3

🔗 Observed while investigating [this community report](https://developercommunity.visualstudio.com/content/problem/150002/ide0032-performs-less-than-ideal.html).

**Steps to Reproduce**:

1. Attempt to use the Use Auto Property diagnostic and code fix

**Expected Behavior**:

1. Code does not break
2. The code fix works
3. The fix all operation either work or is not provided

**Actual Behavior**:

I was unable to use this feature in any context and have it provide a meaningful result.

* The feature was not even visible without enabling a non-default (and not recommended) feature (#23215, #17857)
* The code was broken when the feature was used (#20855)
* The code fix didn't perform as expected (#23216)

This diagnostic needs to be disabled until it meets a reasonable quality bar.</Description>
        <CreatedDate>16/11/2017</CreatedDate>
        <ClosedDate>20/11/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharp/UseAutoProperty/UseAutoPropertyAnalyzer.cs</File>
      <File>src/EditorFeatures/CSharp/UseAutoProperty/UseAutoPropertyCodeFixProvider.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/UseAutoProperty/UseAutoPropertyTests.cs</File>
      <File>src/Features/Core/Portable/UseAutoProperty/AbstractUseAutoPropertyAnalyzer.cs</File>
      <File>src/Features/Core/Portable/UseAutoProperty/AbstractUseAutoPropertyCodeFixProvider.cs</File>
      <File>src/Workspaces/Core/Portable/Rename/Renamer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23224</IssueID>
    <Title>Fix an InvalidCastException in IOperation factory when a name of a range variable conflicts with another range variable.</Title>
    <Description>Fixes #23223.

**Customer scenario**

Request IOperation tree for a query expression like the one below:
```
Dim q As Object = From implicit In New Integer() {1, 2, 3} Let implicit = "1" Select implicit
```

An InvalidCastException is thrown by IOperation factory.

**Bugs this fixes:**

Fixes #23223.

**Workarounds, if any**

No

**Risk**

Low

**Performance impact**

Low perf impact because no extra allocations/no complexity changes

**Is this a regression from a previous update?**

No

**Root cause analysis:**

A test gap. Unit-tests are added.

**How was the bug found?**

Running existing compiler tests with IOperation validation test hook enabled.
</Description>
    <CreatedDate>16/11/2017</CreatedDate>
    <ClosedDate>17/11/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>23223</IssueID>
        <Title>An InvalidCastException is thrown when a name of range variable conflicts with another range variable</Title>
        <Description>```
        &lt;CompilerTrait(CompilerFeature.IOperation)&gt;
        Public Sub DuplicateRangeVariableName_IOperation()
            Dim source = &lt;![CDATA[
Option Strict Off
Imports System
Imports System.Linq

Module Module1
    Sub Main()
        Dim q As Object = From implicit In New Integer() {1, 2, 3} Let implicit = "1" Select implicit 'BIND:"From implicit In New Integer() {1, 2, 3} Let implicit = "1" Select implicit"
    End Sub
End Module]]&gt;.Value

            Dim expectedOperationTree = &lt;![CDATA[
]]&gt;.Value

            Dim expectedDiagnostics = &lt;![CDATA[
BC30978: Range variable 'implicit' hides a variable in an enclosing block or a range variable previously defined in the query expression.
        Dim q As Object = From implicit In New Integer() {1, 2, 3} Let implicit = "1" Select implicit 'BIND:"From implicit In New Integer() {1, 2, 3} Let implicit = "1" Select implicit"
                                                                       ~~~~~~~~
]]&gt;.Value

            VerifyOperationTreeAndDiagnosticsForTest(Of QueryExpressionSyntax)(source, expectedOperationTree, expectedDiagnostics)
        End Sub
```

Observed:
```
Test 'M:Microsoft.CodeAnalysis.VisualBasic.UnitTests.Semantics.QueryExpressions.DiplicateRangeVariableName_IOperation' failed:
	Unable to cast object of type 'Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PENamedTypeSymbolWithEmittedNamespaceName' to type 'AnonymousTypePublicSymbol'.
	System.InvalidCastException: Unable to cast object of type 'Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PENamedTypeSymbolWithEmittedNamespaceName' to type 'AnonymousTypePublicSymbol'.
	at Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.PopulateRangeVariableMapForAnonymousType(SyntaxNode syntax, BoundExpression anonymousTypeInstance, ImmutableArray`1 rangeVariables, Int32&amp; firstUnmappedRangeVariable, Dictionary`2 rangeVariableMap, Boolean inExpressionLambda)
	at Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.PopulateRangeVariableMapForAnonymousType(SyntaxNode syntax, BoundExpression anonymousTypeInstance, ImmutableArray`1 rangeVariables, Int32&amp; firstUnmappedRangeVariable, Dictionary`2 rangeVariableMap, Boolean inExpressionLambda)
	at Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.PopulateRangeVariableMapForQueryLambdaRewrite(BoundQueryLambda node, Dictionary`2&amp; rangeVariableMap, Boolean inExpressionLambda)
	at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.QueryLambdaRewriterPass1.VisitQueryLambda(BoundQueryLambda node)
	at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.RewriteQueryLambda(BoundQueryLambda node)
	at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.CreateInternal(BoundNode boundNode)
	at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory._Lambda$__3-0(BoundNode n)
	at System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(TKey key, Func`2 valueFactory)
	at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.Create(BoundNode boundNode)
	at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory._Closure$__121-0._Lambda$__1()
	at System.Lazy`1.CreateValue()
	at System.Lazy`1.LazyInitValue()
	at System.Lazy`1.get_Value()
	at Microsoft.CodeAnalysis.Operations.LazyDelegateCreationExpression.get_TargetImpl()
	at Microsoft.CodeAnalysis.Operations.BaseDelegateCreationExpression.get_Target()
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.VisitDelegateCreation(IDelegateCreationOperation operation)
	at Microsoft.CodeAnalysis.Operations.BaseDelegateCreationExpression.Accept(OperationVisitor visitor)
	at Microsoft.CodeAnalysis.Operations.OperationWalker.Visit(IOperation operation)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.Visit(IOperation operation)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.VisitArgument(IArgumentOperation operation)
	at Microsoft.CodeAnalysis.Operations.BaseArgument.Accept(OperationVisitor visitor)
	at Microsoft.CodeAnalysis.Operations.OperationWalker.Visit(IOperation operation)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.Visit(IOperation operation)
	at Microsoft.CodeAnalysis.Operations.OperationWalker.VisitOperationArrayElement[T](T operation)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.VisitArrayCommon[T](ImmutableArray`1 list, String header, Boolean logElementCount, Boolean logNullForDefault, Action`1 arrayElementVisitor)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.VisitArray[T](ImmutableArray`1 list, String header, Boolean logElementCount, Boolean logNullForDefault)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.VisitArguments(ImmutableArray`1 arguments)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.VisitInvocation(IInvocationOperation operation)
	at Microsoft.CodeAnalysis.Operations.BaseInvocationExpression.Accept(OperationVisitor visitor)
	at Microsoft.CodeAnalysis.Operations.OperationWalker.Visit(IOperation operation)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.Visit(IOperation operation)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.Visit(IOperation operation, String header)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.VisitTranslatedQuery(ITranslatedQueryOperation operation)
	at Microsoft.CodeAnalysis.Operations.BaseTranslatedQueryExpression.Accept(OperationVisitor visitor)
	at Microsoft.CodeAnalysis.Operations.OperationWalker.Visit(IOperation operation)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.Visit(IOperation operation)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.GetOperationTree(Compilation compilation, IOperation operation, Int32 initialIndent)
	at Microsoft.CodeAnalysis.VisualBasic.UnitTests.BasicTestBaseBase.GetOperationTreeForTest[TSyntaxNode](VisualBasicCompilation compilation, String fileName, Int32 which)
	at Microsoft.CodeAnalysis.VisualBasic.UnitTests.BasicTestBaseBase.VerifyOperationTreeForTest[TSyntaxNode](VisualBasicCompilation compilation, String fileName, String expectedOperationTree, Int32 which, Action`3 additionalOperationTreeVerifier)
	at Microsoft.CodeAnalysis.VisualBasic.UnitTests.BasicTestBaseBase.VerifyOperationTreeAndDiagnosticsForTest[TSyntaxNode](VisualBasicCompilation compilation, String fileName, String expectedOperationTree, String expectedDiagnostics, Int32 which, Action`3 additionalOperationTreeVerifier)
	at Microsoft.CodeAnalysis.VisualBasic.UnitTests.BasicTestBaseBase.VerifyOperationTreeAndDiagnosticsForTest[TSyntaxNode](String testSrc, String expectedOperationTree, String expectedDiagnostics, VisualBasicCompilationOptions compilationOptions, VisualBasicParseOptions parseOptions, Int32 which, IEnumerable`1 additionalReferences, Action`3 additionalOperationTreeVerifier, Boolean useLatestFramework)
	F:\GitHub\roslyn\src\Compilers\VisualBasic\Test\Semantic\Semantics\QueryExpressions.vb(14736,0): at Microsoft.CodeAnalysis.VisualBasic.UnitTests.Semantics.QueryExpressions.DiplicateRangeVariableName_IOperation()
```</Description>
        <CreatedDate>16/11/2017</CreatedDate>
        <ClosedDate>20/11/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23223</IssueID>
        <Title>An InvalidCastException is thrown when a name of range variable conflicts with another range variable</Title>
        <Description>```
        &lt;CompilerTrait(CompilerFeature.IOperation)&gt;
        Public Sub DuplicateRangeVariableName_IOperation()
            Dim source = &lt;![CDATA[
Option Strict Off
Imports System
Imports System.Linq

Module Module1
    Sub Main()
        Dim q As Object = From implicit In New Integer() {1, 2, 3} Let implicit = "1" Select implicit 'BIND:"From implicit In New Integer() {1, 2, 3} Let implicit = "1" Select implicit"
    End Sub
End Module]]&gt;.Value

            Dim expectedOperationTree = &lt;![CDATA[
]]&gt;.Value

            Dim expectedDiagnostics = &lt;![CDATA[
BC30978: Range variable 'implicit' hides a variable in an enclosing block or a range variable previously defined in the query expression.
        Dim q As Object = From implicit In New Integer() {1, 2, 3} Let implicit = "1" Select implicit 'BIND:"From implicit In New Integer() {1, 2, 3} Let implicit = "1" Select implicit"
                                                                       ~~~~~~~~
]]&gt;.Value

            VerifyOperationTreeAndDiagnosticsForTest(Of QueryExpressionSyntax)(source, expectedOperationTree, expectedDiagnostics)
        End Sub
```

Observed:
```
Test 'M:Microsoft.CodeAnalysis.VisualBasic.UnitTests.Semantics.QueryExpressions.DiplicateRangeVariableName_IOperation' failed:
	Unable to cast object of type 'Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PENamedTypeSymbolWithEmittedNamespaceName' to type 'AnonymousTypePublicSymbol'.
	System.InvalidCastException: Unable to cast object of type 'Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PENamedTypeSymbolWithEmittedNamespaceName' to type 'AnonymousTypePublicSymbol'.
	at Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.PopulateRangeVariableMapForAnonymousType(SyntaxNode syntax, BoundExpression anonymousTypeInstance, ImmutableArray`1 rangeVariables, Int32&amp; firstUnmappedRangeVariable, Dictionary`2 rangeVariableMap, Boolean inExpressionLambda)
	at Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.PopulateRangeVariableMapForAnonymousType(SyntaxNode syntax, BoundExpression anonymousTypeInstance, ImmutableArray`1 rangeVariables, Int32&amp; firstUnmappedRangeVariable, Dictionary`2 rangeVariableMap, Boolean inExpressionLambda)
	at Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.PopulateRangeVariableMapForQueryLambdaRewrite(BoundQueryLambda node, Dictionary`2&amp; rangeVariableMap, Boolean inExpressionLambda)
	at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.QueryLambdaRewriterPass1.VisitQueryLambda(BoundQueryLambda node)
	at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.RewriteQueryLambda(BoundQueryLambda node)
	at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.CreateInternal(BoundNode boundNode)
	at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory._Lambda$__3-0(BoundNode n)
	at System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(TKey key, Func`2 valueFactory)
	at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.Create(BoundNode boundNode)
	at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory._Closure$__121-0._Lambda$__1()
	at System.Lazy`1.CreateValue()
	at System.Lazy`1.LazyInitValue()
	at System.Lazy`1.get_Value()
	at Microsoft.CodeAnalysis.Operations.LazyDelegateCreationExpression.get_TargetImpl()
	at Microsoft.CodeAnalysis.Operations.BaseDelegateCreationExpression.get_Target()
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.VisitDelegateCreation(IDelegateCreationOperation operation)
	at Microsoft.CodeAnalysis.Operations.BaseDelegateCreationExpression.Accept(OperationVisitor visitor)
	at Microsoft.CodeAnalysis.Operations.OperationWalker.Visit(IOperation operation)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.Visit(IOperation operation)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.VisitArgument(IArgumentOperation operation)
	at Microsoft.CodeAnalysis.Operations.BaseArgument.Accept(OperationVisitor visitor)
	at Microsoft.CodeAnalysis.Operations.OperationWalker.Visit(IOperation operation)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.Visit(IOperation operation)
	at Microsoft.CodeAnalysis.Operations.OperationWalker.VisitOperationArrayElement[T](T operation)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.VisitArrayCommon[T](ImmutableArray`1 list, String header, Boolean logElementCount, Boolean logNullForDefault, Action`1 arrayElementVisitor)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.VisitArray[T](ImmutableArray`1 list, String header, Boolean logElementCount, Boolean logNullForDefault)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.VisitArguments(ImmutableArray`1 arguments)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.VisitInvocation(IInvocationOperation operation)
	at Microsoft.CodeAnalysis.Operations.BaseInvocationExpression.Accept(OperationVisitor visitor)
	at Microsoft.CodeAnalysis.Operations.OperationWalker.Visit(IOperation operation)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.Visit(IOperation operation)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.Visit(IOperation operation, String header)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.VisitTranslatedQuery(ITranslatedQueryOperation operation)
	at Microsoft.CodeAnalysis.Operations.BaseTranslatedQueryExpression.Accept(OperationVisitor visitor)
	at Microsoft.CodeAnalysis.Operations.OperationWalker.Visit(IOperation operation)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.Visit(IOperation operation)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.GetOperationTree(Compilation compilation, IOperation operation, Int32 initialIndent)
	at Microsoft.CodeAnalysis.VisualBasic.UnitTests.BasicTestBaseBase.GetOperationTreeForTest[TSyntaxNode](VisualBasicCompilation compilation, String fileName, Int32 which)
	at Microsoft.CodeAnalysis.VisualBasic.UnitTests.BasicTestBaseBase.VerifyOperationTreeForTest[TSyntaxNode](VisualBasicCompilation compilation, String fileName, String expectedOperationTree, Int32 which, Action`3 additionalOperationTreeVerifier)
	at Microsoft.CodeAnalysis.VisualBasic.UnitTests.BasicTestBaseBase.VerifyOperationTreeAndDiagnosticsForTest[TSyntaxNode](VisualBasicCompilation compilation, String fileName, String expectedOperationTree, String expectedDiagnostics, Int32 which, Action`3 additionalOperationTreeVerifier)
	at Microsoft.CodeAnalysis.VisualBasic.UnitTests.BasicTestBaseBase.VerifyOperationTreeAndDiagnosticsForTest[TSyntaxNode](String testSrc, String expectedOperationTree, String expectedDiagnostics, VisualBasicCompilationOptions compilationOptions, VisualBasicParseOptions parseOptions, Int32 which, IEnumerable`1 additionalReferences, Action`3 additionalOperationTreeVerifier, Boolean useLatestFramework)
	F:\GitHub\roslyn\src\Compilers\VisualBasic\Test\Semantic\Semantics\QueryExpressions.vb(14736,0): at Microsoft.CodeAnalysis.VisualBasic.UnitTests.Semantics.QueryExpressions.DiplicateRangeVariableName_IOperation()
```</Description>
        <CreatedDate>16/11/2017</CreatedDate>
        <ClosedDate>20/11/2017</ClosedDate>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>23206</IssueID>
    <Title>Fix an InvalidCastException in IOperation factory when a user defined conversions involves an integer overflow.</Title>
    <Description>Fixes #23203.

**Customer scenario**

Request IOperation tree for a variable initializer like the one below:
```
Module Module1

    Class C1
        Shared Widening Operator CType(x As Byte) As C1
            Return Nothing
        End Operator
    End Class

    Sub Main()
        Dim z1 As C1 = &amp;H7FFFFFFFL 'BIND:"= &amp;H7FFFFFFFL"
    End Sub
End Module
```

An InvalidCastException is thrown by IOperation factory.

**Bugs this fixes:**

Fixes #23203.

**Workarounds, if any**

No

**Risk**

Low

**Performance impact**

Low perf impact because no extra allocations/no complexity changes

**Is this a regression from a previous update?**

No

**Root cause analysis:**

A test gap. Unit-tests are added.

**How was the bug found?**

Running existing compiler tests with IOperation validation test hook enabled.
</Description>
    <CreatedDate>16/11/2017</CreatedDate>
    <ClosedDate>17/11/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>23203</IssueID>
        <Title>InvalidCastException is thrown when user defined conversions involves integer overflow</Title>
        <Description>```
        &lt;CompilerTrait(CompilerFeature.IOperation)&gt;
        &lt;Fact&gt;
        Public Sub ConversionExpression_IntegerOverflow()
            Dim source = &lt;![CDATA[
Imports System

Module Module1

    Class C1
        Shared Widening Operator CType(x As Byte) As C1
            Return Nothing
        End Operator
    End Class

    Sub Main()

        Dim z1 As C1 = &amp;H7FFFFFFFL 'BIND:"= &amp;H7FFFFFFFL"
    End Sub
End Module
]]&gt;.Value


            Dim expectedOperationTree = &lt;![CDATA[
]]&gt;.Value

            Dim expectedDiagnostics = &lt;![CDATA[
BC30439: Constant expression not representable in type 'Byte'.
        Dim z1 As C1 = &amp;H7FFFFFFFL 'BIND:"= &amp;H7FFFFFFFL"
                       ~~~~~~~~~~~
]]&gt;.Value

            VerifyOperationTreeAndDiagnosticsForTest(Of EqualsValueSyntax)(source, expectedOperationTree, expectedDiagnostics)
        End Sub
```

Observed:
```
Test 'Microsoft.CodeAnalysis.VisualBasic.UnitTests.Semantics.IOperationTests.ConversionExpression_IntegerOverflow' failed:
	Microsoft.CodeAnalysis.ThrowingTraceListener+DebugAssertFailureException : System.InvalidCastException: Unable to cast object of type 'Microsoft.CodeAnalysis.VisualBasic.BoundLiteral' to type 'Microsoft.CodeAnalysis.VisualBasic.BoundUserDefinedConversion'.
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.GetConversionInfo(BoundConversion boundConversion)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.CreateBoundConversionOperation(BoundConversion boundConversion)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.CreateInternal(BoundNode boundNode)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory._Lambda$__3-0(BoundNode n)
   at System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(TKey key, Func`2 valueFactory)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.Create(BoundNode boundNode)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.GetVariableDeclarationStatementVariables(ImmutableArray`1 declarations)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory._Closure$__73-0._Lambda$__0()
   at System.Lazy`1.CreateValue()
   at System.Lazy`1.LazyInitValue()
   at System.Lazy`1.get_Value()
   at Microsoft.CodeAnalysis.Operations.LazyVariableDeclarationGroupOperation.get_DeclarationsImpl()
   at Microsoft.CodeAnalysis.Operations.BaseVariableDeclarationGroupOperation.get_Declarations()
   at Microsoft.CodeAnalysis.Operations.BaseVariableDeclarationGroupOperation.&lt;get_Children&gt;d__4.MoveNext()
   at Microsoft.CodeAnalysis.Operations.OperationExtensions.&lt;Descendants&gt;d__3.MoveNext()
   at System.Linq.Enumerable.FirstOrDefault[TSource](IEnumerable`1 source, Func`2 predicate)
   at Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.GetOperationWorker(VisualBasicSyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.GetOperationWorker(VisualBasicSyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetOperationCore(SyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.SemanticModel.GetOperation(SyntaxNode node, CancellationToken cancellationToken)

	at Microsoft.CodeAnalysis.ThrowingTraceListener.Fail(String message, String detailMessage)
	at System.Diagnostics.TraceListener.Fail(String message)
	at System.Diagnostics.TraceInternal.Fail(String message)
	at System.Diagnostics.Debug.Assert(Boolean condition, String message)
	at Microsoft.CodeAnalysis.SemanticModel.GetOperation(SyntaxNode node, CancellationToken cancellationToken)
	at Microsoft.CodeAnalysis.VisualBasic.UnitTests.BasicTestBaseBase.GetOperationTreeForTest[TSyntaxNode](VisualBasicCompilation compilation, String fileName, Int32 which)
	at Microsoft.CodeAnalysis.VisualBasic.UnitTests.BasicTestBaseBase.VerifyOperationTreeForTest[TSyntaxNode](VisualBasicCompilation compilation, String fileName, String expectedOperationTree, Int32 which, Action`3 additionalOperationTreeVerifier)
	at Microsoft.CodeAnalysis.VisualBasic.UnitTests.BasicTestBaseBase.VerifyOperationTreeAndDiagnosticsForTest[TSyntaxNode](VisualBasicCompilation compilation, String fileName, String expectedOperationTree, String expectedDiagnostics, Int32 which, Action`3 additionalOperationTreeVerifier)
	at Microsoft.CodeAnalysis.VisualBasic.UnitTests.BasicTestBaseBase.VerifyOperationTreeAndDiagnosticsForTest[TSyntaxNode](String testSrc, String expectedOperationTree, String expectedDiagnostics, VisualBasicCompilationOptions compilationOptions, VisualBasicParseOptions parseOptions, Int32 which, IEnumerable`1 additionalReferences, Action`3 additionalOperationTreeVerifier, Boolean useLatestFramework)
	F:\GitHub\roslyn\src\Compilers\VisualBasic\Test\Semantic\IOperation\IOperationTests_IConversionExpression.vb(3027,0): at Microsoft.CodeAnalysis.VisualBasic.UnitTests.Semantics.IOperationTests.ConversionExpression_IntegerOverflow()
```</Description>
        <CreatedDate>15/11/2017</CreatedDate>
        <ClosedDate>20/11/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23203</IssueID>
        <Title>InvalidCastException is thrown when user defined conversions involves integer overflow</Title>
        <Description>```
        &lt;CompilerTrait(CompilerFeature.IOperation)&gt;
        &lt;Fact&gt;
        Public Sub ConversionExpression_IntegerOverflow()
            Dim source = &lt;![CDATA[
Imports System

Module Module1

    Class C1
        Shared Widening Operator CType(x As Byte) As C1
            Return Nothing
        End Operator
    End Class

    Sub Main()

        Dim z1 As C1 = &amp;H7FFFFFFFL 'BIND:"= &amp;H7FFFFFFFL"
    End Sub
End Module
]]&gt;.Value


            Dim expectedOperationTree = &lt;![CDATA[
]]&gt;.Value

            Dim expectedDiagnostics = &lt;![CDATA[
BC30439: Constant expression not representable in type 'Byte'.
        Dim z1 As C1 = &amp;H7FFFFFFFL 'BIND:"= &amp;H7FFFFFFFL"
                       ~~~~~~~~~~~
]]&gt;.Value

            VerifyOperationTreeAndDiagnosticsForTest(Of EqualsValueSyntax)(source, expectedOperationTree, expectedDiagnostics)
        End Sub
```

Observed:
```
Test 'Microsoft.CodeAnalysis.VisualBasic.UnitTests.Semantics.IOperationTests.ConversionExpression_IntegerOverflow' failed:
	Microsoft.CodeAnalysis.ThrowingTraceListener+DebugAssertFailureException : System.InvalidCastException: Unable to cast object of type 'Microsoft.CodeAnalysis.VisualBasic.BoundLiteral' to type 'Microsoft.CodeAnalysis.VisualBasic.BoundUserDefinedConversion'.
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.GetConversionInfo(BoundConversion boundConversion)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.CreateBoundConversionOperation(BoundConversion boundConversion)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.CreateInternal(BoundNode boundNode)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory._Lambda$__3-0(BoundNode n)
   at System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(TKey key, Func`2 valueFactory)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.Create(BoundNode boundNode)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.GetVariableDeclarationStatementVariables(ImmutableArray`1 declarations)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory._Closure$__73-0._Lambda$__0()
   at System.Lazy`1.CreateValue()
   at System.Lazy`1.LazyInitValue()
   at System.Lazy`1.get_Value()
   at Microsoft.CodeAnalysis.Operations.LazyVariableDeclarationGroupOperation.get_DeclarationsImpl()
   at Microsoft.CodeAnalysis.Operations.BaseVariableDeclarationGroupOperation.get_Declarations()
   at Microsoft.CodeAnalysis.Operations.BaseVariableDeclarationGroupOperation.&lt;get_Children&gt;d__4.MoveNext()
   at Microsoft.CodeAnalysis.Operations.OperationExtensions.&lt;Descendants&gt;d__3.MoveNext()
   at System.Linq.Enumerable.FirstOrDefault[TSource](IEnumerable`1 source, Func`2 predicate)
   at Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.GetOperationWorker(VisualBasicSyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.GetOperationWorker(VisualBasicSyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetOperationCore(SyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.SemanticModel.GetOperation(SyntaxNode node, CancellationToken cancellationToken)

	at Microsoft.CodeAnalysis.ThrowingTraceListener.Fail(String message, String detailMessage)
	at System.Diagnostics.TraceListener.Fail(String message)
	at System.Diagnostics.TraceInternal.Fail(String message)
	at System.Diagnostics.Debug.Assert(Boolean condition, String message)
	at Microsoft.CodeAnalysis.SemanticModel.GetOperation(SyntaxNode node, CancellationToken cancellationToken)
	at Microsoft.CodeAnalysis.VisualBasic.UnitTests.BasicTestBaseBase.GetOperationTreeForTest[TSyntaxNode](VisualBasicCompilation compilation, String fileName, Int32 which)
	at Microsoft.CodeAnalysis.VisualBasic.UnitTests.BasicTestBaseBase.VerifyOperationTreeForTest[TSyntaxNode](VisualBasicCompilation compilation, String fileName, String expectedOperationTree, Int32 which, Action`3 additionalOperationTreeVerifier)
	at Microsoft.CodeAnalysis.VisualBasic.UnitTests.BasicTestBaseBase.VerifyOperationTreeAndDiagnosticsForTest[TSyntaxNode](VisualBasicCompilation compilation, String fileName, String expectedOperationTree, String expectedDiagnostics, Int32 which, Action`3 additionalOperationTreeVerifier)
	at Microsoft.CodeAnalysis.VisualBasic.UnitTests.BasicTestBaseBase.VerifyOperationTreeAndDiagnosticsForTest[TSyntaxNode](String testSrc, String expectedOperationTree, String expectedDiagnostics, VisualBasicCompilationOptions compilationOptions, VisualBasicParseOptions parseOptions, Int32 which, IEnumerable`1 additionalReferences, Action`3 additionalOperationTreeVerifier, Boolean useLatestFramework)
	F:\GitHub\roslyn\src\Compilers\VisualBasic\Test\Semantic\IOperation\IOperationTests_IConversionExpression.vb(3027,0): at Microsoft.CodeAnalysis.VisualBasic.UnitTests.Semantics.IOperationTests.ConversionExpression_IntegerOverflow()
```</Description>
        <CreatedDate>15/11/2017</CreatedDate>
        <ClosedDate>20/11/2017</ClosedDate>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>23170</IssueID>
    <Title>Do not expose type expression as IDynamicMemberReferenceOperation.Instance</Title>
    <Description>Related to #22548 and #22229.
</Description>
    <CreatedDate>14/11/2017</CreatedDate>
    <ClosedDate>15/11/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>22548</IssueID>
        <Title>Follow up on isImplicit mismatch </Title>
        <Description>Address feedback from https://github.com/dotnet/roslyn/pull/22309 </Description>
        <CreatedDate>05/10/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22229</IssueID>
        <Title>IsImplicit for multiple operation nodes with same syntax</Title>
        <Description>we want to make sure there is only one explicit IOperation when multiple IOperations are pointing to same syntax node.

right now, we have case such as this (https://github.com/dotnet/roslyn/pull/21857#pullrequestreview-64081939 or https://github.com/dotnet/roslyn/pull/21857#issuecomment-330950924) where InvalidExpression is pointing to same syntax node as its child. or ExpressionStatement pointing to same syntax node as its expression (ex, expression lambda body)

we need to decide whether we want to mark those as implicit or not. if we do, those IOperation will not be returned by GetOperation. but user can still get to that operation through parent and children.
</Description>
        <CreatedDate>20/09/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Invocation.cs</File>
      <File>src/Compilers/CSharp/Portable/Operations/CSharpOperationFactory.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IDynamicInvocationExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IUsingStatement.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IDynamicMemberReferenceOperation.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23162</IssueID>
    <Title>Fix NullReferenceException thrown while building IOperation node for dynamic object member initializer.</Title>
    <Description>Fixes #23154.
VSO Bug https://devdiv.visualstudio.com/DevDiv/_workitems?id=524873

**Customer scenario**

Request IOperation tree for an object creation expression like the one below:
```
        dynamic x = 1;
        var a = new A {[y: x, x: x] = { X = 1} };
...
class A
{
    dynamic this[int x, int y]
    {
        get
        {
            return new A();
        }
    }

    dynamic this[string x, string y]
    {
        get
        {
            return null;
        }
    }

    int X, Y, Z;
}
```

A null reference exception is thrown by IOperation factory.

**Bugs this fixes:**

Fixes #23154.
VSO Bug https://devdiv.visualstudio.com/DevDiv/_workitems?id=524873

**Workarounds, if any**

No

**Risk**

Low

**Performance impact**

Low perf impact because no extra allocations/no complexity changes

**Is this a regression from a previous update?**

No

**Root cause analysis:**

A test gap. Unit-tests are added.

**How was the bug found?**

Running existing compiler tests with IOperation validation test hook enabled.
</Description>
    <CreatedDate>14/11/2017</CreatedDate>
    <ClosedDate>16/11/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>23154</IssueID>
        <Title>System.NullReferenceException is thrown for dynamic object member initializer</Title>
        <Description>```
        [CompilerTrait(CompilerFeature.IOperation)]
        [Fact]
        public void ObjectCreationWithDynamicMemberInitializer_01()
        {
            string source = @"
class A
{
    dynamic this[int x, int y]
    {
        get
        {
            return new A();
        }
    }

    dynamic this[string x, string y]
    {
        get
        {
            throw null;
        }
    }

    int X, Y, Z;

    static void Main()
    {
        dynamic x = 1;
        new A {/*&lt;bind&gt;*/[y: x, x: x] = { X = 1, Y = 1, Z = 1 }/*&lt;/bind&gt;*/ };
    }
}
";
            string expectedOperationTree = @"
";
            var expectedDiagnostics = DiagnosticDescription.None;

            VerifyOperationTreeAndDiagnosticsForTest&lt;AssignmentExpressionSyntax&gt;(source, expectedOperationTree, expectedDiagnostics);
        }

```

Observed:
```
Test 'Microsoft.CodeAnalysis.CSharp.UnitTests.IOperationTests.ObjectCreationWithDynamicMemberInitializer_01' failed: Microsoft.CodeAnalysis.ThrowingTraceListener+DebugAssertFailureException : System.NullReferenceException: Object reference not set to an instance of an object.
   at Microsoft.CodeAnalysis.Operations.CSharpOperationFactory.CreateBoundObjectInitializerMemberOperation(BoundObjectInitializerMember boundObjectInitializerMember)
   at Microsoft.CodeAnalysis.Operations.CSharpOperationFactory.CreateInternal(BoundNode boundNode)
   at Microsoft.CodeAnalysis.Operations.CSharpOperationFactory.&lt;Create&gt;b__3_0(BoundNode n)
   at System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(TKey key, Func`2 valueFactory)
   at Microsoft.CodeAnalysis.Operations.CSharpOperationFactory.Create(BoundNode boundNode)
   at Microsoft.CodeAnalysis.Operations.CSharpOperationFactory.&lt;&gt;c__DisplayClass49_0.&lt;CreateBoundMemberInitializerOperation&gt;b__0()
   at System.Lazy`1.CreateValue()
   at System.Lazy`1.LazyInitValue()
   at System.Lazy`1.get_Value()
   at Microsoft.CodeAnalysis.Operations.LazyMemberInitializerExpression.get_InitializedMemberImpl()
   at Microsoft.CodeAnalysis.Operations.BaseMemberInitializerExpression.get_InitializedMember()
   at Microsoft.CodeAnalysis.Operations.BaseMemberInitializerExpression.&lt;get_Children&gt;d__6.MoveNext()
   at Microsoft.CodeAnalysis.Operations.OperationExtensions.&lt;Descendants&gt;d__3.MoveNext()
   at System.Linq.Enumerable.FirstOrDefault[TSource](IEnumerable`1 source, Func`2 predicate)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetOperationWorker(CSharpSyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetOperationCore(SyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.SemanticModel.GetOperation(SyntaxNode node, CancellationToken cancellationToken)

	at Microsoft.CodeAnalysis.ThrowingTraceListener.Fail(String message, String detailMessage)
	at System.Diagnostics.TraceListener.Fail(String message)
	at System.Diagnostics.TraceInternal.Fail(String message)
	at System.Diagnostics.Debug.Assert(Boolean condition, String message)
	at Microsoft.CodeAnalysis.SemanticModel.GetOperation(SyntaxNode node, CancellationToken cancellationToken)
	at Microsoft.CodeAnalysis.Operation.SearchParentOperation()
	at Microsoft.CodeAnalysis.Operation.get_Parent()
	at Microsoft.CodeAnalysis.Test.Utilities.CompilationExtensions.ValidateIOperations(Func`1 createCompilation)
	at Microsoft.CodeAnalysis.CSharp.Test.Utilities.CSharpTestBaseBase.CreateCompilation(IEnumerable`1 trees, IEnumerable`1 references, CSharpCompilationOptions options, String assemblyName)
	at Microsoft.CodeAnalysis.CSharp.Test.Utilities.CSharpTestBaseBase.CreateStandardCompilation(IEnumerable`1 trees, IEnumerable`1 references, CSharpCompilationOptions options, String assemblyName)
	at Microsoft.CodeAnalysis.CSharp.Test.Utilities.CSharpTestBaseBase.CreateStandardCompilation(String text, IEnumerable`1 references, CSharpCompilationOptions options, CSharpParseOptions parseOptions, String assemblyName, String sourceFileName)
	at Microsoft.CodeAnalysis.CSharp.Test.Utilities.CSharpTestBaseBase.VerifyOperationTreeAndDiagnosticsForTest[TSyntaxNode](String testSrc, String expectedOperationTree, DiagnosticDescription[] expectedDiagnostics, CSharpCompilationOptions compilationOptions, CSharpParseOptions parseOptions, MetadataReference[] additionalReferences, Action`3 additionalOperationTreeVerifier, Boolean useLatestFrameworkReferences)
	F:\GitHub\roslyn\src\Compilers\CSharp\Test\Semantic\IOperation\IOperationTests_IObjectCreationExpression.cs(644,0): at Microsoft.CodeAnalysis.CSharp.UnitTests.IOperationTests.ObjectCreationWithDynamicMemberInitializer_01()
```</Description>
        <CreatedDate>14/11/2017</CreatedDate>
        <ClosedDate>16/11/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23154</IssueID>
        <Title>System.NullReferenceException is thrown for dynamic object member initializer</Title>
        <Description>```
        [CompilerTrait(CompilerFeature.IOperation)]
        [Fact]
        public void ObjectCreationWithDynamicMemberInitializer_01()
        {
            string source = @"
class A
{
    dynamic this[int x, int y]
    {
        get
        {
            return new A();
        }
    }

    dynamic this[string x, string y]
    {
        get
        {
            throw null;
        }
    }

    int X, Y, Z;

    static void Main()
    {
        dynamic x = 1;
        new A {/*&lt;bind&gt;*/[y: x, x: x] = { X = 1, Y = 1, Z = 1 }/*&lt;/bind&gt;*/ };
    }
}
";
            string expectedOperationTree = @"
";
            var expectedDiagnostics = DiagnosticDescription.None;

            VerifyOperationTreeAndDiagnosticsForTest&lt;AssignmentExpressionSyntax&gt;(source, expectedOperationTree, expectedDiagnostics);
        }

```

Observed:
```
Test 'Microsoft.CodeAnalysis.CSharp.UnitTests.IOperationTests.ObjectCreationWithDynamicMemberInitializer_01' failed: Microsoft.CodeAnalysis.ThrowingTraceListener+DebugAssertFailureException : System.NullReferenceException: Object reference not set to an instance of an object.
   at Microsoft.CodeAnalysis.Operations.CSharpOperationFactory.CreateBoundObjectInitializerMemberOperation(BoundObjectInitializerMember boundObjectInitializerMember)
   at Microsoft.CodeAnalysis.Operations.CSharpOperationFactory.CreateInternal(BoundNode boundNode)
   at Microsoft.CodeAnalysis.Operations.CSharpOperationFactory.&lt;Create&gt;b__3_0(BoundNode n)
   at System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(TKey key, Func`2 valueFactory)
   at Microsoft.CodeAnalysis.Operations.CSharpOperationFactory.Create(BoundNode boundNode)
   at Microsoft.CodeAnalysis.Operations.CSharpOperationFactory.&lt;&gt;c__DisplayClass49_0.&lt;CreateBoundMemberInitializerOperation&gt;b__0()
   at System.Lazy`1.CreateValue()
   at System.Lazy`1.LazyInitValue()
   at System.Lazy`1.get_Value()
   at Microsoft.CodeAnalysis.Operations.LazyMemberInitializerExpression.get_InitializedMemberImpl()
   at Microsoft.CodeAnalysis.Operations.BaseMemberInitializerExpression.get_InitializedMember()
   at Microsoft.CodeAnalysis.Operations.BaseMemberInitializerExpression.&lt;get_Children&gt;d__6.MoveNext()
   at Microsoft.CodeAnalysis.Operations.OperationExtensions.&lt;Descendants&gt;d__3.MoveNext()
   at System.Linq.Enumerable.FirstOrDefault[TSource](IEnumerable`1 source, Func`2 predicate)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetOperationWorker(CSharpSyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetOperationCore(SyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.SemanticModel.GetOperation(SyntaxNode node, CancellationToken cancellationToken)

	at Microsoft.CodeAnalysis.ThrowingTraceListener.Fail(String message, String detailMessage)
	at System.Diagnostics.TraceListener.Fail(String message)
	at System.Diagnostics.TraceInternal.Fail(String message)
	at System.Diagnostics.Debug.Assert(Boolean condition, String message)
	at Microsoft.CodeAnalysis.SemanticModel.GetOperation(SyntaxNode node, CancellationToken cancellationToken)
	at Microsoft.CodeAnalysis.Operation.SearchParentOperation()
	at Microsoft.CodeAnalysis.Operation.get_Parent()
	at Microsoft.CodeAnalysis.Test.Utilities.CompilationExtensions.ValidateIOperations(Func`1 createCompilation)
	at Microsoft.CodeAnalysis.CSharp.Test.Utilities.CSharpTestBaseBase.CreateCompilation(IEnumerable`1 trees, IEnumerable`1 references, CSharpCompilationOptions options, String assemblyName)
	at Microsoft.CodeAnalysis.CSharp.Test.Utilities.CSharpTestBaseBase.CreateStandardCompilation(IEnumerable`1 trees, IEnumerable`1 references, CSharpCompilationOptions options, String assemblyName)
	at Microsoft.CodeAnalysis.CSharp.Test.Utilities.CSharpTestBaseBase.CreateStandardCompilation(String text, IEnumerable`1 references, CSharpCompilationOptions options, CSharpParseOptions parseOptions, String assemblyName, String sourceFileName)
	at Microsoft.CodeAnalysis.CSharp.Test.Utilities.CSharpTestBaseBase.VerifyOperationTreeAndDiagnosticsForTest[TSyntaxNode](String testSrc, String expectedOperationTree, DiagnosticDescription[] expectedDiagnostics, CSharpCompilationOptions compilationOptions, CSharpParseOptions parseOptions, MetadataReference[] additionalReferences, Action`3 additionalOperationTreeVerifier, Boolean useLatestFrameworkReferences)
	F:\GitHub\roslyn\src\Compilers\CSharp\Test\Semantic\IOperation\IOperationTests_IObjectCreationExpression.cs(644,0): at Microsoft.CodeAnalysis.CSharp.UnitTests.IOperationTests.ObjectCreationWithDynamicMemberInitializer_01()
```</Description>
        <CreatedDate>14/11/2017</CreatedDate>
        <ClosedDate>16/11/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Operations/CSharpOperationFactory.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IObjectCreationExpression.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23141</IssueID>
    <Title>Clean-up IOperation tree representing tuple literal conversions.</Title>
    <Description>Related to #22548 and #22229.

There are several issues with IOperation tree when it comes to conversions applied to tuple literals:
1. When conversion is explicitly specified in code, it is translated to conversions on individual
elements of the literal and these BoundConversion nodes are also marked as explicitly
specified in code (which makes sense). However, the syntax associated with a BoundConversion
node on top of an element matches the syntax of the element (which also makes sense).
The problem is that both the conversion node and the element appear as “explicit” in
IOperation tree, which violates one of the tree invariants – at most one “explicit” node for
a given syntax node.
2. When a tuple literal is converted, compiler creates a BoundConvertedTupleLiteral node,
which has the target tuple type as its Type, but the BoundConversion node on top of the
BoundConvertedTupleLiteral captures conversion information (kind, etc.) for conversion
From tuple’s natural type to the target type. So, often, we end up with both nodes having
The same Type, but the conversion says it is not an identity conversion. This shape helps
SemanticModel to provide accurate information about types and conversions, but the
IOperation tree looks very confusing.
3. When conversion is explicitly specified in code, the BoundConversion node from the
previous item is marked as explicitly specified in code, but it shares syntax node with
BoundConvertedTupleLiteral. Both nodes appear as “explicit” in IOperation tree, which
violates the same invariant.
4. When conversion is explicitly specified in code, compiler adds yet another explicit
Identity conversion on top of the BoundConversion node from the previous item.
It is needed for proper SemanticModel behavior. Even when it uses different syntax,
the IOperation tree looks very confusing, there are two conversions on top of each other
and it is not clear why intermediate conversion node is needed.

In order to address all these issue the following changes are made to IOperation factory:
- If conversion node is associated with the same syntax as its operand, the conversion
is marked as isImplicit.
- If Type of BoundConvertedTupleLiteral matches the Type of BoundConversion node
on top of it the conversion node is not added to the IOperation tree. Instead a new property
is added to ITupleOperation interface, called NaturalType. The property exposes the natural
type of the tuple literal and makes it easy for consumers to figure out if a conversion from
a natural type of a tuple literal took place.
-  If Type of BoundConvertedTupleLiteral doesn’t match the Type of BoundConversion node
on top of it and there is an identity conversion node on top of the BoundConversion node,
the intermediate conversion node is not added to the IOperation tree, its conversion
information is used for the top-most conversion node (instead of saying that it is identity).
</Description>
    <CreatedDate>13/11/2017</CreatedDate>
    <ClosedDate>15/11/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>22548</IssueID>
        <Title>Follow up on isImplicit mismatch </Title>
        <Description>Address feedback from https://github.com/dotnet/roslyn/pull/22309 </Description>
        <CreatedDate>05/10/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22229</IssueID>
        <Title>IsImplicit for multiple operation nodes with same syntax</Title>
        <Description>we want to make sure there is only one explicit IOperation when multiple IOperations are pointing to same syntax node.

right now, we have case such as this (https://github.com/dotnet/roslyn/pull/21857#pullrequestreview-64081939 or https://github.com/dotnet/roslyn/pull/21857#issuecomment-330950924) where InvalidExpression is pointing to same syntax node as its child. or ExpressionStatement pointing to same syntax node as its expression (ex, expression lambda body)

we need to decide whether we want to mark those as implicit or not. if we do, those IOperation will not be returned by GetOperation. but user can still get to that operation through parent and children.
</Description>
        <CreatedDate>20/09/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Operations/CSharpOperationFactory.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenDeconstructTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTupleTest.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IFieldReferenceExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IForEachLoopStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_ILocalReferenceExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IParameterReferenceExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_ITupleExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/DeconstructionTests.cs</File>
      <File>src/Compilers/Core/Portable/Generated/Operations.xml.Generated.cs</File>
      <File>src/Compilers/Core/Portable/Operations/ITupleOperation.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationCloner.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/OperationTreeVerifier.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23129</IssueID>
    <Title>Address followup nits from IOp prs.</Title>
    <Description>Fixes nits raised during review for #23041 and #22972. Fixes https://github.com/dotnet/roslyn/issues/23093.</Description>
    <CreatedDate>11/11/2017</CreatedDate>
    <ClosedDate>14/11/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>23041</IssueID>
        <Title>Compound expressions conversions</Title>
        <Description>This adds support for InConversion and OutConversion to ICompoundExpression, and adds VB support for compound expression scenarios with in and out conversions in them. Fixes https://github.com/dotnet/roslyn/issues/21738.

vso:https://devdiv.visualstudio.com/DevDiv/NET%20Developer%20Experience%20Productivity/_workitems/edit/521161</Description>
        <CreatedDate>07/11/2017</CreatedDate>
        <ClosedDate>09/11/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22972</IssueID>
        <Title>Update static instance handling</Title>
        <Description>There were a few places in IOperation error cases where we would drop receivers of static calls always, even if it was explicit. This updates our handling of receivers in both languages to only exclude implicit `this` as a receiver, as that is only ever present when the compiler optimistically generates a receiver before determining the symbol is static. I also added tests for these scenarios, as they were missing. This fixes https://github.com/dotnet/roslyn/issues/22585 and https://github.com/dotnet/roslyn/issues/22737.

vso : [link](https://devdiv.visualstudio.com/DevDiv/NET%20Developer%20Experience%20Productivity/_workitems/edit/518824)</Description>
        <CreatedDate>02/11/2017</CreatedDate>
        <ClosedDate>09/11/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_ICompoundAssignmentOperation.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/CompilationExtensions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>22553</IssueID>
    <Title>Compiler API not to return [Obsolete] for IsByRefLikeTypes</Title>
    <Description>Fixes #22450
Replaces #22504

The fix here is to stop returning [Obsolete] from compiler APIs.

@VSadov @dotnet/roslyn-compiler @dotnet/roslyn-ide for code review
@jaredpar for ask mode approval</Description>
    <CreatedDate>05/10/2017</CreatedDate>
    <ClosedDate>11/10/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>22450</IssueID>
        <Title>IDE visualizes span as [deprecated]</Title>
        <Description>![image](https://user-images.githubusercontent.com/8218165/31048319-795b052c-a5cf-11e7-91b3-bbda0edc7f12.png)

The Obsolete attributes on ref-like types are a part of compiler/runtime handshake and should not be visualized when follow the pattern.

I am not sure on what side this is - symbol display or some higher IDE level, but these obsolete should be filtered out.</Description>
        <CreatedDate>30/09/2017</CreatedDate>
        <ClosedDate>11/10/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22504</IssueID>
        <Title>Hide [deprecated] quick info on ref-like types</Title>
        <Description>Fixes #22450

@dotnet/roslyn-compiler @dotnet/roslyn-ide for code review
@gafter for API review
@jaredpar for ask mode approval</Description>
        <CreatedDate>03/10/2017</CreatedDate>
        <ClosedDate>04/10/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PENamedTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Attributes/AttributeTests_IsByRefLike.cs</File>
      <File>src/EditorFeatures/CSharpTest/QuickInfo/SemanticQuickInfoSourceTests.cs</File>
      <File>src/EditorFeatures/TestUtilities/Workspaces/TestWorkspace_XmlConsumption.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>22502</IssueID>
    <Title>Consume new editor assemblies</Title>
    <Description>Consume all the stuff in #22321 and then point to new editor packages that have the UI/UI.Wpf split that we need. This won't get merged until after #22321 is merged into master and then merged into dev15.5.x.</Description>
    <CreatedDate>03/10/2017</CreatedDate>
    <ClosedDate>16/10/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>22321</IssueID>
        <Title>Merged PR of active PRs that cause EditorFeatures API breaks</Title>
        <Description>This is a merged PR of #22105 and #21589 that will be merged at the same time so we only force partners to update for the breaks once.

**IF YOU WANT TO REVIEW THE CONTENTS OF THIS PULL REQUEST, PLEASE COMMENT IN THE PULL REQUESTS LINKED ABOVE.**</Description>
        <CreatedDate>25/09/2017</CreatedDate>
        <ClosedDate>04/10/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22321</IssueID>
        <Title>Merged PR of active PRs that cause EditorFeatures API breaks</Title>
        <Description>This is a merged PR of #22105 and #21589 that will be merged at the same time so we only force partners to update for the breaks once.

**IF YOU WANT TO REVIEW THE CONTENTS OF THIS PULL REQUEST, PLEASE COMMENT IN THE PULL REQUESTS LINKED ABOVE.**</Description>
        <CreatedDate>25/09/2017</CreatedDate>
        <ClosedDate>04/10/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder.ValueChecks.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Attributes.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Conversions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Deconstruct.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Expressions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Invocation.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Lambda.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Operators.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Patterns.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Statements.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/ForEachLoopBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/PatternSwitchBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/Conversions/Conversions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/Conversions/ConversionsBase.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/OverloadResolution/MethodTypeInference.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/OverloadResolution/OverloadResolution.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/OverloadResolution/OverloadResolutionResult.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/SubsumptionDiagnosticBuilder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/SwitchBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/OutDeconstructVarPendingInference.cs</File>
      <File>src/Compilers/CSharp/Portable/CSharpResources.Designer.cs</File>
      <File>src/Compilers/CSharp/Portable/CodeGen/EmitAddress.cs</File>
      <File>src/Compilers/CSharp/Portable/CodeGen/EmitExpression.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/CSharpCompilation.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/CSharpSemanticModel.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/ErrorCode.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/PreciseAbstractFlowPass_Switch.cs</File>
      <File>src/Compilers/CSharp/Portable/Generated/BoundNodes.xml.Generated.cs</File>
      <File>src/Compilers/CSharp/Portable/Generated/Syntax.xml.Internal.Generated.cs</File>
      <File>src/Compilers/CSharp/Portable/Generated/Syntax.xml.Main.Generated.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/AsyncRewriter/AwaitExpressionSpiller.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/IteratorRewriter/IteratorFinallyMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_Call.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_ObjectOrCollectionInitializerExpression.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_StackAlloc.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/MethodToClassRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/StateMachineRewriter/SynthesizedStateMachineProperty.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/SynthesizedMethodBaseSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/SyntheticBoundNodeFactory.cs</File>
      <File>src/Compilers/CSharp/Portable/Operations/CSharpOperationFactory.cs</File>
      <File>src/Compilers/CSharp/Portable/Operations/CSharpOperationFactory_Methods.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/LanguageParser.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/Lexer.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/SlidingTextWindow.cs</File>
      <File>src/Compilers/CSharp/Portable/SymbolDisplay/SymbolDisplayVisitor.Members.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/AnonymousTypes/SynthesizedSymbols/AnonymousType.ConstructorSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/AnonymousTypes/SynthesizedSymbols/AnonymousType.EqualsMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/AnonymousTypes/SynthesizedSymbols/AnonymousType.GetHashCodeMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/AnonymousTypes/SynthesizedSymbols/AnonymousType.PropertyAccessorSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/AnonymousTypes/SynthesizedSymbols/AnonymousType.PropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/AnonymousTypes/SynthesizedSymbols/AnonymousType.ToStringMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ErrorMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ErrorPropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PEMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PENamedTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PEParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PEPropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/MethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/NamedTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/PropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ReducedExtensionMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/RefKindExtensions.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/SignatureOnlyMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/SignatureOnlyPropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/LambdaSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/LocalFunctionSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/ModifierUtils.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/ParameterHelpers.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceConstructorSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceDelegateMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceDestructorSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceEventAccessorSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceLocalSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceMemberContainerSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceMemberMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceNamedTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceOrdinaryMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourcePropertyAccessorSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourcePropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceUserDefinedOperatorSymbolBase.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/ThisParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedDelegateSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedEntryPointSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedGlobalMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedImplementationMethod.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedInstanceConstructor.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedInteractiveInitializerMethod.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedIntrinsicOperatorSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedSealedPropertyAccessor.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedStaticConstructor.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/TypeSymbolExtensions.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Wrapped/WrappedMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Wrapped/WrappedPropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/SyntaxNodeExtensions.cs</File>
      <File>src/Compilers/CSharp/Portable/Utilities/EnumExtensions.cs</File>
      <File>src/Compilers/CSharp/Test/CommandLine/CommandLineTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Attributes/AttributeTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Attributes/AttributeTests_Embedded.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Attributes/AttributeTests_IsByRefLike.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Attributes/AttributeTests_ReadOnlyStruct.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Attributes/AttributeTests_RefReadOnly.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenConditionalOperatorTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenInParametersTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenLocalFunctionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenReadonlyStructTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenRefConditionalOperatorTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenRefReadonlyReturnTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenRefReturnTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenStructsAndEnum.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTupleTest.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/UnsafeTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Emit/CompilationEmitTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Emit/InAttributeModifierTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/PDB/PDBTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Diagnostics/OperationAnalyzerTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_ArrayCreationAndInitializer.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IAnonymousFunctionExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IArgument.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IArrayElementReferenceExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IAwaitExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IBinaryOperatorExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IConditionalAccessExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IConversionExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IDynamicIndexerAccessExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IDynamicInvocationExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IDynamicMemberReferenceExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IDynamicObjectCreationExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IEventAssignmentExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IFieldReferenceExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IFixedStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IForEachLoopStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IForLoopStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IIfStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IInstanceReferenceTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IInterpolatedStringExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IIsPatternExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IIsTypeExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_ILocalFunctionStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_ILocalReferenceExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_ILockStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IObjectCreationExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IParameterReferenceExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IPatternSwitchCase.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IPropertyReferenceExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IReturnStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_ISizeOfExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_ISymbolInitializer.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_ITupleExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_ITypeOfExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IUnaryOperatorExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IVariableDeclaration.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IWhileUntilLoopStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_InvalidExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_InvalidStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_TryCatch.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/AmbiguousOverrideTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/DynamicTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/NameOfTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/ObjectAndCollectionInitializerTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/OperatorTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/OverloadResolutionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternSwitchTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/QueryTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/RefEscapingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/RefExtensionMethodsTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/RefLocalsAndReturnsTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/SemanticErrorTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/SpanStackSafetyTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/StackAllocSpanExpressionsTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/SwitchTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/UnsafeTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/VarianceTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Compilation/GetUnusedImportDirectivesTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Compilation/SemanticModelGetDeclaredSymbolAPITests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/SymbolDisplay/SymbolDisplayTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/AnonymousTypesSemanticsTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/InterfaceOverriddenOrHiddenMembersTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/OverriddenOrHiddenMembersTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/Source/DelegateTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/Source/ExpressionBodiedPropertyTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/UserDefinedOperatorErrorTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/LexicalAndXml/LexicalTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/DeclarationParsingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/ParserErrorMessageTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/ParserRegressionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/PatternParsingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/ReadOnlyStructs.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/RefReadonlyReturnsTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/RefReadonlyTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/RefStructs.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/RoundTrippingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/ScriptParsingTests.cs</File>
      <File>src/Compilers/Core/Portable/Compilation/Compilation.cs</File>
      <File>src/Compilers/Core/Portable/Generated/Operations.xml.Generated.cs</File>
      <File>src/Compilers/Core/Portable/InternalUtilities/EnumUtilties.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IArrayElementReferenceExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/ICatchClause.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IEndStatement.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IStopStatement.cs</File>
      <File>src/Compilers/Core/Portable/Operations/ITryStatement.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationCloner.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationKind.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationVisitor.cs</File>
      <File>src/Compilers/Core/Portable/SymbolDisplay/SymbolDisplayParameterOptions.cs</File>
      <File>src/Compilers/Core/Portable/Symbols/IMethodSymbol.cs</File>
      <File>src/Compilers/Core/Portable/Symbols/IPropertySymbol.cs</File>
      <File>src/Compilers/Core/Portable/Symbols/RefKind.cs</File>
      <File>src/Compilers/Extension/CompilerPackage.cs</File>
      <File>src/Compilers/Test/Utilities/CSharp/CSharpTestBase.cs</File>
      <File>src/EditorFeatures/CSharp/CallHierarchy/CallHierarchyCommandHandler.cs</File>
      <File>src/EditorFeatures/CSharp/QuickInfo/SemanticQuickInfoProvider.cs</File>
      <File>src/EditorFeatures/CSharp/QuickInfo/SyntacticQuickInfoProvider.cs</File>
      <File>src/EditorFeatures/CSharpTest/AddAccessibilityModifiers/AddAccessibilityModifiersTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Completion/CompletionProviders/DeclarationNameCompletionProviderTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/NamingStyles/EditorConfigNamingStyleParserTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/EditAndContinue/StatementEditingTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/EditAndContinue/TopLevelEditingTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/ExtractInterface/ExtractInterfaceTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/ImplementAbstractClass/ImplementAbstractClassTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/ImplementInterface/ImplementInterfaceTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/QuickInfo/SemanticQuickInfoSourceTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/QuickInfo/SyntacticQuickInfoSourceTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseLocalFunction/UseLocalFunctionTests.cs</File>
      <File>src/EditorFeatures/CSharpTest2/Recommendations/InKeywordRecommenderTests.cs</File>
      <File>src/EditorFeatures/CSharpTest2/Recommendations/OutKeywordRecommenderTests.cs</File>
      <File>src/EditorFeatures/CSharpTest2/Recommendations/ReadOnlyKeywordRecommenderTests.cs</File>
      <File>src/EditorFeatures/CSharpTest2/Recommendations/RefKeywordRecommenderTests.cs</File>
      <File>src/EditorFeatures/CSharpTest2/Recommendations/ThisKeywordRecommenderTests.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Adornments/AbstractAdornmentManagerProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Adornments/AdornmentManager.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Adornments/GraphicsResult.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Adornments/GraphicsTag.cs</File>
      <File>src/EditorFeatures/Core.Wpf/BraceMatching/ClassificationTypeFormatDefinitions.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Classification/ClassificationTypeFormatDefinitions.cs</File>
      <File>src/EditorFeatures/Core.Wpf/CodeAnalysisColors.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Completion/Presentation/ClassificationTags.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Completion/Presentation/CompletionPresenter.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Completion/Presentation/CompletionPresenterSession.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Completion/Presentation/CompletionSource.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Completion/Presentation/CustomCommitCompletion.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Completion/Presentation/ImageMonikers.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Completion/Presentation/RoslynCompletionSet.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Completion/Presentation/RoslynIntellisenseFilter.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Completion/Presentation/ToolTipProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/ConflictTagDefinition.cs</File>
      <File>src/EditorFeatures/Core.Wpf/DependencyObjectExtensions.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Diagnostics/UnnecessaryCodeFormatDefinition.cs</File>
      <File>src/EditorFeatures/Core.Wpf/EditAndContinue/ActiveStatementTagFormatDefinition.cs</File>
      <File>src/EditorFeatures/Core.Wpf/EditAndContinue/EditAndContinueErrorTypeFormatDefinition.cs</File>
      <File>src/EditorFeatures/Core.Wpf/IWpfDifferenceViewerExtensions.cs</File>
      <File>src/EditorFeatures/Core.Wpf/IWpfTextViewExtensions.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/AbstractEditorInlineRenameService.FailureInlineRenameInfo.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/AbstractEditorInlineRenameService.InlineRenameLocationSet.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/AbstractEditorInlineRenameService.InlineRenameReplacementInfo.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/AbstractEditorInlineRenameService.SymbolRenameInfo.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/AbstractEditorInlineRenameService.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/AbstractInlineRenameUndoManager.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/CSharpEditorInlineRenameService.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/CommandHandlers/RenameCommandHandler.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/CommandHandlers/RenameCommandHandler_BackspaceDeleteHandler.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/CommandHandlers/RenameCommandHandler_CutPasteHandler.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/CommandHandlers/RenameCommandHandler_EscapeHandler.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/CommandHandlers/RenameCommandHandler_LineStartEndHandler.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/CommandHandlers/RenameCommandHandler_MoveSelectedLinesHandler.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/CommandHandlers/RenameCommandHandler_OpenLineAboveHandler.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/CommandHandlers/RenameCommandHandler_OpenLineBelowHandler.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/CommandHandlers/RenameCommandHandler_RefactoringWithCommandHandler.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/CommandHandlers/RenameCommandHandler_RenameHandler.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/CommandHandlers/RenameCommandHandler_ReturnHandler.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/CommandHandlers/RenameCommandHandler_SaveHandler.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/CommandHandlers/RenameCommandHandler_SelectAllHandler.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/CommandHandlers/RenameCommandHandler_TabHandler.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/CommandHandlers/RenameCommandHandler_TypeCharHandler.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/CommandHandlers/RenameCommandHandler_UndoRedoHandler.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/CommandHandlers/RenameCommandHandler_WordDeleteHandler.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/Dashboard/Dashboard.xaml.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/Dashboard/DashboardAdornmentManager.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/Dashboard/DashboardAdornmentProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/Dashboard/DashboardAutomationPeer.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/Dashboard/DashboardSeverity.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/Dashboard/DashboardViewModel.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/Dashboard/RenameShortcutKeys.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/HighlightTags/RenameConflictTag.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/HighlightTags/RenameConflictTagDefinition.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/HighlightTags/RenameFieldBackgroundAndBorderTag.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/HighlightTags/RenameFieldBackgroundAndBorderTagDefinition.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/HighlightTags/RenameFixupTag.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/HighlightTags/RenameFixupTagDefinition.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/IInlineRenameUndoManager.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/InlineRenameService.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/InlineRenameSession.OpenTextBufferManager.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/InlineRenameSession.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/RenameLogMessage.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/RenameTrackingSpan.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/Taggers/AbstractRenameTagger.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/Taggers/ClassificationTypeDefinitions.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/Taggers/RenameClassificationTagger.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/Taggers/RenameClassificationTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/Taggers/RenameTagger.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/Taggers/RenameTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/TrackingSpanIntrospector.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/UndoManagerServiceFactory.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/VisualBasicEditorInlineRenameService.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Interactive/InteractivePasteCommandHandler.cs</File>
      <File>src/EditorFeatures/Core.Wpf/LineSeparators/EditorFormatMapChangedEventSource.cs</File>
      <File>src/EditorFeatures/Core.Wpf/LineSeparators/LineSeparatorAdornmentManagerProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/LineSeparators/LineSeparatorTag.cs</File>
      <File>src/EditorFeatures/Core.Wpf/LineSeparators/LineSeparatorTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/NavigateTo/DefaultNavigateToPreviewService.cs</File>
      <File>src/EditorFeatures/Core.Wpf/NavigateTo/DefaultNavigateToPreviewServiceFactory.cs</File>
      <File>src/EditorFeatures/Core.Wpf/NavigateTo/INavigateToPreviewService.cs</File>
      <File>src/EditorFeatures/Core.Wpf/NavigateTo/NavigateToItemDisplay.cs</File>
      <File>src/EditorFeatures/Core.Wpf/NavigateTo/NavigateToItemDisplayFactory.cs</File>
      <File>src/EditorFeatures/Core.Wpf/NavigateTo/NavigateToItemProvider.Searcher.cs</File>
      <File>src/EditorFeatures/Core.Wpf/NavigateTo/NavigateToItemProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/NavigateTo/NavigateToItemProviderFactory.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Notification/EditorNotificationServiceFactory.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Preview/AbstractPreviewTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Preview/DifferenceViewerPreview.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Preview/PreviewConflictViewTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Preview/PreviewFactoryService.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Preview/PreviewReferenceHighlightingTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Preview/PreviewWarningViewTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/PreviewWarningTagDefinition.cs</File>
      <File>src/EditorFeatures/Core.Wpf/QuickInfo/Converters/ClassifiableDeferredContentConverter.cs</File>
      <File>src/EditorFeatures/Core.Wpf/QuickInfo/Converters/DocumentationCommentDeferredContentConverter.cs</File>
      <File>src/EditorFeatures/Core.Wpf/QuickInfo/Converters/IDeferredQuickInfoContentToFrameworkElementConverter.cs</File>
      <File>src/EditorFeatures/Core.Wpf/QuickInfo/Converters/ProjectionBufferDeferredContentConverter.cs</File>
      <File>src/EditorFeatures/Core.Wpf/QuickInfo/Converters/QuickInfoDisplayDeferredContentConverter.cs</File>
      <File>src/EditorFeatures/Core.Wpf/QuickInfo/Converters/SymbolGlyphDeferredContentConverter.cs</File>
      <File>src/EditorFeatures/Core.Wpf/QuickInfo/DeferredContentFrameworkElementFactory.cs</File>
      <File>src/EditorFeatures/Core.Wpf/QuickInfo/Presentation/QuickInfoPresenter.QuickInfoPresenterSession.cs</File>
      <File>src/EditorFeatures/Core.Wpf/QuickInfo/Presentation/QuickInfoPresenter.QuickInfoSource.cs</File>
      <File>src/EditorFeatures/Core.Wpf/QuickInfo/Presentation/QuickInfoPresenter.cs</File>
      <File>src/EditorFeatures/Core.Wpf/QuickInfo/QuickInfoDisplayPanel.cs</File>
      <File>src/EditorFeatures/Core.Wpf/ReferenceHighlighting/DefinitionHighlightTagDefinition.cs</File>
      <File>src/EditorFeatures/Core.Wpf/ReferenceHighlighting/WrittenReferenceHighlightTagDefinition.cs</File>
      <File>src/EditorFeatures/Core.Wpf/RenameTracking/RenameTrackingTagDefinition.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Structure/AbstractStructureTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Structure/BlockContextProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Structure/BlockTagState.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Structure/InvalidOutliningRegionException.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Structure/OutliningCommandHandler.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Structure/RoslynBlockTag.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Structure/RoslynOutliningRegionTag.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Structure/VisualStudio14StructureTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Structure/VisualStudio15StructureTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/ViewHostingControl.cs</File>
      <File>src/EditorFeatures/Core.Wpf/WpfClassificationExtensions.cs</File>
      <File>src/EditorFeatures/Core/Extensibility/QuickInfo/IDeferredQuickInfoContent.cs</File>
      <File>src/EditorFeatures/Core/Implementation/BraceMatching/ClassificationTypeDefinitions.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Classification/ClassificationTypeDefinitions.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Diagnostics/ClassificationTypeDefinitions.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Diagnostics/DiagnosticsClassificationTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Diagnostics/DiagnosticsSuggestionTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/EditAndContinue/EditAndContinueErrorTypeDefinition.cs</File>
      <File>src/EditorFeatures/Core/Implementation/ITextBufferAssociatedViewService.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/QuickInfo/DeferredContent/ClassifiableDeferredContent.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/QuickInfo/DeferredContent/ProjectionBufferDeferredContent.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/QuickInfo/DeferredContent/QuickInfoDisplayDeferredContent.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/QuickInfo/DeferredContent/SymbolGlyphDeferredContent.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/QuickInfo/Providers/AbstractQuickInfoProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/QuickInfo/Providers/AbstractSemanticQuickInfoProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/QuickInfo/Providers/DocumentationCommentDeferredContent.cs</File>
      <File>src/EditorFeatures/Core/Implementation/SolutionPreviewItem.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Suggestions/SuggestedActions/SuggestedAction.CaretPositionRestorer.cs</File>
      <File>src/EditorFeatures/Core/Implementation/TextBufferAssociatedViewService.cs</File>
      <File>src/EditorFeatures/Core/Shared/Extensions/ClassificationExtensions.cs</File>
      <File>src/EditorFeatures/Core/Shared/Extensions/GlyphExtensions.cs</File>
      <File>src/EditorFeatures/Core/Shared/Extensions/ISymbolExtensions.cs</File>
      <File>src/EditorFeatures/Core/Shared/Tagging/EventSources/TaggerEventSources.EditorFormatMapChangedEventSource.cs</File>
      <File>src/EditorFeatures/Core/Shared/Tagging/EventSources/TaggerEventSources.cs</File>
      <File>src/EditorFeatures/Core/Shared/Utilities/ClassificationTypeMap.cs</File>
      <File>src/EditorFeatures/Core/Shared/Utilities/ForegroundThreadAffinitizedObject.cs</File>
      <File>src/EditorFeatures/Core/Shared/Utilities/HighContrastChecker.cs</File>
      <File>src/EditorFeatures/Test/CodeGeneration/CodeGenerationTests.cs</File>
      <File>src/EditorFeatures/Test/TextEditor/TextBufferAssociatedViewServiceTests.cs</File>
      <File>src/EditorFeatures/TestUtilities/CallHierarchy/CallHierarchyTestState.cs</File>
      <File>src/EditorFeatures/TestUtilities/Diagnostics/DiagnosticTaggerWrapper.cs</File>
      <File>src/EditorFeatures/TestUtilities/MinimalTestExportProvider.cs</File>
      <File>src/EditorFeatures/TestUtilities/QuickInfo/AbstractSemanticQuickInfoSourceTests.cs</File>
      <File>src/EditorFeatures/TestUtilities/ServiceTestExportProvider.cs</File>
      <File>src/EditorFeatures/TestUtilities/Threading/WpfTestCase.cs</File>
      <File>src/EditorFeatures/TestUtilities/Workspaces/TestWorkspaceFixture.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Source/ExpressionCompiler/Symbols/EEMethodSymbol.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Source/ExpressionCompiler/Symbols/PlaceholderMethodSymbol.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Source/ExpressionCompiler/Symbols/SynthesizedContextMethodSymbol.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Test/ExpressionCompiler/ExpressionCompilerTests.cs</File>
      <File>src/Features/CSharp/Portable/Completion/CompletionProviders/DeclarationNameCompletionProvider.cs</File>
      <File>src/Features/CSharp/Portable/Completion/KeywordRecommenders/InKeywordRecommender.cs</File>
      <File>src/Features/CSharp/Portable/Completion/KeywordRecommenders/ReadOnlyKeywordRecommender.cs</File>
      <File>src/Features/CSharp/Portable/DesignerAttributes/CSharpDesignerAttributeService.cs</File>
      <File>src/Features/CSharp/Portable/EditAndContinue/CSharpEditAndContinueAnalyzer.cs</File>
      <File>src/Features/CSharp/Portable/ExtractMethod/CSharpMethodExtractor.CSharpCodeGenerator.cs</File>
      <File>src/Features/CSharp/Portable/GenerateMember/GenerateParameterizedMember/CSharpGenerateConversionService.cs</File>
      <File>src/Features/CSharp/Portable/GenerateMember/GenerateParameterizedMember/CSharpGenerateParameterizedMemberService.cs</File>
      <File>src/Features/CSharp/Portable/GenerateType/CSharpGenerateTypeService.cs</File>
      <File>src/Features/CSharp/Portable/UseLocalFunction/CSharpUseLocalFunctionCodeFixProvider.cs</File>
      <File>src/Features/Core/Portable/Completion/CompletionOptions.cs</File>
      <File>src/Features/Core/Portable/Completion/Providers/AbstractPartialMethodCompletionProvider.cs</File>
      <File>src/Features/Core/Portable/DesignerAttributes/AbstractDesignerAttributeService.cs</File>
      <File>src/Features/Core/Portable/DesignerAttributes/DesignerAttributeDocumentData.cs</File>
      <File>src/Features/Core/Portable/DesignerAttributes/DesignerAttributeProjectData.cs</File>
      <File>src/Features/Core/Portable/DesignerAttributes/DesignerAttributeResult.cs</File>
      <File>src/Features/Core/Portable/DesignerAttributes/IDesignerAttributeService.cs</File>
      <File>src/Features/Core/Portable/DesignerAttributes/IRemoteDesignerAttributeService.cs</File>
      <File>src/Features/Core/Portable/EncapsulateField/AbstractEncapsulateFieldService.cs</File>
      <File>src/Features/Core/Portable/ExtractInterface/AbstractExtractInterfaceService.cs</File>
      <File>src/Features/Core/Portable/GenerateMember/GenerateParameterizedMember/AbstractGenerateMethodService.State.cs</File>
      <File>src/Features/Core/Portable/GenerateMember/GenerateParameterizedMember/AbstractGenerateParameterizedMemberService.MethodSignatureInfo.cs</File>
      <File>src/Features/Core/Portable/GenerateMember/GenerateParameterizedMember/AbstractGenerateParameterizedMemberService.SignatureInfo.cs</File>
      <File>src/Features/Core/Portable/GenerateMember/GenerateVariable/AbstractGenerateVariableService.CodeAction.cs</File>
      <File>src/Features/Core/Portable/GenerateType/AbstractGenerateTypeService.GenerateNamedType.cs</File>
      <File>src/Features/Core/Portable/InitializeParameter/AbstractInitializeMemberFromParameterCodeRefactoringProviderMemberCreation.cs</File>
      <File>src/Features/Core/Portable/MetadataAsSource/AbstractMetadataAsSourceService.WrappedMethodSymbol.cs</File>
      <File>src/Features/Core/Portable/MetadataAsSource/AbstractMetadataAsSourceService.WrappedPropertySymbol.cs</File>
      <File>src/Features/Core/Portable/SolutionCrawler/SolutionCrawlerRegistrationService.cs</File>
      <File>src/Features/Core/Portable/SolutionCrawler/State/AbstractAnalyzerState.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/OperationTreeVerifier.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/TestOperationWalker.cs</File>
      <File>src/VisualStudio/CSharp/Impl/CSharpVSResources.Designer.cs</File>
      <File>src/VisualStudio/CSharp/Impl/CodeModel/CSharpCodeModelService.cs</File>
      <File>src/VisualStudio/CSharp/Impl/EventHookup/EventHookupCommandHandler.cs</File>
      <File>src/VisualStudio/CSharp/Impl/EventHookup/EventHookupCommandHandler_SessionCancellingCommands.cs</File>
      <File>src/VisualStudio/CSharp/Impl/EventHookup/EventHookupCommandHandler_ShadowedCommands.cs</File>
      <File>src/VisualStudio/CSharp/Impl/EventHookup/EventHookupCommandHandler_TabKeyCommand.cs</File>
      <File>src/VisualStudio/CSharp/Impl/EventHookup/EventHookupCommandHandler_TypeCharCommand.cs</File>
      <File>src/VisualStudio/CSharp/Impl/EventHookup/EventHookupQuickInfoSource.cs</File>
      <File>src/VisualStudio/CSharp/Impl/EventHookup/EventHookupQuickInfoSourceProvider.cs</File>
      <File>src/VisualStudio/CSharp/Impl/EventHookup/EventHookupSessionManager.cs</File>
      <File>src/VisualStudio/CSharp/Impl/EventHookup/EventHookupSessionManager_EventHookupSession.cs</File>
      <File>src/VisualStudio/CSharp/Impl/EventHookup/IHACK_EventHookupDismissalOnBufferChangePreventerService.cs</File>
      <File>src/VisualStudio/CSharp/Impl/Options/IntelliSenseOptionPageControl.xaml.cs</File>
      <File>src/VisualStudio/CSharp/Impl/Options/IntelliSenseOptionPageStrings.cs</File>
      <File>src/VisualStudio/CSharp/Test/CallHierarchy/CSharpCallHierarchyTests.cs</File>
      <File>src/VisualStudio/CSharp/Test/EventHookup/EventHookupCommandHandlerTests.cs</File>
      <File>src/VisualStudio/CSharp/Test/EventHookup/EventHookupTestState.cs</File>
      <File>src/VisualStudio/CSharp/Test/GlyphExtensionsTests.cs</File>
      <File>src/VisualStudio/CSharp/Test/Interactive/InteractiveWindowTestHost.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/CallHierarchy/CallHierarchyCommandHandler.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/CallHierarchy/CallHierarchyDetail.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/CallHierarchy/CallHierarchyItem.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/CallHierarchy/CallHierarchyProvider.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/CallHierarchy/FieldInitializerItem.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/CallHierarchy/Finders/AbstractCallFinder.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/CallHierarchy/Finders/BaseMemberFinder.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/CallHierarchy/Finders/CallToOverrideFinder.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/CallHierarchy/Finders/FieldReferenceFinder.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/CallHierarchy/Finders/ImplementerFinder.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/CallHierarchy/Finders/InterfaceImplementationCallFinder.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/CallHierarchy/Finders/MethodCallFinder.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/CallHierarchy/Finders/OverridingMemberFinder.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/CallHierarchy/ICallHierarchyPresenter.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ChangeSignature/ChangeSignatureDialogViewModel.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ChangeSignature/VisualStudioChangeSignatureOptionsService.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/DesignerAttribute/DesignerAttributeIncrementalAnalyzer.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/DesignerAttribute/DesignerAttributeState.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ExtractInterface/ExtractInterfaceDialogViewModel.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/FindReferences/Entries/AbstractDocumentSpanEntry.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/FindReferences/Entries/DefinitionItemEntry.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/FindReferences/Entries/DocumentSpanEntry.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/FindReferences/RoslynDefinitionBucket.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/FindReferences/StreamingFindUsagesPresenter.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Interactive/IAbstractResetInteractiveCommand.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/LanguageService/AbstractPackage.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Library/ObjectBrowser/Lists/SymbolListItem.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/PickMembers/PickMembersDialogViewModel.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Preview/TopLevelChange.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Utilities/GlyphExtensions.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Venus/ContainedLanguageCodeSupport.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Watson/WatsonReporter.cs</File>
      <File>src/VisualStudio/Core/Impl/CodeModel/AbstractCodeModelObject_CodeGen.cs</File>
      <File>src/VisualStudio/Core/Test.Next/Services/ServiceHubServicesTests.cs</File>
      <File>src/VisualStudio/Razor/RazorLangaugeServiceClient.cs</File>
      <File>src/VisualStudio/Razor/RazorLanguageServiceClientFactory.cs</File>
      <File>src/VisualStudio/Setup/AssemblyRedirects.cs</File>
      <File>src/Workspaces/CSharp/Portable/CodeGeneration/CSharpSyntaxGenerator.cs</File>
      <File>src/Workspaces/CSharp/Portable/CodeGeneration/MethodGenerator.cs</File>
      <File>src/Workspaces/CSharp/Portable/CodeGeneration/ParameterGenerator.cs</File>
      <File>src/Workspaces/CSharp/Portable/CodeGeneration/PropertyGenerator.cs</File>
      <File>src/Workspaces/CSharp/Portable/Extensions/ContextQuery/SyntaxTreeExtensions.cs</File>
      <File>src/Workspaces/CSharp/Portable/Extensions/ITypeSymbolExtensions.cs</File>
      <File>src/Workspaces/CSharp/Portable/Extensions/TypeSyntaxExtensions.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/CodeGenerationSymbolFactory.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/Symbols/CodeGenerationAbstractMethodSymbol.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/Symbols/CodeGenerationConstructedMethodSymbol.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/Symbols/CodeGenerationConstructorSymbol.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/Symbols/CodeGenerationConversionSymbol.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/Symbols/CodeGenerationDestructorSymbol.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/Symbols/CodeGenerationMethodSymbol.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/Symbols/CodeGenerationOperatorSymbol.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/Symbols/CodeGenerationPropertySymbol.cs</File>
      <File>src/Workspaces/Core/Portable/Editing/DeclarationModifiers.cs</File>
      <File>src/Workspaces/Core/Portable/NamingStyles/EditorConfig/EditorConfigNamingStyleParser.cs</File>
      <File>src/Workspaces/Core/Portable/Shared/Extensions/ICodeDefinitionFactoryExtensions_CreateEqualsMethod.cs</File>
      <File>src/Workspaces/Core/Portable/Shared/Extensions/ICodeDefinitionFactoryExtensions_CreateGetHashCodeMethod.cs</File>
      <File>src/Workspaces/Core/Portable/Shared/Extensions/IMethodSymbolExtensions.cs</File>
      <File>src/Workspaces/Core/Portable/Shared/Extensions/IParameterSymbolExtensions.cs</File>
      <File>src/Workspaces/Core/Portable/Shared/Extensions/IPropertySymbolExtensions.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/Solution/ProjectState.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/Solution/ProjectState_Checksum.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/Solution/StateChecksums.cs</File>
      <File>src/Workspaces/Remote/Core/Services/SolutionCreator.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Services/CodeAnalysisService_DesignerAttributes.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Services/CodeAnalysisService_TodoComments.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Shared/RoslynJsonConverter.RoslynOnly.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>22479</IssueID>
    <Title>Add IOperation API for deconstruction assignment expression and declaration expression.</Title>
    <Description>IOperation APIs exposed by this PR:
```
namespace Microsoft.CodeAnalysis.Semantics
{
    /// &lt;summary&gt;
    /// Represents a declaration expression in C#.
    /// Unlike a regular variable declaration, this operation represents an "expression" declaring a variable.
    /// For example,
    ///   1. "var (x, y)" is a deconstruction declaration expression with variables x and y.
    ///   2. "(var x, var y)" is a tuple expression with two declaration expressions.
    ///   3. "M(out var x);" is an invocation expression with an out "var x" declaration expression.
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;
    /// This interface is reserved for implementation by its associated APIs. We reserve the right to
    /// change it in the future.
    /// &lt;/remarks&gt;
    public interface IDeclarationExpression : IOperation
    {
        /// &lt;summary&gt;
        /// Underlying expression.
        /// &lt;/summary&gt;
        IOperation Expression { get; }
    }
}

namespace Microsoft.CodeAnalysis.Semantics
{
    /// &lt;summary&gt;
    /// Represents a deconstruction assignment expression.
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;
    /// This interface is reserved for implementation by its associated APIs. We reserve the right to
    /// change it in the future.
    /// &lt;/remarks&gt;
    public interface IDeconstructionAssignmentExpression : IAssignmentExpression
    {
    }
}

```

Fixes #19924

For IOperation v1, we have decided to expose deconstruction assignment with regular conversion data. In v2, we will expose richer API with deconstruction method and also match language specification on whether this is exposed as a conversion or not. This is tracked with #22477.
</Description>
    <CreatedDate>03/10/2017</CreatedDate>
    <ClosedDate>13/10/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>19924</IssueID>
        <Title>IOperation API for BoundDeconstructionAssignmentOperator</Title>
        <Description>Two possible approaches:

1. Expose it as an IAssignmentExpression, where left and right are IOperations.
2. Introduce a new type with more strongly typed left and right child nodes:

```
    public interface IDeconstructionAssignmentExpression : IOperation
    {
        ITupleExpression Left { get; }
        IConversionExpression Right { get; }
    }
```</Description>
        <CreatedDate>31/05/2017</CreatedDate>
        <ClosedDate>13/10/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22477</IssueID>
        <Title>Expose richer desconstruction assignment/conversion info in IOperation v2</Title>
        <Description>
        </Description>
        <CreatedDate>03/10/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Operations/CSharpOperationFactory.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IFieldReferenceExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IForEachLoopStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IForLoopStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IIfStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_ILocalReferenceExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IParameterReferenceExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_ITupleExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IWhileUntilLoopStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/DeconstructionTests.cs</File>
      <File>src/Compilers/Core/Portable/Generated/Operations.xml.Generated.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IDeclarationExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IDeconstructionAssignmentExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationCloner.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationKind.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationVisitor.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/OperationTreeVerifier.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>22470</IssueID>
    <Title>Add regression tests for fixed local function crashes</Title>
    <Description>This is a test-only change.

Fixes #21768
Fixes #22027
</Description>
    <CreatedDate>02/10/2017</CreatedDate>
    <ClosedDate>04/10/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>21768</IssueID>
        <Title>Compiler crash (exit code -1) when using local functions</Title>
        <Description>The following code crashes VBCSCompiler.exe as well as csc.exe when building using Visual Studio 2017 15.3.2 on Windows 7: 

        void Function(int someField) //necessary to have a parameter
        {
            using (IInterface db = null) //necessary to have this using statement
            {
                void LocalFunction() //necessary
                {
                    var results =
                        db.Query&lt;Class1&gt;() //need to call this method. using a constant array does not reproduce the bug.
                        .Where(cje =&gt; cje.SomeField &gt;= someField) //need expression tree here referencing parameter
                        ;
                }
            }
        }
        interface IInterface : IDisposable
        {
            IQueryable&lt;T&gt; Query&lt;T&gt;();
        }
        class Class1
        {
            public int SomeField { get; set; }
        }

Quite a few components are needed to reproduce this bug.</Description>
        <CreatedDate>28/08/2017</CreatedDate>
        <ClosedDate>04/10/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22027</IssueID>
        <Title>CSC.exe exits with code -2146232797 in strange cases where local function declared in an inner scope calling another local function</Title>
        <Description>**Version Used**: 
VS 2017 .Net 4.6.2
C# Compiler version 2.3.2.61928 (ec1cde8b)

**Steps to Reproduce**:
1. CSC exits when compiling 
 class Program
    {
        static void Main(string[] args)
        {
            
        }
        public object TestLocalFn(object inp)
        {
            try
            {
                var sr = new object();
                return sr;
                void Local1()
                {
                    var copy = inp;
                    Local2();
                }
                void Local2()
                {

                }
            }
            catch { throw; }
        }
    }
2. Working case 1

 class Program
    {
        static void Main(string[] args)
        {
            
        }
        public object TestLocalFn(object inp)
        {
            try
            {
                var sr = new object();
                return sr;
                void Local1()
                {
                    //var copy = inp;  //removing this line it works
                    Local2();
                }
                void Local2()
                {

                }
            }
            catch { throw; }
        }
    }
3. everything works if not scoped

    class Program
    {
        static void Main(string[] args)
        {

        }
        public object TestLocalFn(object inp)
        {

            var sr = new object();
            return sr;
            void Local1()
            {
                var copy = inp;
                Local2();
            }
            void Local2()
            {

            }

        }
    }
</Description>
        <CreatedDate>11/09/2017</CreatedDate>
        <ClosedDate>04/10/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenLocalFunctionTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>22468</IssueID>
    <Title>workaround NamedPipeClientStream bug where it will spin wait connection to be established consuming 100% of CPU.</Title>
    <Description>workaround is barrowed from service hub -
http://index/?query=NamedPipeClientStream&amp;rightProject=Microsoft.ServiceHub.Client&amp;file=NamedPipeClientStreamExtensions.cs&amp;line=15

also made servicehub to use merged cancellation token as workaround for Microsoft/vs-streamjsonrpc#64

.....................

**Customer scenario**

User starts to use Roslyn (C# or VB projects). after for a while, ServiceHub.RoslynCodeAnalysis32.exe process starts to consume a lot of CPU and ends up consuming 100% of it all the time.

**Bugs this fixes:**

https://devdiv.visualstudio.com/DevDiv/_workitems/edit/503885

**Workarounds, if any**

There is no workaround.

**Risk**

I don't see any risk.

**Performance impact**

this should make perf same as before by cancelling operation correctly.

**Is this a regression from a previous update?**

Yes. this regressed when we moved to new cancellation support from StreamJsonRpc. missed some subtle cancellation issue when cancellation and disconnection happens right after each other. 

in previous version (15.4.x), we used our own mechanism for cancellation which didn't have this issue. moving to new native cancellation support helped us to reuse same connection improving perf, but caused us to regress cancellation support.

**Root cause analysis:**

when cancellation is raised in VS and connection is closed right away, cancellation sometimes doesn't get raised in service hub side. just disconnection happens. and service in service hub side doesn't know it has been cancelled. and keep doing what it was doing. that combined with NamedPipeClientStream.ConnectAsync issue (https://github.com/dotnet/corefx/issues/7635), it ends up consuming 100% cpu waiting pipe that already gone.

more detail is on Microsoft/vs-streamjsonrpc#64.

**How was the bug found?**

Dogfooding.
</Description>
    <CreatedDate>02/10/2017</CreatedDate>
    <ClosedDate>04/10/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>64</IssueID>
        <Title>API Request: TypeSymbolExtensions </Title>
        <Description>Forking this feature request from #16 

Original post: https://github.com/dotnet/roslyn/issues/16#issuecomment-70846421 by @MrJul

Pertinent APIs: http://source.roslyn.codeplex.com/#Microsoft.CodeAnalysis.CSharp/Symbols/TypeSymbolExtensions.cs,8f632696b9da5eba

In my team, I've seen different developers copy-paste portions of ITypeSymbolExtensions into our own project (e.g. `IsNullableType`, `GetNullableUnderlyingType` , `GetBaseTypes` ), which is a shame - these methods are a convenience I'm sure many other people will find useful as well.
</Description>
        <CreatedDate>24/01/2015</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>64</IssueID>
        <Title>API Request: TypeSymbolExtensions </Title>
        <Description>Forking this feature request from #16 

Original post: https://github.com/dotnet/roslyn/issues/16#issuecomment-70846421 by @MrJul

Pertinent APIs: http://source.roslyn.codeplex.com/#Microsoft.CodeAnalysis.CSharp/Symbols/TypeSymbolExtensions.cs,8f632696b9da5eba

In my team, I've seen different developers copy-paste portions of ITypeSymbolExtensions into our own project (e.g. `IsNullableType`, `GetNullableUnderlyingType` , `GetBaseTypes` ), which is a shame - these methods are a convenience I'm sure many other people will find useful as well.
</Description>
        <CreatedDate>24/01/2015</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Workspaces/Remote/ServiceHub/Services/CodeAnalysisService_AddImport.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Services/CodeAnalysisService_CodeLens.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Services/CodeAnalysisService_DesignerAttributes.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Services/CodeAnalysisService_Diagnostics.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Services/CodeAnalysisService_DocumentHighlights.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Services/CodeAnalysisService_NavigateTo.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Services/CodeAnalysisService_SymbolFinder.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Services/CodeAnalysisService_TodoComments.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Services/RemoteHostService.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Services/RemoteSymbolSearchUpdateEngine.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Services/SnapshotService.JsonRpcAssetSource.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Shared/ClientDirectStream.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Shared/ServiceHubServiceBase.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>22243</IssueID>
    <Title>Add IRaiseEventStatement operation for VB</Title>
    <Description>```cs
public interface IRaiseEventStatement : IHasArguments
{
    /// &lt;summary&gt;
    /// Reference to the event to be raised.
    /// &lt;/summary&gt;
    IEventReferenceExpression EventReference { get; }
}
```
Note that to accommodate this change, I also changed `IHasArgumentsExpression` to `IHasArguments`.

Fix #8567 and #8345</Description>
    <CreatedDate>21/09/2017</CreatedDate>
    <ClosedDate>06/10/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>8567</IssueID>
        <Title>Raising-event should be an independent `IOperation`</Title>
        <Description>Right now it is represented as method invocation.

Proposals:

```cs
public interface IRaiseEventExpression : IHasArgumentsExpression
{
    /// &lt;summary&gt;
    /// Reference to the event to be raised.
    /// &lt;/summary&gt;
    IEventReferenceExpression EventReference { get; }
}
```

or

```cs
public interface IRaiseEventExpression : IHasArgumentsExpression
{
    /// &lt;summary&gt;
    /// Referenced event.
    /// &lt;/summary&gt;
    IEventSymbol Event { get; }

    IOperation Instance { get; }
}
```</Description>
        <CreatedDate>10/02/2016</CreatedDate>
        <ClosedDate>06/10/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>8345</IssueID>
        <Title>Raise event in VB should represented by an EventReferenceExepression operation</Title>
        <Description>For this code snippet:

``` vb
RaiseEvent Mumble(Me, args)
```

There should be an EventReferenceExpression for `Mumble`, but currently it is return a FieldReferenceExpression instead.

There's a testcase `EventAndMethodReferencesVisualBasic` for this bug:
src\compilers\visualbasic\test\semantic\diagnostics\operationanalyzertests.vb
</Description>
        <CreatedDate>02/02/2016</CreatedDate>
        <ClosedDate>06/10/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IEventAssignmentExpression.cs</File>
      <File>src/Compilers/Core/Portable/Generated/Operations.xml.Generated.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IHasArguments.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IInvocationExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IObjectCreationExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IPropertyReferenceExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IRaiseEventExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationCloner.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationKind.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationVisitor.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/OperationTreeVerifier.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>22220</IssueID>
    <Title>IntroduceField code action should remove trivia as the other IntroduceVariable actions do.</Title>
    <Description>**Customer scenario**

From #21747.

&gt; CSharpIntroduceVariableService.IntroduceFieldAsync doesn't drop leading and trailing trivia the way IntroduceLocalAsync does (i.e. expression.WithoutTrailingTrivia().WithoutLeadingTrivia()). As a result, the trivia appear in both the initializer of the newly-created field and at its use-site.

&gt; I didn't check VB.

I also looked at the VB implementation and there it should be fine and covered by tests:

* Code: [`VisualBasicIntroduceVariableService.CreateFieldDeclaration`](https://github.com/dotnet/roslyn/blob/6847f1e5a909395aae9456e8f366cbf4deb86b69/src/Features/VisualBasic/Portable/IntroduceVariable/VisualBasicIntroduceVariableService_IntroduceField.vb#L198)
* Test: [`IntroduceVariableTests.TestIntroduceFieldWithTrailingTrivia`](https://github.com/dotnet/roslyn/blob/b57c9b1ebc7ad6eaabe4b8ea8fb37f9898a86325/src/EditorFeatures/VisualBasicTest/CodeActions/IntroduceVariable/IntroduceVariableTests.vb#L753)

**Bugs this fixes:**

#21747

**Workarounds, if any**

None.

**Risk**

Low.

**Performance impact**

Low.

**Is this a regression from a previous update?**

No.

**Root cause analysis:**

Wasn't covered by tests.

**How was the bug found?**

Reported by @amcasey 

**Test documentation updated?**

No.</Description>
    <CreatedDate>20/09/2017</CreatedDate>
    <ClosedDate>09/10/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>21747</IssueID>
        <Title>CSharpIntroduceVariableService.IntroduceFieldAsync doesn't drop leading and trailing trivia</Title>
        <Description>...the way IntroduceLocalAsync does (i.e. `expression.WithoutTrailingTrivia().WithoutLeadingTrivia()`).  As a result, the trivia appear in both the initializer of the newly-created field and at its use-site.</Description>
        <CreatedDate>25/08/2017</CreatedDate>
        <ClosedDate>09/10/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>21747</IssueID>
        <Title>CSharpIntroduceVariableService.IntroduceFieldAsync doesn't drop leading and trailing trivia</Title>
        <Description>...the way IntroduceLocalAsync does (i.e. `expression.WithoutTrailingTrivia().WithoutLeadingTrivia()`).  As a result, the trivia appear in both the initializer of the newly-created field and at its use-site.</Description>
        <CreatedDate>25/08/2017</CreatedDate>
        <ClosedDate>09/10/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/CodeActions/IntroduceVariable/IntroduceVariableTests.cs</File>
      <File>src/Features/CSharp/Portable/IntroduceVariable/CSharpIntroduceVariableService_IntroduceField.cs</File>
      <File>src/Features/CSharp/Portable/IntroduceVariable/CSharpIntroduceVariableService_IntroduceLocal.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>22436</IssueID>
    <Title>Clean up code from previous ref-readonly PRs</Title>
    <Description>Fixes #21981 - Remove specialcasing for Span and ReadOnlySpan before shipping
Responds to one comment on #22424 

cc @dotnet/roslyn-compiler @VSadov </Description>
    <CreatedDate>29/09/2017</CreatedDate>
    <ClosedDate>30/09/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>21981</IssueID>
        <Title>Remove specialcasing for Span and ReadOnlySpan before shipping</Title>
        <Description>We currently assume, regardless of attributes, that Span and ReadOnlySpan are
- ref-like structs
- readonly structs

This is done as a bootstrapping measure to mitigate the situation where some repos have old compilers and some implementations of span types do not have expected annotation.

We should remove the special-casing when before shipping to not set a compat precedent where annotations are unnecessary on span types.</Description>
        <CreatedDate>08/09/2017</CreatedDate>
        <ClosedDate>30/09/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22424</IssueID>
        <Title>Fixes #22381 - Use in for parameters and arguments</Title>
        <Description>Fixes #22381 - Use `in` for parameters and arguments</Description>
        <CreatedDate>29/09/2017</CreatedDate>
        <ClosedDate>29/09/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/Conversions/Conversions.cs</File>
      <File>src/Compilers/CSharp/Portable/CSharpResources.Designer.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_StackAlloc.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PENamedTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/TypeSymbolExtensions.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/SpanStackSafetyTests.cs</File>
      <File>src/Compilers/Test/Utilities/CSharp/CSharpTestBase.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>22407</IssueID>
    <Title>Remove PROTOTYPE markers from "private protected" feature</Title>
    <Description>Fixes #22244
Related to #22406

This is a comment-only change, to remove PROTOTYPE comments and replace by open issues.

@jcouv Please review and approve for 15.5.
</Description>
    <CreatedDate>28/09/2017</CreatedDate>
    <ClosedDate>30/09/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>22244</IssueID>
        <Title>Remove PROTOTYPE markers from "private protected" feature</Title>
        <Description>It looks like some PROTOTYPE markers made it through when the feature was merged.

https://github.com/dotnet/roslyn/blame/9da689b5e705672c050bbac63bccd896ba4aefbb/src/VisualStudio/CSharp/Impl/CodeModel/CSharpCodeModelService.cs#L1041

https://github.com/dotnet/roslyn/blob/9da689b5e705672c050bbac63bccd896ba4aefbb/src/VisualStudio/VisualBasic/Impl/CodeModel/VisualBasicCodeModelService.vb#L1425</Description>
        <CreatedDate>21/09/2017</CreatedDate>
        <ClosedDate>30/09/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22406</IssueID>
        <Title>No mapping for `private protected` in EnvDTE.vsCMAccess</Title>
        <Description>In `Roslyn\src\VisualStudio\VisualBasic\Impl\CodeModel\VisualBasicCodeModelService.vb`, we have

``` vb
        Public Overrides Function GetAccess(symbol As ISymbol) As EnvDTE.vsCMAccess
            Debug.Assert(symbol IsNot Nothing)

            Dim access As EnvDTE.vsCMAccess = 0

            Select Case symbol.DeclaredAccessibility
                Case Accessibility.Private
                    access = access Or EnvDTE.vsCMAccess.vsCMAccessPrivate
                Case Accessibility.Protected
                    access = access Or EnvDTE.vsCMAccess.vsCMAccessProtected
                Case Accessibility.Internal, Accessibility.Friend
                    access = access Or EnvDTE.vsCMAccess.vsCMAccessProject
                Case Accessibility.ProtectedOrInternal, Accessibility.ProtectedOrFriend
                    access = access Or EnvDTE.vsCMAccess.vsCMAccessProjectOrProtected
                Case Accessibility.ProtectedAndInternal, Accessibility.ProtectedAndFriend
                    ' PROTOTYPE: there is no appropriate mapping for private protected in EnvDTE.vsCMAccess
                    access = access Or EnvDTE.vsCMAccess.vsCMAccessProject
                Case Accessibility.Public
                    access = access Or EnvDTE.vsCMAccess.vsCMAccessPublic
                Case Else
                    Throw Exceptions.ThrowEFail()
            End Select

            If TryCast(symbol, IPropertySymbol)?.IsWithEvents Then
                access = access Or EnvDTE.vsCMAccess.vsCMAccessWithEvents
            End If

            Return access
        End Function
```

Also, in `Roslyn\src\VisualStudio\CSharp\Impl\CodeModel\CSharpCodeModelService.cs`, we have

``` c#
        public override EnvDTE.vsCMAccess GetAccess(ISymbol symbol)
        {
            switch (symbol.DeclaredAccessibility)
            {
                case Accessibility.Public:
                    return EnvDTE.vsCMAccess.vsCMAccessPublic;
                case Accessibility.Private:
                    return EnvDTE.vsCMAccess.vsCMAccessPrivate;
                case Accessibility.Internal:
                    return EnvDTE.vsCMAccess.vsCMAccessProject;
                case Accessibility.Protected:
                    return EnvDTE.vsCMAccess.vsCMAccessProtected;
                case Accessibility.ProtectedOrInternal:
                    return EnvDTE.vsCMAccess.vsCMAccessProjectOrProtected;
                case Accessibility.ProtectedAndInternal:
                    // PROTOTYPE: there is no appropriate mapping for private protected in EnvDTE.vsCMAccess
                    return EnvDTE.vsCMAccess.vsCMAccessProtected;
                default:
                    throw Exceptions.ThrowEFail();
            }
        }
```

I am deleting the `PROTOTYPE` comments, and filing this bug to track the fact that there may be work here if and when `EnvDTE` supports the protected mode `Accessibility.ProtectedAndInternal`</Description>
        <CreatedDate>28/09/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/VisualStudio/CSharp/Impl/CodeModel/CSharpCodeModelService.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>22388</IssueID>
    <Title>Added tests for `out` and `ref` completion in local function</Title>
    <Description>Tests added in response to issue #22253.  
The issue was fixed by a previous PR by #17447 which was merged into master with #22050.
This PR is for additional tests only.

**Customer scenario**
If customer is in a local function, out and ref will not appear in the completion list when adding a parameter

**Bugs this fixes:**
#22253

**Risk**
Low, tests only

**Performance impact**
Low, only 2 tests added

**How was the bug found?**
Team member filed issue

**Test documentation updated?**
N/A

</Description>
    <CreatedDate>28/09/2017</CreatedDate>
    <ClosedDate>28/09/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>22253</IssueID>
        <Title>Completion on `out` in local function impedes with typing</Title>
        <Description>I tried to add an out parameter to a local function and Intellisense forced a completion of a type name instead of `out`.

![image](https://user-images.githubusercontent.com/12466233/30706186-79bb6e1e-9eac-11e7-8d4a-d80452857185.png)


FYI @agocke @Pilchie for triage</Description>
        <CreatedDate>21/09/2017</CreatedDate>
        <ClosedDate>28/09/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>17447</IssueID>
        <Title>IDE support for ref readonly/in tokens in completion service</Title>
        <Description>Related to #17287</Description>
        <CreatedDate>28/02/2017</CreatedDate>
        <ClosedDate>03/03/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22050</IssueID>
        <Title>Merge features/readonly-ref to master</Title>
        <Description>Merge from features/readonly-ref into master.

Brings a number of interconnected features geared towards system/hi-perf programming.

User facing features:
- `ref readonly`  parameters
- `ref readonly` return
- `ref` extension methods
- `ref readonly` extension methods
- `ref` ternary expressions
- `readonly` stucts
- `ref` structs     (such as `Span&lt;T&gt;` and `ReadonlySpan&lt;T&gt;`  and structs that contain them)
- escape analysis for byref variables and `ref struct` values
- safe `stackalloc`
- various optimizations for scenarios that involve readonly fields, stackalloc, fixed, unsafe . . .
- peverify-compat mode

Internal improvements:
- attribute embedding infrastructure
- separation of variable/lvalue and writeable/readonly analysis

==== See also
- Championed feature at https://github.com/dotnet/csharplang/issues/666
- Proposal for `[ref] readonly` at https://github.com/dotnet/csharplang/blob/master/proposals/readonly-ref.md    (ignore `in`, that is gone)  
- Detailed spec for Ref-Like types at https://github.com/dotnet/csharplang/blob/master/proposals/span-safety.md
- Smaller design details of the features above. - https://github.com/VSadov/csharplang/blob/RefSpanDesignChoices/proposals/RefReadonlySpanDesignChoices.md
- Test plan for ref `[ref] readonly` at https://github.com/dotnet/roslyn/issues/19216
- Test Plan for Span&lt;T&gt;, aka interior pointer, aka stackonly struct at https://github.com/dotnet/roslyn/issues/20127
</Description>
        <CreatedDate>11/09/2017</CreatedDate>
        <ClosedDate>21/09/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22253</IssueID>
        <Title>Completion on `out` in local function impedes with typing</Title>
        <Description>I tried to add an out parameter to a local function and Intellisense forced a completion of a type name instead of `out`.

![image](https://user-images.githubusercontent.com/12466233/30706186-79bb6e1e-9eac-11e7-8d4a-d80452857185.png)


FYI @agocke @Pilchie for triage</Description>
        <CreatedDate>21/09/2017</CreatedDate>
        <ClosedDate>28/09/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest2/Recommendations/OutKeywordRecommenderTests.cs</File>
      <File>src/EditorFeatures/CSharpTest2/Recommendations/RefKeywordRecommenderTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>22320</IssueID>
    <Title>Quote variable/array expansions in shell scripts</Title>
    <Description>Lack of quoting causes issues when files have spaces or are empty names.
Additionally, some arrays (though single elements) were treated like
simple variables.

The careful reader will note that I have left BUILD_ARGS

`dotnet build "${ROOT_PATH}"/CrossPlatform.sln ${BUILD_ARGS}`

untouched, because it contains spaces meant to separate arguments. Word
expansion is somewhat desired there (I believe) to ensure the arguments
are properly parsed. Unfortunately, BUILD_ARGS may contains paths with
spaces in them, causing this to still fail.

Fix #22259

**Customer scenario**

Try to build roslyn in a path with spaces and fail.

**Bugs this fixes:**

#22259 

**Workarounds, if any**

Don't use a path with spaces.

**Risk**

I'm very wary of this particular change, as it *likely* won't break anything currently (no paths with spaces) but is hard to guarantee for paths with spaces (we don't have test coverage).
As this is my first real contribution, I may have inadvertently quoted something I shouldn't have.

**Performance impact**

Low: these are shell scripts anyways, and the extra quotes should require negligible time compared to the scripts.

**Is this a regression from a previous update?**

I don't think so.

**Root cause analysis:**

We still don't have test coverage (although it appears there has been some discussion on getting some #20929), so I'm not sure we can 100% verify this yet. This is a known issue.

**How was the bug found?**

I tried to build roslyn in a directory whose full name contained spaces.</Description>
    <CreatedDate>25/09/2017</CreatedDate>
    <ClosedDate>27/09/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>22259</IssueID>
        <Title>Path names with spaces fail in build/scripts/obtain_dotnet.sh</Title>
        <Description>**Version Used**: 
```
$ git describe
Visual-Studio-2017-Version-15.3-3100-gf827f7a88c
```

**Steps to Reproduce**:

1. Clone `roslyn` into a directory with spaces in the path (e.g. `/Volumes/G-DRIVE ev RaW SSD/Home/roslyn`)
2. Run `./build/scripts/obtain_dotnet.sh` to obtain dotnet-CLI in order to build roslyn

**Expected Behavior**:

The pathname is handled accordingly.

**Actual Behavior**:

```
$ ./build/scripts/obtain_dotnet.sh
./build/scripts/obtain_dotnet.sh: line 25: /Volumes/G-DRIVE: No such file or directory
```

**Possible Solution**

Line 25 reads:
```bash
    source ${THIS_DIR}/build-utils.sh
```

There are other lines, both in `obtain_dotnet.sh` and other `*.sh` files that contain *unquoted* variables. This is problematic, as the variables undergo word splitting and causes issues like the above. See e.g. [BashPitfalls](http://mywiki.wooledge.org/BashPitfalls#cd_.24.28dirname_.22.24f.22.29) for many discussions on this.</Description>
        <CreatedDate>21/09/2017</CreatedDate>
        <ClosedDate>27/09/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22259</IssueID>
        <Title>Path names with spaces fail in build/scripts/obtain_dotnet.sh</Title>
        <Description>**Version Used**: 
```
$ git describe
Visual-Studio-2017-Version-15.3-3100-gf827f7a88c
```

**Steps to Reproduce**:

1. Clone `roslyn` into a directory with spaces in the path (e.g. `/Volumes/G-DRIVE ev RaW SSD/Home/roslyn`)
2. Run `./build/scripts/obtain_dotnet.sh` to obtain dotnet-CLI in order to build roslyn

**Expected Behavior**:

The pathname is handled accordingly.

**Actual Behavior**:

```
$ ./build/scripts/obtain_dotnet.sh
./build/scripts/obtain_dotnet.sh: line 25: /Volumes/G-DRIVE: No such file or directory
```

**Possible Solution**

Line 25 reads:
```bash
    source ${THIS_DIR}/build-utils.sh
```

There are other lines, both in `obtain_dotnet.sh` and other `*.sh` files that contain *unquoted* variables. This is problematic, as the variables undergo word splitting and causes issues like the above. See e.g. [BashPitfalls](http://mywiki.wooledge.org/BashPitfalls#cd_.24.28dirname_.22.24f.22.29) for many discussions on this.</Description>
        <CreatedDate>21/09/2017</CreatedDate>
        <ClosedDate>27/09/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>20929</IssueID>
        <Title>Roslyn enlistment path restrictions</Title>
        <Description>There are a number of requirements Roslyn has on the path on which it is enlisted:

- Cannot contain spaces
- Cannot contain SEMICOLON (U+003B) character
- Cannot contain `%`, `@` or `$` characters

These limitations are unnecessary and in theory could be supported. However it would require **both**

- Changes to our build scripts and external tooling to support the characters
- Changing to our test infrastructure to verify we don't regress the behavior

The latter in particular is the most important. There have been a number of attempts to remove our limitation on no spaces. These have never been accompanied with the corresponding infrastructure changes and hence the fixes last a week at most before we break them again. 

Using this issue to track the many small limitations we have on the enlistment path. 
</Description>
        <CreatedDate>18/07/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>22318</IssueID>
    <Title>Avoid scheduling an unnecessary dispose task for EmptyAsyncToken</Title>
    <Description>Fixes #22272

**Customer scenario**

Long sequences of asynchronous operations can be scheduled (#22274), which is a problematic condition further exacerbated by the scheduling of a separate call to an empty `Dispose` method.

**Bugs this fixes:**

#22272

**Workarounds, if any**

None

**Risk**

Very low. Avoids scheduling an asynchronous call to an empty non-virtual method.

**Performance impact**

Improves performance by eliminating an asynchronous operation.

**Is this a regression from a previous update?**

No.

**Root cause analysis:**

Found during manual analysis of heaps provided by "low memory" events.

**How was the bug found?**

Manual inspection of heap dumps.

**Test documentation updated?**

N/A
</Description>
    <CreatedDate>25/09/2017</CreatedDate>
    <ClosedDate>25/09/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>22272</IssueID>
        <Title>CompletesTrackingOperation should not dispose of EmptyAsyncToken</Title>
        <Description>**Version Used**: 15.3

:memo: Observed 18,000 scheduled tasks in a work queue in a "low memory" heap dump submitted for analysis.

When `TaskExtensions.CompletesTrackingOperation` is called with `EmptyAsyncToken.Instance`, it should not attempt to dispose of the token. The `Dispose()` method is empty, and scheduling the operation has substantial overhead.
</Description>
        <CreatedDate>21/09/2017</CreatedDate>
        <ClosedDate>25/09/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22274</IssueID>
        <Title>WorkCoordinator.Reanalyze should avoid duplicate scheduling</Title>
        <Description>**Version Used**: 15.3

:memo: Observed 18,000 scheduled operations during analysis of a heap dump provided for a "low memory" condition. The `HashSet&lt;DiagnosticId&gt;` instances required to queue the requested analysis operations accounted for nearly 1GiB of memory overhead.

`WorkCoordinator.Reanalyze` schedules analysis operations on sets of documents:

https://github.com/dotnet/roslyn/blob/c83a39086d062ae46e4eb333970b0cf59feba1a2/src/Features/Core/Portable/SolutionCrawler/WorkCoordinator.cs#L166-L170

These analysis operations may take time. To avoid unnecessary memory overhead, operations should not be scheduled for a `DocumentId` when another scheduled operation will already update that document.</Description>
        <CreatedDate>21/09/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22272</IssueID>
        <Title>CompletesTrackingOperation should not dispose of EmptyAsyncToken</Title>
        <Description>**Version Used**: 15.3

:memo: Observed 18,000 scheduled tasks in a work queue in a "low memory" heap dump submitted for analysis.

When `TaskExtensions.CompletesTrackingOperation` is called with `EmptyAsyncToken.Instance`, it should not attempt to dispose of the token. The `Dispose()` method is empty, and scheduling the operation has substantial overhead.
</Description>
        <CreatedDate>21/09/2017</CreatedDate>
        <ClosedDate>25/09/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Features/Core/Portable/Shared/TestHooks/IAsyncToken.cs</File>
      <File>src/Features/Core/Portable/Shared/TestHooks/TaskExtensions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>22296</IssueID>
    <Title>ported tests from https://github.com/dotnet/roslyn/pull/21263</Title>
    <Description>main issue the PR is trying to fix (#18405) is addressed by this (https://github.com/dotnet/roslyn/pull/21857). 

this mainly port over tests added by this pr (#21263) with some changes.

in some cases such as params array, argument node get removed while converted to IOperation since compiler generated array replaces the argument.

for those, I just made test to dump including statement. for now, the test doesn't show interesting info, but once @jinujoseph finishes the work to show syntax kind/isImplicit/parent in the test, it will show info such as what got injected (param array) and argument got removed.

</Description>
    <CreatedDate>22/09/2017</CreatedDate>
    <ClosedDate>23/09/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>18405</IssueID>
        <Title>[IOperation] Getting the IOperation for a single argument returns the entire expression using the argument</Title>
        <Description>Paste the following code into ETA:

```C#
class Program
{
    static void Main(string[] args)
    {
        Main(new[] { "asdf" });
    }
}
```

Getting the IOperation for the `new[] { "asdf" }` statement returns the following:

```
IOperation tree for "new[] { "asdf" }"

IInvocationExpression (static void Program.Main(System.String[] args)) (OperationKind.InvocationExpression, Type: System.Void)
  IArgument (Matching Parameter: args) (OperationKind.Argument)
    IArrayCreationExpression (Dimension sizes: 1, Element Type: System.String) (OperationKind.ArrayCreationExpression, Type: System.String[])
      ILiteralExpression (OperationKind.LiteralExpression, Type: System.Int32, Constant: 1)
      IArrayInitializer (OperationKind.ArrayInitializer)
        ILiteralExpression (OperationKind.LiteralExpression, Type: System.String, Constant: asdf)
```

It should be returning just the `IArgument`.</Description>
        <CreatedDate>03/04/2017</CreatedDate>
        <ClosedDate>27/09/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>21263</IssueID>
        <Title>Map ArgumentSyntax nodes to appropriate IArgument operations</Title>
        <Description>Fixes https://github.com/dotnet/roslyn/issues/18405</Description>
        <CreatedDate>02/08/2017</CreatedDate>
        <ClosedDate>27/09/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IArgument.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>22285</IssueID>
    <Title>IDE Features fix for code generation for ref-readonly</Title>
    <Description>Fixes #22242 - Implement Interface loses "ref readonly"
Fixes #22241 - Replace lambda with local function loses "ref readonly"
Fixes #22240 - Add Accessibility modifier removes "ref" from a ref struct
Fixes #22239 - Change Signature does not show "ref readonly" modifier on parameters
Fixes #22238 - Extract interface loses "ref readonly" on parameters and returns

I split this PR into two commits:
* One has all the refactoring (threading RefKinds through various APIs)
* Another for the tests, roughly one test file change per bug above.</Description>
    <CreatedDate>22/09/2017</CreatedDate>
    <ClosedDate>28/09/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>22242</IssueID>
        <Title>Implement Interface loses "ref readonly"</Title>
        <Description>Implement interface refactoring loses "ref readonly" on parameters. 

Inherit from abstract class does this too. </Description>
        <CreatedDate>21/09/2017</CreatedDate>
        <ClosedDate>28/09/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22241</IssueID>
        <Title>Replace lambda with local function loses "ref readonly"</Title>
        <Description>```cs
        delegate ref readonly int D1(ref readonly int arg);

            D1 dd = (ref readonly int a) =&gt; ref a;
```

Replace dd with a local function using IDE. - loses "ref readonly"
</Description>
        <CreatedDate>21/09/2017</CreatedDate>
        <ClosedDate>28/09/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22240</IssueID>
        <Title>Add Accessibility modifier removes "ref" from a ref struct</Title>
        <Description>
Invoke Refactor/Add Accessibility modifiers on 

```cs
readonly unsafe ref struct S1 { }
```
The dialog offers adding "private", but also offers to remove "ref"

</Description>
        <CreatedDate>21/09/2017</CreatedDate>
        <ClosedDate>28/09/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22239</IssueID>
        <Title>Change Signature does not show "ref readonly" modifier on parameters</Title>
        <Description>
The Change Signature  shows  other modifiers like "out" but not "ref readonly" - not sure if it does not understand it or because it simply does not fit. There is no much space in that UI.</Description>
        <CreatedDate>21/09/2017</CreatedDate>
        <ClosedDate>28/09/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22238</IssueID>
        <Title>Extract interface loses "ref readonly" on parameters and returns</Title>
        <Description>
parameters become an ordinary `ref`, returns become ordinary byval returns.</Description>
        <CreatedDate>21/09/2017</CreatedDate>
        <ClosedDate>28/09/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Lowering/IteratorRewriter/IteratorFinallyMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/StateMachineRewriter/SynthesizedStateMachineProperty.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/SynthesizedMethodBaseSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/AnonymousTypes/SynthesizedSymbols/AnonymousType.ConstructorSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/AnonymousTypes/SynthesizedSymbols/AnonymousType.EqualsMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/AnonymousTypes/SynthesizedSymbols/AnonymousType.GetHashCodeMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/AnonymousTypes/SynthesizedSymbols/AnonymousType.PropertyAccessorSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/AnonymousTypes/SynthesizedSymbols/AnonymousType.PropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/AnonymousTypes/SynthesizedSymbols/AnonymousType.ToStringMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ErrorMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ErrorPropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PEMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PEParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PEPropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/MethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/PropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ReducedExtensionMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/SignatureOnlyMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/SignatureOnlyPropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/LambdaSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/LocalFunctionSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceConstructorSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceDelegateMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceDestructorSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceEventAccessorSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceMemberContainerSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceMemberMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceOrdinaryMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourcePropertyAccessorSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourcePropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceUserDefinedOperatorSymbolBase.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedDelegateSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedEntryPointSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedGlobalMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedImplementationMethod.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedInstanceConstructor.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedInteractiveInitializerMethod.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedIntrinsicOperatorSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedSealedPropertyAccessor.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedStaticConstructor.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Wrapped/WrappedMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Wrapped/WrappedPropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Utilities/EnumExtensions.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/AmbiguousOverrideTests.cs</File>
      <File>src/Compilers/Core/Portable/InternalUtilities/EnumUtilties.cs</File>
      <File>src/Compilers/Core/Portable/Symbols/IMethodSymbol.cs</File>
      <File>src/Compilers/Core/Portable/Symbols/IPropertySymbol.cs</File>
      <File>src/Compilers/Core/Portable/Symbols/RefKind.cs</File>
      <File>src/EditorFeatures/CSharp/EventHookup/EventHookupCommandHandler_TabKeyCommand.cs</File>
      <File>src/EditorFeatures/CSharpTest/AddAccessibilityModifiers/AddAccessibilityModifiersTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/ExtractInterface/ExtractInterfaceTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/ImplementAbstractClass/ImplementAbstractClassTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/ImplementInterface/ImplementInterfaceTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseLocalFunction/UseLocalFunctionTests.cs</File>
      <File>src/EditorFeatures/Test/CodeGeneration/CodeGenerationTests.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Source/ExpressionCompiler/Symbols/EEMethodSymbol.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Source/ExpressionCompiler/Symbols/PlaceholderMethodSymbol.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Source/ExpressionCompiler/Symbols/SynthesizedContextMethodSymbol.cs</File>
      <File>src/Features/CSharp/Portable/ExtractMethod/CSharpMethodExtractor.CSharpCodeGenerator.cs</File>
      <File>src/Features/CSharp/Portable/GenerateMember/GenerateParameterizedMember/CSharpGenerateConversionService.cs</File>
      <File>src/Features/CSharp/Portable/GenerateMember/GenerateParameterizedMember/CSharpGenerateParameterizedMemberService.cs</File>
      <File>src/Features/CSharp/Portable/GenerateType/CSharpGenerateTypeService.cs</File>
      <File>src/Features/CSharp/Portable/UseLocalFunction/CSharpUseLocalFunctionCodeFixProvider.cs</File>
      <File>src/Features/Core/Portable/Completion/Providers/AbstractPartialMethodCompletionProvider.cs</File>
      <File>src/Features/Core/Portable/EncapsulateField/AbstractEncapsulateFieldService.cs</File>
      <File>src/Features/Core/Portable/ExtractInterface/AbstractExtractInterfaceService.cs</File>
      <File>src/Features/Core/Portable/GenerateMember/GenerateParameterizedMember/AbstractGenerateMethodService.State.cs</File>
      <File>src/Features/Core/Portable/GenerateMember/GenerateParameterizedMember/AbstractGenerateParameterizedMemberService.MethodSignatureInfo.cs</File>
      <File>src/Features/Core/Portable/GenerateMember/GenerateParameterizedMember/AbstractGenerateParameterizedMemberService.SignatureInfo.cs</File>
      <File>src/Features/Core/Portable/GenerateMember/GenerateVariable/AbstractGenerateVariableService.CodeAction.cs</File>
      <File>src/Features/Core/Portable/GenerateType/AbstractGenerateTypeService.GenerateNamedType.cs</File>
      <File>src/Features/Core/Portable/InitializeParameter/AbstractInitializeMemberFromParameterCodeRefactoringProviderMemberCreation.cs</File>
      <File>src/Features/Core/Portable/MetadataAsSource/AbstractMetadataAsSourceService.WrappedMethodSymbol.cs</File>
      <File>src/Features/Core/Portable/MetadataAsSource/AbstractMetadataAsSourceService.WrappedPropertySymbol.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ChangeSignature/ChangeSignatureDialogViewModel.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Venus/ContainedLanguageCodeSupport.cs</File>
      <File>src/VisualStudio/Core/Impl/CodeModel/AbstractCodeModelObject_CodeGen.cs</File>
      <File>src/Workspaces/CSharp/Portable/CodeGeneration/CSharpSyntaxGenerator.cs</File>
      <File>src/Workspaces/CSharp/Portable/CodeGeneration/MethodGenerator.cs</File>
      <File>src/Workspaces/CSharp/Portable/CodeGeneration/ParameterGenerator.cs</File>
      <File>src/Workspaces/CSharp/Portable/CodeGeneration/PropertyGenerator.cs</File>
      <File>src/Workspaces/CSharp/Portable/Extensions/ITypeSymbolExtensions.cs</File>
      <File>src/Workspaces/CSharp/Portable/Extensions/TypeSyntaxExtensions.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/CodeGenerationSymbolFactory.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/Symbols/CodeGenerationAbstractMethodSymbol.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/Symbols/CodeGenerationConstructedMethodSymbol.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/Symbols/CodeGenerationConstructorSymbol.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/Symbols/CodeGenerationConversionSymbol.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/Symbols/CodeGenerationDestructorSymbol.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/Symbols/CodeGenerationMethodSymbol.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/Symbols/CodeGenerationOperatorSymbol.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/Symbols/CodeGenerationPropertySymbol.cs</File>
      <File>src/Workspaces/Core/Portable/Editing/DeclarationModifiers.cs</File>
      <File>src/Workspaces/Core/Portable/Shared/Extensions/ICodeDefinitionFactoryExtensions_CreateEqualsMethod.cs</File>
      <File>src/Workspaces/Core/Portable/Shared/Extensions/ICodeDefinitionFactoryExtensions_CreateGetHashCodeMethod.cs</File>
      <File>src/Workspaces/Core/Portable/Shared/Extensions/IMethodSymbolExtensions.cs</File>
      <File>src/Workspaces/Core/Portable/Shared/Extensions/IParameterSymbolExtensions.cs</File>
      <File>src/Workspaces/Core/Portable/Shared/Extensions/IPropertySymbolExtensions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>22284</IssueID>
    <Title>Create tests to cover test plans #19216 and #20127</Title>
    <Description>* Create tests to cover test plans #19216 and #20127
* Filed issues for the items not covered by tests here.
* Fixed a small bug where `RefKind.RefReadOnly` was displayed as `in` in one error message.
* Fixed a small bug where nested ternary operator statements were not allowed for `stackalloc`.</Description>
    <CreatedDate>22/09/2017</CreatedDate>
    <ClosedDate>28/09/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>19216</IssueID>
        <Title>Test plan for "ref readonly" and related features (7.2)</Title>
        <Description>Write a test plan for "ref readonly", "readonly structs", "ref and ref readonly extensions" and "ref ternary"

## LDM
- [x] remove `in` syntax from initial release? ([merged](https://github.com/dotnet/roslyn/pull/22182))
- [x] ref readonly locals? (implemented in 7.2, Andy)
- [x] allowing `ref readonly` at call site (for those who dislike auto-ref)? (yes, but we're switching to `in` as keyword)
- [ ] throw expression in ref ternary
- [x] ref re-assignment (discussed in Oct 2nd LDM, C# 7.2 candidate)
- [ ] Overloading on in/byval should cause an error (#22132)
- [x] Should referencing [IsReadOnly] methods without an [IsConst] modreq be allowed? (#19792) (yes)

## Spec
- [x] Merge the "decisions made" spec into the existing docs
- [ ] Note that `in` parameters are not allowed in iterator or async methods
- [ ] Note that you can take unmanaged address of readonly variable (https://github.com/dotnet/roslyn/pull/22400)
- [ ] Note the typing rule for stackalloc (`var x = stackalloc ...` is pointer type for compat reasons, but `condition ? stackalloc ... : stackalloc ...` is `Span`)

## Misc

- [x] Add feature docs for all these features (latest rules on Span, ref re-assignment)
- [ ] Update Compiler test plan (stackalloc, in/ref readonly, ref struct)
- [ ] Review BCL work (are the new types everywhere? for example, Span in mono?)
- [ ] do IDE test pass
    - [x] verify IDE completion and formatting on `ref readonly`, `in`, `return ref ...`, `ref` ternary, 
    - [x] CodeStyle for `in` versus `ref readonly`
    - [ ] Analyzer/code fixer to recommend `readonly struct`
    - [ ] If we choose to allow `ref readonly` at call site, CodeStyle for call site (for those who don't like auto-ref)
   - [x] Block EE (problem with emitting attribute types?)
   - [ ] Test Interactive
- [ ] Test on various runtimes (desktop, core, native, mono). May need a spec of expected runtime behavior.
- [ ] Triage remaining issues for the feature
- [x] dogfood in Roslyn repo (https://github.com/dotnet/roslyn/pull/26010)
- [ ] document PE Verify gaps (either with existing tracking issue, or creating a new one)


## Ref readonly parameters
- [x] [Spec](https://github.com/dotnet/csharplang/blob/master/proposals/readonly-ref.md) exists
- [x] test passing too many modifiers ("ref readonly in" or "in ref readonly", etc)
- [x] verify API declaration and usage from compilation, image, metadata-only image and ref assembly
- [x] ref readonly property from metadata with different attributes on getter and property
- [x] Where is it allowed or blocked?
    - [x] combine with `out` or `params` (expect error)
    - [x] `ref readonly` is disallowed: in local declarations `ref readonly var x = y;`, in front of expressions `var x = ref readonly y;`, `return ref readonly`, `foreach (readonly ref i in ...)`
    - [x] ref readonly optional parameter
    - [x] using `in` and `ref readonly` in lambda
    - [x] using `in` in delegate
    - [x] using `in` in local function
    - [x] using `in` in async and iterator methods (disallowed)
    - [x] explicit `in` or `ref readonly` at call site (disallowed)
    - [x] the order of `ref` and `readonly` does matter (what is the error? should we offer a fixer?)
    - [x] Using `in` in pattern-based lowering:
        - [x] `Deconstruct` method with `in` parameters is not applicable for deconstruction
        - [x] Implementing an task-like with `in` in builder type 
        - [x] enumerable/enumerator `GetEnumerator(in int count = 10)` (see #19742)

    
- [x] OHI
    - [x] methods differing in `ref/out/in` (we only consider types)
    - [x] invoke `M(1);` with `void M(ref readonly int i) { }` and `void M(int i) { }` in situation of ambiguity (because of inheritance or extension methods)

- [x] verify `in` is invariant (because of CLR limitation, just like `out`)
 
- [ ] Verify that IL for copy versus no-copy
     - [ ] Passing in an RValue should work (making a temp copy, verify IL)
     - [ ] Default values (temp copy)
     - [ ] LValue need no copy
     - [ ] test spilling for `M(someInArg, async M2(), someOtherInArg)`
            - `someInArg` could be local, constant, `RefReadonlyM(refReadonlyField)`, `someArray[index]`, `field`
- [ ] No writes allowed:
    - [ ] assignment, compound assignment, passing as `ref`
    - [ ] invocation (`in S s`, then `s.Mutate();`) (also allowed, operating on a temp copy, verify IL. But no copy if `S` is readonly struct)
    - [ ] calling into a method passing `in` through is ok
    - [ ] returning ref readonly parameter as ref (disallowed)
    - [ ] returning ref parameter as ref readonly (allowed)
- [ ] `in` parameters cannot be captured (lambda/async/iterator)
- [x] `in` allowed in indexer and operator parameters
- [x] test VB interop (calling blocked because modreq on overridable members and delegate/interface methods, but allowed on non-overridable members)
- [x] taking pointer to ref readonly parameter (in unsafe code) is disallowed
- [x] passing `nameof` expression as `in` argument (expect copy?)

## Ref readonly returns
- [x] [Spec](https://github.com/dotnet/csharplang/blob/master/proposals/readonly-ref.md) exists
- [x] `in` syntax disallowed in method declaration
- [x] `ref readonly` return in async method (no syntax for it)
- [x] `ref readonly` return on operator is disallowed (no syntax for it)
     - [x] operator from metadata should be handled (load as operator, but use-site error?)
- [x] `ref readonly` on indexer (allowed)
- [x] `readonly` is disallowed in `return` statement
- [x] signature needs exact match in OHI
     - [x] differentiates between `in` and `ref`
- [x] ref-readonly-returning lambda?
- [x] calling with a discard (no syntax for it?)
   
- [x] metadata:
    - [x] `IsReadOnlyAttribute` gets embbeded if not found, disallowed in source
    - [x] what if the attribute exists, but has wrong ctor shape?
    - [x] If `InAttribute` modreq present but `IsReadOnlyAttribute` is missing, then cannot load metadata
    - [x] If `IsReadOnlyAttribute` is present, but `InAttribute` modreq is missing, then can load and this absence of modreq will be carried over when overriding.
    - [x] modreq always emitted (test VB interop)
    - [x] verify API declaration and usage from compilation, image, metadata-only image and ref assembly

## Readonly struct
- [x] Spec
- [ ] `readonly` on class declaration and other illegal members
    - [ ] `readonly` is floating, but `ref` must be next to `struct` in `readonly ref struct`
    - [ ] `partial` must be before `ref` or `struct` (but what about the `readonly`?)
    - [ ] no `in` struct
- [ ] `readonly` on half a partial struct (allowed, just like other modifiers)
- [ ] How is it surfaced in symbol (semantic model)?
- [ ] verify API declaration and usage from compilation, image, metadata-only image and ref assembly
- [ ] readonly attribute is missing, readonly attribute specified in source, obsolete attribute is missing
- [ ] `Obsolete` attribute given by user wins. There should be a warning.
- [ ] can call `void M(in S s)` with `M(this)`, but not `void M(ref S s)`.
- [ ] can call `void M(S s)` with `M(this)`, but that will make a copy.
- [ ] `this` cannot be captured by lambda or other
- [ ] taking a pointer to `this` is disallowed
- [ ] all fields must be readonly
- [ ] property setters and events are disallowed


## Ref ternary
- [ ] Blocked in expression tree
- [ ] `(b ? ref x : ref y).M()` where `M` is ref extension method, regular extension method (error), regular method (error)
     - [ ] does it make copies? what if `x` or `y` or both are readonly structs?
- [ ] for `M(b ? ref x : ref y)` where `void M(in ...)`, I expect no temporary.
- [ ] for `b ? ref M() : ref M2()` where `ref readonly C M()` (and same for M2), expect the ternary is readonly
- [ ] for `b ? ref this : ref this` where `this` refers to a readonly struct, is the ternary readonly?
- [ ] what if the branches differ in readonlyness in the examples above?
- [ ] what if `b` is known to be constant (compiler knows which branch will be executed)?
- [ ] Mixing ref and non-ref is disallowed. `b ? ref x : y`
- [ ] Nesting. `b1 ? ref (b2 ? ref x : ref y) : ref z`
- [ ] No ref coalescing operator `ref x ?? ref y`
- [ ] Pattern matching on a ref ternary, or on a ref readonly ternary (this may matter later with tuple/deconstruction pattern?)
- [ ] `b ? ref x : ref default` (disallowed)
- [ ] Ref ternaries in tuple literal
- [x] Ref ternary with throw expression (https://github.com/dotnet/csharplang/issues/919)
- [ ] Ref ternary as `in` argument (`M(in condition ? ref x : ref y);`)

## Ref readonly extension methods
- [x] `ref readonly S Extension(ref readonly this S s) { return ref s; }`
- [x] `void RRExtension&lt;T&gt;(ref readonly this T t) { ... }` (expect error)
- [x] `42.RRExtension()` (ok, but makes temporary)
- [x] `readonlyField.RRExtension()` (expect no temporary)
- [x] `refReadonlyParameter.RRExtension()` (expect no temporary)
- [x] `M().RRExtension()` (expect no temporary)
- [ ] `this.RRExtension()` 
     - [ ] on readonly struct (expect no temporary)
     - [ ] on a plain struct (expect makes temporary)
- [ ] `(ref readonly ternary).RRExtension()` (expect no temporary)
- [ ] Why do we allow on rvalues? (I assume for consistency with methods)
- [x] verify API declaration and usage from compilation, image, metadata-only image and ref assembly

## Ref-like types and safety (Span)
- [x] [Spec](https://github.com/dotnet/csharplang/blob/master/proposals/span-safety.md) exists
- [ ] See Neal's test plan: https://github.com/dotnet/roslyn/issues/20127
- [x] `ref readonly string M(ref readonly string s = "hello") { return ref s; }`. Same with value type. (gives a unsafe-to-escape diagnostic)
- [ ] test foreach with API pattern (as opposed to interface) on ref-like iterator
- [x] dynamic and stackalloc
     - [x] `dynamic d = stackalloc int[10];`
     - [x] `Span&lt;dynamic&gt; d = stackalloc dynamic[10];`

## Misc
- [ ] `(b ? ref x : ref x).foo()`
- [ ] `x.y.foo() // ref may be inferred`
- [ ] Interaction with dynamic? nullable?
- [x] attributes `IsReadOnly` and `IsByRefLike` are disallowed in source

See also
- [Language Feature Status](https://github.com/dotnet/roslyn/blob/master/docs/Language%20Feature%20Status.md)
- [The feature branch](https://github.com/dotnet/roslyn/tree/features/readonly-ref)
- [[Work items] Readonly ref parameters/returns](https://github.com/dotnet/roslyn/issues/17287)
- [Proposal (ref readonly, readonly struct, ref extensions)](https://github.com/dotnet/csharplang/blob/master/proposals/readonly-ref.md)
- [Ref-like types and safety](https://github.com/dotnet/csharplang/blob/master/proposals/span-safety.md), 
- [Decisions made](https://github.com/VSadov/csharplang/blob/RefSpanDesignChoices/proposals/RefReadonlySpanDesignChoices.md)
</Description>
        <CreatedDate>03/05/2017</CreatedDate>
        <ClosedDate>12/11/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>20127</IssueID>
        <Title>Test Plan for Span&lt;T&gt;, aka interior pointer, aka stackonly struct</Title>
        <Description>[This](https://github.com/dotnet/roslyn/issues/20127) is a test plan for the feature set variously known as "stackonly structs", "interior pointer", and "Span&lt;T&gt;" targeting milestone 15.6 (C# 7.2), which is related to (but different from) slicing.

See also
- Championed feature at https://github.com/dotnet/csharplang/issues/666
- Proposed safety rules at https://github.com/dotnet/csharplang/blob/master/proposals/csharp-7.2/span-safety.md
- Test plan for ref readonly at https://github.com/dotnet/roslyn/issues/19216
- Test plan suggestions at https://github.com/dotnet/roslyn/blob/master/docs/contributing/Compiler%20Test%20Plan.md

## Declarations and types

### `ref struct` declarations
- [ ] The parser accepts `ref` as a modifier on a `struct` declaration
- [ ] The `ref` modifier must appear immediately before the `struct` keyword (no intervening `public`)
- [ ] A `ref struct` type cannot be partial (neither `ref partial struct` nor `partial ref struct` are accepted)
- [ ] A `ref struct` type may be generic
- [ ] A `ref struct` type *may* contain an instance field of another `ref struct` type
- [ ] Neither a non-ref `struct`, nor a class, may contain a field of a `ref struct` type
- [ ] A `ref struct` type declaration may not contain a base clause. It therefore cannot be declared to extend any interface type.
- [ ] It is not legal to use `base` in the body of any method, property, etc in a `ref struct` type.
- [ ] A `ref struct` type declaration may not contain an iterator instance method.
- [ ] A `ref struct` type declaration may not contain an async instance method.
- [ ] A `ref struct` type declaration may contain a static iterator method, and a static async method.
- [ ] (NoPia) A `ref struct` type may not be embedded.

### use of `ref struct` types
- [ ] A `ref struct` type may not be used as a type argument to a `class`, `struct`, `delegate`, or method.
  - [ ] It is an error to construct `System.Nullable` with a type argument of a `ref struct` type, even implicitly.
  - [ ] If an instance method `e.M` returns a value of a `ref struct` type, `e?.M()` is an error.
  - [ ] If type inference infers a `ref struct` type as a type argument, an error is given.
- [ ] An instance method declared in a `ref struct` type may not be converted to a delegate
- [ ] An instance method inherited into a `ref struct` type (e.g. `GetHashCode`) may not be converted to a delegate
- [ ] A static field may not be of a `ref struct` type (even if the container is a `ref struct` type)
- [ ] It is an error to use a `ref struct` type as the element type of an array type
- [ ] An anonymous type may not contain an element of a `ref struct` type.
- [ ] A tuple type may not contain an element of a `ref struct` type.
- [ ] It is an error if a tuple literal's natural type contains an element of a `ref struct` type, e.g. `(1, span)`
- [ ] It is not an error if a tuple literal, e.g., `(null, span)` has no natural type and is converted to a tuple type that does not contain an element of a `ref struct` type (e.g. by the use of a user-defined conversion), e.g. `(string, int) x = (null, span);` where the span's type contains a conversion to `int`.
- [ ] A `Deconstruct` method *may* output one or more values of a `ref struct` type.
  - [ ] Such a value can be stored in a local variable via a deconstruction statement.
  - [ ] However, it is an error to use such a deconstruction expression elsewhere.
- [ ] A set of `ref struct` types can be written to implement the `foreach` pattern, in which case the `foreach` statement should work with an iterator variable of a `ref struct` type.
- [ ] A set of `ref struct` types can be written to implement the `foreach` pattern with an element type of a `ref struct` type that contains a `Deconstruct` method, in which case the `foreach` statement should work with a pair of iterator variables of `ref struct` types.
- [ ] Neither a parameter nor local variable of `ref struct` type may be captured in a lambda or local function.
- [ ] Neither a parameter nor local variable of `ref struct` type may be declared in an iterator or async method.
- [ ] A value of `ref struct` type may not require spilling in `async` code, e.g. it is an error (possibly reported during emit) to compile an expression such as `M(span1, await e)`.
- [ ] No boxing conversion exists from a `ref struct` type to `object` or `ValueType`.
- [ ] No unboxing conversion exists to a `ref struct` type
- [ ] No instance method declared in `object` or in `System.ValueType` but not overridden in a `ref struct` type may be called with a receiver of that `ref struct` type.
- [ ] A user-declared conversion may convert to or from a `ref struct` type.
  - [ ] Such a user-declared conversion does not have a lifted form in which the `ref struct` type is nullable.
- [ ] A user-declared operator may accept a parameter of `ref struct` type.
  - [ ] Such a user-declared operator does not have a lifted form in which the `ref struct` type is nullable.
    - [ ] test with one operand a `ref struct` type (left, and right)
    - [ ] test with both operands a `ref struct` type
- [ ] A local function may contain parameters and local variables of `ref struct` types.
  - [ ] Unless the local function is `async` or an iterator method. 
- [ ] (extra credit) A set of `ref struct` types, delegate types, and methods can be declared which permit the use of *Linq* with a sequence of value of a `ref struct` type represented by, e.g., `Span&lt;T&gt;`.
- [ ] A `ref struct` type cannot be awaited, even if it is otherwise task-like. *(is this right?)*

## Restrictions on `stackalloc`

Tests should demonstrate that `stackalloc` can only be used
1. As the initializer of a local variable declaration; or
2. As either the second or third operand of a ternary operator which is in one of these contexts.
- [x] `stackalloc` works in an initializer
- [x] `stackalloc` works in a ternary in an initializer
- [x] `stackalloc` works in a nested ternary in an initializer
- [x] `stackalloc` does not work as an operand to a method invocation, e.g. `M(stackalloc int[1])`
- [x] there may be a user-defined conversion between the `stackalloc` result and the variable's type.
  - [x] when the converted-from type is a pointer type
  - [x] when the converted-from type is a `ref struct` type 
- [x] `stackalloc` is an error if parenthesized
- [x] `stackalloc` is an error if either operand of `??`
- [x] `stackalloc` is an error if subject to an explicit cast, e.g. `var x = (myspan)stackalloc int[10];`
  - [x] Alternatively, change the spec to permit it and test it, including beneath a ternary operator (allowed and tested)
- [x] The statement `var x = stackalloc int[10];` is an error unless in an `unsafe` context, because `x` is of type `int*`.
- [x] The statement `Span&lt;int&gt; x = stackalloc int[10];` is not an error outside an `unsafe` context.
- [x] The statement `T x = stackalloc int[10];` is an error outside an `unsafe` context if it required a user-defined conversion from `int*` to `T` 
- [x] The statement `T x = stackalloc int[10];` is permitted outside an `unsafe` context if it required a user-defined conversion from `Span&lt;int&gt;` to `T` 
- *TODO: We should have LDM confirmation of the above `stackalloc` restrictions regarding where it may appear.*

Tests should demonstrate that the compiler rejects an attempt to use `stackalloc` (#21918)
- [x] In a `catch` block (with or without a catch parameter).
- [X] In an exception filter (due to constraints on the `localloc` instruction). [This cannot occur if `stackalloc` is restricted to local variable initializers]
- [x] In a `finally` block.

## Miscellaneous

- [ ] The C# 7 compiler prevents the use of a `ref struct` type from metadata
- [ ] The C# 5 compiler prevents the use of a `ref struct` type from metadata (hand verify)
- [ ] A warning is given when a `ref struct` type is declared with an explicit `[Obsolete]` attribute
- [ ] Demonstrate that a `ref struct` type acts as such in separate compilation scenarios
  - [ ] through a metadata reference
  - [ ] through a compilation reference
- [ ] The use of a `ref struct` type from VB produces a compile-time error. 
- [ ] There should be some public API (may be an extension method) that can be used to determine that a given `ITypeSymbol` or `TypeSymbol` is a `ref struct` type.
- [ ] A `ref struct` value cannot be used in an expression tree, even as an intermediate result. (?)
- [ ] There is no conversion involving a `ref struct` type, either to or from `dynamic`.
- [ ] A value of `ref struct` type may be used in an object, collection, or dictionary initializer for a type whose API was designed to permit this.
- [ ] An extension method may operate on a `this` parameter of a `ref struct` type.
- [ ] A value of `ref struct` type may not be used as a fill-in in string interpolation due to the need to box the value.

## APIs

- [ ] In a statement of the form `T1 x = stackalloc int[10];`, the semantic model should report that the `stackalloc` expression has the type `int*` and a converted type of `T1`
  - [ ] When `T1` is `int*`
  - [ ] When there is a user-defined conversion from `int*` to `T1`
  - [ ] When there is a user-defined conversion from `Span&lt;int&gt;` to `T1`. 
  - [ ] For each of these, the conversion-from-expression from `stackalloc int[10]` appears as some appropriate kind of conversion.
- [ ] A `stackalloc` expression in any other syntactic context than a local variable initializer context has the type `Span&lt;T&gt;`.
  - [ ] under a ternary operator
  - [ ] under a nested ternary operator
  - [ ] when subjected to a cast expression, if that is permitted  

## Escape safety rules

Each test bullet below of the form "Show that *x* is *(ref-)safe-to-escape* *y* but/and no further.", this is intended to require a test that demonstrates that *x* is *(ref-)safe-to-escape* to *y*, and a separate test that demonstrates that *x* is **not** *(ref-)safe-to-escape* the enclosing scope of *y*.

### Parameters
- [ ] Show that a parameter of a `ref struct` type is _ref-safe-to-escape_ to the top level of a method, but no further, no matter the ref mode of the parameter.
- [ ] Show that a `ref`, `in`, or `out` parameter that is not of a `ref struct` type is _ref-safe-to-escape_ from the entire method.
- [ ] Show that the `this` parameter of a struct type that is not a `ref struct` type is _ref-safe-to-escape_ to the top level of a method, but no further.
- [ ] Show that a value parameter that is not a `ref struct` type is _ref-safe-to-escape_ to the top level of a method, but no further.
- [ ] Show that a (reference to a) parameter of `ref struct` type is *safe-to-escape* (by value) from the entire method. Show this for the `this` parameter as well.

### Locals
- [ ] Show that a non-ref local is _ref-safe-to-escape_ to the scope in which it was declared, but no further (for a `ref struct` type and any other type).
- [ ] Show that a ref local variable declaration requires an initializer.
- [ ] Show that a local variable of a `ref struct` type does not require an initializer, in which case it is safe to return. *TODO: The spec needs to say this* 
- [ ] Show that a ref local is _ref-safe-to-escape_ to the same *ref-safe-to-escape* as its initializer, but no further.
- [ ] Show that an rvalue that is a use of a local whose type is a `ref struct` type that is declared as the iterator variable of a `foreach` loop is *safe-to-escape* the same as the loop's expression, and no further.
- [ ] Show that an rvalue that is a use of a local whose type is a `ref struct` type that is declared in a local variable declaration is *safe-to-escape* the same as the variable's initializer, and no further.
- [ ] It is an error if a `ref struct` type is explicitly the type of a pattern variable.
- [ ] It is an error if a `ref struct` type is implicitly the type of a pattern variable.
- [ ] Show that `out` variables are safe to return.
- [ ] Show that `out` variables participate in the no mixing rule.
- [ ] Show that a top-level variable in a script may not be of a `ref struct` type.
  - [ ] Even when the result of deconstruction or pattern-matching. 
- [ ] Show that a nested variable in a script may be of a `ref struct` type.
- [ ] *TODO: Are there other interesting contexts in which local variables can be declared? What about deconstruction?*

### *2017-09-15 Review of the test plan stopped here*

### Fields
- [ ] Show that if `e` is a reference type, that `e.F` is *ref-safe-to-escape* from the entire method.
- [ ] Show that if `e` is a value type, its *ref-safe-to-escape* is the same as the *ref-safe-to-escape* of `e`, but no further.
- [ ] Show that if `e.F` is a `ref struct` type, it is *safe-to-escape* the same as the *safe-to-escape* of `e`, but no further. 

### Multi-operand expression forms
- [ ] Show that given an expression of the form `c ? e1 : e2` where the result is a `ref struct` type, that the *safe-to-escape* of the result is the narrowest among the *safe-to-escape* of `e1` and `e2`.
  - [ ] When `e1` is a `ref struct` type but `e2` is not (the *safe-to-escape* is taken from `e1`)
  - [ ] When `e2` is a `ref struct` type but `e1` is not (the *safe-to-escape* is taken from `e2`) 
  - [ ] When `e1` and `e2` are `ref struct` types (the *safe-to-escape* is the smallest of the two)
  - [ ] When neither `e1` nor `e2` are `ref struct` types (the result is safe to return)
- [ ] For an expression of the form `c ? ref e1 : ref e2`,
  - [ ] Show that the compiler requires that the *ref-safe-to-escape* of `e1` and `e2` agree
  - [ ] Show that the `ref-safe-to-escape* of the result is the same as the *ref-safe-to-escape* of `e1`, but no further.

### Method invocation
- [ ] Show that an **lvalue** resulting from a ref-returning method invocation `e1.M(e2, ...)` is *ref-safe-to-escape* the smallest of the following scopes (but no further) (a pair of positive/negative tests for each of these)
  - [ ] The entire method, if no other rule below applies
  - [ ] The *ref-safe-to-escape* of all `ref` and `out` argument expressions
    - [ ] excluding the receiver
    - [ ] excluding arguments of `ref struct` types
  - [ ] For an `in` parameter for which there is a corresponding expression that is an lvalue, its *ref-safe-to-escape*
  - [ ] For an `in` parameter for which there is a no corresponding expression, the immediately enclosing scope
  - [ ] The *safe-to-escape* of all argument expressions
    - [ ] including the receiver
- [ ] Show that a **value** resulting from a `ref struct` returning method invocation `e1.M(e2, ...)` is *safe-to-escape* the smallest of the following scopes (but no further) (a pair of positive/negative tests for each of these)
  - [ ] The entire method, if no other rule below applies
  - [ ] The *ref-safe-to-escape* of all `ref` and `out` argument expressions
    - [ ] excluding the receiver
    - [ ] excluding arguments of `ref struct` types
  - [ ] For an `in` parameter for which there is a corresponding expression that is an lvalue, its *ref-safe-to-escape*
  - [ ] For an `in` parameter for which there is a no corresponding expression, the immediately enclosing scope
  - [ ] The *safe-to-escape* of all argument expressions
    - [ ] including the receiver
- [ ] *TODO: we should have a rule and tests for an argument expression of the form `ref d.F` where `d` is of type dynamic*
- [ ] The same rules apply to a user-defined operator invocation. Specifically, show that given an expression of the form `e1 + e2` where the result is a `ref struct` type, that the *safe-to-escape* of the result is the narrowest among the *safe-to-escape* of `e1` and `e2`.
  - [ ] When `e1` is a `ref struct` type but `e2` is not (the *safe-to-escape* is taken from `e1`)
  - [ ] When `e2` is a `ref struct` type but `e1` is not (the *safe-to-escape* is taken from `e2`) 
  - [ ] When `e1` and `e2` are `ref struct` types (the *safe-to-escape* is the smallest of the two)
  - [ ] When neither `e1` nor `e2` are `ref struct` types (the result is safe to return)
- [ ] A property invocation that returns a `ref` result follows the method invocation rules: both the `ref-safe-to-escape` is taken from the *safe-to-escape* of the receiver.
- [ ] A property invocation that returns a result of `ref struct` type follows the method invocation rules: the `safe-to-escape` is taken from the *safe-to-escape* of the receiver. 
- [ ] A constructor invocation acts as a method invocation without a receiver; for a constructor of a `ref struct` type, its result is *safe-to-escape* the smallest of the following scopes (but no further) (a pair of positive/negative tests for each of these)
  - [ ] The entire method, if no other rule below applies
  - [ ] The *ref-safe-to-escape* of all `ref` and `out` argument expressions
    - [ ] excluding the receiver
    - [ ] excluding arguments of `ref struct` types
  - [ ] For an `in` parameter for which there is a corresponding expression that is an lvalue, its *ref-safe-to-escape*
  - [ ] For an `in` parameter for which there is a no corresponding expression, the immediately enclosing scope
  - [ ] The *safe-to-escape* of all argument expressions
- [ ] In a statement such as `return ref await e;`, where the type of `e` is a custom value task whose `GetResult()` method is ref-returning, we should be returning the returned ref, not a ref to a copy of its value. In particular, if the returned ref is ref-safe-to-return, then there should be no error.

### stackalloc
- [ ] a `stackalloc` expression is *safe-to-escape* to the top level of the method, but no further.

### default
- [ ] A `default` or `default(T)` expression is *safe-to-escape* from the entire enclosing method (i.e. it is *safe to return*)

### Other
- [ ] A `default` value of a `ref struct` type is safe to return (i.e. escape from the whole method).

### Constraints in expressions
- [ ] (Only if ref reassignment is supported) For a ref reassignment `ref e1 = ref e2`, the *ref-safe-to-escape* of `e2` must be at least as wide a scope as the *ref-safe-to-escape* of `e1`.
  - [ ] Alternately, demonstrate that ref reassignment is not supported. 
- [ ] For a ref return statement `return ref e1`, the *ref-safe-to-escape* of `e1` must be *ref-safe-to-escape* from the entire method.
- [ ] For a return statement `return e1`, the *safe-to-escape* of `e1` must be *safe-to-escape* from the entire method.
- [ ] For an assignment `e1 = e2`, if the type of `e1` is a `ref struct` type, then the *safe-to-escape* of `e2` must be at least as wide a scope as the *safe-to-escape* of `e1`.
- [ ] In a method invocation, the following constraints apply (negative tests required):
  - If there is a `ref` or `out` argument to a `ref struct` type (including the receiver), with *safe-to-escape* E1, then
    - [ ] no `ref` or `out` argument (excluding the receiver and arguments of `ref struct` types) may have a narrower *ref-safe-to-escape* than E1; and
    - [ ] no argument (including the receiver) may have a narrower *safe-to-escape* than E1.

</Description>
        <CreatedDate>09/06/2017</CreatedDate>
        <ClosedDate>06/09/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder.ValueChecks.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/OverloadResolution/OverloadResolution.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/SyntaxNodeExtensions.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenRefReadOnlyParametersTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenRefReadonlyReturnTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/NameOfTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/RefLocalsAndReturnsTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/SemanticErrorTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/StackAllocSpanExpressionsTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/UnsafeTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/VarianceTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/RefReadonlyReturnsTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/RefReadonlyTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>22225</IssueID>
    <Title>Fix unit tests for IStopStatement and IEndStatement and make the APIs…</Title>
    <Description>… public again

Fixes #21297 and #22004</Description>
    <CreatedDate>20/09/2017</CreatedDate>
    <ClosedDate>26/09/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>21297</IssueID>
        <Title>IStopStatement API Review </Title>
        <Description>https://github.com/dotnet/roslyn/blob/features/ioperation/src/Compilers/Core/Portable/Operations/IStopStatement.cs 

Why we need this ? 

cc @AlekseyTs  , @dotnet/analyzer-ioperation </Description>
        <CreatedDate>03/08/2017</CreatedDate>
        <ClosedDate>26/09/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22004</IssueID>
        <Title>API review for IEndStatement</Title>
        <Description>https://github.com/dotnet/roslyn/blob/features/ioperation/src/Compilers/Core/Portable/Operations/IEndStatement.cs

Add unit tests when making public</Description>
        <CreatedDate>09/09/2017</CreatedDate>
        <ClosedDate>26/09/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/Core/Portable/Generated/Operations.xml.Generated.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IEndStatement.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IStopStatement.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationCloner.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationKind.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationVisitor.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/OperationTreeVerifier.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/TestOperationWalker.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>22222</IssueID>
    <Title>Add unit tests for ITypeOfExpression and ISizeOfExpression and make A…</Title>
    <Description>…PIs public again

Fixes #22003 and #21296</Description>
    <CreatedDate>20/09/2017</CreatedDate>
    <ClosedDate>20/09/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>22003</IssueID>
        <Title>API review for ITypeOfExpression</Title>
        <Description>https://github.com/dotnet/roslyn/blob/features/ioperation/src/Compilers/Core/Portable/Operations/ITypeOfExpression.cs

Add units tests when making public.</Description>
        <CreatedDate>09/09/2017</CreatedDate>
        <ClosedDate>20/09/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>21296</IssueID>
        <Title>ISizeOfExpression API Review</Title>
        <Description>https://github.com/dotnet/roslyn/blob/features/ioperation/src/Compilers/Core/Portable/Operations/ISizeOfExpression.cs

- The API should derive from IOperation rather than ITypeOperationExpression 
- Why we need ITypeOperationExpression  ?</Description>
        <CreatedDate>03/08/2017</CreatedDate>
        <ClosedDate>20/09/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IPatternSwitchCase.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_ISizeOfExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_ITypeOfExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/AnonymousTypesSemanticsTests.cs</File>
      <File>src/Compilers/Core/Portable/Generated/Operations.xml.Generated.cs</File>
      <File>src/Compilers/Core/Portable/Operations/ISizeOfExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/ITypeOfExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationCloner.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationKind.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationVisitor.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/OperationTreeVerifier.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/TestOperationWalker.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>22210</IssueID>
    <Title>Add IOperation unit tests for try/catch statements and make the APIs …</Title>
    <Description>…public again

Fixes #22008 and #21277

We also decided to make some changes to ICatchClause see https://github.com/dotnet/roslyn/issues/21277#issuecomment-330663344 and https://github.com/dotnet/roslyn/issues/21277#issuecomment-331310258
</Description>
    <CreatedDate>19/09/2017</CreatedDate>
    <ClosedDate>29/09/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>22008</IssueID>
        <Title>API review for ITryStatement</Title>
        <Description>https://github.com/dotnet/roslyn/blob/features/ioperation/src/Compilers/Core/Portable/Operations/ITryStatement.cs

Add unit tests when making the APIs public</Description>
        <CreatedDate>09/09/2017</CreatedDate>
        <ClosedDate>29/09/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>21277</IssueID>
        <Title>ICatchClause API review</Title>
        <Description>https://github.com/dotnet/roslyn/blob/features/ioperation/src/Compilers/Core/Portable/Operations/ICatchClause.cs 

- We should get rid of CatchType here</Description>
        <CreatedDate>03/08/2017</CreatedDate>
        <ClosedDate>29/09/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Operations/CSharpOperationFactory.cs</File>
      <File>src/Compilers/CSharp/Portable/Operations/CSharpOperationFactory_Methods.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IWhileUntilLoopStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_TryCatch.cs</File>
      <File>src/Compilers/Core/Portable/Generated/Operations.xml.Generated.cs</File>
      <File>src/Compilers/Core/Portable/Operations/ICatchClause.cs</File>
      <File>src/Compilers/Core/Portable/Operations/ITryStatement.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationCloner.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationKind.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationVisitor.cs</File>
      <File>src/Compilers/Test/Utilities/CSharp/CSharpTestBase.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/OperationTreeVerifier.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/TestOperationWalker.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>22134</IssueID>
    <Title>Add regression tests for 15.3 closure conversion crashes</Title>
    <Description>Fixes #21811
Fixes #21645
Fixes #21543</Description>
    <CreatedDate>14/09/2017</CreatedDate>
    <ClosedDate>15/09/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>21811</IssueID>
        <Title>csc.exe crashes with exit code -2146232797</Title>
        <Description>**Version Used**: 

Roslyn included in VS 2017 15.3.3

**Steps to Reproduce**:

Compile the following code:
```c#
    class Program
    {
        static void Main(string[] args)
        {
            var history = new Queue&lt;long&gt;();
            Enumerable.Range(0, 5)
                .Select(i =&gt;
                {
                    history.Enqueue(i);
                    return Test(i);

                    bool Test(int v)
                    {
                        history.Dequeue();
                        return Square(v) &gt; 5;
                    }

                    int Square(int w)
                    {
                        return w * w;
                    }
                });
        }
    }
```
**Expected Behavior**:

Since this is valid C# syntax the code should compile

**Actual Behavior**:

csc.exe crashes with exit code -2146232797</Description>
        <CreatedDate>30/08/2017</CreatedDate>
        <ClosedDate>15/09/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>21645</IssueID>
        <Title>Nested local functions causes KeyNotFoundException</Title>
        <Description>**Version Used**: 
Microsoft Visual Studio Enterprise 2017 
Version 15.3.1
VisualStudio.15.Release/15.3.1+26730.8
Microsoft .NET Framework
Version 4.7.02046

**Steps to Reproduce**:

1. Create a new C# project
2. Add the following code
```C#
public class Class1
{
    private void Test()
    {
        bool outside = true;

        void Inner() //This can also be a lambda (ie. Action action = () =&gt; { ... };)
        {
            void Bar()
            {
            }

            void Foo()
            {
                Bar();

                bool captured = outside;
            }
        }
    }
}
```
3. Compile with VS 2017 15.3.1 

Example repository available [here](https://github.com/Keboo/NestedInnerFunctionsBug).
This same code does compile with VS 2017 v15.2 (26430.15 release).

**Expected Behavior**:
Compile succeeds without error.

**Actual Behavior**: 
CSC.exe crash with error code -2146232797

MSBuild output:
```
1&gt;  Task "Csc"
1&gt;    C:\Program Files (x86)\Microsoft Visual Studio\2017\Enterprise\MSBuild\15.0\Bin\Roslyn\csc.exe /noconfig /unsafe- /checked- /nowarn:1701,1702,1705,1701,1702,2008 /nostdlib+ /errorreport:prompt /warn:4 /define:TRACE;DEBUG;NETSTANDARD1_4 /errorendlocation /preferreduilang:en-US /reference:C:\Users\Kevin\.nuget\packages\microsoft.win32.primitives\4.3.0\ref\netstandard1.3\Microsoft.Win32.Primitives.dll /reference:C:\Users\Kevin\.nuget\packages\system.appcontext\4.3.0\ref\netstandard1.3\System.AppContext.dll /reference:C:\Users\Kevin\.nuget\packages\system.collections.concurrent\4.3.0\ref\netstandard1.3\System.Collections.Concurrent.dll /reference:C:\Users\Kevin\.nuget\packages\system.collections\4.3.0\ref\netstandard1.3\System.Collections.dll /reference:C:\Users\Kevin\.nuget\packages\system.console\4.3.0\ref\netstandard1.3\System.Console.dll /reference:C:\Users\Kevin\.nuget\packages\system.diagnostics.debug\4.3.0\ref\netstandard1.3\System.Diagnostics.Debug.dll /reference:C:\Users\Kevin\.nuget\packages\system.diagnostics.tools\4.3.0\ref\netstandard1.0\System.Diagnostics.Tools.dll /reference:C:\Users\Kevin\.nuget\packages\system.diagnostics.tracing\4.3.0\ref\netstandard1.3\System.Diagnostics.Tracing.dll /reference:C:\Users\Kevin\.nuget\packages\system.globalization.calendars\4.3.0\ref\netstandard1.3\System.Globalization.Calendars.dll /reference:C:\Users\Kevin\.nuget\packages\system.globalization\4.3.0\ref\netstandard1.3\System.Globalization.dll /reference:C:\Users\Kevin\.nuget\packages\system.io.compression\4.3.0\ref\netstandard1.3\System.IO.Compression.dll /reference:C:\Users\Kevin\.nuget\packages\system.io.compression.zipfile\4.3.0\ref\netstandard1.3\System.IO.Compression.ZipFile.dll /reference:C:\Users\Kevin\.nuget\packages\system.io\4.3.0\ref\netstandard1.3\System.IO.dll /reference:C:\Users\Kevin\.nuget\packages\system.io.filesystem\4.3.0\ref\netstandard1.3\System.IO.FileSystem.dll /reference:C:\Users\Kevin\.nuget\packages\system.io.filesystem.primitives\4.3.0\ref\netstandard1.3\System.IO.FileSystem.Primitives.dll /reference:C:\Users\Kevin\.nuget\packages\system.linq\4.3.0\ref\netstandard1.0\System.Linq.dll /reference:C:\Users\Kevin\.nuget\packages\system.linq.expressions\4.3.0\ref\netstandard1.3\System.Linq.Expressions.dll /reference:C:\Users\Kevin\.nuget\packages\system.net.http\4.3.0\ref\netstandard1.3\System.Net.Http.dll /reference:C:\Users\Kevin\.nuget\packages\system.net.primitives\4.3.0\ref\netstandard1.3\System.Net.Primitives.dll /reference:C:\Users\Kevin\.nuget\packages\system.net.sockets\4.3.0\ref\netstandard1.3\System.Net.Sockets.dll /reference:C:\Users\Kevin\.nuget\packages\system.objectmodel\4.3.0\ref\netstandard1.3\System.ObjectModel.dll /reference:C:\Users\Kevin\.nuget\packages\system.reflection\4.3.0\ref\netstandard1.3\System.Reflection.dll /reference:C:\Users\Kevin\.nuget\packages\system.reflection.extensions\4.3.0\ref\netstandard1.0\System.Reflection.Extensions.dll /reference:C:\Users\Kevin\.nuget\packages\system.reflection.primitives\4.3.0\ref\netstandard1.0\System.Reflection.Primitives.dll /reference:C:\Users\Kevin\.nuget\packages\system.resources.resourcemanager\4.3.0\ref\netstandard1.0\System.Resources.ResourceManager.dll /reference:C:\Users\Kevin\.nuget\packages\system.runtime\4.3.0\ref\netstandard1.3\System.Runtime.dll /reference:C:\Users\Kevin\.nuget\packages\system.runtime.extensions\4.3.0\ref\netstandard1.3\System.Runtime.Extensions.dll /reference:C:\Users\Kevin\.nuget\packages\system.runtime.handles\4.3.0\ref\netstandard1.3\System.Runtime.Handles.dll /reference:C:\Users\Kevin\.nuget\packages\system.runtime.interopservices\4.3.0\ref\netstandard1.3\System.Runtime.InteropServices.dll /reference:C:\Users\Kevin\.nuget\packages\system.runtime.interopservices.runtimeinformation\4.3.0\ref\netstandard1.1\System.Runtime.InteropServices.RuntimeInformation.dll /reference:C:\Users\Kevin\.nuget\packages\system.runtime.numerics\4.3.0\ref\netstandard1.1\System.Runtime.Numerics.dll /reference:C:\Users\Kevin\.nuget\packages\system.security.cryptography.algorithms\4.3.0\ref\netstandard1.4\System.Security.Cryptography.Algorithms.dll /reference:C:\Users\Kevin\.nuget\packages\system.security.cryptography.encoding\4.3.0\ref\netstandard1.3\System.Security.Cryptography.Encoding.dll /reference:C:\Users\Kevin\.nuget\packages\system.security.cryptography.primitives\4.3.0\ref\netstandard1.3\System.Security.Cryptography.Primitives.dll /reference:C:\Users\Kevin\.nuget\packages\system.security.cryptography.x509certificates\4.3.0\ref\netstandard1.4\System.Security.Cryptography.X509Certificates.dll /reference:C:\Users\Kevin\.nuget\packages\system.text.encoding\4.3.0\ref\netstandard1.3\System.Text.Encoding.dll /reference:C:\Users\Kevin\.nuget\packages\system.text.encoding.extensions\4.3.0\ref\netstandard1.3\System.Text.Encoding.Extensions.dll /reference:C:\Users\Kevin\.nuget\packages\system.text.regularexpressions\4.3.0\ref\netstandard1.3\System.Text.RegularExpressions.dll /reference:C:\Users\Kevin\.nuget\packages\system.threading\4.3.0\ref\netstandard1.3\System.Threading.dll /reference:C:\Users\Kevin\.nuget\packages\system.threading.tasks\4.3.0\ref\netstandard1.3\System.Threading.Tasks.dll /reference:C:\Users\Kevin\.nuget\packages\system.threading.timer\4.3.0\ref\netstandard1.2\System.Threading.Timer.dll /reference:C:\Users\Kevin\.nuget\packages\system.xml.readerwriter\4.3.0\ref\netstandard1.3\System.Xml.ReaderWriter.dll /reference:C:\Users\Kevin\.nuget\packages\system.xml.xdocument\4.3.0\ref\netstandard1.3\System.Xml.XDocument.dll /debug+ /debug:portable /filealign:512 /nologo /optimize- /out:obj\Debug\netstandard1.4\NestedInnerFunctionsBug.dll /ruleset:"C:\Program Files (x86)\Microsoft Visual Studio\2017\Enterprise\Team Tools\Static Analysis Tools\\Rule Sets\MinimumRecommendedRules.ruleset" /target:library /warnaserror- /utf8output /deterministic+ Class1.cs "C:\Users\Kevin\AppData\Local\Temp\.NETStandard,Version=v1.4.AssemblyAttributes.cs" obj\Debug\netstandard1.4\\TemporaryGeneratedFile_E7A71F73-0F8D-4B9B-B56E-8E70B10BC5D3.cs obj\Debug\netstandard1.4\\TemporaryGeneratedFile_036C0B5B-1481-4323-8D20-8F5ADCB23D92.cs obj\Debug\netstandard1.4\\TemporaryGeneratedFile_5937a670-0e60-4077-877b-f7221da3dda1.cs obj\Debug\netstandard1.4\NestedInnerFunctionsBug.AssemblyInfo.cs
1&gt;    Using shared compilation with compiler from directory: C:\Program Files (x86)\Microsoft Visual Studio\2017\Enterprise\MSBuild\15.0\Bin\Roslyn
1&gt;    C:\Program Files (x86)\Microsoft Visual Studio\2017\Enterprise\MSBuild\15.0\Bin\Roslyn\Microsoft.CSharp.Core.targets(84,5): error MSB6006: "csc.exe" exited with code -2146232797.
1&gt;  Done executing task "Csc" -- FAILED.
```

Event view log:
```
Application: csc.exe
Framework Version: v4.0.30319
Description: The application requested process termination through System.Environment.FailFast(string message).
Message: System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.
   at System.ThrowHelper.ThrowKeyNotFoundException()
   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.RewriteLambdaOrLocalFunction(IBoundLambdaOrFunction node, ClosureKind&amp; closureKind, NamedTypeSymbol&amp; translatedLambdaContainer, LambdaFrame&amp; containerAsFrame, BoundNode&amp; lambdaScope, DebugId&amp; topLevelMethodId, DebugId&amp; lambdaId)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.VisitLocalFunctionStatement(BoundLocalFunctionStatement node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.RewriteBlock(BoundBlock node, ArrayBuilder`1 prologue, ArrayBuilder`1 newLocals)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.VisitBlock(BoundBlock node)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.RewriteLambdaOrLocalFunction(IBoundLambdaOrFunction node, ClosureKind&amp; closureKind, NamedTypeSymbol&amp; translatedLambdaContainer, LambdaFrame&amp; containerAsFrame, BoundNode&amp; lambdaScope, DebugId&amp; topLevelMethodId, DebugId&amp; lambdaId)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.VisitLocalFunctionStatement(BoundLocalFunctionStatement node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.RewriteBlock(BoundBlock node, ArrayBuilder`1 prologue, ArrayBuilder`1 newLocals)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.IntroduceFrame(BoundNode node, LambdaFrame frame, Func`3 F)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.VisitBlock(BoundBlock node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.Rewrite(BoundStatement loweredBody, NamedTypeSymbol thisType, ParameterSymbol thisParameter, MethodSymbol method, Int32 methodOrdinal, MethodSymbol substitutedSourceMethod, ArrayBuilder`1 lambdaDebugInfoBuilder, ArrayBuilder`1 closureDebugInfoBuilder, VariableSlotAllocator slotAllocatorOpt, TypeCompilationState compilationState, DiagnosticBag diagnostics, HashSet`1 assignLocals)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.LowerBodyOrInitializer(MethodSymbol method, Int32 methodOrdinal, BoundStatement body, SynthesizedSubmissionFields previousSubmissionFields, TypeCompilationState compilationState, Boolean instrumentForDynamicAnalysis, DebugDocumentProvider debugDocumentProvider, ImmutableArray`1&amp; dynamicAnalysisSpans, DiagnosticBag diagnostics, VariableSlotAllocator&amp; lazyVariableSlotAllocator, ArrayBuilder`1 lambdaDebugInfoBuilder, ArrayBuilder`1 closureDebugInfoBuilder, StateMachineTypeSymbol&amp; stateMachineTypeOpt)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethod(MethodSymbol methodSymbol, Int32 methodOrdinal, ProcessedFieldInitializers&amp; processedInitializers, SynthesizedSubmissionFields previousSubmissionFields, TypeCompilationState compilationState)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(NamedTypeSymbol containingType)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.&lt;&gt;c__DisplayClass21_0.&lt;CompileNamedTypeAsTask&gt;b__0()
Stack:
   at System.Environment.FailFast(System.String, System.Exception)
   at Microsoft.CodeAnalysis.FatalError.Report(System.Exception, System.Action`1&lt;System.Exception&gt;)
   at Microsoft.CodeAnalysis.FatalError.ReportUnlessCanceled(System.Exception)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler+&lt;&gt;c__DisplayClass21_0.&lt;CompileNamedTypeAsTask&gt;b__0()
   at System.ThrowHelper.ThrowKeyNotFoundException()
   at System.Collections.Generic.Dictionary`2[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089],[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].get_Item(System.__Canon)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.RewriteLambdaOrLocalFunction(Microsoft.CodeAnalysis.CSharp.IBoundLambdaOrFunction, Microsoft.CodeAnalysis.CSharp.ClosureKind ByRef, Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol ByRef, Microsoft.CodeAnalysis.CSharp.LambdaFrame ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef, Microsoft.CodeAnalysis.CodeGen.DebugId ByRef, Microsoft.CodeAnalysis.CodeGen.DebugId ByRef)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.VisitLocalFunctionStatement(Microsoft.CodeAnalysis.CSharp.BoundLocalFunctionStatement)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.Visit(Microsoft.CodeAnalysis.CSharp.BoundNode)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.RewriteBlock(Microsoft.CodeAnalysis.CSharp.BoundBlock, Microsoft.CodeAnalysis.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.CSharp.BoundExpression&gt;, Microsoft.CodeAnalysis.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol&gt;)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.VisitBlock(Microsoft.CodeAnalysis.CSharp.BoundBlock)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.RewriteLambdaOrLocalFunction(Microsoft.CodeAnalysis.CSharp.IBoundLambdaOrFunction, Microsoft.CodeAnalysis.CSharp.ClosureKind ByRef, Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol ByRef, Microsoft.CodeAnalysis.CSharp.LambdaFrame ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef, Microsoft.CodeAnalysis.CodeGen.DebugId ByRef, Microsoft.CodeAnalysis.CodeGen.DebugId ByRef)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.VisitLocalFunctionStatement(Microsoft.CodeAnalysis.CSharp.BoundLocalFunctionStatement)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.Visit(Microsoft.CodeAnalysis.CSharp.BoundNode)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.RewriteBlock(Microsoft.CodeAnalysis.CSharp.BoundBlock, Microsoft.CodeAnalysis.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.CSharp.BoundExpression&gt;, Microsoft.CodeAnalysis.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol&gt;)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.IntroduceFrame(Microsoft.CodeAnalysis.CSharp.BoundNode, Microsoft.CodeAnalysis.CSharp.LambdaFrame, System.Func`3&lt;Microsoft.CodeAnalysis.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.CSharp.BoundExpression&gt;,Microsoft.CodeAnalysis.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol&gt;,Microsoft.CodeAnalysis.CSharp.BoundNode&gt;)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.VisitBlock(Microsoft.CodeAnalysis.CSharp.BoundBlock)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.Visit(Microsoft.CodeAnalysis.CSharp.BoundNode)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.Rewrite(Microsoft.CodeAnalysis.CSharp.BoundStatement, Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol, Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol, Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol, Int32, Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol, Microsoft.CodeAnalysis.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.CodeGen.LambdaDebugInfo&gt;, Microsoft.CodeAnalysis.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.CodeGen.ClosureDebugInfo&gt;, Microsoft.CodeAnalysis.CodeGen.VariableSlotAllocator, Microsoft.CodeAnalysis.CSharp.TypeCompilationState, Microsoft.CodeAnalysis.DiagnosticBag, System.Collections.Generic.HashSet`1&lt;Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol&gt;)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.LowerBodyOrInitializer(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol, Int32, Microsoft.CodeAnalysis.CSharp.BoundStatement, Microsoft.CodeAnalysis.CSharp.SynthesizedSubmissionFields, Microsoft.CodeAnalysis.CSharp.TypeCompilationState, Boolean, Microsoft.CodeAnalysis.CodeGen.DebugDocumentProvider, System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.CodeGen.SourceSpan&gt; ByRef, Microsoft.CodeAnalysis.DiagnosticBag, Microsoft.CodeAnalysis.CodeGen.VariableSlotAllocator ByRef, Microsoft.CodeAnalysis.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.CodeGen.LambdaDebugInfo&gt;, Microsoft.CodeAnalysis.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.CodeGen.ClosureDebugInfo&gt;, Microsoft.CodeAnalysis.CSharp.StateMachineTypeSymbol ByRef)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethod(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol, Int32, ProcessedFieldInitializers ByRef, Microsoft.CodeAnalysis.CSharp.SynthesizedSubmissionFields, Microsoft.CodeAnalysis.CSharp.TypeCompilationState)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler+&lt;&gt;c__DisplayClass21_0.&lt;CompileNamedTypeAsTask&gt;b__0()
   at Roslyn.Utilities.UICultureUtilities+&lt;&gt;c__DisplayClass5_0.&lt;WithCurrentUICulture&gt;b__0()
   at System.Threading.Tasks.Task.Execute()
   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)
   at System.Threading.Tasks.Task.ExecuteEntry(Boolean)
   at System.Threading.ThreadPoolWorkQueue.Dispatch()
```

Potentially related to #17814 and #16895?</Description>
        <CreatedDate>21/08/2017</CreatedDate>
        <ClosedDate>15/09/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>21543</IssueID>
        <Title>Compiler crashes in VS15.3, analyzer throws NullReferenceException in master, when call local function from nested lambda</Title>
        <Description>I found the issue #16895 that mentioning compiler crash caused by local function and nested lambda. But  I can build that issue's code successfully in VS15.3 so I think this issue is different issue.

**Version Used**: VS2017 15.3.0, master(d67a95f1c01dc7064a47caecf02326a060292649)([demo at  sharplab.io](https://sharplab.io/#v2:EYLgtghgzgLgpgJwDQBMQGoA+ABADAAmwEYBuAWAChLsAmfABQQHsBzBCMSgb0vz/1gQYASwDGhACz4AsnBgALJigAUxOhFEimAOwCU+LvgC+lXv0Ejx2KdIjDty3Wb48K/d/nsx8ANwgAbAFc4fABefFxyNw8+WQUlZUcwgD5nD1cYmP8mUQDHKMyPa3xs3P9HNMKMwsyAYR0oJn84ADoAdQRheAAZezhlPyC4XQKamLjFFSTQ1Oix92r5zNK8kcr5ozW5mpNt903Rvl3doA===))

**Steps to Reproduce**:
```cs
using System;

class Program
{
    static void Method(Action action) { }

    static void Main()
    {
        int value = 0;
        Method(() =&gt;
        {
            local();
            void local()
            {
                Console.WriteLine(value);
                Method(() =&gt;
                {
                    local();
                });
            }
        });
    }
}
```

**Expected Behavior**:
I can build the above code without any errors and warnings.

**Actual Behavior**:
If I build the above code in VS15.3, the build failed due to `"csc.exe" exited with code -2146232797`.
I found a stack trace in `eventvwr.msc` -&gt; `Windows Logs` -&gt; `Application` -&gt; `.NET Runtime`:
```
Application: csc.exe
Framework Version: v4.0.30319
Description: The application requested process termination through System.Environment.FailFast(string message).
Message: System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.
   at System.ThrowHelper.ThrowKeyNotFoundException()
   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitLocalLoad(BoundLocal local, Boolean used)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitExpression(BoundExpression expression, Boolean used)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitDelegateCreation(BoundExpression node, BoundExpression receiver, Boolean isExtensionMethod, MethodSymbol method, TypeSymbol delegateType, Boolean used)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitDelegateCreationExpression(BoundDelegateCreationExpression expression, Boolean used)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitExpression(BoundExpression expression, Boolean used)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitArguments(ImmutableArray`1 arguments, ImmutableArray`1 parameters)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitCallExpression(BoundCall call, UseKind useKind)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitExpressionCoreWithStackGuard(BoundExpression expression, Boolean used)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitExpression(BoundExpression expression, Boolean used)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitStatementAndCountInstructions(BoundStatement statement)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitSequencePointStatement(BoundSequencePoint node)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitStatements(ImmutableArray`1 statements)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitBlock(BoundBlock block)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.GenerateImpl()
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.GenerateMethodBody(PEModuleBuilder moduleBuilder, MethodSymbol method, Int32 methodOrdinal, BoundStatement block, ImmutableArray`1 lambdaDebugInfo, ImmutableArray`1 closureDebugInfo, StateMachineTypeSymbol stateMachineTypeOpt, VariableSlotAllocator variableSlotAllocatorOpt, DiagnosticBag diagnostics, DebugDocumentProvider debugDocumentProvider, ImportChain importChainOpt, Boolean emittingPdb, Boolean emitTestCoverageData, ImmutableArray`1 dynamicAnalysisSpans)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileSynthesizedMethods(TypeCompilationState compilationState)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(NamedTypeSymbol containingType)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.&lt;&gt;c__DisplayClass21_0.&lt;CompileNamedTypeAsTask&gt;b__0()
Stack:
   at System.Environment.FailFast(System.String, System.Exception)
   at Microsoft.CodeAnalysis.FatalError.Report(System.Exception, System.Action`1&lt;System.Exception&gt;)
   at Microsoft.CodeAnalysis.FatalError.ReportUnlessCanceled(System.Exception)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler+&lt;&gt;c__DisplayClass21_0.&lt;CompileNamedTypeAsTask&gt;b__0()
   at System.ThrowHelper.ThrowKeyNotFoundException()
   at System.Collections.Generic.Dictionary`2[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089],[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].get_Item(System.__Canon)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitLocalLoad(Microsoft.CodeAnalysis.CSharp.BoundLocal, Boolean)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitExpression(Microsoft.CodeAnalysis.CSharp.BoundExpression, Boolean)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitDelegateCreation(Microsoft.CodeAnalysis.CSharp.BoundExpression, Microsoft.CodeAnalysis.CSharp.BoundExpression, Boolean, Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol, Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, Boolean)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitDelegateCreationExpression(Microsoft.CodeAnalysis.CSharp.BoundDelegateCreationExpression, Boolean)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitExpression(Microsoft.CodeAnalysis.CSharp.BoundExpression, Boolean)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitArguments(System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.CSharp.BoundExpression&gt;, System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol&gt;)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitCallExpression(Microsoft.CodeAnalysis.CSharp.BoundCall, UseKind)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitExpressionCoreWithStackGuard(Microsoft.CodeAnalysis.CSharp.BoundExpression, Boolean)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitExpression(Microsoft.CodeAnalysis.CSharp.BoundExpression, Boolean)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitStatementAndCountInstructions(Microsoft.CodeAnalysis.CSharp.BoundStatement)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitSequencePointStatement(Microsoft.CodeAnalysis.CSharp.BoundSequencePoint)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitStatements(System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.CSharp.BoundStatement&gt;)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitBlock(Microsoft.CodeAnalysis.CSharp.BoundBlock)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.GenerateImpl()
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.GenerateMethodBody(Microsoft.CodeAnalysis.CSharp.Emit.PEModuleBuilder, Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol, Int32, Microsoft.CodeAnalysis.CSharp.BoundStatement, System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.CodeGen.LambdaDebugInfo&gt;, System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.CodeGen.ClosureDebugInfo&gt;, Microsoft.CodeAnalysis.CSharp.StateMachineTypeSymbol, Microsoft.CodeAnalysis.CodeGen.VariableSlotAllocator, Microsoft.CodeAnalysis.DiagnosticBag, Microsoft.CodeAnalysis.CodeGen.DebugDocumentProvider, Microsoft.CodeAnalysis.CSharp.ImportChain, Boolean, Boolean, System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.CodeGen.SourceSpan&gt;)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileSynthesizedMethods(Microsoft.CodeAnalysis.CSharp.TypeCompilationState)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler+&lt;&gt;c__DisplayClass21_0.&lt;CompileNamedTypeAsTask&gt;b__0()
   at Roslyn.Utilities.UICultureUtilities+&lt;&gt;c__DisplayClass5_0.&lt;WithCurrentUICulture&gt;b__0()
   at System.Threading.Tasks.Task.Execute()
   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)
   at System.Threading.Tasks.Task.ExecuteEntry(Boolean)
   at System.Threading.ThreadPoolWorkQueue.Dispatch()
```

If I build the above code in master, the build succeeded but I get the following warning(same warning occurs 5 times):
```
warning AD0001: Analyzer 'Microsoft.CodeAnalysis.CSharp.ValidateFormatString.CSharpValidateFormatStringDiagnosticAnalyzer' threw an exception of type 'System.NullReferenceException' with message 'Object reference not set to an instance of an object.'.
```</Description>
        <CreatedDate>16/08/2017</CreatedDate>
        <ClosedDate>15/09/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenLocalFunctionTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>21407</IssueID>
    <Title>IBinaryOperatorExpression, IUnaryOperatorExpression and IIncrementExp…</Title>
    <Description>…ression API changes

This implements a bunch of changes to the IOperation representation for binary operator, unary operator and increment expressions.

1. #8834: Simplify `UnaryOperatorKind` to only contain the operator kind values instead of a matrix of operator and operand kinds.
2. #8835: Simplify `BinaryOperatorKind` in similar manner as above.
3. #8825: Add `IUnaryOperatorExpression.IsChecked` flag. Cyrus has already added the `IUnaryOperatorExpression.IsLifted` flag.
4. #8846: Add `IBinaryOperatorExpression.IsChecked` and `IBinaryOperatorExpression.IsCompareText` flags Cyrus has already added the `IBinaryOperatorExpression.IsLifted` flag.
5. #21283: Add `IIncrementExpression.IsDecrement` and `IIncrementExpression.IsPostfix` flags and remove PostFix/Prefix Increment/Decrement from `UnaryOperatorKind` enum.

This change also fixes #8848 and #8843 as the matrix operation kind enums no longer exist.</Description>
    <CreatedDate>09/08/2017</CreatedDate>
    <ClosedDate>26/08/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>8834</IssueID>
        <Title>IOperation: UnaryOperationKind feels unnecessary complicated</Title>
        <Description>Why are we going through the trouble of combining operator kind with type of arguments? Does this really make things easier for consumers? It feels that operator kind is sufficient enough and the type of the operand can be accessed from the Operand.
</Description>
        <CreatedDate>17/02/2016</CreatedDate>
        <ClosedDate>26/08/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>8835</IssueID>
        <Title>IOperation: BinaryOperationKind feels unnecessary complicated</Title>
        <Description>The enum has more than a hundred members!
Why are we going through the trouble of combining operator kind with type of arguments? Does this really make things easier for consumers? It feels that operator kind is sufficient enough and the type of the operand can be accessed from the Operand.
</Description>
        <CreatedDate>17/02/2016</CreatedDate>
        <ClosedDate>26/08/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>8825</IssueID>
        <Title>IOperation: It looks like some unary operator semantics cannot be represented via IUnaryOperatorExpression </Title>
        <Description>It looks like Nullable lifting isn't explicitly repretesented.
It looks like checked/unchecked semantics cannot be represented.
</Description>
        <CreatedDate>17/02/2016</CreatedDate>
        <ClosedDate>26/08/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>8846</IssueID>
        <Title>IOperation: It looks like some binary operator semantics cannot be represented via IBinaryOperatorExpression</Title>
        <Description>It looks like Nullable lifting isn't explicitly repretesented.
It looks like checked/unchecked semantics cannot be represented.
It looks like Option Compare Text for String or Object comparison cannot be represented.
</Description>
        <CreatedDate>17/02/2016</CreatedDate>
        <ClosedDate>26/08/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>21283</IssueID>
        <Title>IIncrementExpression API Review</Title>
        <Description>https://github.com/dotnet/roslyn/blob/features/ioperation/src/Compilers/Core/Portable/Operations/IIncrementExpression.cs 

- We should flatten the list of IncrementOperationKind  </Description>
        <CreatedDate>03/08/2017</CreatedDate>
        <ClosedDate>26/08/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>8848</IssueID>
        <Title>IOperation: VB - BoundUserDefinedBinaryOperator implementation of IBinaryOperatorExpression.BinaryOperationKind doesn't handle some operators</Title>
        <Description>It looks like BinaryOperatorKind.Power is not handled and will cause UnexpectedValue exception.
I didn't confirm that all other operators are handled properly.
</Description>
        <CreatedDate>17/02/2016</CreatedDate>
        <ClosedDate>26/08/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>8843</IssueID>
        <Title>IOperation: VB - BoundBinaryOperator it looks like implementation of IBinaryOperatorExpression.BinaryOperationKind is not handling all possible scenarios</Title>
        <Description>```
        Private ReadOnly Property IBinaryKind As BinaryOperationKind Implements IBinaryOperatorExpression.BinaryOperationKind
            Get
                Return DeriveBinaryOperationKind(Me.OperatorKind, Me.Left)
            End Get
        End Property
```

Glancing over code in DeriveBinaryOperationKind (the list might be incomplete):
- It looks like operands of Nullable type are not handled;
- It looks like LessThanOrEqual, GreaterThanOrEqual, LessThan, GreaterThan operators for strings aren't handled.
</Description>
        <CreatedDate>17/02/2016</CreatedDate>
        <ClosedDate>26/08/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Operations/CSharpOperationFactory.cs</File>
      <File>src/Compilers/CSharp/Portable/Operations/CSharpOperationFactory_Methods.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IBinaryOperatorExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IConversionExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IForEachLoopStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IForLoopStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IIfStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_ILocalFunctionStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IParameterReferenceExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IPatternSwitchCase.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_ISymbolInitializer.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IUnaryOperatorExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IWhileUntilLoopStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_InvalidExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_InvalidStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/ObjectAndCollectionInitializerTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/OperatorTests.cs</File>
      <File>src/Compilers/Core/Portable/Compilation/Expression.cs</File>
      <File>src/Compilers/Core/Portable/Generated/Operations.xml.Generated.cs</File>
      <File>src/Compilers/Core/Portable/Operations/BinaryOperandsKind.cs</File>
      <File>src/Compilers/Core/Portable/Operations/BinaryOperationKind.cs</File>
      <File>src/Compilers/Core/Portable/Operations/BinaryOperatorKind.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IBinaryOperatorExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/ICompoundAssignmentExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IIncrementExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IRelationalCaseClause.cs</File>
      <File>src/Compilers/Core/Portable/Operations/ISingleValueCaseClause.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IUnaryOperatorExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationCloner.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationFactory.cs</File>
      <File>src/Compilers/Core/Portable/Operations/SimpleBinaryOperationKind.cs</File>
      <File>src/Compilers/Core/Portable/Operations/SimpleUnaryOperationKind.cs</File>
      <File>src/Compilers/Core/Portable/Operations/UnaryAndBinaryOperationExtensions.cs</File>
      <File>src/Compilers/Core/Portable/Operations/UnaryOperandKind.cs</File>
      <File>src/Compilers/Core/Portable/Operations/UnaryOperationKind.cs</File>
      <File>src/Compilers/Core/Portable/Operations/UnaryOperatorKind.cs</File>
      <File>src/Features/Core/Portable/UseThrowExpression/AbstractUseThrowExpressionDiagnosticAnalyzer.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/OperationTreeVerifier.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/TestOperationWalker.cs</File>
      <File>src/Test/Utilities/Portable/Diagnostics/OperationTestAnalyzer.cs</File>
      <File>src/VisualStudio/Core/Next/Remote/ServiceHubRemoteHostClient.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>21367</IssueID>
    <Title>Remove RemoveUnneededReferences from LamdaRewriter</Title>
    <Description>Currently, the lambda rewriter has an early optimization pass in
analysis that tries to find all local functions that only capture 'this'
and remove references to local functions that do the same. There are two
problems with this approach:

    1) Generally, removing information from the tree is a bad idea
    because it hurts further analysis passes that may have needed that
    information.

    2) The optimization strategy itself is very tricky and has a number
    of complex corner cases. This has lead to bugs, for example #19033.

This PR deletes the current method and adds a new optimization routine
at the end of the analysis, operating on assigned scopes and
environments rather than removing captured variable analysis. The new
optimization is as follows: if we end up with an environment containing
only 'this', the environment can be removed, all containing methods can
be moved to the top-level type, and all environments which capture the
'this' environment can instead directly capture the 'this' parameter.
This produces almost the same results as the previous optimization, but
is easier to validate as an algebraic equivalence.

Fixes #19033
Fixes #20577</Description>
    <CreatedDate>08/08/2017</CreatedDate>
    <ClosedDate>11/08/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>19033</IssueID>
        <Title>Compiler crash</Title>
        <Description>**Any version below apr 17**: 

```csharp
using System;

namespace ConsoleApp3
{
    class BC { }
    class DC1 : BC { }
    class DC2 : BC { }
    class Program
    {
        static void Main(string[] args)
        {
        }

        private string Q(BC bclass, int n = 0)
        {
            switch (bclass)
            {
                case DC1 mc:

                    string A(BC map)
                    {
                        return "";
                    }

                    string B(BC map) 
                    {
                        switch (map)
                        {
                            case DC1 ne:
                                Action&lt;int&gt; a = _ =&gt; B(new DC2());
                                return "";
                            case DC2 b: 
                                return C(b);
                            default:
                                return A(map);
                        }
                    }

                    string C(BC map)
                    {
                        switch (map)
                        {
                            case DC1 me:
                                return n.ToString();
                            default:
                                return "";
                        }
                    }
                    break;

                default:
                    break;
            }

            return "";
        }
    }
}
```

"csc.exe" exited with code -2146232797
</Description>
        <CreatedDate>27/04/2017</CreatedDate>
        <ClosedDate>11/08/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19033</IssueID>
        <Title>Compiler crash</Title>
        <Description>**Any version below apr 17**: 

```csharp
using System;

namespace ConsoleApp3
{
    class BC { }
    class DC1 : BC { }
    class DC2 : BC { }
    class Program
    {
        static void Main(string[] args)
        {
        }

        private string Q(BC bclass, int n = 0)
        {
            switch (bclass)
            {
                case DC1 mc:

                    string A(BC map)
                    {
                        return "";
                    }

                    string B(BC map) 
                    {
                        switch (map)
                        {
                            case DC1 ne:
                                Action&lt;int&gt; a = _ =&gt; B(new DC2());
                                return "";
                            case DC2 b: 
                                return C(b);
                            default:
                                return A(map);
                        }
                    }

                    string C(BC map)
                    {
                        switch (map)
                        {
                            case DC1 me:
                                return n.ToString();
                            default:
                                return "";
                        }
                    }
                    break;

                default:
                    break;
            }

            return "";
        }
    }
}
```

"csc.exe" exited with code -2146232797
</Description>
        <CreatedDate>27/04/2017</CreatedDate>
        <ClosedDate>11/08/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>20577</IssueID>
        <Title>Compiler (csc) crashes with code of a nested recursive function and different scope access</Title>
        <Description>**Version Used**: 
2.2.0.61624
**Steps to Reproduce**:

1. Paste this code:
```
using System.Linq;

public class Program {
	public static void Main(string[] args) {
		object v;

		void AAA() {
			object BBB(object v2) {
				var a = v;
				((object[])v2).Select(i =&gt; BBB(i));
				return null;
			}
		}
	}
}
```
2. Compile

**Expected Behavior**:
Code compiles or fails to compile.
**Actual Behavior**:
Compiler crashes.</Description>
        <CreatedDate>30/06/2017</CreatedDate>
        <ClosedDate>11/08/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Compiler/TypeCompilationState.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/LambdaCapturedVariable.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/LambdaRewriter.Analysis.Tree.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/LambdaRewriter.Analysis.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/LambdaRewriter.LocalFunctionReferenceRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/LambdaRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/SynthesizedClosureEnvironment.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/SynthesizedClosureEnvironmentConstructor.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/SynthesizedLambdaMethod.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenClosureLambdaTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenLocalFunctionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Emit/EditAndContinue/EditAndContinueClosureTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/PDB/PDBLambdaTests.cs</File>
      <File>src/Compilers/Core/Portable/InternalUtilities/SetWithInsertionOrder.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Test/ExpressionCompiler/LocalFunctionTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>20662</IssueID>
    <Title>Use IVsSolution to get the correct IVsProject for an IVsHierarchy</Title>
    <Description>Fixes crashes associated with InvisibleEditor.

**Customer scenario**

* Use the Inline Rename functionality to rename an element (rare, never reproduced outside of crash reports)
* Use the following steps:
  1. Open dotnet/vs-threading
  2. Open **AsyncAutoResetEvent.cs**
  3. Use Inline Rename to rename `AsyncAutoResetEvent` to `AsyncAutoResetEvent2`
  4. Use CodeLens to drop down the references to the type
  5. Double click the reference in **AsyncAutoResetEventTests.cs** from the `evt` field

**Bugs this fixes:**

Fixes [DevDiv 458062](https://devdiv.visualstudio.com/DevDiv/_workitems?id=458062).

**Workarounds, if any**

None.

**Risk**

Low. The solution to the problem was implemented using techniques which all project systems should support without trouble.

**Performance impact**

Negligible. The solution was analyzed specifically to ensure the performance benefits of #19919 are retained.

**Is this a regression from a previous update?**

Yes.

**Root cause analysis:**

Edge case / race condition introduced by #19919. The root cause is documented in a comment in code:

&gt; The invisible editor manager will fail in cases where the `IVsProject` passed to it is not consistent with the `IVsProject` known to `IVsSolution` (e.g. if the object is a wrapper like `AbstractHostObject` created by the CPS-based project system). This method returns an `IVsProject` instance known to the solution, or null if the project could not be determined.

**How was the bug found?**

Watson and manual testing.
</Description>
    <CreatedDate>06/07/2017</CreatedDate>
    <ClosedDate>07/07/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>19919</IssueID>
        <Title>Pass a project when creating an invisible editor</Title>
        <Description>This change substantially reduces the amount of work required to locate a document within the solution (file path to hierarchy+itemid).

* Time to apply Fix All from #19895: 2:45 mins
* Time to apply Fix All after this change: 1:32 mins

## Ask Mode

**Customer scenario**

A customer applies a Fix All operation which affects many files in a large solution. (Not specific to any particular code fix.)

**Bugs this fixes:**

Derived from #19900 as the safe option for 15.3 (provides some but not all possible benefits).

**Workarounds, if any**

Wait longer.

**Risk**

Low. This feature adds a hint for a lookup, but valid information is not required in order for the underlying operation to succeed (falls back to slow case when information is not available).

**Performance impact**

This is a substantial performance improvement for Fix All operations.

**Is this a regression from a previous update?**

No.

**Root cause analysis:**

No performance tests covering large-scale operations (yet).

**How was the bug found?**

Internal testing.</Description>
        <CreatedDate>31/05/2017</CreatedDate>
        <ClosedDate>01/06/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19919</IssueID>
        <Title>Pass a project when creating an invisible editor</Title>
        <Description>This change substantially reduces the amount of work required to locate a document within the solution (file path to hierarchy+itemid).

* Time to apply Fix All from #19895: 2:45 mins
* Time to apply Fix All after this change: 1:32 mins

## Ask Mode

**Customer scenario**

A customer applies a Fix All operation which affects many files in a large solution. (Not specific to any particular code fix.)

**Bugs this fixes:**

Derived from #19900 as the safe option for 15.3 (provides some but not all possible benefits).

**Workarounds, if any**

Wait longer.

**Risk**

Low. This feature adds a hint for a lookup, but valid information is not required in order for the underlying operation to succeed (falls back to slow case when information is not available).

**Performance impact**

This is a substantial performance improvement for Fix All operations.

**Is this a regression from a previous update?**

No.

**Root cause analysis:**

No performance tests covering large-scale operations (yet).

**How was the bug found?**

Internal testing.</Description>
        <CreatedDate>31/05/2017</CreatedDate>
        <ClosedDate>01/06/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/InvisibleEditor.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>20645</IssueID>
    <Title>Fixed completion list for explicit interface implementation</Title>
    <Description>Fixes #15988
Fixes #19947

**Customer scenario**
Completion list for explicit interface implementations includes invalid members.

**Bugs this fixes:**
#19947, #15988

**Workarounds, if any**
None

**Risk**
Low, affected only ```ExplicitInterfaceMemberCompletionProvider``` class.

**Performance impact**

**Is this a regression from a previous update?**

**Root cause analysis:**
Completion members aren't filtered by interface type. Tests doesn't check that invalid members are not presented in code completion.

**How was the bug found?**

customer reported
</Description>
    <CreatedDate>05/07/2017</CreatedDate>
    <ClosedDate>07/07/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>15988</IssueID>
        <Title>Explicit Interface Implementation Completions show Object methods</Title>
        <Description>**Version Used**: 2017 RC Refresh

```C#
class C : IComparable {
	int IComparable.
}
```

Pressing Ctrl+Space after the `.` will show the four methods from `object`, even though they cannot be implemented with this syntax.</Description>
        <CreatedDate>18/12/2016</CreatedDate>
        <ClosedDate>07/07/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19947</IssueID>
        <Title>Completion list for explicit interface implementations includes invalid members</Title>
        <Description>![image](https://cloud.githubusercontent.com/assets/10522107/26692210/b4df7fee-46b4-11e7-97e6-2d6efb75b249.png)

Only implementable members declared immediately in the named interface should be in the list, members from derived interfaces will cause an error.</Description>
        <CreatedDate>01/06/2017</CreatedDate>
        <ClosedDate>07/07/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19947</IssueID>
        <Title>Completion list for explicit interface implementations includes invalid members</Title>
        <Description>![image](https://cloud.githubusercontent.com/assets/10522107/26692210/b4df7fee-46b4-11e7-97e6-2d6efb75b249.png)

Only implementable members declared immediately in the named interface should be in the list, members from derived interfaces will cause an error.</Description>
        <CreatedDate>01/06/2017</CreatedDate>
        <ClosedDate>07/07/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>15988</IssueID>
        <Title>Explicit Interface Implementation Completions show Object methods</Title>
        <Description>**Version Used**: 2017 RC Refresh

```C#
class C : IComparable {
	int IComparable.
}
```

Pressing Ctrl+Space after the `.` will show the four methods from `object`, even though they cannot be implemented with this syntax.</Description>
        <CreatedDate>18/12/2016</CreatedDate>
        <ClosedDate>07/07/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/Completion/CompletionProviders/ExplicitInterfaceMemberCompletionProviderTests.cs</File>
      <File>src/Features/CSharp/Portable/Completion/CompletionProviders/ExplicitInterfaceMemberCompletionProvider.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>20587</IssueID>
    <Title>Fixes overload resolution regression with ValueTuple</Title>
    <Description>**Customer scenario**

The C# overload resolution tie-breaker involving a more specific type argument isn't respected for instances of ValueTuple. When such a scenario arises, the programmer get an ambiguity error on the invocation.

**Bugs this fixes:**

Fixes #20494
Adds a test for #20583

**Workarounds, if any**

The programmer can provide explicit type arguments to resolve the ambiguity.

**Risk**

Small. The fix is a very local workaround for the symptom. The underlying issue (ValueTuple instances are not recognized by the compiler as generic), may be addressed separately in a more extensive change.

**Performance impact**

Tiny or none.

**Is this a regression from a previous update?**

It is a regression in VS2017 versus VS2015.

**Root cause analysis:**

This is a symptom of our choice of internal representation for tuple types. I am separately looking at a more uniform change to address the underlying issue, which is that tuple types are not recognized by the compiler as generic.

**How was the bug found?**

Ad-hoc testing.

@dotnet/roslyn-compiler May I please have a couple of reviews of this tiny bug fix?
</Description>
    <CreatedDate>30/06/2017</CreatedDate>
    <ClosedDate>09/07/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>20494</IssueID>
        <Title>"More generic" tie-breaker not applied to ValueTuple in C# 7 compiler</Title>
        <Description>**Version Used**: 15.2

**Steps to Reproduce**:

1. Compile the following code

**Expected Behavior**:

Code compiles without problem, just like it did using previous C# compilers.

**Actual Behavior**:

Compile fails at `M2(b)`, complaining that `error CS0121: The call is ambiguous between the following methods or properties: 'C.M2&lt;T&gt;((T, int))' and 'C.M2&lt;T&gt;(((T, int), int))'`

This is a regression from compilers previous to Visual Studio 2017.

``` c#
using System;
public class C
{
    public static void Main()
    {
        A&lt;A&lt;int&gt;&gt; a = null;
        M1(a); // ok, selects M1&lt;T&gt;(A&lt;A&lt;T&gt;&gt; a)

        var b = default(ValueTuple&lt;ValueTuple&lt;int, int&gt;, int&gt;);
        M2(b); // ok, should select M2&lt;T&gt;(ValueTuple&lt;ValueTuple&lt;T, int&gt;, int&gt; a)
    }
    public static void M1&lt;T&gt;(A&lt;T&gt; a) { }
    public static void M1&lt;T&gt;(A&lt;A&lt;T&gt;&gt; a) { }

    public static void M2&lt;T&gt;(ValueTuple&lt;T, int&gt; a) { }
    public static void M2&lt;T&gt;(ValueTuple&lt;ValueTuple&lt;T, int&gt;, int&gt; a) { }
}

public class A&lt;T&gt; { }
```

/cc @jaredpar @MadsTorgersen 
</Description>
        <CreatedDate>28/06/2017</CreatedDate>
        <ClosedDate>09/07/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>20583</IssueID>
        <Title>Inference failure for tuple type vs tuple underlying type (regression)</Title>
        <Description>The following correct program compiles successfully in VS2015, but fails to compile in VS2017:

``` c#
using System;
public class C
{
    public static void Main()
    {
        // var b = (1, 2, 3, 4, 5, 6, 7, 8);
        var b = new ValueTuple&lt;int, int, int, int, int, int, int, ValueTuple&lt;int&gt;&gt;(1, 2, 3, 4, 5, 6, 7, new ValueTuple&lt;int&gt;(8));
        M1(b);
    }
    public static void M1&lt;T1, T2, T3, T4, T5, T6, T7, TRest&gt;(ValueTuple&lt;T1, T2, T3, T4, T5, T6, T7, TRest&gt; a) where TRest : struct { Console.Write(1); }
}
```

with the following error

``` none
Error CS0411: The type arguments for method 'C.M1&lt;T1, T2, T3, T4, T5, T6, T7, TRest&gt;(ValueTuple&lt;T1, T2, T3, T4, T5, T6, T7, TRest&gt;)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
```
</Description>
        <CreatedDate>30/06/2017</CreatedDate>
        <ClosedDate>26/09/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/OverloadResolution/OverloadResolution.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTupleTest.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>20004</IssueID>
    <Title>Better exclude local functions from region analysis</Title>
    <Description>By design, when data flow analyzes local functions it does so devoid of
surrounding context and records possibly unassigned variables rather
than reporting a diagnostic. Thus, all captured variables are expected
to be marked unassigned during data flow analysis without reporting a
diagnostic.

However, reporting a diagnostic is not the only side effect of running
data flow analysis. By calling virtual methods data flow analysis
informs derived types of unassigned variables. While the diagnostic is
suppressed and recorded, currently the virtual method is still called.
This has negative consequences for region analysis, which considers
these calls as indications of variables flowing out of the given
region, which may not be the case for local functions.

This PR changes data flow analysis to only call the ReportUnassigned
virtual method if not inside a local function, excluding local functions
from all unassignment reporting.

Fixes #17165, #18347

**Customer scenario**

Extract method crashes when analyzing code that contains variables captured by
local functions.

**Bugs this fixes:**

Fixes #17165, #18347

**Workarounds, if any**

Don't ask for refactorings around these variables.

**Risk**

This is a code change to data flow analysis and could affect definite assignment for local functions,
but is mostly focused around code flow to region analysis, which is only used by extract method.

**Performance impact**

Low. No extra allocations, minimal extra logic.

**Is this a regression from a previous update?**

No.

**Root cause analysis:**

Local functions were a new feature in C# 7 and there are known issues around region analysis.

**How was the bug found?**

Customer reported.</Description>
    <CreatedDate>04/06/2017</CreatedDate>
    <ClosedDate>15/06/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>17165</IssueID>
        <Title>ExtractMethodMatrix.GetVariableStyle Throws exception on code with errors</Title>
        <Description>**Version Used**: 
![image](https://cloud.githubusercontent.com/assets/9797472/22995888/8293500a-f381-11e6-923e-4d241adef2f9.png)

**Steps to Reproduce**:

1.  Use Alt+Arrow to move members into lambda that is an argument into a method that is missing semicolon

**Expected Behavior**:
No Crash

**Actual Behavior**:
```
System.InvalidOperationException : Unexpected false
   at Roslyn.Utilities.Contract.ThrowIfFalse(Boolean condition,String message)
   at Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodMatrix.GetVariableStyle(Boolean captured,Boolean dataFlowIn,Boolean dataFlowOut,Boolean alwaysAssigned,Boolean variableDeclared,Boolean readInside,Boolean writtenInside,Boolean readOutside,Boolean writtenOutside,Boolean unsafeAddressTaken)
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GetVariableStyle(Dictionary`2 symbolMap,ISymbol symbol,SemanticModel model,ITypeSymbol type,Boolean captured,Boolean dataFlowIn,Boolean dataFlowOut,Boolean alwaysAssigned,Boolean variableDeclared,Boolean readInside,Boolean writtenInside,Boolean readOutside,Boolean writtenOutside,Boolean unsafeAddressTaken)
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GenerateVariableInfoMap(SemanticModel model,DataFlowAnalysis dataFlowAnalysisData,Dictionary`2 symbolMap)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.AnalyzeAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.ExtractMethodAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.ExtractMethodAsync[TValidator,TExtractor,TResult](&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.GetCodeActionAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.ComputeRefactoringsAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringService.GetRefactoringFromProviderAsync(&lt;Unknown Parameters&gt;)
   at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject)
```

Also reported at https://developercommunity.visualstudio.com/content/problem/14869/extractmethodcoderefactoringprovider-encountered-a.html</Description>
        <CreatedDate>15/02/2017</CreatedDate>
        <ClosedDate>15/06/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>18347</IssueID>
        <Title>ExtractMethodCodeRefactoringProvider crashes on selecting a line that references an argument captured by a local method</Title>
        <Description>**Version Used**: 

Microsoft Visual Studio Community 2017
Version 15.0.26228.9

**Steps to Reproduce**:

```csharp
namespace ExtractMethodCrashRepro
{
	public static class SomeClass
	{
		private static void Repro( int arg )
		{
			int localValue = arg;

			int LocalCapture() =&gt; arg;
		}
	}
}
```

Select the line `int localValue = arg;`

**Expected Behavior**:
A lightbulb with available refactorings should appear.

**Actual Behavior**:
`ExtractMethodCodeRefactoringProvider` crashes with the following stack trace:

```
System.InvalidOperationException : Unexpected false
   at Roslyn.Utilities.Contract.ThrowIfFalse(Boolean condition,String message)
   at Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodMatrix.GetVariableStyle(Boolean captured,Boolean dataFlowIn,Boolean dataFlowOut,Boolean alwaysAssigned,Boolean variableDeclared,Boolean readInside,Boolean writtenInside,Boolean readOutside,Boolean writtenOutside,Boolean unsafeAddressTaken)
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GetVariableStyle(Dictionary`2 symbolMap,ISymbol symbol,SemanticModel model,ITypeSymbol type,Boolean captured,Boolean dataFlowIn,Boolean dataFlowOut,Boolean alwaysAssigned,Boolean variableDeclared,Boolean readInside,Boolean writtenInside,Boolean readOutside,Boolean writtenOutside,Boolean unsafeAddressTaken)
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GenerateVariableInfoMap(SemanticModel model,DataFlowAnalysis dataFlowAnalysisData,Dictionary`2 symbolMap)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.AnalyzeAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.ExtractMethodAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.ExtractMethodAsync[TValidator,TExtractor,TResult](&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.GetCodeActionAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.ComputeRefactoringsAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringService.GetRefactoringFromProviderAsync(&lt;Unknown Parameters&gt;)
   at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject)
```</Description>
        <CreatedDate>31/03/2017</CreatedDate>
        <ClosedDate>31/03/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>17165</IssueID>
        <Title>ExtractMethodMatrix.GetVariableStyle Throws exception on code with errors</Title>
        <Description>**Version Used**: 
![image](https://cloud.githubusercontent.com/assets/9797472/22995888/8293500a-f381-11e6-923e-4d241adef2f9.png)

**Steps to Reproduce**:

1.  Use Alt+Arrow to move members into lambda that is an argument into a method that is missing semicolon

**Expected Behavior**:
No Crash

**Actual Behavior**:
```
System.InvalidOperationException : Unexpected false
   at Roslyn.Utilities.Contract.ThrowIfFalse(Boolean condition,String message)
   at Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodMatrix.GetVariableStyle(Boolean captured,Boolean dataFlowIn,Boolean dataFlowOut,Boolean alwaysAssigned,Boolean variableDeclared,Boolean readInside,Boolean writtenInside,Boolean readOutside,Boolean writtenOutside,Boolean unsafeAddressTaken)
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GetVariableStyle(Dictionary`2 symbolMap,ISymbol symbol,SemanticModel model,ITypeSymbol type,Boolean captured,Boolean dataFlowIn,Boolean dataFlowOut,Boolean alwaysAssigned,Boolean variableDeclared,Boolean readInside,Boolean writtenInside,Boolean readOutside,Boolean writtenOutside,Boolean unsafeAddressTaken)
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GenerateVariableInfoMap(SemanticModel model,DataFlowAnalysis dataFlowAnalysisData,Dictionary`2 symbolMap)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.AnalyzeAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.ExtractMethodAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.ExtractMethodAsync[TValidator,TExtractor,TResult](&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.GetCodeActionAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.ComputeRefactoringsAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringService.GetRefactoringFromProviderAsync(&lt;Unknown Parameters&gt;)
   at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject)
```

Also reported at https://developercommunity.visualstudio.com/content/problem/14869/extractmethodcoderefactoringprovider-encountered-a.html</Description>
        <CreatedDate>15/02/2017</CreatedDate>
        <ClosedDate>15/06/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>18347</IssueID>
        <Title>ExtractMethodCodeRefactoringProvider crashes on selecting a line that references an argument captured by a local method</Title>
        <Description>**Version Used**: 

Microsoft Visual Studio Community 2017
Version 15.0.26228.9

**Steps to Reproduce**:

```csharp
namespace ExtractMethodCrashRepro
{
	public static class SomeClass
	{
		private static void Repro( int arg )
		{
			int localValue = arg;

			int LocalCapture() =&gt; arg;
		}
	}
}
```

Select the line `int localValue = arg;`

**Expected Behavior**:
A lightbulb with available refactorings should appear.

**Actual Behavior**:
`ExtractMethodCodeRefactoringProvider` crashes with the following stack trace:

```
System.InvalidOperationException : Unexpected false
   at Roslyn.Utilities.Contract.ThrowIfFalse(Boolean condition,String message)
   at Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodMatrix.GetVariableStyle(Boolean captured,Boolean dataFlowIn,Boolean dataFlowOut,Boolean alwaysAssigned,Boolean variableDeclared,Boolean readInside,Boolean writtenInside,Boolean readOutside,Boolean writtenOutside,Boolean unsafeAddressTaken)
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GetVariableStyle(Dictionary`2 symbolMap,ISymbol symbol,SemanticModel model,ITypeSymbol type,Boolean captured,Boolean dataFlowIn,Boolean dataFlowOut,Boolean alwaysAssigned,Boolean variableDeclared,Boolean readInside,Boolean writtenInside,Boolean readOutside,Boolean writtenOutside,Boolean unsafeAddressTaken)
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GenerateVariableInfoMap(SemanticModel model,DataFlowAnalysis dataFlowAnalysisData,Dictionary`2 symbolMap)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.AnalyzeAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.ExtractMethodAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.ExtractMethodAsync[TValidator,TExtractor,TResult](&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.GetCodeActionAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.ComputeRefactoringsAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringService.GetRefactoringFromProviderAsync(&lt;Unknown Parameters&gt;)
   at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject)
```</Description>
        <CreatedDate>31/03/2017</CreatedDate>
        <ClosedDate>31/03/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/DataFlowPass.LocalFunctions.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/DataFlowPass.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/DataFlowsInWalker.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/DataFlowsOutWalker.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/UnassignedAddressTakenVariablesWalker.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/UnassignedVariablesWalker.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/StateMachineRewriter/IteratorAndAsyncCaptureWalker.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTupleTest.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/FlowAnalysis/LocalFunctions.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/FlowAnalysis/RegionAnalysisTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/FlowAnalysis/StructTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/ExtractMethod/ExtractMethodTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>19945</IssueID>
    <Title>Fix Extract Method operations within an event accessor</Title>
    <Description>Fixes #17474
Closes #19136

## Ask Mode

**Customer scenario**

Uses the light bulb while a selection is present in certain code. A non-fatal exception occurs in the Extract Method refactoring and the gold bar appears.

**Bugs this fixes:**

Fixes #17474
Closes #19136 (the behavior is sub-optimal, but a proper solution can wait for #19958) 

**Workarounds, if any**

None

**Risk**

Low. The changed code paths only affect the failing scenario.

**Performance impact**

This change should not have any impact on performance.

**Is this a regression from a previous update?**

No.

**Root cause analysis:**

* Failure to test all code constructs
* Failure to account for erroneous code in testing

**How was the bug found?**

Internal customer report
</Description>
    <CreatedDate>01/06/2017</CreatedDate>
    <ClosedDate>02/06/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>17474</IssueID>
        <Title>InvalidCastException at Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpSelectionResult.StatementResult.GetContainingScopeType</Title>
        <Description>**Version Used**: 
D15Rel 26226.0

**Steps to Reproduce**:
1. Restore, build and open Roslyn.sln
2. Open source file: `\src\EditorFeatures\Core\Implementation\Classification\SemanticClassificationBufferTaggerProvider.Tagger.cs` and enter the following code at end of the file:
  ```
namespace NewTaggerNamespace
{
    internal partial class NewTagger : IAccurateTagger&lt;IClassificationTag&gt;
    {
        public event EventHandler&lt;SnapshotSpanEventArgs&gt; TagsChanged;

        event EventHandler&lt;SnapshotSpanEventArgs&gt; ITagger&lt;IClassificationTag&gt;.TagsChanged
        {
            add
            {
                throw new NotImplementedException();
            }

            remove
            {
                throw new NotImplementedException();
            }
        }

        public IEnumerable&lt;ITagSpan&lt;IClassificationTag&gt;&gt; GetAllTags(NormalizedSnapshotSpanCollection spans, CancellationToken cancel)
        {
            throw new NotImplementedException();
        }

        IEnumerable&lt;ITagSpan&lt;IClassificationTag&gt;&gt; ITagger&lt;IClassificationTag&gt;.GetTags(NormalizedSnapshotSpanCollection spans)
        {
            throw new NotImplementedException();
        }
    }
}
  ```
3. Select text `throw new NotImplementedException();` in the add or remove handler.

Got the following exception in the info bar:

```
System.InvalidCastException : Unable to cast object of type 'Microsoft.CodeAnalysis.CSharp.Symbols.SourceCustomEventSymbol' to type 'Microsoft.CodeAnalysis.IPropertySymbol'.
   at Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpSelectionResult.StatementResult.GetContainingScopeType()
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.CodeGenerator`3.AddReturnIfUnreachable(IEnumerable`1 statements,CancellationToken cancellationToken)
   at async Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpMethodExtractor.CSharpCodeGenerator.CreateStatementsOrInitializerToInsertAtCallSiteAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpMethodExtractor.CSharpCodeGenerator.GenerateBodyForCallSiteContainerAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.CodeGenerator`3.GenerateAsync[TStatement,TExpression,TNodeUnderContainer](&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.ExtractMethodAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.ExtractMethodAsync[TValidator,TExtractor,TResult](&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.GetCodeActionAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.ComputeRefactoringsAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringService.GetRefactoringFromProviderAsync(&lt;Unknown Parameters&gt;)
   at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject)
```
</Description>
        <CreatedDate>28/02/2017</CreatedDate>
        <ClosedDate>02/06/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19136</IssueID>
        <Title>ExtractMethodCodeRefactoringProvider crashed with InvalidOperationException</Title>
        <Description>VS Build: 26426.1 VSUWPT

Note same code that crashed: https://github.com/dotnet/roslyn/issues/19135.

``` C#
// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.

using System;
using Microsoft.VisualStudio.ProjectSystem.VS;

namespace Microsoft.VisualStudio.Shell.Interop
{
    internal static class IVsOutputWindowExtensions
    {
        public static void ActivatePane(this IVsOutputWindow outputWindow, Guid pane)
        {
            Requires.NotNull(outputWindow, nameof(outputWindow));
            Requires.NotEmpty(pane, nameof(pane));

            HResult hr = outputWindow.GetPane(ref $pane$, out IVsOutputWindowPane pane);
            if (!hr.IsOK) // Pane not found
                return;

            hr = pane.Activate();
            if (hr.Failed)
                throw hr.Exception;
        }
    }
}
```


```
System.InvalidOperationException : Unexpected false
   at Roslyn.Utilities.Contract.ThrowIfFalse(Boolean condition,String message)
   at Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodMatrix.GetVariableStyle(Boolean captured,Boolean dataFlowIn,Boolean dataFlowOut,Boolean alwaysAssigned,Boolean variableDeclared,Boolean readInside,Boolean writtenInside,Boolean readOutside,Boolean writtenOutside,Boolean unsafeAddressTaken)
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GetVariableStyle(Dictionary`2 symbolMap,ISymbol symbol,SemanticModel model,ITypeSymbol type,Boolean captured,Boolean dataFlowIn,Boolean dataFlowOut,Boolean alwaysAssigned,Boolean variableDeclared,Boolean readInside,Boolean writtenInside,Boolean readOutside,Boolean writtenOutside,Boolean unsafeAddressTaken)
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GenerateVariableInfoMap(SemanticModel model,DataFlowAnalysis dataFlowAnalysisData,Dictionary`2 symbolMap)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.AnalyzeAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.ExtractMethodAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.ExtractMethodAsync[TValidator,TExtractor,TResult](&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.GetCodeActionAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.ComputeRefactoringsAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringService.GetRefactoringFromProviderAsync(&lt;Unknown Parameters&gt;)
   at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject)
```</Description>
        <CreatedDate>01/05/2017</CreatedDate>
        <ClosedDate>02/06/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>17474</IssueID>
        <Title>InvalidCastException at Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpSelectionResult.StatementResult.GetContainingScopeType</Title>
        <Description>**Version Used**: 
D15Rel 26226.0

**Steps to Reproduce**:
1. Restore, build and open Roslyn.sln
2. Open source file: `\src\EditorFeatures\Core\Implementation\Classification\SemanticClassificationBufferTaggerProvider.Tagger.cs` and enter the following code at end of the file:
  ```
namespace NewTaggerNamespace
{
    internal partial class NewTagger : IAccurateTagger&lt;IClassificationTag&gt;
    {
        public event EventHandler&lt;SnapshotSpanEventArgs&gt; TagsChanged;

        event EventHandler&lt;SnapshotSpanEventArgs&gt; ITagger&lt;IClassificationTag&gt;.TagsChanged
        {
            add
            {
                throw new NotImplementedException();
            }

            remove
            {
                throw new NotImplementedException();
            }
        }

        public IEnumerable&lt;ITagSpan&lt;IClassificationTag&gt;&gt; GetAllTags(NormalizedSnapshotSpanCollection spans, CancellationToken cancel)
        {
            throw new NotImplementedException();
        }

        IEnumerable&lt;ITagSpan&lt;IClassificationTag&gt;&gt; ITagger&lt;IClassificationTag&gt;.GetTags(NormalizedSnapshotSpanCollection spans)
        {
            throw new NotImplementedException();
        }
    }
}
  ```
3. Select text `throw new NotImplementedException();` in the add or remove handler.

Got the following exception in the info bar:

```
System.InvalidCastException : Unable to cast object of type 'Microsoft.CodeAnalysis.CSharp.Symbols.SourceCustomEventSymbol' to type 'Microsoft.CodeAnalysis.IPropertySymbol'.
   at Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpSelectionResult.StatementResult.GetContainingScopeType()
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.CodeGenerator`3.AddReturnIfUnreachable(IEnumerable`1 statements,CancellationToken cancellationToken)
   at async Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpMethodExtractor.CSharpCodeGenerator.CreateStatementsOrInitializerToInsertAtCallSiteAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpMethodExtractor.CSharpCodeGenerator.GenerateBodyForCallSiteContainerAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.CodeGenerator`3.GenerateAsync[TStatement,TExpression,TNodeUnderContainer](&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.ExtractMethodAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.ExtractMethodAsync[TValidator,TExtractor,TResult](&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.GetCodeActionAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.ComputeRefactoringsAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringService.GetRefactoringFromProviderAsync(&lt;Unknown Parameters&gt;)
   at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject)
```
</Description>
        <CreatedDate>28/02/2017</CreatedDate>
        <ClosedDate>02/06/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19136</IssueID>
        <Title>ExtractMethodCodeRefactoringProvider crashed with InvalidOperationException</Title>
        <Description>VS Build: 26426.1 VSUWPT

Note same code that crashed: https://github.com/dotnet/roslyn/issues/19135.

``` C#
// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.

using System;
using Microsoft.VisualStudio.ProjectSystem.VS;

namespace Microsoft.VisualStudio.Shell.Interop
{
    internal static class IVsOutputWindowExtensions
    {
        public static void ActivatePane(this IVsOutputWindow outputWindow, Guid pane)
        {
            Requires.NotNull(outputWindow, nameof(outputWindow));
            Requires.NotEmpty(pane, nameof(pane));

            HResult hr = outputWindow.GetPane(ref $pane$, out IVsOutputWindowPane pane);
            if (!hr.IsOK) // Pane not found
                return;

            hr = pane.Activate();
            if (hr.Failed)
                throw hr.Exception;
        }
    }
}
```


```
System.InvalidOperationException : Unexpected false
   at Roslyn.Utilities.Contract.ThrowIfFalse(Boolean condition,String message)
   at Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodMatrix.GetVariableStyle(Boolean captured,Boolean dataFlowIn,Boolean dataFlowOut,Boolean alwaysAssigned,Boolean variableDeclared,Boolean readInside,Boolean writtenInside,Boolean readOutside,Boolean writtenOutside,Boolean unsafeAddressTaken)
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GetVariableStyle(Dictionary`2 symbolMap,ISymbol symbol,SemanticModel model,ITypeSymbol type,Boolean captured,Boolean dataFlowIn,Boolean dataFlowOut,Boolean alwaysAssigned,Boolean variableDeclared,Boolean readInside,Boolean writtenInside,Boolean readOutside,Boolean writtenOutside,Boolean unsafeAddressTaken)
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GenerateVariableInfoMap(SemanticModel model,DataFlowAnalysis dataFlowAnalysisData,Dictionary`2 symbolMap)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.AnalyzeAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.ExtractMethodAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.ExtractMethodAsync[TValidator,TExtractor,TResult](&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.GetCodeActionAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.ComputeRefactoringsAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringService.GetRefactoringFromProviderAsync(&lt;Unknown Parameters&gt;)
   at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject)
```</Description>
        <CreatedDate>01/05/2017</CreatedDate>
        <ClosedDate>02/06/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19958</IssueID>
        <Title>Extract method does not support by-ref pass-through</Title>
        <Description>**Version Used**: 15.3

This is an extension of #19136.

**Steps to Reproduce**:

Attempt to use the Extract Method refactoring on the following code:

```csharp
public static int OtherMethod(ref int x)
    =&gt; x;

public static void Method(ref int x)
    =&gt; Console.WriteLine(OtherMethod(ref $x$));
```

**Expected Behavior**:

```csharp
public static int OtherMethod(ref int x)
    =&gt; x;

public static void Method(ref int x)
    =&gt; Console.WriteLine(OtherMethod(ref NewMethod(ref x)));

public static ref int NewMethod(ref int x)
{
    return ref x;
}
```

**Actual Behavior**:

```csharp
public static int OtherMethod(ref int x)
    =&gt; x;

public static void Method(ref int x)
    =&gt; Console.WriteLine(NewMethod(ref x));

public static int NewMethod(ref int x)
{
    return OtherMethod(ref x);
}
```
</Description>
        <CreatedDate>01/06/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/ExtractMethod/ExtractMethodTests.cs</File>
      <File>src/Features/CSharp/Portable/ExtractMethod/CSharpSelectionResult.StatementResult.cs</File>
      <File>src/Features/Core/Portable/ExtractMethod/ExtractMethodMatrix.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>19919</IssueID>
    <Title>Pass a project when creating an invisible editor</Title>
    <Description>This change substantially reduces the amount of work required to locate a document within the solution (file path to hierarchy+itemid).

* Time to apply Fix All from #19895: 2:45 mins
* Time to apply Fix All after this change: 1:32 mins

## Ask Mode

**Customer scenario**

A customer applies a Fix All operation which affects many files in a large solution. (Not specific to any particular code fix.)

**Bugs this fixes:**

Derived from #19900 as the safe option for 15.3 (provides some but not all possible benefits).

**Workarounds, if any**

Wait longer.

**Risk**

Low. This feature adds a hint for a lookup, but valid information is not required in order for the underlying operation to succeed (falls back to slow case when information is not available).

**Performance impact**

This is a substantial performance improvement for Fix All operations.

**Is this a regression from a previous update?**

No.

**Root cause analysis:**

No performance tests covering large-scale operations (yet).

**How was the bug found?**

Internal testing.</Description>
    <CreatedDate>31/05/2017</CreatedDate>
    <ClosedDate>01/06/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>19895</IssueID>
        <Title>Avoid re-verifying semantics of nodes that cannot influence each other</Title>
        <Description>I verified that the applied results on Roslyn.sln are identical before and after this change.

Time to fix all "Use default expression" in Roslyn.sln:

| Implementation | Time to open preview | Time to apply changes |
| --- | --- | --- |
| master branch (05480ee495766eaa198ec3d207867fad5adcc655) | 2:18 min | 2:52 min |
| This branch | 1:35 min | 2:43 min |

:bulb: I filed #19900 to address the time to apply changes.

## Ask Mode

**Customer scenario**

Apply the new **Use Default Literal** code fix to a codebase containing a large number of default expressions.

**Bugs this fixes:**

Closes #19817.

**Workarounds, if any**

Wait longer.

**Risk**

This is much lower risk than a implementation of #19817 as originally described would be, for both correctness and maintainability. This optimization leverages the following language aspects:

1. It assumes that the analyzer only reports diagnostics for cases where a conversion from `default(T)`&amp;rarr;`default` *in isolation* would not change the inferred type of the expression.
2. It assumes that all inference operations (type inference, overload resolution) cannot impact each other across certain boundaries, specifically the following:
    * Parameters
    * Statements
    * Variable declarators
    * Files

**Performance impact**

This change substantially improves performance of code helping users migrate to a specific new feature of C# 7.1.

**Is this a regression from a previous update?**

No.

**Root cause analysis:**

We were aware of the performance limitations and originally opted for the safest path forward. Follow-up investigation revealed an area of low-hanging fruit with relatively low risk.

**How was the bug found?**

Internal dogfooding.</Description>
        <CreatedDate>31/05/2017</CreatedDate>
        <ClosedDate>31/05/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19900</IssueID>
        <Title>Avoid opening invisible editors for applying changes during Fix All</Title>
        <Description>**Version Used**: 15.3 preview 1

**Steps to Reproduce**:

1. Open a large solution (e.g. dotnet/roslyn@05480ee4)
2. Close all open documents except one that can be used to trigger a Fix All operation
3. Apply a Fix All operation that affects a large number of files (e.g. Use Default Literal)

**Expected Behavior**:

The Fix All application (the time it takes *after* hitting Apply on the preview window) completes in the amount of time it takes to save the affected files to disk.

**Actual Behavior**:

The Fix All application takes minutes.

**Notes**:

The dominant costs for this operation ***overwhelmingly*** stem from [opening an invisible editor](https://github.com/dotnet/roslyn/blob/master/src/VisualStudio/Core/Def/Implementation/ProjectSystem/DocumentProvider.StandardTextDocument.cs#L217) for the code fix application rather than operating at a lower level.

During an application of the Use Default Literal code fix for testing #19895, the invisible editor was responsible for 13+GiB of avoidable overhead on the garbage collector in devenv.exe (i.e. overhead unrelated to the actual application of the code fix). Substantial additional time was spent during marshalling for a large number of COM/CLR transitions in various places.</Description>
        <CreatedDate>31/05/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/VisualStudio/Core/Def/Implementation/FindReferences/VisualStudioDefinitionsAndReferencesFactory.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/InvisibleEditor.cs</File>
      <File>src/VisualStudio/Core/Impl/CodeModel/TextManagerAdapter.cs</File>
      <File>src/VisualStudio/Core/Impl/RoslynVisualStudioWorkspace.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>19812</IssueID>
    <Title>Fix IDE0009 false positive on expressions qualified with 'base.'</Title>
    <Description>**Customer scenario**
See #17711 for details

**Bugs this fixes:**
Fixes #17711

**Workarounds, if any**
None

**Risk**
Low

**Performance impact**
Low perf impact because only a couple extra checks are done, with no loops.

**Is this a regression from a previous update?**
No

**Root cause analysis:**
Tests added. Missed because there were no tests initially for this.

**How was the bug found?**
Customer reported.</Description>
    <CreatedDate>26/05/2017</CreatedDate>
    <ClosedDate>02/06/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>17711</IssueID>
        <Title>IDE0009 wrongly generated when using the base keyword</Title>
        <Description>**Version Used**: VS2017 15.0.0-RTW+26228.4

**Steps to Reproduce**: Consider this code

```csharp
class A
{
    public virtual int Value =&gt; 5;
}

class B : A
{
    public override int Value =&gt; base.Value + 6; // warning here
}
```

**Expected Behavior**: No warning generated for IDE0009 on the marked line

**Actual Behavior**: IDE0009 is generated here

The analysis is completely wrong. Applying 'this' would create an infinite loop. The property does not need to be an expression body for IDE0009 to be generated. `Value { get { base.Value + 6; } }` will cause the warning as well.
</Description>
        <CreatedDate>10/03/2017</CreatedDate>
        <ClosedDate>02/06/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>17711</IssueID>
        <Title>IDE0009 wrongly generated when using the base keyword</Title>
        <Description>**Version Used**: VS2017 15.0.0-RTW+26228.4

**Steps to Reproduce**: Consider this code

```csharp
class A
{
    public virtual int Value =&gt; 5;
}

class B : A
{
    public override int Value =&gt; base.Value + 6; // warning here
}
```

**Expected Behavior**: No warning generated for IDE0009 on the marked line

**Actual Behavior**: IDE0009 is generated here

The analysis is completely wrong. Applying 'this' would create an infinite loop. The property does not need to be an expression body for IDE0009 to be generated. `Value { get { base.Value + 6; } }` will cause the warning as well.
</Description>
        <CreatedDate>10/03/2017</CreatedDate>
        <ClosedDate>02/06/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/QualifyMemberAccess/QualifyMemberAccessTests.cs</File>
      <File>src/Features/CSharp/Portable/QualifyMemberAccess/CSharpQualifyMemberAccessDiagnosticAnalyzer.cs</File>
      <File>src/Features/Core/Portable/QualifyMemberAccess/AbstractQualifyMemberAccessDiagnosticAnalyzer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>19737</IssueID>
    <Title>Fix code gen for pattern switch with constant expression</Title>
    <Description>**Customer scenario**

Use new pattern-based switch constructs in which the switch expression is a constant.

**Bugs this fixes:**

* Fix code gen for pattern switch with constant expression
Fixes #19731

* Add instrumentation for pattern switch with constant expression
Fixes #17090

* Incorrect code for generic pattern switch on a constant expression
Fixes #19734

**Workarounds, if any**

Don't use a constant switch expression.

**Risk**

Low. The scenarios are fairly focused, and regression tests now exist for the problematic scenarios.

**Performance impact**

None expected. No significant change in the complexity of the relevant compiler code.

**Is this a regression from a previous update?**

Yes, #19731 is a regression from the last update.

**Root cause analysis:**

We are catching this now as we add coverage for the recently added support for switching on generic types.

**How was the bug found?**

Development testing.
</Description>
    <CreatedDate>23/05/2017</CreatedDate>
    <ClosedDate>05/06/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>19731</IssueID>
        <Title>Bad code for pattern switch with constant expression</Title>
        <Description>The following produces code that does nothing.

This is a regression in master versus the most recent update.

``` c#
    static void M1()
    {
        switch (1)
        {
            case 0 when true:
                ;
            case 1:
                Console.Write(1);
                break;
            case 2:
                ;
        }
    }
```
</Description>
        <CreatedDate>23/05/2017</CreatedDate>
        <ClosedDate>05/06/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>17090</IssueID>
        <Title>Switch expression instrumentation not produced for constant expression in pattern switch</Title>
        <Description>Code generation for a pattern switch does not evaluate the switch expression at runtime when it is a constant. Consequently there is no place in the generated code for the compiler to generate the instrumentation, and the compiler does not produce instrumentation for the switch expression in this case. We should evaluate what the proper treatment of this situation should be.</Description>
        <CreatedDate>10/02/2017</CreatedDate>
        <ClosedDate>05/06/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19734</IssueID>
        <Title>Incorrect code for generic pattern switch on a constant expression</Title>
        <Description>The following produces incorrect code. When `T` is `long`, it prints nothing.

This is a regression in master versus the most recent update.

``` c#
    static void M1&lt;T&gt;()
    {
        switch (1)
        {
            case T t:
                Console.Write(1);
                break;
            case int i:
                Console.Write(2);
                break;
        }
    }
```

This is a new issue in 15.3, as the code was illegal previously.
</Description>
        <CreatedDate>23/05/2017</CreatedDate>
        <ClosedDate>05/06/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19731</IssueID>
        <Title>Bad code for pattern switch with constant expression</Title>
        <Description>The following produces code that does nothing.

This is a regression in master versus the most recent update.

``` c#
    static void M1()
    {
        switch (1)
        {
            case 0 when true:
                ;
            case 1:
                Console.Write(1);
                break;
            case 2:
                ;
        }
    }
```
</Description>
        <CreatedDate>23/05/2017</CreatedDate>
        <ClosedDate>05/06/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/BoundTree/DecisionTreeBuilder.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_PatternSwitchStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/SwitchTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Emit/EditAndContinue/LocalSlotMappingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/PDB/PDBTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>19624</IssueID>
    <Title>Smarter resource management in MemoryMappedInfo</Title>
    <Description>* Unmap views of memory mapped files when they are not in use, allowing the process to use the address space for other purposes (#19604)
* Use fewer memory mapped files for small files (#19570)

## Ask Mode

**Customer scenario**

Customer works in a large solution; over time they tend to observe out of memory exceptions.

**Bugs this fixes:**

Fixes #19493
Fixes #19570
Fixes #19604
Fixes #19761 
[DevDiv 435299](https://devdiv.visualstudio.com/web/wi.aspx?pcguid=011b8bdf-6d56-4f87-be0d-0092136884d9&amp;id=435299) (This is the bug that #19522 was supposed to fix, but it didn't address the problem enough for RPS to drop back to the expected values)

**Workarounds, if any**

None available.

**Risk**

Moderate. The code is complex but efficient and reliable.

**Performance impact**

This change substantially improves performance in several scenarios:

* Application responsiveness is improved by unmapping views of memory mapped files when they are no longer in use, which allows the garbage collector to operate more efficiently
* Application shutdown performance is improved by creating fewer `MemoryMappedFile` instances which need to be finalized

**Is this a regression from a previous update?**

Not really. It's possible that 15.3 Preview 1 or Preview 2 could contain a regression for users on small systems.

**Root cause analysis:**

Failed in #19522 to account for `MemoryMappedInfo` being a long-lived object, where the strong reference to `MemoryMappedInfo._accessor` help memory for much longer than was desirable.

**How was the bug found?**

Reported by dogfooding.
</Description>
    <CreatedDate>18/05/2017</CreatedDate>
    <ClosedDate>01/06/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>19604</IssueID>
        <Title>OOM with memory mapped files</Title>
        <Description>```
System.AggregateException: One or more errors occurred. ---&gt; System.IO.IOException: Not enough storage is available to process this command.

   at System.IO.__Error.WinIOError(Int32 errorCode, String maybeFullPath)
   at System.IO.MemoryMappedFiles.MemoryMappedView.CreateView(SafeMemoryMappedFileHandle memMappedFileHandle, MemoryMappedFileAccess access, Int64 offset, Int64 size)
   at System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewStream(Int64 offset, Int64 size, MemoryMappedFileAccess access)
   at Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.CreateWritableStream()
   at Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService.TemporaryTextStorage.WriteText(SourceText text, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService.TemporaryTextStorage.&lt;&gt;c__DisplayClass13_0.&lt;WriteTextAsync&gt;b__0()
   at System.Threading.Tasks.Task.InnerInvoke()
   at System.Threading.Tasks.Task.Execute()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Microsoft.CodeAnalysis.RecoverableTextAndVersion.RecoverableText.&lt;SaveAsync&gt;d__7.MoveNext()
   --- End of inner exception stack trace ---
---&gt; (Inner Exception #0) System.IO.IOException: Not enough storage is available to process this command.

   at System.IO.__Error.WinIOError(Int32 errorCode, String maybeFullPath)
   at System.IO.MemoryMappedFiles.MemoryMappedView.CreateView(SafeMemoryMappedFileHandle memMappedFileHandle, MemoryMappedFileAccess access, Int64 offset, Int64 size)
   at System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewStream(Int64 offset, Int64 size, MemoryMappedFileAccess access)
   at Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.CreateWritableStream()
   at Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService.TemporaryTextStorage.WriteText(SourceText text, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService.TemporaryTextStorage.&lt;&gt;c__DisplayClass13_0.&lt;WriteTextAsync&gt;b__0()
   at System.Threading.Tasks.Task.InnerInvoke()
   at System.Threading.Tasks.Task.Execute()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Microsoft.CodeAnalysis.RecoverableTextAndVersion.RecoverableText.&lt;SaveAsync&gt;d__7.MoveNext()&lt;---
```</Description>
        <CreatedDate>17/05/2017</CreatedDate>
        <ClosedDate>01/06/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19570</IssueID>
        <Title>Use larger memory mapped files for temporary storage</Title>
        <Description>**Version Used**: 15.2

We can reduce the number of `MemoryMappedFile` instances getting disposed (a time-consuming process) by creating larger instances and using each memory mapped file as the storage for multiple temporary files. This will improve upon the performance gains already realized in #19522.

Currently files are created to match the specific size needed for each file in the solution. For an initial experiment, it might be reasonable to:

* Create files that are 1MiB in size, and use bump pointer allocation to place files within it
* When a file doesn't fit in the remaining space at the end of the last memory mapped file, create a new memory mapped file where it goes at the beginning
* Any file larger than 256KiB is placed in its own memory mapped file

⚠️ Currently these buffers are shared with the OOP workers. The serialization assumes that each temporary file is placed at offset 0 within the target memory mapped file. This will need to be updated to account for multiple temporary storage buffers within a single memory mapped file.</Description>
        <CreatedDate>16/05/2017</CreatedDate>
        <ClosedDate>01/06/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19493</IssueID>
        <Title>MemoryMappedInfo cleanup delays Visual Studio shutdown</Title>
        <Description>**tl;dr:** We create instances of `MemoryMappedInfo` (and its nested types). These types are disposable and have finalizers, but in some cases we do not explicitly dispose of instances. The large number of instances created for some user scenarios combined with non-deterministic cleanup resulted in a measurable (~50ms) increase in the time it takes to close Visual Studio for some scenarios.

What follows is a long and detailed breakdown of an investigation that started early Friday morning (5/12) in response to a performance regression detected the day before.

:bulb: When we refer to "meeting internal performance goals" in places like the contributor guide for Roslyn, but don't explain how external contributors are supposed to actually accomplish that, part of what we're talking about is covered by the system explained in detail below. If you were ever interested in what exactly we meant by that, I hope you enjoy the following read. :smile:

### How it started (5/11)

As part of my current role ("grasshopper") on the @dotnet/roslyn-infrastructure team, one of my responsibilities is scheduling and monitoring the incorporation of Roslyn code into Visual Studio itself. The whole process is very new to me, but a reasonably accurate way for a non-Microsoft to view this system is a build farm dedicated to running end-to-end tests prior to taking changes from one large team and applying them to another team. The system as a whole serves as both an early warning system for potential problems and helps identify the team responsible for various types of failures.

One of the toughest types of problems to detect reliably is performance regressions, and anyone who's tried to implement such tests in the past knows what I'm talking about. And the bigger the system under test, the harder it is to produce meaningful results. Small sections of code might be easy to benchmark, but in this case we're talking about ~15+ minute end-to-end user scenario tests of Visual Studio. To keep things flowing smoothly, performance tests in the system allow for some amount of "noise" in the test results. Deviations outside the allowed noise signify major problems where we cannot proceed until they are resolved (I haven't had to deal with one of these so there could be exceptions/special cases that I just don't know about). Deviations "under the degrade bar" do not cause a red flag in the system, still show up on performance reports based on a scoring system. Test scenarios that ran slower than the baseline are given a score based on how close to the bar they are: (actual-baseline)/(bar-baseline), and the highest values show up on the top of the report for manual investigation.

I mentioned "tests" and "scenarios". The two concepts are vital to understanding how we review long and complicated test sequence to identify specific possible regressions. The "test" refers to a complete end-to-end test, which might include opening VS, creating one or more projects, writing some code, building, running, and finally closing the solution and closing Visual Studio itself. Each test is divided into several named scenarios corresponding to specific actions, and target metrics may be defined either for the test as a whole or for specific scenarios.

:bulb: For anyone wanting to set up a system like this someday, I recommend you implement the ability to automatically assign metrics based on what you measure in a shipping release. This "baselining" ability allows you to establish target goals relatively easily that help ensure future releases of your product perform *at least as well* as the previous release, which is a great place to start when discussing development strategies to gradually improve the experience your customers have on a daily basis.

Thursday's test run included one test which did not exceed the bar but seemed "worse than normal", thus starting a manual review. The specific scenario was "Close VS", which in this test occurs after the solution is already closed. The degrade bar is set at 100ms slower than the previous release, and the build was showing a value of 52ms slower. The investigation started with a review of the history of this test using a tool that shows the builds on our team and the builds for the "mainline" that all the teams interact with. This overlay of the two branches is important because it can show with relatively high confidence whether a problem originated on our team (shows up on ours before mainline), or another team (shows up in mainline before ours). Here's the graph going back several builds. The orange branch is our team, and the purple branch is one of the main Visual Studio branches.

![image](https://cloud.githubusercontent.com/assets/1408396/26037111/46c48730-38b2-11e7-8a4e-a22204894d9c.png)

This investigation centered around the apparent new trend where we are sitting roughly 40-50ms slower than our goal line, and which started on our team builds prior to showing up in the main branch.

### Tracking down the problem (5/12)

Tracking down the problem is not always easy, but the two things you can do to be successful on this front are preparation and practice.

#### Preparation

Our end-to-end tests which we use for performance monitoring have PerfView running in the background. I don't have details regarding the exact configuration, but the key items would be:

1. Configure your sampling rate such that you have a "manageable" output data file size over the duration of your test. Since our tests are 15+ minutes, this means a slower sampling rate than the default.
2. Make sure you are enabling items that relate to your user experience. The meaning of this will vary by industry/application, but for me the two items I found valuable were having Thread Time enabled and also having marks inserted into the trace by the end-to-end test driver identifying exactly when a scenario (e.g. Close VS) started and ended.
3. Store the outputs of the PerfView traces for a sufficient amount of time that they can be used for comparative analysis in the future.

#### Practice

I had an advantage in investigating this by knowing three things:

1. The scenario which failed was Close VS, so I could filter the PerfView reports to start and end at the markers placed at the start and end of this scenario. As you can see from the graph, this is a ~300ms window out of the ~15 minute report.
2. Since I was investigating an elapsed time performance failure, the view of most immediate interest was the Thread Time view. I needed to account for the additional 50ms of time, regardless of whether that time was BLOCKED TIME or CPU TIME.
3. Even though this was my first experience ever with this test or scenario, I knew I could most easily track down the time by opening two reports side by side: one from a recent "slow" run, and the other from a recent "fast" run.

### Findings

I started with the Call Tree view examining the main thread. By comparing with the previous run, I pretty quickly narrowed down the additional time on the main thread to the following trace. The highlighted value accounts for all of the new time:

![image](https://cloud.githubusercontent.com/assets/1408396/26037288/d844c974-38b5-11e7-9d57-8c8fcf781a56.png)

As you can see, the main thread was blocked during this time, so to find the root cause we have to find out what it was waiting on. In this case, the answer was pretty easy to infer by looking at the thread activity histograms and asking "what would the CLR be waiting for during `clr!??EEShutdown`.

![image](https://cloud.githubusercontent.com/assets/1408396/26037348/cb182722-38b6-11e7-9a6f-818a9d89a63c.png)

Focusing on the finalizer thread showed two items of particular interest:

![image](https://cloud.githubusercontent.com/assets/1408396/26037410/b1d48458-38b7-11e7-95a0-4834f2403dff.png)

The in the conveniently available CoreCLR sources, we can see that these are the two methods called to [finalize a single object](https://github.com/dotnet/coreclr/blob/76cbc581382ebbcf745dd2b79ac02c419970808c/src/vm/finalizerthread.cpp#L98-L99).

* **clr!WKS::CallFinalizer**: This is slow when you have many finalizers, or when finalizers themselves are slow
* **clr!WKS::LogFinalization**: This has no measurable overhead normally, but a small amount of overhead when ETW events are being recorded. While the call within it, **clr!??ETW::GCLog::SendFinalizeObjectEvent**, probably should have been pruned by our analysis as measurement overhead imposed by PerfView recording, it nevertheless provided valuable insight for me. *Time here means a large number of objects are getting finalized.*

A closer look at **clr!WKS::CallFinalizer** revealed the problem with `MemoryMappedInfo`:

![image](https://cloud.githubusercontent.com/assets/1408396/26037484/e9aaa91a-38b8-11e7-900a-d1cdfdb0d313.png)

In the next step of my investigation, I wanted to determine how many `MemoryMappedInfo` objects were getting finalized when the CLR was trying to shut down. This part was rather difficult, but hopefully in the future it can be improved (filed Microsoft/perfview#200 and Microsoft/perfview#201). I filtered the events view to the start/end time for the scenario, set MaxRet to 110000 (so all events would show), and set the process filter to **devenv**. I then opened the **Microsoft-Windows-DotNETRuntime/GC/FinalizeObject** events, showed the **TypeID** column, and exported the resulting view as a CSV file. After opening the CSV file in Excel, I used a pivot table on the TypeID column to get a histogram which I sorted by the number of times an object of that type ID was finalized. Working from the top, I then examined all available events in PerfView of type **Microsoft-Windows-DotNETRuntime/GC/AllocationTick** to associate type IDs with type names. I only made it through the first 5 items before the sampling rate of AllocationTick stopped showing results.

![image](https://cloud.githubusercontent.com/assets/1408396/26037537/834c1a12-38ba-11e7-9d33-e0bc0d7e0e63.png)

### Follow-up

The solution appears to be two-fold:

1. Reduce the number of memory-mapped file handles that need to be cleaned up. For example, rather than create a memory mapped file for every temporary storage request, we could set a minimum size on the file at 1 MiB, and use smaller views within the file for temporary storage. When a request is too large to fit in the available space at the end of the current file, stop creating storage in that file and move to a new one.
2. Reduce the "weight" of finalization by reducing the size of the object graph referenced by finalizable objects. In particular, avoid making `MemoryMappedInfo` and `SharedReadableStream` themselves finalizable, and instead create a minimal type (or types) derived from `CriticalHandle` which is responsible for releasing the unmanaged resources.</Description>
        <CreatedDate>14/05/2017</CreatedDate>
        <ClosedDate>01/06/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19570</IssueID>
        <Title>Use larger memory mapped files for temporary storage</Title>
        <Description>**Version Used**: 15.2

We can reduce the number of `MemoryMappedFile` instances getting disposed (a time-consuming process) by creating larger instances and using each memory mapped file as the storage for multiple temporary files. This will improve upon the performance gains already realized in #19522.

Currently files are created to match the specific size needed for each file in the solution. For an initial experiment, it might be reasonable to:

* Create files that are 1MiB in size, and use bump pointer allocation to place files within it
* When a file doesn't fit in the remaining space at the end of the last memory mapped file, create a new memory mapped file where it goes at the beginning
* Any file larger than 256KiB is placed in its own memory mapped file

⚠️ Currently these buffers are shared with the OOP workers. The serialization assumes that each temporary file is placed at offset 0 within the target memory mapped file. This will need to be updated to account for multiple temporary storage buffers within a single memory mapped file.</Description>
        <CreatedDate>16/05/2017</CreatedDate>
        <ClosedDate>01/06/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19604</IssueID>
        <Title>OOM with memory mapped files</Title>
        <Description>```
System.AggregateException: One or more errors occurred. ---&gt; System.IO.IOException: Not enough storage is available to process this command.

   at System.IO.__Error.WinIOError(Int32 errorCode, String maybeFullPath)
   at System.IO.MemoryMappedFiles.MemoryMappedView.CreateView(SafeMemoryMappedFileHandle memMappedFileHandle, MemoryMappedFileAccess access, Int64 offset, Int64 size)
   at System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewStream(Int64 offset, Int64 size, MemoryMappedFileAccess access)
   at Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.CreateWritableStream()
   at Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService.TemporaryTextStorage.WriteText(SourceText text, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService.TemporaryTextStorage.&lt;&gt;c__DisplayClass13_0.&lt;WriteTextAsync&gt;b__0()
   at System.Threading.Tasks.Task.InnerInvoke()
   at System.Threading.Tasks.Task.Execute()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Microsoft.CodeAnalysis.RecoverableTextAndVersion.RecoverableText.&lt;SaveAsync&gt;d__7.MoveNext()
   --- End of inner exception stack trace ---
---&gt; (Inner Exception #0) System.IO.IOException: Not enough storage is available to process this command.

   at System.IO.__Error.WinIOError(Int32 errorCode, String maybeFullPath)
   at System.IO.MemoryMappedFiles.MemoryMappedView.CreateView(SafeMemoryMappedFileHandle memMappedFileHandle, MemoryMappedFileAccess access, Int64 offset, Int64 size)
   at System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewStream(Int64 offset, Int64 size, MemoryMappedFileAccess access)
   at Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.CreateWritableStream()
   at Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService.TemporaryTextStorage.WriteText(SourceText text, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService.TemporaryTextStorage.&lt;&gt;c__DisplayClass13_0.&lt;WriteTextAsync&gt;b__0()
   at System.Threading.Tasks.Task.InnerInvoke()
   at System.Threading.Tasks.Task.Execute()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Microsoft.CodeAnalysis.RecoverableTextAndVersion.RecoverableText.&lt;SaveAsync&gt;d__7.MoveNext()&lt;---
```</Description>
        <CreatedDate>17/05/2017</CreatedDate>
        <ClosedDate>01/06/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19761</IssueID>
        <Title>Access violation in RoslynCodeAnalysisService32 reading from memory mapped file</Title>
        <Description>**Version Used**: 15.3 preview 1

**Stack trace**

```
Application: ServiceHub.RoslynCodeAnalysisService32.exe
Framework Version: v4.0.30319
Description: The process was terminated due to an unhandled exception.
Exception Info: System.AccessViolationException
   at Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory+MemoryMappedInfo+SharedReadableStream.ReadByte()
   at System.IO.BinaryReader.ReadByte()
   at Roslyn.Utilities.ObjectReader.ReadValueWorker()
   at Roslyn.Utilities.ObjectReader.&lt;ReadValue&gt;b__25_0()
   at System.Threading.Tasks.Task`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].InnerInvoke()
   at System.Threading.Tasks.Task.Execute()
   at System.Threading.Tasks.Task.ExecutionContextCallback(System.Object)
   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)
   at System.Threading.Tasks.Task.ExecuteEntry(Boolean)
   at System.Threading.Tasks.ThreadPoolTaskScheduler.LongRunningThreadWork(System.Object)
   at System.Threading.ThreadHelper.ThreadStart_Context(System.Object)
   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)
   at System.Threading.ThreadHelper.ThreadStart(System.Object)
```</Description>
        <CreatedDate>24/05/2017</CreatedDate>
        <ClosedDate>16/06/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19522</IssueID>
        <Title>Reduce overhead from memory mapped files</Title>
        <Description>Fixes #19493

## Ask Mode

**Customer scenario**

Customer closes Visual Studio after working in a C# or Visual Basic project.

**Bugs this fixes:**

#19493 
DevDiv 435299 (external users: this internal bug tracks the internal performance regression and just points to the previous public bug where I placed all the actual info)

**Workarounds, if any**

Wait longer.

**Risk**

Low. Of several ways known ways to improve performance in this scenario, I chose the least risky one. Follow-up issues will be filed as opportunistic areas for further improvement in the future.

**Performance impact**

The time it takes to close Visual Studio is reduced by roughly 0.25-1ms for each file in the solution. This is a multiple second improvement for projects like Roslyn.sln.

**Is this a regression from a previous update?**

No. The bug appears to have been introduced with Visual Studio 2015.

**Root cause analysis:**

Failure of internal Regression Prevention System (RPS) tests to exercise code paths related to this bug, and failure to go through PerfView traces in detail for scenarios targeting very large solutions. Discussions are taking place regarding improvements to PerfView which should help reveal these kinds of problems for both us and developers of other applications before they cause problems.

**How was the bug found?**

RPS tests</Description>
        <CreatedDate>15/05/2017</CreatedDate>
        <ClosedDate>17/05/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19522</IssueID>
        <Title>Reduce overhead from memory mapped files</Title>
        <Description>Fixes #19493

## Ask Mode

**Customer scenario**

Customer closes Visual Studio after working in a C# or Visual Basic project.

**Bugs this fixes:**

#19493 
DevDiv 435299 (external users: this internal bug tracks the internal performance regression and just points to the previous public bug where I placed all the actual info)

**Workarounds, if any**

Wait longer.

**Risk**

Low. Of several ways known ways to improve performance in this scenario, I chose the least risky one. Follow-up issues will be filed as opportunistic areas for further improvement in the future.

**Performance impact**

The time it takes to close Visual Studio is reduced by roughly 0.25-1ms for each file in the solution. This is a multiple second improvement for projects like Roslyn.sln.

**Is this a regression from a previous update?**

No. The bug appears to have been introduced with Visual Studio 2015.

**Root cause analysis:**

Failure of internal Regression Prevention System (RPS) tests to exercise code paths related to this bug, and failure to go through PerfView traces in detail for scenarios targeting very large solutions. Discussions are taking place regarding improvements to PerfView which should help reveal these kinds of problems for both us and developers of other applications before they cause problems.

**How was the bug found?**

RPS tests</Description>
        <CreatedDate>15/05/2017</CreatedDate>
        <ClosedDate>17/05/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Workspaces/Core/Desktop/Workspace/Host/TemporaryStorage/TemporaryStorageServiceFactory.CopiedMemoryMappedViewHandle.cs</File>
      <File>src/Workspaces/Core/Desktop/Workspace/Host/TemporaryStorage/TemporaryStorageServiceFactory.MemoryMappedInfo.cs</File>
      <File>src/Workspaces/Core/Desktop/Workspace/Host/TemporaryStorage/TemporaryStorageServiceFactory.ReferenceCountedDisposable.cs</File>
      <File>src/Workspaces/Core/Desktop/Workspace/Host/TemporaryStorage/TemporaryStorageServiceFactory.cs</File>
      <File>src/Workspaces/Core/Portable/Execution/AbstractReferenceSerializationService.cs</File>
      <File>src/Workspaces/Core/Portable/Execution/Serializer_Asset.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/Host/TemporaryStorage/ITemporaryStorageService2.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/Host/TemporaryStorage/ITemporaryStorageWithName.cs</File>
      <File>src/Workspaces/CoreTest/WorkspaceServiceTests/ReferenceCountedDisposableTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>19278</IssueID>
    <Title>IObjectCreationExpression API Change</Title>
    <Description>**Customer scenario**

All IOperation based analyzers will generate large number of false positives OR not analyze code within object and collection initializers. Given that such a code pattern is very common, this can be a dogfood blocker for IOperation analyzers (FXCop). 

**Bugs this fixes:**

Fixes #18115

There are still 2 remaining bugs affecting this area:
1. #18781: IOperation API shape for collection initializer expressions
2. #19276: Missing Field/Property reference expression nodes in object creation initializer node

**Workarounds, if any**

The analyzer users will have to either suppress all IOperation analyzers on methods containing object/collection initializers or disable these analyzers.

**Risk**

Low. We are just returning the operation nodes as they are in the bound tree rather than synthesizing new symbol initializer nodes.

**Performance impact**

None

**Is this a regression from a previous update?**

No, this was the original IOperation API implementation

**Root cause analysis:**

The underlying reason is that the current API shape of IObjectCreationExpression only exposes member initializers, not collection initializers.

There are couple of changes in this PR:
1. API change: `ImmutableArray&lt;ISymbolInitializer&gt; MemberInitializers` is changed to `ImmutableArray&lt;IOperation&gt; Initializers` as per design time decision.
2. Implementation changes:
   1. Instead of returning the member initializers as synthesized ISymbolInitializer nodes, we now return member initializers as IAssignmentExpression nodes. This ensures completeness of IOperation tree.
   2. Now we also return the collection initializer expressions within an object creation expression.

**How was the bug found?**

Dogfooding.
</Description>
    <CreatedDate>04/05/2017</CreatedDate>
    <ClosedDate>09/05/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>18115</IssueID>
        <Title>IObjectCreationExpression API shape</Title>
        <Description>```
    public interface IObjectCreationExpression : IHasArgumentsExpression
    {
        /// &lt;summary&gt;
        /// Constructor to be invoked on the created instance.
        /// &lt;/summary&gt;
        IMethodSymbol Constructor { get; }
        /// &lt;summary&gt;
        /// Explicitly-specified member initializers.
        /// &lt;/summary&gt;
        ImmutableArray&lt;ISymbolInitializer&gt; MemberInitializers { get; }
    }
```

The shady part is MemberInitializers, which only expose a part of the IOperation tree within the object member initializer.

Let me give an example:
```
Class F
    Public Field As Integer
End Class

Class C
    Public Sub M1()
        Dim x2 = New F() With {.Field = 2}
    End Sub
End Class
```

IOperation tree for object creation:
```
IOperation tree for "Dim x2 = New F() With {.Field = 2}"

IVariableDeclarationStatement (1 variables) (OperationKind.VariableDeclarationStatement)
  IVariableDeclaration: x2 As F (OperationKind.VariableDeclaration)
    Initializer: IObjectCreationExpression (Constructor: Sub F..ctor()) (OperationKind.ObjectCreationExpression, Type: F)
        Member Initializers: IFieldInitializer (Field: F.Field As System.Int32) (OperationKind.FieldInitializerInCreation)
            ILiteralExpression (Text: 2) (OperationKind.LiteralExpression, Type: System.Int32, Constant: 2)
```

IOperation tree for it's child node, object member initializer:
```
IOperation tree for "With {.Field = 2}"

IOperation (OperationKind.None)
```

IOperation tree for one of the child nodes of the member initializer, NamedFieldInitializerSyntax:
```
IOperation tree for ".Field = 2"

IAssignmentExpression (OperationKind.AssignmentExpression, Type: System.Int32)
  Left: IFieldReferenceExpression: F.Field As System.Int32 (OperationKind.FieldReferenceExpression, Type: System.Int32)
      Instance Receiver:  (OperationKind.None)
  Right: ILiteralExpression (Text: 2) (OperationKind.LiteralExpression, Type: System.Int32, Constant: 2)
```

I think we either need to change `MemberInitializers` to return the entire IOperation tree for each initializer (which would be the IAssignmentExpression for the field initializer) OR replace MemberInitializers with `InitializerOpt` of new OperationKind.ObjectMemberInitializer, which exposes all the initializer expressions.</Description>
        <CreatedDate>23/03/2017</CreatedDate>
        <ClosedDate>09/05/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>18781</IssueID>
        <Title>IOperation API shape for object and collection initializer expressions</Title>
        <Description>Currently, BoundCollectionIntializerExpression has OperationKind.None and implements IOperation. This means that we completely cut-off the operations within a collection initializer, including even the nested initializers.

We need to design the API shape for Collection initializers.

1. Do we need an `ICollectionInitializerExpression`? Theoretically, we don't need it as `IObjectCreationExpression.Initializers` can return the child collection element initializer nodes of a collection initializer.
2. Do we need an `ICollectionElementInitializerExpression`? We have 2 possible designs:
   1. Follow the VB bound tree pattern, which stores a `BoundCall` for collection element initializer, so we don't need a new API. However, C# doesn't store this bound call, but instead has a `BoundCollectionElementInitializerExpression` (with invoked method name and arguments) and `BoundDynamicCollectionElementInitializer` (with possible applicable methods and arguments) . So we need to synthesize such a bound call for C# and return it as an initializer. Note that this approach introduces an implicit compiler generated IOperation node in the operation tree.
   2. Add the following API and our Operation tree node for CollectionElementInitializerExpression, can have language specific implementations that delegate to either BoundCall (VB) or BoundICollectionElementInitializerExpression or BoundDynamicCollectionElementInitializer (C#):
```
namespace Microsoft.CodeAnalysis.Semantics
{
    /// &lt;summary&gt;
    /// Represents a collection element initializer expression.
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;
    /// This interface is reserved for implementation by its associated APIs. We reserve the right to
    /// change it in the future.
    /// &lt;/remarks&gt;
    public interface ICollectionElementInitializerExpression : IHasArgumentsExpression
    {
        /// &lt;summary&gt;
        /// Set of applicable methods for an implicit dynamic invocation OR the implicit Add method symbol for non-dynamic invocation.
        /// &lt;/summary&gt;
        ImmutableArray&lt;IMethodSymbol&gt; ApplicableMethods { get; }

        /// &lt;summary&gt;
        /// Flag indicating if this is a dynamic initializer invocation.
        /// &lt;/summary&gt;
        bool IsDynamic { get; }
    }
}
```


look for an example here  https://github.com/dotnet/roslyn/issues/18509  </Description>
        <CreatedDate>18/04/2017</CreatedDate>
        <ClosedDate>12/07/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19276</IssueID>
        <Title>Missing Field/Property reference expression nodes in object creation initializer node</Title>
        <Description>
```
internal class Class
{
    public int Property { get; set; }
    public int Field;

    public void M()
    {
        var c = new Class() { Field = 0, Property = 0 };
    }
}
```

```
IOperation tree for "new Class() { Field = 0, Property = 0 }"

IObjectCreationExpression (Constructor: Class..ctor()) (OperationKind.ObjectCreationExpression, Type: Class) (Syntax: 'new Class() ... perty = 0 }')
  Initializers(2): IAssignmentExpression (OperationKind.AssignmentExpression, Type: System.Int32) (Syntax: 'Field = 0')
      Left: IOperation:  (OperationKind.None) (Syntax: 'Field')
      Right: ILiteralExpression (Text: 0) (OperationKind.LiteralExpression, Type: System.Int32, Constant: 0) (Syntax: '0')
    IAssignmentExpression (OperationKind.AssignmentExpression, Type: System.Int32) (Syntax: 'Property = 0')
      Left: IOperation:  (OperationKind.None) (Syntax: 'Property')
      Right: ILiteralExpression (Text: 0) (OperationKind.LiteralExpression, Type: System.Int32, Constant: 0) (Syntax: '0')
```

**Expected:**
1.  `Left: IOperation:  (OperationKind.None) (Syntax: 'Field')` must be an IFieldReferenceExpression and
2. `Left: IOperation:  (OperationKind.None) (Syntax: 'Property')` must be an IPropertyReferenceExpression

Similar code in VB does contain the field and property reference expressions on Left:

```
Friend Class [Class]
    Public Field As Integer
    Public Property Prop As Integer

    Public Sub M()
        Dim c = New [Class]() With {.Field = 0, .Prop = 0}
    End Sub
End Class
```

```
IOperation tree for "New [Class]() With {.Field = 0, .Prop = 0}"

IObjectCreationExpression (Constructor: Sub [Class]..ctor()) (OperationKind.ObjectCreationExpression, Type: [Class]) (Syntax: 'New [Class] ...  .Prop = 0}')
  Initializers(2): IAssignmentExpression (OperationKind.AssignmentExpression, Type: System.Int32) (Syntax: '.Field = 0')
      Left: IFieldReferenceExpression: [Class].Field As System.Int32 (OperationKind.FieldReferenceExpression, Type: System.Int32) (Syntax: 'Field')
          Instance Receiver: IOperation:  (OperationKind.None) (Syntax: 'New [Class] ...  .Prop = 0}')
      Right: ILiteralExpression (Text: 0) (OperationKind.LiteralExpression, Type: System.Int32, Constant: 0) (Syntax: '0')
    IAssignmentExpression (OperationKind.AssignmentExpression, Type: System.Void) (Syntax: '.Prop = 0')
      Left: IIndexedPropertyReferenceExpression: Property [Class].Prop As System.Int32 (OperationKind.PropertyReferenceExpression, Type: System.Int32) (Syntax: 'Prop')
          Instance Receiver: IOperation:  (OperationKind.None) (Syntax: 'New [Class] ...  .Prop = 0}')
      Right: ILiteralExpression (Text: 0) (OperationKind.LiteralExpression, Type: System.Int32, Constant: 0) (Syntax: '0')
```

```</Description>
        <CreatedDate>04/05/2017</CreatedDate>
        <ClosedDate>12/07/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/BoundTree/Expression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Diagnostics/OperationAnalyzerTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IObjectCreationExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IParameterReferenceExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_ISymbolInitializer.cs</File>
      <File>src/Compilers/Core/Portable/Generated/Operations.xml.Generated.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IObjectCreationExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationWalker.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/OperationTreeVerifier.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>19237</IssueID>
    <Title>Reuse local rewriter to derive arguments for IHasArgumentsExpression</Title>
    <Description>This PR contains following changes:

1. Add `Binder` to `BoundCall`, `BoundIndexerAccess` and `BoundObjectCreationExpression`.
2. Refactored arguments rewriting related methods in `LocalRewriter`, everything needed by `IOperation` is refactored into static methods. 
3. Change `DeriveArguments` method to reuse `LocalRewriter` (only static methods).
4. Add a field `IsLeftOfAssignment` to `BoundIndexerAccess`, which is used to decide whether the parameter symbol of indexer setter or getter should be used for default argument calculation.
5. Add tests.

This seems to address most of the regular scenarios we (i.e. existing FxCop analyzers) care about.

#18722 is not addressed in this PR: If the bound node has errors, we currently still expose it `IInvocationExpression` (or other `IHasArgumentsExpression`), with all provided arguments as `IArgument`.

**Customer scenario**

The C# version of `IHasArgumentsExpression.ArgumentsInEvaluationOrder` was basically reusing the implementation of (now removed) `ArgumentsInSourceOrder`, which was a separate implementation from similar logic in rewriter and results in incorrect/inconsistent default argument and param array argument operations. That in turn would cause a large amount of false positive/negatives in analyzers.

**Bugs this fixes:**

#18549, #7960,  #8813, #8786 and #19382 

**Workarounds, if any**

No. Have to disable analyzers relies on the `IHasArgumentsExpression.ArgumentsInEvaluationOrder` interface to avoid false positive/negatives.

**Risk**

Low. Although the PR touches both c# bound tree and local rewriter, the changes that affects compiler code path is purely refactoring which shouldn't cause any regression. The actual behavior change is limited within IOperation realm behind the feature flag.


**Performance impact**

Low. 

**Is this a regression from a previous update?**

No.

**Root cause analysis:**

IOperation APIs are actively changing and being developed.

**How was the bug found?**

This has been a known issue since the initial IOperation implementation.</Description>
    <CreatedDate>04/05/2017</CreatedDate>
    <ClosedDate>18/05/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>18722</IssueID>
        <Title>Add `IInvalidInvocationExpression` interafce</Title>
        <Description>Currently in C#, an invalid invocation is represented by an `IInvocationExpression` operation, but it might violate the contract of `IInvocationExpression`. For example, we can't provide a list of arguments in evaluation order correctly if we have extra arguments that don't match any parameter, or multiple arguments are matching to a single parameter, etc. On the other hand, making an invalid invocation an `IInvalidExpression` would solve the problem but it would be unnecessarily lossy since in many cases compiler does have more details that users might find useful to do further analysis.

The goal would be to expose as much information of a invalid invocation as possible at best effort, without violating the API contract of `IInvocationExpression`, hence the new `IInvalidInvocationExpression` interface.

Here's the notes from our discussion:
- Will be a sibling of `IInvocationExpression` (child of `IHasArgumentExpression`)
- Should contain candidate symbols and candidate reason.
- Has a list `ArgumentValues` of type `IOperation` that were passed to the invocation.
- And a receiver of type` IOperatoin`
- We would also like an api/extension `TryGetParameterForArgumentValue`, indicating it's best effort and may fail

@dotnet/analyzer-ioperation </Description>
        <CreatedDate>15/04/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>18549</IssueID>
        <Title>`IHasArgumentsExpression.ArgumentsInEvaluationOrder` in C# should not use private implementation</Title>
        <Description>Currently, there is a lot of logic duplicated in C#'s implementation and there is a lot of opportunities to deviate from what LocalRewriter is doing. I believe our goal should be to return result consistent with what LocalRewriter would produce. As such we should find a way to share that logic, IOperation should not have its own private implementation.

With this in mind, I have made the change for IHasArgumentsExpression interface in #18494 with minimal change in implementation, to avoid doing unnecessary throwaway work. As a result, **the contract for `IHasArgumentsExpression.ArgumentsInEvaluationOrder` is broken**, as current implementation is the old `ArgumentsInSourceOrder`, therefore missing all default arguments (including empty param array). This issue is intended to track this as well, as I believe getting rid of private implementation would also fix this.</Description>
        <CreatedDate>08/04/2017</CreatedDate>
        <ClosedDate>18/05/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>7960</IssueID>
        <Title>Default argument operation doesn't handle caller info attributes</Title>
        <Description>We need to decide if we want to make argument operation handles caller info attributes.
</Description>
        <CreatedDate>14/01/2016</CreatedDate>
        <ClosedDate>18/05/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>8813</IssueID>
        <Title>IOperation: A proposal to change design around IHasArgumentsExpression, IInvocationExpression and IArgument interfaces.</Title>
        <Description>**Exposing the set of arguments**

Currently we have two APIs that are supposed to expose arguments and every implementer has to implement both.
In IHasArgumentsExpression, which is IInvocationExpression inherits from:

```
        /// &lt;summary&gt;
        /// Arguments of the invocation, excluding the instance argument. Arguments are in parameter order,
        /// and params/ParamArray arguments have been collected into arrays. Default values are supplied for
        /// optional arguments missing in source.
        /// &lt;/summary&gt;
        ImmutableArray&lt;IArgument&gt; ArgumentsInParameterOrder { get; }
```

In IInvocationExpression 

```
        /// &lt;summary&gt;
        /// Arguments of the invocation, excluding the instance argument. Arguments are in the order specified in source,
        /// and params/ParamArray arguments have been collected into arrays. Arguments are not present
        /// unless supplied in source.
        /// &lt;/summary&gt;
        ImmutableArray&lt;IArgument&gt; ArgumentsInSourceOrder { get; }
```

I am not sure if having two these APIs provides much value. I believe that it would be much more useful to have a single API in IHasArgumentsExpression:

```
        /// &lt;summary&gt;
        /// Arguments of the invocation, excluding the instance argument. Arguments are in evaluation order,
        /// and params/ParamArray arguments have been collected into arrays. Default values are supplied for
        /// optional arguments missing in source.
        /// &lt;/summary&gt;
        ImmutableArray&lt;IArgument&gt; ArgumentsInEvaluationOrder { get; }
```

If we feel that sometimes consumers would want to traverse arguments in source or parameter order, we can provide helpers like this as extension methods for IHasArgumentsExpression interface because all the relevant information should be available from IArguments.

**IArgument, ArgumentKinds and param arrays**

It is not obvious what value do we get from distinguishing between Positional and Named arguments. I believe Analyzers will be more interested in the order, in which arguments are evaluated (ArgumentsInEvaluationOrder solves that). Knowing whether the argument was named doesn't look that important and can always be discovered from syntax. 

The requirement to create a separate IArgument of ParamArray kind for each element of param array

```
        /// &lt;summary&gt;
        /// Argument becomes an element of an array that matches a trailing C# params or VB ParamArray parameter.
        /// &lt;/summary&gt;
        ParamArray = 0x3,
```

means that we will create trees of different shape for situations when param array was created by the compilers and when the array was passed explicitly. Do Analyzers really care that much about param array that they will be willing to be prepared to deal with two different tree shapes for semantically equivalent code?

Another issue with the current design is that it looks like an empty param array created by compilers won't have any representation in the tree at all, because there is no ArgumentKind that could be used for such an argument.

To address all these issues, I propose to change the current set of ArgumentKinds as follows (note, the meaning of ParamArray kind is changed):

```
    /// &lt;summary&gt;
    /// Kinds of arguments.
    /// &lt;/summary&gt;
    public enum ArgumentKind
    {
        None = 0x0,

        /// &lt;summary&gt;
        /// Argument value is explicitly supplied.
        /// &lt;/summary&gt;
        Explicit = 0x1,

        /// &lt;summary&gt;
        /// Argument is a param array created by compilers for the matching C# params or VB ParamArray parameter. Note, the value is a an array creation expression that encapsulates all the elements, if any.
        /// &lt;/summary&gt;
        ParamArray = 0x2,

        /// &lt;summary&gt;
        /// Argument is a default value supplied automatically by the compilers.
        /// &lt;/summary&gt;
        DefaultValue = 0x3
    }
```

See related issues: #8805, #8786, #8781, #8773.
</Description>
        <CreatedDate>17/02/2016</CreatedDate>
        <ClosedDate>18/05/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>8786</IssueID>
        <Title>IOperation: What is the value of ParamArray arguments?</Title>
        <Description>Given the following API definition:

```
    /// &lt;summary&gt;
    /// Kinds of arguments.
    /// &lt;/summary&gt;
    public enum ArgumentKind
    {
        None = 0x0,

        /// &lt;summary&gt;
        /// Argument is specified positionally and matches the parameter of the same ordinality.
        /// &lt;/summary&gt;
        Positional = 0x1,
        /// &lt;summary&gt;
        /// Argument is specified by name and matches the parameter of the same name.
        /// &lt;/summary&gt;
        Named = 0x2,
        /// &lt;summary&gt;
        /// Argument becomes an element of an array that matches a trailing C# params or VB ParamArray parameter.
        /// &lt;/summary&gt;
        ParamArray = 0x3,
        /// &lt;summary&gt;
        /// Argument was omitted in source but has a default value supplied automatically.
        /// &lt;/summary&gt;
        DefaultValue = 0x4
    }
```

It looks like the shape of the IOperation tree is going to depend on whether param array argument was crated by the compiler. Given this method definition:

```
static void Test(params string[] y)
```

The following call will have two ParamArray arguments, corresponding to `"a"` and `"b"`:

```
Test("a", "b");
```

But this call will have one Positional argument, corresponding to `new [] {"a", "b"}`:

```
Test(new [] {"a", "b"});
```

These two calls are semantically identical. Do we really want analyzers to be prepared to deal with this difference? 

What argument should be created for this scenario, where `"a"` is a named argument and a param array element at the same time?

```
    static void Main()
    {
        Test(y: "a", x:10);
    }

    static void Test(int x, params string[] y)
    {
        System.Console.WriteLine(y[0]);
    }
```
</Description>
        <CreatedDate>17/02/2016</CreatedDate>
        <ClosedDate>18/05/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19382</IssueID>
        <Title>A combination of discard with arglist crashes compiler</Title>
        <Description>```
        [Fact]
        public void DiscardAndArgList()
        {
            var text = @"
using System;
public class C
{
    static void Main()
    {
        M(out _, __arglist(2, 3, true));
    }
    
    static void M(out int x, __arglist)
    {    
        x = 0;
        DumpArgs(new ArgIterator(__arglist));
    }

    static void DumpArgs(ArgIterator args)
    {
        while(args.GetRemainingCount() &gt; 0)
        {
            TypedReference tr = args.GetNextArg();
            object arg = TypedReference.ToObject(tr);
            Console.Write(arg);
        }
    }
}";
            var compilation = CreateStandardCompilation(text, options: TestOptions.ReleaseExe, parseOptions: TestOptions.Regular);

            compilation.VerifyDiagnostics(
                );

            CompileAndVerify(compilation, expectedOutput: "23True");
        }
```

{"Unexpected value 'DiscardExpression' of type 'Microsoft.CodeAnalysis.CSharp.BoundKind'"}
&gt;	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitExpressionCore(Microsoft.CodeAnalysis.CSharp.BoundExpression expression, bool used) Line 314	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitExpression(Microsoft.CodeAnalysis.CSharp.BoundExpression expression, bool used) Line 56	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitAddressOfTempClone(Microsoft.CodeAnalysis.CSharp.BoundExpression expression) Line 194	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitAddress(Microsoft.CodeAnalysis.CSharp.BoundExpression expression, Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.AddressKind addressKind) Line 117	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitArgument(Microsoft.CodeAnalysis.CSharp.BoundExpression argument, Microsoft.CodeAnalysis.RefKind refKind) Line 584	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitArguments(System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.CSharp.BoundExpression&gt; arguments, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol&gt; parameters) Line 759	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitCallExpression(Microsoft.CodeAnalysis.CSharp.BoundCall call, Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.UseKind useKind) Line 1488	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitExpressionCore(Microsoft.CodeAnalysis.CSharp.BoundExpression expression, bool used) Line 92	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitExpressionCoreWithStackGuard(Microsoft.CodeAnalysis.CSharp.BoundExpression expression, bool used) Line 72	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitExpression(Microsoft.CodeAnalysis.CSharp.BoundExpression expression, bool used) Line 60	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitStatement(Microsoft.CodeAnalysis.CSharp.BoundStatement statement) Line 40	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitStatementAndCountInstructions(Microsoft.CodeAnalysis.CSharp.BoundStatement statement) Line 99	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitSequencePointStatement(Microsoft.CodeAnalysis.CSharp.BoundSequencePoint node) Line 342	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitStatement(Microsoft.CodeAnalysis.CSharp.BoundStatement statement) Line 32	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitStatements(System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.CSharp.BoundStatement&gt; statements) Line 639	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitBlock(Microsoft.CodeAnalysis.CSharp.BoundBlock block) Line 616	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitStatement(Microsoft.CodeAnalysis.CSharp.BoundStatement statement) Line 24	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitStatementList(Microsoft.CodeAnalysis.CSharp.BoundStatementList list) Line 107	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitStatement(Microsoft.CodeAnalysis.CSharp.BoundStatement statement) Line 44	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.GenerateImpl() Line 248	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.Generate() Line 183	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.MethodCompiler.GenerateMethodBody(Microsoft.CodeAnalysis.CSharp.Emit.PEModuleBuilder moduleBuilder, Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol method, int methodOrdinal, Microsoft.CodeAnalysis.CSharp.BoundStatement block, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.CodeGen.LambdaDebugInfo&gt; lambdaDebugInfo, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.CodeGen.ClosureDebugInfo&gt; closureDebugInfo, Microsoft.CodeAnalysis.CSharp.StateMachineTypeSymbol stateMachineTypeOpt, Microsoft.CodeAnalysis.CodeGen.VariableSlotAllocator variableSlotAllocatorOpt, Microsoft.CodeAnalysis.DiagnosticBag diagnostics, Microsoft.CodeAnalysis.CodeGen.DebugDocumentProvider debugDocumentProvider, Microsoft.CodeAnalysis.CSharp.ImportChain importChainOpt, bool emittingPdb, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.CodeGen.SourceSpan&gt; dynamicAnalysisSpans) Line 1339	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethod(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol methodSymbol, int methodOrdinal, ref Microsoft.CodeAnalysis.CSharp.Binder.ProcessedFieldInitializers processedInitializers, Microsoft.CodeAnalysis.CSharp.SynthesizedSubmissionFields previousSubmissionFields, Microsoft.CodeAnalysis.CSharp.TypeCompilationState compilationState) Line 1109	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol containingType) Line 434	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedTypeAsTask.AnonymousMethod__0() Line 324	C#

</Description>
        <CreatedDate>10/05/2017</CreatedDate>
        <ClosedDate>18/05/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Expressions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Invocation.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Query.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Statements.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/BoundExpression.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/BoundObjectCreationExpression.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/Constructors.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/Expression.cs</File>
      <File>src/Compilers/CSharp/Portable/CodeGen/Optimizer.cs</File>
      <File>src/Compilers/CSharp/Portable/Compiler/MethodBodySynthesizer.cs</File>
      <File>src/Compilers/CSharp/Portable/Compiler/MethodCompiler.cs</File>
      <File>src/Compilers/CSharp/Portable/Generated/BoundNodes.xml.Generated.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/AsyncRewriter/AwaitExpressionSpiller.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/LambdaRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_AnonymousObjectCreation.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_BinaryOperator.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_Call.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_CompoundAssignmentOperator.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_Conversion.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_IndexerAccess.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_Literal.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_ObjectCreationExpression.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_TupleCreationExpression.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_UnaryOperator.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/MethodToClassRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/SyntheticBoundNodeFactory.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedEntryPointSymbol.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Diagnostics/OperationAnalyzerTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IArgument.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_InvalidExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/OutVarTests.cs</File>
      <File>src/Compilers/Test/Utilities/CSharp/CSharpTestBase.cs</File>
      <File>src/Compilers/Test/Utilities/CSharp/SemanticModelTestBase.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Source/ExpressionCompiler/CompilationContext.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Source/ExpressionCompiler/Rewriters/LocalDeclarationRewriter.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>19211</IssueID>
    <Title>Don't run naming rules on symbols with no name</Title>
    <Description>Fixes #19106

Ask Mode
=======

**Customer scenario**: The customer has broken code such that there's a declared symbol with no name ("interface" with no name), and the naming style analyzer throws exceptions into the error list.

**Bugs this fixes:** #19106

**Workarounds, if any** No reasonable ones.

**Risk**: Very low. It's a very simple empty string check, and no other features depend on this.

**Risk**: Very low. It's a very simple empty string check.

**Performance impact**: Very low. It's a very simple empty string check.

**Is this a regression from a previous update?** No

**Root cause analysis:** A missed scenario. Unit tests are added.

**How was the bug found?** Dogfooding</Description>
    <CreatedDate>03/05/2017</CreatedDate>
    <ClosedDate>08/05/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>19106</IssueID>
        <Title>Naming Styles fantastic failure in broken code.</Title>
        <Description>```c#
namespace Microsoft.CodeAnalysis.Host
{
    /// &lt;summary&gt;
    /// This service allows you to persist information relative to solution, projects and documents.
    /// &lt;/summary&gt;
    public interface IPersistentStorageService : IWorkspaceService
    {
        IPersistentStorage GetStorage(Solution solution);
    }

    internal interface 
}
```

Note hte unterminated interface.  First, observe the following suggestion tag span:

![image](https://cloud.githubusercontent.com/assets/4564579/25547764/ffbaf9fa-2c1d-11e7-9d89-910d8538e07b.png)

Next, observe the totally broken suggestion:

![image](https://cloud.githubusercontent.com/assets/4564579/25547771/087da114-2c1e-11e7-8ca5-acdbb18fd7fd.png)


Note: that "IHost" is being picked because the *namespace* we're contained in ends with "Host".</Description>
        <CreatedDate>28/04/2017</CreatedDate>
        <ClosedDate>08/05/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19106</IssueID>
        <Title>Naming Styles fantastic failure in broken code.</Title>
        <Description>```c#
namespace Microsoft.CodeAnalysis.Host
{
    /// &lt;summary&gt;
    /// This service allows you to persist information relative to solution, projects and documents.
    /// &lt;/summary&gt;
    public interface IPersistentStorageService : IWorkspaceService
    {
        IPersistentStorage GetStorage(Solution solution);
    }

    internal interface 
}
```

Note hte unterminated interface.  First, observe the following suggestion tag span:

![image](https://cloud.githubusercontent.com/assets/4564579/25547764/ffbaf9fa-2c1d-11e7-9d89-910d8538e07b.png)

Next, observe the totally broken suggestion:

![image](https://cloud.githubusercontent.com/assets/4564579/25547771/087da114-2c1e-11e7-8ca5-acdbb18fd7fd.png)


Note: that "IHost" is being picked because the *namespace* we're contained in ends with "Host".</Description>
        <CreatedDate>28/04/2017</CreatedDate>
        <ClosedDate>08/05/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/NamingStyles/NamingStylesTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/NamingStyles/NamingStylesTests_OptionSets.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/Analyzers/NamingStyleDiagnosticAnalyzerBase.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>19164</IssueID>
    <Title>support CasePatternSwitchLabel in StatementSyntaxComparer</Title>
    <Description>**Customer scenario**

Variables declared by patterns within switch statements are matched incorrectly by StatementSyntaxComparer. Fixing this. Have to add one more pass for the matcher. It does not affect the performance. However, it would be nice to re-consider this. Created #19163.

**Bugs this fixes:**

Fixes #18970

**Workarounds, if any**

**Risk**

Low

**Performance impact**
Low 

**Is this a regression from a previous update?**

**Root cause analysis:**

How did we miss it?  What tests are we adding to guard against it in the future?

**How was the bug found?**

Planned</Description>
    <CreatedDate>02/05/2017</CreatedDate>
    <ClosedDate>16/05/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>19163</IssueID>
        <Title>Microsoft.CodeAnalysis.Differencing.Match.ComputeMatchForLabel performance and maintainability improvements</Title>
        <Description>The Microsoft.CodeAnalysis.Differencing.Match.ComputeMatchForLabel method attempts to approximate an O(N^2) matching algorithm with multiple passes with difference distance thresholds. It is expected that those passes are often executed within O(N). However, it is not guaranteed and, O(N^2) still happens often.

Moreover, it is observed that:
1. Passes perform the same calculations multiple times. We can fix this by saving information between passes.
2. Solving some matching issues involve maintaining the set of thresholds. See #18970. This looks fragile.</Description>
        <CreatedDate>02/05/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>18970</IssueID>
        <Title>support CasePatternSwitchLabel in StatementSyntaxComparer </Title>
        <Description>related to #17991

Consider the following code changes:
```
            var src1 = @"
 switch(shape)
 {
     case Circle circle: return 1;
     default: return 4;
 }
 ";
 
             var src2 = @"
 switch(shape)
 {
     case Circle c: return 1;
     case Point p: return 0;
     default: return 4;
 }
 ";
```

See RudeEditStatementTests
**Expected:** 
MatchingPairs should contain "circle" vs."c".

**Actual:**
MatchingPairs contain "circle" vs. "p".

</Description>
        <CreatedDate>25/04/2017</CreatedDate>
        <ClosedDate>16/05/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/EditAndContinue/RudeEditStatementTests.cs</File>
      <File>src/Features/CSharp/Portable/EditAndContinue/StatementSyntaxComparer.cs</File>
      <File>src/Workspaces/Core/Portable/Differencing/Match.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>19126</IssueID>
    <Title>Avoid allocations due to use of Keys/Values instead of GetEnumerator</Title>
    <Description>`ImmutableDictionary&lt;TKey, TValue&gt;` provides a non-allocating implementation of `GetEnumerator()`, but does not offer non-allocating implementations of the `Keys` or `Values` properties (dotnet/corefx#249 and linked issues). This pull request adds a `Deconstruct` extension method for `KeyValuePair&lt;TKey, TValue&gt;`, leveraging a new C# feature to provide almost identical use-site code for these properties without actually incurring the allocation overhead.

:memo: This pull request builds on the change in #19125 to avoid merge conflicts (~~the first commit in the branch overlaps~~) (edit: no longer applies).

## Ask Mode

**Customer scenario**

No observable changes.

* Use `GetEnumerator()` instead of `Keys` where applicable
* Use `GetEnumerator()` instead of `Values` where applicable
* Add a `Deconstruct` extension method so the above changes can be implemented with minimal changes to the actual code structure

**Bugs this fixes:**

N/A

**Workarounds, if any**

None needed.

**Risk**

Low (no behavior changes).

**Performance impact**

Performance is improved by eliminating unnecessary allocations.

**Is this a regression from a previous update?**

No.

**Root cause analysis:**

Missed during code review?

**How was the bug found?**

Internal code review.
</Description>
    <CreatedDate>29/04/2017</CreatedDate>
    <ClosedDate>08/05/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>249</IssueID>
        <Title>Fix IDE diagnostics/code fix test framework to use DiagnosticAnalyzerService to compute diagnostics rather than DiagnosticAnalyzerDriver</Title>
        <Description>Ported from TFS WorkItem: &lt;b&gt;1114332&lt;/b&gt;

---

&lt;p&gt;Our test framework for IDE diagnostics and fixes tests uses DiagnosticAnalyzerDriver directly to compute diagnostics. However, this in turn means that we don’t exercise the end-to-end test path of going via the DiagnosticAnalyzerService. Lot of recent bugs&amp;nbsp;is a case where DiagnosticAnalyzerDriver does the right thing, but it’s caller&amp;nbsp;has a bug in filtering logic&amp;nbsp;and we end up with missing or wrong diagnostics in error list OR missing code fixes due to filtered diagnostics in IDE, though the same test passes fine with our unit test framework.&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;I guess we need to fix up at least&amp;nbsp;&lt;a id=db7d18e25e2715bb class=t href="http://index/Roslyn.Services.Editor.UnitTests/R/db7d18e25e2715bb.html"&gt;&lt;u&gt;&lt;font color="#0066cc"&gt;DiagnosticProviderTestUtilities&lt;/font&gt;&lt;/u&gt;&lt;/a&gt; type&lt;a href="http://index/Roslyn.Services.Editor.UnitTests/R/db7d18e25e2715bb.html"&gt;,&lt;/a&gt; not sure if there are other places too&lt;/p&gt;

---

&lt;!---
@huboard:{"order":326.999755859375,"milestone_order":249,"custom_state":""}
--&gt;
</Description>
        <CreatedDate>05/02/2015</CreatedDate>
        <ClosedDate>18/03/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19125</IssueID>
        <Title>Avoid inefficient use of ContainsKey</Title>
        <Description>## Ask Mode

**Customer scenario**

No observable changes.

* Use `TryGetValue` instead of `ContainsKey`&amp;rarr;indexer
* Use `Remove` instead of `ContainsKey`&amp;rarr;`Remove`
* Use `SetItem` instead of `ContainsKey`&amp;rarr;`Remove`&amp;rarr;`Add`

**Bugs this fixes:**

N/A

**Workarounds, if any**

None needed.

**Risk**

Low (no behavior changes).

**Performance impact**

Performance is improved by eliminating duplicated dictionary operations.

**Is this a regression from a previous update?**

No.

**Root cause analysis:**

Missed during code review.

**How was the bug found?**

Internal code review.
</Description>
        <CreatedDate>29/04/2017</CreatedDate>
        <ClosedDate>03/05/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Imports.cs</File>
      <File>src/Compilers/Core/Portable/DiagnosticAnalyzer/AnalysisState.cs</File>
      <File>src/Compilers/Core/Portable/DiagnosticAnalyzer/AnalyzerFileReference.cs</File>
      <File>src/Compilers/Core/Portable/InternalUtilities/KeyValuePair.cs</File>
      <File>src/EditorFeatures/Core/Tagging/AbstractAsynchronousTaggerProvider.TagSource_ProduceTags.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/AbstractHostDiagnosticUpdateSource.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/EngineV2/DiagnosticIncrementalAnalyzer.StateManager.HostStates.cs</File>
      <File>src/Features/Core/Portable/SolutionCrawler/AggregateIncrementalAnalyzer.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/TableDataSource/Suppression/VisualStudioSuppressionFixService.cs</File>
      <File>src/Workspaces/Core/Portable/CodeFixes/FixAllOccurrences/FixAllLogger.cs</File>
      <File>src/Workspaces/Core/Portable/Diagnostics/Extensions.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/Solution/ProjectState.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/Solution/SolutionState.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>19121</IssueID>
    <Title>Removing zero initialization of locals upon entering a scope. (for locals captured by a local function).</Title>
    <Description>Fixes :#19119

While working on a blog article about Local Functions, I noticed a codegen artifact whose purpose I could not quite explain. We are zeroing out variables when entering a scope if the variables happen to be captured in a struct closure. 

See: bug #19119

The reason why this is happening is likely because the behavior was copied from the older codepath when closure is a class and we do have to `new` a new instance. We do not need to `new` the struct though.  
The code does not really create a new instance. It only clears the old state, which is not observable anyways by the guarantees provided by the Definite Assignment Analysis. 

== Risk

The risk is low.

If this zero-out is observable, we have a much bigger problem. It would indicate a Definite Assignment Analysis failure.

== Performance impact

We are removing redundant code.
In simple cases it is removed by the JIT as well, so we are mostly just making the IL a bit cleaner.

I could imagine that in more complicated cases - bigger display structs or a JIT that is not as smart, zeroing out would incur run-time penalties.

== Is this a regression from a previous update?

No. We had that redundancy since we have shipped the feature.</Description>
    <CreatedDate>29/04/2017</CreatedDate>
    <ClosedDate>02/05/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>19119</IssueID>
        <Title>Should not zero-out locals when entering a scope, regardless if lifted in a struct.</Title>
        <Description>The whole purpose of Definite Assignment Analysis is to ensure that uninitialized locals cannot be observed. That allows us to not zero-initialize locals when entering a scope because the uninitialized/previous state cannot be observed. 

It appears we do zero-initialization when locals happen to be captured in a display struct because of use in Local Functions.  It seems to be a remnant of frame allocation code that is needed in a case where the frame is a class.
We should not do this when frame is a struct. It is redundant. 

NOTE: we do not do the redundant zeroing for async struct captures. The problem is specific to Local Functions.

</Description>
        <CreatedDate>29/04/2017</CreatedDate>
        <ClosedDate>02/05/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19119</IssueID>
        <Title>Should not zero-out locals when entering a scope, regardless if lifted in a struct.</Title>
        <Description>The whole purpose of Definite Assignment Analysis is to ensure that uninitialized locals cannot be observed. That allows us to not zero-initialize locals when entering a scope because the uninitialized/previous state cannot be observed. 

It appears we do zero-initialization when locals happen to be captured in a display struct because of use in Local Functions.  It seems to be a remnant of frame allocation code that is needed in a case where the frame is a class.
We should not do this when frame is a struct. It is redundant. 

NOTE: we do not do the redundant zeroing for async struct captures. The problem is specific to Local Functions.

</Description>
        <CreatedDate>29/04/2017</CreatedDate>
        <ClosedDate>02/05/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/LambdaRewriter.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenDynamicTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenLocalFunctionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenRefReturnTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>19114</IssueID>
    <Title>support of C# 7.0 foreach in ENC</Title>
    <Description>**Customer scenario**

Enabling support of C#7.0 foreach statemets by ENC: tuples and deconstructions.
Also verified enabling manually. The only issue I see to consider is when we change tuple to deconstruction (or the opposite) as a foreach variable, it displays a rude edit saying "ENC0060	Adding 'foreach statement' around an active statement will prevent the debug session from continuing." Should we consider fixing this?

**Bugs this fixes:**

Works towards to fix #17891

**Workarounds, if any**

**Risk**
Low

**Performance impact**
Low

**Is this a regression from a previous update?**

**Root cause analysis:**

How did we miss it?  What tests are we adding to guard against it in the future?

**How was the bug found?**
Planned</Description>
    <CreatedDate>28/04/2017</CreatedDate>
    <ClosedDate>04/05/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>7</IssueID>
        <Title>Feature: Parameter Name Aliasing</Title>
        <Description>The human meaning of parameters may vary from method caller's perspective.

It would be useful if the language provides an ability to assign aliases to the parameters.

``` C#
[Alias({second: [secondAndHalf, quarterToThree], first: [Initial]})] 
public static void Member1(string first, string second) { 
  // Here the user will always use the given names: first and second.
  // which means the user cannot use the param by its nickname
  // inside the method scope.
}

private static void Caller1() {
  Member1(secondAndHalf: "secondly, this is not a bad idea after all",
          Initial: "Initially it sounded moot... :)  ");
}

private static void Caller2() {
  Member1(first: "1st",
          quarterToThree: "almost there");
}

private static void Caller3() {
  Member1("one", "two");
}
```

vs. this current approach:

``` c#
public static void Member1(string first, string second) {  }

public static void Member1(string first, string secondAndHalf, string devNull = null) { 
  Member1(first, secondAndHalf);
}
```

Note: the parameter `devNull` may violate [CA1026](http://msdn.microsoft.com/en-us/library/ms182135.aspx), in case of `overridden` methods. On the flip side, setting `devNull` as non-default parameter would yield "unused parameter".

Related / Real world example: https://github.com/madskristensen/WebEssentials2013/pull/380#issuecomment-31402391
</Description>
        <CreatedDate>15/01/2015</CreatedDate>
        <ClosedDate>26/08/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>17891</IssueID>
        <Title>Enable EnC support for C#7 features</Title>
        <Description>- [x] https://github.com/dotnet/roslyn/issues/17896 ENC support for out Var
- [x] https://github.com/dotnet/roslyn/issues/12435 ENC support for pattern matching
- [x] https://github.com/dotnet/roslyn/issues/17991 ENC support for switch
- [x] https://github.com/dotnet/roslyn/issues/5156   ENC support for local functions
- [x] https://github.com/dotnet/roslyn/issues/17681 ENC for expression-bodied methods
- [x] https://github.com/dotnet/roslyn/issues/16960 ENC for out variable declarations
- [x] https://github.com/dotnet/roslyn/issues/12438 ENC improvements for C# 7
- [x] https://github.com/dotnet/roslyn/issues/12436 ENC for Tuples

See also https://github.com/dotnet/roslyn/issues/12438 https://github.com/dotnet/roslyn/issues/12379
</Description>
        <CreatedDate>15/03/2017</CreatedDate>
        <ClosedDate>08/09/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Test/Emit/Emit/EditAndContinue/EditAndContinueTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Emit/EditAndContinue/LocalSlotMappingTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/EditAndContinue/ActiveStatementTests.cs</File>
      <File>src/Features/CSharp/Portable/EditAndContinue/CSharpEditAndContinueAnalyzer.cs</File>
      <File>src/Features/CSharp/Portable/EditAndContinue/StatementSyntaxComparer.cs</File>
      <File>src/Features/Core/Portable/EditAndContinue/AbstractEditAndContinueAnalyzer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>18976</IssueID>
    <Title>Ensure that we get a well formed child IOperation tree even for bound…</Title>
    <Description>… nodes for whom IOperation support is not yet implemented

**Customer scenario**

Due to large number of unimplemented IOperation APIs for new language and existing features, all the IOperation analyzers (such as FXCop analyzers) do not receive any operation callbacks for code containing these features (tuples, string interpolation, query expressions, object and collection initializers, etc.). This causes lot of false positives in the analyzer diagnostics as it doesn't see parameter or field references within such code. Additionally, the analyzers do not report *true* issues in expressions within this language features. This is one of the biggest blocker towards dogfooding the FXCop analyzers.

**Bugs this fixes:**

Fixes #8884

**Workarounds, if any**

Disable the rule or suppress all the false positives. All our three repos consuming the FXCop analyzers (Roslyn, Project system and Roslyn-analyzers) were forced to disable these rules due to extremely large number of false positives.

**Risk**

Low. Proposed fix is to introduce a temporary internal interface `IOperationWithChildren` for bound nodes for which we haven't designed the IOperation APIs or they have missing pieces. This will allow the OperationWalker to walk the descendants of such nodes and make analyzer callbacks and drastically reduce the false positives. This change doesn't modify the publically available IOperation tree or the API, so we should be able to remove it once we have fully designed and implemented IOperation (tracked by #19060)

**Performance impact**

Low. We will now walk additional IOperation nodes and make callbacks, but this is a functional requirement.

**Is this a regression from a previous update?**

No.

**Root cause analysis:**

IOperation based analyzers are still being developed and tested.

**How was the bug found?**

Lots of customer reports about false positives.</Description>
    <CreatedDate>25/04/2017</CreatedDate>
    <ClosedDate>04/05/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>8884</IssueID>
        <Title>IParameterReferenceExpression operation not generated for parameter access in a certain cases</Title>
        <Description>Sample test code:

``` C#
using System;

public class NeatCode
{
    // Used parameter methods
    public void UsedParameterMethod1(Action a)
    {
        Action a2 = new Action(() =&gt;
        {
            a(); // No parameter reference expression operation generated for this access
        });
    }
}
```

This does not repro for VB.
</Description>
        <CreatedDate>18/02/2016</CreatedDate>
        <ClosedDate>23/06/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19060</IssueID>
        <Title>Remove the IOperationWithChildren interface once we have designed all the IOperation APIs.</Title>
        <Description>
        </Description>
        <CreatedDate>27/04/2017</CreatedDate>
        <ClosedDate>06/09/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/BoundTree/Expression.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/Statement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IFieldReferenceExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IIfStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IParameterReferenceExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IOperationWithChildren.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationWalker.cs</File>
      <File>src/Compilers/Test/Utilities/CSharp/SemanticModelTestBase.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/OperationTreeVerifier.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>18784</IssueID>
    <Title>Relax conversion requirements for pattern-matching involving type parameters.</Title>
    <Description>**Customer scenario**

This is a tiny language change for 7.1. See https://github.com/dotnet/csharplang/issues/154.

See #16195 for customer scenario. In short, pattern-matching can give a compile-time error unexpectedly when type parameters are involved. The compiler is correct to give these errors according to the spec, but we wish to relax the language to make it legal.

**Bugs this fixes:**

Fixes #16195

**Workarounds, if any**

Cast the expression being matched to `object`.

**Risk**

Low. This has little impact on existing code.

**Performance impact**

None expected.

**Is this a regression from a previous update?**

No.
</Description>
    <CreatedDate>18/04/2017</CreatedDate>
    <ClosedDate>08/05/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>16195</IssueID>
        <Title>Generic expression of a derived type cannot be handled by a pattern</Title>
        <Description>**Version Used**: 
Microsoft Visual Studio Professional 2017 RC
Version 15.0.26014.0 D15REL
Microsoft .NET Framework
Version 4.6.01586
Visual C# Compiler version 2.0.0.61213

**Steps to Reproduce**:

    public class Packet
    {
    }

    public class KeepalivePacket : Packet
    {
    }

    public void Send&lt;T&gt;(T packet)
        where T : Packet
    {
        if (packet is KeepalivePacket keepalive)
        {
            // Do stuff with keepalive
        }

        switch (packet)
        {
            case KeepalivePacket keepalivePacket:
                // Do stuff with keepalivePacket
                break;
        }
    }

I get a compilation error for both the if statement and case statement. 

&gt; CS8121: An expression of type T cannot be handled by a pattern of type KeepalivePacket

The code compiles successfully if the type is _not_ a derived type of `Packet` (ie. `packet is Packet keepalive` or `packet is object keepalive` works fine).

The code compiles without error if I first cast the parameter to `object`.

    if ((object)packet is KeepalivePacket keepalive)
    {
        // This works
    }

I couldn't find any mention of unsupported pattern matching with generic parameters/variables in the design notes/blog posts. 

Is this expected to fail? Does this compilation error need a more informative message?

Roslyn is recommending pattern matching for the following code with **IDE0019**. Applying the code fix to the following code results in the compilation error above.

    var keepalive = packet as KeepalivePacket;
    if (keepalive != null)
    {
        // Do stuff with keepalive
    }

Does **IDE0019** need to be updated to not apply when the variable/parameter is generic?</Description>
        <CreatedDate>03/01/2017</CreatedDate>
        <ClosedDate>08/05/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>16195</IssueID>
        <Title>Generic expression of a derived type cannot be handled by a pattern</Title>
        <Description>**Version Used**: 
Microsoft Visual Studio Professional 2017 RC
Version 15.0.26014.0 D15REL
Microsoft .NET Framework
Version 4.6.01586
Visual C# Compiler version 2.0.0.61213

**Steps to Reproduce**:

    public class Packet
    {
    }

    public class KeepalivePacket : Packet
    {
    }

    public void Send&lt;T&gt;(T packet)
        where T : Packet
    {
        if (packet is KeepalivePacket keepalive)
        {
            // Do stuff with keepalive
        }

        switch (packet)
        {
            case KeepalivePacket keepalivePacket:
                // Do stuff with keepalivePacket
                break;
        }
    }

I get a compilation error for both the if statement and case statement. 

&gt; CS8121: An expression of type T cannot be handled by a pattern of type KeepalivePacket

The code compiles successfully if the type is _not_ a derived type of `Packet` (ie. `packet is Packet keepalive` or `packet is object keepalive` works fine).

The code compiles without error if I first cast the parameter to `object`.

    if ((object)packet is KeepalivePacket keepalive)
    {
        // This works
    }

I couldn't find any mention of unsupported pattern matching with generic parameters/variables in the design notes/blog posts. 

Is this expected to fail? Does this compilation error need a more informative message?

Roslyn is recommending pattern matching for the following code with **IDE0019**. Applying the code fix to the following code results in the compilation error above.

    var keepalive = packet as KeepalivePacket;
    if (keepalive != null)
    {
        // Do stuff with keepalive
    }

Does **IDE0019** need to be updated to not apply when the variable/parameter is generic?</Description>
        <CreatedDate>03/01/2017</CreatedDate>
        <ClosedDate>08/05/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Patterns.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/SubsumptionDiagnosticBuilder.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/DecisionTree.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/DecisionTreeBuilder.cs</File>
      <File>src/Compilers/CSharp/Portable/CSharpResources.Designer.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/ErrorCode.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/MessageID.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_PatternSwitchStatement.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_Patterns.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/SyntheticBoundNodeFactory.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/SwitchTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/PDB/PDBTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternSwitchTests.cs</File>
      <File>src/Compilers/Test/Utilities/CSharp/TestOptions.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/UpgradeProject/UpgradeProjectTests.cs</File>
      <File>src/Features/CSharp/Portable/UpgradeProject/CSharpUpgradeProjectCodeFixProvider.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>18494</IssueID>
    <Title>Interface change of IHasArgumentsExpression, IInvocationExpression and IArgument </Title>
    <Description>Based on the proposal in #8813. The goal of this PR is to make sure the interface change follows the proposed design, ~~and the implementation has correct behavior~~. Finalizing the implementation is not of the interest of this PR (for example, we want to leverage rewriter to derive arguments in C# later).

**Update:**
Talked with @AlekseyTs offline, we decided to remove all the implementation changes in C# side as they still doesn't cover all scenarios correctly and are going to be thrown away with the fix for #18549. In 228b604 I have rolled back all the changes, and the implementation for C#  `ArgumentsInEvaluationOrder` is basically the old ~~`ArgumentsInSourceOrder`~~`ArgumentsInParameterOrder`. As a result of this, **the contract for `IHasArgumentsExpression.ArgumentsInEvaluationOrder` is broken**, i.e. it doesn't return correct list of arguments, and we decided this is OK as long as it will be fixed in my next PR (supposedly very soon). 

Affected tests are disabled, because it makes no sense to "fix" them for incorrect behavior.

**Update2**
`GetArgumentMatchingParameter ` and `ArgumentsInParameterOrder`, which were downgraded to extension methods in this PR, now completely removed with intention to bring them back after the interface and implementation of `IHasArgumentsExpression` is finalized. Tracked by #18658

This also fixes #8781, and fixes the design part of #8786
Related: #18549, #18550, 

==========================

**Customer scenario**

Improved interfaces for `IHasArgumentsExpression` and `IArgument`. For example, `ArgumentsInEvaluationOrder` property is added to `IHasArgumentsExpression`, which provides a unified way to order arguments in execution order for both C# and VB. This replaced previous arguments ordering APIs for source order and parameter order, which are demoted from core interface to probably extension methods.

**Bugs this fixes:**
#8813, #8781 

**Workarounds, if any**
None.

**Risk**
Low. And this is still behind a feature flag.

**Performance impact**
Low.

**Is this a regression from a previous update?**
No.

**Root cause analysis:**
N/A

**How was the bug found?**
Not a bug, this is part of the IOperation cleanup work.</Description>
    <CreatedDate>06/04/2017</CreatedDate>
    <ClosedDate>18/04/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>8813</IssueID>
        <Title>IOperation: A proposal to change design around IHasArgumentsExpression, IInvocationExpression and IArgument interfaces.</Title>
        <Description>**Exposing the set of arguments**

Currently we have two APIs that are supposed to expose arguments and every implementer has to implement both.
In IHasArgumentsExpression, which is IInvocationExpression inherits from:

```
        /// &lt;summary&gt;
        /// Arguments of the invocation, excluding the instance argument. Arguments are in parameter order,
        /// and params/ParamArray arguments have been collected into arrays. Default values are supplied for
        /// optional arguments missing in source.
        /// &lt;/summary&gt;
        ImmutableArray&lt;IArgument&gt; ArgumentsInParameterOrder { get; }
```

In IInvocationExpression 

```
        /// &lt;summary&gt;
        /// Arguments of the invocation, excluding the instance argument. Arguments are in the order specified in source,
        /// and params/ParamArray arguments have been collected into arrays. Arguments are not present
        /// unless supplied in source.
        /// &lt;/summary&gt;
        ImmutableArray&lt;IArgument&gt; ArgumentsInSourceOrder { get; }
```

I am not sure if having two these APIs provides much value. I believe that it would be much more useful to have a single API in IHasArgumentsExpression:

```
        /// &lt;summary&gt;
        /// Arguments of the invocation, excluding the instance argument. Arguments are in evaluation order,
        /// and params/ParamArray arguments have been collected into arrays. Default values are supplied for
        /// optional arguments missing in source.
        /// &lt;/summary&gt;
        ImmutableArray&lt;IArgument&gt; ArgumentsInEvaluationOrder { get; }
```

If we feel that sometimes consumers would want to traverse arguments in source or parameter order, we can provide helpers like this as extension methods for IHasArgumentsExpression interface because all the relevant information should be available from IArguments.

**IArgument, ArgumentKinds and param arrays**

It is not obvious what value do we get from distinguishing between Positional and Named arguments. I believe Analyzers will be more interested in the order, in which arguments are evaluated (ArgumentsInEvaluationOrder solves that). Knowing whether the argument was named doesn't look that important and can always be discovered from syntax. 

The requirement to create a separate IArgument of ParamArray kind for each element of param array

```
        /// &lt;summary&gt;
        /// Argument becomes an element of an array that matches a trailing C# params or VB ParamArray parameter.
        /// &lt;/summary&gt;
        ParamArray = 0x3,
```

means that we will create trees of different shape for situations when param array was created by the compilers and when the array was passed explicitly. Do Analyzers really care that much about param array that they will be willing to be prepared to deal with two different tree shapes for semantically equivalent code?

Another issue with the current design is that it looks like an empty param array created by compilers won't have any representation in the tree at all, because there is no ArgumentKind that could be used for such an argument.

To address all these issues, I propose to change the current set of ArgumentKinds as follows (note, the meaning of ParamArray kind is changed):

```
    /// &lt;summary&gt;
    /// Kinds of arguments.
    /// &lt;/summary&gt;
    public enum ArgumentKind
    {
        None = 0x0,

        /// &lt;summary&gt;
        /// Argument value is explicitly supplied.
        /// &lt;/summary&gt;
        Explicit = 0x1,

        /// &lt;summary&gt;
        /// Argument is a param array created by compilers for the matching C# params or VB ParamArray parameter. Note, the value is a an array creation expression that encapsulates all the elements, if any.
        /// &lt;/summary&gt;
        ParamArray = 0x2,

        /// &lt;summary&gt;
        /// Argument is a default value supplied automatically by the compilers.
        /// &lt;/summary&gt;
        DefaultValue = 0x3
    }
```

See related issues: #8805, #8786, #8781, #8773.
</Description>
        <CreatedDate>17/02/2016</CreatedDate>
        <ClosedDate>18/05/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>18549</IssueID>
        <Title>`IHasArgumentsExpression.ArgumentsInEvaluationOrder` in C# should not use private implementation</Title>
        <Description>Currently, there is a lot of logic duplicated in C#'s implementation and there is a lot of opportunities to deviate from what LocalRewriter is doing. I believe our goal should be to return result consistent with what LocalRewriter would produce. As such we should find a way to share that logic, IOperation should not have its own private implementation.

With this in mind, I have made the change for IHasArgumentsExpression interface in #18494 with minimal change in implementation, to avoid doing unnecessary throwaway work. As a result, **the contract for `IHasArgumentsExpression.ArgumentsInEvaluationOrder` is broken**, as current implementation is the old `ArgumentsInSourceOrder`, therefore missing all default arguments (including empty param array). This issue is intended to track this as well, as I believe getting rid of private implementation would also fix this.</Description>
        <CreatedDate>08/04/2017</CreatedDate>
        <ClosedDate>18/05/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>18658</IssueID>
        <Title>Implement GetArgumentMatchingParameter and ArgumentsInParameterOrder as extension methods</Title>
        <Description>Those are removed from core `IHasArgumentsExpression` interface, based on the latest interface design. Will likely bring them back as extension methods instead, once the core interface and implementation are finalized. This issue is created to track that.

Related to:
#8813 #8805</Description>
        <CreatedDate>12/04/2017</CreatedDate>
        <ClosedDate>23/06/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>8781</IssueID>
        <Title>IOperation: VB - BoundCall.ByRefArgument always reported as positional</Title>
        <Description>The argument can be named as well.

```
            Public Overrides ReadOnly Property ArgumentKind As ArgumentKind
                Get
                    ' Do the VB bound trees encode named arguments?
                    Return ArgumentKind.Positional
                End Get
            End Property
```
</Description>
        <CreatedDate>17/02/2016</CreatedDate>
        <ClosedDate>18/04/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>8786</IssueID>
        <Title>IOperation: What is the value of ParamArray arguments?</Title>
        <Description>Given the following API definition:

```
    /// &lt;summary&gt;
    /// Kinds of arguments.
    /// &lt;/summary&gt;
    public enum ArgumentKind
    {
        None = 0x0,

        /// &lt;summary&gt;
        /// Argument is specified positionally and matches the parameter of the same ordinality.
        /// &lt;/summary&gt;
        Positional = 0x1,
        /// &lt;summary&gt;
        /// Argument is specified by name and matches the parameter of the same name.
        /// &lt;/summary&gt;
        Named = 0x2,
        /// &lt;summary&gt;
        /// Argument becomes an element of an array that matches a trailing C# params or VB ParamArray parameter.
        /// &lt;/summary&gt;
        ParamArray = 0x3,
        /// &lt;summary&gt;
        /// Argument was omitted in source but has a default value supplied automatically.
        /// &lt;/summary&gt;
        DefaultValue = 0x4
    }
```

It looks like the shape of the IOperation tree is going to depend on whether param array argument was crated by the compiler. Given this method definition:

```
static void Test(params string[] y)
```

The following call will have two ParamArray arguments, corresponding to `"a"` and `"b"`:

```
Test("a", "b");
```

But this call will have one Positional argument, corresponding to `new [] {"a", "b"}`:

```
Test(new [] {"a", "b"});
```

These two calls are semantically identical. Do we really want analyzers to be prepared to deal with this difference? 

What argument should be created for this scenario, where `"a"` is a named argument and a param array element at the same time?

```
    static void Main()
    {
        Test(y: "a", x:10);
    }

    static void Test(int x, params string[] y)
    {
        System.Console.WriteLine(y[0]);
    }
```
</Description>
        <CreatedDate>17/02/2016</CreatedDate>
        <ClosedDate>18/05/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>18549</IssueID>
        <Title>`IHasArgumentsExpression.ArgumentsInEvaluationOrder` in C# should not use private implementation</Title>
        <Description>Currently, there is a lot of logic duplicated in C#'s implementation and there is a lot of opportunities to deviate from what LocalRewriter is doing. I believe our goal should be to return result consistent with what LocalRewriter would produce. As such we should find a way to share that logic, IOperation should not have its own private implementation.

With this in mind, I have made the change for IHasArgumentsExpression interface in #18494 with minimal change in implementation, to avoid doing unnecessary throwaway work. As a result, **the contract for `IHasArgumentsExpression.ArgumentsInEvaluationOrder` is broken**, as current implementation is the old `ArgumentsInSourceOrder`, therefore missing all default arguments (including empty param array). This issue is intended to track this as well, as I believe getting rid of private implementation would also fix this.</Description>
        <CreatedDate>08/04/2017</CreatedDate>
        <ClosedDate>18/05/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>18550</IssueID>
        <Title>`WasCompilerGenerated` property on bound node is not a robust way to determine `ArgumentKind` in VB</Title>
        <Description>The implementation in VB bound tree provides a fully populated list of arguments, including arguments with default value and array that is generated by compiler as argument for `ParamArray` parameter for invocation of expanded form. However, we currently don't have definitive information on the bound node that tells us if 

1. it is a default value argument, or 
2. it is an array created by compiler because or it is an array provided explicitly by caller for the normal form of invocation. 

At the moment, we rely on checking `WasCompilerGenerated` property on the argument bound nodes, which might break in many cases. @AlekseyTs proposed a more robust approach, basically to create additional wrapper nodes, and during binding we wrap up argument nodes of default value and paramarray argument generated by compiler.
</Description>
        <CreatedDate>08/04/2017</CreatedDate>
        <ClosedDate>25/06/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>8813</IssueID>
        <Title>IOperation: A proposal to change design around IHasArgumentsExpression, IInvocationExpression and IArgument interfaces.</Title>
        <Description>**Exposing the set of arguments**

Currently we have two APIs that are supposed to expose arguments and every implementer has to implement both.
In IHasArgumentsExpression, which is IInvocationExpression inherits from:

```
        /// &lt;summary&gt;
        /// Arguments of the invocation, excluding the instance argument. Arguments are in parameter order,
        /// and params/ParamArray arguments have been collected into arrays. Default values are supplied for
        /// optional arguments missing in source.
        /// &lt;/summary&gt;
        ImmutableArray&lt;IArgument&gt; ArgumentsInParameterOrder { get; }
```

In IInvocationExpression 

```
        /// &lt;summary&gt;
        /// Arguments of the invocation, excluding the instance argument. Arguments are in the order specified in source,
        /// and params/ParamArray arguments have been collected into arrays. Arguments are not present
        /// unless supplied in source.
        /// &lt;/summary&gt;
        ImmutableArray&lt;IArgument&gt; ArgumentsInSourceOrder { get; }
```

I am not sure if having two these APIs provides much value. I believe that it would be much more useful to have a single API in IHasArgumentsExpression:

```
        /// &lt;summary&gt;
        /// Arguments of the invocation, excluding the instance argument. Arguments are in evaluation order,
        /// and params/ParamArray arguments have been collected into arrays. Default values are supplied for
        /// optional arguments missing in source.
        /// &lt;/summary&gt;
        ImmutableArray&lt;IArgument&gt; ArgumentsInEvaluationOrder { get; }
```

If we feel that sometimes consumers would want to traverse arguments in source or parameter order, we can provide helpers like this as extension methods for IHasArgumentsExpression interface because all the relevant information should be available from IArguments.

**IArgument, ArgumentKinds and param arrays**

It is not obvious what value do we get from distinguishing between Positional and Named arguments. I believe Analyzers will be more interested in the order, in which arguments are evaluated (ArgumentsInEvaluationOrder solves that). Knowing whether the argument was named doesn't look that important and can always be discovered from syntax. 

The requirement to create a separate IArgument of ParamArray kind for each element of param array

```
        /// &lt;summary&gt;
        /// Argument becomes an element of an array that matches a trailing C# params or VB ParamArray parameter.
        /// &lt;/summary&gt;
        ParamArray = 0x3,
```

means that we will create trees of different shape for situations when param array was created by the compilers and when the array was passed explicitly. Do Analyzers really care that much about param array that they will be willing to be prepared to deal with two different tree shapes for semantically equivalent code?

Another issue with the current design is that it looks like an empty param array created by compilers won't have any representation in the tree at all, because there is no ArgumentKind that could be used for such an argument.

To address all these issues, I propose to change the current set of ArgumentKinds as follows (note, the meaning of ParamArray kind is changed):

```
    /// &lt;summary&gt;
    /// Kinds of arguments.
    /// &lt;/summary&gt;
    public enum ArgumentKind
    {
        None = 0x0,

        /// &lt;summary&gt;
        /// Argument value is explicitly supplied.
        /// &lt;/summary&gt;
        Explicit = 0x1,

        /// &lt;summary&gt;
        /// Argument is a param array created by compilers for the matching C# params or VB ParamArray parameter. Note, the value is a an array creation expression that encapsulates all the elements, if any.
        /// &lt;/summary&gt;
        ParamArray = 0x2,

        /// &lt;summary&gt;
        /// Argument is a default value supplied automatically by the compilers.
        /// &lt;/summary&gt;
        DefaultValue = 0x3
    }
```

See related issues: #8805, #8786, #8781, #8773.
</Description>
        <CreatedDate>17/02/2016</CreatedDate>
        <ClosedDate>18/05/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>8781</IssueID>
        <Title>IOperation: VB - BoundCall.ByRefArgument always reported as positional</Title>
        <Description>The argument can be named as well.

```
            Public Overrides ReadOnly Property ArgumentKind As ArgumentKind
                Get
                    ' Do the VB bound trees encode named arguments?
                    Return ArgumentKind.Positional
                End Get
            End Property
```
</Description>
        <CreatedDate>17/02/2016</CreatedDate>
        <ClosedDate>18/04/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/BoundTree/Expression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Diagnostics/OperationAnalyzerTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IArgument.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IIfStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_ISymbolInitializer.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_InvalidExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/ArgumentKind.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IArgument.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IHasArgumentsExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IInvocationExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IndexedPropertyReferenceExpression_IHasArgumentsExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/InvocationExpression_IHasArgumentsExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/ObjectCreationExpression_IHasArgumentsExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationExtensions.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationWalker.cs</File>
      <File>src/Features/Core/Portable/InitializeParameter/AbstractAddParameterCheckCodeRefactoringProvider.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/OperationTreeVerifier.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/TestOperationWalker.cs</File>
      <File>src/Test/Utilities/Portable/Diagnostics/CouldHaveMoreSpecificTypeAnalyzer.cs</File>
      <File>src/Test/Utilities/Portable/Diagnostics/FieldCouldBeReadOnlyAnalyzer.cs</File>
      <File>src/Test/Utilities/Portable/Diagnostics/LocalCouldBeConstAnalyzer.cs</File>
      <File>src/Test/Utilities/Portable/Diagnostics/OperationTestAnalyzer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>18489</IssueID>
    <Title>Fixes #18311 - Incorrect quick info for ValueTuple&lt;T&gt;</Title>
    <Description>Fixes #18311 
Closes #15508

Hovering `var` will show `System.ValueTuple&lt;System.Int32&gt;`
Hovering `y` will show `(local variable) ValueTuple&lt;int&gt; y`</Description>
    <CreatedDate>06/04/2017</CreatedDate>
    <ClosedDate>07/04/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>18311</IssueID>
        <Title>Incorrect quick info for ValueTuple&lt;T&gt;</Title>
        <Description>**Version Used**: VS 2017 (15.0.0+26228.9)

**Steps to Reproduce**:

1. Use the following code:

    ```csharp
    void Foo()
    {
        var y = ValueTuple.Create(1);
    }
    ```

2. Hover over `var`
3. Hover over `y`

**Expected Behavior**:

* In step 2, the result should be `struct System.ValueTuple&lt;T&gt;`, with `T is int`.
* In step 3, the result should be `ValueTuple&lt;int, int&gt; y`

**Actual Behavior**:

* In step 2, the result is `(System.Int32)`
* In step 3, the result is `(int) y`

Neither of these are valid tuple syntaxes in C#.
</Description>
        <CreatedDate>30/03/2017</CreatedDate>
        <ClosedDate>07/04/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>15508</IssueID>
        <Title>IDE extract method fails to handle some deconstruction scenarios.</Title>
        <Description>The IDE code is not resilient against arbitrary expressions appearing on the left-hand-side of a deconstruction. It tries to produce a zero-element tuple type, which causes an exception to be thrown.

This will be a problem after generalized deconstruction support is added to the compiler, even in error scenarios. I'll skip the two affected tests, `GenerateMethodTests.TestDeconstruction3` and `4`. The offending code is here, in `src\Workspaces\CSharp\Portable\LanguageServices\CSharpTypeInferenceService.TypeInferrer.cs`:

```cs
            private bool TryGetTupleTypesAndNames(
                SeparatedSyntaxList&lt;ArgumentSyntax&gt; arguments,
                out ImmutableArray&lt;ITypeSymbol&gt; elementTypes,
                out ImmutableArray&lt;string&gt; elementNames)
            {
                elementTypes = default(ImmutableArray&lt;ITypeSymbol&gt;);
                elementNames = default(ImmutableArray&lt;string&gt;);

                var elementTypesBuilder = ArrayBuilder&lt;ITypeSymbol&gt;.GetInstance();
                var elementNamesBuilder = ArrayBuilder&lt;string&gt;.GetInstance();
                try
                {
                    foreach (var arg in arguments)
                    {
                        var expr = arg.Expression;
                        if (expr.IsKind(SyntaxKind.DeclarationExpression))
                        {
                            AddTypeAndName((DeclarationExpressionSyntax)expr, elementTypesBuilder, elementNamesBuilder);
                        }
                        else if (expr.IsKind(SyntaxKind.TupleExpression))
                        {
                            AddTypeAndName((TupleExpressionSyntax)expr, elementTypesBuilder, elementNamesBuilder);
                        }
                    }

                    if (elementTypesBuilder.Contains(null))
                    {
                        return false;
                    }

                    elementTypes = elementTypesBuilder.ToImmutable();
                    elementNames = elementNamesBuilder.ToImmutable();
                    return true;
                }
                finally
                {
                    elementTypesBuilder.Free();
                    elementNamesBuilder.Free();
                }
            }
```

there appears to be an `else` missing when we test `expr.IsKind`. This causes the caller to attempt to produce a tuple type with an insufficient number of elements.</Description>
        <CreatedDate>24/11/2016</CreatedDate>
        <ClosedDate>07/04/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/SymbolDisplay/SymbolDisplayVisitor.Types.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTupleTest.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/SymbolDisplay/SymbolDisplayTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/CodeActions/ExtractMethod/ExtractMethodTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/QuickInfo/SemanticQuickInfoSourceTests.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Test/ExpressionCompiler/TupleTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>18444</IssueID>
    <Title>Removes control type from NavBar's accessible names</Title>
    <Description>This fixes #18443 - Accessible name should not contain the type of the control.

Narrator automatically adds the control type, which means that with this fix in place, hitting Ctrl+F2 as described in #18443 will make Narrator say "Projects, WpfApp1, ComboBox"

Screenshot from AccEvent:
![image](https://cloud.githubusercontent.com/assets/1673956/24684004/cb86c96c-1957-11e7-83f5-4b0c6ac73c0c.png)
</Description>
    <CreatedDate>04/04/2017</CreatedDate>
    <ClosedDate>14/04/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>18443</IssueID>
        <Title>Accessibility: Narrator says control type twice in the navigation bar </Title>
        <Description>Copied from [VSO tracker](https://devdiv.visualstudio.com/DevDiv/_workitems/edit/394818)

**Version Used**: master

**Steps to Reproduce**:

1. Launch Visual Studio
2. Create a New WPF Project
3. Tab to the editor that is present in the .cs file
4. Press CONTROL +F2 to navigate to the combo boxes.

**Expected Behavior**:
Name property should be appropriate and should not contain any localized control type

**Actual Behavior**:
Name property is 'Memberdropdown'
Narrator reads as 'Member drop down, &lt;name&gt;, Combo box'</Description>
        <CreatedDate>04/04/2017</CreatedDate>
        <ClosedDate>14/04/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>18443</IssueID>
        <Title>Accessibility: Narrator says control type twice in the navigation bar </Title>
        <Description>Copied from [VSO tracker](https://devdiv.visualstudio.com/DevDiv/_workitems/edit/394818)

**Version Used**: master

**Steps to Reproduce**:

1. Launch Visual Studio
2. Create a New WPF Project
3. Tab to the editor that is present in the .cs file
4. Press CONTROL +F2 to navigate to the combo boxes.

**Expected Behavior**:
Name property should be appropriate and should not contain any localized control type

**Actual Behavior**:
Name property is 'Memberdropdown'
Narrator reads as 'Member drop down, &lt;name&gt;, Combo box'</Description>
        <CreatedDate>04/04/2017</CreatedDate>
        <ClosedDate>14/04/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/Core/Extensibility/NavigationBar/NavigationBarAutomationStrings.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>18360</IssueID>
    <Title>Don't create deferred projects for things that opt-out of DPL</Title>
    <Description>While investigating #17570, I discovered that we would sometimes create
"deferred" Roslyn projects for .NET Core projects that just hadn't been
asynchronously created yet. In *theory* that did no functional harm - they would
just get closed and converted to real projects when the project system created
the real project, but might as well not even bother creating them.

While I'm here, clean up PR feedback from #17335.</Description>
    <CreatedDate>01/04/2017</CreatedDate>
    <ClosedDate>07/04/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>17570</IssueID>
        <Title>VS crash in VisualStudioProjectTracker.GetOrCreateProjectFromArgumentsAndReferences</Title>
        <Description>_From @AArnott on March 6, 2017 3:4_

d15rel 26228.00
I have lightweight solution load turned on.
This crashed twice in a row (2 out of 2 attempts)

```
git clone https://github.com/aarnott/pinvoke
cd pinvoke
git checkout bugrepro/roslyn-project-system/1678
devenv src\pinvoke.sln
```

Crashes with:

```
Application: devenv.exe
Framework Version: v4.0.30319
Description: The process was terminated due to an unhandled exception.
Exception Info: System.InvalidOperationException
   at System.Linq.Enumerable.Single[[System.Byte, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](System.Collections.Generic.IEnumerable`1&lt;Byte&gt;)
   at System.Linq.ImmutableArrayExtensions.SingleOrDefault[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](System.Collections.Immutable.ImmutableArray`1&lt;System.__Canon&gt;, System.Func`2&lt;System.__Canon,Boolean&gt;)
   at Microsoft.VisualStudio.LanguageServices.Implementation.ProjectSystem.VisualStudioProjectTracker.GetOrCreateProjectFromArgumentsAndReferences(Microsoft.VisualStudio.LanguageServices.ProjectSystem.IWorkspaceProjectContextFactory, Microsoft.CodeAnalysis.IAnalyzerAssemblyLoader, System.String, System.Collections.Generic.IReadOnlyDictionary`2&lt;System.String,Microsoft.VisualStudio.LanguageServices.Implementation.ProjectSystem.DeferredProjectInformation&gt;, System.Collections.Generic.IReadOnlyDictionary`2&lt;System.String,System.String&gt;)
   at Microsoft.VisualStudio.LanguageServices.Implementation.ProjectSystem.VisualStudioProjectTracker+&lt;PopulateWorkspaceFromDeferredProjectInfoAsync&gt;d__69.MoveNext()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(System.Threading.Tasks.Task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(System.Threading.Tasks.Task)
   at Microsoft.VisualStudio.LanguageServices.Implementation.ProjectSystem.VisualStudioProjectTracker+&lt;LoadSolutionFromMSBuildAsync&gt;d__62.MoveNext()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(System.Threading.Tasks.Task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(System.Threading.Tasks.Task)
   at Roslyn.Utilities.TaskExtensions+&lt;FireAndForget&gt;d__0.MoveNext()
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore+&lt;&gt;c.&lt;ThrowAsync&gt;b__6_0(System.Object)
   at System.Windows.Threading.ExceptionWrapper.InternalRealCall(System.Delegate, System.Object, Int32)
   at System.Windows.Threading.ExceptionWrapper.TryCatchWhen(System.Object, System.Delegate, System.Object, Int32, System.Delegate)
   at System.Windows.Threading.DispatcherOperation.InvokeImpl()
   at System.Windows.Threading.DispatcherOperation.InvokeInSecurityContext(System.Object)
   at MS.Internal.CulturePreservingExecutionContext.CallbackWrapper(System.Object)
   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)
   at MS.Internal.CulturePreservingExecutionContext.Run(MS.Internal.CulturePreservingExecutionContext, System.Threading.ContextCallback, System.Object)
   at System.Windows.Threading.DispatcherOperation.Invoke()
   at System.Windows.Threading.Dispatcher.ProcessQueue()
   at System.Windows.Threading.Dispatcher.WndProcHook(IntPtr, Int32, IntPtr, IntPtr, Boolean ByRef)
   at MS.Win32.HwndWrapper.WndProc(IntPtr, Int32, IntPtr, IntPtr, Boolean ByRef)
   at MS.Win32.HwndSubclass.DispatcherCallbackOperation(System.Object)
   at System.Windows.Threading.ExceptionWrapper.InternalRealCall(System.Delegate, System.Object, Int32)
   at System.Windows.Threading.ExceptionWrapper.TryCatchWhen(System.Object, System.Delegate, System.Object, Int32, System.Delegate)
   at System.Windows.Threading.Dispatcher.LegacyInvokeImpl(System.Windows.Threading.DispatcherPriority, System.TimeSpan, System.Delegate, System.Object, Int32)
   at MS.Win32.HwndSubclass.SubclassWndProc(IntPtr, Int32, IntPtr, IntPtr)
```

_Copied from original issue: dotnet/roslyn-project-system#1678_</Description>
        <CreatedDate>06/03/2017</CreatedDate>
        <ClosedDate>21/03/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>17335</IssueID>
        <Title>Move IVsSolutionEvents to VisualStudioWorkspaceImpl</Title>
        <Description>In Lightweight solution load, we depend on
IVsSolutionEvents.OnAfterOpenSolution being called to populate the
workspace and create projects.  However we were subscribing from
VisualStudioProjectTracker, which we defer create until a project is
opened.  This meant we never got the event for the first time a solution
was opened, and so we failed to populate the workspace.</Description>
        <CreatedDate>23/02/2017</CreatedDate>
        <ClosedDate>27/02/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/Interop/IVsSolution7.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/VisualStudioProjectTracker.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/VisualStudioWorkspaceImpl_IVsSolutionEvents.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>17938</IssueID>
    <Title>Expose the child IOperations within an IInvalidExpression and IInvali…</Title>
    <Description>…dStatement

This is a proposal PR for #17802, and needs API design team approval.

Fixes #17802, #17598 and #17607

Most of the changes in this PR are as a result of changing BoundBadExpression to hold more strongly typed `ImmutableArray&lt;BoundExpression&gt; childNodes` instead of the current `ImmutableArray&lt;BoundNode&gt; childNodes`</Description>
    <CreatedDate>17/03/2017</CreatedDate>
    <ClosedDate>10/04/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>17802</IssueID>
        <Title>IInvalidExpression and IInvalidStatement should expose child operations</Title>
        <Description>IInvalidExpression and IInvalidStatement currently expose no child operations. However, BoundBadExpression and BoundBadStatement both contain bound nodes for children, and hence we should expose `ImmutableArray&lt;IOperation&gt; ChildOperations` from these 2 interfaces.

Additional, BoundBadExpression also contains a list of candidate symbols, and we should expose `ImmutableArray&lt;ISymbol&gt; CandidateSymbols` on IInvalidExpression</Description>
        <CreatedDate>13/03/2017</CreatedDate>
        <ClosedDate>10/04/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>17802</IssueID>
        <Title>IInvalidExpression and IInvalidStatement should expose child operations</Title>
        <Description>IInvalidExpression and IInvalidStatement currently expose no child operations. However, BoundBadExpression and BoundBadStatement both contain bound nodes for children, and hence we should expose `ImmutableArray&lt;IOperation&gt; ChildOperations` from these 2 interfaces.

Additional, BoundBadExpression also contains a list of candidate symbols, and we should expose `ImmutableArray&lt;ISymbol&gt; CandidateSymbols` on IInvalidExpression</Description>
        <CreatedDate>13/03/2017</CreatedDate>
        <ClosedDate>10/04/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>17598</IssueID>
        <Title>[IExpression] IOperation unit tests for invalid expressions</Title>
        <Description>- [ ] IInvalidExpression

We will need to test all possible bad expression/error scenarios across all the different possible expression kinds for completeness.</Description>
        <CreatedDate>07/03/2017</CreatedDate>
        <ClosedDate>10/04/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>17607</IssueID>
        <Title>[IStatement] IOperation unit tests for invalid statements</Title>
        <Description>- [x] IInvalidStatement

We need to test all possible cases where binding different statements can end up as an invalid statement.</Description>
        <CreatedDate>07/03/2017</CreatedDate>
        <ClosedDate>10/04/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder.WithQueryLambdaParametersBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Deconstruct.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Expressions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Query.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Statements.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/ForEachLoopBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/SwitchBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/Constructors.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/Expression.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/Statement.cs</File>
      <File>src/Compilers/CSharp/Portable/Generated/BoundNodes.xml.Generated.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/ExpressionLambdaRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/LambdaRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_Event.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_FixedStatement.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_LockStatement.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_ObjectCreationExpression.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_UsingStatement.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LoweredDynamicOperation.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/SyntheticBoundNodeFactory.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Diagnostics/OperationAnalyzerTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_InvalidExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_InvalidStatement.cs</File>
      <File>src/Compilers/Core/Portable/Generated/Operations.xml.Generated.cs</File>
      <File>src/Compilers/Core/Portable/Operations/Expressions.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IInvalidExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IInvalidStatement.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationWalker.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Source/ExpressionCompiler/Symbols/PlaceholderLocalSymbol.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/OperationTreeVerifier.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>12741</IssueID>
    <Title>Extension everything update: bugfixes</Title>
    <Description>Lots of bugfixes in this PR:
- Fix a diagnostic related to SelectMany (detection of the specialized case was wrong due to an off-by-1, so the general error was being reported)
- Fix overload resolution on static extension methods. Mixed instance/static methods is still an open issue.
- Fix ref kind of valuetype extension class members.
- Syntax offset of unreduced methods
- Calling convention of unreduced properties (remove HasThis)
- Fix what modifiers are allowed on members inside extension classes.
- Type-map (alpha-rename) the ReceiverType of ReducedExtensionMethodSymbol. **!!!** This change might want to get cherry-picked into master, as it feels like a bug.
- Modify `SymbolKey.MethodSymbolKey.cs` to not write the receiver type in the case of an unconstructed reduced method symbol. This is required to avoid a stackoverflow due to a long chain of events with the root cause of type mapping the ReceiverType of a reduced extension method symbol, and will want to be carried along if that change is ported to master. Additionally, I'm questioning the usefulness at all of writing the receiver type into the symbolkey - I think it provides no new information that the comparer/deserializer can use, as the constructed form of the method is written as well (so any inferences from the receiver type are already saved).
- ... and other pretty minor things, where listing them all would be equivalent to just reading through the diff.

Ping @dotnet/roslyn-compiler for review. In particular, the ReceiverType mapping (and SymbolKey change) would be good to inspect/discuss, as it might be applicable to master (or some other branch that's more master-ish than this feature branch). I've discussed it with @cston a bit, and the change seems correct. Here's an overview of the change:

``` csharp
// For this method:
static void Foo&lt;T&gt;(this T x);
// that has been reduced without construction of some other concrete type:
void T.Foo&lt;T&gt;();
// which can happen if, for example, the call is recursive:
static void Foo&lt;T&gt;(this T x) { /* ... */ x.Foo() /* ... */ }
// note the type parameters in the reduced form are alpha renamed (indicated with "new"):
Foo&lt;Tnew&gt;()
// the question is: does ReceiverType on this Foo return T or Tnew?
// In other words, what is the reduced symbol:
void T.Foo&lt;Tnew&gt;();
void Tnew.Foo&lt;Tnew&gt;();
// The old behavior (currently in master) is choice #1, and I have ran into bugs (even after construction) due to it.
// The new behavior is choice #2, and is what this PR does in the ReceiverType diff (calls _typeMap.SubstituteType). This also causes other places to run into bugs, e.g. a stackoverflow in SymbolKey.
```
</Description>
    <CreatedDate>26/07/2016</CreatedDate>
    <ClosedDate>26/04/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>1</IssueID>
        <Title>Initial port and addition of README.md</Title>
        <Description>This is a port of the readme from CodePlex.  Some of the links have been updated to point to locations on GitHub, but many of the links still point back to CodePlex as comparable GitHub locations are currently absent.
</Description>
        <CreatedDate>14/01/2015</CreatedDate>
        <ClosedDate>14/01/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>2</IssueID>
        <Title>Update links in README.md with ported wiki content</Title>
        <Description>
        </Description>
        <CreatedDate>14/01/2015</CreatedDate>
        <ClosedDate>14/01/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Conversions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Expressions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Invocation.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Lookup.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_QueryErrors.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/OverloadResolution/OverloadResolution.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/OverloadResolution/OverloadResolutionResult.cs</File>
      <File>src/Compilers/CSharp/Portable/CodeGen/EmitExpression.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/CSharpSemanticModel.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_Call.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_PropertyAccess.cs</File>
      <File>src/Compilers/CSharp/Portable/SymbolDisplay/SymbolDisplayVisitor.Members.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PEMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/MethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/NamedTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/PropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ReducedExtensionMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Retargeting/RetargetingNamespaceSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceConstructorSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceEventSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceMemberContainerSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceMemberMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceNamedTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourcePropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/SubstitutedMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Symbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/SymbolExtensions.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/UnreducedExtensionMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/UnreducedExtensionPropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/ExtensionEverythingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/SemanticErrorTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Completion/CompletionProviders/SymbolCompletionProviderTests.cs</File>
      <File>src/EditorFeatures/Test/Utilities/SymbolEquivalenceComparerTests.cs</File>
      <File>src/Workspaces/Core/Portable/SymbolId/SymbolKey.MethodSymbolKey.cs</File>
      <File>src/Workspaces/CoreTest/SymbolKeyTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>18291</IssueID>
    <Title>Fixing Flaky Interactive Tests</Title>
    <Description>Fixes:  #18283 and #18133 

Tagging @dotnet/roslyn-ide </Description>
    <CreatedDate>29/03/2017</CreatedDate>
    <ClosedDate>29/03/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>18283</IssueID>
        <Title>Flaky Interactive Integration Tests</Title>
        <Description>The following tests have been failing (only one failed per build) in the latest debug integration test runs:

* [Roslyn.VisualStudio.IntegrationTests.CSharp.CSharpInteractive.TypingHelpDirectiveWorks](https://ci.dot.net/job/dotnet_roslyn/job/master/job/windows_debug_vs-integration/638/)
* [Roslyn.VisualStudio.IntegrationTests.CSharp.CSharpSendToInteractive.ExecuteInInteractiveWithKeyboardShortcut](https://ci.dot.net/job/dotnet_roslyn/job/master/job/windows_debug_vs-integration/639/)
* [Roslyn.VisualStudio.IntegrationTests.CSharp.CSharpInteractiveCommands.CutDeletePasteSelectAll](https://ci.dot.net/job/dotnet_roslyn/job/master/job/windows_debug_vs-integration/640/)</Description>
        <CreatedDate>29/03/2017</CreatedDate>
        <ClosedDate>29/03/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>18133</IssueID>
        <Title>Resetting Visual Studio after ResetInteractiveFromProject fails</Title>
        <Description>The **next** test after the following one (to be added shortly) fails:

```
        public void ResetInteractiveFromProjectAndVerify()
        {
            AddReference(ProjectName,
                "System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089");

            VisualStudio.Instance.SolutionExplorer.SelectItem(ProjectName);
            ExecuteCommand(WellKnownCommandNames.ProjectAndSolutionContextMenus_Project_ResetCSharpInteractiveFromProject);

            WaitForReplOutput("using TestProj;");
            SubmitText("x");
            WaitForLastReplOutputContains("CS0103");

            SubmitText("(new TestProj.C()).M()");
            WaitForLastReplOutput("\"C.M()\"");

            SubmitText("System.Windows.Forms.Form f = new System.Windows.Forms.Form(); f.Text = \"foo\";");
            SubmitText("f.Text");
            WaitForLastReplOutput("\"foo\"");
        }
```

The failure reason: Visual Studio crashed on switching between tests.
Adding `Wait(seconds: 5); ` in the very end of the test fixes the issue.            </Description>
        <CreatedDate>23/03/2017</CreatedDate>
        <ClosedDate>29/03/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/VisualStudio/IntegrationTest/IntegrationTests/CSharp/CSharpInteractiveCommands.cs</File>
      <File>src/VisualStudio/IntegrationTest/IntegrationTests/CSharp/CSharpSendToInteractive.cs</File>
      <File>src/VisualStudio/IntegrationTest/TestUtilities/InProcess/InteractiveWindow_InProc.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>18045</IssueID>
    <Title>Add "#error version" to C# and udpate UpgradeProject to support 7.1</Title>
    <Description>This is a re-worked version of PR #17957. In particular, it introduces no new syntax nodes.

This change solves two problems:
1. print out the compiler version as a diagnostic for troubleshooting purpose (with `#error version`)
2. generate a "please use version 7.1" diagnostic even when the compiler supports no 7.1 features yet (with `#error version:7.1`)

This is only supported in C# for now. I can file a separate issue for VB if needed.

Adds ability to print the compiler version as diagnostic (#17859)
Updates the UpgradeProject fixer as follow-up on #17894

@gafter @cston @tmat @CyrusNajmabadi for review. Thanks</Description>
    <CreatedDate>22/03/2017</CreatedDate>
    <ClosedDate>24/03/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>17957</IssueID>
        <Title>Add 7.1 support to UpgradeProject, add #version directive</Title>
        <Description>
Adds #version (https://github.com/dotnet/roslyn/issues/17859)
Updates the UpgradeProject fixer as follow-up on https://github.com/dotnet/roslyn/pull/17894</Description>
        <CreatedDate>18/03/2017</CreatedDate>
        <ClosedDate>22/03/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>17859</IssueID>
        <Title>Print compiler version in diagnostics when certain code is compiled</Title>
        <Description>It would be useful to troubleshooting purpose to have the equivalent of `phpversion()` for C# and VB. 
It could be a special pragma (`#VERSION`), a well-known method without implementation (`System.Runtime.CompilerServices.RuntimeHelpers.Version()`?) or maybe a special doc tag.

The output should not only include the version of the compiler, but also the language version that is used to compile the current code (this would be useful in asp.net scenario).

FYI @gafter @jaredpar</Description>
        <CreatedDate>14/03/2017</CreatedDate>
        <ClosedDate>24/03/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>17894</IssueID>
        <Title>Add C# 7.1 version to compiler</Title>
        <Description>cc @AlekseyTs @jcouv @dotnet/roslyn-compiler 

Contributes to #17173</Description>
        <CreatedDate>15/03/2017</CreatedDate>
        <ClosedDate>15/03/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/CSharpResources.Designer.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/ErrorCode.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/DirectiveParser.cs</File>
      <File>src/Compilers/CSharp/Test/CommandLine/CommandLineTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/LexicalAndXml/PreprocessorTests.cs</File>
      <File>src/Compilers/Core/Portable/CommandLine/CommonCompiler.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/UpgradeProject/UpgradeProjectTests.cs</File>
      <File>src/EditorFeatures/TestUtilities/Diagnostics/AbstractUserDiagnosticTest.cs</File>
      <File>src/Features/CSharp/Portable/UpgradeProject/CSharpUpgradeProjectCodeFixProvider.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>17692</IssueID>
    <Title>Refine syntax error recovery for partial code to not interfere with non-error code.</Title>
    <Description>Related to #15885
Fixes #17683

@CyrusNajmabadi Would you like to have a look at this before I send it out for review?
</Description>
    <CreatedDate>10/03/2017</CreatedDate>
    <ClosedDate>15/03/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>15885</IssueID>
        <Title>Parse incomplete code differently to better reflect user intent.</Title>
        <Description>Fixes https://github.com/dotnet/roslyn/issues/15881

This is a port of a parsing strategy we took in TypeScript to better deal with code as the user is typing it.  Note that this is a change in how we parse code in *error*, and it involves heuristics to make the tree better match the user intent.  The code in question is code like:

```c#
Task.
await Task.Delay(...);
```

Today, the C# parser eagerly parses this as a local declaration of the form "Task.await Task".  i.e. the "Type" is "Task.await" and the VariableDeclarator is "Task".  This clearly doesn't match what the user intends, and it messes up higher layers of the stack.

Specifically, because "Task." is a QualifiedName, that changes how we treat it (when it really should be a MemberAccessExpression).  Similarly, because it looks like we're declaring a local called 'Task', we introduce a bogus LocalSymbol into scope, which messes up binding of names like "Task" (it finds the local instead of the type).

The fix is to tweak how we parse here.  We specifically look for the pattern:

```
Id dot new-line
Id id
```

And we do not think of it as a LocalDeclaration *unless* we see a following token that more definitely demonstrates that it is local-variable.  i.e.

```
X.
Y z;
```

In this case, there is no syntax error, so we have to accept this code as being a local variable declaration. 

</Description>
        <CreatedDate>14/12/2016</CreatedDate>
        <ClosedDate>19/12/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>17683</IssueID>
        <Title>Compiler sensitive to newline in parsing an expression</Title>
        <Description>In VS2017 (C# 7), the compiler now rejects the following. Eliminating the newline before `MinValue` allows it to compile. This code compiled in previous versions of the product.

See also our [internal VSO bug](https://devdiv.visualstudio.com/0bdbc590-a062-4c3f-b0f6-9383f67865ee/_workitems?id=393733&amp;_a=edit) tracking this and the [community feedback page](https://developercommunity.visualstudio.com/content/problem/25465/c-linq-expression-doesnt-compile-in-vs2017.html).

``` c#
using System;
using System.Linq;

namespace ConsoleApp1
{
    class Program
    {
        static void Main(string[] args)
        {
            var a = from t in Enumerable.Range(0, 10)
                    where
                    t == Int32.
                    MinValue
                    select t;
        }
    }
}
```
</Description>
        <CreatedDate>10/03/2017</CreatedDate>
        <ClosedDate>15/03/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Parser/LanguageParser.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/ExpressionParsingTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>17113</IssueID>
    <Title>Diagnostics from Parse Options</Title>
    <Description>Fixes #15900.
Fixes #15797.
Reverts #15798.</Description>
    <CreatedDate>13/02/2017</CreatedDate>
    <ClosedDate>14/03/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>15900</IssueID>
        <Title>Change how pre-processor symbols are verified</Title>
        <Description>Today the `CSharpParseOptions` type is inconsistent with how it verifies pre-processor symbols:

- The constructor will verify all symbols are valid identifiers and throw an exception when they are not. 
- The `WithPreProcessorSymbols` method does no verification. 

This inconsistency is bad for bot the compiler and consumers of the compiler API.  After some discussion the compiler team decided to change the API in the following way:

- The `CSharpParseOptions` type will never throw on pre-processor symbols that are invalid identifiers.
- Diagnostics will be produced for invalid identifiers in the pre-processor symbols

As a part of fixing this we should examine uses like in the following PR to see if they need to be cleaned up after the change.  

https://github.com/dotnet/roslyn/pull/15798

</Description>
        <CreatedDate>14/12/2016</CreatedDate>
        <ClosedDate>14/03/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>15797</IssueID>
        <Title>CSharpParseOptions doesn't validate preprocessor symbols in some entry points</Title>
        <Description>CSharpParseOptions validate given preprocessor names in ctor.

```csharp
public CSharpParseOptions(
            LanguageVersion languageVersion = LanguageVersion.Default,
            DocumentationMode documentationMode = DocumentationMode.Parse,
            SourceCodeKind kind = SourceCodeKind.Regular,
            IEnumerable&lt;string&gt; preprocessorSymbols = null)
            : this(languageVersion, documentationMode, kind, preprocessorSymbols.ToImmutableArrayOrEmpty())
        {
            // We test the mapped value, LanguageVersion, rather than the parameter, languageVersion,
            // which has not had "Latest" mapped to the latest version yet.
            if (!LanguageVersion.IsValid())
            {
                throw new ArgumentOutOfRangeException(nameof(languageVersion));
            }

            if (!kind.IsValid())
            {
                throw new ArgumentOutOfRangeException(nameof(kind));
            }

            if (preprocessorSymbols != null)
            {
                foreach (var preprocessorSymbol in preprocessorSymbols)
                {
                    if (!SyntaxFacts.IsValidIdentifier(preprocessorSymbol))
                    {
                        throw new ArgumentException(nameof(preprocessorSymbol));
                    }
                }
            }
        }
```

but, there are other API to update those preprocessor and those doesn't validate preprocessor which lead to invalidate preprocessor names in parse options.

for example, this (WithPreprocessorSymbols) doesnt validate preprocessor names.

```csharp
public CSharpParseOptions WithPreprocessorSymbols(ImmutableArray&lt;string&gt; symbols)
        {
            if (symbols.IsDefault)
            {
                symbols = ImmutableArray&lt;string&gt;.Empty;
            }

            if (symbols.Equals(this.PreprocessorSymbols))
            {
                return this;
            }

            return new CSharpParseOptions(this) { PreprocessorSymbols = symbols };
        }
```

this is causing serialization to fail since csharp parse option has a way for user to set preprocessor name that is not valid.</Description>
        <CreatedDate>09/12/2016</CreatedDate>
        <ClosedDate>17/02/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>15798</IssueID>
        <Title>fix watson bug for OOP serialization</Title>
        <Description>**Customer scenario**

Customer has preprocessor defined for his csproj project which is actually invalid preprocessor

**Bugs this fixes:** 
https://devdiv.visualstudio.com/DevDiv/_workitems/edit/295512

**Workarounds, if any**

no workaround

**Risk**

no risk. IDE already allow to set such preprocessor on CSharpParseOptions.

**Performance impact**

N/A

**Is this a regression from a previous update?**

no

**Root cause analysis:**

root issue is this
https://github.com/dotnet/roslyn/issues/15797

but regardless, if such option exist, then serialization should be able to clone it over RPC.

**How was the bug found?**

Watson
</Description>
        <CreatedDate>09/12/2016</CreatedDate>
        <ClosedDate>09/12/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/CSharpParseOptions.cs</File>
      <File>src/Compilers/CSharp/Portable/CSharpResources.Designer.cs</File>
      <File>src/Compilers/CSharp/Portable/CommandLine/CSharpCommandLineParser.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/CSharpCompilation.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/ErrorCode.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/MessageProvider.cs</File>
      <File>src/Compilers/CSharp/Test/CommandLine/CommandLineTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Diagnostics/GetDiagnosticsTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/ScriptSemanticsTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/CSharpParseOptionsTests.cs</File>
      <File>src/Compilers/Core/CodeAnalysisTest/CommonParseOptionsTests.cs</File>
      <File>src/Compilers/Core/Portable/Compilation/ParseOptions.cs</File>
      <File>src/Compilers/Core/Portable/Diagnostic/CommonMessageProvider.cs</File>
      <File>src/Compilers/Core/Portable/SourceCodeKind.cs</File>
      <File>src/Test/Utilities/Portable/Mocks/TestMessageProvider.cs</File>
      <File>src/Test/Utilities/Portable/ReflectionAssert.cs</File>
      <File>src/Workspaces/CSharp/Portable/Execution/CSharpOptionsSerializationService.cs</File>
      <File>src/Workspaces/CoreTest/WorkspaceTests/MSBuildWorkspaceTestBase.cs</File>
      <File>src/Workspaces/CoreTest/WorkspaceTests/MSBuildWorkspaceTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>17404</IssueID>
    <Title>Ensure script compilations properly inherit return type from first compilation</Title>
    <Description>This fixes #17403 which prevents Xamarin Workbooks from moving to the upstream Roslyn 2.0 NuGet. Related to, and expands upon, #8507 _(Compilation: use System.Object from target corlib)_.

### Before

&lt;img width="628" alt="screen shot 2017-02-26 at 3 44 52 pm" src="https://cloud.githubusercontent.com/assets/49539/23343577/cee69cf6-fc3b-11e6-9537-0c6ff8bd1f23.png"&gt;

### After

&lt;img width="628" alt="screen shot 2017-02-26 at 3 51 05 pm" src="https://cloud.githubusercontent.com/assets/49539/23343580/d6d61748-fc3b-11e6-9c25-b0f2c7695e21.png"&gt;

</Description>
    <CreatedDate>26/02/2017</CreatedDate>
    <ClosedDate>27/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>17403</IssueID>
        <Title>Script compilations created from a previous compilation have incorrect return type</Title>
        <Description>We are now finally able to use the Roslyn 2.0 NuGet for Xamarin Workbooks, which means I can finally leverage my work for [supporting compilations against a target (not host) corlib](https://github.com/dotnet/roslyn/pull/8507).

Unfortunately the tests I wrote for that fix were not extensive enough to catch an issue where subsequent compilations result in an implicit reference to host corlib and not the target corlib.

This is due to the implementation of `ScriptCompilationInfo.ReturnType`, which was desired to never return `null`:

```csharp
public Type ReturnType =&gt; ReturnTypeOpt ?? typeof(object);
```

I did not catch all the places in Roslyn that were using `ReturnType` but should now be using `ReturnTypeOpt`:

* `CSharpScriptCompilationInfo.WithPreviousScriptCompilation`
* `CSharpCompilation.WithScriptCompilationInfo`
* `VisualBasicScriptCompilationInfo.WithPreviousScriptCompilation`
* `VisualBasicCompilation.WithScriptCompilationInfo`

This is how the bug ends up manifesting in Workbooks:

&lt;img width="628" alt="screen shot 2017-02-26 at 3 44 52 pm" src="https://cloud.githubusercontent.com/assets/49539/23343501/99d63ee6-fc3a-11e6-898d-0511b0b706bc.png"&gt;
</Description>
        <CreatedDate>26/02/2017</CreatedDate>
        <ClosedDate>27/02/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>8507</IssueID>
        <Title>Compilation: use System.Object from target corlib</Title>
        <Description>When creating a script compilation without an explicit return type, `System.Object` was being resolved via reflection from the host.

This resulted in an implicit dependency of a script compilation on the host corlib, even if a different corlib was specified as a reference for the compilation (e.g. Xamarin.iOS).

Fix this by using `System.Object` as defined in the corlib resolved for the compilation.

This fixes https://github.com/dotnet/roslyn/issues/8506.
</Description>
        <CreatedDate>09/02/2016</CreatedDate>
        <ClosedDate>02/06/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Compilation/CSharpCompilation.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/CSharpScriptCompilationInfo.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Compilation/CompilationAPITests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>17372</IssueID>
    <Title>Avoid deadlock on solution close with linked files</Title>
    <Description>Fixes #17305
Fixes
https://devdiv.visualstudio.com/0bdbc590-a062-4c3f-b0f6-9383f67865ee/_workitems?id=388328&amp;_a=edit

Escrow Template
==========
**Customer scenario** I'm not exactly sure how to reproduce it, but multiple reports point to the same problem. When closing a solution, we close a linked file, which causes the running document table to tell us about a context change, which deadlocks. I believe it can hang **before saving the solution**.

**Bugs this fixes:** 

#17305
https://devdiv.visualstudio.com/0bdbc590-a062-4c3f-b0f6-9383f67865ee/_workitems?id=388328&amp;_a=edit

**Workarounds, if any**: Close all open documents before closing the solution.

**Risk**: Fairly low. We avoid taking a lock when the lock has already been taken for us.

**Performance impact**: Essentially none. No allocations or complexity changes. 

**Is this a regression from a previous update?**: Unknown, but probably. I can't repro it, but the reports seem to be on RC4+ builds.

**Root cause analysis:** I don't know what regressed it. This should have been fixed in https://github.com/dotnet/roslyn/pull/16889, but I missed the linked files case. Shared Projects and linked files are now both handled appropriately.

**How did we miss it?**  I didn't think there were any additional callers of a particular overload of OnDocumentContextUpdated.

**How was the bug found?** Customer reports and dogfooding.</Description>
    <CreatedDate>24/02/2017</CreatedDate>
    <ClosedDate>28/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>17305</IssueID>
        <Title>Deadlock in VS while unloading project at OnDocumentContextUpdated</Title>
        <Description>**Version Used**: d15rel/15.0.26221.0, Roslyn commit: 38afa69825db300e58aa6416dbb2c14ab340da7f

**Steps to Reproduce**:
(this seems to be very intermittant and probably not reproduce, please see attached dump)
1. Open solution with several projects and several open files
2. Close VS

**Expected Behavior**:
VS exits

**Actual Behavior**:
VS freezes at "Unloading project 6 of 31: [Project Name]"

**Callstack**:
```
 	mscorlib.dll!System.Threading.Monitor.Wait(object obj, int millisecondsTimeout, bool exitContext) Line 203	C#
 	mscorlib.dll!System.Threading.SemaphoreSlim.WaitUntilCountOrTimeout(int millisecondsTimeout, uint startTime, System.Threading.CancellationToken cancellationToken) Line 469	C#
 	mscorlib.dll!System.Threading.SemaphoreSlim.Wait(int millisecondsTimeout, System.Threading.CancellationToken cancellationToken) Line 439	C#
&gt;	Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Workspace.OnDocumentContextUpdated(Microsoft.CodeAnalysis.DocumentId documentId, Microsoft.CodeAnalysis.Text.SourceTextContainer container) Line 354	C#
 	Microsoft.VisualStudio.LanguageServices.dll!Microsoft.VisualStudio.LanguageServices.Implementation.ProjectSystem.DocumentProvider.OnHierarchyChanged(uint docCookie, Microsoft.VisualStudio.Shell.Interop.IVsHierarchy pHierOld, uint itemidOld, Microsoft.VisualStudio.Shell.Interop.IVsHierarchy pHierNew, uint itemidNew, bool itemidChanged) Line 547	C#
 	Microsoft.VisualStudio.LanguageServices.dll!Microsoft.VisualStudio.LanguageServices.Implementation.ProjectSystem.DocumentProvider.OnAfterAttributeChangeEx(uint docCookie, uint grfAttribs, Microsoft.VisualStudio.Shell.Interop.IVsHierarchy pHierOld, uint itemidOld, string pszMkDocumentOld, Microsoft.VisualStudio.Shell.Interop.IVsHierarchy pHierNew, uint itemidNew, string pszMkDocumentNew) Line 535	C#
 	Microsoft.VisualStudio.LanguageServices.dll!Microsoft.VisualStudio.LanguageServices.Implementation.ProjectSystem.DocumentProvider.RunningDocTableEventsSink.OnAfterAttributeChangeEx(uint docCookie, uint grfAttribs, Microsoft.VisualStudio.Shell.Interop.IVsHierarchy pHierOld, uint itemidOld, string pszMkDocumentOld, Microsoft.VisualStudio.Shell.Interop.IVsHierarchy pHierNew, uint itemidNew, string pszMkDocumentNew) Line 27	C#

```
See dump at: \\\\mlangfs1\public\pafenelo\Issue17305</Description>
        <CreatedDate>22/02/2017</CreatedDate>
        <ClosedDate>28/02/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>17305</IssueID>
        <Title>Deadlock in VS while unloading project at OnDocumentContextUpdated</Title>
        <Description>**Version Used**: d15rel/15.0.26221.0, Roslyn commit: 38afa69825db300e58aa6416dbb2c14ab340da7f

**Steps to Reproduce**:
(this seems to be very intermittant and probably not reproduce, please see attached dump)
1. Open solution with several projects and several open files
2. Close VS

**Expected Behavior**:
VS exits

**Actual Behavior**:
VS freezes at "Unloading project 6 of 31: [Project Name]"

**Callstack**:
```
 	mscorlib.dll!System.Threading.Monitor.Wait(object obj, int millisecondsTimeout, bool exitContext) Line 203	C#
 	mscorlib.dll!System.Threading.SemaphoreSlim.WaitUntilCountOrTimeout(int millisecondsTimeout, uint startTime, System.Threading.CancellationToken cancellationToken) Line 469	C#
 	mscorlib.dll!System.Threading.SemaphoreSlim.Wait(int millisecondsTimeout, System.Threading.CancellationToken cancellationToken) Line 439	C#
&gt;	Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Workspace.OnDocumentContextUpdated(Microsoft.CodeAnalysis.DocumentId documentId, Microsoft.CodeAnalysis.Text.SourceTextContainer container) Line 354	C#
 	Microsoft.VisualStudio.LanguageServices.dll!Microsoft.VisualStudio.LanguageServices.Implementation.ProjectSystem.DocumentProvider.OnHierarchyChanged(uint docCookie, Microsoft.VisualStudio.Shell.Interop.IVsHierarchy pHierOld, uint itemidOld, Microsoft.VisualStudio.Shell.Interop.IVsHierarchy pHierNew, uint itemidNew, bool itemidChanged) Line 547	C#
 	Microsoft.VisualStudio.LanguageServices.dll!Microsoft.VisualStudio.LanguageServices.Implementation.ProjectSystem.DocumentProvider.OnAfterAttributeChangeEx(uint docCookie, uint grfAttribs, Microsoft.VisualStudio.Shell.Interop.IVsHierarchy pHierOld, uint itemidOld, string pszMkDocumentOld, Microsoft.VisualStudio.Shell.Interop.IVsHierarchy pHierNew, uint itemidNew, string pszMkDocumentNew) Line 535	C#
 	Microsoft.VisualStudio.LanguageServices.dll!Microsoft.VisualStudio.LanguageServices.Implementation.ProjectSystem.DocumentProvider.RunningDocTableEventsSink.OnAfterAttributeChangeEx(uint docCookie, uint grfAttribs, Microsoft.VisualStudio.Shell.Interop.IVsHierarchy pHierOld, uint itemidOld, string pszMkDocumentOld, Microsoft.VisualStudio.Shell.Interop.IVsHierarchy pHierNew, uint itemidNew, string pszMkDocumentNew) Line 27	C#

```
See dump at: \\\\mlangfs1\public\pafenelo\Issue17305</Description>
        <CreatedDate>22/02/2017</CreatedDate>
        <ClosedDate>28/02/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Workspaces/Core/Portable/Workspace/Workspace_Editor.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>17366</IssueID>
    <Title>send servicehub log files along with NFW to help investigate HubClient.RequestServiceAsync issues.</Title>
    <Description>this doesn't change any user experience. but will help us to have more info on figuring out why this happens

[Watson] clr20r3: CLR_EXCEPTION_System.InvalidOperationException_DETOURS_80131509_Microsoft.CodeAnalysis.Workspaces.dll!Roslyn.Utilities.Contract.FailWithReturn[[System.__Canon,_mscorlib]]
(https://devdiv.visualstudio.com/0bdbc590-a062-4c3f-b0f6-9383f67865ee/_workitems?id=386567&amp;projectId=0bdbc590-a062-4c3f-b0f6-9383f67865ee&amp;src=alerts&amp;src-action=summary_id_link&amp;fullScreen=true&amp;_a=edit)

....

currently we identified 3 common cases that lead to the above problem. but we need more info to figure out the root cause of it.

this change let us send those info when this happens.

....

**Customer scenario**

VS suddenly crash while user is using solution with C#/VB projects.

**Bugs this fixes:** 

https://github.com/dotnet/roslyn/issues/17012

this doesn't actually fix the crash, but send more info to help us to fix the issue.

**Workarounds, if any**

turn off OOP through hidden registry key.

**Risk**

when customer hit the issue, now we send more info than before when sending NFW. but since NFW is throttled and not sent on every occurrences of the issue, most of time, should be okay. but when NFW is actually sent, it will take more time.

**Performance impact**

when NFW is actually sent, it will take more time to gather information.

**Is this a regression from a previous update?**

No

**Root cause analysis:**

we have found these 3 common patterns that cause HubClient.RequestServiceAsync to fail. people are tracking each issues separately. but requires more info to track down to root cause. this PR is to gather more data to help investigating the issues below.

#1, “StreamJsonRpc.RemoteInvocationException: Request locate failed with message: Cannot find service module info file '*/codeAnalysisService.servicehub.service.json' in 'C:\Program Files (x86)\Microsoft Visual Studio\2017\Enterprise\Common7\ServiceHub\Services', using discovery services failed: VsixServiceDiscovery: ExternalSettingsManager::GetScopePaths failed to initialize PkgDefManager”
 
 
#2, “StreamJsonRpc.RemoteInvocationException: Request locate failed with message: Cannot find service module info file '*/codeAnalysisService.servicehub.service.json' in 'C:\Program Files (x86)\Microsoft Visual Studio\2017\Enterprise\Common7\ServiceHub\Services', using discovery services failed: VsixServiceDiscovery: connect ENOENT \\?\pipe\a5e4cfe06cbe4adead96a3d5ff65a88d at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)”
 
#3, StreamJsonRpc.RemoteInvocationException: Request locate failed with message: Cannot find service config file 'C:\Users\[UserName]\AppData\Local\Temp\dev50B1.tmp'. at Microsoft.ServiceHub.HostLib.AppDomainIsolationServiceManager.GetDomainKey(ServiceModuleInfo smi) at Microsoft.ServiceHub.HostLib.AppDomainIsolationServiceManager.StartService(ServiceModuleInfo smi) at Microsoft.ServiceHub.HostLib.Host.startService(ServiceModuleInfo smi) at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at System.Runtime.CompilerServices.TaskAwaiter.ValidateEnd(Task task) at StreamJsonRpc.JsonRpc.&lt;InvokeCoreAsync&gt;d__56`1.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification

currently, we have these bugs to track each issues.

388344
[Watson] crash32: HEAP_CORRUPTION_c0000374_heap_corruption!ServiceHub.Host.CLR.x86.exe
https://devdiv.visualstudio.com/DevDiv/_workitems/edit/388344

388327
[Watson] crash32: HEAP_CORRUPTION_ACTIONABLE_BlockNotBusy_DOUBLE_FREE_c0000374_Microsoft.VisualStudio.Settings.15.0.dll!RegistryDetouring::InitializeRegRootHive
https://devdiv.visualstudio.com/DevDiv/_workitems/edit/388327

387392 Lock the app config file in %temp% in volatile pkgdef merge case for the lifetime of VS instance
https://devdiv.visualstudio.com/DevDiv/_workitems/edit/387392

**How was the bug found?**

Watson, customer report.</Description>
    <CreatedDate>24/02/2017</CreatedDate>
    <ClosedDate>27/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>1</IssueID>
        <Title>Initial port and addition of README.md</Title>
        <Description>This is a port of the readme from CodePlex.  Some of the links have been updated to point to locations on GitHub, but many of the links still point back to CodePlex as comparable GitHub locations are currently absent.
</Description>
        <CreatedDate>14/01/2015</CreatedDate>
        <ClosedDate>14/01/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>2</IssueID>
        <Title>Update links in README.md with ported wiki content</Title>
        <Description>
        </Description>
        <CreatedDate>14/01/2015</CreatedDate>
        <ClosedDate>14/01/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>3</IssueID>
        <Title>Add symbol files(.pdb/source) to NuGet packages</Title>
        <Description>It would be nice to be able to step inside Roslyn code when using NuGet packages.

This is nice guide on how to do this:
http://blog.davidebbo.com/2011/04/easy-way-to-publish-nuget-packages-with.html

&lt;!---
@huboard:{"order":6.0}
--&gt;
</Description>
        <CreatedDate>15/01/2015</CreatedDate>
        <ClosedDate>08/11/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/VisualStudio/Core/Def/Implementation/Watson/WatsonReporter.cs</File>
      <File>src/VisualStudio/Core/Next/Remote/ServiceHubRemoteHostClient.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>17294</IssueID>
    <Title>Put Local Function's type parameters in scope within function's signature for the purpose of SemanticModel lookup/binding.</Title>
    <Description>Fixes #16801.
Also fixes #17198.

@dotnet/roslyn-compiler, @agocke Please review.</Description>
    <CreatedDate>22/02/2017</CreatedDate>
    <ClosedDate>28/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>16801</IssueID>
        <Title>SemanticModel.LookupNames/LookupSymbols APIs do not return Local Function type parameters in any place within the function signature</Title>
        <Description>This is a clone of TestMethodParameterAndTypeParameterScope unit-test from src\compilers\csharp\test\semantic\semantics\lookuppositiontests.cs
```
        [Fact]
        public void TestLocalFunctionParameterAndTypeParameterScope()
        {
            var text = @"
class C
`{
    void Test()
    `{
        `void `M`&lt;T&gt;(int x) `{ `}
    `}
`}
";

            var expectedNames = MakeExpectedSymbols(
                Add( //Global
                    "C",
                    "System",
                    "Microsoft"),
                Add( //C
                    "void C.Test()",
                    "System.Boolean System.Object.Equals(System.Object obj)",
                    "System.Boolean System.Object.Equals(System.Object objA, System.Object objB)",
                    "System.Boolean System.Object.ReferenceEquals(System.Object objA, System.Object objB)",
                    "System.Int32 System.Object.GetHashCode()",
                    "System.Object System.Object.MemberwiseClone()",
                    "void System.Object.Finalize()",
                    "System.String System.Object.ToString()",
                    "System.Type System.Object.GetType()"),
                Add("void M&lt;T&gt;(System.Int32 x)"), // Test body
                Add("T"), s_pop, //C.C(int) return type
                Add("T"), //C.C(int) between name and body
                Add("System.Int32 x"), //C.C(int) body
                Combine(s_pop, s_pop), //C.C(int)
                s_pop, // Test body
                s_pop //C
            );

            TestLookupNames(text, expectedNames);
        }
```

```
Test 'Microsoft.CodeAnalysis.CSharp.UnitTests.LookupPositionTests.TestLocalFunctionParameterAndTypeParameterScope' failed:
	Lookup(46) - 'void' in 'void' after 3th '`' - "--&gt;" found but not expected, "++&gt;" expected but not found

Expected:
C,
Microsoft,
System,
System.Boolean System.Object.Equals(System.Object obj),
System.Boolean System.Object.Equals(System.Object objA, System.Object objB),
System.Boolean System.Object.ReferenceEquals(System.Object objA, System.Object objB),
System.Int32 System.Object.GetHashCode(),
System.Object System.Object.MemberwiseClone(),
System.String System.Object.ToString(),
System.Type System.Object.GetType(),
T,
void C.Test(),
void M&lt;T&gt;(System.Int32 x),
void System.Object.Finalize()
Actual:
C,
Microsoft,
System,
System.Boolean System.Object.Equals(System.Object obj),
System.Boolean System.Object.Equals(System.Object objA, System.Object objB),
System.Boolean System.Object.ReferenceEquals(System.Object objA, System.Object objB),
System.Int32 System.Object.GetHashCode(),
System.Object System.Object.MemberwiseClone(),
System.String System.Object.ToString(),
System.Type System.Object.GetType(),
void C.Test(),
void M&lt;T&gt;(System.Int32 x),
void System.Object.Finalize()
Differences:
    C,
    Microsoft,
    System,
    System.Boolean System.Object.Equals(System.Object obj),
    System.Boolean System.Object.Equals(System.Object objA, System.Object objB),
    System.Boolean System.Object.ReferenceEquals(System.Object objA, System.Object objB),
    System.Int32 System.Object.GetHashCode(),
    System.Object System.Object.MemberwiseClone(),
    System.String System.Object.ToString(),
    System.Type System.Object.GetType(),
--&gt; T,
    void C.Test(),
    void M&lt;T&gt;(System.Int32 x),
    void System.Object.Finalize()

Expected: True
Actual:   False
```</Description>
        <CreatedDate>27/01/2017</CreatedDate>
        <ClosedDate>28/02/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>17198</IssueID>
        <Title>MemberSemanticModel.GetDeclaredSymbol(LocalFunctionStatementSyntax shouldn't bind LocalFunctionStatementSyntax</Title>
        <Description>It should work similar to ```GetDeclaredSymbol(VariableDeclaratorSyntax```, which doesn't bind any syntax. </Description>
        <CreatedDate>16/02/2017</CreatedDate>
        <ClosedDate>28/02/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Compilation/MemberSemanticModel.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/LocalFunctionSymbol.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/LocalFunctionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/LookupPositionTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>17260</IssueID>
    <Title>Document that "additional files" are an input for determinism.</Title>
    <Description>Fixes #17121 

@jcouv @jaredpar Please verify that this is what you had in mind for #17121.
</Description>
    <CreatedDate>20/02/2017</CreatedDate>
    <ClosedDate>21/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>17121</IssueID>
        <Title>Compiler does not take all inputs into account for determinism</Title>
        <Description>In discussion about editorconfig today, a number of scenarios were mentioned that we know or suspect are not properly accounted for in determinism:
- additional files
- rulesets
- included rulesets from ruleset

FYI @jaredpar </Description>
        <CreatedDate>13/02/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>17121</IssueID>
        <Title>Compiler does not take all inputs into account for determinism</Title>
        <Description>In discussion about editorconfig today, a number of scenarios were mentioned that we know or suspect are not properly accounted for in determinism:
- additional files
- rulesets
- included rulesets from ruleset

FYI @jaredpar </Description>
        <CreatedDate>13/02/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>17227</IssueID>
    <Title>Eliminate bound method groups during local lowering</Title>
    <Description>Fixes #14882
Fixes #13840
Fixes #13915
(those three are mostly separate reports of the same issue)

It takes one line to lower method groups in local lowering, and we can then delete lots of code
that used to be required to handle them in later phases.

@dotnet/roslyn-compiler May I please have a couple of reviews for this?
</Description>
    <CreatedDate>18/02/2017</CreatedDate>
    <ClosedDate>23/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>14882</IssueID>
        <Title>Consider lowering method group conversions into delegate creation</Title>
        <Description>Currently we have a conflated bound node that can represent both high-level method group conversion and low-level delegate creation. Semantically these are slightly different actions and there are many places that need to adjust for this.
I think initially we reused the node, hoping to minimize rewriting, but as a result we still need to rewrite most method group conversions while the code dealing with unified node needs to deal with its peculiarities.

see for example comments like:
```cs
                // This can occur in a delegate creation expression because the method group
                // in the argument can have a "this" receiver even when "this"
                // is not captured because a static method is selected.  But we do preserve
                // the method group and its receiver in the bound tree, so the "this"
                // receiver must be rewritten.

                //TODO: It seems we may capture more than needed here.

                // TODO: Why don't we drop "this" while lowering if method is static? 
                //       Actually, considering that method group expression does not evaluate to a particular value 
                //       why do we have it in the lowered tree at all?
```

Note that VB already uses separate nodes for this and separation of responsibilities makes corresponding code simpler since certain scenarios (like fake "capturing" of "this" by a static method group in the example above)  simply cannot happen.</Description>
        <CreatedDate>02/11/2016</CreatedDate>
        <ClosedDate>23/02/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>13840</IssueID>
        <Title>BoundMethodGroup node sometimes survives local lowering phase </Title>
        <Description>@gafter 

This can be seen in the following bugs / prs
- https://github.com/dotnet/roslyn/pull/13832
- https://github.com/dotnet/roslyn/issues/13734
</Description>
        <CreatedDate>15/09/2016</CreatedDate>
        <ClosedDate>23/02/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>13915</IssueID>
        <Title>sometimes a method group remains in the bound tree after lowering</Title>
        <Description>There are cases where a method group is not lowered properly (i.e. a method group remains in the bound tree following the lowering phase), resulting in the need for compensating code in a number of other places in the compiler. The method group is kept in the tree as a handle on the receiver, but the lowered code should store the receiver explicitly.

See https://github.com/dotnet/roslyn/pull/13832#r79497612 for an example where compensating code had to be added recently.
</Description>
        <CreatedDate>19/09/2016</CreatedDate>
        <ClosedDate>23/02/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/CodeGen/EmitConversion.cs</File>
      <File>src/Compilers/CSharp/Portable/CodeGen/EmitExpression.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/AsyncRewriter/AwaitExpressionSpiller.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/ExpressionLambdaRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/LambdaRewriter.Analysis.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/LambdaRewriter.LocalFunctionReferenceRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/LambdaRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_Conversion.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_DelegateCreationExpression.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/MethodToClassRewriter.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Source/ExpressionCompiler/Rewriters/CapturedVariableRewriter.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>16928</IssueID>
    <Title>Add tests to improve coverage of pattern-matching implementation and fix a crash.</Title>
    <Description>Fixes #9542
Fixes #16876
</Description>
    <CreatedDate>03/02/2017</CreatedDate>
    <ClosedDate>15/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>9542</IssueID>
        <Title>Test code coverage of pattern-matching implementation.</Title>
        <Description>The pattern-matching implementation started out as a prototype, and reflects a specification that is in flux; it is not in its final production-ready form. The implementation needs to be reviewed in detail against the final specification once it exists, and we should ensure we have code coverage of the relevant code paths of the implementation.
</Description>
        <CreatedDate>08/03/2016</CreatedDate>
        <ClosedDate>15/02/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>16876</IssueID>
        <Title>Crash (assertion error) compiling pattern switch</Title>
        <Description>Crash (assertion error) compiling pattern switch

The following switch crashes the compiler with an assertion error in Miltstone 2.0 RTM.

``` c#
    static void M2(object o, bool b)
    {
        switch (o)
        {
            case null:
                Console.WriteLine(""M2a""); break;
            case var _ when b:
                Console.WriteLine(""M2b""); break;
            case 1:
                Console.WriteLine(""M2c""); break;
        }
    }
```
</Description>
        <CreatedDate>01/02/2017</CreatedDate>
        <ClosedDate>15/02/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Patterns.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/PatternSwitchBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/SubsumptionDiagnosticBuilder.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/DecisionTree.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/DecisionTreeBuilder.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_PatternSwitchStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/PDB/PDBTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTestBase.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternSwitchTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23930</IssueID>
    <Title>Fix two bugs in async lifting analysis which results in unnecessarily lifted locals.</Title>
    <Description>The first issue is that we did not properly track the unreachable state in lifting analysis. I believe we did so to work around a bug that has since been fixed.
The second issue is that an assignment in a conditional branch condition was not treated as conditional.

Since VB does not have an assignment expression, I do not have a repro for user locals, but the fix results in some temps no longer being unnecessarily lifted (as shown by changes in existing tests)

### Customer scenario

Async methods have more IL for their bodies, and more locals lifted, than necessary.

### Bugs this fixes

Fixes #13759

### Workarounds, if any

None known.

### Risk

The fix is simple. On the other hand, flow analysis is subtle and the reasons that we tracked unreachable state the way we did is lost in prehistory.

### Performance impact

Changes are simple and local, so no performance impact expected.

### Is this a regression from a previous update?

No.

### Root cause analysis

We do not have extensive testing for which locals are lifted in async code under what circumstances. Too much lifting is generally only a performance (not correctness) problem, so we did not prioritize it.

### How was the bug found?

Customer reported.

### Test documentation updated?

It would be good to add supporting test infrastructure and tests for which locals are lifted for various uses of language constructs. Once that is in place, we could add it as an item to check off for testing new features. This suggestion is recorded in #23929.
</Description>
    <CreatedDate>26/12/2017</CreatedDate>
    <ClosedDate>09/01/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>13759</IssueID>
        <Title>Unnecessarily lifted field in async state machine</Title>
        <Description>**Version Used**: 
2.0.0.60620

**Steps to Reproduce**:
Compile this code:

``` C#
using System.IO;
using System.Threading.Tasks;

class Program
{
    public static void Main() { }

    public static async Task Repro1(Stream source, Stream destination)
    {
        byte[] buffer = new byte[0x1000];
        int bytesRead;
        while ((bytesRead = await source.ReadAsync(buffer, 0, buffer.Length)) != 0)
        {
            await destination.WriteAsync(buffer, 0, bytesRead);
        }
    }

    public static async Task Repro2(Stream source, Stream destination)
    {
        byte[] buffer = new byte[0x1000];
        while (true)
        {
            int bytesRead = await source.ReadAsync(buffer, 0, buffer.Length);
            if (bytesRead == 0) break;
            await destination.WriteAsync(buffer, 0, bytesRead);
        }
    }
}
```

**Expected Behavior**:
The async state machine does not have a field for `bytesRead`.

**Actual Behavior**:
In Repro2, as expected, the async state machine does not lift `bytesRead` to the state machine.  But in Repro1, it does lift `bytesRead` to the state machine, even though the value of `bytesRead` doesn't need to be preserved across an await.
</Description>
        <CreatedDate>13/09/2016</CreatedDate>
        <ClosedDate>09/01/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23929</IssueID>
        <Title>Add tests for lifted variables in async/iterator code</Title>
        <Description>We do not have many tests that verify the set of variables lifted in async or iterator code. It would be good to add a bit of testing infrastructure to make that easy, and add tests. Also, this could be added to the checklist for new features.</Description>
        <CreatedDate>26/12/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/PreciseAbstractFlowPass.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/StateMachineRewriter/IteratorAndAsyncCaptureWalker.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenAsyncTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23448</IssueID>
    <Title>Simplify diagnostic tagging by making it use the standard tagging model.</Title>
    <Description>### Customer scenario

User is working on a big solution and switching between git branches multiple times or close and reopen solutions multiple times. and on some unfortunate cases, VS will crash with out of memory exception. 

### Bugs this fixes

Fixes #24055
Fixes [DevDiv 512757](https://devdiv.visualstudio.com/DevDiv/_workitems/edit/512757)

Supersedes #22920, #23377, #23409, #23411

### Workarounds, if any

after each git branch switching or solution open/close, give VS sometimes to process pending works enqueued by the operation.

### Risk

this simplify our diagnostic tagger dramatically. so there is a risk where behavior might not exactly same as before. but we believe this is right direction to go. 

### Performance impact

this should remove OOM due to too many pending UI work items completely. that is source of most of our OOM crash.

### Is this a regression from a previous update?

No

### Root cause analysis

previously, diagnostic service didn't support pull model for all diagnostics source. so, tagger used event (push model) to hold onto last reported diagnostics and later use that to report tags. and that made us to use custom logic for the tagger which ends up forcing us to use UI thread to synchronize many states to remove potential race. and that caused us to push too many work items to UI thread in certain case such as git branch switching.

now, diagnostic service fully supporting pull model for all sources, this moves diagnostic taggers to follow our tagger framework which doesn't require UI thread for state synchronization. removing the root cause of OOM from the picture completely.

### How was the bug found?

MemoryWatson

....

more dev detail.

From a conversation with @heejaechang https://github.com/dotnet/roslyn/pull/23409#issuecomment-347675771 

A while back the diagnostics subsystem had a limitation where you could only hear about some diagnostics if you explicitly listened for diagnostic events.  i.e. if you weren't listenting and capturing those events, you couldn't go back and ask for those diagnostics later.  This meant that we couldn't do diagnostic tagging (squiggles/fading/suggestions) like we did normal tagging. Normal tagging hears about events, pauses a bit, then goes and gets all the data necessary later to produce the tags.  Because that data wasn't available 'later', diagnostic tagging had to aggregate the info and contort things to fit into the tagging infrastructure.

This restriction from the diagnostics service no longer exists. THat means we can great simplify how we do our tagging computation.  </Description>
    <CreatedDate>28/11/2017</CreatedDate>
    <ClosedDate>16/01/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>24055</IssueID>
        <Title>Microsoft CodeAnalysis OOM Exception </Title>
        <Description>Ported from https://github.com/dotnet/roslyn-analyzers/issues/1503

-----------------------------
@chillryan

I've reported this issue through the visual studio feedback tool [see link](https://developercommunity.visualstudio.com/content/problem/174842/visual-studio-155-crashes-when-switching-git-branc.html) but figured I'd try my chances posting here.

I'm using the Code Analysis 2017 extension for VS 2017 15.5. In looking at the stack trace, I can only assume that since the extension is running inside the devenv process, when its analysis a loaded solution, it hits the OOM. 

Since I've hit this situation a very frequent basis, I've disabled solution analysis for C# projects hoping that will help. I'll report back here if there are any changes or comment on the visual studio feedback link posted prior.
  </Description>
        <CreatedDate>04/01/2018</CreatedDate>
        <ClosedDate>16/01/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22920</IssueID>
        <Title>reduce diagnostic tagger's usages of UI thread for synchronization</Title>
        <Description>**Customer scenario**

Customer is working on a VS. doing code fix and watching previews, applying fix all and etc, and suddenly VS crash due to OOM.

**Bugs this fixes:**

https://devdiv.visualstudio.com/DevDiv/_workitems/edit/512757

**Workarounds, if any**

there is no easy workaround.

**Risk**

I don't see risk of crash, but since it is highly visible area (tagger), we probably want more dogfooding time for this.

**Performance impact**

it should move more work to background thread, and reduce need for UI thread. in turn, improving responsiveness and memory.

**Is this a regression from a previous update?**

Yes.

**Root cause analysis:**

this one is hard to pin point to 1 issue. but caused by several different fixes. 

first, we made all state management to happen on UI thread to remove any potential race. and that caused us to use more FG than before.

second, we merged preview only tagger with regular diagnostic tagger, making preview tagger to be as expansive as normal diagnostic tagger meaning it uses same amount of UI threads since it now has same states tracking as normal ones.

third, along with that, some filtering on BG got removed which was there to reduce work on FG since all those are changed to be done on FG. 

forth, diagnostic tagger didn't pass cancellation token all the way through, leaving already cancelled works in the UI work queue.

fifth, foreground work queue cleaned up cancelled works too lazily and let cancelled work to pile up.

..

this reduces demand for UI thread, but due to the fact that UI thread can be blocked (due to exclusive operation running such as Fix All, or model dialog box or Wait dialog box and more), we can't completely get rid of pending requests for UI threads. but with this change, we should have way less chance to hit 2.1 million pending UI requests.

**How was the bug found?**

MemoryWatson
</Description>
        <CreatedDate>31/10/2017</CreatedDate>
        <ClosedDate>29/11/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23377</IssueID>
        <Title>Batch up and flatten diagnostic updates.</Title>
        <Description>In response to https://github.com/dotnet/roslyn/pull/22920#issuecomment-346950158

This is a tweak to the diagnostic taggers to improve how they respond to a flood of notifications from the underlying diagnostic services.  There are a few improvements as part of this PR.  

1. We batch up diagnostic notifications over a 50ms window and process them all at once, instead of enqueing and processing each notification on the UI thread individually.
2. Because we're batching, we can do a lot of preprocessing of the notifications to throw out information that has been superceded.  For example, if we get a notification that we're actually removing all the diagnostics for a provider, we can just ignore all previous diagnostic-creates that we haven't processed yet.  Also, any more diagnostic creations we hear about will supercede previous diagnostic creations for that provider.  
</Description>
        <CreatedDate>26/11/2017</CreatedDate>
        <ClosedDate>16/01/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23409</IssueID>
        <Title>Batch up and flatten diagnostic updates, second approach.</Title>
        <Description>This is a followup to https://github.com/dotnet/roslyn/pull/23377.  The primary difference between this PR and that one is that we also do filtering of diagnostic events on teh BG (acknowledging that this is racey, but just as racey as before).</Description>
        <CreatedDate>28/11/2017</CreatedDate>
        <ClosedDate>16/01/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23411</IssueID>
        <Title>Batch up and flatten diagnostic updates, third approach.</Title>
        <Description>Followup to https://github.com/dotnet/roslyn/pull/23409.

But with a simpler batching model where we only have to store the latest args for any id+doc pair.  </Description>
        <CreatedDate>28/11/2017</CreatedDate>
        <ClosedDate>16/01/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/Core/Implementation/Diagnostics/AbstractDiagnosticsAdornmentTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Diagnostics/AbstractDiagnosticsTaggerProvider.AggregatingTagger.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Diagnostics/AbstractDiagnosticsTaggerProvider.TaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Diagnostics/AbstractDiagnosticsTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Diagnostics/DiagnosticsClassificationTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Diagnostics/DiagnosticsSquiggleTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Diagnostics/DiagnosticsSuggestionTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Tagging/TaggerContext.cs</File>
      <File>src/Workspaces/Core/Portable/Diagnostics/DiagnosticData.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>22100</IssueID>
    <Title>Make analyzer diagnostics independent of the current warning level</Title>
    <Description>Fixes #20377

**Customer scenario**

Sets the C# compiler warning level to 1, 2, or 3 (instead of the default 4). Several IDE features stop working, including fading out unused `using` directives and all "suggestion" level editor hints.

**Bugs this fixes:**

Fixes #20377.

**Workarounds, if any**

Set the compiler warning level to 4, then manually disable warnings it introduces. This works, and warning level 4 is certainly recommended, but users are not likely to understand why the IDE is "not working" when the warning level changes.

**Risk**

Low.

* The behavior in default and overwhelming majority scenarios does not change
* The behavior the edge case where `/warn:0` is used for the compiler to only show "true" errors is retained
* Diagnostic severity is not tied to diagnostic warning level, so the change is not even observable in most cases

**Performance impact**

For most users, performance will not change at all. For users with customized warning levels, performance could drop, but only because we would now be showing diagnostic results which were previously suppressed at the filtering stage.

**Is this a regression from a previous update?**

No.

**Root cause analysis:**

Almost no one uses warning level 3.

**How was the bug found?**

Observed broken functionality in [Microsoft/perfview](https://github.com/Microsoft/perfview).

**Test documentation updated?**

Unknown

&lt;!-- If this is a new non-compiler feature or a significant improvement to an existing feature, update https://github.com/dotnet/roslyn/wiki/Manual-Testing once you know which release it is targeting. --&gt;
</Description>
    <CreatedDate>13/09/2017</CreatedDate>
    <ClosedDate>16/01/2018</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>20377</IssueID>
        <Title>Warning Level 3 breaks Remove Unused Usings and Simplify Type Name</Title>
        <Description>**Version Used**: 15.3 Preview 2.1

**Steps to Reproduce**:

1. Set C# warning level to 3
2. Add the following code

    ```csharp
    using System;
    using System.Threading;

    class Class
    {
      System.Action _action = (Action)(() =&gt; { });
    }
    ```

**Expected Behavior**:

1. `System.Threading` is indicated as an unused using directive, and the light bulb allows its removal
2. The `System.` qualification in `System.Action` is marked as unnecessary, and the light bulb allows the type to be simplified to `Action`

**Actual Behavior**:

1. Both using directives are indicated as used
2. `System.Action` is not indicated as overly qualified

Neither the light bulb nor the Remove and Sort Usings command may be used to make the desired corrections.</Description>
        <CreatedDate>21/06/2017</CreatedDate>
        <ClosedDate>16/01/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>20377</IssueID>
        <Title>Warning Level 3 breaks Remove Unused Usings and Simplify Type Name</Title>
        <Description>**Version Used**: 15.3 Preview 2.1

**Steps to Reproduce**:

1. Set C# warning level to 3
2. Add the following code

    ```csharp
    using System;
    using System.Threading;

    class Class
    {
      System.Action _action = (Action)(() =&gt; { });
    }
    ```

**Expected Behavior**:

1. `System.Threading` is indicated as an unused using directive, and the light bulb allows its removal
2. The `System.` qualification in `System.Action` is marked as unnecessary, and the light bulb allows the type to be simplified to `Action`

**Actual Behavior**:

1. Both using directives are indicated as used
2. `System.Action` is not indicated as overly qualified

Neither the light bulb nor the Remove and Sort Usings command may be used to make the desired corrections.</Description>
        <CreatedDate>21/06/2017</CreatedDate>
        <ClosedDate>16/01/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Test/Semantic/Diagnostics/GetDiagnosticsTests.cs</File>
      <File>src/Compilers/Core/Portable/Diagnostic/Diagnostic.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/SimplifyTypeNames/SimplifyTypeNamesTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/RemoveUnnecessaryImports/RemoveUnnecessaryImportsTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23794</IssueID>
    <Title>Do not allow source suppression for VS/host diagnostics</Title>
    <Description>This fixes the UI delay from force binding all assembly attributes during solution load.
Fixes #23775

&lt;details&gt;&lt;summary&gt;Ask Mode template&lt;/summary&gt;

### Customer scenario

Customer loads a solution that has more than one analyzer with conflicting dependency contents. This leads to analyzer conflict diagnostics getting reported during solution load. Reporting these diagnostic force completes binding of all assembly attributes in the compilation on the UI thread, causing a very large UI delay.

### Bugs this fixes

#23775

### Workarounds, if any

N/A

### Risk

Low. We are not executing a bunch of code that force completes the attributes to check for source suppressions. Users are recommended to suppress analyzer conflict diagnostics through compilation options.

### Performance impact

This should improve solution load performance in presence of analyzer dependency conflict diagnostics.

### Is this a regression from a previous update?

No.

### Root cause analysis

This was a known issue for a while, but we thought it was pretty rare, and something that would go away with us moving to new project system doing this work on a background thread.

### How was the bug found?

Dogfooding.

### Test documentation updated?

N/A

&lt;/details&gt;
</Description>
    <CreatedDate>14/12/2017</CreatedDate>
    <ClosedDate>15/12/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>23775</IssueID>
        <Title>AnalyzerDependencyCheckingService.CheckForConflictsAsync results in 15 seconds of blocked UI opening Roslyn</Title>
        <Description>**Version Used**: 
Visual Studio 2017 version 15.5

**Steps to Reproduce**:
1. Open a large solution where there are analyzer diagnostics in a "leaf" project.

**Expected Behavior**:
Solution should open in a reasonable time

**Actual Behavior**:
It's very slow, because creating the diagnostic requires a full compilation to be built and then examined for source level suppressions, and this happens synchronously on the UI thread as part of solution load.


`microsoft.visualstudio.languageservices   &lt;&lt;microsoft.visualstudio.languageservices!Microsoft.VisualStudio.LanguageServices.Implementation.AnalyzerDependencyCheckingService+&lt;CheckForConflictsAsync&gt;d__14.MoveNext()&gt;&gt; | 11.2 | 9,363.414 | 4,087`



</Description>
        <CreatedDate>14/12/2017</CreatedDate>
        <ClosedDate>15/12/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23775</IssueID>
        <Title>AnalyzerDependencyCheckingService.CheckForConflictsAsync results in 15 seconds of blocked UI opening Roslyn</Title>
        <Description>**Version Used**: 
Visual Studio 2017 version 15.5

**Steps to Reproduce**:
1. Open a large solution where there are analyzer diagnostics in a "leaf" project.

**Expected Behavior**:
Solution should open in a reasonable time

**Actual Behavior**:
It's very slow, because creating the diagnostic requires a full compilation to be built and then examined for source level suppressions, and this happens synchronously on the UI thread as part of solution load.


`microsoft.visualstudio.languageservices   &lt;&lt;microsoft.visualstudio.languageservices!Microsoft.VisualStudio.LanguageServices.Implementation.AnalyzerDependencyCheckingService+&lt;CheckForConflictsAsync&gt;d__14.MoveNext()&gt;&gt; | 11.2 | 9,363.414 | 4,087`



</Description>
        <CreatedDate>14/12/2017</CreatedDate>
        <ClosedDate>15/12/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/Core/Portable/Diagnostic/Diagnostic.cs</File>
      <File>src/Workspaces/Core/Portable/Diagnostics/DiagnosticData.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23610</IssueID>
    <Title>Fix UseNullPropagation codefix doesn't recognize `x is null ? null : x.y` pattern</Title>
    <Description>Fixes #23043. This should handle both the `x is null` and the `ReferenceEquals(x, null)` scenarios.

### Customer scenario

Visual Studio 2017 contains a "Use Null Propagation" analyzer and code fix that helps users convert conditional code (`if` statements and ternary expressions) into the new `?.` syntax. While the analysis already supports the most common styles of null checks, there were two specific cases that were simply ignored:

* Conditions based on the new pattern syntax: `x is null`
* Conditions based on calls to `object.ReferenceEquals`

### Bugs this fixes

Fixes #23043 

### Workarounds, if any

None needed

### Risk

Low¹. Changes are restricted to a single analyzer/fix, and tests² are added for all newly supported cases.

¹ ✔️ I need to apply a Fix All on Roslyn before and after this change to review the difference for bugs. (Confirmed via https://github.com/dotnet/roslyn/pull/23610#issuecomment-350328171)
² ✔️ Negative tests would be good as well. I am requesting them in review. (Confirmed via https://github.com/dotnet/roslyn/pull/23610#issuecomment-350294478)

### Performance impact

Should be low. The code was reviewed with consideration for known performance sensitivities in analyzers, and will be run through AnalyzerRunner prior to final release.

### Is this a regression from a previous update?

No.

### Root cause analysis

Previously identified optional work from a prior feature.

### How was the bug found?

Spec review of the original feature.

### Test documentation updated?

No.</Description>
    <CreatedDate>06/12/2017</CreatedDate>
    <ClosedDate>08/12/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>23043</IssueID>
        <Title>UseNullPropagation codefix doesn't recognize `x is null ? null : x.y` pattern</Title>
        <Description>Also, `ReferenceEquals(foo, null) ? null : foo.y`

```C#
        [Fact, Trait(Traits.Feature, Traits.Features.CodeActionsUseNullPropagation)]
        public async Task TestWithNullableTypeAndIsNull()
        {
            await TestInRegularAndScriptAsync(
@"
class C
{
    public int? f;
    void M(C c)
    {
        int? x = [||]c is null ? null : c.f;
    }
}",
@"
class C
{
    public int? f;
    void M(C c)
    {
        int? x = c?.f;
    }
}");
        }
```</Description>
        <CreatedDate>07/11/2017</CreatedDate>
        <ClosedDate>08/12/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23043</IssueID>
        <Title>UseNullPropagation codefix doesn't recognize `x is null ? null : x.y` pattern</Title>
        <Description>Also, `ReferenceEquals(foo, null) ? null : foo.y`

```C#
        [Fact, Trait(Traits.Feature, Traits.Features.CodeActionsUseNullPropagation)]
        public async Task TestWithNullableTypeAndIsNull()
        {
            await TestInRegularAndScriptAsync(
@"
class C
{
    public int? f;
    void M(C c)
    {
        int? x = [||]c is null ? null : c.f;
    }
}",
@"
class C
{
    public int? f;
    void M(C c)
    {
        int? x = c?.f;
    }
}");
        }
```</Description>
        <CreatedDate>07/11/2017</CreatedDate>
        <ClosedDate>08/12/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/UseNullPropagation/UseNullPropagationTests.cs</File>
      <File>src/Features/CSharp/Portable/UseNullPropagation/CSharpUseNullPropagationDiagnosticAnalyzer.cs</File>
      <File>src/Features/Core/Portable/UseNullPropagation/AbstractUseNullPropagationCodeFixProvider.cs</File>
      <File>src/Features/Core/Portable/UseNullPropagation/AbstractUseNullPropagationDiagnosticAnalyzer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23570</IssueID>
    <Title>Disallow use of 'out var' in __arglist.</Title>
    <Description>Fixes #23378.
Also, preserve and adjust arguments passed to 'new T'.

### Customer scenario

Type the following C# code ```__arglist(out var x)``` and observe a crash in a compiler.

### Bugs this fixes

#23378.

### Workarounds, if any

Do not use 'out var' as an argument for __arglist.

### Risk

Low

### Performance impact

Low perf impact because no extra allocations/no complexity changes

### Is this a regression from a previous update?

No

### Root cause analysis

There was a test gap. Added unit-tests.

### How was the bug found?

Customer reported 

### Test documentation updated?

N/A</Description>
    <CreatedDate>05/12/2017</CreatedDate>
    <ClosedDate>05/12/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>23378</IssueID>
        <Title>Using __arglist with `out var` causes Visual Studio to crash</Title>
        <Description>**Version Used**: 15.4.4 and 15.5.0 Preview 4

**Steps to Reproduce**:

1. Create a new console application targeting .NET Framework v4.7.1
2. Replace the entire contents of `Program.cs` with the following:
```cs
namespace ArgListOutVar
{
    public class Program
    {
        public static void Main(string[] args)
        {
            // __arglist(out var x);
            __arglist(out int y);
        }
    }
}
```
3. Remove a single `/` from line 7.

**Expected Behavior**: Visual Studio should not crash.

**Actual Behavior**: Visual Studio crashes. Below is the stack trace from debugging an instance of VS while reproducing this issue.

&lt;details&gt;
&lt;summary&gt;Exception Details&lt;/summary&gt;

```
System.InvalidOperationException
  HResult=0x80131509
  Message=This program location is thought to be unreachable.
  Source=Microsoft.CodeAnalysis.CSharp
  StackTrace:
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitOutVariablePendingInference(OutVariablePendingInference node)
   at Microsoft.CodeAnalysis.CSharp.OutVariablePendingInference.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitConversion(BoundConversion node)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.VisitConversion(BoundConversion node)
   at Microsoft.CodeAnalysis.CSharp.BoundConversion.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitLvalue(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitArguments(ImmutableArray`1 arguments, ImmutableArray`1 refKindsOpt, MethodSymbol method)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitArgListOperator(BoundArgListOperator node)
   at Microsoft.CodeAnalysis.CSharp.BoundArgListOperator.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitBadExpression(BoundBadExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundBadExpression.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitBinaryOperatorChildren(BoundBinaryOperator node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitBinaryOperator(BoundBinaryOperator node)
   at Microsoft.CodeAnalysis.CSharp.BoundBinaryOperator.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitExpressionStatement(BoundExpressionStatement node)
   at Microsoft.CodeAnalysis.CSharp.BoundExpressionStatement.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitStatement(BoundStatement statement)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.VisitStatementsWithLocalFunctions(BoundBlock block)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.VisitBlock(BoundBlock node)
   at Microsoft.CodeAnalysis.CSharp.BoundBlock.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Scan(Boolean&amp; badRegion)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.Scan(Boolean&amp; badRegion)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Analyze(Boolean&amp; badRegion)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.Analyze(Boolean&amp; badRegion, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.Analyze(CSharpCompilation compilation, Symbol member, BoundNode node, DiagnosticBag diagnostics, Boolean requireOutParamsAssigned)
   at Microsoft.CodeAnalysis.CSharp.FlowAnalysisPass.Rewrite(MethodSymbol method, BoundBlock block, DiagnosticBag diagnostics, Boolean hasTrailingExpression, Boolean originalBodyNested)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethod(MethodSymbol methodSymbol, Int32 methodOrdinal, ProcessedFieldInitializers&amp; processedInitializers, SynthesizedSubmissionFields previousSubmissionFields, TypeCompilationState compilationState)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(NamedTypeSymbol containingType)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.VisitNamedType(NamedTypeSymbol symbol, TypeCompilationState arg)
   at Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.Accept[TArgument,TResult](CSharpSymbolVisitor`2 visitor, TArgument argument)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamespace(NamespaceSymbol symbol)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.VisitNamespace(NamespaceSymbol symbol, TypeCompilationState arg)
   at Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol.Accept[TArgument,TResult](CSharpSymbolVisitor`2 visitor, TArgument argument)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamespace(NamespaceSymbol symbol)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethodBodies(CSharpCompilation compilation, PEModuleBuilder moduleBeingBuiltOpt, Boolean emittingPdb, Boolean emitTestCoverageData, Boolean hasDeclarationErrors, DiagnosticBag diagnostics, Predicate`1 filterOpt, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnosticsForMethodBodiesInTree(SyntaxTree tree, Nullable`1 span, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnosticsForSyntaxTree(CompilationStage stage, SyntaxTree syntaxTree, Nullable`1 filterSpanWithinTree, Boolean includeEarlierStages, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDiagnostics(Nullable`1 span, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.GenerateCompilationEvents(AnalysisScope analysisScope, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.&lt;GenerateCompilationEventsAndPopulateEventsCacheAsync&gt;d__58.MoveNext()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
```

&lt;/details&gt;
</Description>
        <CreatedDate>26/11/2017</CreatedDate>
        <ClosedDate>05/12/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23378</IssueID>
        <Title>Using __arglist with `out var` causes Visual Studio to crash</Title>
        <Description>**Version Used**: 15.4.4 and 15.5.0 Preview 4

**Steps to Reproduce**:

1. Create a new console application targeting .NET Framework v4.7.1
2. Replace the entire contents of `Program.cs` with the following:
```cs
namespace ArgListOutVar
{
    public class Program
    {
        public static void Main(string[] args)
        {
            // __arglist(out var x);
            __arglist(out int y);
        }
    }
}
```
3. Remove a single `/` from line 7.

**Expected Behavior**: Visual Studio should not crash.

**Actual Behavior**: Visual Studio crashes. Below is the stack trace from debugging an instance of VS while reproducing this issue.

&lt;details&gt;
&lt;summary&gt;Exception Details&lt;/summary&gt;

```
System.InvalidOperationException
  HResult=0x80131509
  Message=This program location is thought to be unreachable.
  Source=Microsoft.CodeAnalysis.CSharp
  StackTrace:
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitOutVariablePendingInference(OutVariablePendingInference node)
   at Microsoft.CodeAnalysis.CSharp.OutVariablePendingInference.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitConversion(BoundConversion node)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.VisitConversion(BoundConversion node)
   at Microsoft.CodeAnalysis.CSharp.BoundConversion.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitLvalue(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitArguments(ImmutableArray`1 arguments, ImmutableArray`1 refKindsOpt, MethodSymbol method)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitArgListOperator(BoundArgListOperator node)
   at Microsoft.CodeAnalysis.CSharp.BoundArgListOperator.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitBadExpression(BoundBadExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundBadExpression.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitBinaryOperatorChildren(BoundBinaryOperator node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitBinaryOperator(BoundBinaryOperator node)
   at Microsoft.CodeAnalysis.CSharp.BoundBinaryOperator.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitExpressionStatement(BoundExpressionStatement node)
   at Microsoft.CodeAnalysis.CSharp.BoundExpressionStatement.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitStatement(BoundStatement statement)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.VisitStatementsWithLocalFunctions(BoundBlock block)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.VisitBlock(BoundBlock node)
   at Microsoft.CodeAnalysis.CSharp.BoundBlock.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Scan(Boolean&amp; badRegion)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.Scan(Boolean&amp; badRegion)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Analyze(Boolean&amp; badRegion)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.Analyze(Boolean&amp; badRegion, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.Analyze(CSharpCompilation compilation, Symbol member, BoundNode node, DiagnosticBag diagnostics, Boolean requireOutParamsAssigned)
   at Microsoft.CodeAnalysis.CSharp.FlowAnalysisPass.Rewrite(MethodSymbol method, BoundBlock block, DiagnosticBag diagnostics, Boolean hasTrailingExpression, Boolean originalBodyNested)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethod(MethodSymbol methodSymbol, Int32 methodOrdinal, ProcessedFieldInitializers&amp; processedInitializers, SynthesizedSubmissionFields previousSubmissionFields, TypeCompilationState compilationState)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(NamedTypeSymbol containingType)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.VisitNamedType(NamedTypeSymbol symbol, TypeCompilationState arg)
   at Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.Accept[TArgument,TResult](CSharpSymbolVisitor`2 visitor, TArgument argument)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamespace(NamespaceSymbol symbol)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.VisitNamespace(NamespaceSymbol symbol, TypeCompilationState arg)
   at Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol.Accept[TArgument,TResult](CSharpSymbolVisitor`2 visitor, TArgument argument)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamespace(NamespaceSymbol symbol)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethodBodies(CSharpCompilation compilation, PEModuleBuilder moduleBeingBuiltOpt, Boolean emittingPdb, Boolean emitTestCoverageData, Boolean hasDeclarationErrors, DiagnosticBag diagnostics, Predicate`1 filterOpt, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnosticsForMethodBodiesInTree(SyntaxTree tree, Nullable`1 span, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnosticsForSyntaxTree(CompilationStage stage, SyntaxTree syntaxTree, Nullable`1 filterSpanWithinTree, Boolean includeEarlierStages, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDiagnostics(Nullable`1 span, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.GenerateCompilationEvents(AnalysisScope analysisScope, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.&lt;GenerateCompilationEventsAndPopulateEventsCacheAsync&gt;d__58.MoveNext()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
```

&lt;/details&gt;
</Description>
        <CreatedDate>26/11/2017</CreatedDate>
        <ClosedDate>05/12/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Expressions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Invocation.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IConversionExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/ObjectAndCollectionInitializerTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/OutVarTests.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/OperationTreeVerifier.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23505</IssueID>
    <Title>Reduce the number of attributes that should be bound in order to determine if there are NoPia local types explicitly defined in code.</Title>
    <Description>Fixes #23179.

### Customer scenario

Today compilers bind all attributes on all top level types in order to determine if there are NoPia local types explicitly defined in code. This information is necessary every time a project to project reference is created. NoPia local types explicitly defined in code are extremely uncommon, but attributes binding can be expensive if there are a lot of them. We have a customer that apparently experiences IDE performance and/or reliability problems because of that.

### Bugs this fixes

#23179

### Workarounds, if any

None

### Risk

Low

### Performance impact

Low perf impact because in a common scenario we will be doing less work than before.

### Is this a regression from a previous update?

No

### Root cause analysis

Unit-tests added.

### How was the bug found?

Customer reported

### Test documentation updated?

N/A</Description>
    <CreatedDate>30/11/2017</CreatedDate>
    <ClosedDate>07/12/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>23179</IssueID>
        <Title>SourceModuleSymbol.ContainsExplicitDefinitionOfNoPiaLocalTypes forces expensive binding</Title>
        <Description>`SourceModuleSymbol.ContainsExplicitDefinitionOfNoPiaLocalTypes` forces all attributes to be bound, resulting in extreme performance and/or reliability problems when using the IDE.

https://github.com/dotnet/roslyn/blob/a604cefecd2cba10803a872c580cfb7a9e0883ad/src/Compilers/CSharp/Portable/Symbols/Source/SourceModuleSymbol.cs#L146-L150

🔗 [Slowdown and then crash](https://developercommunity.visualstudio.com/content/problem/136307/slowdown-and-then-crash.html) ([Internal feedback ticket](https://devdiv.visualstudio.com/DevDiv/_workitems/edit/513336))
:link: [Slowdown and Crash #3](https://developercommunity.visualstudio.com/content/problem/136317/slowdown-and-crash-3.html) ([Internal feedback ticket](https://devdiv.visualstudio.com/DevDiv/_workitems/edit/513345))</Description>
        <CreatedDate>15/11/2017</CreatedDate>
        <ClosedDate>07/12/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23179</IssueID>
        <Title>SourceModuleSymbol.ContainsExplicitDefinitionOfNoPiaLocalTypes forces expensive binding</Title>
        <Description>`SourceModuleSymbol.ContainsExplicitDefinitionOfNoPiaLocalTypes` forces all attributes to be bound, resulting in extreme performance and/or reliability problems when using the IDE.

https://github.com/dotnet/roslyn/blob/a604cefecd2cba10803a872c580cfb7a9e0883ad/src/Compilers/CSharp/Portable/Symbols/Source/SourceModuleSymbol.cs#L146-L150

🔗 [Slowdown and then crash](https://developercommunity.visualstudio.com/content/problem/136307/slowdown-and-then-crash.html) ([Internal feedback ticket](https://devdiv.visualstudio.com/DevDiv/_workitems/edit/513336))
:link: [Slowdown and Crash #3](https://developercommunity.visualstudio.com/content/problem/136317/slowdown-and-crash-3.html) ([Internal feedback ticket](https://devdiv.visualstudio.com/DevDiv/_workitems/edit/513345))</Description>
        <CreatedDate>15/11/2017</CreatedDate>
        <ClosedDate>07/12/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/BuckStopsHereBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/InContainerBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/QuickTypeIdentifierAttributeChecker.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceModuleSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceNamedTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/TypeTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23491</IssueID>
    <Title>Avoid allocations in IsDefinedInSourceTree hot paths</Title>
    <Description>Fixes #23462

:memo: This is an alternate approach to the one seen in #23490. This approach has more code duplication, but further reduces memory usage and can't increase memory footprint due to caching.

### Customer scenario

Running analyzer during a build is slower than it should be, with the analyzer driver contributing substantial overhead even when the analyzers themselves are lightweight.

### Bugs this fixes

Fixes #23462

### Workarounds, if any

None needed

### Risk

This poses a small maintainability risk by duplicating an existing algorithm into a new form for the sole benefit of reducing allocations. The risk is partially mitigated by comment(s) in the source code, and justified by AnalyzerRunner indicating the code lies on a particularly hot path.

### Performance impact

6% reduction in allocations for running IDE analyzers.

### Is this a regression from a previous update?

No.

### Root cause analysis

AnalyzerRunner is a new tool for helping us test analyzer performance in isolation.

### How was the bug found?

AnalyzerRunner.

### Test documentation updated?

No.

</Description>
    <CreatedDate>30/11/2017</CreatedDate>
    <ClosedDate>01/12/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>23462</IssueID>
        <Title>Optimize allocations in IsDefinedInSourceTree hot paths</Title>
        <Description>AnalyzerRunner is showing a few allocation hot paths in `IsDefinedInSourceTree`. The primary cases are:

* 677MB (3.5%): `Symbol.IsDefinedInSourceTree` &amp;rarr; `SourceMemberContainerTypeSymbol.DeclaringSyntaxReferences` &amp;rarr; `MergedTypeDeclaration.SyntaxReferences`
    * 677MB: `SyntaxReference[]`
* 475MB (2.5%): `SourceNamespaceSymbol.IsDefinedInSourceTree` &amp;rarr; `SourceNamespaceSymbol.DeclaringSyntaxReferences`
    * 372MB: `NamespaceDeclarationSyntaxReference`
    * 103MB: `SyntaxReference[]`</Description>
        <CreatedDate>29/11/2017</CreatedDate>
        <ClosedDate>01/12/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23490</IssueID>
        <Title>Optimize allocations in IsDefinedInSourceTree hot paths </Title>
        <Description>Fix for #23462
This solutions lazy caches the SyntaxReferences array in the same way the [Children](http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Declarations/MergedTypeDeclaration.cs,196) property is cached a few lines down in the same class.

If this is the way to got the same solution can be adopted for the other property (SourceNamespaceSymbol.DeclaringSyntaxReferences) mentioned in the issue.

No additional tests are provided. See performance impact below for details on how I measured the impact of the change.

### Customer scenario

Avoid array allocations in hot path.

### Bugs this fixes

#23462

### Workarounds, if any

No.

### Risk

This solution avoids allocations by caching SyntaxReferences. The cache may increase memory usage. The cached array should be small (❓  0 to 1 references are the common case. More references are only stored for partial definitions).

### Performance impact

The performance impact was measured on solution load of a console app with only Program.cs and 100 lines of code (VS start -&gt; Load Solution -&gt; Wait a minute for warmup).
Before:
1.300 allocating calls of the now removed line
`return _declarations.SelectAsArray(r =&gt; r.SyntaxReference);` 
After:
2 allocating calls
```
    if (_lazySyntaxReferences.IsDefault) 
    {
        // Number of calls measured on next line
        ImmutableInterlocked.InterlockedInitialize(ref _lazySyntaxReferences, _declarations.SelectAsArray(r =&gt; r.SyntaxReference)); 
    } 
    return _lazySyntaxReferences; 
```

### Is this a regression from a previous update?

I don't know.

### Root cause analysis

I don't know.

### How was the bug found?

via Watson and AnalyzerWatcher. See #23462 and ask @sharwell for details.

### Test documentation updated?
</Description>
        <CreatedDate>30/11/2017</CreatedDate>
        <ClosedDate>01/12/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23462</IssueID>
        <Title>Optimize allocations in IsDefinedInSourceTree hot paths</Title>
        <Description>AnalyzerRunner is showing a few allocation hot paths in `IsDefinedInSourceTree`. The primary cases are:

* 677MB (3.5%): `Symbol.IsDefinedInSourceTree` &amp;rarr; `SourceMemberContainerTypeSymbol.DeclaringSyntaxReferences` &amp;rarr; `MergedTypeDeclaration.SyntaxReferences`
    * 677MB: `SyntaxReference[]`
* 475MB (2.5%): `SourceNamespaceSymbol.IsDefinedInSourceTree` &amp;rarr; `SourceNamespaceSymbol.DeclaringSyntaxReferences`
    * 372MB: `NamespaceDeclarationSyntaxReference`
    * 103MB: `SyntaxReference[]`</Description>
        <CreatedDate>29/11/2017</CreatedDate>
        <ClosedDate>01/12/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceMemberContainerSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceNamespaceSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/NamespaceDeclarationSyntaxReference.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23458</IssueID>
    <Title>Perform a lightweight syntax check before getting document options</Title>
    <Description>### Customer scenario

A user has the Validate String Format analyzer enabled, and it uses more CPU than it needs to.

### Bugs this fixes

N/A

### Workarounds, if any

None needed.

### Risk

Low. The analysis conditions are not changed, but are simply reordered so a check that generally fails quickly executes before one that takes longer to complete.

### Performance impact

Improves performance. Times are in milliseconds running the analyzers on OrchardCMS/Orchard@941c6912ae2eaba60896758cc60f1dc54c142be4, and the compiler at 2b39919ba6eebb6b22524db11a537fe247ee8a79+#23087+#23457.

|  | Options first | Syntax first (this PR) |
| --- | --- | --- |
| **Non-concurrent** | 1262 | 1000 |
| **Concurrent** (#23423) | 1262 | 775 |

### Is this a regression from a previous update?

No.

### Root cause analysis

AnalyzerRunner was not available previously.

### How was the bug found?

AnalyzerRunner.

### Test documentation updated?

No.</Description>
    <CreatedDate>29/11/2017</CreatedDate>
    <ClosedDate>07/12/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>23087</IssueID>
        <Title>Analyzer Runner tool</Title>
        <Description>This is a draft version of the analyzer runner tool which should be used for execution analyzers against a given solution and measuring their performance.

The code is based on [StyleCopAnalyzers](https://github.com/DotNetAnalyzers/StyleCopAnalyzers/)

Closes #23104</Description>
        <CreatedDate>09/11/2017</CreatedDate>
        <ClosedDate>19/05/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23457</IssueID>
        <Title>Avoid skewing analysis time when logging analyzer times</Title>
        <Description>### Customer scenario

A user attempts to run analyzers through the Roslyn API for performance testing. The measured performance overhead is significantly greater than the observed overhead for the analyzer in other cases.

### Bugs this fixes

N/A

### Workarounds, if any

None

### Risk

Low. The code was only intended to add stability to analyzer performance testing. After running the code through AnalyzerRunner, measurements indicated that the approach caused substantial performance overhead which obscured the true performance of the analyzers. The issue was most apparent during document edit testing (#23104).

### Performance impact

For applications like Visual Studio, no change in performance. For some applications using the Roslyn API, e.g. AnalyzerRunner, performance is either unchanged or improved.

### Is this a regression from a previous update?

No.

### Root cause analysis

Analyzer performance was only tested in limited scenarios previously.

### How was the bug found?

AnalyzerRunner

### Test documentation updated?

No.</Description>
        <CreatedDate>29/11/2017</CreatedDate>
        <ClosedDate>06/01/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23423</IssueID>
        <Title>Enable concurrent execution for all built-in C# analyzers</Title>
        <Description>Eliminates a large amount of unnecessary performance overhead due to serializing analyzers when running in the OOP host.

### Customer scenario

A user attempts to use a Fix All operation, and the initial analysis phase to find all diagnostics to fix is very slow. Alternately, a user turns on Full Solution Analysis, and the time taken to run the analyzers is very slow.

### Bugs this fixes

N/A

### Workarounds, if any

* Wait longer
* Leave Full Solution Analysis disabled

### Risk

Low:

1. All of our analyzers were designed to be stateless so concurrent analysis *could* be enabled.
2. The primary performance concern - overwhelming devenv.exe with analysis operations - is not likely to result in problems because the in-process analyzer driver never uses multiple threads.

### Performance impact

Improves performance by reducing monitor contention. The difference is most apparent on analyzers that are register callbacks for a large number of syntax nodes, but have an early return fast path that applies to the majority of cases. The performance improvement was measured at up to 30% for some lightweight analyzers.

Note that for some analysis situations, performance is not improved by this change in isolation. This tends to impact cases where large numbers of analyzers are used in a manner that causes substantial GC overhead. Profiling indicates that these are "downstream" issues and I would not consider them a contraindication for this change.

### Is this a regression from a previous update?

No.

### Root cause analysis

* No performance testing of analyzers at scale.
* No unit tests to ensure analyzers are registered as concurrent.

### How was the bug found?

Found with AnalyzerRunner, verified with profiling.

### Test documentation updated?

N/A
</Description>
        <CreatedDate>28/11/2017</CreatedDate>
        <ClosedDate>29/11/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/Core/Portable/InternalUtilities/PerformanceSensitiveAttribute.cs</File>
      <File>src/Features/Core/Portable/ValidateFormatString/AbstractValidateFormatStringDiagnosticAnalyzer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23438</IssueID>
    <Title>Several small bug fixes related to readonly references.</Title>
    <Description>Fixes some bugs related to readonly references.

Fixes:#23422
Null-conditional operators should not be allowed with members that return restricted or ref-like types.
Similarly to unconstrained generics or pointers - these types cannot be used to form nullables.
Allowing such types result in crashes at run time or even at compile time, depending on scenario.

Fixes:#23338
Consider special members of `Nullable&lt;T&gt;` nonmutating. 
Example: Not doing defensive copies when invoking `GetValueOrDefault` on readonly variables.
Related to: https://github.com/dotnet/corefx/issues/24900

Fixes:#23166
Removes unused parameters in CheckFieldRefEscape and CheckEventRefEscape


### Customer scenario

- Customer uses null conditional operator `obj?.Member()` where `Member()` returns stack-only type such as `Span&lt;T&gt;` or `TypedReference`. The code should result in compiler error since it would lead to `Nullable&lt;Span&lt;T&gt;&gt;` or `Nullable&lt;TypedReference&gt;` and that is disallowed by JIT/CLR. 
Instead C# compiler crashes and VB compiler successfully compiles IL that fails to JIT.

- Customer uses code that performs some lifted operations with  `readonly` variable (like a field) that has `Nullable` type. 
In such scenario compiler frequently emits calls to special methods on `Nullable` such as `GetValueOrDefault`. The codegen of such calls is suboptimial. The calls are performed on copies, because compiler conservatively treat these helpers as potentially mutating the value.
We know for sure that these members are not mutating. That is required for their correctness and for soundness of `Nullable` operations. We do not need defensive copies.

- there are couple of redundant parameters found by an  "unused parameters" analyzer. 

### Bugs this fixes

Fixes:#23422
Fixes:#23338
Fixes:#23166

### Workarounds, if any

User must be careful to not use `?.` with stack-only types. 
No workaround for extra nullable copy.

### Risk

Very low. We are just adding some simple conditions to already existing functionality.

### Performance impact

Very low for the same reason.

### Is this a regression from a previous update?

No.

### Root cause analysis

The "?." crashing bug is actually fairly old. Now easier to expose with ref-like types such as `Span`

### How was the bug found?

Reported by external customers.

### Test documentation updated?

N/A</Description>
    <CreatedDate>28/11/2017</CreatedDate>
    <ClosedDate>05/12/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>23422</IssueID>
        <Title>Unexpected value 'NullCoalescingOperator expression of System.Span&lt;byte&gt; type' of type 'System.String'</Title>
        <Description>**Version Used**: 
![image](https://user-images.githubusercontent.com/95136/33313758-71ffab54-d3e0-11e7-916d-b428514f369a.png)

**Steps to Reproduce**:

```C#
public class Foo
{
   public Span&lt;byte&gt; Span =&gt; Span&lt;byte&gt;.Empty;
}

public void Method()
{
   Foo foo = null;
   var span = foo?.Span ?? Span&lt;byte&gt;.Empty;
}

```

**Expected Behavior**:
No Crash

**Actual Behavior**:
Crash

```
Log Name:      Application
Source:        .NET Runtime
Date:          11/28/2017 2:01:22 AM
Event ID:      1025
Task Category: None
Level:         Error
Keywords:      Classic
User:          N/A
Description:
Application: devenv.exe
Framework Version: v4.0.30319
Description: The application requested process termination through System.Environment.FailFast(string message).
Message: System.InvalidOperationException: Unexpected value 'NullCoalescingOperator expression of System.Span&lt;byte&gt; type' of type 'System.String'
   at Microsoft.CodeAnalysis.CSharp.Binder.GetValEscape(BoundExpression expr, UInt32 scopeOfTheContainingExpression)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindVariableDeclaration(SourceLocalSymbol localSymbol, LocalDeclarationKind kind, Boolean isVar, VariableDeclaratorSyntax declarator, TypeSyntax typeSyntax, TypeSymbol declTypeOpt, AliasSymbol aliasOpt, DiagnosticBag diagnostics, CSharpSyntaxNode associatedSyntaxNode)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindDeclarationStatementParts(LocalDeclarationStatementSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.IncrementalBinder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLowerBoundNode(CSharpSyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node, CSharpSyntaxNode&amp; bindableNode, BoundNode&amp; lowestBoundNode, BoundNode&amp; highestBoundNode, BoundNode&amp; boundParent)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetSymbolInfoWorker(CSharpSyntaxNode node, SymbolInfoOptions options, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(ExpressionSyntax expression, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.ClassifyTypeSyntax(NameSyntax name, SemanticModel semanticModel, ArrayBuilder`1 result, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.AddClassifications(SyntaxNode syntax, SemanticModel semanticModel, ArrayBuilder`1 result, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.Worker.ClassifyNode(SyntaxNode syntax)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.Worker.ProcessNodes()
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.Worker.Classify(Workspace workspace, SemanticModel semanticModel, TextSpan textSpan, ArrayBuilder`1 list, Func`2 getNodeClassifiers, Func`2 getTokenClassifiers, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.&lt;AddSemanticClassificationsAsync&gt;d__5.MoveNext()
Stack:
   at System.Environment.FailFast(System.String, System.Exception)
   at Microsoft.CodeAnalysis.FailFast.OnFatalException(System.Exception)
   at Microsoft.CodeAnalysis.ErrorReporting.FatalError.Report(System.Exception, System.Action`1&lt;System.Exception&gt;)
   at Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportUnlessCanceled(System.Exception)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__5.MoveNext()
   at Microsoft.CodeAnalysis.CSharp.Binder.GetValEscape(Microsoft.CodeAnalysis.CSharp.BoundExpression, UInt32)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindVariableDeclaration(Microsoft.CodeAnalysis.CSharp.Symbols.SourceLocalSymbol, Microsoft.CodeAnalysis.CSharp.Symbols.LocalDeclarationKind, Boolean, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax, Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, Microsoft.CodeAnalysis.CSharp.Symbols.AliasSymbol, Microsoft.CodeAnalysis.DiagnosticBag, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindDeclarationStatementParts(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel+IncrementalBinder.BindStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Bind(Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.Bind(Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLowerBoundNode(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetSymbolInfoWorker(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, SymbolInfoOptions, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.ClassifyTypeSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax, Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.AddClassifications(Microsoft.CodeAnalysis.SyntaxNode, Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+Worker.ClassifyNode(Microsoft.CodeAnalysis.SyntaxNode)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+Worker.ProcessNodes()
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+Worker.Classify(Microsoft.CodeAnalysis.Workspace, Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.Text.TextSpan, Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__5.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__5, Microsoft.CodeAnalysis.Workspaces, Version=2.6.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;AddSemanticClassificationsAsync&gt;d__5 ByRef)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Document, Microsoft.CodeAnalysis.Text.TextSpan, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__2.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Classification.AbstractClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__2, Microsoft.CodeAnalysis.Workspaces, Version=2.6.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;AddSemanticClassificationsAsync&gt;d__2 ByRef)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Document, Microsoft.CodeAnalysis.Text.TextSpan, System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.WorkspaceClassificationDelegationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Classification.IClassificationService, Microsoft.CodeAnalysis.Document, Microsoft.CodeAnalysis.Text.TextSpan, System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ClassifySpansAsync&gt;d__2`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ClassifySpansAsync&gt;d__2`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Microsoft.CodeAnalysis.EditorFeatures, Version=2.6.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;ClassifySpansAsync&gt;d__2`1&lt;System.__Canon&gt; ByRef)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.ClassifySpansAsync[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IClassificationDelegationService`1&lt;System.__Canon&gt;, System.__Canon, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;TryClassifyContainingMemberSpan&gt;d__1`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].Start[[Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;TryClassifyContainingMemberSpan&gt;d__1`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Microsoft.CodeAnalysis.EditorFeatures, Version=2.6.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;TryClassifyContainingMemberSpan&gt;d__1`1&lt;System.__Canon&gt; ByRef)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.TryClassifyContainingMemberSpan[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IClassificationDelegationService`1&lt;System.__Canon&gt;, System.__Canon, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ProduceTagsAsync&gt;d__0`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ProduceTagsAsync&gt;d__0`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Microsoft.CodeAnalysis.EditorFeatures, Version=2.6.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;ProduceTagsAsync&gt;d__0`1&lt;System.__Canon&gt; ByRef)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.ProduceTagsAsync[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IClassificationDelegationService`1&lt;System.__Canon&gt;, System.__Canon, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationViewTaggerProvider.ProduceTagsAsync[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IClassificationDelegationService`1&lt;System.__Canon&gt;)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationViewTaggerProvider.ProduceTagsAsync(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;)
   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].ProduceTagsAsync(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;System.__Canon&gt;)
   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource+&lt;RecomputeTagsAsync&gt;d__73[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource+&lt;RecomputeTagsAsync&gt;d__73[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Microsoft.CodeAnalysis.EditorFeatures, Version=2.6.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;RecomputeTagsAsync&gt;d__73&lt;System.__Canon&gt; ByRef)
   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].RecomputeTagsAsync(System.Object, System.Nullable`1&lt;Microsoft.VisualStudio.Text.SnapshotPoint&gt;, System.Nullable`1&lt;Microsoft.CodeAnalysis.Text.TextChangeRange&gt;, System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan&gt;, System.Collections.Immutable.ImmutableDictionary`2&lt;Microsoft.VisualStudio.Text.ITextBuffer,Microsoft.CodeAnalysis.Editor.Shared.Tagging.TagSpanIntervalTree`1&lt;System.__Canon&gt;&gt;, Boolean, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource+&lt;&gt;c__DisplayClass63_0[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].&lt;RecomputeTagsForeground&gt;b__0(System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.Shared.Threading.AsynchronousSerialWorkQueue+&lt;&gt;c__DisplayClass11_0.&lt;EnqueueBackgroundTask&gt;b__0(System.Threading.Tasks.Task)
   at System.Threading.Tasks.ContinuationResultTaskFromTask`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].InnerInvoke()
   at System.Threading.Tasks.Task.Execute()
   at System.Threading.Tasks.Task.ExecutionContextCallback(System.Object)
   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)
   at System.Threading.Tasks.Task.ExecuteEntry(Boolean)
   at System.Threading.Tasks.Task.System.Threading.IThreadPoolWorkItem.ExecuteWorkItem()
   at System.Threading.ThreadPoolWorkQueue.Dispatch()
   at System.Threading._ThreadPoolWaitCallback.PerformWaitCallback()
```

/cc @VSadov </Description>
        <CreatedDate>28/11/2017</CreatedDate>
        <ClosedDate>05/12/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23338</IssueID>
        <Title>Unnecessary defensive copy of an `in` parameter is created, whose type is nullable readonly struct</Title>
        <Description>**Version Used**: 

Version 15.5.0 Preview 4.0
VisualStudio.15.Preview/15.5.0-pre.4.0+27110.0

Visual C# 2017 00369-60000-00001-AA127
Microsoft Visual C# 2017

C# 7.2

**Steps to Reproduce**:

Compile and inspect IL:
```
using System;

readonly struct S
{
    readonly decimal d;

    public S(decimal d)
    {
        this.d = d;
    }
}

class P
{
    static void Foo(in S? x)
    {
        Console.WriteLine(x.GetValueOrDefault());
    }
    
    static void Main()
    {
        S? y = new S(5m);
        Foo(y);
    }
}
```
**Actual Behavior**:
The `in` parameter `x` in the method  `Foo` is copied to a compiler-generated local before `GetValueOrDefault()` is invoked.

**Expected Behavior**:
This copy is unnecessary and should be elided. No method or property of a nullable value type can mutate it if the underlying type is a readonly struct.</Description>
        <CreatedDate>21/11/2017</CreatedDate>
        <ClosedDate>05/12/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23166</IssueID>
        <Title>Unused parameter in Microsoft.CodeAnalysis.CSharp.Binder.CheckFieldRefEscape (potential bug?)</Title>
        <Description>Enabling CA1801 (unused parameter rule) fires it for [CheckFieldRefEscape](http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Binder/Binder.ValueChecks.cs,a204c04b97fd2e6c) and [CheckFieldLikeEventRefEscape](http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Binder/Binder.ValueChecks.cs,09e0b3ce0e53064a) for parameter `checkingReceiver` being unused. We should either use this parameter or remove it from the signature.</Description>
        <CreatedDate>14/11/2017</CreatedDate>
        <ClosedDate>05/12/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23422</IssueID>
        <Title>Unexpected value 'NullCoalescingOperator expression of System.Span&lt;byte&gt; type' of type 'System.String'</Title>
        <Description>**Version Used**: 
![image](https://user-images.githubusercontent.com/95136/33313758-71ffab54-d3e0-11e7-916d-b428514f369a.png)

**Steps to Reproduce**:

```C#
public class Foo
{
   public Span&lt;byte&gt; Span =&gt; Span&lt;byte&gt;.Empty;
}

public void Method()
{
   Foo foo = null;
   var span = foo?.Span ?? Span&lt;byte&gt;.Empty;
}

```

**Expected Behavior**:
No Crash

**Actual Behavior**:
Crash

```
Log Name:      Application
Source:        .NET Runtime
Date:          11/28/2017 2:01:22 AM
Event ID:      1025
Task Category: None
Level:         Error
Keywords:      Classic
User:          N/A
Description:
Application: devenv.exe
Framework Version: v4.0.30319
Description: The application requested process termination through System.Environment.FailFast(string message).
Message: System.InvalidOperationException: Unexpected value 'NullCoalescingOperator expression of System.Span&lt;byte&gt; type' of type 'System.String'
   at Microsoft.CodeAnalysis.CSharp.Binder.GetValEscape(BoundExpression expr, UInt32 scopeOfTheContainingExpression)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindVariableDeclaration(SourceLocalSymbol localSymbol, LocalDeclarationKind kind, Boolean isVar, VariableDeclaratorSyntax declarator, TypeSyntax typeSyntax, TypeSymbol declTypeOpt, AliasSymbol aliasOpt, DiagnosticBag diagnostics, CSharpSyntaxNode associatedSyntaxNode)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindDeclarationStatementParts(LocalDeclarationStatementSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.IncrementalBinder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLowerBoundNode(CSharpSyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node, CSharpSyntaxNode&amp; bindableNode, BoundNode&amp; lowestBoundNode, BoundNode&amp; highestBoundNode, BoundNode&amp; boundParent)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetSymbolInfoWorker(CSharpSyntaxNode node, SymbolInfoOptions options, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(ExpressionSyntax expression, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.ClassifyTypeSyntax(NameSyntax name, SemanticModel semanticModel, ArrayBuilder`1 result, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.AddClassifications(SyntaxNode syntax, SemanticModel semanticModel, ArrayBuilder`1 result, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.Worker.ClassifyNode(SyntaxNode syntax)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.Worker.ProcessNodes()
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.Worker.Classify(Workspace workspace, SemanticModel semanticModel, TextSpan textSpan, ArrayBuilder`1 list, Func`2 getNodeClassifiers, Func`2 getTokenClassifiers, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.&lt;AddSemanticClassificationsAsync&gt;d__5.MoveNext()
Stack:
   at System.Environment.FailFast(System.String, System.Exception)
   at Microsoft.CodeAnalysis.FailFast.OnFatalException(System.Exception)
   at Microsoft.CodeAnalysis.ErrorReporting.FatalError.Report(System.Exception, System.Action`1&lt;System.Exception&gt;)
   at Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportUnlessCanceled(System.Exception)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__5.MoveNext()
   at Microsoft.CodeAnalysis.CSharp.Binder.GetValEscape(Microsoft.CodeAnalysis.CSharp.BoundExpression, UInt32)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindVariableDeclaration(Microsoft.CodeAnalysis.CSharp.Symbols.SourceLocalSymbol, Microsoft.CodeAnalysis.CSharp.Symbols.LocalDeclarationKind, Boolean, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax, Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, Microsoft.CodeAnalysis.CSharp.Symbols.AliasSymbol, Microsoft.CodeAnalysis.DiagnosticBag, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindDeclarationStatementParts(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel+IncrementalBinder.BindStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Bind(Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.Bind(Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLowerBoundNode(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetSymbolInfoWorker(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, SymbolInfoOptions, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.ClassifyTypeSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax, Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.AddClassifications(Microsoft.CodeAnalysis.SyntaxNode, Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+Worker.ClassifyNode(Microsoft.CodeAnalysis.SyntaxNode)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+Worker.ProcessNodes()
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+Worker.Classify(Microsoft.CodeAnalysis.Workspace, Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.Text.TextSpan, Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__5.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__5, Microsoft.CodeAnalysis.Workspaces, Version=2.6.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;AddSemanticClassificationsAsync&gt;d__5 ByRef)
   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Document, Microsoft.CodeAnalysis.Text.TextSpan, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__2.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Classification.AbstractClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__2, Microsoft.CodeAnalysis.Workspaces, Version=2.6.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;AddSemanticClassificationsAsync&gt;d__2 ByRef)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Document, Microsoft.CodeAnalysis.Text.TextSpan, System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.WorkspaceClassificationDelegationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Classification.IClassificationService, Microsoft.CodeAnalysis.Document, Microsoft.CodeAnalysis.Text.TextSpan, System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ClassifySpansAsync&gt;d__2`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ClassifySpansAsync&gt;d__2`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Microsoft.CodeAnalysis.EditorFeatures, Version=2.6.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;ClassifySpansAsync&gt;d__2`1&lt;System.__Canon&gt; ByRef)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.ClassifySpansAsync[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IClassificationDelegationService`1&lt;System.__Canon&gt;, System.__Canon, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;TryClassifyContainingMemberSpan&gt;d__1`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].Start[[Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;TryClassifyContainingMemberSpan&gt;d__1`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Microsoft.CodeAnalysis.EditorFeatures, Version=2.6.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;TryClassifyContainingMemberSpan&gt;d__1`1&lt;System.__Canon&gt; ByRef)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.TryClassifyContainingMemberSpan[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IClassificationDelegationService`1&lt;System.__Canon&gt;, System.__Canon, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ProduceTagsAsync&gt;d__0`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ProduceTagsAsync&gt;d__0`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Microsoft.CodeAnalysis.EditorFeatures, Version=2.6.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;ProduceTagsAsync&gt;d__0`1&lt;System.__Canon&gt; ByRef)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.ProduceTagsAsync[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IClassificationDelegationService`1&lt;System.__Canon&gt;, System.__Canon, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationViewTaggerProvider.ProduceTagsAsync[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IClassificationDelegationService`1&lt;System.__Canon&gt;)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationViewTaggerProvider.ProduceTagsAsync(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;)
   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].ProduceTagsAsync(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;System.__Canon&gt;)
   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource+&lt;RecomputeTagsAsync&gt;d__73[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource+&lt;RecomputeTagsAsync&gt;d__73[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Microsoft.CodeAnalysis.EditorFeatures, Version=2.6.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;RecomputeTagsAsync&gt;d__73&lt;System.__Canon&gt; ByRef)
   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].RecomputeTagsAsync(System.Object, System.Nullable`1&lt;Microsoft.VisualStudio.Text.SnapshotPoint&gt;, System.Nullable`1&lt;Microsoft.CodeAnalysis.Text.TextChangeRange&gt;, System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan&gt;, System.Collections.Immutable.ImmutableDictionary`2&lt;Microsoft.VisualStudio.Text.ITextBuffer,Microsoft.CodeAnalysis.Editor.Shared.Tagging.TagSpanIntervalTree`1&lt;System.__Canon&gt;&gt;, Boolean, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource+&lt;&gt;c__DisplayClass63_0[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].&lt;RecomputeTagsForeground&gt;b__0(System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.Shared.Threading.AsynchronousSerialWorkQueue+&lt;&gt;c__DisplayClass11_0.&lt;EnqueueBackgroundTask&gt;b__0(System.Threading.Tasks.Task)
   at System.Threading.Tasks.ContinuationResultTaskFromTask`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].InnerInvoke()
   at System.Threading.Tasks.Task.Execute()
   at System.Threading.Tasks.Task.ExecutionContextCallback(System.Object)
   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)
   at System.Threading.Tasks.Task.ExecuteEntry(Boolean)
   at System.Threading.Tasks.Task.System.Threading.IThreadPoolWorkItem.ExecuteWorkItem()
   at System.Threading.ThreadPoolWorkQueue.Dispatch()
   at System.Threading._ThreadPoolWaitCallback.PerformWaitCallback()
```

/cc @VSadov </Description>
        <CreatedDate>28/11/2017</CreatedDate>
        <ClosedDate>05/12/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23338</IssueID>
        <Title>Unnecessary defensive copy of an `in` parameter is created, whose type is nullable readonly struct</Title>
        <Description>**Version Used**: 

Version 15.5.0 Preview 4.0
VisualStudio.15.Preview/15.5.0-pre.4.0+27110.0

Visual C# 2017 00369-60000-00001-AA127
Microsoft Visual C# 2017

C# 7.2

**Steps to Reproduce**:

Compile and inspect IL:
```
using System;

readonly struct S
{
    readonly decimal d;

    public S(decimal d)
    {
        this.d = d;
    }
}

class P
{
    static void Foo(in S? x)
    {
        Console.WriteLine(x.GetValueOrDefault());
    }
    
    static void Main()
    {
        S? y = new S(5m);
        Foo(y);
    }
}
```
**Actual Behavior**:
The `in` parameter `x` in the method  `Foo` is copied to a compiler-generated local before `GetValueOrDefault()` is invoked.

**Expected Behavior**:
This copy is unnecessary and should be elided. No method or property of a nullable value type can mutate it if the underlying type is a readonly struct.</Description>
        <CreatedDate>21/11/2017</CreatedDate>
        <ClosedDate>05/12/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23166</IssueID>
        <Title>Unused parameter in Microsoft.CodeAnalysis.CSharp.Binder.CheckFieldRefEscape (potential bug?)</Title>
        <Description>Enabling CA1801 (unused parameter rule) fires it for [CheckFieldRefEscape](http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Binder/Binder.ValueChecks.cs,a204c04b97fd2e6c) and [CheckFieldLikeEventRefEscape](http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Binder/Binder.ValueChecks.cs,09e0b3ce0e53064a) for parameter `checkingReceiver` being unused. We should either use this parameter or remove it from the signature.</Description>
        <CreatedDate>14/11/2017</CreatedDate>
        <ClosedDate>05/12/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder.ValueChecks.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Expressions.cs</File>
      <File>src/Compilers/CSharp/Portable/CodeGen/EmitExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenInParametersTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenShortCircuitOperatorTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/NullableTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/SemanticErrorTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23430</IssueID>
    <Title>Go To Disassembly</Title>
    <Description>I was asked by @sharwell to submit this as PR, I took most of the code from https://github.com/dotnet/roslyn/compare/master...rchande:go-to-disassembly and replaced the 2.x version of ICSharpCode.Decompiler with 3.0.0.3367-beta3.

Notes:

a) not sure if the template is needed, please help! ;-)
b) I had to manually add `ICSharpCode.Decompiler.dll` and `Mono.Cecil.dll` to `devenv.exe.config`, despite having added the following attributes to `\src\VisualStudio\Setup\AssemblyRedirects.cs`

```
[assembly: ProvideCodeBase(CodeBase = @"$PackageFolder$\Mono.Cecil.dll")]
[assembly: ProvideCodeBase(CodeBase = @"$PackageFolder$\ICSharpCode.Decompiler.dll")]
```

Could you help me with that?

c) the `Go To Disassembly` command is not implemented yet.

### Customer scenario

A customer uses **Go To Definition** on a symbol defined in metadata, and is taken to a file with stubs instead of the actual implementation.

### Bugs this fixes

Related to #16540
Related to icsharpcode/ILSpy#791

### Workarounds, if any

None.

### Risk

Low. The feature is behind a feature flag and a legal notice. The original code path is used by default during the experimental phase of this feature. The original code path is used if the new feature fails for any reason aside from a stack overflow.

### Performance impact

Non-deterministic, but only pay for play.

### Is this a regression from a previous update?

No.

### Root cause analysis

N/A (new feature)

### How was the bug found?

Customer request

### Test documentation updated?

No (left as a required item for moving this feature from experimental to stable).
</Description>
    <CreatedDate>28/11/2017</CreatedDate>
    <ClosedDate>08/12/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>16540</IssueID>
        <Title>Public API for IMetadataAsSourceService</Title>
        <Description>I have just found [`IMetadataAsSourceService`](http://source.roslyn.io/#Microsoft.CodeAnalysis.Features/MetadataAsSource/IMetadataAsSourceService.cs,efa3025f7d523cd9) interface that enables me to replace default metadata view with decompiled code from ILSpy in about 50LOC - see https://github.com/icsharpcode/ILSpy/pull/791 It is sooo cool :), but the interface is internal so I had to hack it a bit. Would it be possible to make it an official extensibility point?
</Description>
        <CreatedDate>16/01/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>791</IssueID>
        <Title>VS crashes with ArgumentOutOfRangeException: "startIndex cannot be larger than length" for unclosed /* comment in C# source</Title>
        <Description>Ported from TFS WorkItem: **1108049**

---

**Repro Steps:**

Paste this C# code into ETA (or VS):
`/*`

System.ArgumentOutOfRangeException: startIndex cannot be larger than length of string.

&amp;nbsp; at string.Substring(int startIndex)

&amp;nbsp; at M.CA.Editor.CSharp.Outlining.CSharpOutliningHelpers.CreateCommentBannerTextWithPrefix(string text = "", string prefix = "/*")

&amp;nbsp;

The call stack is attached.

See the dump at [\mlangfs1\public\vladres\78c676647ef347a7917a0b954666544a](file://\mlangfs1publicvladres78c676647ef347a7917a0b954666544a)

---

**Revisions:**

1) Created By Vladimir Reshetnikov (1/14/2015 2:23:48 PM)

---

2) Edited By Kevin Pilch-Bisson (1/15/2015 10:26:03 AM)

Leaving in RTM, because it has to be a a file with less than 2 characters after the /*.

---
</Description>
        <CreatedDate>23/02/2015</CreatedDate>
        <ClosedDate>24/02/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/Core/IMetadataAsSourceFileService.cs</File>
      <File>src/EditorFeatures/Core/Implementation/MetadataAsSource/MetadataAsSourceFileService.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Peek/DefinitionPeekableItem.cs</File>
      <File>src/EditorFeatures/Core/Shared/Options/FeatureOnOffOptions.cs</File>
      <File>src/EditorFeatures/Test/MetadataAsSource/AbstractMetadataAsSourceTests.TestContext.cs</File>
      <File>src/VisualStudio/CSharp/Impl/Options/AdvancedOptionPageControl.xaml.cs</File>
      <File>src/VisualStudio/CSharp/Impl/Options/AdvancedOptionPageStrings.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Workspace/VisualStudioSymbolNavigationService.cs</File>
      <File>src/VisualStudio/Core/Def/ServicesVSResources.Designer.cs</File>
      <File>src/VisualStudio/Setup/AssemblyRedirects.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23397</IssueID>
    <Title>Making sure that "in" matches exactly in method group conversions.</Title>
    <Description>It looks like method group conversions apply regular method overload resolution when resolving target method group.
However we know that in such scenario, unlike the regular argument passing, "byval" cannot match "in".

We should reject candidates with in/val mismatches when doing overload resolution for group conversion purposes. Otherwise we may encounter false ambiguity errors or even pick wrong candidates that crash at run time.

Fixes:#23319

### Customer scenario

Customer uses code that converts a method group with `in` parameters to a delegate that uses ordinary byval parameters in the same positions. 
It is expected that C# compiler rejects such assignment ans it is not permitted by CLR. (ref and val parameters are not compatible, during delegate creation).

Because of the bug, code compiles and crashes at run time.

### Bugs this fixes

Fixes:#23319

### Workarounds, if any

Not using the described scenario that results in broken code.

### Risk

Low. 
The change is mostly about propagating "isMethodConversion" further, so that conversion machinery could reject candidates with `in` --&gt; `byval` parameter match when performing resolution for the purpose of method group conversions. 

### Performance impact

Low.

### Is this a regression from a previous update?

No.

### Root cause analysis

Similar rules govern lambda conversions and were implemented and tested. The case with method group conversions goes on a different path (since it needs to do overload resolution form multiple candidates) and thus the scenario was missed.

### How was the bug found?

Reported by external customer.

### Test documentation updated?

N/A</Description>
    <CreatedDate>27/11/2017</CreatedDate>
    <ClosedDate>04/12/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>23319</IssueID>
        <Title>C# compiler allows unsafe conversions from method groups to delegates with mismatching `in` modifier</Title>
        <Description>**Version Used**: 
Version 15.5.0 Preview 4.0
VisualStudio.15.Preview/15.5.0-pre.4.0+27110.0

Visual C# 2017   00369-60000-00001-AA127
Microsoft Visual C# 2017

C# 7.2

**Steps to Reproduce**:

Compile and run:

```
using System;

class Program
{
    static void F(in DateTime x)
    {
        Console.WriteLine(x);
    }

    static void Main()
    {
        Action&lt;DateTime&gt; a = F;
        a(DateTime.MaxValue);
    }
}
```

**Expected Behavior**:
A compile-time error.

**Actual Behavior**:
The program compiles successfully, but fails at runtime:
&gt; Unhandled Exception: System.AccessViolationException: Attempted to read or write protected memory. This is often an indication that other memory is corrupt.
   at Program.F(DateTime&amp; x) in Program.cs:line 7</Description>
        <CreatedDate>21/11/2017</CreatedDate>
        <ClosedDate>04/12/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23319</IssueID>
        <Title>C# compiler allows unsafe conversions from method groups to delegates with mismatching `in` modifier</Title>
        <Description>**Version Used**: 
Version 15.5.0 Preview 4.0
VisualStudio.15.Preview/15.5.0-pre.4.0+27110.0

Visual C# 2017   00369-60000-00001-AA127
Microsoft Visual C# 2017

C# 7.2

**Steps to Reproduce**:

Compile and run:

```
using System;

class Program
{
    static void F(in DateTime x)
    {
        Console.WriteLine(x);
    }

    static void Main()
    {
        Action&lt;DateTime&gt; a = F;
        a(DateTime.MaxValue);
    }
}
```

**Expected Behavior**:
A compile-time error.

**Actual Behavior**:
The program compiles successfully, but fails at runtime:
&gt; Unhandled Exception: System.AccessViolationException: Attempted to read or write protected memory. This is often an indication that other memory is corrupt.
   at Program.F(DateTime&amp; x) in Program.cs:line 7</Description>
        <CreatedDate>21/11/2017</CreatedDate>
        <ClosedDate>04/12/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Conversions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/OverloadResolution/OverloadResolution.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/OverloadResolutionTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23315</IssueID>
    <Title>Handle parentheses in explicit VB delegate creation scenarios.</Title>
    <Description>This updates our implementation to handle cases such as `DirectCast(((Sub() Console.WriteLine())), Action)`. Previously, we would have an Identity conversion as the top node, alternating IParenthesizedOperation and IConversionOperations down the tree, until we got to an explicit IConversion on top of the lambda or addressof. These final nodes shared a syntax node and both were explicit. This removes the alternating IConversionOperations from the tree, so we only have 2 conversion, one at the top and one at the bottom. When we encounter this scenario, we remove the lower conversion from the tree, and use it's characteristics for the upper conversion (which becomes an IDelegateCreationExpression). Fixes #22988, fixes #22879.

Ask Mode Template:
### Customer scenario

When an analyzer runs on VB code that has parenthesis inside an explicit conversion (CType, DirectCast, TryCast), the IOperation tree contains bogus nodes and is incorrect. This scenario can also violate our invariant of no duplicate explicit syntax nodes in some of these scenarios.

### Bugs this fixes

https://github.com/dotnet/roslyn/issues/22988
https://github.com/dotnet/roslyn/issues/22879

### Workarounds, if any

None

### Risk

Minimal. We're slightly modifying the bound nodes that get generated in this scenario, but these were already ignored later in the compiler.

### Performance impact

Minimal. This will add a few functions calls to generating VB IOperation trees involving this specific scenario, but doesn't affect any other scenarios.

### Is this a regression from a previous update?

No, bug in original implementation.

### Root cause analysis

Added a number of new tests around nested delegates to cover this.

### How was the bug found?

Internal testing.</Description>
    <CreatedDate>20/11/2017</CreatedDate>
    <ClosedDate>13/12/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>22988</IssueID>
        <Title>Lambda conversion when argument is parenthesized fails in VB.</Title>
        <Description>```VB.NET
CType((Sub()
       End Sub), Action)
```
Fails with a duplicate explicit syntax node expression. This is because it's not considered a delegate creation conversion, as the operand is a BoundParenthesizedExpression.
</Description>
        <CreatedDate>02/11/2017</CreatedDate>
        <ClosedDate>13/12/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22879</IssueID>
        <Title>Assert about multiple explicit operation nodes with same syntax in VB</Title>
        <Description>I tried to add following VB test as part of https://github.com/dotnet/roslyn/pull/22846 without doing any source changes and I see the following assert fire: `Assert.False(true, $"Duplicate explicit node for syntax ({operation.Syntax.RawKind}): {operation.Syntax.ToString()}");` where both IDelegateCreation and IAnonymousObjectCreation have same syntax

```
        &lt;CompilerTrait(CompilerFeature.IOperation)&gt;
        &lt;Fact&gt;
        Public Sub TestParenthesizedDelegateCreationParent()
            Dim source = &lt;![CDATA[
Class P
    Private Shared Function M1() As Object
        Return CType((Sub() System.Console.WriteLine()), System.Action)'BIND:"CType((Sub() System.Console.WriteLine()), System.Action)"
    End Function
End Class]]&gt;.Value

            Dim expectedOperationTree = &lt;![CDATA[
]]&gt;.Value

            Dim expectedDiagnostics = String.Empty

            VerifyOperationTreeAndDiagnosticsForTest(Of CTypeExpressionSyntax)(source, expectedOperationTree, expectedDiagnostics)
        End Sub
```</Description>
        <CreatedDate>26/10/2017</CreatedDate>
        <ClosedDate>13/12/2017</ClosedDate>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>23484</IssueID>
    <Title>Skip IOperation test GroupBy_Lookup1 until it is investigated</Title>
    <Description>This PR skips a single test that has been failing frequently in code flow from master to other branches. See, for example, 

- https://github.com/dotnet/roslyn/pull/23419
- https://github.com/dotnet/roslyn/pull/23420
- https://github.com/dotnet/roslyn/pull/23454
- https://github.com/dotnet/roslyn/pull/23455

Issue #23483 has been filed to investigate the underlying failure.

### Risk

No product code change.

### Performance impact

No product code change.

### Root cause analysis

#23483 has been filed to analyze the root cause.

### How was the bug found?

Automated testing of integration branches.

### Test documentation updated?

N/A

@dotnet/roslyn-compiler @dotnet/roslyn-infrastructure May I please have a review of this?
</Description>
    <CreatedDate>30/11/2017</CreatedDate>
    <ClosedDate>30/11/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>23483</IssueID>
        <Title>Flaky test Microsoft.CodeAnalysis.VisualBasic.UnitTests.GetExtendedSemanticInfoTests.GroupBy_Lookup1</Title>
        <Description>The test `Microsoft.CodeAnalysis.VisualBasic.UnitTests.GetExtendedSemanticInfoTests.GroupBy_Lookup1` is failing frequently on merges from `master` to other branches. It isn't clear what the failure is (I tried testing the affected branch and did not see the failure).

The test is skipped to unblock the code flow. It needs to be investigated and unskipped.

Here is the output from the failing test:

``` none
Failed

Microsoft.CodeAnalysis.VisualBasic.UnitTests.GetExtendedSemanticInfoTests.GroupBy_Lookup1 (from Roslyn.Compilers.VisualBasic.Semantic.UnitTests)

MESSAGE:
  | Expected and actual were different.\r\nExpected:\r\nITranslatedQueryOperation (OperationKind.TranslatedQuery, Type: ?, IsInvalid) (Syntax: 'From s1 In ... in qi Group')\r\n Expression: \r\n IInvalidOperation (OperationKind.Invalid, Type: ?, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\n Children(4):\r\n IInvalidOperation (OperationKind.Invalid, Type: ?, IsImplicit) (Syntax: 's2 in qi')\r\n Children(3):\r\n ILocalReferenceOperation: qi (OperationKind.LocalReference, Type: QueryAble, IsInvalid) (Syntax: 'qi')\r\n IAnonymousFunctionOperation (Symbol: Function (s1 As System.Int32) As ?) (OperationKind.AnonymousFunction, Type: null, IsImplicit) (Syntax: 'qi')\r\n IBlockOperation (1 statements) (OperationKind.Block, Type: null, IsImplicit) (Syntax: 'qi')\r\n IReturnOperation (OperationKind.Return, Type: null, IsImplicit) (Syntax: 'qi')\r\n ReturnedValue: \r\n ILocalReferenceOperation: qi (OperationKind.LocalReference, Type: QueryAble) (Syntax: 'qi')\r\n IAnonymousFunctionOperation (Symbol: Function (s1 As System.Int32, s2 As System.Int32) As &amp;lt;anonymous type: Key s1 As System.Int32, Key s2 As System.Int32&gt;) (OperationKind.AnonymousFunction, Type: null, IsInvalid, IsImplicit) (Syntax: 'From s1 In qi, s2 in qi')\r\n IBlockOperation (1 statements) (OperationKind.Block, Type: null, IsInvalid, IsImplicit) (Syntax: 'From s1 In qi, s2 in qi')\r\n IReturnOperation (OperationKind.Return, Type: null, IsInvalid, IsImplicit) (Syntax: 'From s1 In qi, s2 in qi')\r\n ReturnedValue: \r\n IAnonymousObjectCreationOperation (OperationKind.AnonymousObjectCreation, Type: &amp;lt;anonymous type: Key s1 As System.Int32, Key s2 As System.Int32&gt;, IsImplicit) (Syntax: 's2 in qi')\r\n Initializers(2):\r\n IParameterReferenceOperation: s1 (OperationKind.ParameterReference, Type: System.Int32, IsImplicit) (Syntax: 's1')\r\n IParameterReferenceOperation: s2 (OperationKind.ParameterReference, Type: System.Int32, IsImplicit) (Syntax: 's2')\r\n IAnonymousFunctionOperation (Symbol: Function ($VB$It As &amp;lt;anonymous type: Key s1 As System.Int32, Key s2 As System.Int32&gt;) As ?) (OperationKind.AnonymousFunction, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n IBlockOperation (1 statements) (OperationKind.Block, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n IReturnOperation (OperationKind.Return, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n ReturnedValue: \r\n IInvalidOperation (OperationKind.Invalid, Type: null, IsInvalid) (Syntax: '')\r\n Children(0)\r\n IAnonymousFunctionOperation (Symbol: Function ($VB$It As &amp;lt;anonymous type: Key s1 As System.Int32, Key s2 As System.Int32&gt;) As ?) (OperationKind.AnonymousFunction, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n IBlockOperation (1 statements) (OperationKind.Block, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n IReturnOperation (OperationKind.Return, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n ReturnedValue: \r\n IInvalidOperation (OperationKind.Invalid, Type: null, IsInvalid) (Syntax: '')\r\n Children(0)\r\n IAnonymousFunctionOperation (Symbol: Function ($315 As ?, $VB$ItAnonymous As ?) As &amp;lt;anonymous type: Key $315 As ?, Key $315 As ?&gt;) (OperationKind.AnonymousFunction, Type: null, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\n IBlockOperation (1 statements) (OperationKind.Block, Type: null, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\n IReturnOperation (OperationKind.Return, Type: null, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\n ReturnedValue: \r\n IAnonymousObjectCreationOperation (OperationKind.AnonymousObjectCreation, Type: &amp;lt;anonymous type: Key $315 As ?, Key $315 As ?&gt;, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\n Initializers(2):\r\n IOperation: (OperationKind.None, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n IInvalidOperation (OperationKind.Invalid, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n Children(1):\r\n IParameterReferenceOperation: $VB$ItAnonymous (OperationKind.ParameterReference, Type: ?, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\nActual:\r\nITranslatedQueryOperation (OperationKind.TranslatedQuery, Type: ?, IsInvalid) (Syntax: 'From s1 In ... in qi Group')\r\n Expression: \r\n IInvalidOperation (OperationKind.Invalid, Type: ?, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\n Children(4):\r\n IInvalidOperation (OperationKind.Invalid, Type: ?, IsImplicit) (Syntax: 's2 in qi')\r\n Children(3):\r\n ILocalReferenceOperation: qi (OperationKind.LocalReference, Type: QueryAble, IsInvalid) (Syntax: 'qi')\r\n IAnonymousFunctionOperation (Symbol: Function (s1 As System.Int32) As ?) (OperationKind.AnonymousFunction, Type: null, IsImplicit) (Syntax: 'qi')\r\n IBlockOperation (1 statements) (OperationKind.Block, Type: null, IsImplicit) (Syntax: 'qi')\r\n IReturnOperation (OperationKind.Return, Type: null, IsImplicit) (Syntax: 'qi')\r\n ReturnedValue: \r\n ILocalReferenceOperation: qi (OperationKind.LocalReference, Type: QueryAble) (Syntax: 'qi')\r\n IAnonymousFunctionOperation (Symbol: Function (s1 As System.Int32, s2 As System.Int32) As &amp;lt;anonymous type: Key s1 As System.Int32, Key s2 As System.Int32&gt;) (OperationKind.AnonymousFunction, Type: null, IsInvalid, IsImplicit) (Syntax: 'From s1 In qi, s2 in qi')\r\n IBlockOperation (1 statements) (OperationKind.Block, Type: null, IsInvalid, IsImplicit) (Syntax: 'From s1 In qi, s2 in qi')\r\n IReturnOperation (OperationKind.Return, Type: null, IsInvalid, IsImplicit) (Syntax: 'From s1 In qi, s2 in qi')\r\n ReturnedValue: \r\n IAnonymousObjectCreationOperation (OperationKind.AnonymousObjectCreation, Type: &amp;lt;anonymous type: Key s1 As System.Int32, Key s2 As System.Int32&gt;, IsImplicit) (Syntax: 's2 in qi')\r\n Initializers(2):\r\n IParameterReferenceOperation: s1 (OperationKind.ParameterReference, Type: System.Int32, IsImplicit) (Syntax: 's1')\r\n IParameterReferenceOperation: s2 (OperationKind.ParameterReference, Type: System.Int32, IsImplicit) (Syntax: 's2')\r\n IAnonymousFunctionOperation (Symbol: Function ($VB$It As &amp;lt;anonymous type: Key s1 As System.Int32, Key s2 As System.Int32&gt;) As ?) (OperationKind.AnonymousFunction, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n IBlockOperation (1 statements) (OperationKind.Block, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n IReturnOperation (OperationKind.Return, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n ReturnedValue: \r\n IInvalidOperation (OperationKind.Invalid, Type: null, IsInvalid) (Syntax: '')\r\n Children(0)\r\n IAnonymousFunctionOperation (Symbol: Function ($VB$It As &amp;lt;anonymous type: Key s1 As System.Int32, Key s2 As System.Int32&gt;) As ?) (OperationKind.AnonymousFunction, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n IBlockOperation (1 statements) (OperationKind.Block, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n IReturnOperation (OperationKind.Return, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n ReturnedValue: \r\n IInvalidOperation (OperationKind.Invalid, Type: null, IsInvalid) (Syntax: '')\r\n Children(0)\r\n IAnonymousFunctionOperation (Symbol: Function ($315 As ?, $VB$ItAnonymous As ?) As &amp;lt;anonymous type: Key $315 As ?, Key $315 As ?&gt;) (OperationKind.AnonymousFunction, Type: null, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\n IBlockOperation (1 statements) (OperationKind.Block, Type: null, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\n IReturnOperation (OperationKind.Return, Type: null, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\n ReturnedValue: \r\n IAnonymousObjectCreationOperation (OperationKind.AnonymousObjectCreation, Type: &amp;lt;anonymous type: Key $315 As ?, Key $315 As ?&gt;, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\n Initializers(2):\r\n IParameterReferenceOperation: $315 (OperationKind.ParameterReference, Type: ?, IsInvalid, IsImplicit) (Syntax: '')\r\n IInvalidOperation (OperationKind.Invalid, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n Children(1):\r\n IParameterReferenceOperation: $VB$ItAnonymous (OperationKind.ParameterReference, Type: ?, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\n
  | +++++++++++++++++++
  | STACK TRACE:
  | at Roslyn.Test.Utilities.AssertEx.Fail(String message) at Roslyn.Test.Utilities.AssertEx.AreEqual[T](T expected, T actual, String message, IEqualityComparer`1 comparer) at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.Verify(String expectedOperationTree, String actualOperationTree) at Microsoft.CodeAnalysis.Test.Utilities.CompilationExtensions.VerifyOperationTree(Compilation compilation, SyntaxNode node, String expectedOperationTree) at Microsoft.CodeAnalysis.VisualBasic.UnitTests.GetExtendedSemanticInfoTests.GroupBy_Lookup1()
```
</Description>
        <CreatedDate>30/11/2017</CreatedDate>
        <ClosedDate>06/12/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23483</IssueID>
        <Title>Flaky test Microsoft.CodeAnalysis.VisualBasic.UnitTests.GetExtendedSemanticInfoTests.GroupBy_Lookup1</Title>
        <Description>The test `Microsoft.CodeAnalysis.VisualBasic.UnitTests.GetExtendedSemanticInfoTests.GroupBy_Lookup1` is failing frequently on merges from `master` to other branches. It isn't clear what the failure is (I tried testing the affected branch and did not see the failure).

The test is skipped to unblock the code flow. It needs to be investigated and unskipped.

Here is the output from the failing test:

``` none
Failed

Microsoft.CodeAnalysis.VisualBasic.UnitTests.GetExtendedSemanticInfoTests.GroupBy_Lookup1 (from Roslyn.Compilers.VisualBasic.Semantic.UnitTests)

MESSAGE:
  | Expected and actual were different.\r\nExpected:\r\nITranslatedQueryOperation (OperationKind.TranslatedQuery, Type: ?, IsInvalid) (Syntax: 'From s1 In ... in qi Group')\r\n Expression: \r\n IInvalidOperation (OperationKind.Invalid, Type: ?, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\n Children(4):\r\n IInvalidOperation (OperationKind.Invalid, Type: ?, IsImplicit) (Syntax: 's2 in qi')\r\n Children(3):\r\n ILocalReferenceOperation: qi (OperationKind.LocalReference, Type: QueryAble, IsInvalid) (Syntax: 'qi')\r\n IAnonymousFunctionOperation (Symbol: Function (s1 As System.Int32) As ?) (OperationKind.AnonymousFunction, Type: null, IsImplicit) (Syntax: 'qi')\r\n IBlockOperation (1 statements) (OperationKind.Block, Type: null, IsImplicit) (Syntax: 'qi')\r\n IReturnOperation (OperationKind.Return, Type: null, IsImplicit) (Syntax: 'qi')\r\n ReturnedValue: \r\n ILocalReferenceOperation: qi (OperationKind.LocalReference, Type: QueryAble) (Syntax: 'qi')\r\n IAnonymousFunctionOperation (Symbol: Function (s1 As System.Int32, s2 As System.Int32) As &amp;lt;anonymous type: Key s1 As System.Int32, Key s2 As System.Int32&gt;) (OperationKind.AnonymousFunction, Type: null, IsInvalid, IsImplicit) (Syntax: 'From s1 In qi, s2 in qi')\r\n IBlockOperation (1 statements) (OperationKind.Block, Type: null, IsInvalid, IsImplicit) (Syntax: 'From s1 In qi, s2 in qi')\r\n IReturnOperation (OperationKind.Return, Type: null, IsInvalid, IsImplicit) (Syntax: 'From s1 In qi, s2 in qi')\r\n ReturnedValue: \r\n IAnonymousObjectCreationOperation (OperationKind.AnonymousObjectCreation, Type: &amp;lt;anonymous type: Key s1 As System.Int32, Key s2 As System.Int32&gt;, IsImplicit) (Syntax: 's2 in qi')\r\n Initializers(2):\r\n IParameterReferenceOperation: s1 (OperationKind.ParameterReference, Type: System.Int32, IsImplicit) (Syntax: 's1')\r\n IParameterReferenceOperation: s2 (OperationKind.ParameterReference, Type: System.Int32, IsImplicit) (Syntax: 's2')\r\n IAnonymousFunctionOperation (Symbol: Function ($VB$It As &amp;lt;anonymous type: Key s1 As System.Int32, Key s2 As System.Int32&gt;) As ?) (OperationKind.AnonymousFunction, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n IBlockOperation (1 statements) (OperationKind.Block, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n IReturnOperation (OperationKind.Return, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n ReturnedValue: \r\n IInvalidOperation (OperationKind.Invalid, Type: null, IsInvalid) (Syntax: '')\r\n Children(0)\r\n IAnonymousFunctionOperation (Symbol: Function ($VB$It As &amp;lt;anonymous type: Key s1 As System.Int32, Key s2 As System.Int32&gt;) As ?) (OperationKind.AnonymousFunction, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n IBlockOperation (1 statements) (OperationKind.Block, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n IReturnOperation (OperationKind.Return, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n ReturnedValue: \r\n IInvalidOperation (OperationKind.Invalid, Type: null, IsInvalid) (Syntax: '')\r\n Children(0)\r\n IAnonymousFunctionOperation (Symbol: Function ($315 As ?, $VB$ItAnonymous As ?) As &amp;lt;anonymous type: Key $315 As ?, Key $315 As ?&gt;) (OperationKind.AnonymousFunction, Type: null, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\n IBlockOperation (1 statements) (OperationKind.Block, Type: null, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\n IReturnOperation (OperationKind.Return, Type: null, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\n ReturnedValue: \r\n IAnonymousObjectCreationOperation (OperationKind.AnonymousObjectCreation, Type: &amp;lt;anonymous type: Key $315 As ?, Key $315 As ?&gt;, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\n Initializers(2):\r\n IOperation: (OperationKind.None, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n IInvalidOperation (OperationKind.Invalid, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n Children(1):\r\n IParameterReferenceOperation: $VB$ItAnonymous (OperationKind.ParameterReference, Type: ?, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\nActual:\r\nITranslatedQueryOperation (OperationKind.TranslatedQuery, Type: ?, IsInvalid) (Syntax: 'From s1 In ... in qi Group')\r\n Expression: \r\n IInvalidOperation (OperationKind.Invalid, Type: ?, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\n Children(4):\r\n IInvalidOperation (OperationKind.Invalid, Type: ?, IsImplicit) (Syntax: 's2 in qi')\r\n Children(3):\r\n ILocalReferenceOperation: qi (OperationKind.LocalReference, Type: QueryAble, IsInvalid) (Syntax: 'qi')\r\n IAnonymousFunctionOperation (Symbol: Function (s1 As System.Int32) As ?) (OperationKind.AnonymousFunction, Type: null, IsImplicit) (Syntax: 'qi')\r\n IBlockOperation (1 statements) (OperationKind.Block, Type: null, IsImplicit) (Syntax: 'qi')\r\n IReturnOperation (OperationKind.Return, Type: null, IsImplicit) (Syntax: 'qi')\r\n ReturnedValue: \r\n ILocalReferenceOperation: qi (OperationKind.LocalReference, Type: QueryAble) (Syntax: 'qi')\r\n IAnonymousFunctionOperation (Symbol: Function (s1 As System.Int32, s2 As System.Int32) As &amp;lt;anonymous type: Key s1 As System.Int32, Key s2 As System.Int32&gt;) (OperationKind.AnonymousFunction, Type: null, IsInvalid, IsImplicit) (Syntax: 'From s1 In qi, s2 in qi')\r\n IBlockOperation (1 statements) (OperationKind.Block, Type: null, IsInvalid, IsImplicit) (Syntax: 'From s1 In qi, s2 in qi')\r\n IReturnOperation (OperationKind.Return, Type: null, IsInvalid, IsImplicit) (Syntax: 'From s1 In qi, s2 in qi')\r\n ReturnedValue: \r\n IAnonymousObjectCreationOperation (OperationKind.AnonymousObjectCreation, Type: &amp;lt;anonymous type: Key s1 As System.Int32, Key s2 As System.Int32&gt;, IsImplicit) (Syntax: 's2 in qi')\r\n Initializers(2):\r\n IParameterReferenceOperation: s1 (OperationKind.ParameterReference, Type: System.Int32, IsImplicit) (Syntax: 's1')\r\n IParameterReferenceOperation: s2 (OperationKind.ParameterReference, Type: System.Int32, IsImplicit) (Syntax: 's2')\r\n IAnonymousFunctionOperation (Symbol: Function ($VB$It As &amp;lt;anonymous type: Key s1 As System.Int32, Key s2 As System.Int32&gt;) As ?) (OperationKind.AnonymousFunction, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n IBlockOperation (1 statements) (OperationKind.Block, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n IReturnOperation (OperationKind.Return, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n ReturnedValue: \r\n IInvalidOperation (OperationKind.Invalid, Type: null, IsInvalid) (Syntax: '')\r\n Children(0)\r\n IAnonymousFunctionOperation (Symbol: Function ($VB$It As &amp;lt;anonymous type: Key s1 As System.Int32, Key s2 As System.Int32&gt;) As ?) (OperationKind.AnonymousFunction, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n IBlockOperation (1 statements) (OperationKind.Block, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n IReturnOperation (OperationKind.Return, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n ReturnedValue: \r\n IInvalidOperation (OperationKind.Invalid, Type: null, IsInvalid) (Syntax: '')\r\n Children(0)\r\n IAnonymousFunctionOperation (Symbol: Function ($315 As ?, $VB$ItAnonymous As ?) As &amp;lt;anonymous type: Key $315 As ?, Key $315 As ?&gt;) (OperationKind.AnonymousFunction, Type: null, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\n IBlockOperation (1 statements) (OperationKind.Block, Type: null, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\n IReturnOperation (OperationKind.Return, Type: null, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\n ReturnedValue: \r\n IAnonymousObjectCreationOperation (OperationKind.AnonymousObjectCreation, Type: &amp;lt;anonymous type: Key $315 As ?, Key $315 As ?&gt;, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\n Initializers(2):\r\n IParameterReferenceOperation: $315 (OperationKind.ParameterReference, Type: ?, IsInvalid, IsImplicit) (Syntax: '')\r\n IInvalidOperation (OperationKind.Invalid, Type: null, IsInvalid, IsImplicit) (Syntax: '')\r\n Children(1):\r\n IParameterReferenceOperation: $VB$ItAnonymous (OperationKind.ParameterReference, Type: ?, IsInvalid, IsImplicit) (Syntax: 'Group ')\r\n
  | +++++++++++++++++++
  | STACK TRACE:
  | at Roslyn.Test.Utilities.AssertEx.Fail(String message) at Roslyn.Test.Utilities.AssertEx.AreEqual[T](T expected, T actual, String message, IEqualityComparer`1 comparer) at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.Verify(String expectedOperationTree, String actualOperationTree) at Microsoft.CodeAnalysis.Test.Utilities.CompilationExtensions.VerifyOperationTree(Compilation compilation, SyntaxNode node, String expectedOperationTree) at Microsoft.CodeAnalysis.VisualBasic.UnitTests.GetExtendedSemanticInfoTests.GroupBy_Lookup1()
```
</Description>
        <CreatedDate>30/11/2017</CreatedDate>
        <ClosedDate>06/12/2017</ClosedDate>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>23414</IssueID>
    <Title>Make anonymous type's GetHashCode not depend on compilation environment</Title>
    <Description>We stop calling string.GetHashCode() at compile time and placing the value in the
generated code because that is not deterministic. Instead we use FNV1a hash code.

For VB, which does not have this bug, we update the implementation to use a more
reliable case-mapping method (see #2116)

### Customer scenario

Compile source code in two different compilation environments, expecting the result to be the same. But the generated GetHashCode varies from one to another because it depends on string.GetHashCode in the compilation environment. When compiling in an environment with [randomized string hashing](https://docs.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element), the compiler will produce a different assembly nearly every time.

### Bugs this fixes

Fixes #23020

### Workarounds, if any

Don't compile in different environments and expect deterministic compiler output.

### Risk

Very low. Replaces one hash code computation with another.

### Performance impact

Very low for the same reason.

### Is this a regression from a previous update?

No.

### Root cause analysis

We've been improving our determinism since we started working on it a couple of years ago. This particular issue was detected and diagnosed by a customer.

### How was the bug found?

Customer reported.

### Test documentation updated?

N/A

@dotnet/roslyn-compiler Please review.</Description>
    <CreatedDate>28/11/2017</CreatedDate>
    <ClosedDate>30/11/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>2116</IssueID>
        <Title>Change VB's case-mapping rules to use a more recent Unicode version</Title>
        <Description>VB's current case-mapping rules for identifier equivalence uses a pretty old version of the Unicode spec, and has bugs. Specifically we use the "invariant" locale, which because it is invariant will never change to be updated as the Unicode spec evolves.

We should instead use a "neutral" culture for the case-mapping, such as the "en" locale, which follows the Unicode case-mapping rules and has no locale-specific exceptions.

&lt;!---
@huboard:{"order":1968.0,"milestone_order":2116,"custom_state":""}
--&gt;
</Description>
        <CreatedDate>20/04/2015</CreatedDate>
        <ClosedDate>27/04/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23020</IssueID>
        <Title>Generation of the GetHashCode method of anonymous types is not deterministic</Title>
        <Description>**Version Used**: 
Commit 72b8f88b0d

**Steps to Reproduce**:

1. Create the following .cs file:
```
class Program
{
    static void Main()
    {
        var a = new { a = 4 };
    }
}
```
2. Compile it with core MSBuild
3. Copy the output .dll elsewhere and compile it again
4. Alternatively, use csc and set the `deterministic` flag:
`dotnet csc.dll Program.cs /target:library /deterministic /noconfig /reference:"C:\Program Files\dotnet\sdk\NuGetFallbackFolder\microsoft.netcore.app\2.0.0\ref\netcoreapp2.0\System.Collections.dll" /reference:"C:\Program Files\dotnet\sdk\NuGetFallbackFolder\microsoft.netcore.app\2.0.0\ref\netcoreapp2.0\System.Runtime.dll"`

**Expected Behavior**:
The compiler should produce the exact same output both times.

**Actual Behavior**:
The compiler's output differs every time.
If the net46 csc build is used, the compiler produces the same output each time it is run.

**Reason**:
The difference comes from the GetHashCode method of the created anonymous type. Here's the IL from two separate compiles.
```
  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    // Code size       29 (0x1d)
    .maxstack  8
    IL_0000:  ldc.i4     0x1af3bd32
    IL_0005:  ldc.i4     0xa5555529
    IL_000a:  mul
```
```
.method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    // Code size       29 (0x1d)
    .maxstack  8
    IL_0000:  ldc.i4     0xc61810dc
    IL_0005:  ldc.i4     0xa5555529
    IL_000a:  mul
```

One of the constants used in the hash method changes every time. This is because Roslyn uses the hash codes of the backing fields of anonymous types to generate the above constant. ([Code here](https://github.com/dotnet/roslyn/blob/72b8f88b0daf42e1a8b1d6687cbfc9ccbb0cc21a/src/Compilers/CSharp/Portable/Compiler/AnonymousTypeMethodBodySynthesizer.cs#L190))

This isn't a problem in .NET Framework because [randomized string hashing](https://docs.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element) is disabled by default. However, it's enabled by default in coreclr, so identical strings will give different hash codes each time the process is run, creating non-deterministic IL code.</Description>
        <CreatedDate>06/11/2017</CreatedDate>
        <ClosedDate>30/11/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Compiler/AnonymousTypeMethodBodySynthesizer.cs</File>
      <File>src/Compilers/CSharp/Test/WinRT/AnonymousTypesSymbolTests.cs</File>
      <File>src/Compilers/Core/Portable/InternalUtilities/Hash.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23412</IssueID>
    <Title>Fix for #22690 NRE in GetAttributeSyntaxNodeOfToken</Title>
    <Description>:memo: This is a back-port of #22961 to **dev15.5.x**. The template below is copied from that issue.

**Customer scenario**

An NRE in AbstractInternalsVisibleToCompletionProvider causes a crash of VS. The NRE was not reproducible and seemed only to occur in the C# intermediate window. No tests are provided (see #22690 why).

**Bugs this fixes:**

Fixes #22690 
[DevDiv 525354](https://devdiv.visualstudio.com/DevDiv/_workitems/edit/525354)

**Workarounds, if any**

None.

**Risk**

Bug was not reproducible and therefore no tests are given. The fix is a best guess effort and is based on looking at possible NRE places in the stacktrace given by #22690:

* `IsStringLiteralExpression` is only called at on place in `AbstractInternalsVisibleToCompletionProvider.GetAttributeSyntaxNodeOfToken`
* `CSharpSyntaxFactsService.IsStringLiteralExpression`  is defined as `=&gt; node.Kind() == SyntaxKind.StringLiteralExpression;`
* `node.Kind()` causes the NRE most likely here: `var rawKind = node.RawKind;` if node is null.

If this analysis is not correct there might still be a bug that causes VS to crash.

**Performance impact**

None.

**Is this a regression from a previous update?**

No. New feature. Bug found in VS 15.5 Preview 1

**Root cause analysis:**

`var node = token.Parent;` returns `null` in some rare circumstances. This was discovered in VS 15.5 Preview 1.

**How was the bug found?**

Reported by @tmat in #22690.

**Test documentation updated?**

No.</Description>
    <CreatedDate>28/11/2017</CreatedDate>
    <ClosedDate>29/11/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>22961</IssueID>
        <Title>Fix for #22690 NRE in GetAttributeSyntaxNodeOfToken in AbstractInternalsVisibleToCompletionProvider</Title>
        <Description>**Customer scenario**

An NRE in AbstractInternalsVisibleToCompletionProvider causes a crash of VS. The NRE was not reproducible and seemed only to occur in the C# intermediate window. No tests are provided (see #22690 why).

**Bugs this fixes:**

Fixes #22690 

**Workarounds, if any**

None.

**Risk**

Bug was not reproducible and therefore no tests are given. The fix is a best guess effort and is based on looking at possible NRE places in the stacktrace given by #22690:

* `IsStringLiteralExpression` is only called at on place in `AbstractInternalsVisibleToCompletionProvider.GetAttributeSyntaxNodeOfToken`
* `CSharpSyntaxFactsService.IsStringLiteralExpression`  is defined as `=&gt; node.Kind() == SyntaxKind.StringLiteralExpression;`
* `node.Kind()` causes the NRE most likely here: `var rawKind = node.RawKind;` if node is null.

If this analysis is not correct there might still be a bug that causes VS to crash.

**Performance impact**

None.

**Is this a regression from a previous update?**

No. New feature. Bug found in VS 15.5 Preview 1

**Root cause analysis:**

`var node = token.Parent;` returns `null` in some rare circumstances. This was discovered in VS 15.5 Preview 1.

**How was the bug found?**

Reported by @tmat in #22690.

**Test documentation updated?**

No.</Description>
        <CreatedDate>01/11/2017</CreatedDate>
        <ClosedDate>22/11/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22690</IssueID>
        <Title>VS crash: AbstractInternalsVisibleToCompletionProvider.GetAttributeSyntaxNodeOfToken throws NRE</Title>
        <Description>```
   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(SyntaxNode node) in E:\A\_work\24\s\src\Compilers\CSharp\Portable\CSharpExtensions.cs:line 161
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxFactsService.IsStringLiteralExpression(SyntaxNode node) in E:\A\_work\24\s\src\Workspaces\CSharp\Portable\LanguageServices\CSharpSyntaxFactsService.cs:line 1314
   at Microsoft.CodeAnalysis.Completion.Providers.AbstractInternalsVisibleToCompletionProvider.GetAttributeSyntaxNodeOfToken(ISyntaxFactsService syntaxFactsService, SyntaxToken token) in E:\A\_work\24\s\src\Features\Core\Portable\Completion\Providers\AbstractInternalsVisibleToCompletionProvider.cs:line 78
   at Microsoft.CodeAnalysis.Completion.Providers.AbstractInternalsVisibleToCompletionProvider.&lt;ProvideCompletionsAsync&gt;d__4.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\Providers\AbstractInternalsVisibleToCompletionProvider.cs:line 55
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders.&lt;GetContextAsync&gt;d__31.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionServiceWithProviders.cs:line 449
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders.&lt;ComputeNonEmptyCompletionContextsAsync&gt;d__24.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionServiceWithProviders.cs:line 311
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders.&lt;GetCompletionsAsync&gt;d__22.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionServiceWithProviders.cs:line 241
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionService.&lt;GetCompletionsAndSetItemDocumentAsync&gt;d__11.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionService.cs:line 183
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Editor.Implementation.IntelliSense.Completion.Controller.Session.ModelComputer.&lt;DoInBackgroundAsync&gt;d__13.MoveNext() in E:\A\_work\24\s\src\EditorFeatures\Core\Implementation\IntelliSense\Completion\Controller.Session_ComputeModel.cs:line 103
```

Crash dump: %internal_share%\public\tomat\Bugs\22690

VS build: 15.5.0 P1 (26927.1)
</Description>
        <CreatedDate>13/10/2017</CreatedDate>
        <ClosedDate>22/11/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22690</IssueID>
        <Title>VS crash: AbstractInternalsVisibleToCompletionProvider.GetAttributeSyntaxNodeOfToken throws NRE</Title>
        <Description>```
   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(SyntaxNode node) in E:\A\_work\24\s\src\Compilers\CSharp\Portable\CSharpExtensions.cs:line 161
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxFactsService.IsStringLiteralExpression(SyntaxNode node) in E:\A\_work\24\s\src\Workspaces\CSharp\Portable\LanguageServices\CSharpSyntaxFactsService.cs:line 1314
   at Microsoft.CodeAnalysis.Completion.Providers.AbstractInternalsVisibleToCompletionProvider.GetAttributeSyntaxNodeOfToken(ISyntaxFactsService syntaxFactsService, SyntaxToken token) in E:\A\_work\24\s\src\Features\Core\Portable\Completion\Providers\AbstractInternalsVisibleToCompletionProvider.cs:line 78
   at Microsoft.CodeAnalysis.Completion.Providers.AbstractInternalsVisibleToCompletionProvider.&lt;ProvideCompletionsAsync&gt;d__4.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\Providers\AbstractInternalsVisibleToCompletionProvider.cs:line 55
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders.&lt;GetContextAsync&gt;d__31.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionServiceWithProviders.cs:line 449
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders.&lt;ComputeNonEmptyCompletionContextsAsync&gt;d__24.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionServiceWithProviders.cs:line 311
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders.&lt;GetCompletionsAsync&gt;d__22.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionServiceWithProviders.cs:line 241
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionService.&lt;GetCompletionsAndSetItemDocumentAsync&gt;d__11.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionService.cs:line 183
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Editor.Implementation.IntelliSense.Completion.Controller.Session.ModelComputer.&lt;DoInBackgroundAsync&gt;d__13.MoveNext() in E:\A\_work\24\s\src\EditorFeatures\Core\Implementation\IntelliSense\Completion\Controller.Session_ComputeModel.cs:line 103
```

Crash dump: %internal_share%\public\tomat\Bugs\22690

VS build: 15.5.0 P1 (26927.1)
</Description>
        <CreatedDate>13/10/2017</CreatedDate>
        <ClosedDate>22/11/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22690</IssueID>
        <Title>VS crash: AbstractInternalsVisibleToCompletionProvider.GetAttributeSyntaxNodeOfToken throws NRE</Title>
        <Description>```
   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(SyntaxNode node) in E:\A\_work\24\s\src\Compilers\CSharp\Portable\CSharpExtensions.cs:line 161
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxFactsService.IsStringLiteralExpression(SyntaxNode node) in E:\A\_work\24\s\src\Workspaces\CSharp\Portable\LanguageServices\CSharpSyntaxFactsService.cs:line 1314
   at Microsoft.CodeAnalysis.Completion.Providers.AbstractInternalsVisibleToCompletionProvider.GetAttributeSyntaxNodeOfToken(ISyntaxFactsService syntaxFactsService, SyntaxToken token) in E:\A\_work\24\s\src\Features\Core\Portable\Completion\Providers\AbstractInternalsVisibleToCompletionProvider.cs:line 78
   at Microsoft.CodeAnalysis.Completion.Providers.AbstractInternalsVisibleToCompletionProvider.&lt;ProvideCompletionsAsync&gt;d__4.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\Providers\AbstractInternalsVisibleToCompletionProvider.cs:line 55
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders.&lt;GetContextAsync&gt;d__31.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionServiceWithProviders.cs:line 449
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders.&lt;ComputeNonEmptyCompletionContextsAsync&gt;d__24.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionServiceWithProviders.cs:line 311
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders.&lt;GetCompletionsAsync&gt;d__22.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionServiceWithProviders.cs:line 241
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionService.&lt;GetCompletionsAndSetItemDocumentAsync&gt;d__11.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionService.cs:line 183
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Editor.Implementation.IntelliSense.Completion.Controller.Session.ModelComputer.&lt;DoInBackgroundAsync&gt;d__13.MoveNext() in E:\A\_work\24\s\src\EditorFeatures\Core\Implementation\IntelliSense\Completion\Controller.Session_ComputeModel.cs:line 103
```

Crash dump: %internal_share%\public\tomat\Bugs\22690

VS build: 15.5.0 P1 (26927.1)
</Description>
        <CreatedDate>13/10/2017</CreatedDate>
        <ClosedDate>22/11/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22690</IssueID>
        <Title>VS crash: AbstractInternalsVisibleToCompletionProvider.GetAttributeSyntaxNodeOfToken throws NRE</Title>
        <Description>```
   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(SyntaxNode node) in E:\A\_work\24\s\src\Compilers\CSharp\Portable\CSharpExtensions.cs:line 161
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxFactsService.IsStringLiteralExpression(SyntaxNode node) in E:\A\_work\24\s\src\Workspaces\CSharp\Portable\LanguageServices\CSharpSyntaxFactsService.cs:line 1314
   at Microsoft.CodeAnalysis.Completion.Providers.AbstractInternalsVisibleToCompletionProvider.GetAttributeSyntaxNodeOfToken(ISyntaxFactsService syntaxFactsService, SyntaxToken token) in E:\A\_work\24\s\src\Features\Core\Portable\Completion\Providers\AbstractInternalsVisibleToCompletionProvider.cs:line 78
   at Microsoft.CodeAnalysis.Completion.Providers.AbstractInternalsVisibleToCompletionProvider.&lt;ProvideCompletionsAsync&gt;d__4.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\Providers\AbstractInternalsVisibleToCompletionProvider.cs:line 55
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders.&lt;GetContextAsync&gt;d__31.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionServiceWithProviders.cs:line 449
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders.&lt;ComputeNonEmptyCompletionContextsAsync&gt;d__24.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionServiceWithProviders.cs:line 311
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders.&lt;GetCompletionsAsync&gt;d__22.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionServiceWithProviders.cs:line 241
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Completion.CompletionService.&lt;GetCompletionsAndSetItemDocumentAsync&gt;d__11.MoveNext() in E:\A\_work\24\s\src\Features\Core\Portable\Completion\CompletionService.cs:line 183
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 184
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in f:\dd\ndp\clr\src\BCL\system\runtime\compilerservices\TaskAwaiter.cs:line 157
   at Microsoft.CodeAnalysis.Editor.Implementation.IntelliSense.Completion.Controller.Session.ModelComputer.&lt;DoInBackgroundAsync&gt;d__13.MoveNext() in E:\A\_work\24\s\src\EditorFeatures\Core\Implementation\IntelliSense\Completion\Controller.Session_ComputeModel.cs:line 103
```

Crash dump: %internal_share%\public\tomat\Bugs\22690

VS build: 15.5.0 P1 (26927.1)
</Description>
        <CreatedDate>13/10/2017</CreatedDate>
        <ClosedDate>22/11/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Features/Core/Portable/Completion/Providers/AbstractInternalsVisibleToCompletionProvider.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23390</IssueID>
    <Title>Fixed 'Qualify member access' analyzer for object initializer</Title>
    <Description>Fixes #22776
Fixes #23016

Regression from 15.4

VSO bug : [link](https://devdiv.visualstudio.com/DevDiv/NET%20Developer%20Experience%20Productivity/_workitems/edit/529870)</Description>
    <CreatedDate>27/11/2017</CreatedDate>
    <ClosedDate>28/11/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>22776</IssueID>
        <Title>Incorrect "Add 'this.'" diagnostic for class initializers</Title>
        <Description>This is reported in a few Developer Community feedback items, I will link them as they're processed.
-  https://developercommunity.visualstudio.com/content/problem/131432/add-this-or-me-qualification-for-class-initializer.html
- https://developercommunity.visualstudio.com/content/problem/129705/incorrect-ide0009-in-object-initializer.html
- https://developercommunity.visualstudio.com/content/problem/161932/ide0009-add-this-or-me-qualification-incorrectly-r.html

I have not been able to reproduce this locally using the settings in the Tools | Options. Maybe it requires the editorconfig? That doesn't make much sense but I haven't been able to come up with anything else.</Description>
        <CreatedDate>19/10/2017</CreatedDate>
        <ClosedDate>21/12/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23016</IssueID>
        <Title>Add this or me qualification rule triggered incorrectly in return statement</Title>
        <Description>Have the following code:

            return new UserSession
            {
                UserId = subject
            };

Where UserSession is a simple class with property UserId. I'm getting green squiggles under the UserId in that statement, suggesting I add this or me qualification.

_This issue has been moved from https://developercommunity.visualstudio.com/content/problem/126539/add-this-or-me-qualification-rule-triggered-incorr.html
VSTS ticketId: 505612_
_These are the original issue comments:_

David Poeschl [MSFT] on ‎10‎/‎18‎/‎2017, 00:37 PM (17 days ago): &lt;p&gt;Thank you for your feedback! I've so far been unable to reproduce this problem. I tried with the following code:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;class C&lt;/p&gt;&lt;p&gt;\{&lt;/p&gt;&lt;p&gt;  static UserSession M()&lt;/p&gt;&lt;p&gt;  \{&lt;/p&gt;&lt;p&gt;    object subject = null;&lt;/p&gt;&lt;p&gt;    return new UserSession&lt;/p&gt;&lt;p&gt;    \{&lt;/p&gt;&lt;p&gt;      UserId = subject&lt;/p&gt;&lt;p&gt;    };&lt;/p&gt;&lt;p&gt;  }&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;internal class UserSession&lt;/p&gt;&lt;p&gt;\{&lt;/p&gt;&lt;p&gt;  public object UserId \{ get; set; }&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;And under &amp;quot;Text Editor | C# | Code Style | General | 'this.' preferences&amp;quot; I've set everything to &amp;quot;Prefer 'this.'&amp;quot; with &amp;quot;Warning&amp;quot; severity. Am I missing a step that you can tell? Thanks!&lt;/p&gt;

_These are the original issue solutions:_
(no solutions)</Description>
        <CreatedDate>05/11/2017</CreatedDate>
        <ClosedDate>09/01/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/QualifyMemberAccess/QualifyMemberAccessTests.cs</File>
      <File>src/Features/CSharp/Portable/QualifyMemberAccess/CSharpQualifyMemberAccessDiagnosticAnalyzer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23343</IssueID>
    <Title>Address a number of IOperation issues for VB</Title>
    <Description>Related to #22548 and #22229.
</Description>
    <CreatedDate>21/11/2017</CreatedDate>
    <ClosedDate>27/11/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>22548</IssueID>
        <Title>Follow up on isImplicit mismatch </Title>
        <Description>Address feedback from https://github.com/dotnet/roslyn/pull/22309 </Description>
        <CreatedDate>05/10/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22229</IssueID>
        <Title>IsImplicit for multiple operation nodes with same syntax</Title>
        <Description>we want to make sure there is only one explicit IOperation when multiple IOperations are pointing to same syntax node.

right now, we have case such as this (https://github.com/dotnet/roslyn/pull/21857#pullrequestreview-64081939 or https://github.com/dotnet/roslyn/pull/21857#issuecomment-330950924) where InvalidExpression is pointing to same syntax node as its child. or ExpressionStatement pointing to same syntax node as its expression (ex, expression lambda body)

we need to decide whether we want to mark those as implicit or not. if we do, those IOperation will not be returned by GetOperation. but user can still get to that operation through parent and children.
</Description>
        <CreatedDate>20/09/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>23284</IssueID>
    <Title>Fix System.InvalidOperationException in IOperation factory for an Option statement inside a method body</Title>
    <Description>Fixes #23283.

**Customer scenario**

Request IOperation tree for an Option statement like the one below:
```
    Sub Method()
        Option Strict On 'BIND:"Option Strict On"
    End Sub
```

An InvalidOperationException is thrown by IOperation factory.

**Bugs this fixes:**

Fixes #23283.

**Workarounds, if any**

No

**Risk**

Low

**Performance impact**

Low perf impact because no extra allocations/no complexity changes

**Is this a regression from a previous update?**

No

**Root cause analysis:**

A test gap. Unit-tests are added.

**How was the bug found?**

Running existing compiler tests with IOperation validation test hook enabled.
</Description>
    <CreatedDate>20/11/2017</CreatedDate>
    <ClosedDate>20/11/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>23283</IssueID>
        <Title>IOperation factory throws System.InvalidOperationException for an Option statement inside a method body</Title>
        <Description>```
        &lt;CompilerTrait(CompilerFeature.IOperation)&gt;
        &lt;Fact()&gt;
        Public Sub TestOptionStatement_01()
            Dim source = &lt;![CDATA[
Imports System

Class Test
    Sub Method()
        Option Strict On 'BIND:"Option Strict On"
    End Sub
End Class]]&gt;.Value

            Dim expectedOperationTree = &lt;![CDATA[
]]&gt;.Value

            Dim expectedDiagnostics = &lt;![CDATA[
BC30024: Statement is not valid inside a method.
        Option Strict On 'BIND:"Option Strict On"
        ~~~~~~~~~~~~~~~~
]]&gt;.Value

            VerifyOperationTreeAndDiagnosticsForTest(Of StatementSyntax)(source, expectedOperationTree, expectedDiagnostics)
        End Sub
```

Observed:
```
System.InvalidOperationException: Unexpected value 'OptionStatement' of type 'Microsoft.CodeAnalysis.VisualBasic.SyntaxKind'
   at Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.IsStandaloneStatement(StatementSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.GetBindingRoot(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.GetOperationWorker(VisualBasicSyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.GetOperationWorker(VisualBasicSyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetOperationCore(SyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.SemanticModel.GetOperation(SyntaxNode node, CancellationToken cancellationToken)
```</Description>
        <CreatedDate>20/11/2017</CreatedDate>
        <ClosedDate>20/11/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23283</IssueID>
        <Title>IOperation factory throws System.InvalidOperationException for an Option statement inside a method body</Title>
        <Description>```
        &lt;CompilerTrait(CompilerFeature.IOperation)&gt;
        &lt;Fact()&gt;
        Public Sub TestOptionStatement_01()
            Dim source = &lt;![CDATA[
Imports System

Class Test
    Sub Method()
        Option Strict On 'BIND:"Option Strict On"
    End Sub
End Class]]&gt;.Value

            Dim expectedOperationTree = &lt;![CDATA[
]]&gt;.Value

            Dim expectedDiagnostics = &lt;![CDATA[
BC30024: Statement is not valid inside a method.
        Option Strict On 'BIND:"Option Strict On"
        ~~~~~~~~~~~~~~~~
]]&gt;.Value

            VerifyOperationTreeAndDiagnosticsForTest(Of StatementSyntax)(source, expectedOperationTree, expectedDiagnostics)
        End Sub
```

Observed:
```
System.InvalidOperationException: Unexpected value 'OptionStatement' of type 'Microsoft.CodeAnalysis.VisualBasic.SyntaxKind'
   at Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.IsStandaloneStatement(StatementSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.GetBindingRoot(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.GetOperationWorker(VisualBasicSyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.GetOperationWorker(VisualBasicSyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetOperationCore(SyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.SemanticModel.GetOperation(SyntaxNode node, CancellationToken cancellationToken)
```</Description>
        <CreatedDate>20/11/2017</CreatedDate>
        <ClosedDate>20/11/2017</ClosedDate>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>23238</IssueID>
    <Title>Fix an InvalidCastException in IOperation factory for an ambiguous user-defined short-circuiting operator</Title>
    <Description>Fixes #23232.
Also fixes incorrect calculation of BinaryOperatorKind for the same node.

**Customer scenario**

Request IOperation tree for an ambiguous user-defined short-circuiting operator like the one below:
```
Option Strict Off

Imports System

Module Module1

    Class B2
        Public Shared Operator And(x As B3, y As B2) As B2
            Return Nothing
        End Operator

        Public Shared Operator Or(x As B3, y As B2) As B2
            Return Nothing
        End Operator
    End Class

    Class B3
        Public Shared Operator And(x As B3, y As B2) As B3
            Return Nothing
        End Operator

        Public Shared Operator Or(x As B3, y As B2) As B3
            Return Nothing
        End Operator
    End Class

    Sub Main()
        Dim x As Object

        x = New B3() AndAlso New B2() 'BIND1:"New B3() AndAlso New B2()"
    End Sub
End Module
```

An InvalidCastException is thrown by IOperation factory.

**Bugs this fixes:**

Fixes #23232.

**Workarounds, if any**

No

**Risk**

Low

**Performance impact**

Low perf impact because no extra allocations/no complexity changes

**Is this a regression from a previous update?**

No

**Root cause analysis:**

A test gap. Unit-tests are added.

**How was the bug found?**

Running existing compiler tests with IOperation validation test hook enabled.
</Description>
    <CreatedDate>17/11/2017</CreatedDate>
    <ClosedDate>17/11/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>23232</IssueID>
        <Title>An InvalidCastException is thrown for an ambiguous user-defined short-circuiting operator</Title>
        <Description>```
        &lt;CompilerTrait(CompilerFeature.IOperation)&gt;
        &lt;Fact&gt;
        Public Sub ShortCircuiting5()
            Dim compilationDef =
&lt;compilation name="SimpleTest1"&gt;
    &lt;file name="a.vb"&gt;&lt;![CDATA[
Option Strict Off

Imports System

Module Module1

    Class B2
        Public Shared Operator And(x As B3, y As B2) As B2
            Return Nothing
        End Operator

        Public Shared Operator Or(x As B3, y As B2) As B2
            Return Nothing
        End Operator
    End Class

    Class B3
        Public Shared Operator And(x As B3, y As B2) As B3
            Return Nothing
        End Operator

        Public Shared Operator Or(x As B3, y As B2) As B3
            Return Nothing
        End Operator
    End Class

    Sub Main()
        Dim x As Object

        x = New B3() AndAlso New B2() 'BIND1:"New B3() AndAlso New B2()"
        x = New B3() OrElse New B2() 'BIND2:"New B3() OrElse New B2()"
    End Sub
End Module
    ]]&gt;&lt;/file&gt;
&lt;/compilation&gt;

            Dim compilation = CreateCompilationWithMscorlibAndVBRuntime(compilationDef)

            CompilationUtils.AssertTheseDiagnostics(compilation,
&lt;expected&gt;
BC30521: Overload resolution failed because no accessible 'And' is most specific for these arguments:
    'Public Shared Operator Module1.B3.And(x As Module1.B3, y As Module1.B2) As Module1.B3': Not most specific.
    'Public Shared Operator Module1.B2.And(x As Module1.B3, y As Module1.B2) As Module1.B2': Not most specific.
        x = New B3() AndAlso New B2() 'BIND1:"New B3() AndAlso New B2()"
            ~~~~~~~~~~~~~~~~~~~~~~~~~
BC30521: Overload resolution failed because no accessible 'Or' is most specific for these arguments:
    'Public Shared Operator Module1.B3.Or(x As Module1.B3, y As Module1.B2) As Module1.B3': Not most specific.
    'Public Shared Operator Module1.B2.Or(x As Module1.B3, y As Module1.B2) As Module1.B2': Not most specific.
        x = New B3() OrElse New B2() 'BIND2:"New B3() OrElse New B2()"
            ~~~~~~~~~~~~~~~~~~~~~~~~
&lt;/expected&gt;)
   
            compilation.VerifyOperationTree(CompilationUtils.FindBindingText(Of ExpressionSyntax)(compilation, "a.vb", 1), expectedOperationTree:=
            &lt;![CDATA[
]]&gt;.Value)

            compilation.VerifyOperationTree(CompilationUtils.FindBindingText(Of ExpressionSyntax)(compilation, "a.vb", 2), expectedOperationTree:=
            &lt;![CDATA[
]]&gt;.Value)
        End Sub
```

Observed:
```
Test 'Microsoft.CodeAnalysis.VisualBasic.UnitTests.Semantics.UserDefinedBinaryOperators.ShortCircuiting5' failed: Microsoft.CodeAnalysis.ThrowingTraceListener+DebugAssertFailureException : 
System.InvalidCastException: Unable to cast object of type 'Microsoft.CodeAnalysis.VisualBasic.BoundBadExpression' to type 'Microsoft.CodeAnalysis.VisualBasic.BoundCall'.
   at Microsoft.CodeAnalysis.VisualBasic.BoundUserDefinedBinaryOperator.get_Call()
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.CreateBoundUserDefinedShortCircuitingOperatorOperation(BoundUserDefinedShortCircuitingOperator boundUserDefinedShortCircuitingOperator)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.CreateInternal(BoundNode boundNode)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory._Lambda$__3-0(BoundNode n)
   at System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(TKey key, Func`2 valueFactory)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.Create(BoundNode boundNode)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory._Closure$__121-0._Lambda$__2()
   at System.Lazy`1.CreateValue()
   at System.Lazy`1.LazyInitValue()
   at System.Lazy`1.get_Value()
   at Microsoft.CodeAnalysis.VisualBasic.LazyVisualBasicConversionExpression.get_OperandImpl()
   at Microsoft.CodeAnalysis.Operations.BaseConversionExpression.get_Operand()
   at Microsoft.CodeAnalysis.Operations.BaseConversionExpression.&lt;get_Children&gt;d__14.MoveNext()
   at Microsoft.CodeAnalysis.Operations.OperationExtensions.&lt;Descendants&gt;d__3.MoveNext()
   at System.Linq.Enumerable.FirstOrDefault[TSource](IEnumerable`1 source, Func`2 predicate)
   at Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.GetOperationWorker(VisualBasicSyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.GetOperationWorker(VisualBasicSyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetOperationCore(SyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.SemanticModel.GetOperation(SyntaxNode node, CancellationToken cancellationToken)

	at Microsoft.CodeAnalysis.ThrowingTraceListener.Fail(String message, String detailMessage)
	at System.Diagnostics.TraceListener.Fail(String message)
	at System.Diagnostics.TraceInternal.Fail(String message)
	at System.Diagnostics.Debug.Assert(Boolean condition, String message)
	at Microsoft.CodeAnalysis.SemanticModel.GetOperation(SyntaxNode node, CancellationToken cancellationToken)
	at Microsoft.CodeAnalysis.Test.Utilities.CompilationExtensions.AppendOperationTree(SemanticModel model, SyntaxNode node, StringBuilder actualTextBuilder, Int32 initialIndent)
	at Microsoft.CodeAnalysis.Test.Utilities.CompilationExtensions.VerifyOperationTree(Compilation compilation, SyntaxNode node, String expectedOperationTree)
	F:\GitHub\roslyn\src\Compilers\VisualBasic\Test\Semantic\Semantics\UserDefinedBinaryOperators.vb(590,0): at Microsoft.CodeAnalysis.VisualBasic.UnitTests.Semantics.UserDefinedBinaryOperators.ShortCircuiting5()
```
</Description>
        <CreatedDate>17/11/2017</CreatedDate>
        <ClosedDate>20/11/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23232</IssueID>
        <Title>An InvalidCastException is thrown for an ambiguous user-defined short-circuiting operator</Title>
        <Description>```
        &lt;CompilerTrait(CompilerFeature.IOperation)&gt;
        &lt;Fact&gt;
        Public Sub ShortCircuiting5()
            Dim compilationDef =
&lt;compilation name="SimpleTest1"&gt;
    &lt;file name="a.vb"&gt;&lt;![CDATA[
Option Strict Off

Imports System

Module Module1

    Class B2
        Public Shared Operator And(x As B3, y As B2) As B2
            Return Nothing
        End Operator

        Public Shared Operator Or(x As B3, y As B2) As B2
            Return Nothing
        End Operator
    End Class

    Class B3
        Public Shared Operator And(x As B3, y As B2) As B3
            Return Nothing
        End Operator

        Public Shared Operator Or(x As B3, y As B2) As B3
            Return Nothing
        End Operator
    End Class

    Sub Main()
        Dim x As Object

        x = New B3() AndAlso New B2() 'BIND1:"New B3() AndAlso New B2()"
        x = New B3() OrElse New B2() 'BIND2:"New B3() OrElse New B2()"
    End Sub
End Module
    ]]&gt;&lt;/file&gt;
&lt;/compilation&gt;

            Dim compilation = CreateCompilationWithMscorlibAndVBRuntime(compilationDef)

            CompilationUtils.AssertTheseDiagnostics(compilation,
&lt;expected&gt;
BC30521: Overload resolution failed because no accessible 'And' is most specific for these arguments:
    'Public Shared Operator Module1.B3.And(x As Module1.B3, y As Module1.B2) As Module1.B3': Not most specific.
    'Public Shared Operator Module1.B2.And(x As Module1.B3, y As Module1.B2) As Module1.B2': Not most specific.
        x = New B3() AndAlso New B2() 'BIND1:"New B3() AndAlso New B2()"
            ~~~~~~~~~~~~~~~~~~~~~~~~~
BC30521: Overload resolution failed because no accessible 'Or' is most specific for these arguments:
    'Public Shared Operator Module1.B3.Or(x As Module1.B3, y As Module1.B2) As Module1.B3': Not most specific.
    'Public Shared Operator Module1.B2.Or(x As Module1.B3, y As Module1.B2) As Module1.B2': Not most specific.
        x = New B3() OrElse New B2() 'BIND2:"New B3() OrElse New B2()"
            ~~~~~~~~~~~~~~~~~~~~~~~~
&lt;/expected&gt;)
   
            compilation.VerifyOperationTree(CompilationUtils.FindBindingText(Of ExpressionSyntax)(compilation, "a.vb", 1), expectedOperationTree:=
            &lt;![CDATA[
]]&gt;.Value)

            compilation.VerifyOperationTree(CompilationUtils.FindBindingText(Of ExpressionSyntax)(compilation, "a.vb", 2), expectedOperationTree:=
            &lt;![CDATA[
]]&gt;.Value)
        End Sub
```

Observed:
```
Test 'Microsoft.CodeAnalysis.VisualBasic.UnitTests.Semantics.UserDefinedBinaryOperators.ShortCircuiting5' failed: Microsoft.CodeAnalysis.ThrowingTraceListener+DebugAssertFailureException : 
System.InvalidCastException: Unable to cast object of type 'Microsoft.CodeAnalysis.VisualBasic.BoundBadExpression' to type 'Microsoft.CodeAnalysis.VisualBasic.BoundCall'.
   at Microsoft.CodeAnalysis.VisualBasic.BoundUserDefinedBinaryOperator.get_Call()
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.CreateBoundUserDefinedShortCircuitingOperatorOperation(BoundUserDefinedShortCircuitingOperator boundUserDefinedShortCircuitingOperator)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.CreateInternal(BoundNode boundNode)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory._Lambda$__3-0(BoundNode n)
   at System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(TKey key, Func`2 valueFactory)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.Create(BoundNode boundNode)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory._Closure$__121-0._Lambda$__2()
   at System.Lazy`1.CreateValue()
   at System.Lazy`1.LazyInitValue()
   at System.Lazy`1.get_Value()
   at Microsoft.CodeAnalysis.VisualBasic.LazyVisualBasicConversionExpression.get_OperandImpl()
   at Microsoft.CodeAnalysis.Operations.BaseConversionExpression.get_Operand()
   at Microsoft.CodeAnalysis.Operations.BaseConversionExpression.&lt;get_Children&gt;d__14.MoveNext()
   at Microsoft.CodeAnalysis.Operations.OperationExtensions.&lt;Descendants&gt;d__3.MoveNext()
   at System.Linq.Enumerable.FirstOrDefault[TSource](IEnumerable`1 source, Func`2 predicate)
   at Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.GetOperationWorker(VisualBasicSyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.GetOperationWorker(VisualBasicSyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetOperationCore(SyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.SemanticModel.GetOperation(SyntaxNode node, CancellationToken cancellationToken)

	at Microsoft.CodeAnalysis.ThrowingTraceListener.Fail(String message, String detailMessage)
	at System.Diagnostics.TraceListener.Fail(String message)
	at System.Diagnostics.TraceInternal.Fail(String message)
	at System.Diagnostics.Debug.Assert(Boolean condition, String message)
	at Microsoft.CodeAnalysis.SemanticModel.GetOperation(SyntaxNode node, CancellationToken cancellationToken)
	at Microsoft.CodeAnalysis.Test.Utilities.CompilationExtensions.AppendOperationTree(SemanticModel model, SyntaxNode node, StringBuilder actualTextBuilder, Int32 initialIndent)
	at Microsoft.CodeAnalysis.Test.Utilities.CompilationExtensions.VerifyOperationTree(Compilation compilation, SyntaxNode node, String expectedOperationTree)
	F:\GitHub\roslyn\src\Compilers\VisualBasic\Test\Semantic\Semantics\UserDefinedBinaryOperators.vb(590,0): at Microsoft.CodeAnalysis.VisualBasic.UnitTests.Semantics.UserDefinedBinaryOperators.ShortCircuiting5()
```
</Description>
        <CreatedDate>17/11/2017</CreatedDate>
        <ClosedDate>20/11/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/Core/Portable/Compilation/SemanticModel.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23237</IssueID>
    <Title>Change the 'Use auto property' code fixer to not be a 'compilation end' analyzer.</Title>
    <Description>Fixes #23216
Fixes #23215
Fixes #20855
Closes #23217

This PR changes the 'use auto property' code fixer to work as a Semantic-Model-Analyzer, instead of a Compilation-End analyzer.  Compilation-End-Analyzers are basically an unusable part of the analyzer API for code that wants to run in VS.  They are too expensive, and users can't interact with their results in a timely manner, like they can with normal analyzers.

As part of making this happen, I had to make a small change to the functionality of the feature.  Specifically, we used to determine if it was safe to make the change by analyzing all usages of a the field-to-remove in the project the feature was analyzing.  This was very expensive, but was necessary in case some code was using the field in an unexpected manner.  Now, we limit the feature to only private fields.  This means we can do that analysis in a timely manner, as we only have to examine the type it is contained in.  

This should have very little end user impact as the majority of user fields are private (esp. the ones that are paired with a property that you'd want ot make an auto prop out of).
</Description>
    <CreatedDate>17/11/2017</CreatedDate>
    <ClosedDate>20/11/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>23216</IssueID>
        <Title>IDE0032 (Use Auto Property) Fix All does not work</Title>
        <Description>**Version Used**: 15.5 Preview 3

🔗 Observed while investigating [this community report](https://developercommunity.visualstudio.com/content/problem/150002/ide0032-performs-less-than-ideal.html).

### Steps to Reproduce

1. Attempt to apply a Fix All operation to IDE0032 (Use Auto Property)

### Expected Behavior

Fix All, when available, fixes all instances of an issue within the specified context.

### Actual Behavior

Only one instance is fixed.

### Additional Details

* This behavior is observed even when Full Solution Analysis is enabled (see #23215)
* This behavior is observed even when IDE0032 is set to Warning severity</Description>
        <CreatedDate>16/11/2017</CreatedDate>
        <ClosedDate>20/11/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23215</IssueID>
        <Title>IDE0032 (Use Auto Property) does not work when full solution analysis is disabled</Title>
        <Description>**Version Used**: 15.5 Preview 3

🔗 Observed while investigating [this community report](https://developercommunity.visualstudio.com/content/problem/150002/ide0032-performs-less-than-ideal.html).

### Steps to Reproduce

1. Add a property:

    ```csharp
    private string _text;

    public string Text
    {
      get { return _text; }
      set { _text = value; }
    }
    ```

### Expected Behavior

The `_text` field is grayed (unnecessary code), and a code fix is provided to convert the field to an auto property.

### Actual Behavior

No suggestion is given.

### Additional details

If **Full Solution Analysis** is enabled, the feature works as expected. However, this feature is disabled both by default and by recommendation, with no plans to enable it. IDE analyzers cannot rely on this feature being enabled.</Description>
        <CreatedDate>16/11/2017</CreatedDate>
        <ClosedDate>20/11/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>20855</IssueID>
        <Title>IDE0032 Use Auto Property code fix mangles code in preexisting property with getter</Title>
        <Description>**Version Used**: d15rel 26711.00

**Steps to Reproduce**:

```
git clone https://github.com/microsoft/vs-threading.git
cd vs-threading
git checkout 0404d41776090ad54fd892081dcd1bd2b9165698
cd src
MSBuild /t:restore
.\Microsoft.VisualStudio.Threading.sln
```

1. Once in VS with the solution open, navigate to AsyncQueue.cs.
1. (I had netstandard1.1 selected as the language service context)
1. When the language service fades out the first field in the class (`syncObject`) activate the "Use Auto Property" code fix.

**Expected Behavior**:

No compile errors and no incorrect changes to code.

**Actual Behavior**:

The `SyncRoot` property which exposed the `syncObject` property is badly mangled. It was this:

```csharp
        protected object SyncRoot
        {
            get { return this.syncObject; }
        }
```

And was changed to this (including the comments, invalid syntax, etc.):

```csharp
        protected object SyncRoot {
/* Unmerged change from project 'Microsoft.VisualStudio.Threading(netstandard1.1)'
Before:
            get { return this.syncObject; }
After:
            get { return set; }
*/
 get; private this.SyncRoot; }
```

Note that there are absolutely no `#if` directives anywhere in the file. But this file is in a project that has 3 target frameworks.</Description>
        <CreatedDate>13/07/2017</CreatedDate>
        <ClosedDate>20/11/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23217</IssueID>
        <Title>Disable IDE0032 until it works</Title>
        <Description>**Version Used**: 15.5 Preview 3

🔗 Observed while investigating [this community report](https://developercommunity.visualstudio.com/content/problem/150002/ide0032-performs-less-than-ideal.html).

**Steps to Reproduce**:

1. Attempt to use the Use Auto Property diagnostic and code fix

**Expected Behavior**:

1. Code does not break
2. The code fix works
3. The fix all operation either work or is not provided

**Actual Behavior**:

I was unable to use this feature in any context and have it provide a meaningful result.

* The feature was not even visible without enabling a non-default (and not recommended) feature (#23215, #17857)
* The code was broken when the feature was used (#20855)
* The code fix didn't perform as expected (#23216)

This diagnostic needs to be disabled until it meets a reasonable quality bar.</Description>
        <CreatedDate>16/11/2017</CreatedDate>
        <ClosedDate>20/11/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharp/UseAutoProperty/UseAutoPropertyAnalyzer.cs</File>
      <File>src/EditorFeatures/CSharp/UseAutoProperty/UseAutoPropertyCodeFixProvider.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/UseAutoProperty/UseAutoPropertyTests.cs</File>
      <File>src/Features/Core/Portable/UseAutoProperty/AbstractUseAutoPropertyAnalyzer.cs</File>
      <File>src/Features/Core/Portable/UseAutoProperty/AbstractUseAutoPropertyCodeFixProvider.cs</File>
      <File>src/Workspaces/Core/Portable/Rename/Renamer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23224</IssueID>
    <Title>Fix an InvalidCastException in IOperation factory when a name of a range variable conflicts with another range variable.</Title>
    <Description>Fixes #23223.

**Customer scenario**

Request IOperation tree for a query expression like the one below:
```
Dim q As Object = From implicit In New Integer() {1, 2, 3} Let implicit = "1" Select implicit
```

An InvalidCastException is thrown by IOperation factory.

**Bugs this fixes:**

Fixes #23223.

**Workarounds, if any**

No

**Risk**

Low

**Performance impact**

Low perf impact because no extra allocations/no complexity changes

**Is this a regression from a previous update?**

No

**Root cause analysis:**

A test gap. Unit-tests are added.

**How was the bug found?**

Running existing compiler tests with IOperation validation test hook enabled.
</Description>
    <CreatedDate>16/11/2017</CreatedDate>
    <ClosedDate>17/11/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>23223</IssueID>
        <Title>An InvalidCastException is thrown when a name of range variable conflicts with another range variable</Title>
        <Description>```
        &lt;CompilerTrait(CompilerFeature.IOperation)&gt;
        Public Sub DuplicateRangeVariableName_IOperation()
            Dim source = &lt;![CDATA[
Option Strict Off
Imports System
Imports System.Linq

Module Module1
    Sub Main()
        Dim q As Object = From implicit In New Integer() {1, 2, 3} Let implicit = "1" Select implicit 'BIND:"From implicit In New Integer() {1, 2, 3} Let implicit = "1" Select implicit"
    End Sub
End Module]]&gt;.Value

            Dim expectedOperationTree = &lt;![CDATA[
]]&gt;.Value

            Dim expectedDiagnostics = &lt;![CDATA[
BC30978: Range variable 'implicit' hides a variable in an enclosing block or a range variable previously defined in the query expression.
        Dim q As Object = From implicit In New Integer() {1, 2, 3} Let implicit = "1" Select implicit 'BIND:"From implicit In New Integer() {1, 2, 3} Let implicit = "1" Select implicit"
                                                                       ~~~~~~~~
]]&gt;.Value

            VerifyOperationTreeAndDiagnosticsForTest(Of QueryExpressionSyntax)(source, expectedOperationTree, expectedDiagnostics)
        End Sub
```

Observed:
```
Test 'M:Microsoft.CodeAnalysis.VisualBasic.UnitTests.Semantics.QueryExpressions.DiplicateRangeVariableName_IOperation' failed:
	Unable to cast object of type 'Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PENamedTypeSymbolWithEmittedNamespaceName' to type 'AnonymousTypePublicSymbol'.
	System.InvalidCastException: Unable to cast object of type 'Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PENamedTypeSymbolWithEmittedNamespaceName' to type 'AnonymousTypePublicSymbol'.
	at Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.PopulateRangeVariableMapForAnonymousType(SyntaxNode syntax, BoundExpression anonymousTypeInstance, ImmutableArray`1 rangeVariables, Int32&amp; firstUnmappedRangeVariable, Dictionary`2 rangeVariableMap, Boolean inExpressionLambda)
	at Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.PopulateRangeVariableMapForAnonymousType(SyntaxNode syntax, BoundExpression anonymousTypeInstance, ImmutableArray`1 rangeVariables, Int32&amp; firstUnmappedRangeVariable, Dictionary`2 rangeVariableMap, Boolean inExpressionLambda)
	at Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.PopulateRangeVariableMapForQueryLambdaRewrite(BoundQueryLambda node, Dictionary`2&amp; rangeVariableMap, Boolean inExpressionLambda)
	at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.QueryLambdaRewriterPass1.VisitQueryLambda(BoundQueryLambda node)
	at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.RewriteQueryLambda(BoundQueryLambda node)
	at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.CreateInternal(BoundNode boundNode)
	at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory._Lambda$__3-0(BoundNode n)
	at System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(TKey key, Func`2 valueFactory)
	at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.Create(BoundNode boundNode)
	at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory._Closure$__121-0._Lambda$__1()
	at System.Lazy`1.CreateValue()
	at System.Lazy`1.LazyInitValue()
	at System.Lazy`1.get_Value()
	at Microsoft.CodeAnalysis.Operations.LazyDelegateCreationExpression.get_TargetImpl()
	at Microsoft.CodeAnalysis.Operations.BaseDelegateCreationExpression.get_Target()
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.VisitDelegateCreation(IDelegateCreationOperation operation)
	at Microsoft.CodeAnalysis.Operations.BaseDelegateCreationExpression.Accept(OperationVisitor visitor)
	at Microsoft.CodeAnalysis.Operations.OperationWalker.Visit(IOperation operation)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.Visit(IOperation operation)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.VisitArgument(IArgumentOperation operation)
	at Microsoft.CodeAnalysis.Operations.BaseArgument.Accept(OperationVisitor visitor)
	at Microsoft.CodeAnalysis.Operations.OperationWalker.Visit(IOperation operation)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.Visit(IOperation operation)
	at Microsoft.CodeAnalysis.Operations.OperationWalker.VisitOperationArrayElement[T](T operation)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.VisitArrayCommon[T](ImmutableArray`1 list, String header, Boolean logElementCount, Boolean logNullForDefault, Action`1 arrayElementVisitor)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.VisitArray[T](ImmutableArray`1 list, String header, Boolean logElementCount, Boolean logNullForDefault)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.VisitArguments(ImmutableArray`1 arguments)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.VisitInvocation(IInvocationOperation operation)
	at Microsoft.CodeAnalysis.Operations.BaseInvocationExpression.Accept(OperationVisitor visitor)
	at Microsoft.CodeAnalysis.Operations.OperationWalker.Visit(IOperation operation)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.Visit(IOperation operation)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.Visit(IOperation operation, String header)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.VisitTranslatedQuery(ITranslatedQueryOperation operation)
	at Microsoft.CodeAnalysis.Operations.BaseTranslatedQueryExpression.Accept(OperationVisitor visitor)
	at Microsoft.CodeAnalysis.Operations.OperationWalker.Visit(IOperation operation)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.Visit(IOperation operation)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.GetOperationTree(Compilation compilation, IOperation operation, Int32 initialIndent)
	at Microsoft.CodeAnalysis.VisualBasic.UnitTests.BasicTestBaseBase.GetOperationTreeForTest[TSyntaxNode](VisualBasicCompilation compilation, String fileName, Int32 which)
	at Microsoft.CodeAnalysis.VisualBasic.UnitTests.BasicTestBaseBase.VerifyOperationTreeForTest[TSyntaxNode](VisualBasicCompilation compilation, String fileName, String expectedOperationTree, Int32 which, Action`3 additionalOperationTreeVerifier)
	at Microsoft.CodeAnalysis.VisualBasic.UnitTests.BasicTestBaseBase.VerifyOperationTreeAndDiagnosticsForTest[TSyntaxNode](VisualBasicCompilation compilation, String fileName, String expectedOperationTree, String expectedDiagnostics, Int32 which, Action`3 additionalOperationTreeVerifier)
	at Microsoft.CodeAnalysis.VisualBasic.UnitTests.BasicTestBaseBase.VerifyOperationTreeAndDiagnosticsForTest[TSyntaxNode](String testSrc, String expectedOperationTree, String expectedDiagnostics, VisualBasicCompilationOptions compilationOptions, VisualBasicParseOptions parseOptions, Int32 which, IEnumerable`1 additionalReferences, Action`3 additionalOperationTreeVerifier, Boolean useLatestFramework)
	F:\GitHub\roslyn\src\Compilers\VisualBasic\Test\Semantic\Semantics\QueryExpressions.vb(14736,0): at Microsoft.CodeAnalysis.VisualBasic.UnitTests.Semantics.QueryExpressions.DiplicateRangeVariableName_IOperation()
```</Description>
        <CreatedDate>16/11/2017</CreatedDate>
        <ClosedDate>20/11/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23223</IssueID>
        <Title>An InvalidCastException is thrown when a name of range variable conflicts with another range variable</Title>
        <Description>```
        &lt;CompilerTrait(CompilerFeature.IOperation)&gt;
        Public Sub DuplicateRangeVariableName_IOperation()
            Dim source = &lt;![CDATA[
Option Strict Off
Imports System
Imports System.Linq

Module Module1
    Sub Main()
        Dim q As Object = From implicit In New Integer() {1, 2, 3} Let implicit = "1" Select implicit 'BIND:"From implicit In New Integer() {1, 2, 3} Let implicit = "1" Select implicit"
    End Sub
End Module]]&gt;.Value

            Dim expectedOperationTree = &lt;![CDATA[
]]&gt;.Value

            Dim expectedDiagnostics = &lt;![CDATA[
BC30978: Range variable 'implicit' hides a variable in an enclosing block or a range variable previously defined in the query expression.
        Dim q As Object = From implicit In New Integer() {1, 2, 3} Let implicit = "1" Select implicit 'BIND:"From implicit In New Integer() {1, 2, 3} Let implicit = "1" Select implicit"
                                                                       ~~~~~~~~
]]&gt;.Value

            VerifyOperationTreeAndDiagnosticsForTest(Of QueryExpressionSyntax)(source, expectedOperationTree, expectedDiagnostics)
        End Sub
```

Observed:
```
Test 'M:Microsoft.CodeAnalysis.VisualBasic.UnitTests.Semantics.QueryExpressions.DiplicateRangeVariableName_IOperation' failed:
	Unable to cast object of type 'Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PENamedTypeSymbolWithEmittedNamespaceName' to type 'AnonymousTypePublicSymbol'.
	System.InvalidCastException: Unable to cast object of type 'Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PENamedTypeSymbolWithEmittedNamespaceName' to type 'AnonymousTypePublicSymbol'.
	at Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.PopulateRangeVariableMapForAnonymousType(SyntaxNode syntax, BoundExpression anonymousTypeInstance, ImmutableArray`1 rangeVariables, Int32&amp; firstUnmappedRangeVariable, Dictionary`2 rangeVariableMap, Boolean inExpressionLambda)
	at Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.PopulateRangeVariableMapForAnonymousType(SyntaxNode syntax, BoundExpression anonymousTypeInstance, ImmutableArray`1 rangeVariables, Int32&amp; firstUnmappedRangeVariable, Dictionary`2 rangeVariableMap, Boolean inExpressionLambda)
	at Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.PopulateRangeVariableMapForQueryLambdaRewrite(BoundQueryLambda node, Dictionary`2&amp; rangeVariableMap, Boolean inExpressionLambda)
	at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.QueryLambdaRewriterPass1.VisitQueryLambda(BoundQueryLambda node)
	at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.RewriteQueryLambda(BoundQueryLambda node)
	at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.CreateInternal(BoundNode boundNode)
	at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory._Lambda$__3-0(BoundNode n)
	at System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(TKey key, Func`2 valueFactory)
	at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.Create(BoundNode boundNode)
	at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory._Closure$__121-0._Lambda$__1()
	at System.Lazy`1.CreateValue()
	at System.Lazy`1.LazyInitValue()
	at System.Lazy`1.get_Value()
	at Microsoft.CodeAnalysis.Operations.LazyDelegateCreationExpression.get_TargetImpl()
	at Microsoft.CodeAnalysis.Operations.BaseDelegateCreationExpression.get_Target()
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.VisitDelegateCreation(IDelegateCreationOperation operation)
	at Microsoft.CodeAnalysis.Operations.BaseDelegateCreationExpression.Accept(OperationVisitor visitor)
	at Microsoft.CodeAnalysis.Operations.OperationWalker.Visit(IOperation operation)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.Visit(IOperation operation)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.VisitArgument(IArgumentOperation operation)
	at Microsoft.CodeAnalysis.Operations.BaseArgument.Accept(OperationVisitor visitor)
	at Microsoft.CodeAnalysis.Operations.OperationWalker.Visit(IOperation operation)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.Visit(IOperation operation)
	at Microsoft.CodeAnalysis.Operations.OperationWalker.VisitOperationArrayElement[T](T operation)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.VisitArrayCommon[T](ImmutableArray`1 list, String header, Boolean logElementCount, Boolean logNullForDefault, Action`1 arrayElementVisitor)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.VisitArray[T](ImmutableArray`1 list, String header, Boolean logElementCount, Boolean logNullForDefault)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.VisitArguments(ImmutableArray`1 arguments)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.VisitInvocation(IInvocationOperation operation)
	at Microsoft.CodeAnalysis.Operations.BaseInvocationExpression.Accept(OperationVisitor visitor)
	at Microsoft.CodeAnalysis.Operations.OperationWalker.Visit(IOperation operation)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.Visit(IOperation operation)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.Visit(IOperation operation, String header)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.VisitTranslatedQuery(ITranslatedQueryOperation operation)
	at Microsoft.CodeAnalysis.Operations.BaseTranslatedQueryExpression.Accept(OperationVisitor visitor)
	at Microsoft.CodeAnalysis.Operations.OperationWalker.Visit(IOperation operation)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.Visit(IOperation operation)
	at Microsoft.CodeAnalysis.Test.Utilities.OperationTreeVerifier.GetOperationTree(Compilation compilation, IOperation operation, Int32 initialIndent)
	at Microsoft.CodeAnalysis.VisualBasic.UnitTests.BasicTestBaseBase.GetOperationTreeForTest[TSyntaxNode](VisualBasicCompilation compilation, String fileName, Int32 which)
	at Microsoft.CodeAnalysis.VisualBasic.UnitTests.BasicTestBaseBase.VerifyOperationTreeForTest[TSyntaxNode](VisualBasicCompilation compilation, String fileName, String expectedOperationTree, Int32 which, Action`3 additionalOperationTreeVerifier)
	at Microsoft.CodeAnalysis.VisualBasic.UnitTests.BasicTestBaseBase.VerifyOperationTreeAndDiagnosticsForTest[TSyntaxNode](VisualBasicCompilation compilation, String fileName, String expectedOperationTree, String expectedDiagnostics, Int32 which, Action`3 additionalOperationTreeVerifier)
	at Microsoft.CodeAnalysis.VisualBasic.UnitTests.BasicTestBaseBase.VerifyOperationTreeAndDiagnosticsForTest[TSyntaxNode](String testSrc, String expectedOperationTree, String expectedDiagnostics, VisualBasicCompilationOptions compilationOptions, VisualBasicParseOptions parseOptions, Int32 which, IEnumerable`1 additionalReferences, Action`3 additionalOperationTreeVerifier, Boolean useLatestFramework)
	F:\GitHub\roslyn\src\Compilers\VisualBasic\Test\Semantic\Semantics\QueryExpressions.vb(14736,0): at Microsoft.CodeAnalysis.VisualBasic.UnitTests.Semantics.QueryExpressions.DiplicateRangeVariableName_IOperation()
```</Description>
        <CreatedDate>16/11/2017</CreatedDate>
        <ClosedDate>20/11/2017</ClosedDate>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>23206</IssueID>
    <Title>Fix an InvalidCastException in IOperation factory when a user defined conversions involves an integer overflow.</Title>
    <Description>Fixes #23203.

**Customer scenario**

Request IOperation tree for a variable initializer like the one below:
```
Module Module1

    Class C1
        Shared Widening Operator CType(x As Byte) As C1
            Return Nothing
        End Operator
    End Class

    Sub Main()
        Dim z1 As C1 = &amp;H7FFFFFFFL 'BIND:"= &amp;H7FFFFFFFL"
    End Sub
End Module
```

An InvalidCastException is thrown by IOperation factory.

**Bugs this fixes:**

Fixes #23203.

**Workarounds, if any**

No

**Risk**

Low

**Performance impact**

Low perf impact because no extra allocations/no complexity changes

**Is this a regression from a previous update?**

No

**Root cause analysis:**

A test gap. Unit-tests are added.

**How was the bug found?**

Running existing compiler tests with IOperation validation test hook enabled.
</Description>
    <CreatedDate>16/11/2017</CreatedDate>
    <ClosedDate>17/11/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>23203</IssueID>
        <Title>InvalidCastException is thrown when user defined conversions involves integer overflow</Title>
        <Description>```
        &lt;CompilerTrait(CompilerFeature.IOperation)&gt;
        &lt;Fact&gt;
        Public Sub ConversionExpression_IntegerOverflow()
            Dim source = &lt;![CDATA[
Imports System

Module Module1

    Class C1
        Shared Widening Operator CType(x As Byte) As C1
            Return Nothing
        End Operator
    End Class

    Sub Main()

        Dim z1 As C1 = &amp;H7FFFFFFFL 'BIND:"= &amp;H7FFFFFFFL"
    End Sub
End Module
]]&gt;.Value


            Dim expectedOperationTree = &lt;![CDATA[
]]&gt;.Value

            Dim expectedDiagnostics = &lt;![CDATA[
BC30439: Constant expression not representable in type 'Byte'.
        Dim z1 As C1 = &amp;H7FFFFFFFL 'BIND:"= &amp;H7FFFFFFFL"
                       ~~~~~~~~~~~
]]&gt;.Value

            VerifyOperationTreeAndDiagnosticsForTest(Of EqualsValueSyntax)(source, expectedOperationTree, expectedDiagnostics)
        End Sub
```

Observed:
```
Test 'Microsoft.CodeAnalysis.VisualBasic.UnitTests.Semantics.IOperationTests.ConversionExpression_IntegerOverflow' failed:
	Microsoft.CodeAnalysis.ThrowingTraceListener+DebugAssertFailureException : System.InvalidCastException: Unable to cast object of type 'Microsoft.CodeAnalysis.VisualBasic.BoundLiteral' to type 'Microsoft.CodeAnalysis.VisualBasic.BoundUserDefinedConversion'.
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.GetConversionInfo(BoundConversion boundConversion)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.CreateBoundConversionOperation(BoundConversion boundConversion)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.CreateInternal(BoundNode boundNode)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory._Lambda$__3-0(BoundNode n)
   at System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(TKey key, Func`2 valueFactory)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.Create(BoundNode boundNode)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.GetVariableDeclarationStatementVariables(ImmutableArray`1 declarations)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory._Closure$__73-0._Lambda$__0()
   at System.Lazy`1.CreateValue()
   at System.Lazy`1.LazyInitValue()
   at System.Lazy`1.get_Value()
   at Microsoft.CodeAnalysis.Operations.LazyVariableDeclarationGroupOperation.get_DeclarationsImpl()
   at Microsoft.CodeAnalysis.Operations.BaseVariableDeclarationGroupOperation.get_Declarations()
   at Microsoft.CodeAnalysis.Operations.BaseVariableDeclarationGroupOperation.&lt;get_Children&gt;d__4.MoveNext()
   at Microsoft.CodeAnalysis.Operations.OperationExtensions.&lt;Descendants&gt;d__3.MoveNext()
   at System.Linq.Enumerable.FirstOrDefault[TSource](IEnumerable`1 source, Func`2 predicate)
   at Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.GetOperationWorker(VisualBasicSyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.GetOperationWorker(VisualBasicSyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetOperationCore(SyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.SemanticModel.GetOperation(SyntaxNode node, CancellationToken cancellationToken)

	at Microsoft.CodeAnalysis.ThrowingTraceListener.Fail(String message, String detailMessage)
	at System.Diagnostics.TraceListener.Fail(String message)
	at System.Diagnostics.TraceInternal.Fail(String message)
	at System.Diagnostics.Debug.Assert(Boolean condition, String message)
	at Microsoft.CodeAnalysis.SemanticModel.GetOperation(SyntaxNode node, CancellationToken cancellationToken)
	at Microsoft.CodeAnalysis.VisualBasic.UnitTests.BasicTestBaseBase.GetOperationTreeForTest[TSyntaxNode](VisualBasicCompilation compilation, String fileName, Int32 which)
	at Microsoft.CodeAnalysis.VisualBasic.UnitTests.BasicTestBaseBase.VerifyOperationTreeForTest[TSyntaxNode](VisualBasicCompilation compilation, String fileName, String expectedOperationTree, Int32 which, Action`3 additionalOperationTreeVerifier)
	at Microsoft.CodeAnalysis.VisualBasic.UnitTests.BasicTestBaseBase.VerifyOperationTreeAndDiagnosticsForTest[TSyntaxNode](VisualBasicCompilation compilation, String fileName, String expectedOperationTree, String expectedDiagnostics, Int32 which, Action`3 additionalOperationTreeVerifier)
	at Microsoft.CodeAnalysis.VisualBasic.UnitTests.BasicTestBaseBase.VerifyOperationTreeAndDiagnosticsForTest[TSyntaxNode](String testSrc, String expectedOperationTree, String expectedDiagnostics, VisualBasicCompilationOptions compilationOptions, VisualBasicParseOptions parseOptions, Int32 which, IEnumerable`1 additionalReferences, Action`3 additionalOperationTreeVerifier, Boolean useLatestFramework)
	F:\GitHub\roslyn\src\Compilers\VisualBasic\Test\Semantic\IOperation\IOperationTests_IConversionExpression.vb(3027,0): at Microsoft.CodeAnalysis.VisualBasic.UnitTests.Semantics.IOperationTests.ConversionExpression_IntegerOverflow()
```</Description>
        <CreatedDate>15/11/2017</CreatedDate>
        <ClosedDate>20/11/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23203</IssueID>
        <Title>InvalidCastException is thrown when user defined conversions involves integer overflow</Title>
        <Description>```
        &lt;CompilerTrait(CompilerFeature.IOperation)&gt;
        &lt;Fact&gt;
        Public Sub ConversionExpression_IntegerOverflow()
            Dim source = &lt;![CDATA[
Imports System

Module Module1

    Class C1
        Shared Widening Operator CType(x As Byte) As C1
            Return Nothing
        End Operator
    End Class

    Sub Main()

        Dim z1 As C1 = &amp;H7FFFFFFFL 'BIND:"= &amp;H7FFFFFFFL"
    End Sub
End Module
]]&gt;.Value


            Dim expectedOperationTree = &lt;![CDATA[
]]&gt;.Value

            Dim expectedDiagnostics = &lt;![CDATA[
BC30439: Constant expression not representable in type 'Byte'.
        Dim z1 As C1 = &amp;H7FFFFFFFL 'BIND:"= &amp;H7FFFFFFFL"
                       ~~~~~~~~~~~
]]&gt;.Value

            VerifyOperationTreeAndDiagnosticsForTest(Of EqualsValueSyntax)(source, expectedOperationTree, expectedDiagnostics)
        End Sub
```

Observed:
```
Test 'Microsoft.CodeAnalysis.VisualBasic.UnitTests.Semantics.IOperationTests.ConversionExpression_IntegerOverflow' failed:
	Microsoft.CodeAnalysis.ThrowingTraceListener+DebugAssertFailureException : System.InvalidCastException: Unable to cast object of type 'Microsoft.CodeAnalysis.VisualBasic.BoundLiteral' to type 'Microsoft.CodeAnalysis.VisualBasic.BoundUserDefinedConversion'.
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.GetConversionInfo(BoundConversion boundConversion)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.CreateBoundConversionOperation(BoundConversion boundConversion)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.CreateInternal(BoundNode boundNode)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory._Lambda$__3-0(BoundNode n)
   at System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(TKey key, Func`2 valueFactory)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.Create(BoundNode boundNode)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory.GetVariableDeclarationStatementVariables(ImmutableArray`1 declarations)
   at Microsoft.CodeAnalysis.Operations.VisualBasicOperationFactory._Closure$__73-0._Lambda$__0()
   at System.Lazy`1.CreateValue()
   at System.Lazy`1.LazyInitValue()
   at System.Lazy`1.get_Value()
   at Microsoft.CodeAnalysis.Operations.LazyVariableDeclarationGroupOperation.get_DeclarationsImpl()
   at Microsoft.CodeAnalysis.Operations.BaseVariableDeclarationGroupOperation.get_Declarations()
   at Microsoft.CodeAnalysis.Operations.BaseVariableDeclarationGroupOperation.&lt;get_Children&gt;d__4.MoveNext()
   at Microsoft.CodeAnalysis.Operations.OperationExtensions.&lt;Descendants&gt;d__3.MoveNext()
   at System.Linq.Enumerable.FirstOrDefault[TSource](IEnumerable`1 source, Func`2 predicate)
   at Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel.GetOperationWorker(VisualBasicSyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel.GetOperationWorker(VisualBasicSyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel.GetOperationCore(SyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.SemanticModel.GetOperation(SyntaxNode node, CancellationToken cancellationToken)

	at Microsoft.CodeAnalysis.ThrowingTraceListener.Fail(String message, String detailMessage)
	at System.Diagnostics.TraceListener.Fail(String message)
	at System.Diagnostics.TraceInternal.Fail(String message)
	at System.Diagnostics.Debug.Assert(Boolean condition, String message)
	at Microsoft.CodeAnalysis.SemanticModel.GetOperation(SyntaxNode node, CancellationToken cancellationToken)
	at Microsoft.CodeAnalysis.VisualBasic.UnitTests.BasicTestBaseBase.GetOperationTreeForTest[TSyntaxNode](VisualBasicCompilation compilation, String fileName, Int32 which)
	at Microsoft.CodeAnalysis.VisualBasic.UnitTests.BasicTestBaseBase.VerifyOperationTreeForTest[TSyntaxNode](VisualBasicCompilation compilation, String fileName, String expectedOperationTree, Int32 which, Action`3 additionalOperationTreeVerifier)
	at Microsoft.CodeAnalysis.VisualBasic.UnitTests.BasicTestBaseBase.VerifyOperationTreeAndDiagnosticsForTest[TSyntaxNode](VisualBasicCompilation compilation, String fileName, String expectedOperationTree, String expectedDiagnostics, Int32 which, Action`3 additionalOperationTreeVerifier)
	at Microsoft.CodeAnalysis.VisualBasic.UnitTests.BasicTestBaseBase.VerifyOperationTreeAndDiagnosticsForTest[TSyntaxNode](String testSrc, String expectedOperationTree, String expectedDiagnostics, VisualBasicCompilationOptions compilationOptions, VisualBasicParseOptions parseOptions, Int32 which, IEnumerable`1 additionalReferences, Action`3 additionalOperationTreeVerifier, Boolean useLatestFramework)
	F:\GitHub\roslyn\src\Compilers\VisualBasic\Test\Semantic\IOperation\IOperationTests_IConversionExpression.vb(3027,0): at Microsoft.CodeAnalysis.VisualBasic.UnitTests.Semantics.IOperationTests.ConversionExpression_IntegerOverflow()
```</Description>
        <CreatedDate>15/11/2017</CreatedDate>
        <ClosedDate>20/11/2017</ClosedDate>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>23170</IssueID>
    <Title>Do not expose type expression as IDynamicMemberReferenceOperation.Instance</Title>
    <Description>Related to #22548 and #22229.
</Description>
    <CreatedDate>14/11/2017</CreatedDate>
    <ClosedDate>15/11/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>22548</IssueID>
        <Title>Follow up on isImplicit mismatch </Title>
        <Description>Address feedback from https://github.com/dotnet/roslyn/pull/22309 </Description>
        <CreatedDate>05/10/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22229</IssueID>
        <Title>IsImplicit for multiple operation nodes with same syntax</Title>
        <Description>we want to make sure there is only one explicit IOperation when multiple IOperations are pointing to same syntax node.

right now, we have case such as this (https://github.com/dotnet/roslyn/pull/21857#pullrequestreview-64081939 or https://github.com/dotnet/roslyn/pull/21857#issuecomment-330950924) where InvalidExpression is pointing to same syntax node as its child. or ExpressionStatement pointing to same syntax node as its expression (ex, expression lambda body)

we need to decide whether we want to mark those as implicit or not. if we do, those IOperation will not be returned by GetOperation. but user can still get to that operation through parent and children.
</Description>
        <CreatedDate>20/09/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Invocation.cs</File>
      <File>src/Compilers/CSharp/Portable/Operations/CSharpOperationFactory.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IDynamicInvocationExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IUsingStatement.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IDynamicMemberReferenceOperation.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23162</IssueID>
    <Title>Fix NullReferenceException thrown while building IOperation node for dynamic object member initializer.</Title>
    <Description>Fixes #23154.
VSO Bug https://devdiv.visualstudio.com/DevDiv/_workitems?id=524873

**Customer scenario**

Request IOperation tree for an object creation expression like the one below:
```
        dynamic x = 1;
        var a = new A {[y: x, x: x] = { X = 1} };
...
class A
{
    dynamic this[int x, int y]
    {
        get
        {
            return new A();
        }
    }

    dynamic this[string x, string y]
    {
        get
        {
            return null;
        }
    }

    int X, Y, Z;
}
```

A null reference exception is thrown by IOperation factory.

**Bugs this fixes:**

Fixes #23154.
VSO Bug https://devdiv.visualstudio.com/DevDiv/_workitems?id=524873

**Workarounds, if any**

No

**Risk**

Low

**Performance impact**

Low perf impact because no extra allocations/no complexity changes

**Is this a regression from a previous update?**

No

**Root cause analysis:**

A test gap. Unit-tests are added.

**How was the bug found?**

Running existing compiler tests with IOperation validation test hook enabled.
</Description>
    <CreatedDate>14/11/2017</CreatedDate>
    <ClosedDate>16/11/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>23154</IssueID>
        <Title>System.NullReferenceException is thrown for dynamic object member initializer</Title>
        <Description>```
        [CompilerTrait(CompilerFeature.IOperation)]
        [Fact]
        public void ObjectCreationWithDynamicMemberInitializer_01()
        {
            string source = @"
class A
{
    dynamic this[int x, int y]
    {
        get
        {
            return new A();
        }
    }

    dynamic this[string x, string y]
    {
        get
        {
            throw null;
        }
    }

    int X, Y, Z;

    static void Main()
    {
        dynamic x = 1;
        new A {/*&lt;bind&gt;*/[y: x, x: x] = { X = 1, Y = 1, Z = 1 }/*&lt;/bind&gt;*/ };
    }
}
";
            string expectedOperationTree = @"
";
            var expectedDiagnostics = DiagnosticDescription.None;

            VerifyOperationTreeAndDiagnosticsForTest&lt;AssignmentExpressionSyntax&gt;(source, expectedOperationTree, expectedDiagnostics);
        }

```

Observed:
```
Test 'Microsoft.CodeAnalysis.CSharp.UnitTests.IOperationTests.ObjectCreationWithDynamicMemberInitializer_01' failed: Microsoft.CodeAnalysis.ThrowingTraceListener+DebugAssertFailureException : System.NullReferenceException: Object reference not set to an instance of an object.
   at Microsoft.CodeAnalysis.Operations.CSharpOperationFactory.CreateBoundObjectInitializerMemberOperation(BoundObjectInitializerMember boundObjectInitializerMember)
   at Microsoft.CodeAnalysis.Operations.CSharpOperationFactory.CreateInternal(BoundNode boundNode)
   at Microsoft.CodeAnalysis.Operations.CSharpOperationFactory.&lt;Create&gt;b__3_0(BoundNode n)
   at System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(TKey key, Func`2 valueFactory)
   at Microsoft.CodeAnalysis.Operations.CSharpOperationFactory.Create(BoundNode boundNode)
   at Microsoft.CodeAnalysis.Operations.CSharpOperationFactory.&lt;&gt;c__DisplayClass49_0.&lt;CreateBoundMemberInitializerOperation&gt;b__0()
   at System.Lazy`1.CreateValue()
   at System.Lazy`1.LazyInitValue()
   at System.Lazy`1.get_Value()
   at Microsoft.CodeAnalysis.Operations.LazyMemberInitializerExpression.get_InitializedMemberImpl()
   at Microsoft.CodeAnalysis.Operations.BaseMemberInitializerExpression.get_InitializedMember()
   at Microsoft.CodeAnalysis.Operations.BaseMemberInitializerExpression.&lt;get_Children&gt;d__6.MoveNext()
   at Microsoft.CodeAnalysis.Operations.OperationExtensions.&lt;Descendants&gt;d__3.MoveNext()
   at System.Linq.Enumerable.FirstOrDefault[TSource](IEnumerable`1 source, Func`2 predicate)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetOperationWorker(CSharpSyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetOperationCore(SyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.SemanticModel.GetOperation(SyntaxNode node, CancellationToken cancellationToken)

	at Microsoft.CodeAnalysis.ThrowingTraceListener.Fail(String message, String detailMessage)
	at System.Diagnostics.TraceListener.Fail(String message)
	at System.Diagnostics.TraceInternal.Fail(String message)
	at System.Diagnostics.Debug.Assert(Boolean condition, String message)
	at Microsoft.CodeAnalysis.SemanticModel.GetOperation(SyntaxNode node, CancellationToken cancellationToken)
	at Microsoft.CodeAnalysis.Operation.SearchParentOperation()
	at Microsoft.CodeAnalysis.Operation.get_Parent()
	at Microsoft.CodeAnalysis.Test.Utilities.CompilationExtensions.ValidateIOperations(Func`1 createCompilation)
	at Microsoft.CodeAnalysis.CSharp.Test.Utilities.CSharpTestBaseBase.CreateCompilation(IEnumerable`1 trees, IEnumerable`1 references, CSharpCompilationOptions options, String assemblyName)
	at Microsoft.CodeAnalysis.CSharp.Test.Utilities.CSharpTestBaseBase.CreateStandardCompilation(IEnumerable`1 trees, IEnumerable`1 references, CSharpCompilationOptions options, String assemblyName)
	at Microsoft.CodeAnalysis.CSharp.Test.Utilities.CSharpTestBaseBase.CreateStandardCompilation(String text, IEnumerable`1 references, CSharpCompilationOptions options, CSharpParseOptions parseOptions, String assemblyName, String sourceFileName)
	at Microsoft.CodeAnalysis.CSharp.Test.Utilities.CSharpTestBaseBase.VerifyOperationTreeAndDiagnosticsForTest[TSyntaxNode](String testSrc, String expectedOperationTree, DiagnosticDescription[] expectedDiagnostics, CSharpCompilationOptions compilationOptions, CSharpParseOptions parseOptions, MetadataReference[] additionalReferences, Action`3 additionalOperationTreeVerifier, Boolean useLatestFrameworkReferences)
	F:\GitHub\roslyn\src\Compilers\CSharp\Test\Semantic\IOperation\IOperationTests_IObjectCreationExpression.cs(644,0): at Microsoft.CodeAnalysis.CSharp.UnitTests.IOperationTests.ObjectCreationWithDynamicMemberInitializer_01()
```</Description>
        <CreatedDate>14/11/2017</CreatedDate>
        <ClosedDate>16/11/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>23154</IssueID>
        <Title>System.NullReferenceException is thrown for dynamic object member initializer</Title>
        <Description>```
        [CompilerTrait(CompilerFeature.IOperation)]
        [Fact]
        public void ObjectCreationWithDynamicMemberInitializer_01()
        {
            string source = @"
class A
{
    dynamic this[int x, int y]
    {
        get
        {
            return new A();
        }
    }

    dynamic this[string x, string y]
    {
        get
        {
            throw null;
        }
    }

    int X, Y, Z;

    static void Main()
    {
        dynamic x = 1;
        new A {/*&lt;bind&gt;*/[y: x, x: x] = { X = 1, Y = 1, Z = 1 }/*&lt;/bind&gt;*/ };
    }
}
";
            string expectedOperationTree = @"
";
            var expectedDiagnostics = DiagnosticDescription.None;

            VerifyOperationTreeAndDiagnosticsForTest&lt;AssignmentExpressionSyntax&gt;(source, expectedOperationTree, expectedDiagnostics);
        }

```

Observed:
```
Test 'Microsoft.CodeAnalysis.CSharp.UnitTests.IOperationTests.ObjectCreationWithDynamicMemberInitializer_01' failed: Microsoft.CodeAnalysis.ThrowingTraceListener+DebugAssertFailureException : System.NullReferenceException: Object reference not set to an instance of an object.
   at Microsoft.CodeAnalysis.Operations.CSharpOperationFactory.CreateBoundObjectInitializerMemberOperation(BoundObjectInitializerMember boundObjectInitializerMember)
   at Microsoft.CodeAnalysis.Operations.CSharpOperationFactory.CreateInternal(BoundNode boundNode)
   at Microsoft.CodeAnalysis.Operations.CSharpOperationFactory.&lt;Create&gt;b__3_0(BoundNode n)
   at System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(TKey key, Func`2 valueFactory)
   at Microsoft.CodeAnalysis.Operations.CSharpOperationFactory.Create(BoundNode boundNode)
   at Microsoft.CodeAnalysis.Operations.CSharpOperationFactory.&lt;&gt;c__DisplayClass49_0.&lt;CreateBoundMemberInitializerOperation&gt;b__0()
   at System.Lazy`1.CreateValue()
   at System.Lazy`1.LazyInitValue()
   at System.Lazy`1.get_Value()
   at Microsoft.CodeAnalysis.Operations.LazyMemberInitializerExpression.get_InitializedMemberImpl()
   at Microsoft.CodeAnalysis.Operations.BaseMemberInitializerExpression.get_InitializedMember()
   at Microsoft.CodeAnalysis.Operations.BaseMemberInitializerExpression.&lt;get_Children&gt;d__6.MoveNext()
   at Microsoft.CodeAnalysis.Operations.OperationExtensions.&lt;Descendants&gt;d__3.MoveNext()
   at System.Linq.Enumerable.FirstOrDefault[TSource](IEnumerable`1 source, Func`2 predicate)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetOperationWorker(CSharpSyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetOperationCore(SyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.SemanticModel.GetOperation(SyntaxNode node, CancellationToken cancellationToken)

	at Microsoft.CodeAnalysis.ThrowingTraceListener.Fail(String message, String detailMessage)
	at System.Diagnostics.TraceListener.Fail(String message)
	at System.Diagnostics.TraceInternal.Fail(String message)
	at System.Diagnostics.Debug.Assert(Boolean condition, String message)
	at Microsoft.CodeAnalysis.SemanticModel.GetOperation(SyntaxNode node, CancellationToken cancellationToken)
	at Microsoft.CodeAnalysis.Operation.SearchParentOperation()
	at Microsoft.CodeAnalysis.Operation.get_Parent()
	at Microsoft.CodeAnalysis.Test.Utilities.CompilationExtensions.ValidateIOperations(Func`1 createCompilation)
	at Microsoft.CodeAnalysis.CSharp.Test.Utilities.CSharpTestBaseBase.CreateCompilation(IEnumerable`1 trees, IEnumerable`1 references, CSharpCompilationOptions options, String assemblyName)
	at Microsoft.CodeAnalysis.CSharp.Test.Utilities.CSharpTestBaseBase.CreateStandardCompilation(IEnumerable`1 trees, IEnumerable`1 references, CSharpCompilationOptions options, String assemblyName)
	at Microsoft.CodeAnalysis.CSharp.Test.Utilities.CSharpTestBaseBase.CreateStandardCompilation(String text, IEnumerable`1 references, CSharpCompilationOptions options, CSharpParseOptions parseOptions, String assemblyName, String sourceFileName)
	at Microsoft.CodeAnalysis.CSharp.Test.Utilities.CSharpTestBaseBase.VerifyOperationTreeAndDiagnosticsForTest[TSyntaxNode](String testSrc, String expectedOperationTree, DiagnosticDescription[] expectedDiagnostics, CSharpCompilationOptions compilationOptions, CSharpParseOptions parseOptions, MetadataReference[] additionalReferences, Action`3 additionalOperationTreeVerifier, Boolean useLatestFrameworkReferences)
	F:\GitHub\roslyn\src\Compilers\CSharp\Test\Semantic\IOperation\IOperationTests_IObjectCreationExpression.cs(644,0): at Microsoft.CodeAnalysis.CSharp.UnitTests.IOperationTests.ObjectCreationWithDynamicMemberInitializer_01()
```</Description>
        <CreatedDate>14/11/2017</CreatedDate>
        <ClosedDate>16/11/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Operations/CSharpOperationFactory.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IObjectCreationExpression.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23141</IssueID>
    <Title>Clean-up IOperation tree representing tuple literal conversions.</Title>
    <Description>Related to #22548 and #22229.

There are several issues with IOperation tree when it comes to conversions applied to tuple literals:
1. When conversion is explicitly specified in code, it is translated to conversions on individual
elements of the literal and these BoundConversion nodes are also marked as explicitly
specified in code (which makes sense). However, the syntax associated with a BoundConversion
node on top of an element matches the syntax of the element (which also makes sense).
The problem is that both the conversion node and the element appear as “explicit” in
IOperation tree, which violates one of the tree invariants – at most one “explicit” node for
a given syntax node.
2. When a tuple literal is converted, compiler creates a BoundConvertedTupleLiteral node,
which has the target tuple type as its Type, but the BoundConversion node on top of the
BoundConvertedTupleLiteral captures conversion information (kind, etc.) for conversion
From tuple’s natural type to the target type. So, often, we end up with both nodes having
The same Type, but the conversion says it is not an identity conversion. This shape helps
SemanticModel to provide accurate information about types and conversions, but the
IOperation tree looks very confusing.
3. When conversion is explicitly specified in code, the BoundConversion node from the
previous item is marked as explicitly specified in code, but it shares syntax node with
BoundConvertedTupleLiteral. Both nodes appear as “explicit” in IOperation tree, which
violates the same invariant.
4. When conversion is explicitly specified in code, compiler adds yet another explicit
Identity conversion on top of the BoundConversion node from the previous item.
It is needed for proper SemanticModel behavior. Even when it uses different syntax,
the IOperation tree looks very confusing, there are two conversions on top of each other
and it is not clear why intermediate conversion node is needed.

In order to address all these issue the following changes are made to IOperation factory:
- If conversion node is associated with the same syntax as its operand, the conversion
is marked as isImplicit.
- If Type of BoundConvertedTupleLiteral matches the Type of BoundConversion node
on top of it the conversion node is not added to the IOperation tree. Instead a new property
is added to ITupleOperation interface, called NaturalType. The property exposes the natural
type of the tuple literal and makes it easy for consumers to figure out if a conversion from
a natural type of a tuple literal took place.
-  If Type of BoundConvertedTupleLiteral doesn’t match the Type of BoundConversion node
on top of it and there is an identity conversion node on top of the BoundConversion node,
the intermediate conversion node is not added to the IOperation tree, its conversion
information is used for the top-most conversion node (instead of saying that it is identity).
</Description>
    <CreatedDate>13/11/2017</CreatedDate>
    <ClosedDate>15/11/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>22548</IssueID>
        <Title>Follow up on isImplicit mismatch </Title>
        <Description>Address feedback from https://github.com/dotnet/roslyn/pull/22309 </Description>
        <CreatedDate>05/10/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22229</IssueID>
        <Title>IsImplicit for multiple operation nodes with same syntax</Title>
        <Description>we want to make sure there is only one explicit IOperation when multiple IOperations are pointing to same syntax node.

right now, we have case such as this (https://github.com/dotnet/roslyn/pull/21857#pullrequestreview-64081939 or https://github.com/dotnet/roslyn/pull/21857#issuecomment-330950924) where InvalidExpression is pointing to same syntax node as its child. or ExpressionStatement pointing to same syntax node as its expression (ex, expression lambda body)

we need to decide whether we want to mark those as implicit or not. if we do, those IOperation will not be returned by GetOperation. but user can still get to that operation through parent and children.
</Description>
        <CreatedDate>20/09/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Operations/CSharpOperationFactory.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenDeconstructTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTupleTest.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IFieldReferenceExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IForEachLoopStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_ILocalReferenceExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IParameterReferenceExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_ITupleExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/DeconstructionTests.cs</File>
      <File>src/Compilers/Core/Portable/Generated/Operations.xml.Generated.cs</File>
      <File>src/Compilers/Core/Portable/Operations/ITupleOperation.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationCloner.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/OperationTreeVerifier.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>23129</IssueID>
    <Title>Address followup nits from IOp prs.</Title>
    <Description>Fixes nits raised during review for #23041 and #22972. Fixes https://github.com/dotnet/roslyn/issues/23093.</Description>
    <CreatedDate>11/11/2017</CreatedDate>
    <ClosedDate>14/11/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>23041</IssueID>
        <Title>Compound expressions conversions</Title>
        <Description>This adds support for InConversion and OutConversion to ICompoundExpression, and adds VB support for compound expression scenarios with in and out conversions in them. Fixes https://github.com/dotnet/roslyn/issues/21738.

vso:https://devdiv.visualstudio.com/DevDiv/NET%20Developer%20Experience%20Productivity/_workitems/edit/521161</Description>
        <CreatedDate>07/11/2017</CreatedDate>
        <ClosedDate>09/11/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22972</IssueID>
        <Title>Update static instance handling</Title>
        <Description>There were a few places in IOperation error cases where we would drop receivers of static calls always, even if it was explicit. This updates our handling of receivers in both languages to only exclude implicit `this` as a receiver, as that is only ever present when the compiler optimistically generates a receiver before determining the symbol is static. I also added tests for these scenarios, as they were missing. This fixes https://github.com/dotnet/roslyn/issues/22585 and https://github.com/dotnet/roslyn/issues/22737.

vso : [link](https://devdiv.visualstudio.com/DevDiv/NET%20Developer%20Experience%20Productivity/_workitems/edit/518824)</Description>
        <CreatedDate>02/11/2017</CreatedDate>
        <ClosedDate>09/11/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_ICompoundAssignmentOperation.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/CompilationExtensions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>22553</IssueID>
    <Title>Compiler API not to return [Obsolete] for IsByRefLikeTypes</Title>
    <Description>Fixes #22450
Replaces #22504

The fix here is to stop returning [Obsolete] from compiler APIs.

@VSadov @dotnet/roslyn-compiler @dotnet/roslyn-ide for code review
@jaredpar for ask mode approval</Description>
    <CreatedDate>05/10/2017</CreatedDate>
    <ClosedDate>11/10/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>22450</IssueID>
        <Title>IDE visualizes span as [deprecated]</Title>
        <Description>![image](https://user-images.githubusercontent.com/8218165/31048319-795b052c-a5cf-11e7-91b3-bbda0edc7f12.png)

The Obsolete attributes on ref-like types are a part of compiler/runtime handshake and should not be visualized when follow the pattern.

I am not sure on what side this is - symbol display or some higher IDE level, but these obsolete should be filtered out.</Description>
        <CreatedDate>30/09/2017</CreatedDate>
        <ClosedDate>11/10/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22504</IssueID>
        <Title>Hide [deprecated] quick info on ref-like types</Title>
        <Description>Fixes #22450

@dotnet/roslyn-compiler @dotnet/roslyn-ide for code review
@gafter for API review
@jaredpar for ask mode approval</Description>
        <CreatedDate>03/10/2017</CreatedDate>
        <ClosedDate>04/10/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PENamedTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Attributes/AttributeTests_IsByRefLike.cs</File>
      <File>src/EditorFeatures/CSharpTest/QuickInfo/SemanticQuickInfoSourceTests.cs</File>
      <File>src/EditorFeatures/TestUtilities/Workspaces/TestWorkspace_XmlConsumption.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>22502</IssueID>
    <Title>Consume new editor assemblies</Title>
    <Description>Consume all the stuff in #22321 and then point to new editor packages that have the UI/UI.Wpf split that we need. This won't get merged until after #22321 is merged into master and then merged into dev15.5.x.</Description>
    <CreatedDate>03/10/2017</CreatedDate>
    <ClosedDate>16/10/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>22321</IssueID>
        <Title>Merged PR of active PRs that cause EditorFeatures API breaks</Title>
        <Description>This is a merged PR of #22105 and #21589 that will be merged at the same time so we only force partners to update for the breaks once.

**IF YOU WANT TO REVIEW THE CONTENTS OF THIS PULL REQUEST, PLEASE COMMENT IN THE PULL REQUESTS LINKED ABOVE.**</Description>
        <CreatedDate>25/09/2017</CreatedDate>
        <ClosedDate>04/10/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22321</IssueID>
        <Title>Merged PR of active PRs that cause EditorFeatures API breaks</Title>
        <Description>This is a merged PR of #22105 and #21589 that will be merged at the same time so we only force partners to update for the breaks once.

**IF YOU WANT TO REVIEW THE CONTENTS OF THIS PULL REQUEST, PLEASE COMMENT IN THE PULL REQUESTS LINKED ABOVE.**</Description>
        <CreatedDate>25/09/2017</CreatedDate>
        <ClosedDate>04/10/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder.ValueChecks.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Attributes.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Conversions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Deconstruct.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Expressions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Invocation.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Lambda.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Operators.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Patterns.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Statements.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/ForEachLoopBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/PatternSwitchBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/Conversions/Conversions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/Conversions/ConversionsBase.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/OverloadResolution/MethodTypeInference.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/OverloadResolution/OverloadResolution.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/OverloadResolution/OverloadResolutionResult.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/SubsumptionDiagnosticBuilder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/SwitchBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/OutDeconstructVarPendingInference.cs</File>
      <File>src/Compilers/CSharp/Portable/CSharpResources.Designer.cs</File>
      <File>src/Compilers/CSharp/Portable/CodeGen/EmitAddress.cs</File>
      <File>src/Compilers/CSharp/Portable/CodeGen/EmitExpression.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/CSharpCompilation.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/CSharpSemanticModel.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/ErrorCode.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/PreciseAbstractFlowPass_Switch.cs</File>
      <File>src/Compilers/CSharp/Portable/Generated/BoundNodes.xml.Generated.cs</File>
      <File>src/Compilers/CSharp/Portable/Generated/Syntax.xml.Internal.Generated.cs</File>
      <File>src/Compilers/CSharp/Portable/Generated/Syntax.xml.Main.Generated.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/AsyncRewriter/AwaitExpressionSpiller.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/IteratorRewriter/IteratorFinallyMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_Call.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_ObjectOrCollectionInitializerExpression.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_StackAlloc.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/MethodToClassRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/StateMachineRewriter/SynthesizedStateMachineProperty.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/SynthesizedMethodBaseSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/SyntheticBoundNodeFactory.cs</File>
      <File>src/Compilers/CSharp/Portable/Operations/CSharpOperationFactory.cs</File>
      <File>src/Compilers/CSharp/Portable/Operations/CSharpOperationFactory_Methods.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/LanguageParser.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/Lexer.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/SlidingTextWindow.cs</File>
      <File>src/Compilers/CSharp/Portable/SymbolDisplay/SymbolDisplayVisitor.Members.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/AnonymousTypes/SynthesizedSymbols/AnonymousType.ConstructorSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/AnonymousTypes/SynthesizedSymbols/AnonymousType.EqualsMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/AnonymousTypes/SynthesizedSymbols/AnonymousType.GetHashCodeMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/AnonymousTypes/SynthesizedSymbols/AnonymousType.PropertyAccessorSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/AnonymousTypes/SynthesizedSymbols/AnonymousType.PropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/AnonymousTypes/SynthesizedSymbols/AnonymousType.ToStringMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ErrorMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ErrorPropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PEMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PENamedTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PEParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PEPropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/MethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/NamedTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/PropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ReducedExtensionMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/RefKindExtensions.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/SignatureOnlyMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/SignatureOnlyPropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/LambdaSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/LocalFunctionSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/ModifierUtils.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/ParameterHelpers.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceConstructorSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceDelegateMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceDestructorSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceEventAccessorSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceLocalSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceMemberContainerSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceMemberMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceNamedTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceOrdinaryMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourcePropertyAccessorSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourcePropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceUserDefinedOperatorSymbolBase.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/ThisParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedDelegateSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedEntryPointSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedGlobalMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedImplementationMethod.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedInstanceConstructor.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedInteractiveInitializerMethod.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedIntrinsicOperatorSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedSealedPropertyAccessor.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedStaticConstructor.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/TypeSymbolExtensions.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Wrapped/WrappedMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Wrapped/WrappedPropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/SyntaxNodeExtensions.cs</File>
      <File>src/Compilers/CSharp/Portable/Utilities/EnumExtensions.cs</File>
      <File>src/Compilers/CSharp/Test/CommandLine/CommandLineTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Attributes/AttributeTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Attributes/AttributeTests_Embedded.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Attributes/AttributeTests_IsByRefLike.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Attributes/AttributeTests_ReadOnlyStruct.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Attributes/AttributeTests_RefReadOnly.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenConditionalOperatorTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenInParametersTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenLocalFunctionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenReadonlyStructTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenRefConditionalOperatorTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenRefReadonlyReturnTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenRefReturnTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenStructsAndEnum.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTupleTest.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/UnsafeTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Emit/CompilationEmitTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Emit/InAttributeModifierTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/PDB/PDBTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Diagnostics/OperationAnalyzerTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_ArrayCreationAndInitializer.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IAnonymousFunctionExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IArgument.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IArrayElementReferenceExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IAwaitExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IBinaryOperatorExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IConditionalAccessExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IConversionExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IDynamicIndexerAccessExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IDynamicInvocationExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IDynamicMemberReferenceExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IDynamicObjectCreationExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IEventAssignmentExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IFieldReferenceExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IFixedStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IForEachLoopStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IForLoopStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IIfStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IInstanceReferenceTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IInterpolatedStringExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IIsPatternExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IIsTypeExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_ILocalFunctionStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_ILocalReferenceExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_ILockStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IObjectCreationExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IParameterReferenceExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IPatternSwitchCase.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IPropertyReferenceExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IReturnStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_ISizeOfExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_ISymbolInitializer.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_ITupleExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_ITypeOfExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IUnaryOperatorExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IVariableDeclaration.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IWhileUntilLoopStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_InvalidExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_InvalidStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_TryCatch.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/AmbiguousOverrideTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/DynamicTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/NameOfTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/ObjectAndCollectionInitializerTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/OperatorTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/OverloadResolutionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternSwitchTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/QueryTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/RefEscapingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/RefExtensionMethodsTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/RefLocalsAndReturnsTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/SemanticErrorTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/SpanStackSafetyTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/StackAllocSpanExpressionsTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/SwitchTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/UnsafeTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/VarianceTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Compilation/GetUnusedImportDirectivesTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Compilation/SemanticModelGetDeclaredSymbolAPITests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/SymbolDisplay/SymbolDisplayTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/AnonymousTypesSemanticsTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/InterfaceOverriddenOrHiddenMembersTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/OverriddenOrHiddenMembersTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/Source/DelegateTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/Source/ExpressionBodiedPropertyTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/UserDefinedOperatorErrorTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/LexicalAndXml/LexicalTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/DeclarationParsingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/ParserErrorMessageTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/ParserRegressionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/PatternParsingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/ReadOnlyStructs.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/RefReadonlyReturnsTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/RefReadonlyTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/RefStructs.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/RoundTrippingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/ScriptParsingTests.cs</File>
      <File>src/Compilers/Core/Portable/Compilation/Compilation.cs</File>
      <File>src/Compilers/Core/Portable/Generated/Operations.xml.Generated.cs</File>
      <File>src/Compilers/Core/Portable/InternalUtilities/EnumUtilties.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IArrayElementReferenceExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/ICatchClause.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IEndStatement.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IStopStatement.cs</File>
      <File>src/Compilers/Core/Portable/Operations/ITryStatement.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationCloner.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationKind.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationVisitor.cs</File>
      <File>src/Compilers/Core/Portable/SymbolDisplay/SymbolDisplayParameterOptions.cs</File>
      <File>src/Compilers/Core/Portable/Symbols/IMethodSymbol.cs</File>
      <File>src/Compilers/Core/Portable/Symbols/IPropertySymbol.cs</File>
      <File>src/Compilers/Core/Portable/Symbols/RefKind.cs</File>
      <File>src/Compilers/Extension/CompilerPackage.cs</File>
      <File>src/Compilers/Test/Utilities/CSharp/CSharpTestBase.cs</File>
      <File>src/EditorFeatures/CSharp/CallHierarchy/CallHierarchyCommandHandler.cs</File>
      <File>src/EditorFeatures/CSharp/QuickInfo/SemanticQuickInfoProvider.cs</File>
      <File>src/EditorFeatures/CSharp/QuickInfo/SyntacticQuickInfoProvider.cs</File>
      <File>src/EditorFeatures/CSharpTest/AddAccessibilityModifiers/AddAccessibilityModifiersTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Completion/CompletionProviders/DeclarationNameCompletionProviderTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/NamingStyles/EditorConfigNamingStyleParserTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/EditAndContinue/StatementEditingTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/EditAndContinue/TopLevelEditingTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/ExtractInterface/ExtractInterfaceTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/ImplementAbstractClass/ImplementAbstractClassTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/ImplementInterface/ImplementInterfaceTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/QuickInfo/SemanticQuickInfoSourceTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/QuickInfo/SyntacticQuickInfoSourceTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseLocalFunction/UseLocalFunctionTests.cs</File>
      <File>src/EditorFeatures/CSharpTest2/Recommendations/InKeywordRecommenderTests.cs</File>
      <File>src/EditorFeatures/CSharpTest2/Recommendations/OutKeywordRecommenderTests.cs</File>
      <File>src/EditorFeatures/CSharpTest2/Recommendations/ReadOnlyKeywordRecommenderTests.cs</File>
      <File>src/EditorFeatures/CSharpTest2/Recommendations/RefKeywordRecommenderTests.cs</File>
      <File>src/EditorFeatures/CSharpTest2/Recommendations/ThisKeywordRecommenderTests.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Adornments/AbstractAdornmentManagerProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Adornments/AdornmentManager.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Adornments/GraphicsResult.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Adornments/GraphicsTag.cs</File>
      <File>src/EditorFeatures/Core.Wpf/BraceMatching/ClassificationTypeFormatDefinitions.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Classification/ClassificationTypeFormatDefinitions.cs</File>
      <File>src/EditorFeatures/Core.Wpf/CodeAnalysisColors.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Completion/Presentation/ClassificationTags.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Completion/Presentation/CompletionPresenter.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Completion/Presentation/CompletionPresenterSession.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Completion/Presentation/CompletionSource.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Completion/Presentation/CustomCommitCompletion.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Completion/Presentation/ImageMonikers.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Completion/Presentation/RoslynCompletionSet.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Completion/Presentation/RoslynIntellisenseFilter.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Completion/Presentation/ToolTipProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/ConflictTagDefinition.cs</File>
      <File>src/EditorFeatures/Core.Wpf/DependencyObjectExtensions.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Diagnostics/UnnecessaryCodeFormatDefinition.cs</File>
      <File>src/EditorFeatures/Core.Wpf/EditAndContinue/ActiveStatementTagFormatDefinition.cs</File>
      <File>src/EditorFeatures/Core.Wpf/EditAndContinue/EditAndContinueErrorTypeFormatDefinition.cs</File>
      <File>src/EditorFeatures/Core.Wpf/IWpfDifferenceViewerExtensions.cs</File>
      <File>src/EditorFeatures/Core.Wpf/IWpfTextViewExtensions.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/AbstractEditorInlineRenameService.FailureInlineRenameInfo.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/AbstractEditorInlineRenameService.InlineRenameLocationSet.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/AbstractEditorInlineRenameService.InlineRenameReplacementInfo.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/AbstractEditorInlineRenameService.SymbolRenameInfo.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/AbstractEditorInlineRenameService.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/AbstractInlineRenameUndoManager.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/CSharpEditorInlineRenameService.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/CommandHandlers/RenameCommandHandler.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/CommandHandlers/RenameCommandHandler_BackspaceDeleteHandler.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/CommandHandlers/RenameCommandHandler_CutPasteHandler.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/CommandHandlers/RenameCommandHandler_EscapeHandler.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/CommandHandlers/RenameCommandHandler_LineStartEndHandler.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/CommandHandlers/RenameCommandHandler_MoveSelectedLinesHandler.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/CommandHandlers/RenameCommandHandler_OpenLineAboveHandler.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/CommandHandlers/RenameCommandHandler_OpenLineBelowHandler.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/CommandHandlers/RenameCommandHandler_RefactoringWithCommandHandler.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/CommandHandlers/RenameCommandHandler_RenameHandler.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/CommandHandlers/RenameCommandHandler_ReturnHandler.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/CommandHandlers/RenameCommandHandler_SaveHandler.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/CommandHandlers/RenameCommandHandler_SelectAllHandler.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/CommandHandlers/RenameCommandHandler_TabHandler.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/CommandHandlers/RenameCommandHandler_TypeCharHandler.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/CommandHandlers/RenameCommandHandler_UndoRedoHandler.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/CommandHandlers/RenameCommandHandler_WordDeleteHandler.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/Dashboard/Dashboard.xaml.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/Dashboard/DashboardAdornmentManager.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/Dashboard/DashboardAdornmentProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/Dashboard/DashboardAutomationPeer.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/Dashboard/DashboardSeverity.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/Dashboard/DashboardViewModel.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/Dashboard/RenameShortcutKeys.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/HighlightTags/RenameConflictTag.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/HighlightTags/RenameConflictTagDefinition.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/HighlightTags/RenameFieldBackgroundAndBorderTag.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/HighlightTags/RenameFieldBackgroundAndBorderTagDefinition.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/HighlightTags/RenameFixupTag.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/HighlightTags/RenameFixupTagDefinition.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/IInlineRenameUndoManager.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/InlineRenameService.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/InlineRenameSession.OpenTextBufferManager.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/InlineRenameSession.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/RenameLogMessage.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/RenameTrackingSpan.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/Taggers/AbstractRenameTagger.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/Taggers/ClassificationTypeDefinitions.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/Taggers/RenameClassificationTagger.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/Taggers/RenameClassificationTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/Taggers/RenameTagger.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/Taggers/RenameTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/TrackingSpanIntrospector.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/UndoManagerServiceFactory.cs</File>
      <File>src/EditorFeatures/Core.Wpf/InlineRename/VisualBasicEditorInlineRenameService.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Interactive/InteractivePasteCommandHandler.cs</File>
      <File>src/EditorFeatures/Core.Wpf/LineSeparators/EditorFormatMapChangedEventSource.cs</File>
      <File>src/EditorFeatures/Core.Wpf/LineSeparators/LineSeparatorAdornmentManagerProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/LineSeparators/LineSeparatorTag.cs</File>
      <File>src/EditorFeatures/Core.Wpf/LineSeparators/LineSeparatorTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/NavigateTo/DefaultNavigateToPreviewService.cs</File>
      <File>src/EditorFeatures/Core.Wpf/NavigateTo/DefaultNavigateToPreviewServiceFactory.cs</File>
      <File>src/EditorFeatures/Core.Wpf/NavigateTo/INavigateToPreviewService.cs</File>
      <File>src/EditorFeatures/Core.Wpf/NavigateTo/NavigateToItemDisplay.cs</File>
      <File>src/EditorFeatures/Core.Wpf/NavigateTo/NavigateToItemDisplayFactory.cs</File>
      <File>src/EditorFeatures/Core.Wpf/NavigateTo/NavigateToItemProvider.Searcher.cs</File>
      <File>src/EditorFeatures/Core.Wpf/NavigateTo/NavigateToItemProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/NavigateTo/NavigateToItemProviderFactory.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Notification/EditorNotificationServiceFactory.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Preview/AbstractPreviewTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Preview/DifferenceViewerPreview.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Preview/PreviewConflictViewTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Preview/PreviewFactoryService.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Preview/PreviewReferenceHighlightingTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Preview/PreviewWarningViewTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/PreviewWarningTagDefinition.cs</File>
      <File>src/EditorFeatures/Core.Wpf/QuickInfo/Converters/ClassifiableDeferredContentConverter.cs</File>
      <File>src/EditorFeatures/Core.Wpf/QuickInfo/Converters/DocumentationCommentDeferredContentConverter.cs</File>
      <File>src/EditorFeatures/Core.Wpf/QuickInfo/Converters/IDeferredQuickInfoContentToFrameworkElementConverter.cs</File>
      <File>src/EditorFeatures/Core.Wpf/QuickInfo/Converters/ProjectionBufferDeferredContentConverter.cs</File>
      <File>src/EditorFeatures/Core.Wpf/QuickInfo/Converters/QuickInfoDisplayDeferredContentConverter.cs</File>
      <File>src/EditorFeatures/Core.Wpf/QuickInfo/Converters/SymbolGlyphDeferredContentConverter.cs</File>
      <File>src/EditorFeatures/Core.Wpf/QuickInfo/DeferredContentFrameworkElementFactory.cs</File>
      <File>src/EditorFeatures/Core.Wpf/QuickInfo/Presentation/QuickInfoPresenter.QuickInfoPresenterSession.cs</File>
      <File>src/EditorFeatures/Core.Wpf/QuickInfo/Presentation/QuickInfoPresenter.QuickInfoSource.cs</File>
      <File>src/EditorFeatures/Core.Wpf/QuickInfo/Presentation/QuickInfoPresenter.cs</File>
      <File>src/EditorFeatures/Core.Wpf/QuickInfo/QuickInfoDisplayPanel.cs</File>
      <File>src/EditorFeatures/Core.Wpf/ReferenceHighlighting/DefinitionHighlightTagDefinition.cs</File>
      <File>src/EditorFeatures/Core.Wpf/ReferenceHighlighting/WrittenReferenceHighlightTagDefinition.cs</File>
      <File>src/EditorFeatures/Core.Wpf/RenameTracking/RenameTrackingTagDefinition.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Structure/AbstractStructureTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Structure/BlockContextProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Structure/BlockTagState.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Structure/InvalidOutliningRegionException.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Structure/OutliningCommandHandler.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Structure/RoslynBlockTag.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Structure/RoslynOutliningRegionTag.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Structure/VisualStudio14StructureTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/Structure/VisualStudio15StructureTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core.Wpf/ViewHostingControl.cs</File>
      <File>src/EditorFeatures/Core.Wpf/WpfClassificationExtensions.cs</File>
      <File>src/EditorFeatures/Core/Extensibility/QuickInfo/IDeferredQuickInfoContent.cs</File>
      <File>src/EditorFeatures/Core/Implementation/BraceMatching/ClassificationTypeDefinitions.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Classification/ClassificationTypeDefinitions.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Diagnostics/ClassificationTypeDefinitions.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Diagnostics/DiagnosticsClassificationTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Diagnostics/DiagnosticsSuggestionTaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/EditAndContinue/EditAndContinueErrorTypeDefinition.cs</File>
      <File>src/EditorFeatures/Core/Implementation/ITextBufferAssociatedViewService.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/QuickInfo/DeferredContent/ClassifiableDeferredContent.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/QuickInfo/DeferredContent/ProjectionBufferDeferredContent.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/QuickInfo/DeferredContent/QuickInfoDisplayDeferredContent.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/QuickInfo/DeferredContent/SymbolGlyphDeferredContent.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/QuickInfo/Providers/AbstractQuickInfoProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/QuickInfo/Providers/AbstractSemanticQuickInfoProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/IntelliSense/QuickInfo/Providers/DocumentationCommentDeferredContent.cs</File>
      <File>src/EditorFeatures/Core/Implementation/SolutionPreviewItem.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Suggestions/SuggestedActions/SuggestedAction.CaretPositionRestorer.cs</File>
      <File>src/EditorFeatures/Core/Implementation/TextBufferAssociatedViewService.cs</File>
      <File>src/EditorFeatures/Core/Shared/Extensions/ClassificationExtensions.cs</File>
      <File>src/EditorFeatures/Core/Shared/Extensions/GlyphExtensions.cs</File>
      <File>src/EditorFeatures/Core/Shared/Extensions/ISymbolExtensions.cs</File>
      <File>src/EditorFeatures/Core/Shared/Tagging/EventSources/TaggerEventSources.EditorFormatMapChangedEventSource.cs</File>
      <File>src/EditorFeatures/Core/Shared/Tagging/EventSources/TaggerEventSources.cs</File>
      <File>src/EditorFeatures/Core/Shared/Utilities/ClassificationTypeMap.cs</File>
      <File>src/EditorFeatures/Core/Shared/Utilities/ForegroundThreadAffinitizedObject.cs</File>
      <File>src/EditorFeatures/Core/Shared/Utilities/HighContrastChecker.cs</File>
      <File>src/EditorFeatures/Test/CodeGeneration/CodeGenerationTests.cs</File>
      <File>src/EditorFeatures/Test/TextEditor/TextBufferAssociatedViewServiceTests.cs</File>
      <File>src/EditorFeatures/TestUtilities/CallHierarchy/CallHierarchyTestState.cs</File>
      <File>src/EditorFeatures/TestUtilities/Diagnostics/DiagnosticTaggerWrapper.cs</File>
      <File>src/EditorFeatures/TestUtilities/MinimalTestExportProvider.cs</File>
      <File>src/EditorFeatures/TestUtilities/QuickInfo/AbstractSemanticQuickInfoSourceTests.cs</File>
      <File>src/EditorFeatures/TestUtilities/ServiceTestExportProvider.cs</File>
      <File>src/EditorFeatures/TestUtilities/Threading/WpfTestCase.cs</File>
      <File>src/EditorFeatures/TestUtilities/Workspaces/TestWorkspaceFixture.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Source/ExpressionCompiler/Symbols/EEMethodSymbol.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Source/ExpressionCompiler/Symbols/PlaceholderMethodSymbol.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Source/ExpressionCompiler/Symbols/SynthesizedContextMethodSymbol.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Test/ExpressionCompiler/ExpressionCompilerTests.cs</File>
      <File>src/Features/CSharp/Portable/Completion/CompletionProviders/DeclarationNameCompletionProvider.cs</File>
      <File>src/Features/CSharp/Portable/Completion/KeywordRecommenders/InKeywordRecommender.cs</File>
      <File>src/Features/CSharp/Portable/Completion/KeywordRecommenders/ReadOnlyKeywordRecommender.cs</File>
      <File>src/Features/CSharp/Portable/DesignerAttributes/CSharpDesignerAttributeService.cs</File>
      <File>src/Features/CSharp/Portable/EditAndContinue/CSharpEditAndContinueAnalyzer.cs</File>
      <File>src/Features/CSharp/Portable/ExtractMethod/CSharpMethodExtractor.CSharpCodeGenerator.cs</File>
      <File>src/Features/CSharp/Portable/GenerateMember/GenerateParameterizedMember/CSharpGenerateConversionService.cs</File>
      <File>src/Features/CSharp/Portable/GenerateMember/GenerateParameterizedMember/CSharpGenerateParameterizedMemberService.cs</File>
      <File>src/Features/CSharp/Portable/GenerateType/CSharpGenerateTypeService.cs</File>
      <File>src/Features/CSharp/Portable/UseLocalFunction/CSharpUseLocalFunctionCodeFixProvider.cs</File>
      <File>src/Features/Core/Portable/Completion/CompletionOptions.cs</File>
      <File>src/Features/Core/Portable/Completion/Providers/AbstractPartialMethodCompletionProvider.cs</File>
      <File>src/Features/Core/Portable/DesignerAttributes/AbstractDesignerAttributeService.cs</File>
      <File>src/Features/Core/Portable/DesignerAttributes/DesignerAttributeDocumentData.cs</File>
      <File>src/Features/Core/Portable/DesignerAttributes/DesignerAttributeProjectData.cs</File>
      <File>src/Features/Core/Portable/DesignerAttributes/DesignerAttributeResult.cs</File>
      <File>src/Features/Core/Portable/DesignerAttributes/IDesignerAttributeService.cs</File>
      <File>src/Features/Core/Portable/DesignerAttributes/IRemoteDesignerAttributeService.cs</File>
      <File>src/Features/Core/Portable/EncapsulateField/AbstractEncapsulateFieldService.cs</File>
      <File>src/Features/Core/Portable/ExtractInterface/AbstractExtractInterfaceService.cs</File>
      <File>src/Features/Core/Portable/GenerateMember/GenerateParameterizedMember/AbstractGenerateMethodService.State.cs</File>
      <File>src/Features/Core/Portable/GenerateMember/GenerateParameterizedMember/AbstractGenerateParameterizedMemberService.MethodSignatureInfo.cs</File>
      <File>src/Features/Core/Portable/GenerateMember/GenerateParameterizedMember/AbstractGenerateParameterizedMemberService.SignatureInfo.cs</File>
      <File>src/Features/Core/Portable/GenerateMember/GenerateVariable/AbstractGenerateVariableService.CodeAction.cs</File>
      <File>src/Features/Core/Portable/GenerateType/AbstractGenerateTypeService.GenerateNamedType.cs</File>
      <File>src/Features/Core/Portable/InitializeParameter/AbstractInitializeMemberFromParameterCodeRefactoringProviderMemberCreation.cs</File>
      <File>src/Features/Core/Portable/MetadataAsSource/AbstractMetadataAsSourceService.WrappedMethodSymbol.cs</File>
      <File>src/Features/Core/Portable/MetadataAsSource/AbstractMetadataAsSourceService.WrappedPropertySymbol.cs</File>
      <File>src/Features/Core/Portable/SolutionCrawler/SolutionCrawlerRegistrationService.cs</File>
      <File>src/Features/Core/Portable/SolutionCrawler/State/AbstractAnalyzerState.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/OperationTreeVerifier.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/TestOperationWalker.cs</File>
      <File>src/VisualStudio/CSharp/Impl/CSharpVSResources.Designer.cs</File>
      <File>src/VisualStudio/CSharp/Impl/CodeModel/CSharpCodeModelService.cs</File>
      <File>src/VisualStudio/CSharp/Impl/EventHookup/EventHookupCommandHandler.cs</File>
      <File>src/VisualStudio/CSharp/Impl/EventHookup/EventHookupCommandHandler_SessionCancellingCommands.cs</File>
      <File>src/VisualStudio/CSharp/Impl/EventHookup/EventHookupCommandHandler_ShadowedCommands.cs</File>
      <File>src/VisualStudio/CSharp/Impl/EventHookup/EventHookupCommandHandler_TabKeyCommand.cs</File>
      <File>src/VisualStudio/CSharp/Impl/EventHookup/EventHookupCommandHandler_TypeCharCommand.cs</File>
      <File>src/VisualStudio/CSharp/Impl/EventHookup/EventHookupQuickInfoSource.cs</File>
      <File>src/VisualStudio/CSharp/Impl/EventHookup/EventHookupQuickInfoSourceProvider.cs</File>
      <File>src/VisualStudio/CSharp/Impl/EventHookup/EventHookupSessionManager.cs</File>
      <File>src/VisualStudio/CSharp/Impl/EventHookup/EventHookupSessionManager_EventHookupSession.cs</File>
      <File>src/VisualStudio/CSharp/Impl/EventHookup/IHACK_EventHookupDismissalOnBufferChangePreventerService.cs</File>
      <File>src/VisualStudio/CSharp/Impl/Options/IntelliSenseOptionPageControl.xaml.cs</File>
      <File>src/VisualStudio/CSharp/Impl/Options/IntelliSenseOptionPageStrings.cs</File>
      <File>src/VisualStudio/CSharp/Test/CallHierarchy/CSharpCallHierarchyTests.cs</File>
      <File>src/VisualStudio/CSharp/Test/EventHookup/EventHookupCommandHandlerTests.cs</File>
      <File>src/VisualStudio/CSharp/Test/EventHookup/EventHookupTestState.cs</File>
      <File>src/VisualStudio/CSharp/Test/GlyphExtensionsTests.cs</File>
      <File>src/VisualStudio/CSharp/Test/Interactive/InteractiveWindowTestHost.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/CallHierarchy/CallHierarchyCommandHandler.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/CallHierarchy/CallHierarchyDetail.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/CallHierarchy/CallHierarchyItem.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/CallHierarchy/CallHierarchyProvider.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/CallHierarchy/FieldInitializerItem.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/CallHierarchy/Finders/AbstractCallFinder.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/CallHierarchy/Finders/BaseMemberFinder.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/CallHierarchy/Finders/CallToOverrideFinder.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/CallHierarchy/Finders/FieldReferenceFinder.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/CallHierarchy/Finders/ImplementerFinder.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/CallHierarchy/Finders/InterfaceImplementationCallFinder.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/CallHierarchy/Finders/MethodCallFinder.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/CallHierarchy/Finders/OverridingMemberFinder.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/CallHierarchy/ICallHierarchyPresenter.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ChangeSignature/ChangeSignatureDialogViewModel.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ChangeSignature/VisualStudioChangeSignatureOptionsService.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/DesignerAttribute/DesignerAttributeIncrementalAnalyzer.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/DesignerAttribute/DesignerAttributeState.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ExtractInterface/ExtractInterfaceDialogViewModel.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/FindReferences/Entries/AbstractDocumentSpanEntry.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/FindReferences/Entries/DefinitionItemEntry.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/FindReferences/Entries/DocumentSpanEntry.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/FindReferences/RoslynDefinitionBucket.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/FindReferences/StreamingFindUsagesPresenter.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Interactive/IAbstractResetInteractiveCommand.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/LanguageService/AbstractPackage.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Library/ObjectBrowser/Lists/SymbolListItem.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/PickMembers/PickMembersDialogViewModel.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Preview/TopLevelChange.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Utilities/GlyphExtensions.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Venus/ContainedLanguageCodeSupport.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Watson/WatsonReporter.cs</File>
      <File>src/VisualStudio/Core/Impl/CodeModel/AbstractCodeModelObject_CodeGen.cs</File>
      <File>src/VisualStudio/Core/Test.Next/Services/ServiceHubServicesTests.cs</File>
      <File>src/VisualStudio/Razor/RazorLangaugeServiceClient.cs</File>
      <File>src/VisualStudio/Razor/RazorLanguageServiceClientFactory.cs</File>
      <File>src/VisualStudio/Setup/AssemblyRedirects.cs</File>
      <File>src/Workspaces/CSharp/Portable/CodeGeneration/CSharpSyntaxGenerator.cs</File>
      <File>src/Workspaces/CSharp/Portable/CodeGeneration/MethodGenerator.cs</File>
      <File>src/Workspaces/CSharp/Portable/CodeGeneration/ParameterGenerator.cs</File>
      <File>src/Workspaces/CSharp/Portable/CodeGeneration/PropertyGenerator.cs</File>
      <File>src/Workspaces/CSharp/Portable/Extensions/ContextQuery/SyntaxTreeExtensions.cs</File>
      <File>src/Workspaces/CSharp/Portable/Extensions/ITypeSymbolExtensions.cs</File>
      <File>src/Workspaces/CSharp/Portable/Extensions/TypeSyntaxExtensions.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/CodeGenerationSymbolFactory.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/Symbols/CodeGenerationAbstractMethodSymbol.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/Symbols/CodeGenerationConstructedMethodSymbol.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/Symbols/CodeGenerationConstructorSymbol.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/Symbols/CodeGenerationConversionSymbol.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/Symbols/CodeGenerationDestructorSymbol.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/Symbols/CodeGenerationMethodSymbol.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/Symbols/CodeGenerationOperatorSymbol.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/Symbols/CodeGenerationPropertySymbol.cs</File>
      <File>src/Workspaces/Core/Portable/Editing/DeclarationModifiers.cs</File>
      <File>src/Workspaces/Core/Portable/NamingStyles/EditorConfig/EditorConfigNamingStyleParser.cs</File>
      <File>src/Workspaces/Core/Portable/Shared/Extensions/ICodeDefinitionFactoryExtensions_CreateEqualsMethod.cs</File>
      <File>src/Workspaces/Core/Portable/Shared/Extensions/ICodeDefinitionFactoryExtensions_CreateGetHashCodeMethod.cs</File>
      <File>src/Workspaces/Core/Portable/Shared/Extensions/IMethodSymbolExtensions.cs</File>
      <File>src/Workspaces/Core/Portable/Shared/Extensions/IParameterSymbolExtensions.cs</File>
      <File>src/Workspaces/Core/Portable/Shared/Extensions/IPropertySymbolExtensions.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/Solution/ProjectState.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/Solution/ProjectState_Checksum.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/Solution/StateChecksums.cs</File>
      <File>src/Workspaces/Remote/Core/Services/SolutionCreator.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Services/CodeAnalysisService_DesignerAttributes.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Services/CodeAnalysisService_TodoComments.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Shared/RoslynJsonConverter.RoslynOnly.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>22479</IssueID>
    <Title>Add IOperation API for deconstruction assignment expression and declaration expression.</Title>
    <Description>IOperation APIs exposed by this PR:
```
namespace Microsoft.CodeAnalysis.Semantics
{
    /// &lt;summary&gt;
    /// Represents a declaration expression in C#.
    /// Unlike a regular variable declaration, this operation represents an "expression" declaring a variable.
    /// For example,
    ///   1. "var (x, y)" is a deconstruction declaration expression with variables x and y.
    ///   2. "(var x, var y)" is a tuple expression with two declaration expressions.
    ///   3. "M(out var x);" is an invocation expression with an out "var x" declaration expression.
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;
    /// This interface is reserved for implementation by its associated APIs. We reserve the right to
    /// change it in the future.
    /// &lt;/remarks&gt;
    public interface IDeclarationExpression : IOperation
    {
        /// &lt;summary&gt;
        /// Underlying expression.
        /// &lt;/summary&gt;
        IOperation Expression { get; }
    }
}

namespace Microsoft.CodeAnalysis.Semantics
{
    /// &lt;summary&gt;
    /// Represents a deconstruction assignment expression.
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;
    /// This interface is reserved for implementation by its associated APIs. We reserve the right to
    /// change it in the future.
    /// &lt;/remarks&gt;
    public interface IDeconstructionAssignmentExpression : IAssignmentExpression
    {
    }
}

```

Fixes #19924

For IOperation v1, we have decided to expose deconstruction assignment with regular conversion data. In v2, we will expose richer API with deconstruction method and also match language specification on whether this is exposed as a conversion or not. This is tracked with #22477.
</Description>
    <CreatedDate>03/10/2017</CreatedDate>
    <ClosedDate>13/10/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>19924</IssueID>
        <Title>IOperation API for BoundDeconstructionAssignmentOperator</Title>
        <Description>Two possible approaches:

1. Expose it as an IAssignmentExpression, where left and right are IOperations.
2. Introduce a new type with more strongly typed left and right child nodes:

```
    public interface IDeconstructionAssignmentExpression : IOperation
    {
        ITupleExpression Left { get; }
        IConversionExpression Right { get; }
    }
```</Description>
        <CreatedDate>31/05/2017</CreatedDate>
        <ClosedDate>13/10/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22477</IssueID>
        <Title>Expose richer desconstruction assignment/conversion info in IOperation v2</Title>
        <Description>
        </Description>
        <CreatedDate>03/10/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Operations/CSharpOperationFactory.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IFieldReferenceExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IForEachLoopStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IForLoopStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IIfStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_ILocalReferenceExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IParameterReferenceExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_ITupleExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IWhileUntilLoopStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/DeconstructionTests.cs</File>
      <File>src/Compilers/Core/Portable/Generated/Operations.xml.Generated.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IDeclarationExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IDeconstructionAssignmentExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationCloner.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationKind.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationVisitor.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/OperationTreeVerifier.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>22470</IssueID>
    <Title>Add regression tests for fixed local function crashes</Title>
    <Description>This is a test-only change.

Fixes #21768
Fixes #22027
</Description>
    <CreatedDate>02/10/2017</CreatedDate>
    <ClosedDate>04/10/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>21768</IssueID>
        <Title>Compiler crash (exit code -1) when using local functions</Title>
        <Description>The following code crashes VBCSCompiler.exe as well as csc.exe when building using Visual Studio 2017 15.3.2 on Windows 7: 

        void Function(int someField) //necessary to have a parameter
        {
            using (IInterface db = null) //necessary to have this using statement
            {
                void LocalFunction() //necessary
                {
                    var results =
                        db.Query&lt;Class1&gt;() //need to call this method. using a constant array does not reproduce the bug.
                        .Where(cje =&gt; cje.SomeField &gt;= someField) //need expression tree here referencing parameter
                        ;
                }
            }
        }
        interface IInterface : IDisposable
        {
            IQueryable&lt;T&gt; Query&lt;T&gt;();
        }
        class Class1
        {
            public int SomeField { get; set; }
        }

Quite a few components are needed to reproduce this bug.</Description>
        <CreatedDate>28/08/2017</CreatedDate>
        <ClosedDate>04/10/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22027</IssueID>
        <Title>CSC.exe exits with code -2146232797 in strange cases where local function declared in an inner scope calling another local function</Title>
        <Description>**Version Used**: 
VS 2017 .Net 4.6.2
C# Compiler version 2.3.2.61928 (ec1cde8b)

**Steps to Reproduce**:
1. CSC exits when compiling 
 class Program
    {
        static void Main(string[] args)
        {
            
        }
        public object TestLocalFn(object inp)
        {
            try
            {
                var sr = new object();
                return sr;
                void Local1()
                {
                    var copy = inp;
                    Local2();
                }
                void Local2()
                {

                }
            }
            catch { throw; }
        }
    }
2. Working case 1

 class Program
    {
        static void Main(string[] args)
        {
            
        }
        public object TestLocalFn(object inp)
        {
            try
            {
                var sr = new object();
                return sr;
                void Local1()
                {
                    //var copy = inp;  //removing this line it works
                    Local2();
                }
                void Local2()
                {

                }
            }
            catch { throw; }
        }
    }
3. everything works if not scoped

    class Program
    {
        static void Main(string[] args)
        {

        }
        public object TestLocalFn(object inp)
        {

            var sr = new object();
            return sr;
            void Local1()
            {
                var copy = inp;
                Local2();
            }
            void Local2()
            {

            }

        }
    }
</Description>
        <CreatedDate>11/09/2017</CreatedDate>
        <ClosedDate>04/10/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenLocalFunctionTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>22468</IssueID>
    <Title>workaround NamedPipeClientStream bug where it will spin wait connection to be established consuming 100% of CPU.</Title>
    <Description>workaround is barrowed from service hub -
http://index/?query=NamedPipeClientStream&amp;rightProject=Microsoft.ServiceHub.Client&amp;file=NamedPipeClientStreamExtensions.cs&amp;line=15

also made servicehub to use merged cancellation token as workaround for Microsoft/vs-streamjsonrpc#64

.....................

**Customer scenario**

User starts to use Roslyn (C# or VB projects). after for a while, ServiceHub.RoslynCodeAnalysis32.exe process starts to consume a lot of CPU and ends up consuming 100% of it all the time.

**Bugs this fixes:**

https://devdiv.visualstudio.com/DevDiv/_workitems/edit/503885

**Workarounds, if any**

There is no workaround.

**Risk**

I don't see any risk.

**Performance impact**

this should make perf same as before by cancelling operation correctly.

**Is this a regression from a previous update?**

Yes. this regressed when we moved to new cancellation support from StreamJsonRpc. missed some subtle cancellation issue when cancellation and disconnection happens right after each other. 

in previous version (15.4.x), we used our own mechanism for cancellation which didn't have this issue. moving to new native cancellation support helped us to reuse same connection improving perf, but caused us to regress cancellation support.

**Root cause analysis:**

when cancellation is raised in VS and connection is closed right away, cancellation sometimes doesn't get raised in service hub side. just disconnection happens. and service in service hub side doesn't know it has been cancelled. and keep doing what it was doing. that combined with NamedPipeClientStream.ConnectAsync issue (https://github.com/dotnet/corefx/issues/7635), it ends up consuming 100% cpu waiting pipe that already gone.

more detail is on Microsoft/vs-streamjsonrpc#64.

**How was the bug found?**

Dogfooding.
</Description>
    <CreatedDate>02/10/2017</CreatedDate>
    <ClosedDate>04/10/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>64</IssueID>
        <Title>API Request: TypeSymbolExtensions </Title>
        <Description>Forking this feature request from #16 

Original post: https://github.com/dotnet/roslyn/issues/16#issuecomment-70846421 by @MrJul

Pertinent APIs: http://source.roslyn.codeplex.com/#Microsoft.CodeAnalysis.CSharp/Symbols/TypeSymbolExtensions.cs,8f632696b9da5eba

In my team, I've seen different developers copy-paste portions of ITypeSymbolExtensions into our own project (e.g. `IsNullableType`, `GetNullableUnderlyingType` , `GetBaseTypes` ), which is a shame - these methods are a convenience I'm sure many other people will find useful as well.
</Description>
        <CreatedDate>24/01/2015</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>64</IssueID>
        <Title>API Request: TypeSymbolExtensions </Title>
        <Description>Forking this feature request from #16 

Original post: https://github.com/dotnet/roslyn/issues/16#issuecomment-70846421 by @MrJul

Pertinent APIs: http://source.roslyn.codeplex.com/#Microsoft.CodeAnalysis.CSharp/Symbols/TypeSymbolExtensions.cs,8f632696b9da5eba

In my team, I've seen different developers copy-paste portions of ITypeSymbolExtensions into our own project (e.g. `IsNullableType`, `GetNullableUnderlyingType` , `GetBaseTypes` ), which is a shame - these methods are a convenience I'm sure many other people will find useful as well.
</Description>
        <CreatedDate>24/01/2015</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Workspaces/Remote/ServiceHub/Services/CodeAnalysisService_AddImport.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Services/CodeAnalysisService_CodeLens.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Services/CodeAnalysisService_DesignerAttributes.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Services/CodeAnalysisService_Diagnostics.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Services/CodeAnalysisService_DocumentHighlights.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Services/CodeAnalysisService_NavigateTo.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Services/CodeAnalysisService_SymbolFinder.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Services/CodeAnalysisService_TodoComments.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Services/RemoteHostService.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Services/RemoteSymbolSearchUpdateEngine.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Services/SnapshotService.JsonRpcAssetSource.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Shared/ClientDirectStream.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Shared/ServiceHubServiceBase.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>22243</IssueID>
    <Title>Add IRaiseEventStatement operation for VB</Title>
    <Description>```cs
public interface IRaiseEventStatement : IHasArguments
{
    /// &lt;summary&gt;
    /// Reference to the event to be raised.
    /// &lt;/summary&gt;
    IEventReferenceExpression EventReference { get; }
}
```
Note that to accommodate this change, I also changed `IHasArgumentsExpression` to `IHasArguments`.

Fix #8567 and #8345</Description>
    <CreatedDate>21/09/2017</CreatedDate>
    <ClosedDate>06/10/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>8567</IssueID>
        <Title>Raising-event should be an independent `IOperation`</Title>
        <Description>Right now it is represented as method invocation.

Proposals:

```cs
public interface IRaiseEventExpression : IHasArgumentsExpression
{
    /// &lt;summary&gt;
    /// Reference to the event to be raised.
    /// &lt;/summary&gt;
    IEventReferenceExpression EventReference { get; }
}
```

or

```cs
public interface IRaiseEventExpression : IHasArgumentsExpression
{
    /// &lt;summary&gt;
    /// Referenced event.
    /// &lt;/summary&gt;
    IEventSymbol Event { get; }

    IOperation Instance { get; }
}
```</Description>
        <CreatedDate>10/02/2016</CreatedDate>
        <ClosedDate>06/10/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>8345</IssueID>
        <Title>Raise event in VB should represented by an EventReferenceExepression operation</Title>
        <Description>For this code snippet:

``` vb
RaiseEvent Mumble(Me, args)
```

There should be an EventReferenceExpression for `Mumble`, but currently it is return a FieldReferenceExpression instead.

There's a testcase `EventAndMethodReferencesVisualBasic` for this bug:
src\compilers\visualbasic\test\semantic\diagnostics\operationanalyzertests.vb
</Description>
        <CreatedDate>02/02/2016</CreatedDate>
        <ClosedDate>06/10/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IEventAssignmentExpression.cs</File>
      <File>src/Compilers/Core/Portable/Generated/Operations.xml.Generated.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IHasArguments.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IInvocationExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IObjectCreationExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IPropertyReferenceExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IRaiseEventExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationCloner.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationKind.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationVisitor.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/OperationTreeVerifier.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>22220</IssueID>
    <Title>IntroduceField code action should remove trivia as the other IntroduceVariable actions do.</Title>
    <Description>**Customer scenario**

From #21747.

&gt; CSharpIntroduceVariableService.IntroduceFieldAsync doesn't drop leading and trailing trivia the way IntroduceLocalAsync does (i.e. expression.WithoutTrailingTrivia().WithoutLeadingTrivia()). As a result, the trivia appear in both the initializer of the newly-created field and at its use-site.

&gt; I didn't check VB.

I also looked at the VB implementation and there it should be fine and covered by tests:

* Code: [`VisualBasicIntroduceVariableService.CreateFieldDeclaration`](https://github.com/dotnet/roslyn/blob/6847f1e5a909395aae9456e8f366cbf4deb86b69/src/Features/VisualBasic/Portable/IntroduceVariable/VisualBasicIntroduceVariableService_IntroduceField.vb#L198)
* Test: [`IntroduceVariableTests.TestIntroduceFieldWithTrailingTrivia`](https://github.com/dotnet/roslyn/blob/b57c9b1ebc7ad6eaabe4b8ea8fb37f9898a86325/src/EditorFeatures/VisualBasicTest/CodeActions/IntroduceVariable/IntroduceVariableTests.vb#L753)

**Bugs this fixes:**

#21747

**Workarounds, if any**

None.

**Risk**

Low.

**Performance impact**

Low.

**Is this a regression from a previous update?**

No.

**Root cause analysis:**

Wasn't covered by tests.

**How was the bug found?**

Reported by @amcasey 

**Test documentation updated?**

No.</Description>
    <CreatedDate>20/09/2017</CreatedDate>
    <ClosedDate>09/10/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>21747</IssueID>
        <Title>CSharpIntroduceVariableService.IntroduceFieldAsync doesn't drop leading and trailing trivia</Title>
        <Description>...the way IntroduceLocalAsync does (i.e. `expression.WithoutTrailingTrivia().WithoutLeadingTrivia()`).  As a result, the trivia appear in both the initializer of the newly-created field and at its use-site.</Description>
        <CreatedDate>25/08/2017</CreatedDate>
        <ClosedDate>09/10/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>21747</IssueID>
        <Title>CSharpIntroduceVariableService.IntroduceFieldAsync doesn't drop leading and trailing trivia</Title>
        <Description>...the way IntroduceLocalAsync does (i.e. `expression.WithoutTrailingTrivia().WithoutLeadingTrivia()`).  As a result, the trivia appear in both the initializer of the newly-created field and at its use-site.</Description>
        <CreatedDate>25/08/2017</CreatedDate>
        <ClosedDate>09/10/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/CodeActions/IntroduceVariable/IntroduceVariableTests.cs</File>
      <File>src/Features/CSharp/Portable/IntroduceVariable/CSharpIntroduceVariableService_IntroduceField.cs</File>
      <File>src/Features/CSharp/Portable/IntroduceVariable/CSharpIntroduceVariableService_IntroduceLocal.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>22436</IssueID>
    <Title>Clean up code from previous ref-readonly PRs</Title>
    <Description>Fixes #21981 - Remove specialcasing for Span and ReadOnlySpan before shipping
Responds to one comment on #22424 

cc @dotnet/roslyn-compiler @VSadov </Description>
    <CreatedDate>29/09/2017</CreatedDate>
    <ClosedDate>30/09/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>21981</IssueID>
        <Title>Remove specialcasing for Span and ReadOnlySpan before shipping</Title>
        <Description>We currently assume, regardless of attributes, that Span and ReadOnlySpan are
- ref-like structs
- readonly structs

This is done as a bootstrapping measure to mitigate the situation where some repos have old compilers and some implementations of span types do not have expected annotation.

We should remove the special-casing when before shipping to not set a compat precedent where annotations are unnecessary on span types.</Description>
        <CreatedDate>08/09/2017</CreatedDate>
        <ClosedDate>30/09/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22424</IssueID>
        <Title>Fixes #22381 - Use in for parameters and arguments</Title>
        <Description>Fixes #22381 - Use `in` for parameters and arguments</Description>
        <CreatedDate>29/09/2017</CreatedDate>
        <ClosedDate>29/09/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/Conversions/Conversions.cs</File>
      <File>src/Compilers/CSharp/Portable/CSharpResources.Designer.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_StackAlloc.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PENamedTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/TypeSymbolExtensions.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/SpanStackSafetyTests.cs</File>
      <File>src/Compilers/Test/Utilities/CSharp/CSharpTestBase.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>22407</IssueID>
    <Title>Remove PROTOTYPE markers from "private protected" feature</Title>
    <Description>Fixes #22244
Related to #22406

This is a comment-only change, to remove PROTOTYPE comments and replace by open issues.

@jcouv Please review and approve for 15.5.
</Description>
    <CreatedDate>28/09/2017</CreatedDate>
    <ClosedDate>30/09/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>22244</IssueID>
        <Title>Remove PROTOTYPE markers from "private protected" feature</Title>
        <Description>It looks like some PROTOTYPE markers made it through when the feature was merged.

https://github.com/dotnet/roslyn/blame/9da689b5e705672c050bbac63bccd896ba4aefbb/src/VisualStudio/CSharp/Impl/CodeModel/CSharpCodeModelService.cs#L1041

https://github.com/dotnet/roslyn/blob/9da689b5e705672c050bbac63bccd896ba4aefbb/src/VisualStudio/VisualBasic/Impl/CodeModel/VisualBasicCodeModelService.vb#L1425</Description>
        <CreatedDate>21/09/2017</CreatedDate>
        <ClosedDate>30/09/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22406</IssueID>
        <Title>No mapping for `private protected` in EnvDTE.vsCMAccess</Title>
        <Description>In `Roslyn\src\VisualStudio\VisualBasic\Impl\CodeModel\VisualBasicCodeModelService.vb`, we have

``` vb
        Public Overrides Function GetAccess(symbol As ISymbol) As EnvDTE.vsCMAccess
            Debug.Assert(symbol IsNot Nothing)

            Dim access As EnvDTE.vsCMAccess = 0

            Select Case symbol.DeclaredAccessibility
                Case Accessibility.Private
                    access = access Or EnvDTE.vsCMAccess.vsCMAccessPrivate
                Case Accessibility.Protected
                    access = access Or EnvDTE.vsCMAccess.vsCMAccessProtected
                Case Accessibility.Internal, Accessibility.Friend
                    access = access Or EnvDTE.vsCMAccess.vsCMAccessProject
                Case Accessibility.ProtectedOrInternal, Accessibility.ProtectedOrFriend
                    access = access Or EnvDTE.vsCMAccess.vsCMAccessProjectOrProtected
                Case Accessibility.ProtectedAndInternal, Accessibility.ProtectedAndFriend
                    ' PROTOTYPE: there is no appropriate mapping for private protected in EnvDTE.vsCMAccess
                    access = access Or EnvDTE.vsCMAccess.vsCMAccessProject
                Case Accessibility.Public
                    access = access Or EnvDTE.vsCMAccess.vsCMAccessPublic
                Case Else
                    Throw Exceptions.ThrowEFail()
            End Select

            If TryCast(symbol, IPropertySymbol)?.IsWithEvents Then
                access = access Or EnvDTE.vsCMAccess.vsCMAccessWithEvents
            End If

            Return access
        End Function
```

Also, in `Roslyn\src\VisualStudio\CSharp\Impl\CodeModel\CSharpCodeModelService.cs`, we have

``` c#
        public override EnvDTE.vsCMAccess GetAccess(ISymbol symbol)
        {
            switch (symbol.DeclaredAccessibility)
            {
                case Accessibility.Public:
                    return EnvDTE.vsCMAccess.vsCMAccessPublic;
                case Accessibility.Private:
                    return EnvDTE.vsCMAccess.vsCMAccessPrivate;
                case Accessibility.Internal:
                    return EnvDTE.vsCMAccess.vsCMAccessProject;
                case Accessibility.Protected:
                    return EnvDTE.vsCMAccess.vsCMAccessProtected;
                case Accessibility.ProtectedOrInternal:
                    return EnvDTE.vsCMAccess.vsCMAccessProjectOrProtected;
                case Accessibility.ProtectedAndInternal:
                    // PROTOTYPE: there is no appropriate mapping for private protected in EnvDTE.vsCMAccess
                    return EnvDTE.vsCMAccess.vsCMAccessProtected;
                default:
                    throw Exceptions.ThrowEFail();
            }
        }
```

I am deleting the `PROTOTYPE` comments, and filing this bug to track the fact that there may be work here if and when `EnvDTE` supports the protected mode `Accessibility.ProtectedAndInternal`</Description>
        <CreatedDate>28/09/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/VisualStudio/CSharp/Impl/CodeModel/CSharpCodeModelService.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>22388</IssueID>
    <Title>Added tests for `out` and `ref` completion in local function</Title>
    <Description>Tests added in response to issue #22253.  
The issue was fixed by a previous PR by #17447 which was merged into master with #22050.
This PR is for additional tests only.

**Customer scenario**
If customer is in a local function, out and ref will not appear in the completion list when adding a parameter

**Bugs this fixes:**
#22253

**Risk**
Low, tests only

**Performance impact**
Low, only 2 tests added

**How was the bug found?**
Team member filed issue

**Test documentation updated?**
N/A

</Description>
    <CreatedDate>28/09/2017</CreatedDate>
    <ClosedDate>28/09/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>22253</IssueID>
        <Title>Completion on `out` in local function impedes with typing</Title>
        <Description>I tried to add an out parameter to a local function and Intellisense forced a completion of a type name instead of `out`.

![image](https://user-images.githubusercontent.com/12466233/30706186-79bb6e1e-9eac-11e7-8d4a-d80452857185.png)


FYI @agocke @Pilchie for triage</Description>
        <CreatedDate>21/09/2017</CreatedDate>
        <ClosedDate>28/09/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>17447</IssueID>
        <Title>IDE support for ref readonly/in tokens in completion service</Title>
        <Description>Related to #17287</Description>
        <CreatedDate>28/02/2017</CreatedDate>
        <ClosedDate>03/03/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22050</IssueID>
        <Title>Merge features/readonly-ref to master</Title>
        <Description>Merge from features/readonly-ref into master.

Brings a number of interconnected features geared towards system/hi-perf programming.

User facing features:
- `ref readonly`  parameters
- `ref readonly` return
- `ref` extension methods
- `ref readonly` extension methods
- `ref` ternary expressions
- `readonly` stucts
- `ref` structs     (such as `Span&lt;T&gt;` and `ReadonlySpan&lt;T&gt;`  and structs that contain them)
- escape analysis for byref variables and `ref struct` values
- safe `stackalloc`
- various optimizations for scenarios that involve readonly fields, stackalloc, fixed, unsafe . . .
- peverify-compat mode

Internal improvements:
- attribute embedding infrastructure
- separation of variable/lvalue and writeable/readonly analysis

==== See also
- Championed feature at https://github.com/dotnet/csharplang/issues/666
- Proposal for `[ref] readonly` at https://github.com/dotnet/csharplang/blob/master/proposals/readonly-ref.md    (ignore `in`, that is gone)  
- Detailed spec for Ref-Like types at https://github.com/dotnet/csharplang/blob/master/proposals/span-safety.md
- Smaller design details of the features above. - https://github.com/VSadov/csharplang/blob/RefSpanDesignChoices/proposals/RefReadonlySpanDesignChoices.md
- Test plan for ref `[ref] readonly` at https://github.com/dotnet/roslyn/issues/19216
- Test Plan for Span&lt;T&gt;, aka interior pointer, aka stackonly struct at https://github.com/dotnet/roslyn/issues/20127
</Description>
        <CreatedDate>11/09/2017</CreatedDate>
        <ClosedDate>21/09/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22253</IssueID>
        <Title>Completion on `out` in local function impedes with typing</Title>
        <Description>I tried to add an out parameter to a local function and Intellisense forced a completion of a type name instead of `out`.

![image](https://user-images.githubusercontent.com/12466233/30706186-79bb6e1e-9eac-11e7-8d4a-d80452857185.png)


FYI @agocke @Pilchie for triage</Description>
        <CreatedDate>21/09/2017</CreatedDate>
        <ClosedDate>28/09/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest2/Recommendations/OutKeywordRecommenderTests.cs</File>
      <File>src/EditorFeatures/CSharpTest2/Recommendations/RefKeywordRecommenderTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>22320</IssueID>
    <Title>Quote variable/array expansions in shell scripts</Title>
    <Description>Lack of quoting causes issues when files have spaces or are empty names.
Additionally, some arrays (though single elements) were treated like
simple variables.

The careful reader will note that I have left BUILD_ARGS

`dotnet build "${ROOT_PATH}"/CrossPlatform.sln ${BUILD_ARGS}`

untouched, because it contains spaces meant to separate arguments. Word
expansion is somewhat desired there (I believe) to ensure the arguments
are properly parsed. Unfortunately, BUILD_ARGS may contains paths with
spaces in them, causing this to still fail.

Fix #22259

**Customer scenario**

Try to build roslyn in a path with spaces and fail.

**Bugs this fixes:**

#22259 

**Workarounds, if any**

Don't use a path with spaces.

**Risk**

I'm very wary of this particular change, as it *likely* won't break anything currently (no paths with spaces) but is hard to guarantee for paths with spaces (we don't have test coverage).
As this is my first real contribution, I may have inadvertently quoted something I shouldn't have.

**Performance impact**

Low: these are shell scripts anyways, and the extra quotes should require negligible time compared to the scripts.

**Is this a regression from a previous update?**

I don't think so.

**Root cause analysis:**

We still don't have test coverage (although it appears there has been some discussion on getting some #20929), so I'm not sure we can 100% verify this yet. This is a known issue.

**How was the bug found?**

I tried to build roslyn in a directory whose full name contained spaces.</Description>
    <CreatedDate>25/09/2017</CreatedDate>
    <ClosedDate>27/09/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>22259</IssueID>
        <Title>Path names with spaces fail in build/scripts/obtain_dotnet.sh</Title>
        <Description>**Version Used**: 
```
$ git describe
Visual-Studio-2017-Version-15.3-3100-gf827f7a88c
```

**Steps to Reproduce**:

1. Clone `roslyn` into a directory with spaces in the path (e.g. `/Volumes/G-DRIVE ev RaW SSD/Home/roslyn`)
2. Run `./build/scripts/obtain_dotnet.sh` to obtain dotnet-CLI in order to build roslyn

**Expected Behavior**:

The pathname is handled accordingly.

**Actual Behavior**:

```
$ ./build/scripts/obtain_dotnet.sh
./build/scripts/obtain_dotnet.sh: line 25: /Volumes/G-DRIVE: No such file or directory
```

**Possible Solution**

Line 25 reads:
```bash
    source ${THIS_DIR}/build-utils.sh
```

There are other lines, both in `obtain_dotnet.sh` and other `*.sh` files that contain *unquoted* variables. This is problematic, as the variables undergo word splitting and causes issues like the above. See e.g. [BashPitfalls](http://mywiki.wooledge.org/BashPitfalls#cd_.24.28dirname_.22.24f.22.29) for many discussions on this.</Description>
        <CreatedDate>21/09/2017</CreatedDate>
        <ClosedDate>27/09/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22259</IssueID>
        <Title>Path names with spaces fail in build/scripts/obtain_dotnet.sh</Title>
        <Description>**Version Used**: 
```
$ git describe
Visual-Studio-2017-Version-15.3-3100-gf827f7a88c
```

**Steps to Reproduce**:

1. Clone `roslyn` into a directory with spaces in the path (e.g. `/Volumes/G-DRIVE ev RaW SSD/Home/roslyn`)
2. Run `./build/scripts/obtain_dotnet.sh` to obtain dotnet-CLI in order to build roslyn

**Expected Behavior**:

The pathname is handled accordingly.

**Actual Behavior**:

```
$ ./build/scripts/obtain_dotnet.sh
./build/scripts/obtain_dotnet.sh: line 25: /Volumes/G-DRIVE: No such file or directory
```

**Possible Solution**

Line 25 reads:
```bash
    source ${THIS_DIR}/build-utils.sh
```

There are other lines, both in `obtain_dotnet.sh` and other `*.sh` files that contain *unquoted* variables. This is problematic, as the variables undergo word splitting and causes issues like the above. See e.g. [BashPitfalls](http://mywiki.wooledge.org/BashPitfalls#cd_.24.28dirname_.22.24f.22.29) for many discussions on this.</Description>
        <CreatedDate>21/09/2017</CreatedDate>
        <ClosedDate>27/09/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>20929</IssueID>
        <Title>Roslyn enlistment path restrictions</Title>
        <Description>There are a number of requirements Roslyn has on the path on which it is enlisted:

- Cannot contain spaces
- Cannot contain SEMICOLON (U+003B) character
- Cannot contain `%`, `@` or `$` characters

These limitations are unnecessary and in theory could be supported. However it would require **both**

- Changes to our build scripts and external tooling to support the characters
- Changing to our test infrastructure to verify we don't regress the behavior

The latter in particular is the most important. There have been a number of attempts to remove our limitation on no spaces. These have never been accompanied with the corresponding infrastructure changes and hence the fixes last a week at most before we break them again. 

Using this issue to track the many small limitations we have on the enlistment path. 
</Description>
        <CreatedDate>18/07/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>22318</IssueID>
    <Title>Avoid scheduling an unnecessary dispose task for EmptyAsyncToken</Title>
    <Description>Fixes #22272

**Customer scenario**

Long sequences of asynchronous operations can be scheduled (#22274), which is a problematic condition further exacerbated by the scheduling of a separate call to an empty `Dispose` method.

**Bugs this fixes:**

#22272

**Workarounds, if any**

None

**Risk**

Very low. Avoids scheduling an asynchronous call to an empty non-virtual method.

**Performance impact**

Improves performance by eliminating an asynchronous operation.

**Is this a regression from a previous update?**

No.

**Root cause analysis:**

Found during manual analysis of heaps provided by "low memory" events.

**How was the bug found?**

Manual inspection of heap dumps.

**Test documentation updated?**

N/A
</Description>
    <CreatedDate>25/09/2017</CreatedDate>
    <ClosedDate>25/09/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>22272</IssueID>
        <Title>CompletesTrackingOperation should not dispose of EmptyAsyncToken</Title>
        <Description>**Version Used**: 15.3

:memo: Observed 18,000 scheduled tasks in a work queue in a "low memory" heap dump submitted for analysis.

When `TaskExtensions.CompletesTrackingOperation` is called with `EmptyAsyncToken.Instance`, it should not attempt to dispose of the token. The `Dispose()` method is empty, and scheduling the operation has substantial overhead.
</Description>
        <CreatedDate>21/09/2017</CreatedDate>
        <ClosedDate>25/09/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22274</IssueID>
        <Title>WorkCoordinator.Reanalyze should avoid duplicate scheduling</Title>
        <Description>**Version Used**: 15.3

:memo: Observed 18,000 scheduled operations during analysis of a heap dump provided for a "low memory" condition. The `HashSet&lt;DiagnosticId&gt;` instances required to queue the requested analysis operations accounted for nearly 1GiB of memory overhead.

`WorkCoordinator.Reanalyze` schedules analysis operations on sets of documents:

https://github.com/dotnet/roslyn/blob/c83a39086d062ae46e4eb333970b0cf59feba1a2/src/Features/Core/Portable/SolutionCrawler/WorkCoordinator.cs#L166-L170

These analysis operations may take time. To avoid unnecessary memory overhead, operations should not be scheduled for a `DocumentId` when another scheduled operation will already update that document.</Description>
        <CreatedDate>21/09/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22272</IssueID>
        <Title>CompletesTrackingOperation should not dispose of EmptyAsyncToken</Title>
        <Description>**Version Used**: 15.3

:memo: Observed 18,000 scheduled tasks in a work queue in a "low memory" heap dump submitted for analysis.

When `TaskExtensions.CompletesTrackingOperation` is called with `EmptyAsyncToken.Instance`, it should not attempt to dispose of the token. The `Dispose()` method is empty, and scheduling the operation has substantial overhead.
</Description>
        <CreatedDate>21/09/2017</CreatedDate>
        <ClosedDate>25/09/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Features/Core/Portable/Shared/TestHooks/IAsyncToken.cs</File>
      <File>src/Features/Core/Portable/Shared/TestHooks/TaskExtensions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>22296</IssueID>
    <Title>ported tests from https://github.com/dotnet/roslyn/pull/21263</Title>
    <Description>main issue the PR is trying to fix (#18405) is addressed by this (https://github.com/dotnet/roslyn/pull/21857). 

this mainly port over tests added by this pr (#21263) with some changes.

in some cases such as params array, argument node get removed while converted to IOperation since compiler generated array replaces the argument.

for those, I just made test to dump including statement. for now, the test doesn't show interesting info, but once @jinujoseph finishes the work to show syntax kind/isImplicit/parent in the test, it will show info such as what got injected (param array) and argument got removed.

</Description>
    <CreatedDate>22/09/2017</CreatedDate>
    <ClosedDate>23/09/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>18405</IssueID>
        <Title>[IOperation] Getting the IOperation for a single argument returns the entire expression using the argument</Title>
        <Description>Paste the following code into ETA:

```C#
class Program
{
    static void Main(string[] args)
    {
        Main(new[] { "asdf" });
    }
}
```

Getting the IOperation for the `new[] { "asdf" }` statement returns the following:

```
IOperation tree for "new[] { "asdf" }"

IInvocationExpression (static void Program.Main(System.String[] args)) (OperationKind.InvocationExpression, Type: System.Void)
  IArgument (Matching Parameter: args) (OperationKind.Argument)
    IArrayCreationExpression (Dimension sizes: 1, Element Type: System.String) (OperationKind.ArrayCreationExpression, Type: System.String[])
      ILiteralExpression (OperationKind.LiteralExpression, Type: System.Int32, Constant: 1)
      IArrayInitializer (OperationKind.ArrayInitializer)
        ILiteralExpression (OperationKind.LiteralExpression, Type: System.String, Constant: asdf)
```

It should be returning just the `IArgument`.</Description>
        <CreatedDate>03/04/2017</CreatedDate>
        <ClosedDate>27/09/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>21263</IssueID>
        <Title>Map ArgumentSyntax nodes to appropriate IArgument operations</Title>
        <Description>Fixes https://github.com/dotnet/roslyn/issues/18405</Description>
        <CreatedDate>02/08/2017</CreatedDate>
        <ClosedDate>27/09/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IArgument.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>22285</IssueID>
    <Title>IDE Features fix for code generation for ref-readonly</Title>
    <Description>Fixes #22242 - Implement Interface loses "ref readonly"
Fixes #22241 - Replace lambda with local function loses "ref readonly"
Fixes #22240 - Add Accessibility modifier removes "ref" from a ref struct
Fixes #22239 - Change Signature does not show "ref readonly" modifier on parameters
Fixes #22238 - Extract interface loses "ref readonly" on parameters and returns

I split this PR into two commits:
* One has all the refactoring (threading RefKinds through various APIs)
* Another for the tests, roughly one test file change per bug above.</Description>
    <CreatedDate>22/09/2017</CreatedDate>
    <ClosedDate>28/09/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>22242</IssueID>
        <Title>Implement Interface loses "ref readonly"</Title>
        <Description>Implement interface refactoring loses "ref readonly" on parameters. 

Inherit from abstract class does this too. </Description>
        <CreatedDate>21/09/2017</CreatedDate>
        <ClosedDate>28/09/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22241</IssueID>
        <Title>Replace lambda with local function loses "ref readonly"</Title>
        <Description>```cs
        delegate ref readonly int D1(ref readonly int arg);

            D1 dd = (ref readonly int a) =&gt; ref a;
```

Replace dd with a local function using IDE. - loses "ref readonly"
</Description>
        <CreatedDate>21/09/2017</CreatedDate>
        <ClosedDate>28/09/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22240</IssueID>
        <Title>Add Accessibility modifier removes "ref" from a ref struct</Title>
        <Description>
Invoke Refactor/Add Accessibility modifiers on 

```cs
readonly unsafe ref struct S1 { }
```
The dialog offers adding "private", but also offers to remove "ref"

</Description>
        <CreatedDate>21/09/2017</CreatedDate>
        <ClosedDate>28/09/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22239</IssueID>
        <Title>Change Signature does not show "ref readonly" modifier on parameters</Title>
        <Description>
The Change Signature  shows  other modifiers like "out" but not "ref readonly" - not sure if it does not understand it or because it simply does not fit. There is no much space in that UI.</Description>
        <CreatedDate>21/09/2017</CreatedDate>
        <ClosedDate>28/09/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22238</IssueID>
        <Title>Extract interface loses "ref readonly" on parameters and returns</Title>
        <Description>
parameters become an ordinary `ref`, returns become ordinary byval returns.</Description>
        <CreatedDate>21/09/2017</CreatedDate>
        <ClosedDate>28/09/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Lowering/IteratorRewriter/IteratorFinallyMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/StateMachineRewriter/SynthesizedStateMachineProperty.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/SynthesizedMethodBaseSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/AnonymousTypes/SynthesizedSymbols/AnonymousType.ConstructorSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/AnonymousTypes/SynthesizedSymbols/AnonymousType.EqualsMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/AnonymousTypes/SynthesizedSymbols/AnonymousType.GetHashCodeMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/AnonymousTypes/SynthesizedSymbols/AnonymousType.PropertyAccessorSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/AnonymousTypes/SynthesizedSymbols/AnonymousType.PropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/AnonymousTypes/SynthesizedSymbols/AnonymousType.ToStringMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ErrorMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ErrorPropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PEMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PEParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Metadata/PE/PEPropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/MethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/PropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/ReducedExtensionMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/SignatureOnlyMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/SignatureOnlyPropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/LambdaSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/LocalFunctionSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceConstructorSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceDelegateMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceDestructorSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceEventAccessorSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceMemberContainerSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceMemberMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceOrdinaryMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourcePropertyAccessorSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourcePropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceUserDefinedOperatorSymbolBase.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedDelegateSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedEntryPointSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedGlobalMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedImplementationMethod.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedInstanceConstructor.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedInteractiveInitializerMethod.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedIntrinsicOperatorSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedSealedPropertyAccessor.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedStaticConstructor.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Wrapped/WrappedMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Wrapped/WrappedPropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Utilities/EnumExtensions.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/AmbiguousOverrideTests.cs</File>
      <File>src/Compilers/Core/Portable/InternalUtilities/EnumUtilties.cs</File>
      <File>src/Compilers/Core/Portable/Symbols/IMethodSymbol.cs</File>
      <File>src/Compilers/Core/Portable/Symbols/IPropertySymbol.cs</File>
      <File>src/Compilers/Core/Portable/Symbols/RefKind.cs</File>
      <File>src/EditorFeatures/CSharp/EventHookup/EventHookupCommandHandler_TabKeyCommand.cs</File>
      <File>src/EditorFeatures/CSharpTest/AddAccessibilityModifiers/AddAccessibilityModifiersTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/ExtractInterface/ExtractInterfaceTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/ImplementAbstractClass/ImplementAbstractClassTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/ImplementInterface/ImplementInterfaceTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/UseLocalFunction/UseLocalFunctionTests.cs</File>
      <File>src/EditorFeatures/Test/CodeGeneration/CodeGenerationTests.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Source/ExpressionCompiler/Symbols/EEMethodSymbol.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Source/ExpressionCompiler/Symbols/PlaceholderMethodSymbol.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Source/ExpressionCompiler/Symbols/SynthesizedContextMethodSymbol.cs</File>
      <File>src/Features/CSharp/Portable/ExtractMethod/CSharpMethodExtractor.CSharpCodeGenerator.cs</File>
      <File>src/Features/CSharp/Portable/GenerateMember/GenerateParameterizedMember/CSharpGenerateConversionService.cs</File>
      <File>src/Features/CSharp/Portable/GenerateMember/GenerateParameterizedMember/CSharpGenerateParameterizedMemberService.cs</File>
      <File>src/Features/CSharp/Portable/GenerateType/CSharpGenerateTypeService.cs</File>
      <File>src/Features/CSharp/Portable/UseLocalFunction/CSharpUseLocalFunctionCodeFixProvider.cs</File>
      <File>src/Features/Core/Portable/Completion/Providers/AbstractPartialMethodCompletionProvider.cs</File>
      <File>src/Features/Core/Portable/EncapsulateField/AbstractEncapsulateFieldService.cs</File>
      <File>src/Features/Core/Portable/ExtractInterface/AbstractExtractInterfaceService.cs</File>
      <File>src/Features/Core/Portable/GenerateMember/GenerateParameterizedMember/AbstractGenerateMethodService.State.cs</File>
      <File>src/Features/Core/Portable/GenerateMember/GenerateParameterizedMember/AbstractGenerateParameterizedMemberService.MethodSignatureInfo.cs</File>
      <File>src/Features/Core/Portable/GenerateMember/GenerateParameterizedMember/AbstractGenerateParameterizedMemberService.SignatureInfo.cs</File>
      <File>src/Features/Core/Portable/GenerateMember/GenerateVariable/AbstractGenerateVariableService.CodeAction.cs</File>
      <File>src/Features/Core/Portable/GenerateType/AbstractGenerateTypeService.GenerateNamedType.cs</File>
      <File>src/Features/Core/Portable/InitializeParameter/AbstractInitializeMemberFromParameterCodeRefactoringProviderMemberCreation.cs</File>
      <File>src/Features/Core/Portable/MetadataAsSource/AbstractMetadataAsSourceService.WrappedMethodSymbol.cs</File>
      <File>src/Features/Core/Portable/MetadataAsSource/AbstractMetadataAsSourceService.WrappedPropertySymbol.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ChangeSignature/ChangeSignatureDialogViewModel.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Venus/ContainedLanguageCodeSupport.cs</File>
      <File>src/VisualStudio/Core/Impl/CodeModel/AbstractCodeModelObject_CodeGen.cs</File>
      <File>src/Workspaces/CSharp/Portable/CodeGeneration/CSharpSyntaxGenerator.cs</File>
      <File>src/Workspaces/CSharp/Portable/CodeGeneration/MethodGenerator.cs</File>
      <File>src/Workspaces/CSharp/Portable/CodeGeneration/ParameterGenerator.cs</File>
      <File>src/Workspaces/CSharp/Portable/CodeGeneration/PropertyGenerator.cs</File>
      <File>src/Workspaces/CSharp/Portable/Extensions/ITypeSymbolExtensions.cs</File>
      <File>src/Workspaces/CSharp/Portable/Extensions/TypeSyntaxExtensions.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/CodeGenerationSymbolFactory.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/Symbols/CodeGenerationAbstractMethodSymbol.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/Symbols/CodeGenerationConstructedMethodSymbol.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/Symbols/CodeGenerationConstructorSymbol.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/Symbols/CodeGenerationConversionSymbol.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/Symbols/CodeGenerationDestructorSymbol.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/Symbols/CodeGenerationMethodSymbol.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/Symbols/CodeGenerationOperatorSymbol.cs</File>
      <File>src/Workspaces/Core/Portable/CodeGeneration/Symbols/CodeGenerationPropertySymbol.cs</File>
      <File>src/Workspaces/Core/Portable/Editing/DeclarationModifiers.cs</File>
      <File>src/Workspaces/Core/Portable/Shared/Extensions/ICodeDefinitionFactoryExtensions_CreateEqualsMethod.cs</File>
      <File>src/Workspaces/Core/Portable/Shared/Extensions/ICodeDefinitionFactoryExtensions_CreateGetHashCodeMethod.cs</File>
      <File>src/Workspaces/Core/Portable/Shared/Extensions/IMethodSymbolExtensions.cs</File>
      <File>src/Workspaces/Core/Portable/Shared/Extensions/IParameterSymbolExtensions.cs</File>
      <File>src/Workspaces/Core/Portable/Shared/Extensions/IPropertySymbolExtensions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>22284</IssueID>
    <Title>Create tests to cover test plans #19216 and #20127</Title>
    <Description>* Create tests to cover test plans #19216 and #20127
* Filed issues for the items not covered by tests here.
* Fixed a small bug where `RefKind.RefReadOnly` was displayed as `in` in one error message.
* Fixed a small bug where nested ternary operator statements were not allowed for `stackalloc`.</Description>
    <CreatedDate>22/09/2017</CreatedDate>
    <ClosedDate>28/09/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>19216</IssueID>
        <Title>Test plan for "ref readonly" and related features (7.2)</Title>
        <Description>Write a test plan for "ref readonly", "readonly structs", "ref and ref readonly extensions" and "ref ternary"

## LDM
- [x] remove `in` syntax from initial release? ([merged](https://github.com/dotnet/roslyn/pull/22182))
- [x] ref readonly locals? (implemented in 7.2, Andy)
- [x] allowing `ref readonly` at call site (for those who dislike auto-ref)? (yes, but we're switching to `in` as keyword)
- [ ] throw expression in ref ternary
- [x] ref re-assignment (discussed in Oct 2nd LDM, C# 7.2 candidate)
- [ ] Overloading on in/byval should cause an error (#22132)
- [x] Should referencing [IsReadOnly] methods without an [IsConst] modreq be allowed? (#19792) (yes)

## Spec
- [x] Merge the "decisions made" spec into the existing docs
- [ ] Note that `in` parameters are not allowed in iterator or async methods
- [ ] Note that you can take unmanaged address of readonly variable (https://github.com/dotnet/roslyn/pull/22400)
- [ ] Note the typing rule for stackalloc (`var x = stackalloc ...` is pointer type for compat reasons, but `condition ? stackalloc ... : stackalloc ...` is `Span`)

## Misc

- [x] Add feature docs for all these features (latest rules on Span, ref re-assignment)
- [ ] Update Compiler test plan (stackalloc, in/ref readonly, ref struct)
- [ ] Review BCL work (are the new types everywhere? for example, Span in mono?)
- [ ] do IDE test pass
    - [x] verify IDE completion and formatting on `ref readonly`, `in`, `return ref ...`, `ref` ternary, 
    - [x] CodeStyle for `in` versus `ref readonly`
    - [ ] Analyzer/code fixer to recommend `readonly struct`
    - [ ] If we choose to allow `ref readonly` at call site, CodeStyle for call site (for those who don't like auto-ref)
   - [x] Block EE (problem with emitting attribute types?)
   - [ ] Test Interactive
- [ ] Test on various runtimes (desktop, core, native, mono). May need a spec of expected runtime behavior.
- [ ] Triage remaining issues for the feature
- [x] dogfood in Roslyn repo (https://github.com/dotnet/roslyn/pull/26010)
- [ ] document PE Verify gaps (either with existing tracking issue, or creating a new one)


## Ref readonly parameters
- [x] [Spec](https://github.com/dotnet/csharplang/blob/master/proposals/readonly-ref.md) exists
- [x] test passing too many modifiers ("ref readonly in" or "in ref readonly", etc)
- [x] verify API declaration and usage from compilation, image, metadata-only image and ref assembly
- [x] ref readonly property from metadata with different attributes on getter and property
- [x] Where is it allowed or blocked?
    - [x] combine with `out` or `params` (expect error)
    - [x] `ref readonly` is disallowed: in local declarations `ref readonly var x = y;`, in front of expressions `var x = ref readonly y;`, `return ref readonly`, `foreach (readonly ref i in ...)`
    - [x] ref readonly optional parameter
    - [x] using `in` and `ref readonly` in lambda
    - [x] using `in` in delegate
    - [x] using `in` in local function
    - [x] using `in` in async and iterator methods (disallowed)
    - [x] explicit `in` or `ref readonly` at call site (disallowed)
    - [x] the order of `ref` and `readonly` does matter (what is the error? should we offer a fixer?)
    - [x] Using `in` in pattern-based lowering:
        - [x] `Deconstruct` method with `in` parameters is not applicable for deconstruction
        - [x] Implementing an task-like with `in` in builder type 
        - [x] enumerable/enumerator `GetEnumerator(in int count = 10)` (see #19742)

    
- [x] OHI
    - [x] methods differing in `ref/out/in` (we only consider types)
    - [x] invoke `M(1);` with `void M(ref readonly int i) { }` and `void M(int i) { }` in situation of ambiguity (because of inheritance or extension methods)

- [x] verify `in` is invariant (because of CLR limitation, just like `out`)
 
- [ ] Verify that IL for copy versus no-copy
     - [ ] Passing in an RValue should work (making a temp copy, verify IL)
     - [ ] Default values (temp copy)
     - [ ] LValue need no copy
     - [ ] test spilling for `M(someInArg, async M2(), someOtherInArg)`
            - `someInArg` could be local, constant, `RefReadonlyM(refReadonlyField)`, `someArray[index]`, `field`
- [ ] No writes allowed:
    - [ ] assignment, compound assignment, passing as `ref`
    - [ ] invocation (`in S s`, then `s.Mutate();`) (also allowed, operating on a temp copy, verify IL. But no copy if `S` is readonly struct)
    - [ ] calling into a method passing `in` through is ok
    - [ ] returning ref readonly parameter as ref (disallowed)
    - [ ] returning ref parameter as ref readonly (allowed)
- [ ] `in` parameters cannot be captured (lambda/async/iterator)
- [x] `in` allowed in indexer and operator parameters
- [x] test VB interop (calling blocked because modreq on overridable members and delegate/interface methods, but allowed on non-overridable members)
- [x] taking pointer to ref readonly parameter (in unsafe code) is disallowed
- [x] passing `nameof` expression as `in` argument (expect copy?)

## Ref readonly returns
- [x] [Spec](https://github.com/dotnet/csharplang/blob/master/proposals/readonly-ref.md) exists
- [x] `in` syntax disallowed in method declaration
- [x] `ref readonly` return in async method (no syntax for it)
- [x] `ref readonly` return on operator is disallowed (no syntax for it)
     - [x] operator from metadata should be handled (load as operator, but use-site error?)
- [x] `ref readonly` on indexer (allowed)
- [x] `readonly` is disallowed in `return` statement
- [x] signature needs exact match in OHI
     - [x] differentiates between `in` and `ref`
- [x] ref-readonly-returning lambda?
- [x] calling with a discard (no syntax for it?)
   
- [x] metadata:
    - [x] `IsReadOnlyAttribute` gets embbeded if not found, disallowed in source
    - [x] what if the attribute exists, but has wrong ctor shape?
    - [x] If `InAttribute` modreq present but `IsReadOnlyAttribute` is missing, then cannot load metadata
    - [x] If `IsReadOnlyAttribute` is present, but `InAttribute` modreq is missing, then can load and this absence of modreq will be carried over when overriding.
    - [x] modreq always emitted (test VB interop)
    - [x] verify API declaration and usage from compilation, image, metadata-only image and ref assembly

## Readonly struct
- [x] Spec
- [ ] `readonly` on class declaration and other illegal members
    - [ ] `readonly` is floating, but `ref` must be next to `struct` in `readonly ref struct`
    - [ ] `partial` must be before `ref` or `struct` (but what about the `readonly`?)
    - [ ] no `in` struct
- [ ] `readonly` on half a partial struct (allowed, just like other modifiers)
- [ ] How is it surfaced in symbol (semantic model)?
- [ ] verify API declaration and usage from compilation, image, metadata-only image and ref assembly
- [ ] readonly attribute is missing, readonly attribute specified in source, obsolete attribute is missing
- [ ] `Obsolete` attribute given by user wins. There should be a warning.
- [ ] can call `void M(in S s)` with `M(this)`, but not `void M(ref S s)`.
- [ ] can call `void M(S s)` with `M(this)`, but that will make a copy.
- [ ] `this` cannot be captured by lambda or other
- [ ] taking a pointer to `this` is disallowed
- [ ] all fields must be readonly
- [ ] property setters and events are disallowed


## Ref ternary
- [ ] Blocked in expression tree
- [ ] `(b ? ref x : ref y).M()` where `M` is ref extension method, regular extension method (error), regular method (error)
     - [ ] does it make copies? what if `x` or `y` or both are readonly structs?
- [ ] for `M(b ? ref x : ref y)` where `void M(in ...)`, I expect no temporary.
- [ ] for `b ? ref M() : ref M2()` where `ref readonly C M()` (and same for M2), expect the ternary is readonly
- [ ] for `b ? ref this : ref this` where `this` refers to a readonly struct, is the ternary readonly?
- [ ] what if the branches differ in readonlyness in the examples above?
- [ ] what if `b` is known to be constant (compiler knows which branch will be executed)?
- [ ] Mixing ref and non-ref is disallowed. `b ? ref x : y`
- [ ] Nesting. `b1 ? ref (b2 ? ref x : ref y) : ref z`
- [ ] No ref coalescing operator `ref x ?? ref y`
- [ ] Pattern matching on a ref ternary, or on a ref readonly ternary (this may matter later with tuple/deconstruction pattern?)
- [ ] `b ? ref x : ref default` (disallowed)
- [ ] Ref ternaries in tuple literal
- [x] Ref ternary with throw expression (https://github.com/dotnet/csharplang/issues/919)
- [ ] Ref ternary as `in` argument (`M(in condition ? ref x : ref y);`)

## Ref readonly extension methods
- [x] `ref readonly S Extension(ref readonly this S s) { return ref s; }`
- [x] `void RRExtension&lt;T&gt;(ref readonly this T t) { ... }` (expect error)
- [x] `42.RRExtension()` (ok, but makes temporary)
- [x] `readonlyField.RRExtension()` (expect no temporary)
- [x] `refReadonlyParameter.RRExtension()` (expect no temporary)
- [x] `M().RRExtension()` (expect no temporary)
- [ ] `this.RRExtension()` 
     - [ ] on readonly struct (expect no temporary)
     - [ ] on a plain struct (expect makes temporary)
- [ ] `(ref readonly ternary).RRExtension()` (expect no temporary)
- [ ] Why do we allow on rvalues? (I assume for consistency with methods)
- [x] verify API declaration and usage from compilation, image, metadata-only image and ref assembly

## Ref-like types and safety (Span)
- [x] [Spec](https://github.com/dotnet/csharplang/blob/master/proposals/span-safety.md) exists
- [ ] See Neal's test plan: https://github.com/dotnet/roslyn/issues/20127
- [x] `ref readonly string M(ref readonly string s = "hello") { return ref s; }`. Same with value type. (gives a unsafe-to-escape diagnostic)
- [ ] test foreach with API pattern (as opposed to interface) on ref-like iterator
- [x] dynamic and stackalloc
     - [x] `dynamic d = stackalloc int[10];`
     - [x] `Span&lt;dynamic&gt; d = stackalloc dynamic[10];`

## Misc
- [ ] `(b ? ref x : ref x).foo()`
- [ ] `x.y.foo() // ref may be inferred`
- [ ] Interaction with dynamic? nullable?
- [x] attributes `IsReadOnly` and `IsByRefLike` are disallowed in source

See also
- [Language Feature Status](https://github.com/dotnet/roslyn/blob/master/docs/Language%20Feature%20Status.md)
- [The feature branch](https://github.com/dotnet/roslyn/tree/features/readonly-ref)
- [[Work items] Readonly ref parameters/returns](https://github.com/dotnet/roslyn/issues/17287)
- [Proposal (ref readonly, readonly struct, ref extensions)](https://github.com/dotnet/csharplang/blob/master/proposals/readonly-ref.md)
- [Ref-like types and safety](https://github.com/dotnet/csharplang/blob/master/proposals/span-safety.md), 
- [Decisions made](https://github.com/VSadov/csharplang/blob/RefSpanDesignChoices/proposals/RefReadonlySpanDesignChoices.md)
</Description>
        <CreatedDate>03/05/2017</CreatedDate>
        <ClosedDate>12/11/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>20127</IssueID>
        <Title>Test Plan for Span&lt;T&gt;, aka interior pointer, aka stackonly struct</Title>
        <Description>[This](https://github.com/dotnet/roslyn/issues/20127) is a test plan for the feature set variously known as "stackonly structs", "interior pointer", and "Span&lt;T&gt;" targeting milestone 15.6 (C# 7.2), which is related to (but different from) slicing.

See also
- Championed feature at https://github.com/dotnet/csharplang/issues/666
- Proposed safety rules at https://github.com/dotnet/csharplang/blob/master/proposals/csharp-7.2/span-safety.md
- Test plan for ref readonly at https://github.com/dotnet/roslyn/issues/19216
- Test plan suggestions at https://github.com/dotnet/roslyn/blob/master/docs/contributing/Compiler%20Test%20Plan.md

## Declarations and types

### `ref struct` declarations
- [ ] The parser accepts `ref` as a modifier on a `struct` declaration
- [ ] The `ref` modifier must appear immediately before the `struct` keyword (no intervening `public`)
- [ ] A `ref struct` type cannot be partial (neither `ref partial struct` nor `partial ref struct` are accepted)
- [ ] A `ref struct` type may be generic
- [ ] A `ref struct` type *may* contain an instance field of another `ref struct` type
- [ ] Neither a non-ref `struct`, nor a class, may contain a field of a `ref struct` type
- [ ] A `ref struct` type declaration may not contain a base clause. It therefore cannot be declared to extend any interface type.
- [ ] It is not legal to use `base` in the body of any method, property, etc in a `ref struct` type.
- [ ] A `ref struct` type declaration may not contain an iterator instance method.
- [ ] A `ref struct` type declaration may not contain an async instance method.
- [ ] A `ref struct` type declaration may contain a static iterator method, and a static async method.
- [ ] (NoPia) A `ref struct` type may not be embedded.

### use of `ref struct` types
- [ ] A `ref struct` type may not be used as a type argument to a `class`, `struct`, `delegate`, or method.
  - [ ] It is an error to construct `System.Nullable` with a type argument of a `ref struct` type, even implicitly.
  - [ ] If an instance method `e.M` returns a value of a `ref struct` type, `e?.M()` is an error.
  - [ ] If type inference infers a `ref struct` type as a type argument, an error is given.
- [ ] An instance method declared in a `ref struct` type may not be converted to a delegate
- [ ] An instance method inherited into a `ref struct` type (e.g. `GetHashCode`) may not be converted to a delegate
- [ ] A static field may not be of a `ref struct` type (even if the container is a `ref struct` type)
- [ ] It is an error to use a `ref struct` type as the element type of an array type
- [ ] An anonymous type may not contain an element of a `ref struct` type.
- [ ] A tuple type may not contain an element of a `ref struct` type.
- [ ] It is an error if a tuple literal's natural type contains an element of a `ref struct` type, e.g. `(1, span)`
- [ ] It is not an error if a tuple literal, e.g., `(null, span)` has no natural type and is converted to a tuple type that does not contain an element of a `ref struct` type (e.g. by the use of a user-defined conversion), e.g. `(string, int) x = (null, span);` where the span's type contains a conversion to `int`.
- [ ] A `Deconstruct` method *may* output one or more values of a `ref struct` type.
  - [ ] Such a value can be stored in a local variable via a deconstruction statement.
  - [ ] However, it is an error to use such a deconstruction expression elsewhere.
- [ ] A set of `ref struct` types can be written to implement the `foreach` pattern, in which case the `foreach` statement should work with an iterator variable of a `ref struct` type.
- [ ] A set of `ref struct` types can be written to implement the `foreach` pattern with an element type of a `ref struct` type that contains a `Deconstruct` method, in which case the `foreach` statement should work with a pair of iterator variables of `ref struct` types.
- [ ] Neither a parameter nor local variable of `ref struct` type may be captured in a lambda or local function.
- [ ] Neither a parameter nor local variable of `ref struct` type may be declared in an iterator or async method.
- [ ] A value of `ref struct` type may not require spilling in `async` code, e.g. it is an error (possibly reported during emit) to compile an expression such as `M(span1, await e)`.
- [ ] No boxing conversion exists from a `ref struct` type to `object` or `ValueType`.
- [ ] No unboxing conversion exists to a `ref struct` type
- [ ] No instance method declared in `object` or in `System.ValueType` but not overridden in a `ref struct` type may be called with a receiver of that `ref struct` type.
- [ ] A user-declared conversion may convert to or from a `ref struct` type.
  - [ ] Such a user-declared conversion does not have a lifted form in which the `ref struct` type is nullable.
- [ ] A user-declared operator may accept a parameter of `ref struct` type.
  - [ ] Such a user-declared operator does not have a lifted form in which the `ref struct` type is nullable.
    - [ ] test with one operand a `ref struct` type (left, and right)
    - [ ] test with both operands a `ref struct` type
- [ ] A local function may contain parameters and local variables of `ref struct` types.
  - [ ] Unless the local function is `async` or an iterator method. 
- [ ] (extra credit) A set of `ref struct` types, delegate types, and methods can be declared which permit the use of *Linq* with a sequence of value of a `ref struct` type represented by, e.g., `Span&lt;T&gt;`.
- [ ] A `ref struct` type cannot be awaited, even if it is otherwise task-like. *(is this right?)*

## Restrictions on `stackalloc`

Tests should demonstrate that `stackalloc` can only be used
1. As the initializer of a local variable declaration; or
2. As either the second or third operand of a ternary operator which is in one of these contexts.
- [x] `stackalloc` works in an initializer
- [x] `stackalloc` works in a ternary in an initializer
- [x] `stackalloc` works in a nested ternary in an initializer
- [x] `stackalloc` does not work as an operand to a method invocation, e.g. `M(stackalloc int[1])`
- [x] there may be a user-defined conversion between the `stackalloc` result and the variable's type.
  - [x] when the converted-from type is a pointer type
  - [x] when the converted-from type is a `ref struct` type 
- [x] `stackalloc` is an error if parenthesized
- [x] `stackalloc` is an error if either operand of `??`
- [x] `stackalloc` is an error if subject to an explicit cast, e.g. `var x = (myspan)stackalloc int[10];`
  - [x] Alternatively, change the spec to permit it and test it, including beneath a ternary operator (allowed and tested)
- [x] The statement `var x = stackalloc int[10];` is an error unless in an `unsafe` context, because `x` is of type `int*`.
- [x] The statement `Span&lt;int&gt; x = stackalloc int[10];` is not an error outside an `unsafe` context.
- [x] The statement `T x = stackalloc int[10];` is an error outside an `unsafe` context if it required a user-defined conversion from `int*` to `T` 
- [x] The statement `T x = stackalloc int[10];` is permitted outside an `unsafe` context if it required a user-defined conversion from `Span&lt;int&gt;` to `T` 
- *TODO: We should have LDM confirmation of the above `stackalloc` restrictions regarding where it may appear.*

Tests should demonstrate that the compiler rejects an attempt to use `stackalloc` (#21918)
- [x] In a `catch` block (with or without a catch parameter).
- [X] In an exception filter (due to constraints on the `localloc` instruction). [This cannot occur if `stackalloc` is restricted to local variable initializers]
- [x] In a `finally` block.

## Miscellaneous

- [ ] The C# 7 compiler prevents the use of a `ref struct` type from metadata
- [ ] The C# 5 compiler prevents the use of a `ref struct` type from metadata (hand verify)
- [ ] A warning is given when a `ref struct` type is declared with an explicit `[Obsolete]` attribute
- [ ] Demonstrate that a `ref struct` type acts as such in separate compilation scenarios
  - [ ] through a metadata reference
  - [ ] through a compilation reference
- [ ] The use of a `ref struct` type from VB produces a compile-time error. 
- [ ] There should be some public API (may be an extension method) that can be used to determine that a given `ITypeSymbol` or `TypeSymbol` is a `ref struct` type.
- [ ] A `ref struct` value cannot be used in an expression tree, even as an intermediate result. (?)
- [ ] There is no conversion involving a `ref struct` type, either to or from `dynamic`.
- [ ] A value of `ref struct` type may be used in an object, collection, or dictionary initializer for a type whose API was designed to permit this.
- [ ] An extension method may operate on a `this` parameter of a `ref struct` type.
- [ ] A value of `ref struct` type may not be used as a fill-in in string interpolation due to the need to box the value.

## APIs

- [ ] In a statement of the form `T1 x = stackalloc int[10];`, the semantic model should report that the `stackalloc` expression has the type `int*` and a converted type of `T1`
  - [ ] When `T1` is `int*`
  - [ ] When there is a user-defined conversion from `int*` to `T1`
  - [ ] When there is a user-defined conversion from `Span&lt;int&gt;` to `T1`. 
  - [ ] For each of these, the conversion-from-expression from `stackalloc int[10]` appears as some appropriate kind of conversion.
- [ ] A `stackalloc` expression in any other syntactic context than a local variable initializer context has the type `Span&lt;T&gt;`.
  - [ ] under a ternary operator
  - [ ] under a nested ternary operator
  - [ ] when subjected to a cast expression, if that is permitted  

## Escape safety rules

Each test bullet below of the form "Show that *x* is *(ref-)safe-to-escape* *y* but/and no further.", this is intended to require a test that demonstrates that *x* is *(ref-)safe-to-escape* to *y*, and a separate test that demonstrates that *x* is **not** *(ref-)safe-to-escape* the enclosing scope of *y*.

### Parameters
- [ ] Show that a parameter of a `ref struct` type is _ref-safe-to-escape_ to the top level of a method, but no further, no matter the ref mode of the parameter.
- [ ] Show that a `ref`, `in`, or `out` parameter that is not of a `ref struct` type is _ref-safe-to-escape_ from the entire method.
- [ ] Show that the `this` parameter of a struct type that is not a `ref struct` type is _ref-safe-to-escape_ to the top level of a method, but no further.
- [ ] Show that a value parameter that is not a `ref struct` type is _ref-safe-to-escape_ to the top level of a method, but no further.
- [ ] Show that a (reference to a) parameter of `ref struct` type is *safe-to-escape* (by value) from the entire method. Show this for the `this` parameter as well.

### Locals
- [ ] Show that a non-ref local is _ref-safe-to-escape_ to the scope in which it was declared, but no further (for a `ref struct` type and any other type).
- [ ] Show that a ref local variable declaration requires an initializer.
- [ ] Show that a local variable of a `ref struct` type does not require an initializer, in which case it is safe to return. *TODO: The spec needs to say this* 
- [ ] Show that a ref local is _ref-safe-to-escape_ to the same *ref-safe-to-escape* as its initializer, but no further.
- [ ] Show that an rvalue that is a use of a local whose type is a `ref struct` type that is declared as the iterator variable of a `foreach` loop is *safe-to-escape* the same as the loop's expression, and no further.
- [ ] Show that an rvalue that is a use of a local whose type is a `ref struct` type that is declared in a local variable declaration is *safe-to-escape* the same as the variable's initializer, and no further.
- [ ] It is an error if a `ref struct` type is explicitly the type of a pattern variable.
- [ ] It is an error if a `ref struct` type is implicitly the type of a pattern variable.
- [ ] Show that `out` variables are safe to return.
- [ ] Show that `out` variables participate in the no mixing rule.
- [ ] Show that a top-level variable in a script may not be of a `ref struct` type.
  - [ ] Even when the result of deconstruction or pattern-matching. 
- [ ] Show that a nested variable in a script may be of a `ref struct` type.
- [ ] *TODO: Are there other interesting contexts in which local variables can be declared? What about deconstruction?*

### *2017-09-15 Review of the test plan stopped here*

### Fields
- [ ] Show that if `e` is a reference type, that `e.F` is *ref-safe-to-escape* from the entire method.
- [ ] Show that if `e` is a value type, its *ref-safe-to-escape* is the same as the *ref-safe-to-escape* of `e`, but no further.
- [ ] Show that if `e.F` is a `ref struct` type, it is *safe-to-escape* the same as the *safe-to-escape* of `e`, but no further. 

### Multi-operand expression forms
- [ ] Show that given an expression of the form `c ? e1 : e2` where the result is a `ref struct` type, that the *safe-to-escape* of the result is the narrowest among the *safe-to-escape* of `e1` and `e2`.
  - [ ] When `e1` is a `ref struct` type but `e2` is not (the *safe-to-escape* is taken from `e1`)
  - [ ] When `e2` is a `ref struct` type but `e1` is not (the *safe-to-escape* is taken from `e2`) 
  - [ ] When `e1` and `e2` are `ref struct` types (the *safe-to-escape* is the smallest of the two)
  - [ ] When neither `e1` nor `e2` are `ref struct` types (the result is safe to return)
- [ ] For an expression of the form `c ? ref e1 : ref e2`,
  - [ ] Show that the compiler requires that the *ref-safe-to-escape* of `e1` and `e2` agree
  - [ ] Show that the `ref-safe-to-escape* of the result is the same as the *ref-safe-to-escape* of `e1`, but no further.

### Method invocation
- [ ] Show that an **lvalue** resulting from a ref-returning method invocation `e1.M(e2, ...)` is *ref-safe-to-escape* the smallest of the following scopes (but no further) (a pair of positive/negative tests for each of these)
  - [ ] The entire method, if no other rule below applies
  - [ ] The *ref-safe-to-escape* of all `ref` and `out` argument expressions
    - [ ] excluding the receiver
    - [ ] excluding arguments of `ref struct` types
  - [ ] For an `in` parameter for which there is a corresponding expression that is an lvalue, its *ref-safe-to-escape*
  - [ ] For an `in` parameter for which there is a no corresponding expression, the immediately enclosing scope
  - [ ] The *safe-to-escape* of all argument expressions
    - [ ] including the receiver
- [ ] Show that a **value** resulting from a `ref struct` returning method invocation `e1.M(e2, ...)` is *safe-to-escape* the smallest of the following scopes (but no further) (a pair of positive/negative tests for each of these)
  - [ ] The entire method, if no other rule below applies
  - [ ] The *ref-safe-to-escape* of all `ref` and `out` argument expressions
    - [ ] excluding the receiver
    - [ ] excluding arguments of `ref struct` types
  - [ ] For an `in` parameter for which there is a corresponding expression that is an lvalue, its *ref-safe-to-escape*
  - [ ] For an `in` parameter for which there is a no corresponding expression, the immediately enclosing scope
  - [ ] The *safe-to-escape* of all argument expressions
    - [ ] including the receiver
- [ ] *TODO: we should have a rule and tests for an argument expression of the form `ref d.F` where `d` is of type dynamic*
- [ ] The same rules apply to a user-defined operator invocation. Specifically, show that given an expression of the form `e1 + e2` where the result is a `ref struct` type, that the *safe-to-escape* of the result is the narrowest among the *safe-to-escape* of `e1` and `e2`.
  - [ ] When `e1` is a `ref struct` type but `e2` is not (the *safe-to-escape* is taken from `e1`)
  - [ ] When `e2` is a `ref struct` type but `e1` is not (the *safe-to-escape* is taken from `e2`) 
  - [ ] When `e1` and `e2` are `ref struct` types (the *safe-to-escape* is the smallest of the two)
  - [ ] When neither `e1` nor `e2` are `ref struct` types (the result is safe to return)
- [ ] A property invocation that returns a `ref` result follows the method invocation rules: both the `ref-safe-to-escape` is taken from the *safe-to-escape* of the receiver.
- [ ] A property invocation that returns a result of `ref struct` type follows the method invocation rules: the `safe-to-escape` is taken from the *safe-to-escape* of the receiver. 
- [ ] A constructor invocation acts as a method invocation without a receiver; for a constructor of a `ref struct` type, its result is *safe-to-escape* the smallest of the following scopes (but no further) (a pair of positive/negative tests for each of these)
  - [ ] The entire method, if no other rule below applies
  - [ ] The *ref-safe-to-escape* of all `ref` and `out` argument expressions
    - [ ] excluding the receiver
    - [ ] excluding arguments of `ref struct` types
  - [ ] For an `in` parameter for which there is a corresponding expression that is an lvalue, its *ref-safe-to-escape*
  - [ ] For an `in` parameter for which there is a no corresponding expression, the immediately enclosing scope
  - [ ] The *safe-to-escape* of all argument expressions
- [ ] In a statement such as `return ref await e;`, where the type of `e` is a custom value task whose `GetResult()` method is ref-returning, we should be returning the returned ref, not a ref to a copy of its value. In particular, if the returned ref is ref-safe-to-return, then there should be no error.

### stackalloc
- [ ] a `stackalloc` expression is *safe-to-escape* to the top level of the method, but no further.

### default
- [ ] A `default` or `default(T)` expression is *safe-to-escape* from the entire enclosing method (i.e. it is *safe to return*)

### Other
- [ ] A `default` value of a `ref struct` type is safe to return (i.e. escape from the whole method).

### Constraints in expressions
- [ ] (Only if ref reassignment is supported) For a ref reassignment `ref e1 = ref e2`, the *ref-safe-to-escape* of `e2` must be at least as wide a scope as the *ref-safe-to-escape* of `e1`.
  - [ ] Alternately, demonstrate that ref reassignment is not supported. 
- [ ] For a ref return statement `return ref e1`, the *ref-safe-to-escape* of `e1` must be *ref-safe-to-escape* from the entire method.
- [ ] For a return statement `return e1`, the *safe-to-escape* of `e1` must be *safe-to-escape* from the entire method.
- [ ] For an assignment `e1 = e2`, if the type of `e1` is a `ref struct` type, then the *safe-to-escape* of `e2` must be at least as wide a scope as the *safe-to-escape* of `e1`.
- [ ] In a method invocation, the following constraints apply (negative tests required):
  - If there is a `ref` or `out` argument to a `ref struct` type (including the receiver), with *safe-to-escape* E1, then
    - [ ] no `ref` or `out` argument (excluding the receiver and arguments of `ref struct` types) may have a narrower *ref-safe-to-escape* than E1; and
    - [ ] no argument (including the receiver) may have a narrower *safe-to-escape* than E1.

</Description>
        <CreatedDate>09/06/2017</CreatedDate>
        <ClosedDate>06/09/2018</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder.ValueChecks.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/OverloadResolution/OverloadResolution.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/SyntaxNodeExtensions.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenRefReadOnlyParametersTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenRefReadonlyReturnTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/NameOfTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/RefLocalsAndReturnsTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/SemanticErrorTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/StackAllocSpanExpressionsTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/UnsafeTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/VarianceTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/RefReadonlyReturnsTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/RefReadonlyTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>22225</IssueID>
    <Title>Fix unit tests for IStopStatement and IEndStatement and make the APIs…</Title>
    <Description>… public again

Fixes #21297 and #22004</Description>
    <CreatedDate>20/09/2017</CreatedDate>
    <ClosedDate>26/09/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>21297</IssueID>
        <Title>IStopStatement API Review </Title>
        <Description>https://github.com/dotnet/roslyn/blob/features/ioperation/src/Compilers/Core/Portable/Operations/IStopStatement.cs 

Why we need this ? 

cc @AlekseyTs  , @dotnet/analyzer-ioperation </Description>
        <CreatedDate>03/08/2017</CreatedDate>
        <ClosedDate>26/09/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>22004</IssueID>
        <Title>API review for IEndStatement</Title>
        <Description>https://github.com/dotnet/roslyn/blob/features/ioperation/src/Compilers/Core/Portable/Operations/IEndStatement.cs

Add unit tests when making public</Description>
        <CreatedDate>09/09/2017</CreatedDate>
        <ClosedDate>26/09/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/Core/Portable/Generated/Operations.xml.Generated.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IEndStatement.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IStopStatement.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationCloner.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationKind.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationVisitor.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/OperationTreeVerifier.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/TestOperationWalker.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>22222</IssueID>
    <Title>Add unit tests for ITypeOfExpression and ISizeOfExpression and make A…</Title>
    <Description>…PIs public again

Fixes #22003 and #21296</Description>
    <CreatedDate>20/09/2017</CreatedDate>
    <ClosedDate>20/09/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>22003</IssueID>
        <Title>API review for ITypeOfExpression</Title>
        <Description>https://github.com/dotnet/roslyn/blob/features/ioperation/src/Compilers/Core/Portable/Operations/ITypeOfExpression.cs

Add units tests when making public.</Description>
        <CreatedDate>09/09/2017</CreatedDate>
        <ClosedDate>20/09/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>21296</IssueID>
        <Title>ISizeOfExpression API Review</Title>
        <Description>https://github.com/dotnet/roslyn/blob/features/ioperation/src/Compilers/Core/Portable/Operations/ISizeOfExpression.cs

- The API should derive from IOperation rather than ITypeOperationExpression 
- Why we need ITypeOperationExpression  ?</Description>
        <CreatedDate>03/08/2017</CreatedDate>
        <ClosedDate>20/09/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IPatternSwitchCase.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_ISizeOfExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_ITypeOfExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/AnonymousTypesSemanticsTests.cs</File>
      <File>src/Compilers/Core/Portable/Generated/Operations.xml.Generated.cs</File>
      <File>src/Compilers/Core/Portable/Operations/ISizeOfExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/ITypeOfExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationCloner.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationKind.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationVisitor.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/OperationTreeVerifier.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/TestOperationWalker.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>22210</IssueID>
    <Title>Add IOperation unit tests for try/catch statements and make the APIs …</Title>
    <Description>…public again

Fixes #22008 and #21277

We also decided to make some changes to ICatchClause see https://github.com/dotnet/roslyn/issues/21277#issuecomment-330663344 and https://github.com/dotnet/roslyn/issues/21277#issuecomment-331310258
</Description>
    <CreatedDate>19/09/2017</CreatedDate>
    <ClosedDate>29/09/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>22008</IssueID>
        <Title>API review for ITryStatement</Title>
        <Description>https://github.com/dotnet/roslyn/blob/features/ioperation/src/Compilers/Core/Portable/Operations/ITryStatement.cs

Add unit tests when making the APIs public</Description>
        <CreatedDate>09/09/2017</CreatedDate>
        <ClosedDate>29/09/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>21277</IssueID>
        <Title>ICatchClause API review</Title>
        <Description>https://github.com/dotnet/roslyn/blob/features/ioperation/src/Compilers/Core/Portable/Operations/ICatchClause.cs 

- We should get rid of CatchType here</Description>
        <CreatedDate>03/08/2017</CreatedDate>
        <ClosedDate>29/09/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Operations/CSharpOperationFactory.cs</File>
      <File>src/Compilers/CSharp/Portable/Operations/CSharpOperationFactory_Methods.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IWhileUntilLoopStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_TryCatch.cs</File>
      <File>src/Compilers/Core/Portable/Generated/Operations.xml.Generated.cs</File>
      <File>src/Compilers/Core/Portable/Operations/ICatchClause.cs</File>
      <File>src/Compilers/Core/Portable/Operations/ITryStatement.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationCloner.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationKind.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationVisitor.cs</File>
      <File>src/Compilers/Test/Utilities/CSharp/CSharpTestBase.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/OperationTreeVerifier.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/TestOperationWalker.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>22134</IssueID>
    <Title>Add regression tests for 15.3 closure conversion crashes</Title>
    <Description>Fixes #21811
Fixes #21645
Fixes #21543</Description>
    <CreatedDate>14/09/2017</CreatedDate>
    <ClosedDate>15/09/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>21811</IssueID>
        <Title>csc.exe crashes with exit code -2146232797</Title>
        <Description>**Version Used**: 

Roslyn included in VS 2017 15.3.3

**Steps to Reproduce**:

Compile the following code:
```c#
    class Program
    {
        static void Main(string[] args)
        {
            var history = new Queue&lt;long&gt;();
            Enumerable.Range(0, 5)
                .Select(i =&gt;
                {
                    history.Enqueue(i);
                    return Test(i);

                    bool Test(int v)
                    {
                        history.Dequeue();
                        return Square(v) &gt; 5;
                    }

                    int Square(int w)
                    {
                        return w * w;
                    }
                });
        }
    }
```
**Expected Behavior**:

Since this is valid C# syntax the code should compile

**Actual Behavior**:

csc.exe crashes with exit code -2146232797</Description>
        <CreatedDate>30/08/2017</CreatedDate>
        <ClosedDate>15/09/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>21645</IssueID>
        <Title>Nested local functions causes KeyNotFoundException</Title>
        <Description>**Version Used**: 
Microsoft Visual Studio Enterprise 2017 
Version 15.3.1
VisualStudio.15.Release/15.3.1+26730.8
Microsoft .NET Framework
Version 4.7.02046

**Steps to Reproduce**:

1. Create a new C# project
2. Add the following code
```C#
public class Class1
{
    private void Test()
    {
        bool outside = true;

        void Inner() //This can also be a lambda (ie. Action action = () =&gt; { ... };)
        {
            void Bar()
            {
            }

            void Foo()
            {
                Bar();

                bool captured = outside;
            }
        }
    }
}
```
3. Compile with VS 2017 15.3.1 

Example repository available [here](https://github.com/Keboo/NestedInnerFunctionsBug).
This same code does compile with VS 2017 v15.2 (26430.15 release).

**Expected Behavior**:
Compile succeeds without error.

**Actual Behavior**: 
CSC.exe crash with error code -2146232797

MSBuild output:
```
1&gt;  Task "Csc"
1&gt;    C:\Program Files (x86)\Microsoft Visual Studio\2017\Enterprise\MSBuild\15.0\Bin\Roslyn\csc.exe /noconfig /unsafe- /checked- /nowarn:1701,1702,1705,1701,1702,2008 /nostdlib+ /errorreport:prompt /warn:4 /define:TRACE;DEBUG;NETSTANDARD1_4 /errorendlocation /preferreduilang:en-US /reference:C:\Users\Kevin\.nuget\packages\microsoft.win32.primitives\4.3.0\ref\netstandard1.3\Microsoft.Win32.Primitives.dll /reference:C:\Users\Kevin\.nuget\packages\system.appcontext\4.3.0\ref\netstandard1.3\System.AppContext.dll /reference:C:\Users\Kevin\.nuget\packages\system.collections.concurrent\4.3.0\ref\netstandard1.3\System.Collections.Concurrent.dll /reference:C:\Users\Kevin\.nuget\packages\system.collections\4.3.0\ref\netstandard1.3\System.Collections.dll /reference:C:\Users\Kevin\.nuget\packages\system.console\4.3.0\ref\netstandard1.3\System.Console.dll /reference:C:\Users\Kevin\.nuget\packages\system.diagnostics.debug\4.3.0\ref\netstandard1.3\System.Diagnostics.Debug.dll /reference:C:\Users\Kevin\.nuget\packages\system.diagnostics.tools\4.3.0\ref\netstandard1.0\System.Diagnostics.Tools.dll /reference:C:\Users\Kevin\.nuget\packages\system.diagnostics.tracing\4.3.0\ref\netstandard1.3\System.Diagnostics.Tracing.dll /reference:C:\Users\Kevin\.nuget\packages\system.globalization.calendars\4.3.0\ref\netstandard1.3\System.Globalization.Calendars.dll /reference:C:\Users\Kevin\.nuget\packages\system.globalization\4.3.0\ref\netstandard1.3\System.Globalization.dll /reference:C:\Users\Kevin\.nuget\packages\system.io.compression\4.3.0\ref\netstandard1.3\System.IO.Compression.dll /reference:C:\Users\Kevin\.nuget\packages\system.io.compression.zipfile\4.3.0\ref\netstandard1.3\System.IO.Compression.ZipFile.dll /reference:C:\Users\Kevin\.nuget\packages\system.io\4.3.0\ref\netstandard1.3\System.IO.dll /reference:C:\Users\Kevin\.nuget\packages\system.io.filesystem\4.3.0\ref\netstandard1.3\System.IO.FileSystem.dll /reference:C:\Users\Kevin\.nuget\packages\system.io.filesystem.primitives\4.3.0\ref\netstandard1.3\System.IO.FileSystem.Primitives.dll /reference:C:\Users\Kevin\.nuget\packages\system.linq\4.3.0\ref\netstandard1.0\System.Linq.dll /reference:C:\Users\Kevin\.nuget\packages\system.linq.expressions\4.3.0\ref\netstandard1.3\System.Linq.Expressions.dll /reference:C:\Users\Kevin\.nuget\packages\system.net.http\4.3.0\ref\netstandard1.3\System.Net.Http.dll /reference:C:\Users\Kevin\.nuget\packages\system.net.primitives\4.3.0\ref\netstandard1.3\System.Net.Primitives.dll /reference:C:\Users\Kevin\.nuget\packages\system.net.sockets\4.3.0\ref\netstandard1.3\System.Net.Sockets.dll /reference:C:\Users\Kevin\.nuget\packages\system.objectmodel\4.3.0\ref\netstandard1.3\System.ObjectModel.dll /reference:C:\Users\Kevin\.nuget\packages\system.reflection\4.3.0\ref\netstandard1.3\System.Reflection.dll /reference:C:\Users\Kevin\.nuget\packages\system.reflection.extensions\4.3.0\ref\netstandard1.0\System.Reflection.Extensions.dll /reference:C:\Users\Kevin\.nuget\packages\system.reflection.primitives\4.3.0\ref\netstandard1.0\System.Reflection.Primitives.dll /reference:C:\Users\Kevin\.nuget\packages\system.resources.resourcemanager\4.3.0\ref\netstandard1.0\System.Resources.ResourceManager.dll /reference:C:\Users\Kevin\.nuget\packages\system.runtime\4.3.0\ref\netstandard1.3\System.Runtime.dll /reference:C:\Users\Kevin\.nuget\packages\system.runtime.extensions\4.3.0\ref\netstandard1.3\System.Runtime.Extensions.dll /reference:C:\Users\Kevin\.nuget\packages\system.runtime.handles\4.3.0\ref\netstandard1.3\System.Runtime.Handles.dll /reference:C:\Users\Kevin\.nuget\packages\system.runtime.interopservices\4.3.0\ref\netstandard1.3\System.Runtime.InteropServices.dll /reference:C:\Users\Kevin\.nuget\packages\system.runtime.interopservices.runtimeinformation\4.3.0\ref\netstandard1.1\System.Runtime.InteropServices.RuntimeInformation.dll /reference:C:\Users\Kevin\.nuget\packages\system.runtime.numerics\4.3.0\ref\netstandard1.1\System.Runtime.Numerics.dll /reference:C:\Users\Kevin\.nuget\packages\system.security.cryptography.algorithms\4.3.0\ref\netstandard1.4\System.Security.Cryptography.Algorithms.dll /reference:C:\Users\Kevin\.nuget\packages\system.security.cryptography.encoding\4.3.0\ref\netstandard1.3\System.Security.Cryptography.Encoding.dll /reference:C:\Users\Kevin\.nuget\packages\system.security.cryptography.primitives\4.3.0\ref\netstandard1.3\System.Security.Cryptography.Primitives.dll /reference:C:\Users\Kevin\.nuget\packages\system.security.cryptography.x509certificates\4.3.0\ref\netstandard1.4\System.Security.Cryptography.X509Certificates.dll /reference:C:\Users\Kevin\.nuget\packages\system.text.encoding\4.3.0\ref\netstandard1.3\System.Text.Encoding.dll /reference:C:\Users\Kevin\.nuget\packages\system.text.encoding.extensions\4.3.0\ref\netstandard1.3\System.Text.Encoding.Extensions.dll /reference:C:\Users\Kevin\.nuget\packages\system.text.regularexpressions\4.3.0\ref\netstandard1.3\System.Text.RegularExpressions.dll /reference:C:\Users\Kevin\.nuget\packages\system.threading\4.3.0\ref\netstandard1.3\System.Threading.dll /reference:C:\Users\Kevin\.nuget\packages\system.threading.tasks\4.3.0\ref\netstandard1.3\System.Threading.Tasks.dll /reference:C:\Users\Kevin\.nuget\packages\system.threading.timer\4.3.0\ref\netstandard1.2\System.Threading.Timer.dll /reference:C:\Users\Kevin\.nuget\packages\system.xml.readerwriter\4.3.0\ref\netstandard1.3\System.Xml.ReaderWriter.dll /reference:C:\Users\Kevin\.nuget\packages\system.xml.xdocument\4.3.0\ref\netstandard1.3\System.Xml.XDocument.dll /debug+ /debug:portable /filealign:512 /nologo /optimize- /out:obj\Debug\netstandard1.4\NestedInnerFunctionsBug.dll /ruleset:"C:\Program Files (x86)\Microsoft Visual Studio\2017\Enterprise\Team Tools\Static Analysis Tools\\Rule Sets\MinimumRecommendedRules.ruleset" /target:library /warnaserror- /utf8output /deterministic+ Class1.cs "C:\Users\Kevin\AppData\Local\Temp\.NETStandard,Version=v1.4.AssemblyAttributes.cs" obj\Debug\netstandard1.4\\TemporaryGeneratedFile_E7A71F73-0F8D-4B9B-B56E-8E70B10BC5D3.cs obj\Debug\netstandard1.4\\TemporaryGeneratedFile_036C0B5B-1481-4323-8D20-8F5ADCB23D92.cs obj\Debug\netstandard1.4\\TemporaryGeneratedFile_5937a670-0e60-4077-877b-f7221da3dda1.cs obj\Debug\netstandard1.4\NestedInnerFunctionsBug.AssemblyInfo.cs
1&gt;    Using shared compilation with compiler from directory: C:\Program Files (x86)\Microsoft Visual Studio\2017\Enterprise\MSBuild\15.0\Bin\Roslyn
1&gt;    C:\Program Files (x86)\Microsoft Visual Studio\2017\Enterprise\MSBuild\15.0\Bin\Roslyn\Microsoft.CSharp.Core.targets(84,5): error MSB6006: "csc.exe" exited with code -2146232797.
1&gt;  Done executing task "Csc" -- FAILED.
```

Event view log:
```
Application: csc.exe
Framework Version: v4.0.30319
Description: The application requested process termination through System.Environment.FailFast(string message).
Message: System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.
   at System.ThrowHelper.ThrowKeyNotFoundException()
   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.RewriteLambdaOrLocalFunction(IBoundLambdaOrFunction node, ClosureKind&amp; closureKind, NamedTypeSymbol&amp; translatedLambdaContainer, LambdaFrame&amp; containerAsFrame, BoundNode&amp; lambdaScope, DebugId&amp; topLevelMethodId, DebugId&amp; lambdaId)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.VisitLocalFunctionStatement(BoundLocalFunctionStatement node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.RewriteBlock(BoundBlock node, ArrayBuilder`1 prologue, ArrayBuilder`1 newLocals)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.VisitBlock(BoundBlock node)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.RewriteLambdaOrLocalFunction(IBoundLambdaOrFunction node, ClosureKind&amp; closureKind, NamedTypeSymbol&amp; translatedLambdaContainer, LambdaFrame&amp; containerAsFrame, BoundNode&amp; lambdaScope, DebugId&amp; topLevelMethodId, DebugId&amp; lambdaId)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.VisitLocalFunctionStatement(BoundLocalFunctionStatement node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.RewriteBlock(BoundBlock node, ArrayBuilder`1 prologue, ArrayBuilder`1 newLocals)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.IntroduceFrame(BoundNode node, LambdaFrame frame, Func`3 F)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.VisitBlock(BoundBlock node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.Rewrite(BoundStatement loweredBody, NamedTypeSymbol thisType, ParameterSymbol thisParameter, MethodSymbol method, Int32 methodOrdinal, MethodSymbol substitutedSourceMethod, ArrayBuilder`1 lambdaDebugInfoBuilder, ArrayBuilder`1 closureDebugInfoBuilder, VariableSlotAllocator slotAllocatorOpt, TypeCompilationState compilationState, DiagnosticBag diagnostics, HashSet`1 assignLocals)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.LowerBodyOrInitializer(MethodSymbol method, Int32 methodOrdinal, BoundStatement body, SynthesizedSubmissionFields previousSubmissionFields, TypeCompilationState compilationState, Boolean instrumentForDynamicAnalysis, DebugDocumentProvider debugDocumentProvider, ImmutableArray`1&amp; dynamicAnalysisSpans, DiagnosticBag diagnostics, VariableSlotAllocator&amp; lazyVariableSlotAllocator, ArrayBuilder`1 lambdaDebugInfoBuilder, ArrayBuilder`1 closureDebugInfoBuilder, StateMachineTypeSymbol&amp; stateMachineTypeOpt)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethod(MethodSymbol methodSymbol, Int32 methodOrdinal, ProcessedFieldInitializers&amp; processedInitializers, SynthesizedSubmissionFields previousSubmissionFields, TypeCompilationState compilationState)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(NamedTypeSymbol containingType)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.&lt;&gt;c__DisplayClass21_0.&lt;CompileNamedTypeAsTask&gt;b__0()
Stack:
   at System.Environment.FailFast(System.String, System.Exception)
   at Microsoft.CodeAnalysis.FatalError.Report(System.Exception, System.Action`1&lt;System.Exception&gt;)
   at Microsoft.CodeAnalysis.FatalError.ReportUnlessCanceled(System.Exception)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler+&lt;&gt;c__DisplayClass21_0.&lt;CompileNamedTypeAsTask&gt;b__0()
   at System.ThrowHelper.ThrowKeyNotFoundException()
   at System.Collections.Generic.Dictionary`2[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089],[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].get_Item(System.__Canon)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.RewriteLambdaOrLocalFunction(Microsoft.CodeAnalysis.CSharp.IBoundLambdaOrFunction, Microsoft.CodeAnalysis.CSharp.ClosureKind ByRef, Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol ByRef, Microsoft.CodeAnalysis.CSharp.LambdaFrame ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef, Microsoft.CodeAnalysis.CodeGen.DebugId ByRef, Microsoft.CodeAnalysis.CodeGen.DebugId ByRef)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.VisitLocalFunctionStatement(Microsoft.CodeAnalysis.CSharp.BoundLocalFunctionStatement)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.Visit(Microsoft.CodeAnalysis.CSharp.BoundNode)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.RewriteBlock(Microsoft.CodeAnalysis.CSharp.BoundBlock, Microsoft.CodeAnalysis.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.CSharp.BoundExpression&gt;, Microsoft.CodeAnalysis.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol&gt;)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.VisitBlock(Microsoft.CodeAnalysis.CSharp.BoundBlock)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.RewriteLambdaOrLocalFunction(Microsoft.CodeAnalysis.CSharp.IBoundLambdaOrFunction, Microsoft.CodeAnalysis.CSharp.ClosureKind ByRef, Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol ByRef, Microsoft.CodeAnalysis.CSharp.LambdaFrame ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef, Microsoft.CodeAnalysis.CodeGen.DebugId ByRef, Microsoft.CodeAnalysis.CodeGen.DebugId ByRef)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.VisitLocalFunctionStatement(Microsoft.CodeAnalysis.CSharp.BoundLocalFunctionStatement)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.Visit(Microsoft.CodeAnalysis.CSharp.BoundNode)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.RewriteBlock(Microsoft.CodeAnalysis.CSharp.BoundBlock, Microsoft.CodeAnalysis.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.CSharp.BoundExpression&gt;, Microsoft.CodeAnalysis.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol&gt;)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.IntroduceFrame(Microsoft.CodeAnalysis.CSharp.BoundNode, Microsoft.CodeAnalysis.CSharp.LambdaFrame, System.Func`3&lt;Microsoft.CodeAnalysis.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.CSharp.BoundExpression&gt;,Microsoft.CodeAnalysis.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol&gt;,Microsoft.CodeAnalysis.CSharp.BoundNode&gt;)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.VisitBlock(Microsoft.CodeAnalysis.CSharp.BoundBlock)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.Visit(Microsoft.CodeAnalysis.CSharp.BoundNode)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.Rewrite(Microsoft.CodeAnalysis.CSharp.BoundStatement, Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol, Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol, Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol, Int32, Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol, Microsoft.CodeAnalysis.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.CodeGen.LambdaDebugInfo&gt;, Microsoft.CodeAnalysis.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.CodeGen.ClosureDebugInfo&gt;, Microsoft.CodeAnalysis.CodeGen.VariableSlotAllocator, Microsoft.CodeAnalysis.CSharp.TypeCompilationState, Microsoft.CodeAnalysis.DiagnosticBag, System.Collections.Generic.HashSet`1&lt;Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol&gt;)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.LowerBodyOrInitializer(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol, Int32, Microsoft.CodeAnalysis.CSharp.BoundStatement, Microsoft.CodeAnalysis.CSharp.SynthesizedSubmissionFields, Microsoft.CodeAnalysis.CSharp.TypeCompilationState, Boolean, Microsoft.CodeAnalysis.CodeGen.DebugDocumentProvider, System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.CodeGen.SourceSpan&gt; ByRef, Microsoft.CodeAnalysis.DiagnosticBag, Microsoft.CodeAnalysis.CodeGen.VariableSlotAllocator ByRef, Microsoft.CodeAnalysis.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.CodeGen.LambdaDebugInfo&gt;, Microsoft.CodeAnalysis.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.CodeGen.ClosureDebugInfo&gt;, Microsoft.CodeAnalysis.CSharp.StateMachineTypeSymbol ByRef)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethod(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol, Int32, ProcessedFieldInitializers ByRef, Microsoft.CodeAnalysis.CSharp.SynthesizedSubmissionFields, Microsoft.CodeAnalysis.CSharp.TypeCompilationState)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler+&lt;&gt;c__DisplayClass21_0.&lt;CompileNamedTypeAsTask&gt;b__0()
   at Roslyn.Utilities.UICultureUtilities+&lt;&gt;c__DisplayClass5_0.&lt;WithCurrentUICulture&gt;b__0()
   at System.Threading.Tasks.Task.Execute()
   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)
   at System.Threading.Tasks.Task.ExecuteEntry(Boolean)
   at System.Threading.ThreadPoolWorkQueue.Dispatch()
```

Potentially related to #17814 and #16895?</Description>
        <CreatedDate>21/08/2017</CreatedDate>
        <ClosedDate>15/09/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>21543</IssueID>
        <Title>Compiler crashes in VS15.3, analyzer throws NullReferenceException in master, when call local function from nested lambda</Title>
        <Description>I found the issue #16895 that mentioning compiler crash caused by local function and nested lambda. But  I can build that issue's code successfully in VS15.3 so I think this issue is different issue.

**Version Used**: VS2017 15.3.0, master(d67a95f1c01dc7064a47caecf02326a060292649)([demo at  sharplab.io](https://sharplab.io/#v2:EYLgtghgzgLgpgJwDQBMQGoA+ABADAAmwEYBuAWAChLsAmfABQQHsBzBCMSgb0vz/1gQYASwDGhACz4AsnBgALJigAUxOhFEimAOwCU+LvgC+lXv0Ejx2KdIjDty3Wb48K/d/nsx8ANwgAbAFc4fABefFxyNw8+WQUlZUcwgD5nD1cYmP8mUQDHKMyPa3xs3P9HNMKMwsyAYR0oJn84ADoAdQRheAAZezhlPyC4XQKamLjFFSTQ1Oix92r5zNK8kcr5ozW5mpNt903Rvl3doA===))

**Steps to Reproduce**:
```cs
using System;

class Program
{
    static void Method(Action action) { }

    static void Main()
    {
        int value = 0;
        Method(() =&gt;
        {
            local();
            void local()
            {
                Console.WriteLine(value);
                Method(() =&gt;
                {
                    local();
                });
            }
        });
    }
}
```

**Expected Behavior**:
I can build the above code without any errors and warnings.

**Actual Behavior**:
If I build the above code in VS15.3, the build failed due to `"csc.exe" exited with code -2146232797`.
I found a stack trace in `eventvwr.msc` -&gt; `Windows Logs` -&gt; `Application` -&gt; `.NET Runtime`:
```
Application: csc.exe
Framework Version: v4.0.30319
Description: The application requested process termination through System.Environment.FailFast(string message).
Message: System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.
   at System.ThrowHelper.ThrowKeyNotFoundException()
   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitLocalLoad(BoundLocal local, Boolean used)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitExpression(BoundExpression expression, Boolean used)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitDelegateCreation(BoundExpression node, BoundExpression receiver, Boolean isExtensionMethod, MethodSymbol method, TypeSymbol delegateType, Boolean used)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitDelegateCreationExpression(BoundDelegateCreationExpression expression, Boolean used)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitExpression(BoundExpression expression, Boolean used)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitArguments(ImmutableArray`1 arguments, ImmutableArray`1 parameters)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitCallExpression(BoundCall call, UseKind useKind)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitExpressionCoreWithStackGuard(BoundExpression expression, Boolean used)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitExpression(BoundExpression expression, Boolean used)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitStatementAndCountInstructions(BoundStatement statement)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitSequencePointStatement(BoundSequencePoint node)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitStatements(ImmutableArray`1 statements)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitBlock(BoundBlock block)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.GenerateImpl()
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.GenerateMethodBody(PEModuleBuilder moduleBuilder, MethodSymbol method, Int32 methodOrdinal, BoundStatement block, ImmutableArray`1 lambdaDebugInfo, ImmutableArray`1 closureDebugInfo, StateMachineTypeSymbol stateMachineTypeOpt, VariableSlotAllocator variableSlotAllocatorOpt, DiagnosticBag diagnostics, DebugDocumentProvider debugDocumentProvider, ImportChain importChainOpt, Boolean emittingPdb, Boolean emitTestCoverageData, ImmutableArray`1 dynamicAnalysisSpans)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileSynthesizedMethods(TypeCompilationState compilationState)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(NamedTypeSymbol containingType)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.&lt;&gt;c__DisplayClass21_0.&lt;CompileNamedTypeAsTask&gt;b__0()
Stack:
   at System.Environment.FailFast(System.String, System.Exception)
   at Microsoft.CodeAnalysis.FatalError.Report(System.Exception, System.Action`1&lt;System.Exception&gt;)
   at Microsoft.CodeAnalysis.FatalError.ReportUnlessCanceled(System.Exception)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler+&lt;&gt;c__DisplayClass21_0.&lt;CompileNamedTypeAsTask&gt;b__0()
   at System.ThrowHelper.ThrowKeyNotFoundException()
   at System.Collections.Generic.Dictionary`2[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089],[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].get_Item(System.__Canon)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitLocalLoad(Microsoft.CodeAnalysis.CSharp.BoundLocal, Boolean)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitExpression(Microsoft.CodeAnalysis.CSharp.BoundExpression, Boolean)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitDelegateCreation(Microsoft.CodeAnalysis.CSharp.BoundExpression, Microsoft.CodeAnalysis.CSharp.BoundExpression, Boolean, Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol, Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, Boolean)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitDelegateCreationExpression(Microsoft.CodeAnalysis.CSharp.BoundDelegateCreationExpression, Boolean)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitExpression(Microsoft.CodeAnalysis.CSharp.BoundExpression, Boolean)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitArguments(System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.CSharp.BoundExpression&gt;, System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol&gt;)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitCallExpression(Microsoft.CodeAnalysis.CSharp.BoundCall, UseKind)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitExpressionCoreWithStackGuard(Microsoft.CodeAnalysis.CSharp.BoundExpression, Boolean)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitExpression(Microsoft.CodeAnalysis.CSharp.BoundExpression, Boolean)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitStatementAndCountInstructions(Microsoft.CodeAnalysis.CSharp.BoundStatement)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitSequencePointStatement(Microsoft.CodeAnalysis.CSharp.BoundSequencePoint)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitStatements(System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.CSharp.BoundStatement&gt;)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitBlock(Microsoft.CodeAnalysis.CSharp.BoundBlock)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.GenerateImpl()
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.GenerateMethodBody(Microsoft.CodeAnalysis.CSharp.Emit.PEModuleBuilder, Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol, Int32, Microsoft.CodeAnalysis.CSharp.BoundStatement, System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.CodeGen.LambdaDebugInfo&gt;, System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.CodeGen.ClosureDebugInfo&gt;, Microsoft.CodeAnalysis.CSharp.StateMachineTypeSymbol, Microsoft.CodeAnalysis.CodeGen.VariableSlotAllocator, Microsoft.CodeAnalysis.DiagnosticBag, Microsoft.CodeAnalysis.CodeGen.DebugDocumentProvider, Microsoft.CodeAnalysis.CSharp.ImportChain, Boolean, Boolean, System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.CodeGen.SourceSpan&gt;)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileSynthesizedMethods(Microsoft.CodeAnalysis.CSharp.TypeCompilationState)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler+&lt;&gt;c__DisplayClass21_0.&lt;CompileNamedTypeAsTask&gt;b__0()
   at Roslyn.Utilities.UICultureUtilities+&lt;&gt;c__DisplayClass5_0.&lt;WithCurrentUICulture&gt;b__0()
   at System.Threading.Tasks.Task.Execute()
   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)
   at System.Threading.Tasks.Task.ExecuteEntry(Boolean)
   at System.Threading.ThreadPoolWorkQueue.Dispatch()
```

If I build the above code in master, the build succeeded but I get the following warning(same warning occurs 5 times):
```
warning AD0001: Analyzer 'Microsoft.CodeAnalysis.CSharp.ValidateFormatString.CSharpValidateFormatStringDiagnosticAnalyzer' threw an exception of type 'System.NullReferenceException' with message 'Object reference not set to an instance of an object.'.
```</Description>
        <CreatedDate>16/08/2017</CreatedDate>
        <ClosedDate>15/09/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenLocalFunctionTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>21407</IssueID>
    <Title>IBinaryOperatorExpression, IUnaryOperatorExpression and IIncrementExp…</Title>
    <Description>…ression API changes

This implements a bunch of changes to the IOperation representation for binary operator, unary operator and increment expressions.

1. #8834: Simplify `UnaryOperatorKind` to only contain the operator kind values instead of a matrix of operator and operand kinds.
2. #8835: Simplify `BinaryOperatorKind` in similar manner as above.
3. #8825: Add `IUnaryOperatorExpression.IsChecked` flag. Cyrus has already added the `IUnaryOperatorExpression.IsLifted` flag.
4. #8846: Add `IBinaryOperatorExpression.IsChecked` and `IBinaryOperatorExpression.IsCompareText` flags Cyrus has already added the `IBinaryOperatorExpression.IsLifted` flag.
5. #21283: Add `IIncrementExpression.IsDecrement` and `IIncrementExpression.IsPostfix` flags and remove PostFix/Prefix Increment/Decrement from `UnaryOperatorKind` enum.

This change also fixes #8848 and #8843 as the matrix operation kind enums no longer exist.</Description>
    <CreatedDate>09/08/2017</CreatedDate>
    <ClosedDate>26/08/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>8834</IssueID>
        <Title>IOperation: UnaryOperationKind feels unnecessary complicated</Title>
        <Description>Why are we going through the trouble of combining operator kind with type of arguments? Does this really make things easier for consumers? It feels that operator kind is sufficient enough and the type of the operand can be accessed from the Operand.
</Description>
        <CreatedDate>17/02/2016</CreatedDate>
        <ClosedDate>26/08/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>8835</IssueID>
        <Title>IOperation: BinaryOperationKind feels unnecessary complicated</Title>
        <Description>The enum has more than a hundred members!
Why are we going through the trouble of combining operator kind with type of arguments? Does this really make things easier for consumers? It feels that operator kind is sufficient enough and the type of the operand can be accessed from the Operand.
</Description>
        <CreatedDate>17/02/2016</CreatedDate>
        <ClosedDate>26/08/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>8825</IssueID>
        <Title>IOperation: It looks like some unary operator semantics cannot be represented via IUnaryOperatorExpression </Title>
        <Description>It looks like Nullable lifting isn't explicitly repretesented.
It looks like checked/unchecked semantics cannot be represented.
</Description>
        <CreatedDate>17/02/2016</CreatedDate>
        <ClosedDate>26/08/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>8846</IssueID>
        <Title>IOperation: It looks like some binary operator semantics cannot be represented via IBinaryOperatorExpression</Title>
        <Description>It looks like Nullable lifting isn't explicitly repretesented.
It looks like checked/unchecked semantics cannot be represented.
It looks like Option Compare Text for String or Object comparison cannot be represented.
</Description>
        <CreatedDate>17/02/2016</CreatedDate>
        <ClosedDate>26/08/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>21283</IssueID>
        <Title>IIncrementExpression API Review</Title>
        <Description>https://github.com/dotnet/roslyn/blob/features/ioperation/src/Compilers/Core/Portable/Operations/IIncrementExpression.cs 

- We should flatten the list of IncrementOperationKind  </Description>
        <CreatedDate>03/08/2017</CreatedDate>
        <ClosedDate>26/08/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>8848</IssueID>
        <Title>IOperation: VB - BoundUserDefinedBinaryOperator implementation of IBinaryOperatorExpression.BinaryOperationKind doesn't handle some operators</Title>
        <Description>It looks like BinaryOperatorKind.Power is not handled and will cause UnexpectedValue exception.
I didn't confirm that all other operators are handled properly.
</Description>
        <CreatedDate>17/02/2016</CreatedDate>
        <ClosedDate>26/08/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>8843</IssueID>
        <Title>IOperation: VB - BoundBinaryOperator it looks like implementation of IBinaryOperatorExpression.BinaryOperationKind is not handling all possible scenarios</Title>
        <Description>```
        Private ReadOnly Property IBinaryKind As BinaryOperationKind Implements IBinaryOperatorExpression.BinaryOperationKind
            Get
                Return DeriveBinaryOperationKind(Me.OperatorKind, Me.Left)
            End Get
        End Property
```

Glancing over code in DeriveBinaryOperationKind (the list might be incomplete):
- It looks like operands of Nullable type are not handled;
- It looks like LessThanOrEqual, GreaterThanOrEqual, LessThan, GreaterThan operators for strings aren't handled.
</Description>
        <CreatedDate>17/02/2016</CreatedDate>
        <ClosedDate>26/08/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Operations/CSharpOperationFactory.cs</File>
      <File>src/Compilers/CSharp/Portable/Operations/CSharpOperationFactory_Methods.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IBinaryOperatorExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IConversionExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IForEachLoopStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IForLoopStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IIfStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_ILocalFunctionStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IParameterReferenceExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IPatternSwitchCase.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_ISymbolInitializer.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IUnaryOperatorExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IWhileUntilLoopStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_InvalidExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_InvalidStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/ObjectAndCollectionInitializerTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/OperatorTests.cs</File>
      <File>src/Compilers/Core/Portable/Compilation/Expression.cs</File>
      <File>src/Compilers/Core/Portable/Generated/Operations.xml.Generated.cs</File>
      <File>src/Compilers/Core/Portable/Operations/BinaryOperandsKind.cs</File>
      <File>src/Compilers/Core/Portable/Operations/BinaryOperationKind.cs</File>
      <File>src/Compilers/Core/Portable/Operations/BinaryOperatorKind.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IBinaryOperatorExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/ICompoundAssignmentExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IIncrementExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IRelationalCaseClause.cs</File>
      <File>src/Compilers/Core/Portable/Operations/ISingleValueCaseClause.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IUnaryOperatorExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationCloner.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationFactory.cs</File>
      <File>src/Compilers/Core/Portable/Operations/SimpleBinaryOperationKind.cs</File>
      <File>src/Compilers/Core/Portable/Operations/SimpleUnaryOperationKind.cs</File>
      <File>src/Compilers/Core/Portable/Operations/UnaryAndBinaryOperationExtensions.cs</File>
      <File>src/Compilers/Core/Portable/Operations/UnaryOperandKind.cs</File>
      <File>src/Compilers/Core/Portable/Operations/UnaryOperationKind.cs</File>
      <File>src/Compilers/Core/Portable/Operations/UnaryOperatorKind.cs</File>
      <File>src/Features/Core/Portable/UseThrowExpression/AbstractUseThrowExpressionDiagnosticAnalyzer.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/OperationTreeVerifier.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/TestOperationWalker.cs</File>
      <File>src/Test/Utilities/Portable/Diagnostics/OperationTestAnalyzer.cs</File>
      <File>src/VisualStudio/Core/Next/Remote/ServiceHubRemoteHostClient.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>21367</IssueID>
    <Title>Remove RemoveUnneededReferences from LamdaRewriter</Title>
    <Description>Currently, the lambda rewriter has an early optimization pass in
analysis that tries to find all local functions that only capture 'this'
and remove references to local functions that do the same. There are two
problems with this approach:

    1) Generally, removing information from the tree is a bad idea
    because it hurts further analysis passes that may have needed that
    information.

    2) The optimization strategy itself is very tricky and has a number
    of complex corner cases. This has lead to bugs, for example #19033.

This PR deletes the current method and adds a new optimization routine
at the end of the analysis, operating on assigned scopes and
environments rather than removing captured variable analysis. The new
optimization is as follows: if we end up with an environment containing
only 'this', the environment can be removed, all containing methods can
be moved to the top-level type, and all environments which capture the
'this' environment can instead directly capture the 'this' parameter.
This produces almost the same results as the previous optimization, but
is easier to validate as an algebraic equivalence.

Fixes #19033
Fixes #20577</Description>
    <CreatedDate>08/08/2017</CreatedDate>
    <ClosedDate>11/08/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>19033</IssueID>
        <Title>Compiler crash</Title>
        <Description>**Any version below apr 17**: 

```csharp
using System;

namespace ConsoleApp3
{
    class BC { }
    class DC1 : BC { }
    class DC2 : BC { }
    class Program
    {
        static void Main(string[] args)
        {
        }

        private string Q(BC bclass, int n = 0)
        {
            switch (bclass)
            {
                case DC1 mc:

                    string A(BC map)
                    {
                        return "";
                    }

                    string B(BC map) 
                    {
                        switch (map)
                        {
                            case DC1 ne:
                                Action&lt;int&gt; a = _ =&gt; B(new DC2());
                                return "";
                            case DC2 b: 
                                return C(b);
                            default:
                                return A(map);
                        }
                    }

                    string C(BC map)
                    {
                        switch (map)
                        {
                            case DC1 me:
                                return n.ToString();
                            default:
                                return "";
                        }
                    }
                    break;

                default:
                    break;
            }

            return "";
        }
    }
}
```

"csc.exe" exited with code -2146232797
</Description>
        <CreatedDate>27/04/2017</CreatedDate>
        <ClosedDate>11/08/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19033</IssueID>
        <Title>Compiler crash</Title>
        <Description>**Any version below apr 17**: 

```csharp
using System;

namespace ConsoleApp3
{
    class BC { }
    class DC1 : BC { }
    class DC2 : BC { }
    class Program
    {
        static void Main(string[] args)
        {
        }

        private string Q(BC bclass, int n = 0)
        {
            switch (bclass)
            {
                case DC1 mc:

                    string A(BC map)
                    {
                        return "";
                    }

                    string B(BC map) 
                    {
                        switch (map)
                        {
                            case DC1 ne:
                                Action&lt;int&gt; a = _ =&gt; B(new DC2());
                                return "";
                            case DC2 b: 
                                return C(b);
                            default:
                                return A(map);
                        }
                    }

                    string C(BC map)
                    {
                        switch (map)
                        {
                            case DC1 me:
                                return n.ToString();
                            default:
                                return "";
                        }
                    }
                    break;

                default:
                    break;
            }

            return "";
        }
    }
}
```

"csc.exe" exited with code -2146232797
</Description>
        <CreatedDate>27/04/2017</CreatedDate>
        <ClosedDate>11/08/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>20577</IssueID>
        <Title>Compiler (csc) crashes with code of a nested recursive function and different scope access</Title>
        <Description>**Version Used**: 
2.2.0.61624
**Steps to Reproduce**:

1. Paste this code:
```
using System.Linq;

public class Program {
	public static void Main(string[] args) {
		object v;

		void AAA() {
			object BBB(object v2) {
				var a = v;
				((object[])v2).Select(i =&gt; BBB(i));
				return null;
			}
		}
	}
}
```
2. Compile

**Expected Behavior**:
Code compiles or fails to compile.
**Actual Behavior**:
Compiler crashes.</Description>
        <CreatedDate>30/06/2017</CreatedDate>
        <ClosedDate>11/08/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Compiler/TypeCompilationState.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/LambdaCapturedVariable.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/LambdaRewriter.Analysis.Tree.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/LambdaRewriter.Analysis.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/LambdaRewriter.LocalFunctionReferenceRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/LambdaRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/SynthesizedClosureEnvironment.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/SynthesizedClosureEnvironmentConstructor.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/SynthesizedLambdaMethod.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenClosureLambdaTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenLocalFunctionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Emit/EditAndContinue/EditAndContinueClosureTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/PDB/PDBLambdaTests.cs</File>
      <File>src/Compilers/Core/Portable/InternalUtilities/SetWithInsertionOrder.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Test/ExpressionCompiler/LocalFunctionTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>20662</IssueID>
    <Title>Use IVsSolution to get the correct IVsProject for an IVsHierarchy</Title>
    <Description>Fixes crashes associated with InvisibleEditor.

**Customer scenario**

* Use the Inline Rename functionality to rename an element (rare, never reproduced outside of crash reports)
* Use the following steps:
  1. Open dotnet/vs-threading
  2. Open **AsyncAutoResetEvent.cs**
  3. Use Inline Rename to rename `AsyncAutoResetEvent` to `AsyncAutoResetEvent2`
  4. Use CodeLens to drop down the references to the type
  5. Double click the reference in **AsyncAutoResetEventTests.cs** from the `evt` field

**Bugs this fixes:**

Fixes [DevDiv 458062](https://devdiv.visualstudio.com/DevDiv/_workitems?id=458062).

**Workarounds, if any**

None.

**Risk**

Low. The solution to the problem was implemented using techniques which all project systems should support without trouble.

**Performance impact**

Negligible. The solution was analyzed specifically to ensure the performance benefits of #19919 are retained.

**Is this a regression from a previous update?**

Yes.

**Root cause analysis:**

Edge case / race condition introduced by #19919. The root cause is documented in a comment in code:

&gt; The invisible editor manager will fail in cases where the `IVsProject` passed to it is not consistent with the `IVsProject` known to `IVsSolution` (e.g. if the object is a wrapper like `AbstractHostObject` created by the CPS-based project system). This method returns an `IVsProject` instance known to the solution, or null if the project could not be determined.

**How was the bug found?**

Watson and manual testing.
</Description>
    <CreatedDate>06/07/2017</CreatedDate>
    <ClosedDate>07/07/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>19919</IssueID>
        <Title>Pass a project when creating an invisible editor</Title>
        <Description>This change substantially reduces the amount of work required to locate a document within the solution (file path to hierarchy+itemid).

* Time to apply Fix All from #19895: 2:45 mins
* Time to apply Fix All after this change: 1:32 mins

## Ask Mode

**Customer scenario**

A customer applies a Fix All operation which affects many files in a large solution. (Not specific to any particular code fix.)

**Bugs this fixes:**

Derived from #19900 as the safe option for 15.3 (provides some but not all possible benefits).

**Workarounds, if any**

Wait longer.

**Risk**

Low. This feature adds a hint for a lookup, but valid information is not required in order for the underlying operation to succeed (falls back to slow case when information is not available).

**Performance impact**

This is a substantial performance improvement for Fix All operations.

**Is this a regression from a previous update?**

No.

**Root cause analysis:**

No performance tests covering large-scale operations (yet).

**How was the bug found?**

Internal testing.</Description>
        <CreatedDate>31/05/2017</CreatedDate>
        <ClosedDate>01/06/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19919</IssueID>
        <Title>Pass a project when creating an invisible editor</Title>
        <Description>This change substantially reduces the amount of work required to locate a document within the solution (file path to hierarchy+itemid).

* Time to apply Fix All from #19895: 2:45 mins
* Time to apply Fix All after this change: 1:32 mins

## Ask Mode

**Customer scenario**

A customer applies a Fix All operation which affects many files in a large solution. (Not specific to any particular code fix.)

**Bugs this fixes:**

Derived from #19900 as the safe option for 15.3 (provides some but not all possible benefits).

**Workarounds, if any**

Wait longer.

**Risk**

Low. This feature adds a hint for a lookup, but valid information is not required in order for the underlying operation to succeed (falls back to slow case when information is not available).

**Performance impact**

This is a substantial performance improvement for Fix All operations.

**Is this a regression from a previous update?**

No.

**Root cause analysis:**

No performance tests covering large-scale operations (yet).

**How was the bug found?**

Internal testing.</Description>
        <CreatedDate>31/05/2017</CreatedDate>
        <ClosedDate>01/06/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/InvisibleEditor.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>20645</IssueID>
    <Title>Fixed completion list for explicit interface implementation</Title>
    <Description>Fixes #15988
Fixes #19947

**Customer scenario**
Completion list for explicit interface implementations includes invalid members.

**Bugs this fixes:**
#19947, #15988

**Workarounds, if any**
None

**Risk**
Low, affected only ```ExplicitInterfaceMemberCompletionProvider``` class.

**Performance impact**

**Is this a regression from a previous update?**

**Root cause analysis:**
Completion members aren't filtered by interface type. Tests doesn't check that invalid members are not presented in code completion.

**How was the bug found?**

customer reported
</Description>
    <CreatedDate>05/07/2017</CreatedDate>
    <ClosedDate>07/07/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>15988</IssueID>
        <Title>Explicit Interface Implementation Completions show Object methods</Title>
        <Description>**Version Used**: 2017 RC Refresh

```C#
class C : IComparable {
	int IComparable.
}
```

Pressing Ctrl+Space after the `.` will show the four methods from `object`, even though they cannot be implemented with this syntax.</Description>
        <CreatedDate>18/12/2016</CreatedDate>
        <ClosedDate>07/07/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19947</IssueID>
        <Title>Completion list for explicit interface implementations includes invalid members</Title>
        <Description>![image](https://cloud.githubusercontent.com/assets/10522107/26692210/b4df7fee-46b4-11e7-97e6-2d6efb75b249.png)

Only implementable members declared immediately in the named interface should be in the list, members from derived interfaces will cause an error.</Description>
        <CreatedDate>01/06/2017</CreatedDate>
        <ClosedDate>07/07/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19947</IssueID>
        <Title>Completion list for explicit interface implementations includes invalid members</Title>
        <Description>![image](https://cloud.githubusercontent.com/assets/10522107/26692210/b4df7fee-46b4-11e7-97e6-2d6efb75b249.png)

Only implementable members declared immediately in the named interface should be in the list, members from derived interfaces will cause an error.</Description>
        <CreatedDate>01/06/2017</CreatedDate>
        <ClosedDate>07/07/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>15988</IssueID>
        <Title>Explicit Interface Implementation Completions show Object methods</Title>
        <Description>**Version Used**: 2017 RC Refresh

```C#
class C : IComparable {
	int IComparable.
}
```

Pressing Ctrl+Space after the `.` will show the four methods from `object`, even though they cannot be implemented with this syntax.</Description>
        <CreatedDate>18/12/2016</CreatedDate>
        <ClosedDate>07/07/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/Completion/CompletionProviders/ExplicitInterfaceMemberCompletionProviderTests.cs</File>
      <File>src/Features/CSharp/Portable/Completion/CompletionProviders/ExplicitInterfaceMemberCompletionProvider.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>20587</IssueID>
    <Title>Fixes overload resolution regression with ValueTuple</Title>
    <Description>**Customer scenario**

The C# overload resolution tie-breaker involving a more specific type argument isn't respected for instances of ValueTuple. When such a scenario arises, the programmer get an ambiguity error on the invocation.

**Bugs this fixes:**

Fixes #20494
Adds a test for #20583

**Workarounds, if any**

The programmer can provide explicit type arguments to resolve the ambiguity.

**Risk**

Small. The fix is a very local workaround for the symptom. The underlying issue (ValueTuple instances are not recognized by the compiler as generic), may be addressed separately in a more extensive change.

**Performance impact**

Tiny or none.

**Is this a regression from a previous update?**

It is a regression in VS2017 versus VS2015.

**Root cause analysis:**

This is a symptom of our choice of internal representation for tuple types. I am separately looking at a more uniform change to address the underlying issue, which is that tuple types are not recognized by the compiler as generic.

**How was the bug found?**

Ad-hoc testing.

@dotnet/roslyn-compiler May I please have a couple of reviews of this tiny bug fix?
</Description>
    <CreatedDate>30/06/2017</CreatedDate>
    <ClosedDate>09/07/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>20494</IssueID>
        <Title>"More generic" tie-breaker not applied to ValueTuple in C# 7 compiler</Title>
        <Description>**Version Used**: 15.2

**Steps to Reproduce**:

1. Compile the following code

**Expected Behavior**:

Code compiles without problem, just like it did using previous C# compilers.

**Actual Behavior**:

Compile fails at `M2(b)`, complaining that `error CS0121: The call is ambiguous between the following methods or properties: 'C.M2&lt;T&gt;((T, int))' and 'C.M2&lt;T&gt;(((T, int), int))'`

This is a regression from compilers previous to Visual Studio 2017.

``` c#
using System;
public class C
{
    public static void Main()
    {
        A&lt;A&lt;int&gt;&gt; a = null;
        M1(a); // ok, selects M1&lt;T&gt;(A&lt;A&lt;T&gt;&gt; a)

        var b = default(ValueTuple&lt;ValueTuple&lt;int, int&gt;, int&gt;);
        M2(b); // ok, should select M2&lt;T&gt;(ValueTuple&lt;ValueTuple&lt;T, int&gt;, int&gt; a)
    }
    public static void M1&lt;T&gt;(A&lt;T&gt; a) { }
    public static void M1&lt;T&gt;(A&lt;A&lt;T&gt;&gt; a) { }

    public static void M2&lt;T&gt;(ValueTuple&lt;T, int&gt; a) { }
    public static void M2&lt;T&gt;(ValueTuple&lt;ValueTuple&lt;T, int&gt;, int&gt; a) { }
}

public class A&lt;T&gt; { }
```

/cc @jaredpar @MadsTorgersen 
</Description>
        <CreatedDate>28/06/2017</CreatedDate>
        <ClosedDate>09/07/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>20583</IssueID>
        <Title>Inference failure for tuple type vs tuple underlying type (regression)</Title>
        <Description>The following correct program compiles successfully in VS2015, but fails to compile in VS2017:

``` c#
using System;
public class C
{
    public static void Main()
    {
        // var b = (1, 2, 3, 4, 5, 6, 7, 8);
        var b = new ValueTuple&lt;int, int, int, int, int, int, int, ValueTuple&lt;int&gt;&gt;(1, 2, 3, 4, 5, 6, 7, new ValueTuple&lt;int&gt;(8));
        M1(b);
    }
    public static void M1&lt;T1, T2, T3, T4, T5, T6, T7, TRest&gt;(ValueTuple&lt;T1, T2, T3, T4, T5, T6, T7, TRest&gt; a) where TRest : struct { Console.Write(1); }
}
```

with the following error

``` none
Error CS0411: The type arguments for method 'C.M1&lt;T1, T2, T3, T4, T5, T6, T7, TRest&gt;(ValueTuple&lt;T1, T2, T3, T4, T5, T6, T7, TRest&gt;)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
```
</Description>
        <CreatedDate>30/06/2017</CreatedDate>
        <ClosedDate>26/09/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/OverloadResolution/OverloadResolution.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTupleTest.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>20004</IssueID>
    <Title>Better exclude local functions from region analysis</Title>
    <Description>By design, when data flow analyzes local functions it does so devoid of
surrounding context and records possibly unassigned variables rather
than reporting a diagnostic. Thus, all captured variables are expected
to be marked unassigned during data flow analysis without reporting a
diagnostic.

However, reporting a diagnostic is not the only side effect of running
data flow analysis. By calling virtual methods data flow analysis
informs derived types of unassigned variables. While the diagnostic is
suppressed and recorded, currently the virtual method is still called.
This has negative consequences for region analysis, which considers
these calls as indications of variables flowing out of the given
region, which may not be the case for local functions.

This PR changes data flow analysis to only call the ReportUnassigned
virtual method if not inside a local function, excluding local functions
from all unassignment reporting.

Fixes #17165, #18347

**Customer scenario**

Extract method crashes when analyzing code that contains variables captured by
local functions.

**Bugs this fixes:**

Fixes #17165, #18347

**Workarounds, if any**

Don't ask for refactorings around these variables.

**Risk**

This is a code change to data flow analysis and could affect definite assignment for local functions,
but is mostly focused around code flow to region analysis, which is only used by extract method.

**Performance impact**

Low. No extra allocations, minimal extra logic.

**Is this a regression from a previous update?**

No.

**Root cause analysis:**

Local functions were a new feature in C# 7 and there are known issues around region analysis.

**How was the bug found?**

Customer reported.</Description>
    <CreatedDate>04/06/2017</CreatedDate>
    <ClosedDate>15/06/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>17165</IssueID>
        <Title>ExtractMethodMatrix.GetVariableStyle Throws exception on code with errors</Title>
        <Description>**Version Used**: 
![image](https://cloud.githubusercontent.com/assets/9797472/22995888/8293500a-f381-11e6-923e-4d241adef2f9.png)

**Steps to Reproduce**:

1.  Use Alt+Arrow to move members into lambda that is an argument into a method that is missing semicolon

**Expected Behavior**:
No Crash

**Actual Behavior**:
```
System.InvalidOperationException : Unexpected false
   at Roslyn.Utilities.Contract.ThrowIfFalse(Boolean condition,String message)
   at Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodMatrix.GetVariableStyle(Boolean captured,Boolean dataFlowIn,Boolean dataFlowOut,Boolean alwaysAssigned,Boolean variableDeclared,Boolean readInside,Boolean writtenInside,Boolean readOutside,Boolean writtenOutside,Boolean unsafeAddressTaken)
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GetVariableStyle(Dictionary`2 symbolMap,ISymbol symbol,SemanticModel model,ITypeSymbol type,Boolean captured,Boolean dataFlowIn,Boolean dataFlowOut,Boolean alwaysAssigned,Boolean variableDeclared,Boolean readInside,Boolean writtenInside,Boolean readOutside,Boolean writtenOutside,Boolean unsafeAddressTaken)
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GenerateVariableInfoMap(SemanticModel model,DataFlowAnalysis dataFlowAnalysisData,Dictionary`2 symbolMap)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.AnalyzeAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.ExtractMethodAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.ExtractMethodAsync[TValidator,TExtractor,TResult](&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.GetCodeActionAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.ComputeRefactoringsAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringService.GetRefactoringFromProviderAsync(&lt;Unknown Parameters&gt;)
   at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject)
```

Also reported at https://developercommunity.visualstudio.com/content/problem/14869/extractmethodcoderefactoringprovider-encountered-a.html</Description>
        <CreatedDate>15/02/2017</CreatedDate>
        <ClosedDate>15/06/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>18347</IssueID>
        <Title>ExtractMethodCodeRefactoringProvider crashes on selecting a line that references an argument captured by a local method</Title>
        <Description>**Version Used**: 

Microsoft Visual Studio Community 2017
Version 15.0.26228.9

**Steps to Reproduce**:

```csharp
namespace ExtractMethodCrashRepro
{
	public static class SomeClass
	{
		private static void Repro( int arg )
		{
			int localValue = arg;

			int LocalCapture() =&gt; arg;
		}
	}
}
```

Select the line `int localValue = arg;`

**Expected Behavior**:
A lightbulb with available refactorings should appear.

**Actual Behavior**:
`ExtractMethodCodeRefactoringProvider` crashes with the following stack trace:

```
System.InvalidOperationException : Unexpected false
   at Roslyn.Utilities.Contract.ThrowIfFalse(Boolean condition,String message)
   at Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodMatrix.GetVariableStyle(Boolean captured,Boolean dataFlowIn,Boolean dataFlowOut,Boolean alwaysAssigned,Boolean variableDeclared,Boolean readInside,Boolean writtenInside,Boolean readOutside,Boolean writtenOutside,Boolean unsafeAddressTaken)
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GetVariableStyle(Dictionary`2 symbolMap,ISymbol symbol,SemanticModel model,ITypeSymbol type,Boolean captured,Boolean dataFlowIn,Boolean dataFlowOut,Boolean alwaysAssigned,Boolean variableDeclared,Boolean readInside,Boolean writtenInside,Boolean readOutside,Boolean writtenOutside,Boolean unsafeAddressTaken)
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GenerateVariableInfoMap(SemanticModel model,DataFlowAnalysis dataFlowAnalysisData,Dictionary`2 symbolMap)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.AnalyzeAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.ExtractMethodAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.ExtractMethodAsync[TValidator,TExtractor,TResult](&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.GetCodeActionAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.ComputeRefactoringsAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringService.GetRefactoringFromProviderAsync(&lt;Unknown Parameters&gt;)
   at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject)
```</Description>
        <CreatedDate>31/03/2017</CreatedDate>
        <ClosedDate>31/03/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>17165</IssueID>
        <Title>ExtractMethodMatrix.GetVariableStyle Throws exception on code with errors</Title>
        <Description>**Version Used**: 
![image](https://cloud.githubusercontent.com/assets/9797472/22995888/8293500a-f381-11e6-923e-4d241adef2f9.png)

**Steps to Reproduce**:

1.  Use Alt+Arrow to move members into lambda that is an argument into a method that is missing semicolon

**Expected Behavior**:
No Crash

**Actual Behavior**:
```
System.InvalidOperationException : Unexpected false
   at Roslyn.Utilities.Contract.ThrowIfFalse(Boolean condition,String message)
   at Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodMatrix.GetVariableStyle(Boolean captured,Boolean dataFlowIn,Boolean dataFlowOut,Boolean alwaysAssigned,Boolean variableDeclared,Boolean readInside,Boolean writtenInside,Boolean readOutside,Boolean writtenOutside,Boolean unsafeAddressTaken)
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GetVariableStyle(Dictionary`2 symbolMap,ISymbol symbol,SemanticModel model,ITypeSymbol type,Boolean captured,Boolean dataFlowIn,Boolean dataFlowOut,Boolean alwaysAssigned,Boolean variableDeclared,Boolean readInside,Boolean writtenInside,Boolean readOutside,Boolean writtenOutside,Boolean unsafeAddressTaken)
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GenerateVariableInfoMap(SemanticModel model,DataFlowAnalysis dataFlowAnalysisData,Dictionary`2 symbolMap)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.AnalyzeAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.ExtractMethodAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.ExtractMethodAsync[TValidator,TExtractor,TResult](&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.GetCodeActionAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.ComputeRefactoringsAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringService.GetRefactoringFromProviderAsync(&lt;Unknown Parameters&gt;)
   at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject)
```

Also reported at https://developercommunity.visualstudio.com/content/problem/14869/extractmethodcoderefactoringprovider-encountered-a.html</Description>
        <CreatedDate>15/02/2017</CreatedDate>
        <ClosedDate>15/06/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>18347</IssueID>
        <Title>ExtractMethodCodeRefactoringProvider crashes on selecting a line that references an argument captured by a local method</Title>
        <Description>**Version Used**: 

Microsoft Visual Studio Community 2017
Version 15.0.26228.9

**Steps to Reproduce**:

```csharp
namespace ExtractMethodCrashRepro
{
	public static class SomeClass
	{
		private static void Repro( int arg )
		{
			int localValue = arg;

			int LocalCapture() =&gt; arg;
		}
	}
}
```

Select the line `int localValue = arg;`

**Expected Behavior**:
A lightbulb with available refactorings should appear.

**Actual Behavior**:
`ExtractMethodCodeRefactoringProvider` crashes with the following stack trace:

```
System.InvalidOperationException : Unexpected false
   at Roslyn.Utilities.Contract.ThrowIfFalse(Boolean condition,String message)
   at Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodMatrix.GetVariableStyle(Boolean captured,Boolean dataFlowIn,Boolean dataFlowOut,Boolean alwaysAssigned,Boolean variableDeclared,Boolean readInside,Boolean writtenInside,Boolean readOutside,Boolean writtenOutside,Boolean unsafeAddressTaken)
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GetVariableStyle(Dictionary`2 symbolMap,ISymbol symbol,SemanticModel model,ITypeSymbol type,Boolean captured,Boolean dataFlowIn,Boolean dataFlowOut,Boolean alwaysAssigned,Boolean variableDeclared,Boolean readInside,Boolean writtenInside,Boolean readOutside,Boolean writtenOutside,Boolean unsafeAddressTaken)
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GenerateVariableInfoMap(SemanticModel model,DataFlowAnalysis dataFlowAnalysisData,Dictionary`2 symbolMap)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.AnalyzeAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.ExtractMethodAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.ExtractMethodAsync[TValidator,TExtractor,TResult](&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.GetCodeActionAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.ComputeRefactoringsAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringService.GetRefactoringFromProviderAsync(&lt;Unknown Parameters&gt;)
   at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject)
```</Description>
        <CreatedDate>31/03/2017</CreatedDate>
        <ClosedDate>31/03/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/DataFlowPass.LocalFunctions.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/DataFlowPass.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/DataFlowsInWalker.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/DataFlowsOutWalker.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/UnassignedAddressTakenVariablesWalker.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/UnassignedVariablesWalker.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/StateMachineRewriter/IteratorAndAsyncCaptureWalker.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTupleTest.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/FlowAnalysis/LocalFunctions.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/FlowAnalysis/RegionAnalysisTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/FlowAnalysis/StructTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/ExtractMethod/ExtractMethodTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>19945</IssueID>
    <Title>Fix Extract Method operations within an event accessor</Title>
    <Description>Fixes #17474
Closes #19136

## Ask Mode

**Customer scenario**

Uses the light bulb while a selection is present in certain code. A non-fatal exception occurs in the Extract Method refactoring and the gold bar appears.

**Bugs this fixes:**

Fixes #17474
Closes #19136 (the behavior is sub-optimal, but a proper solution can wait for #19958) 

**Workarounds, if any**

None

**Risk**

Low. The changed code paths only affect the failing scenario.

**Performance impact**

This change should not have any impact on performance.

**Is this a regression from a previous update?**

No.

**Root cause analysis:**

* Failure to test all code constructs
* Failure to account for erroneous code in testing

**How was the bug found?**

Internal customer report
</Description>
    <CreatedDate>01/06/2017</CreatedDate>
    <ClosedDate>02/06/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>17474</IssueID>
        <Title>InvalidCastException at Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpSelectionResult.StatementResult.GetContainingScopeType</Title>
        <Description>**Version Used**: 
D15Rel 26226.0

**Steps to Reproduce**:
1. Restore, build and open Roslyn.sln
2. Open source file: `\src\EditorFeatures\Core\Implementation\Classification\SemanticClassificationBufferTaggerProvider.Tagger.cs` and enter the following code at end of the file:
  ```
namespace NewTaggerNamespace
{
    internal partial class NewTagger : IAccurateTagger&lt;IClassificationTag&gt;
    {
        public event EventHandler&lt;SnapshotSpanEventArgs&gt; TagsChanged;

        event EventHandler&lt;SnapshotSpanEventArgs&gt; ITagger&lt;IClassificationTag&gt;.TagsChanged
        {
            add
            {
                throw new NotImplementedException();
            }

            remove
            {
                throw new NotImplementedException();
            }
        }

        public IEnumerable&lt;ITagSpan&lt;IClassificationTag&gt;&gt; GetAllTags(NormalizedSnapshotSpanCollection spans, CancellationToken cancel)
        {
            throw new NotImplementedException();
        }

        IEnumerable&lt;ITagSpan&lt;IClassificationTag&gt;&gt; ITagger&lt;IClassificationTag&gt;.GetTags(NormalizedSnapshotSpanCollection spans)
        {
            throw new NotImplementedException();
        }
    }
}
  ```
3. Select text `throw new NotImplementedException();` in the add or remove handler.

Got the following exception in the info bar:

```
System.InvalidCastException : Unable to cast object of type 'Microsoft.CodeAnalysis.CSharp.Symbols.SourceCustomEventSymbol' to type 'Microsoft.CodeAnalysis.IPropertySymbol'.
   at Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpSelectionResult.StatementResult.GetContainingScopeType()
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.CodeGenerator`3.AddReturnIfUnreachable(IEnumerable`1 statements,CancellationToken cancellationToken)
   at async Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpMethodExtractor.CSharpCodeGenerator.CreateStatementsOrInitializerToInsertAtCallSiteAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpMethodExtractor.CSharpCodeGenerator.GenerateBodyForCallSiteContainerAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.CodeGenerator`3.GenerateAsync[TStatement,TExpression,TNodeUnderContainer](&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.ExtractMethodAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.ExtractMethodAsync[TValidator,TExtractor,TResult](&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.GetCodeActionAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.ComputeRefactoringsAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringService.GetRefactoringFromProviderAsync(&lt;Unknown Parameters&gt;)
   at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject)
```
</Description>
        <CreatedDate>28/02/2017</CreatedDate>
        <ClosedDate>02/06/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19136</IssueID>
        <Title>ExtractMethodCodeRefactoringProvider crashed with InvalidOperationException</Title>
        <Description>VS Build: 26426.1 VSUWPT

Note same code that crashed: https://github.com/dotnet/roslyn/issues/19135.

``` C#
// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.

using System;
using Microsoft.VisualStudio.ProjectSystem.VS;

namespace Microsoft.VisualStudio.Shell.Interop
{
    internal static class IVsOutputWindowExtensions
    {
        public static void ActivatePane(this IVsOutputWindow outputWindow, Guid pane)
        {
            Requires.NotNull(outputWindow, nameof(outputWindow));
            Requires.NotEmpty(pane, nameof(pane));

            HResult hr = outputWindow.GetPane(ref $pane$, out IVsOutputWindowPane pane);
            if (!hr.IsOK) // Pane not found
                return;

            hr = pane.Activate();
            if (hr.Failed)
                throw hr.Exception;
        }
    }
}
```


```
System.InvalidOperationException : Unexpected false
   at Roslyn.Utilities.Contract.ThrowIfFalse(Boolean condition,String message)
   at Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodMatrix.GetVariableStyle(Boolean captured,Boolean dataFlowIn,Boolean dataFlowOut,Boolean alwaysAssigned,Boolean variableDeclared,Boolean readInside,Boolean writtenInside,Boolean readOutside,Boolean writtenOutside,Boolean unsafeAddressTaken)
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GetVariableStyle(Dictionary`2 symbolMap,ISymbol symbol,SemanticModel model,ITypeSymbol type,Boolean captured,Boolean dataFlowIn,Boolean dataFlowOut,Boolean alwaysAssigned,Boolean variableDeclared,Boolean readInside,Boolean writtenInside,Boolean readOutside,Boolean writtenOutside,Boolean unsafeAddressTaken)
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GenerateVariableInfoMap(SemanticModel model,DataFlowAnalysis dataFlowAnalysisData,Dictionary`2 symbolMap)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.AnalyzeAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.ExtractMethodAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.ExtractMethodAsync[TValidator,TExtractor,TResult](&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.GetCodeActionAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.ComputeRefactoringsAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringService.GetRefactoringFromProviderAsync(&lt;Unknown Parameters&gt;)
   at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject)
```</Description>
        <CreatedDate>01/05/2017</CreatedDate>
        <ClosedDate>02/06/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>17474</IssueID>
        <Title>InvalidCastException at Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpSelectionResult.StatementResult.GetContainingScopeType</Title>
        <Description>**Version Used**: 
D15Rel 26226.0

**Steps to Reproduce**:
1. Restore, build and open Roslyn.sln
2. Open source file: `\src\EditorFeatures\Core\Implementation\Classification\SemanticClassificationBufferTaggerProvider.Tagger.cs` and enter the following code at end of the file:
  ```
namespace NewTaggerNamespace
{
    internal partial class NewTagger : IAccurateTagger&lt;IClassificationTag&gt;
    {
        public event EventHandler&lt;SnapshotSpanEventArgs&gt; TagsChanged;

        event EventHandler&lt;SnapshotSpanEventArgs&gt; ITagger&lt;IClassificationTag&gt;.TagsChanged
        {
            add
            {
                throw new NotImplementedException();
            }

            remove
            {
                throw new NotImplementedException();
            }
        }

        public IEnumerable&lt;ITagSpan&lt;IClassificationTag&gt;&gt; GetAllTags(NormalizedSnapshotSpanCollection spans, CancellationToken cancel)
        {
            throw new NotImplementedException();
        }

        IEnumerable&lt;ITagSpan&lt;IClassificationTag&gt;&gt; ITagger&lt;IClassificationTag&gt;.GetTags(NormalizedSnapshotSpanCollection spans)
        {
            throw new NotImplementedException();
        }
    }
}
  ```
3. Select text `throw new NotImplementedException();` in the add or remove handler.

Got the following exception in the info bar:

```
System.InvalidCastException : Unable to cast object of type 'Microsoft.CodeAnalysis.CSharp.Symbols.SourceCustomEventSymbol' to type 'Microsoft.CodeAnalysis.IPropertySymbol'.
   at Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpSelectionResult.StatementResult.GetContainingScopeType()
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.CodeGenerator`3.AddReturnIfUnreachable(IEnumerable`1 statements,CancellationToken cancellationToken)
   at async Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpMethodExtractor.CSharpCodeGenerator.CreateStatementsOrInitializerToInsertAtCallSiteAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpMethodExtractor.CSharpCodeGenerator.GenerateBodyForCallSiteContainerAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.CodeGenerator`3.GenerateAsync[TStatement,TExpression,TNodeUnderContainer](&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.ExtractMethodAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.ExtractMethodAsync[TValidator,TExtractor,TResult](&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.GetCodeActionAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.ComputeRefactoringsAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringService.GetRefactoringFromProviderAsync(&lt;Unknown Parameters&gt;)
   at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject)
```
</Description>
        <CreatedDate>28/02/2017</CreatedDate>
        <ClosedDate>02/06/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19136</IssueID>
        <Title>ExtractMethodCodeRefactoringProvider crashed with InvalidOperationException</Title>
        <Description>VS Build: 26426.1 VSUWPT

Note same code that crashed: https://github.com/dotnet/roslyn/issues/19135.

``` C#
// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.

using System;
using Microsoft.VisualStudio.ProjectSystem.VS;

namespace Microsoft.VisualStudio.Shell.Interop
{
    internal static class IVsOutputWindowExtensions
    {
        public static void ActivatePane(this IVsOutputWindow outputWindow, Guid pane)
        {
            Requires.NotNull(outputWindow, nameof(outputWindow));
            Requires.NotEmpty(pane, nameof(pane));

            HResult hr = outputWindow.GetPane(ref $pane$, out IVsOutputWindowPane pane);
            if (!hr.IsOK) // Pane not found
                return;

            hr = pane.Activate();
            if (hr.Failed)
                throw hr.Exception;
        }
    }
}
```


```
System.InvalidOperationException : Unexpected false
   at Roslyn.Utilities.Contract.ThrowIfFalse(Boolean condition,String message)
   at Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodMatrix.GetVariableStyle(Boolean captured,Boolean dataFlowIn,Boolean dataFlowOut,Boolean alwaysAssigned,Boolean variableDeclared,Boolean readInside,Boolean writtenInside,Boolean readOutside,Boolean writtenOutside,Boolean unsafeAddressTaken)
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GetVariableStyle(Dictionary`2 symbolMap,ISymbol symbol,SemanticModel model,ITypeSymbol type,Boolean captured,Boolean dataFlowIn,Boolean dataFlowOut,Boolean alwaysAssigned,Boolean variableDeclared,Boolean readInside,Boolean writtenInside,Boolean readOutside,Boolean writtenOutside,Boolean unsafeAddressTaken)
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GenerateVariableInfoMap(SemanticModel model,DataFlowAnalysis dataFlowAnalysisData,Dictionary`2 symbolMap)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.AnalyzeAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.ExtractMethodAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.ExtractMethodAsync[TValidator,TExtractor,TResult](&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.GetCodeActionAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.ComputeRefactoringsAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringService.GetRefactoringFromProviderAsync(&lt;Unknown Parameters&gt;)
   at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject)
```</Description>
        <CreatedDate>01/05/2017</CreatedDate>
        <ClosedDate>02/06/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19958</IssueID>
        <Title>Extract method does not support by-ref pass-through</Title>
        <Description>**Version Used**: 15.3

This is an extension of #19136.

**Steps to Reproduce**:

Attempt to use the Extract Method refactoring on the following code:

```csharp
public static int OtherMethod(ref int x)
    =&gt; x;

public static void Method(ref int x)
    =&gt; Console.WriteLine(OtherMethod(ref $x$));
```

**Expected Behavior**:

```csharp
public static int OtherMethod(ref int x)
    =&gt; x;

public static void Method(ref int x)
    =&gt; Console.WriteLine(OtherMethod(ref NewMethod(ref x)));

public static ref int NewMethod(ref int x)
{
    return ref x;
}
```

**Actual Behavior**:

```csharp
public static int OtherMethod(ref int x)
    =&gt; x;

public static void Method(ref int x)
    =&gt; Console.WriteLine(NewMethod(ref x));

public static int NewMethod(ref int x)
{
    return OtherMethod(ref x);
}
```
</Description>
        <CreatedDate>01/06/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/ExtractMethod/ExtractMethodTests.cs</File>
      <File>src/Features/CSharp/Portable/ExtractMethod/CSharpSelectionResult.StatementResult.cs</File>
      <File>src/Features/Core/Portable/ExtractMethod/ExtractMethodMatrix.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>19919</IssueID>
    <Title>Pass a project when creating an invisible editor</Title>
    <Description>This change substantially reduces the amount of work required to locate a document within the solution (file path to hierarchy+itemid).

* Time to apply Fix All from #19895: 2:45 mins
* Time to apply Fix All after this change: 1:32 mins

## Ask Mode

**Customer scenario**

A customer applies a Fix All operation which affects many files in a large solution. (Not specific to any particular code fix.)

**Bugs this fixes:**

Derived from #19900 as the safe option for 15.3 (provides some but not all possible benefits).

**Workarounds, if any**

Wait longer.

**Risk**

Low. This feature adds a hint for a lookup, but valid information is not required in order for the underlying operation to succeed (falls back to slow case when information is not available).

**Performance impact**

This is a substantial performance improvement for Fix All operations.

**Is this a regression from a previous update?**

No.

**Root cause analysis:**

No performance tests covering large-scale operations (yet).

**How was the bug found?**

Internal testing.</Description>
    <CreatedDate>31/05/2017</CreatedDate>
    <ClosedDate>01/06/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>19895</IssueID>
        <Title>Avoid re-verifying semantics of nodes that cannot influence each other</Title>
        <Description>I verified that the applied results on Roslyn.sln are identical before and after this change.

Time to fix all "Use default expression" in Roslyn.sln:

| Implementation | Time to open preview | Time to apply changes |
| --- | --- | --- |
| master branch (05480ee495766eaa198ec3d207867fad5adcc655) | 2:18 min | 2:52 min |
| This branch | 1:35 min | 2:43 min |

:bulb: I filed #19900 to address the time to apply changes.

## Ask Mode

**Customer scenario**

Apply the new **Use Default Literal** code fix to a codebase containing a large number of default expressions.

**Bugs this fixes:**

Closes #19817.

**Workarounds, if any**

Wait longer.

**Risk**

This is much lower risk than a implementation of #19817 as originally described would be, for both correctness and maintainability. This optimization leverages the following language aspects:

1. It assumes that the analyzer only reports diagnostics for cases where a conversion from `default(T)`&amp;rarr;`default` *in isolation* would not change the inferred type of the expression.
2. It assumes that all inference operations (type inference, overload resolution) cannot impact each other across certain boundaries, specifically the following:
    * Parameters
    * Statements
    * Variable declarators
    * Files

**Performance impact**

This change substantially improves performance of code helping users migrate to a specific new feature of C# 7.1.

**Is this a regression from a previous update?**

No.

**Root cause analysis:**

We were aware of the performance limitations and originally opted for the safest path forward. Follow-up investigation revealed an area of low-hanging fruit with relatively low risk.

**How was the bug found?**

Internal dogfooding.</Description>
        <CreatedDate>31/05/2017</CreatedDate>
        <ClosedDate>31/05/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19900</IssueID>
        <Title>Avoid opening invisible editors for applying changes during Fix All</Title>
        <Description>**Version Used**: 15.3 preview 1

**Steps to Reproduce**:

1. Open a large solution (e.g. dotnet/roslyn@05480ee4)
2. Close all open documents except one that can be used to trigger a Fix All operation
3. Apply a Fix All operation that affects a large number of files (e.g. Use Default Literal)

**Expected Behavior**:

The Fix All application (the time it takes *after* hitting Apply on the preview window) completes in the amount of time it takes to save the affected files to disk.

**Actual Behavior**:

The Fix All application takes minutes.

**Notes**:

The dominant costs for this operation ***overwhelmingly*** stem from [opening an invisible editor](https://github.com/dotnet/roslyn/blob/master/src/VisualStudio/Core/Def/Implementation/ProjectSystem/DocumentProvider.StandardTextDocument.cs#L217) for the code fix application rather than operating at a lower level.

During an application of the Use Default Literal code fix for testing #19895, the invisible editor was responsible for 13+GiB of avoidable overhead on the garbage collector in devenv.exe (i.e. overhead unrelated to the actual application of the code fix). Substantial additional time was spent during marshalling for a large number of COM/CLR transitions in various places.</Description>
        <CreatedDate>31/05/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/VisualStudio/Core/Def/Implementation/FindReferences/VisualStudioDefinitionsAndReferencesFactory.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/InvisibleEditor.cs</File>
      <File>src/VisualStudio/Core/Impl/CodeModel/TextManagerAdapter.cs</File>
      <File>src/VisualStudio/Core/Impl/RoslynVisualStudioWorkspace.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>19812</IssueID>
    <Title>Fix IDE0009 false positive on expressions qualified with 'base.'</Title>
    <Description>**Customer scenario**
See #17711 for details

**Bugs this fixes:**
Fixes #17711

**Workarounds, if any**
None

**Risk**
Low

**Performance impact**
Low perf impact because only a couple extra checks are done, with no loops.

**Is this a regression from a previous update?**
No

**Root cause analysis:**
Tests added. Missed because there were no tests initially for this.

**How was the bug found?**
Customer reported.</Description>
    <CreatedDate>26/05/2017</CreatedDate>
    <ClosedDate>02/06/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>17711</IssueID>
        <Title>IDE0009 wrongly generated when using the base keyword</Title>
        <Description>**Version Used**: VS2017 15.0.0-RTW+26228.4

**Steps to Reproduce**: Consider this code

```csharp
class A
{
    public virtual int Value =&gt; 5;
}

class B : A
{
    public override int Value =&gt; base.Value + 6; // warning here
}
```

**Expected Behavior**: No warning generated for IDE0009 on the marked line

**Actual Behavior**: IDE0009 is generated here

The analysis is completely wrong. Applying 'this' would create an infinite loop. The property does not need to be an expression body for IDE0009 to be generated. `Value { get { base.Value + 6; } }` will cause the warning as well.
</Description>
        <CreatedDate>10/03/2017</CreatedDate>
        <ClosedDate>02/06/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>17711</IssueID>
        <Title>IDE0009 wrongly generated when using the base keyword</Title>
        <Description>**Version Used**: VS2017 15.0.0-RTW+26228.4

**Steps to Reproduce**: Consider this code

```csharp
class A
{
    public virtual int Value =&gt; 5;
}

class B : A
{
    public override int Value =&gt; base.Value + 6; // warning here
}
```

**Expected Behavior**: No warning generated for IDE0009 on the marked line

**Actual Behavior**: IDE0009 is generated here

The analysis is completely wrong. Applying 'this' would create an infinite loop. The property does not need to be an expression body for IDE0009 to be generated. `Value { get { base.Value + 6; } }` will cause the warning as well.
</Description>
        <CreatedDate>10/03/2017</CreatedDate>
        <ClosedDate>02/06/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/QualifyMemberAccess/QualifyMemberAccessTests.cs</File>
      <File>src/Features/CSharp/Portable/QualifyMemberAccess/CSharpQualifyMemberAccessDiagnosticAnalyzer.cs</File>
      <File>src/Features/Core/Portable/QualifyMemberAccess/AbstractQualifyMemberAccessDiagnosticAnalyzer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>19737</IssueID>
    <Title>Fix code gen for pattern switch with constant expression</Title>
    <Description>**Customer scenario**

Use new pattern-based switch constructs in which the switch expression is a constant.

**Bugs this fixes:**

* Fix code gen for pattern switch with constant expression
Fixes #19731

* Add instrumentation for pattern switch with constant expression
Fixes #17090

* Incorrect code for generic pattern switch on a constant expression
Fixes #19734

**Workarounds, if any**

Don't use a constant switch expression.

**Risk**

Low. The scenarios are fairly focused, and regression tests now exist for the problematic scenarios.

**Performance impact**

None expected. No significant change in the complexity of the relevant compiler code.

**Is this a regression from a previous update?**

Yes, #19731 is a regression from the last update.

**Root cause analysis:**

We are catching this now as we add coverage for the recently added support for switching on generic types.

**How was the bug found?**

Development testing.
</Description>
    <CreatedDate>23/05/2017</CreatedDate>
    <ClosedDate>05/06/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>19731</IssueID>
        <Title>Bad code for pattern switch with constant expression</Title>
        <Description>The following produces code that does nothing.

This is a regression in master versus the most recent update.

``` c#
    static void M1()
    {
        switch (1)
        {
            case 0 when true:
                ;
            case 1:
                Console.Write(1);
                break;
            case 2:
                ;
        }
    }
```
</Description>
        <CreatedDate>23/05/2017</CreatedDate>
        <ClosedDate>05/06/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>17090</IssueID>
        <Title>Switch expression instrumentation not produced for constant expression in pattern switch</Title>
        <Description>Code generation for a pattern switch does not evaluate the switch expression at runtime when it is a constant. Consequently there is no place in the generated code for the compiler to generate the instrumentation, and the compiler does not produce instrumentation for the switch expression in this case. We should evaluate what the proper treatment of this situation should be.</Description>
        <CreatedDate>10/02/2017</CreatedDate>
        <ClosedDate>05/06/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19734</IssueID>
        <Title>Incorrect code for generic pattern switch on a constant expression</Title>
        <Description>The following produces incorrect code. When `T` is `long`, it prints nothing.

This is a regression in master versus the most recent update.

``` c#
    static void M1&lt;T&gt;()
    {
        switch (1)
        {
            case T t:
                Console.Write(1);
                break;
            case int i:
                Console.Write(2);
                break;
        }
    }
```

This is a new issue in 15.3, as the code was illegal previously.
</Description>
        <CreatedDate>23/05/2017</CreatedDate>
        <ClosedDate>05/06/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19731</IssueID>
        <Title>Bad code for pattern switch with constant expression</Title>
        <Description>The following produces code that does nothing.

This is a regression in master versus the most recent update.

``` c#
    static void M1()
    {
        switch (1)
        {
            case 0 when true:
                ;
            case 1:
                Console.Write(1);
                break;
            case 2:
                ;
        }
    }
```
</Description>
        <CreatedDate>23/05/2017</CreatedDate>
        <ClosedDate>05/06/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/BoundTree/DecisionTreeBuilder.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_PatternSwitchStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/SwitchTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Emit/EditAndContinue/LocalSlotMappingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/PDB/PDBTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>19624</IssueID>
    <Title>Smarter resource management in MemoryMappedInfo</Title>
    <Description>* Unmap views of memory mapped files when they are not in use, allowing the process to use the address space for other purposes (#19604)
* Use fewer memory mapped files for small files (#19570)

## Ask Mode

**Customer scenario**

Customer works in a large solution; over time they tend to observe out of memory exceptions.

**Bugs this fixes:**

Fixes #19493
Fixes #19570
Fixes #19604
Fixes #19761 
[DevDiv 435299](https://devdiv.visualstudio.com/web/wi.aspx?pcguid=011b8bdf-6d56-4f87-be0d-0092136884d9&amp;id=435299) (This is the bug that #19522 was supposed to fix, but it didn't address the problem enough for RPS to drop back to the expected values)

**Workarounds, if any**

None available.

**Risk**

Moderate. The code is complex but efficient and reliable.

**Performance impact**

This change substantially improves performance in several scenarios:

* Application responsiveness is improved by unmapping views of memory mapped files when they are no longer in use, which allows the garbage collector to operate more efficiently
* Application shutdown performance is improved by creating fewer `MemoryMappedFile` instances which need to be finalized

**Is this a regression from a previous update?**

Not really. It's possible that 15.3 Preview 1 or Preview 2 could contain a regression for users on small systems.

**Root cause analysis:**

Failed in #19522 to account for `MemoryMappedInfo` being a long-lived object, where the strong reference to `MemoryMappedInfo._accessor` help memory for much longer than was desirable.

**How was the bug found?**

Reported by dogfooding.
</Description>
    <CreatedDate>18/05/2017</CreatedDate>
    <ClosedDate>01/06/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>19604</IssueID>
        <Title>OOM with memory mapped files</Title>
        <Description>```
System.AggregateException: One or more errors occurred. ---&gt; System.IO.IOException: Not enough storage is available to process this command.

   at System.IO.__Error.WinIOError(Int32 errorCode, String maybeFullPath)
   at System.IO.MemoryMappedFiles.MemoryMappedView.CreateView(SafeMemoryMappedFileHandle memMappedFileHandle, MemoryMappedFileAccess access, Int64 offset, Int64 size)
   at System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewStream(Int64 offset, Int64 size, MemoryMappedFileAccess access)
   at Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.CreateWritableStream()
   at Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService.TemporaryTextStorage.WriteText(SourceText text, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService.TemporaryTextStorage.&lt;&gt;c__DisplayClass13_0.&lt;WriteTextAsync&gt;b__0()
   at System.Threading.Tasks.Task.InnerInvoke()
   at System.Threading.Tasks.Task.Execute()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Microsoft.CodeAnalysis.RecoverableTextAndVersion.RecoverableText.&lt;SaveAsync&gt;d__7.MoveNext()
   --- End of inner exception stack trace ---
---&gt; (Inner Exception #0) System.IO.IOException: Not enough storage is available to process this command.

   at System.IO.__Error.WinIOError(Int32 errorCode, String maybeFullPath)
   at System.IO.MemoryMappedFiles.MemoryMappedView.CreateView(SafeMemoryMappedFileHandle memMappedFileHandle, MemoryMappedFileAccess access, Int64 offset, Int64 size)
   at System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewStream(Int64 offset, Int64 size, MemoryMappedFileAccess access)
   at Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.CreateWritableStream()
   at Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService.TemporaryTextStorage.WriteText(SourceText text, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService.TemporaryTextStorage.&lt;&gt;c__DisplayClass13_0.&lt;WriteTextAsync&gt;b__0()
   at System.Threading.Tasks.Task.InnerInvoke()
   at System.Threading.Tasks.Task.Execute()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Microsoft.CodeAnalysis.RecoverableTextAndVersion.RecoverableText.&lt;SaveAsync&gt;d__7.MoveNext()&lt;---
```</Description>
        <CreatedDate>17/05/2017</CreatedDate>
        <ClosedDate>01/06/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19570</IssueID>
        <Title>Use larger memory mapped files for temporary storage</Title>
        <Description>**Version Used**: 15.2

We can reduce the number of `MemoryMappedFile` instances getting disposed (a time-consuming process) by creating larger instances and using each memory mapped file as the storage for multiple temporary files. This will improve upon the performance gains already realized in #19522.

Currently files are created to match the specific size needed for each file in the solution. For an initial experiment, it might be reasonable to:

* Create files that are 1MiB in size, and use bump pointer allocation to place files within it
* When a file doesn't fit in the remaining space at the end of the last memory mapped file, create a new memory mapped file where it goes at the beginning
* Any file larger than 256KiB is placed in its own memory mapped file

⚠️ Currently these buffers are shared with the OOP workers. The serialization assumes that each temporary file is placed at offset 0 within the target memory mapped file. This will need to be updated to account for multiple temporary storage buffers within a single memory mapped file.</Description>
        <CreatedDate>16/05/2017</CreatedDate>
        <ClosedDate>01/06/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19493</IssueID>
        <Title>MemoryMappedInfo cleanup delays Visual Studio shutdown</Title>
        <Description>**tl;dr:** We create instances of `MemoryMappedInfo` (and its nested types). These types are disposable and have finalizers, but in some cases we do not explicitly dispose of instances. The large number of instances created for some user scenarios combined with non-deterministic cleanup resulted in a measurable (~50ms) increase in the time it takes to close Visual Studio for some scenarios.

What follows is a long and detailed breakdown of an investigation that started early Friday morning (5/12) in response to a performance regression detected the day before.

:bulb: When we refer to "meeting internal performance goals" in places like the contributor guide for Roslyn, but don't explain how external contributors are supposed to actually accomplish that, part of what we're talking about is covered by the system explained in detail below. If you were ever interested in what exactly we meant by that, I hope you enjoy the following read. :smile:

### How it started (5/11)

As part of my current role ("grasshopper") on the @dotnet/roslyn-infrastructure team, one of my responsibilities is scheduling and monitoring the incorporation of Roslyn code into Visual Studio itself. The whole process is very new to me, but a reasonably accurate way for a non-Microsoft to view this system is a build farm dedicated to running end-to-end tests prior to taking changes from one large team and applying them to another team. The system as a whole serves as both an early warning system for potential problems and helps identify the team responsible for various types of failures.

One of the toughest types of problems to detect reliably is performance regressions, and anyone who's tried to implement such tests in the past knows what I'm talking about. And the bigger the system under test, the harder it is to produce meaningful results. Small sections of code might be easy to benchmark, but in this case we're talking about ~15+ minute end-to-end user scenario tests of Visual Studio. To keep things flowing smoothly, performance tests in the system allow for some amount of "noise" in the test results. Deviations outside the allowed noise signify major problems where we cannot proceed until they are resolved (I haven't had to deal with one of these so there could be exceptions/special cases that I just don't know about). Deviations "under the degrade bar" do not cause a red flag in the system, still show up on performance reports based on a scoring system. Test scenarios that ran slower than the baseline are given a score based on how close to the bar they are: (actual-baseline)/(bar-baseline), and the highest values show up on the top of the report for manual investigation.

I mentioned "tests" and "scenarios". The two concepts are vital to understanding how we review long and complicated test sequence to identify specific possible regressions. The "test" refers to a complete end-to-end test, which might include opening VS, creating one or more projects, writing some code, building, running, and finally closing the solution and closing Visual Studio itself. Each test is divided into several named scenarios corresponding to specific actions, and target metrics may be defined either for the test as a whole or for specific scenarios.

:bulb: For anyone wanting to set up a system like this someday, I recommend you implement the ability to automatically assign metrics based on what you measure in a shipping release. This "baselining" ability allows you to establish target goals relatively easily that help ensure future releases of your product perform *at least as well* as the previous release, which is a great place to start when discussing development strategies to gradually improve the experience your customers have on a daily basis.

Thursday's test run included one test which did not exceed the bar but seemed "worse than normal", thus starting a manual review. The specific scenario was "Close VS", which in this test occurs after the solution is already closed. The degrade bar is set at 100ms slower than the previous release, and the build was showing a value of 52ms slower. The investigation started with a review of the history of this test using a tool that shows the builds on our team and the builds for the "mainline" that all the teams interact with. This overlay of the two branches is important because it can show with relatively high confidence whether a problem originated on our team (shows up on ours before mainline), or another team (shows up in mainline before ours). Here's the graph going back several builds. The orange branch is our team, and the purple branch is one of the main Visual Studio branches.

![image](https://cloud.githubusercontent.com/assets/1408396/26037111/46c48730-38b2-11e7-8a4e-a22204894d9c.png)

This investigation centered around the apparent new trend where we are sitting roughly 40-50ms slower than our goal line, and which started on our team builds prior to showing up in the main branch.

### Tracking down the problem (5/12)

Tracking down the problem is not always easy, but the two things you can do to be successful on this front are preparation and practice.

#### Preparation

Our end-to-end tests which we use for performance monitoring have PerfView running in the background. I don't have details regarding the exact configuration, but the key items would be:

1. Configure your sampling rate such that you have a "manageable" output data file size over the duration of your test. Since our tests are 15+ minutes, this means a slower sampling rate than the default.
2. Make sure you are enabling items that relate to your user experience. The meaning of this will vary by industry/application, but for me the two items I found valuable were having Thread Time enabled and also having marks inserted into the trace by the end-to-end test driver identifying exactly when a scenario (e.g. Close VS) started and ended.
3. Store the outputs of the PerfView traces for a sufficient amount of time that they can be used for comparative analysis in the future.

#### Practice

I had an advantage in investigating this by knowing three things:

1. The scenario which failed was Close VS, so I could filter the PerfView reports to start and end at the markers placed at the start and end of this scenario. As you can see from the graph, this is a ~300ms window out of the ~15 minute report.
2. Since I was investigating an elapsed time performance failure, the view of most immediate interest was the Thread Time view. I needed to account for the additional 50ms of time, regardless of whether that time was BLOCKED TIME or CPU TIME.
3. Even though this was my first experience ever with this test or scenario, I knew I could most easily track down the time by opening two reports side by side: one from a recent "slow" run, and the other from a recent "fast" run.

### Findings

I started with the Call Tree view examining the main thread. By comparing with the previous run, I pretty quickly narrowed down the additional time on the main thread to the following trace. The highlighted value accounts for all of the new time:

![image](https://cloud.githubusercontent.com/assets/1408396/26037288/d844c974-38b5-11e7-9d57-8c8fcf781a56.png)

As you can see, the main thread was blocked during this time, so to find the root cause we have to find out what it was waiting on. In this case, the answer was pretty easy to infer by looking at the thread activity histograms and asking "what would the CLR be waiting for during `clr!??EEShutdown`.

![image](https://cloud.githubusercontent.com/assets/1408396/26037348/cb182722-38b6-11e7-9a6f-818a9d89a63c.png)

Focusing on the finalizer thread showed two items of particular interest:

![image](https://cloud.githubusercontent.com/assets/1408396/26037410/b1d48458-38b7-11e7-95a0-4834f2403dff.png)

The in the conveniently available CoreCLR sources, we can see that these are the two methods called to [finalize a single object](https://github.com/dotnet/coreclr/blob/76cbc581382ebbcf745dd2b79ac02c419970808c/src/vm/finalizerthread.cpp#L98-L99).

* **clr!WKS::CallFinalizer**: This is slow when you have many finalizers, or when finalizers themselves are slow
* **clr!WKS::LogFinalization**: This has no measurable overhead normally, but a small amount of overhead when ETW events are being recorded. While the call within it, **clr!??ETW::GCLog::SendFinalizeObjectEvent**, probably should have been pruned by our analysis as measurement overhead imposed by PerfView recording, it nevertheless provided valuable insight for me. *Time here means a large number of objects are getting finalized.*

A closer look at **clr!WKS::CallFinalizer** revealed the problem with `MemoryMappedInfo`:

![image](https://cloud.githubusercontent.com/assets/1408396/26037484/e9aaa91a-38b8-11e7-900a-d1cdfdb0d313.png)

In the next step of my investigation, I wanted to determine how many `MemoryMappedInfo` objects were getting finalized when the CLR was trying to shut down. This part was rather difficult, but hopefully in the future it can be improved (filed Microsoft/perfview#200 and Microsoft/perfview#201). I filtered the events view to the start/end time for the scenario, set MaxRet to 110000 (so all events would show), and set the process filter to **devenv**. I then opened the **Microsoft-Windows-DotNETRuntime/GC/FinalizeObject** events, showed the **TypeID** column, and exported the resulting view as a CSV file. After opening the CSV file in Excel, I used a pivot table on the TypeID column to get a histogram which I sorted by the number of times an object of that type ID was finalized. Working from the top, I then examined all available events in PerfView of type **Microsoft-Windows-DotNETRuntime/GC/AllocationTick** to associate type IDs with type names. I only made it through the first 5 items before the sampling rate of AllocationTick stopped showing results.

![image](https://cloud.githubusercontent.com/assets/1408396/26037537/834c1a12-38ba-11e7-9d33-e0bc0d7e0e63.png)

### Follow-up

The solution appears to be two-fold:

1. Reduce the number of memory-mapped file handles that need to be cleaned up. For example, rather than create a memory mapped file for every temporary storage request, we could set a minimum size on the file at 1 MiB, and use smaller views within the file for temporary storage. When a request is too large to fit in the available space at the end of the current file, stop creating storage in that file and move to a new one.
2. Reduce the "weight" of finalization by reducing the size of the object graph referenced by finalizable objects. In particular, avoid making `MemoryMappedInfo` and `SharedReadableStream` themselves finalizable, and instead create a minimal type (or types) derived from `CriticalHandle` which is responsible for releasing the unmanaged resources.</Description>
        <CreatedDate>14/05/2017</CreatedDate>
        <ClosedDate>01/06/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19570</IssueID>
        <Title>Use larger memory mapped files for temporary storage</Title>
        <Description>**Version Used**: 15.2

We can reduce the number of `MemoryMappedFile` instances getting disposed (a time-consuming process) by creating larger instances and using each memory mapped file as the storage for multiple temporary files. This will improve upon the performance gains already realized in #19522.

Currently files are created to match the specific size needed for each file in the solution. For an initial experiment, it might be reasonable to:

* Create files that are 1MiB in size, and use bump pointer allocation to place files within it
* When a file doesn't fit in the remaining space at the end of the last memory mapped file, create a new memory mapped file where it goes at the beginning
* Any file larger than 256KiB is placed in its own memory mapped file

⚠️ Currently these buffers are shared with the OOP workers. The serialization assumes that each temporary file is placed at offset 0 within the target memory mapped file. This will need to be updated to account for multiple temporary storage buffers within a single memory mapped file.</Description>
        <CreatedDate>16/05/2017</CreatedDate>
        <ClosedDate>01/06/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19604</IssueID>
        <Title>OOM with memory mapped files</Title>
        <Description>```
System.AggregateException: One or more errors occurred. ---&gt; System.IO.IOException: Not enough storage is available to process this command.

   at System.IO.__Error.WinIOError(Int32 errorCode, String maybeFullPath)
   at System.IO.MemoryMappedFiles.MemoryMappedView.CreateView(SafeMemoryMappedFileHandle memMappedFileHandle, MemoryMappedFileAccess access, Int64 offset, Int64 size)
   at System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewStream(Int64 offset, Int64 size, MemoryMappedFileAccess access)
   at Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.CreateWritableStream()
   at Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService.TemporaryTextStorage.WriteText(SourceText text, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService.TemporaryTextStorage.&lt;&gt;c__DisplayClass13_0.&lt;WriteTextAsync&gt;b__0()
   at System.Threading.Tasks.Task.InnerInvoke()
   at System.Threading.Tasks.Task.Execute()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Microsoft.CodeAnalysis.RecoverableTextAndVersion.RecoverableText.&lt;SaveAsync&gt;d__7.MoveNext()
   --- End of inner exception stack trace ---
---&gt; (Inner Exception #0) System.IO.IOException: Not enough storage is available to process this command.

   at System.IO.__Error.WinIOError(Int32 errorCode, String maybeFullPath)
   at System.IO.MemoryMappedFiles.MemoryMappedView.CreateView(SafeMemoryMappedFileHandle memMappedFileHandle, MemoryMappedFileAccess access, Int64 offset, Int64 size)
   at System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewStream(Int64 offset, Int64 size, MemoryMappedFileAccess access)
   at Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.CreateWritableStream()
   at Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService.TemporaryTextStorage.WriteText(SourceText text, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService.TemporaryTextStorage.&lt;&gt;c__DisplayClass13_0.&lt;WriteTextAsync&gt;b__0()
   at System.Threading.Tasks.Task.InnerInvoke()
   at System.Threading.Tasks.Task.Execute()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Microsoft.CodeAnalysis.RecoverableTextAndVersion.RecoverableText.&lt;SaveAsync&gt;d__7.MoveNext()&lt;---
```</Description>
        <CreatedDate>17/05/2017</CreatedDate>
        <ClosedDate>01/06/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19761</IssueID>
        <Title>Access violation in RoslynCodeAnalysisService32 reading from memory mapped file</Title>
        <Description>**Version Used**: 15.3 preview 1

**Stack trace**

```
Application: ServiceHub.RoslynCodeAnalysisService32.exe
Framework Version: v4.0.30319
Description: The process was terminated due to an unhandled exception.
Exception Info: System.AccessViolationException
   at Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory+MemoryMappedInfo+SharedReadableStream.ReadByte()
   at System.IO.BinaryReader.ReadByte()
   at Roslyn.Utilities.ObjectReader.ReadValueWorker()
   at Roslyn.Utilities.ObjectReader.&lt;ReadValue&gt;b__25_0()
   at System.Threading.Tasks.Task`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].InnerInvoke()
   at System.Threading.Tasks.Task.Execute()
   at System.Threading.Tasks.Task.ExecutionContextCallback(System.Object)
   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)
   at System.Threading.Tasks.Task.ExecuteEntry(Boolean)
   at System.Threading.Tasks.ThreadPoolTaskScheduler.LongRunningThreadWork(System.Object)
   at System.Threading.ThreadHelper.ThreadStart_Context(System.Object)
   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)
   at System.Threading.ThreadHelper.ThreadStart(System.Object)
```</Description>
        <CreatedDate>24/05/2017</CreatedDate>
        <ClosedDate>16/06/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19522</IssueID>
        <Title>Reduce overhead from memory mapped files</Title>
        <Description>Fixes #19493

## Ask Mode

**Customer scenario**

Customer closes Visual Studio after working in a C# or Visual Basic project.

**Bugs this fixes:**

#19493 
DevDiv 435299 (external users: this internal bug tracks the internal performance regression and just points to the previous public bug where I placed all the actual info)

**Workarounds, if any**

Wait longer.

**Risk**

Low. Of several ways known ways to improve performance in this scenario, I chose the least risky one. Follow-up issues will be filed as opportunistic areas for further improvement in the future.

**Performance impact**

The time it takes to close Visual Studio is reduced by roughly 0.25-1ms for each file in the solution. This is a multiple second improvement for projects like Roslyn.sln.

**Is this a regression from a previous update?**

No. The bug appears to have been introduced with Visual Studio 2015.

**Root cause analysis:**

Failure of internal Regression Prevention System (RPS) tests to exercise code paths related to this bug, and failure to go through PerfView traces in detail for scenarios targeting very large solutions. Discussions are taking place regarding improvements to PerfView which should help reveal these kinds of problems for both us and developers of other applications before they cause problems.

**How was the bug found?**

RPS tests</Description>
        <CreatedDate>15/05/2017</CreatedDate>
        <ClosedDate>17/05/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19522</IssueID>
        <Title>Reduce overhead from memory mapped files</Title>
        <Description>Fixes #19493

## Ask Mode

**Customer scenario**

Customer closes Visual Studio after working in a C# or Visual Basic project.

**Bugs this fixes:**

#19493 
DevDiv 435299 (external users: this internal bug tracks the internal performance regression and just points to the previous public bug where I placed all the actual info)

**Workarounds, if any**

Wait longer.

**Risk**

Low. Of several ways known ways to improve performance in this scenario, I chose the least risky one. Follow-up issues will be filed as opportunistic areas for further improvement in the future.

**Performance impact**

The time it takes to close Visual Studio is reduced by roughly 0.25-1ms for each file in the solution. This is a multiple second improvement for projects like Roslyn.sln.

**Is this a regression from a previous update?**

No. The bug appears to have been introduced with Visual Studio 2015.

**Root cause analysis:**

Failure of internal Regression Prevention System (RPS) tests to exercise code paths related to this bug, and failure to go through PerfView traces in detail for scenarios targeting very large solutions. Discussions are taking place regarding improvements to PerfView which should help reveal these kinds of problems for both us and developers of other applications before they cause problems.

**How was the bug found?**

RPS tests</Description>
        <CreatedDate>15/05/2017</CreatedDate>
        <ClosedDate>17/05/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Workspaces/Core/Desktop/Workspace/Host/TemporaryStorage/TemporaryStorageServiceFactory.CopiedMemoryMappedViewHandle.cs</File>
      <File>src/Workspaces/Core/Desktop/Workspace/Host/TemporaryStorage/TemporaryStorageServiceFactory.MemoryMappedInfo.cs</File>
      <File>src/Workspaces/Core/Desktop/Workspace/Host/TemporaryStorage/TemporaryStorageServiceFactory.ReferenceCountedDisposable.cs</File>
      <File>src/Workspaces/Core/Desktop/Workspace/Host/TemporaryStorage/TemporaryStorageServiceFactory.cs</File>
      <File>src/Workspaces/Core/Portable/Execution/AbstractReferenceSerializationService.cs</File>
      <File>src/Workspaces/Core/Portable/Execution/Serializer_Asset.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/Host/TemporaryStorage/ITemporaryStorageService2.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/Host/TemporaryStorage/ITemporaryStorageWithName.cs</File>
      <File>src/Workspaces/CoreTest/WorkspaceServiceTests/ReferenceCountedDisposableTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>19278</IssueID>
    <Title>IObjectCreationExpression API Change</Title>
    <Description>**Customer scenario**

All IOperation based analyzers will generate large number of false positives OR not analyze code within object and collection initializers. Given that such a code pattern is very common, this can be a dogfood blocker for IOperation analyzers (FXCop). 

**Bugs this fixes:**

Fixes #18115

There are still 2 remaining bugs affecting this area:
1. #18781: IOperation API shape for collection initializer expressions
2. #19276: Missing Field/Property reference expression nodes in object creation initializer node

**Workarounds, if any**

The analyzer users will have to either suppress all IOperation analyzers on methods containing object/collection initializers or disable these analyzers.

**Risk**

Low. We are just returning the operation nodes as they are in the bound tree rather than synthesizing new symbol initializer nodes.

**Performance impact**

None

**Is this a regression from a previous update?**

No, this was the original IOperation API implementation

**Root cause analysis:**

The underlying reason is that the current API shape of IObjectCreationExpression only exposes member initializers, not collection initializers.

There are couple of changes in this PR:
1. API change: `ImmutableArray&lt;ISymbolInitializer&gt; MemberInitializers` is changed to `ImmutableArray&lt;IOperation&gt; Initializers` as per design time decision.
2. Implementation changes:
   1. Instead of returning the member initializers as synthesized ISymbolInitializer nodes, we now return member initializers as IAssignmentExpression nodes. This ensures completeness of IOperation tree.
   2. Now we also return the collection initializer expressions within an object creation expression.

**How was the bug found?**

Dogfooding.
</Description>
    <CreatedDate>04/05/2017</CreatedDate>
    <ClosedDate>09/05/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>18115</IssueID>
        <Title>IObjectCreationExpression API shape</Title>
        <Description>```
    public interface IObjectCreationExpression : IHasArgumentsExpression
    {
        /// &lt;summary&gt;
        /// Constructor to be invoked on the created instance.
        /// &lt;/summary&gt;
        IMethodSymbol Constructor { get; }
        /// &lt;summary&gt;
        /// Explicitly-specified member initializers.
        /// &lt;/summary&gt;
        ImmutableArray&lt;ISymbolInitializer&gt; MemberInitializers { get; }
    }
```

The shady part is MemberInitializers, which only expose a part of the IOperation tree within the object member initializer.

Let me give an example:
```
Class F
    Public Field As Integer
End Class

Class C
    Public Sub M1()
        Dim x2 = New F() With {.Field = 2}
    End Sub
End Class
```

IOperation tree for object creation:
```
IOperation tree for "Dim x2 = New F() With {.Field = 2}"

IVariableDeclarationStatement (1 variables) (OperationKind.VariableDeclarationStatement)
  IVariableDeclaration: x2 As F (OperationKind.VariableDeclaration)
    Initializer: IObjectCreationExpression (Constructor: Sub F..ctor()) (OperationKind.ObjectCreationExpression, Type: F)
        Member Initializers: IFieldInitializer (Field: F.Field As System.Int32) (OperationKind.FieldInitializerInCreation)
            ILiteralExpression (Text: 2) (OperationKind.LiteralExpression, Type: System.Int32, Constant: 2)
```

IOperation tree for it's child node, object member initializer:
```
IOperation tree for "With {.Field = 2}"

IOperation (OperationKind.None)
```

IOperation tree for one of the child nodes of the member initializer, NamedFieldInitializerSyntax:
```
IOperation tree for ".Field = 2"

IAssignmentExpression (OperationKind.AssignmentExpression, Type: System.Int32)
  Left: IFieldReferenceExpression: F.Field As System.Int32 (OperationKind.FieldReferenceExpression, Type: System.Int32)
      Instance Receiver:  (OperationKind.None)
  Right: ILiteralExpression (Text: 2) (OperationKind.LiteralExpression, Type: System.Int32, Constant: 2)
```

I think we either need to change `MemberInitializers` to return the entire IOperation tree for each initializer (which would be the IAssignmentExpression for the field initializer) OR replace MemberInitializers with `InitializerOpt` of new OperationKind.ObjectMemberInitializer, which exposes all the initializer expressions.</Description>
        <CreatedDate>23/03/2017</CreatedDate>
        <ClosedDate>09/05/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>18781</IssueID>
        <Title>IOperation API shape for object and collection initializer expressions</Title>
        <Description>Currently, BoundCollectionIntializerExpression has OperationKind.None and implements IOperation. This means that we completely cut-off the operations within a collection initializer, including even the nested initializers.

We need to design the API shape for Collection initializers.

1. Do we need an `ICollectionInitializerExpression`? Theoretically, we don't need it as `IObjectCreationExpression.Initializers` can return the child collection element initializer nodes of a collection initializer.
2. Do we need an `ICollectionElementInitializerExpression`? We have 2 possible designs:
   1. Follow the VB bound tree pattern, which stores a `BoundCall` for collection element initializer, so we don't need a new API. However, C# doesn't store this bound call, but instead has a `BoundCollectionElementInitializerExpression` (with invoked method name and arguments) and `BoundDynamicCollectionElementInitializer` (with possible applicable methods and arguments) . So we need to synthesize such a bound call for C# and return it as an initializer. Note that this approach introduces an implicit compiler generated IOperation node in the operation tree.
   2. Add the following API and our Operation tree node for CollectionElementInitializerExpression, can have language specific implementations that delegate to either BoundCall (VB) or BoundICollectionElementInitializerExpression or BoundDynamicCollectionElementInitializer (C#):
```
namespace Microsoft.CodeAnalysis.Semantics
{
    /// &lt;summary&gt;
    /// Represents a collection element initializer expression.
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;
    /// This interface is reserved for implementation by its associated APIs. We reserve the right to
    /// change it in the future.
    /// &lt;/remarks&gt;
    public interface ICollectionElementInitializerExpression : IHasArgumentsExpression
    {
        /// &lt;summary&gt;
        /// Set of applicable methods for an implicit dynamic invocation OR the implicit Add method symbol for non-dynamic invocation.
        /// &lt;/summary&gt;
        ImmutableArray&lt;IMethodSymbol&gt; ApplicableMethods { get; }

        /// &lt;summary&gt;
        /// Flag indicating if this is a dynamic initializer invocation.
        /// &lt;/summary&gt;
        bool IsDynamic { get; }
    }
}
```


look for an example here  https://github.com/dotnet/roslyn/issues/18509  </Description>
        <CreatedDate>18/04/2017</CreatedDate>
        <ClosedDate>12/07/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19276</IssueID>
        <Title>Missing Field/Property reference expression nodes in object creation initializer node</Title>
        <Description>
```
internal class Class
{
    public int Property { get; set; }
    public int Field;

    public void M()
    {
        var c = new Class() { Field = 0, Property = 0 };
    }
}
```

```
IOperation tree for "new Class() { Field = 0, Property = 0 }"

IObjectCreationExpression (Constructor: Class..ctor()) (OperationKind.ObjectCreationExpression, Type: Class) (Syntax: 'new Class() ... perty = 0 }')
  Initializers(2): IAssignmentExpression (OperationKind.AssignmentExpression, Type: System.Int32) (Syntax: 'Field = 0')
      Left: IOperation:  (OperationKind.None) (Syntax: 'Field')
      Right: ILiteralExpression (Text: 0) (OperationKind.LiteralExpression, Type: System.Int32, Constant: 0) (Syntax: '0')
    IAssignmentExpression (OperationKind.AssignmentExpression, Type: System.Int32) (Syntax: 'Property = 0')
      Left: IOperation:  (OperationKind.None) (Syntax: 'Property')
      Right: ILiteralExpression (Text: 0) (OperationKind.LiteralExpression, Type: System.Int32, Constant: 0) (Syntax: '0')
```

**Expected:**
1.  `Left: IOperation:  (OperationKind.None) (Syntax: 'Field')` must be an IFieldReferenceExpression and
2. `Left: IOperation:  (OperationKind.None) (Syntax: 'Property')` must be an IPropertyReferenceExpression

Similar code in VB does contain the field and property reference expressions on Left:

```
Friend Class [Class]
    Public Field As Integer
    Public Property Prop As Integer

    Public Sub M()
        Dim c = New [Class]() With {.Field = 0, .Prop = 0}
    End Sub
End Class
```

```
IOperation tree for "New [Class]() With {.Field = 0, .Prop = 0}"

IObjectCreationExpression (Constructor: Sub [Class]..ctor()) (OperationKind.ObjectCreationExpression, Type: [Class]) (Syntax: 'New [Class] ...  .Prop = 0}')
  Initializers(2): IAssignmentExpression (OperationKind.AssignmentExpression, Type: System.Int32) (Syntax: '.Field = 0')
      Left: IFieldReferenceExpression: [Class].Field As System.Int32 (OperationKind.FieldReferenceExpression, Type: System.Int32) (Syntax: 'Field')
          Instance Receiver: IOperation:  (OperationKind.None) (Syntax: 'New [Class] ...  .Prop = 0}')
      Right: ILiteralExpression (Text: 0) (OperationKind.LiteralExpression, Type: System.Int32, Constant: 0) (Syntax: '0')
    IAssignmentExpression (OperationKind.AssignmentExpression, Type: System.Void) (Syntax: '.Prop = 0')
      Left: IIndexedPropertyReferenceExpression: Property [Class].Prop As System.Int32 (OperationKind.PropertyReferenceExpression, Type: System.Int32) (Syntax: 'Prop')
          Instance Receiver: IOperation:  (OperationKind.None) (Syntax: 'New [Class] ...  .Prop = 0}')
      Right: ILiteralExpression (Text: 0) (OperationKind.LiteralExpression, Type: System.Int32, Constant: 0) (Syntax: '0')
```

```</Description>
        <CreatedDate>04/05/2017</CreatedDate>
        <ClosedDate>12/07/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/BoundTree/Expression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Diagnostics/OperationAnalyzerTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IObjectCreationExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IParameterReferenceExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_ISymbolInitializer.cs</File>
      <File>src/Compilers/Core/Portable/Generated/Operations.xml.Generated.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IObjectCreationExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationWalker.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/OperationTreeVerifier.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>19237</IssueID>
    <Title>Reuse local rewriter to derive arguments for IHasArgumentsExpression</Title>
    <Description>This PR contains following changes:

1. Add `Binder` to `BoundCall`, `BoundIndexerAccess` and `BoundObjectCreationExpression`.
2. Refactored arguments rewriting related methods in `LocalRewriter`, everything needed by `IOperation` is refactored into static methods. 
3. Change `DeriveArguments` method to reuse `LocalRewriter` (only static methods).
4. Add a field `IsLeftOfAssignment` to `BoundIndexerAccess`, which is used to decide whether the parameter symbol of indexer setter or getter should be used for default argument calculation.
5. Add tests.

This seems to address most of the regular scenarios we (i.e. existing FxCop analyzers) care about.

#18722 is not addressed in this PR: If the bound node has errors, we currently still expose it `IInvocationExpression` (or other `IHasArgumentsExpression`), with all provided arguments as `IArgument`.

**Customer scenario**

The C# version of `IHasArgumentsExpression.ArgumentsInEvaluationOrder` was basically reusing the implementation of (now removed) `ArgumentsInSourceOrder`, which was a separate implementation from similar logic in rewriter and results in incorrect/inconsistent default argument and param array argument operations. That in turn would cause a large amount of false positive/negatives in analyzers.

**Bugs this fixes:**

#18549, #7960,  #8813, #8786 and #19382 

**Workarounds, if any**

No. Have to disable analyzers relies on the `IHasArgumentsExpression.ArgumentsInEvaluationOrder` interface to avoid false positive/negatives.

**Risk**

Low. Although the PR touches both c# bound tree and local rewriter, the changes that affects compiler code path is purely refactoring which shouldn't cause any regression. The actual behavior change is limited within IOperation realm behind the feature flag.


**Performance impact**

Low. 

**Is this a regression from a previous update?**

No.

**Root cause analysis:**

IOperation APIs are actively changing and being developed.

**How was the bug found?**

This has been a known issue since the initial IOperation implementation.</Description>
    <CreatedDate>04/05/2017</CreatedDate>
    <ClosedDate>18/05/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>18722</IssueID>
        <Title>Add `IInvalidInvocationExpression` interafce</Title>
        <Description>Currently in C#, an invalid invocation is represented by an `IInvocationExpression` operation, but it might violate the contract of `IInvocationExpression`. For example, we can't provide a list of arguments in evaluation order correctly if we have extra arguments that don't match any parameter, or multiple arguments are matching to a single parameter, etc. On the other hand, making an invalid invocation an `IInvalidExpression` would solve the problem but it would be unnecessarily lossy since in many cases compiler does have more details that users might find useful to do further analysis.

The goal would be to expose as much information of a invalid invocation as possible at best effort, without violating the API contract of `IInvocationExpression`, hence the new `IInvalidInvocationExpression` interface.

Here's the notes from our discussion:
- Will be a sibling of `IInvocationExpression` (child of `IHasArgumentExpression`)
- Should contain candidate symbols and candidate reason.
- Has a list `ArgumentValues` of type `IOperation` that were passed to the invocation.
- And a receiver of type` IOperatoin`
- We would also like an api/extension `TryGetParameterForArgumentValue`, indicating it's best effort and may fail

@dotnet/analyzer-ioperation </Description>
        <CreatedDate>15/04/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>18549</IssueID>
        <Title>`IHasArgumentsExpression.ArgumentsInEvaluationOrder` in C# should not use private implementation</Title>
        <Description>Currently, there is a lot of logic duplicated in C#'s implementation and there is a lot of opportunities to deviate from what LocalRewriter is doing. I believe our goal should be to return result consistent with what LocalRewriter would produce. As such we should find a way to share that logic, IOperation should not have its own private implementation.

With this in mind, I have made the change for IHasArgumentsExpression interface in #18494 with minimal change in implementation, to avoid doing unnecessary throwaway work. As a result, **the contract for `IHasArgumentsExpression.ArgumentsInEvaluationOrder` is broken**, as current implementation is the old `ArgumentsInSourceOrder`, therefore missing all default arguments (including empty param array). This issue is intended to track this as well, as I believe getting rid of private implementation would also fix this.</Description>
        <CreatedDate>08/04/2017</CreatedDate>
        <ClosedDate>18/05/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>7960</IssueID>
        <Title>Default argument operation doesn't handle caller info attributes</Title>
        <Description>We need to decide if we want to make argument operation handles caller info attributes.
</Description>
        <CreatedDate>14/01/2016</CreatedDate>
        <ClosedDate>18/05/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>8813</IssueID>
        <Title>IOperation: A proposal to change design around IHasArgumentsExpression, IInvocationExpression and IArgument interfaces.</Title>
        <Description>**Exposing the set of arguments**

Currently we have two APIs that are supposed to expose arguments and every implementer has to implement both.
In IHasArgumentsExpression, which is IInvocationExpression inherits from:

```
        /// &lt;summary&gt;
        /// Arguments of the invocation, excluding the instance argument. Arguments are in parameter order,
        /// and params/ParamArray arguments have been collected into arrays. Default values are supplied for
        /// optional arguments missing in source.
        /// &lt;/summary&gt;
        ImmutableArray&lt;IArgument&gt; ArgumentsInParameterOrder { get; }
```

In IInvocationExpression 

```
        /// &lt;summary&gt;
        /// Arguments of the invocation, excluding the instance argument. Arguments are in the order specified in source,
        /// and params/ParamArray arguments have been collected into arrays. Arguments are not present
        /// unless supplied in source.
        /// &lt;/summary&gt;
        ImmutableArray&lt;IArgument&gt; ArgumentsInSourceOrder { get; }
```

I am not sure if having two these APIs provides much value. I believe that it would be much more useful to have a single API in IHasArgumentsExpression:

```
        /// &lt;summary&gt;
        /// Arguments of the invocation, excluding the instance argument. Arguments are in evaluation order,
        /// and params/ParamArray arguments have been collected into arrays. Default values are supplied for
        /// optional arguments missing in source.
        /// &lt;/summary&gt;
        ImmutableArray&lt;IArgument&gt; ArgumentsInEvaluationOrder { get; }
```

If we feel that sometimes consumers would want to traverse arguments in source or parameter order, we can provide helpers like this as extension methods for IHasArgumentsExpression interface because all the relevant information should be available from IArguments.

**IArgument, ArgumentKinds and param arrays**

It is not obvious what value do we get from distinguishing between Positional and Named arguments. I believe Analyzers will be more interested in the order, in which arguments are evaluated (ArgumentsInEvaluationOrder solves that). Knowing whether the argument was named doesn't look that important and can always be discovered from syntax. 

The requirement to create a separate IArgument of ParamArray kind for each element of param array

```
        /// &lt;summary&gt;
        /// Argument becomes an element of an array that matches a trailing C# params or VB ParamArray parameter.
        /// &lt;/summary&gt;
        ParamArray = 0x3,
```

means that we will create trees of different shape for situations when param array was created by the compilers and when the array was passed explicitly. Do Analyzers really care that much about param array that they will be willing to be prepared to deal with two different tree shapes for semantically equivalent code?

Another issue with the current design is that it looks like an empty param array created by compilers won't have any representation in the tree at all, because there is no ArgumentKind that could be used for such an argument.

To address all these issues, I propose to change the current set of ArgumentKinds as follows (note, the meaning of ParamArray kind is changed):

```
    /// &lt;summary&gt;
    /// Kinds of arguments.
    /// &lt;/summary&gt;
    public enum ArgumentKind
    {
        None = 0x0,

        /// &lt;summary&gt;
        /// Argument value is explicitly supplied.
        /// &lt;/summary&gt;
        Explicit = 0x1,

        /// &lt;summary&gt;
        /// Argument is a param array created by compilers for the matching C# params or VB ParamArray parameter. Note, the value is a an array creation expression that encapsulates all the elements, if any.
        /// &lt;/summary&gt;
        ParamArray = 0x2,

        /// &lt;summary&gt;
        /// Argument is a default value supplied automatically by the compilers.
        /// &lt;/summary&gt;
        DefaultValue = 0x3
    }
```

See related issues: #8805, #8786, #8781, #8773.
</Description>
        <CreatedDate>17/02/2016</CreatedDate>
        <ClosedDate>18/05/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>8786</IssueID>
        <Title>IOperation: What is the value of ParamArray arguments?</Title>
        <Description>Given the following API definition:

```
    /// &lt;summary&gt;
    /// Kinds of arguments.
    /// &lt;/summary&gt;
    public enum ArgumentKind
    {
        None = 0x0,

        /// &lt;summary&gt;
        /// Argument is specified positionally and matches the parameter of the same ordinality.
        /// &lt;/summary&gt;
        Positional = 0x1,
        /// &lt;summary&gt;
        /// Argument is specified by name and matches the parameter of the same name.
        /// &lt;/summary&gt;
        Named = 0x2,
        /// &lt;summary&gt;
        /// Argument becomes an element of an array that matches a trailing C# params or VB ParamArray parameter.
        /// &lt;/summary&gt;
        ParamArray = 0x3,
        /// &lt;summary&gt;
        /// Argument was omitted in source but has a default value supplied automatically.
        /// &lt;/summary&gt;
        DefaultValue = 0x4
    }
```

It looks like the shape of the IOperation tree is going to depend on whether param array argument was crated by the compiler. Given this method definition:

```
static void Test(params string[] y)
```

The following call will have two ParamArray arguments, corresponding to `"a"` and `"b"`:

```
Test("a", "b");
```

But this call will have one Positional argument, corresponding to `new [] {"a", "b"}`:

```
Test(new [] {"a", "b"});
```

These two calls are semantically identical. Do we really want analyzers to be prepared to deal with this difference? 

What argument should be created for this scenario, where `"a"` is a named argument and a param array element at the same time?

```
    static void Main()
    {
        Test(y: "a", x:10);
    }

    static void Test(int x, params string[] y)
    {
        System.Console.WriteLine(y[0]);
    }
```
</Description>
        <CreatedDate>17/02/2016</CreatedDate>
        <ClosedDate>18/05/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19382</IssueID>
        <Title>A combination of discard with arglist crashes compiler</Title>
        <Description>```
        [Fact]
        public void DiscardAndArgList()
        {
            var text = @"
using System;
public class C
{
    static void Main()
    {
        M(out _, __arglist(2, 3, true));
    }
    
    static void M(out int x, __arglist)
    {    
        x = 0;
        DumpArgs(new ArgIterator(__arglist));
    }

    static void DumpArgs(ArgIterator args)
    {
        while(args.GetRemainingCount() &gt; 0)
        {
            TypedReference tr = args.GetNextArg();
            object arg = TypedReference.ToObject(tr);
            Console.Write(arg);
        }
    }
}";
            var compilation = CreateStandardCompilation(text, options: TestOptions.ReleaseExe, parseOptions: TestOptions.Regular);

            compilation.VerifyDiagnostics(
                );

            CompileAndVerify(compilation, expectedOutput: "23True");
        }
```

{"Unexpected value 'DiscardExpression' of type 'Microsoft.CodeAnalysis.CSharp.BoundKind'"}
&gt;	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitExpressionCore(Microsoft.CodeAnalysis.CSharp.BoundExpression expression, bool used) Line 314	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitExpression(Microsoft.CodeAnalysis.CSharp.BoundExpression expression, bool used) Line 56	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitAddressOfTempClone(Microsoft.CodeAnalysis.CSharp.BoundExpression expression) Line 194	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitAddress(Microsoft.CodeAnalysis.CSharp.BoundExpression expression, Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.AddressKind addressKind) Line 117	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitArgument(Microsoft.CodeAnalysis.CSharp.BoundExpression argument, Microsoft.CodeAnalysis.RefKind refKind) Line 584	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitArguments(System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.CSharp.BoundExpression&gt; arguments, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol&gt; parameters) Line 759	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitCallExpression(Microsoft.CodeAnalysis.CSharp.BoundCall call, Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.UseKind useKind) Line 1488	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitExpressionCore(Microsoft.CodeAnalysis.CSharp.BoundExpression expression, bool used) Line 92	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitExpressionCoreWithStackGuard(Microsoft.CodeAnalysis.CSharp.BoundExpression expression, bool used) Line 72	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitExpression(Microsoft.CodeAnalysis.CSharp.BoundExpression expression, bool used) Line 60	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitStatement(Microsoft.CodeAnalysis.CSharp.BoundStatement statement) Line 40	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitStatementAndCountInstructions(Microsoft.CodeAnalysis.CSharp.BoundStatement statement) Line 99	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitSequencePointStatement(Microsoft.CodeAnalysis.CSharp.BoundSequencePoint node) Line 342	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitStatement(Microsoft.CodeAnalysis.CSharp.BoundStatement statement) Line 32	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitStatements(System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.CSharp.BoundStatement&gt; statements) Line 639	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitBlock(Microsoft.CodeAnalysis.CSharp.BoundBlock block) Line 616	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitStatement(Microsoft.CodeAnalysis.CSharp.BoundStatement statement) Line 24	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitStatementList(Microsoft.CodeAnalysis.CSharp.BoundStatementList list) Line 107	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitStatement(Microsoft.CodeAnalysis.CSharp.BoundStatement statement) Line 44	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.GenerateImpl() Line 248	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.Generate() Line 183	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.MethodCompiler.GenerateMethodBody(Microsoft.CodeAnalysis.CSharp.Emit.PEModuleBuilder moduleBuilder, Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol method, int methodOrdinal, Microsoft.CodeAnalysis.CSharp.BoundStatement block, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.CodeGen.LambdaDebugInfo&gt; lambdaDebugInfo, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.CodeGen.ClosureDebugInfo&gt; closureDebugInfo, Microsoft.CodeAnalysis.CSharp.StateMachineTypeSymbol stateMachineTypeOpt, Microsoft.CodeAnalysis.CodeGen.VariableSlotAllocator variableSlotAllocatorOpt, Microsoft.CodeAnalysis.DiagnosticBag diagnostics, Microsoft.CodeAnalysis.CodeGen.DebugDocumentProvider debugDocumentProvider, Microsoft.CodeAnalysis.CSharp.ImportChain importChainOpt, bool emittingPdb, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.CodeGen.SourceSpan&gt; dynamicAnalysisSpans) Line 1339	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethod(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol methodSymbol, int methodOrdinal, ref Microsoft.CodeAnalysis.CSharp.Binder.ProcessedFieldInitializers processedInitializers, Microsoft.CodeAnalysis.CSharp.SynthesizedSubmissionFields previousSubmissionFields, Microsoft.CodeAnalysis.CSharp.TypeCompilationState compilationState) Line 1109	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol containingType) Line 434	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedTypeAsTask.AnonymousMethod__0() Line 324	C#

</Description>
        <CreatedDate>10/05/2017</CreatedDate>
        <ClosedDate>18/05/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Expressions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Invocation.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Query.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Statements.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/BoundExpression.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/BoundObjectCreationExpression.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/Constructors.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/Expression.cs</File>
      <File>src/Compilers/CSharp/Portable/CodeGen/Optimizer.cs</File>
      <File>src/Compilers/CSharp/Portable/Compiler/MethodBodySynthesizer.cs</File>
      <File>src/Compilers/CSharp/Portable/Compiler/MethodCompiler.cs</File>
      <File>src/Compilers/CSharp/Portable/Generated/BoundNodes.xml.Generated.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/AsyncRewriter/AwaitExpressionSpiller.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/LambdaRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_AnonymousObjectCreation.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_BinaryOperator.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_Call.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_CompoundAssignmentOperator.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_Conversion.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_IndexerAccess.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_Literal.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_ObjectCreationExpression.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_TupleCreationExpression.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_UnaryOperator.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/MethodToClassRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/SyntheticBoundNodeFactory.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedEntryPointSymbol.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Diagnostics/OperationAnalyzerTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IArgument.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_InvalidExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/OutVarTests.cs</File>
      <File>src/Compilers/Test/Utilities/CSharp/CSharpTestBase.cs</File>
      <File>src/Compilers/Test/Utilities/CSharp/SemanticModelTestBase.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Source/ExpressionCompiler/CompilationContext.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Source/ExpressionCompiler/Rewriters/LocalDeclarationRewriter.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>19211</IssueID>
    <Title>Don't run naming rules on symbols with no name</Title>
    <Description>Fixes #19106

Ask Mode
=======

**Customer scenario**: The customer has broken code such that there's a declared symbol with no name ("interface" with no name), and the naming style analyzer throws exceptions into the error list.

**Bugs this fixes:** #19106

**Workarounds, if any** No reasonable ones.

**Risk**: Very low. It's a very simple empty string check, and no other features depend on this.

**Risk**: Very low. It's a very simple empty string check.

**Performance impact**: Very low. It's a very simple empty string check.

**Is this a regression from a previous update?** No

**Root cause analysis:** A missed scenario. Unit tests are added.

**How was the bug found?** Dogfooding</Description>
    <CreatedDate>03/05/2017</CreatedDate>
    <ClosedDate>08/05/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>19106</IssueID>
        <Title>Naming Styles fantastic failure in broken code.</Title>
        <Description>```c#
namespace Microsoft.CodeAnalysis.Host
{
    /// &lt;summary&gt;
    /// This service allows you to persist information relative to solution, projects and documents.
    /// &lt;/summary&gt;
    public interface IPersistentStorageService : IWorkspaceService
    {
        IPersistentStorage GetStorage(Solution solution);
    }

    internal interface 
}
```

Note hte unterminated interface.  First, observe the following suggestion tag span:

![image](https://cloud.githubusercontent.com/assets/4564579/25547764/ffbaf9fa-2c1d-11e7-9d89-910d8538e07b.png)

Next, observe the totally broken suggestion:

![image](https://cloud.githubusercontent.com/assets/4564579/25547771/087da114-2c1e-11e7-8ca5-acdbb18fd7fd.png)


Note: that "IHost" is being picked because the *namespace* we're contained in ends with "Host".</Description>
        <CreatedDate>28/04/2017</CreatedDate>
        <ClosedDate>08/05/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19106</IssueID>
        <Title>Naming Styles fantastic failure in broken code.</Title>
        <Description>```c#
namespace Microsoft.CodeAnalysis.Host
{
    /// &lt;summary&gt;
    /// This service allows you to persist information relative to solution, projects and documents.
    /// &lt;/summary&gt;
    public interface IPersistentStorageService : IWorkspaceService
    {
        IPersistentStorage GetStorage(Solution solution);
    }

    internal interface 
}
```

Note hte unterminated interface.  First, observe the following suggestion tag span:

![image](https://cloud.githubusercontent.com/assets/4564579/25547764/ffbaf9fa-2c1d-11e7-9d89-910d8538e07b.png)

Next, observe the totally broken suggestion:

![image](https://cloud.githubusercontent.com/assets/4564579/25547771/087da114-2c1e-11e7-8ca5-acdbb18fd7fd.png)


Note: that "IHost" is being picked because the *namespace* we're contained in ends with "Host".</Description>
        <CreatedDate>28/04/2017</CreatedDate>
        <ClosedDate>08/05/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/NamingStyles/NamingStylesTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/NamingStyles/NamingStylesTests_OptionSets.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/Analyzers/NamingStyleDiagnosticAnalyzerBase.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>19164</IssueID>
    <Title>support CasePatternSwitchLabel in StatementSyntaxComparer</Title>
    <Description>**Customer scenario**

Variables declared by patterns within switch statements are matched incorrectly by StatementSyntaxComparer. Fixing this. Have to add one more pass for the matcher. It does not affect the performance. However, it would be nice to re-consider this. Created #19163.

**Bugs this fixes:**

Fixes #18970

**Workarounds, if any**

**Risk**

Low

**Performance impact**
Low 

**Is this a regression from a previous update?**

**Root cause analysis:**

How did we miss it?  What tests are we adding to guard against it in the future?

**How was the bug found?**

Planned</Description>
    <CreatedDate>02/05/2017</CreatedDate>
    <ClosedDate>16/05/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>19163</IssueID>
        <Title>Microsoft.CodeAnalysis.Differencing.Match.ComputeMatchForLabel performance and maintainability improvements</Title>
        <Description>The Microsoft.CodeAnalysis.Differencing.Match.ComputeMatchForLabel method attempts to approximate an O(N^2) matching algorithm with multiple passes with difference distance thresholds. It is expected that those passes are often executed within O(N). However, it is not guaranteed and, O(N^2) still happens often.

Moreover, it is observed that:
1. Passes perform the same calculations multiple times. We can fix this by saving information between passes.
2. Solving some matching issues involve maintaining the set of thresholds. See #18970. This looks fragile.</Description>
        <CreatedDate>02/05/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>18970</IssueID>
        <Title>support CasePatternSwitchLabel in StatementSyntaxComparer </Title>
        <Description>related to #17991

Consider the following code changes:
```
            var src1 = @"
 switch(shape)
 {
     case Circle circle: return 1;
     default: return 4;
 }
 ";
 
             var src2 = @"
 switch(shape)
 {
     case Circle c: return 1;
     case Point p: return 0;
     default: return 4;
 }
 ";
```

See RudeEditStatementTests
**Expected:** 
MatchingPairs should contain "circle" vs."c".

**Actual:**
MatchingPairs contain "circle" vs. "p".

</Description>
        <CreatedDate>25/04/2017</CreatedDate>
        <ClosedDate>16/05/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/EditAndContinue/RudeEditStatementTests.cs</File>
      <File>src/Features/CSharp/Portable/EditAndContinue/StatementSyntaxComparer.cs</File>
      <File>src/Workspaces/Core/Portable/Differencing/Match.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>19126</IssueID>
    <Title>Avoid allocations due to use of Keys/Values instead of GetEnumerator</Title>
    <Description>`ImmutableDictionary&lt;TKey, TValue&gt;` provides a non-allocating implementation of `GetEnumerator()`, but does not offer non-allocating implementations of the `Keys` or `Values` properties (dotnet/corefx#249 and linked issues). This pull request adds a `Deconstruct` extension method for `KeyValuePair&lt;TKey, TValue&gt;`, leveraging a new C# feature to provide almost identical use-site code for these properties without actually incurring the allocation overhead.

:memo: This pull request builds on the change in #19125 to avoid merge conflicts (~~the first commit in the branch overlaps~~) (edit: no longer applies).

## Ask Mode

**Customer scenario**

No observable changes.

* Use `GetEnumerator()` instead of `Keys` where applicable
* Use `GetEnumerator()` instead of `Values` where applicable
* Add a `Deconstruct` extension method so the above changes can be implemented with minimal changes to the actual code structure

**Bugs this fixes:**

N/A

**Workarounds, if any**

None needed.

**Risk**

Low (no behavior changes).

**Performance impact**

Performance is improved by eliminating unnecessary allocations.

**Is this a regression from a previous update?**

No.

**Root cause analysis:**

Missed during code review?

**How was the bug found?**

Internal code review.
</Description>
    <CreatedDate>29/04/2017</CreatedDate>
    <ClosedDate>08/05/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>249</IssueID>
        <Title>Fix IDE diagnostics/code fix test framework to use DiagnosticAnalyzerService to compute diagnostics rather than DiagnosticAnalyzerDriver</Title>
        <Description>Ported from TFS WorkItem: &lt;b&gt;1114332&lt;/b&gt;

---

&lt;p&gt;Our test framework for IDE diagnostics and fixes tests uses DiagnosticAnalyzerDriver directly to compute diagnostics. However, this in turn means that we don’t exercise the end-to-end test path of going via the DiagnosticAnalyzerService. Lot of recent bugs&amp;nbsp;is a case where DiagnosticAnalyzerDriver does the right thing, but it’s caller&amp;nbsp;has a bug in filtering logic&amp;nbsp;and we end up with missing or wrong diagnostics in error list OR missing code fixes due to filtered diagnostics in IDE, though the same test passes fine with our unit test framework.&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;I guess we need to fix up at least&amp;nbsp;&lt;a id=db7d18e25e2715bb class=t href="http://index/Roslyn.Services.Editor.UnitTests/R/db7d18e25e2715bb.html"&gt;&lt;u&gt;&lt;font color="#0066cc"&gt;DiagnosticProviderTestUtilities&lt;/font&gt;&lt;/u&gt;&lt;/a&gt; type&lt;a href="http://index/Roslyn.Services.Editor.UnitTests/R/db7d18e25e2715bb.html"&gt;,&lt;/a&gt; not sure if there are other places too&lt;/p&gt;

---

&lt;!---
@huboard:{"order":326.999755859375,"milestone_order":249,"custom_state":""}
--&gt;
</Description>
        <CreatedDate>05/02/2015</CreatedDate>
        <ClosedDate>18/03/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19125</IssueID>
        <Title>Avoid inefficient use of ContainsKey</Title>
        <Description>## Ask Mode

**Customer scenario**

No observable changes.

* Use `TryGetValue` instead of `ContainsKey`&amp;rarr;indexer
* Use `Remove` instead of `ContainsKey`&amp;rarr;`Remove`
* Use `SetItem` instead of `ContainsKey`&amp;rarr;`Remove`&amp;rarr;`Add`

**Bugs this fixes:**

N/A

**Workarounds, if any**

None needed.

**Risk**

Low (no behavior changes).

**Performance impact**

Performance is improved by eliminating duplicated dictionary operations.

**Is this a regression from a previous update?**

No.

**Root cause analysis:**

Missed during code review.

**How was the bug found?**

Internal code review.
</Description>
        <CreatedDate>29/04/2017</CreatedDate>
        <ClosedDate>03/05/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Imports.cs</File>
      <File>src/Compilers/Core/Portable/DiagnosticAnalyzer/AnalysisState.cs</File>
      <File>src/Compilers/Core/Portable/DiagnosticAnalyzer/AnalyzerFileReference.cs</File>
      <File>src/Compilers/Core/Portable/InternalUtilities/KeyValuePair.cs</File>
      <File>src/EditorFeatures/Core/Tagging/AbstractAsynchronousTaggerProvider.TagSource_ProduceTags.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/AbstractHostDiagnosticUpdateSource.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/EngineV2/DiagnosticIncrementalAnalyzer.StateManager.HostStates.cs</File>
      <File>src/Features/Core/Portable/SolutionCrawler/AggregateIncrementalAnalyzer.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/TableDataSource/Suppression/VisualStudioSuppressionFixService.cs</File>
      <File>src/Workspaces/Core/Portable/CodeFixes/FixAllOccurrences/FixAllLogger.cs</File>
      <File>src/Workspaces/Core/Portable/Diagnostics/Extensions.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/Solution/ProjectState.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/Solution/SolutionState.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>19121</IssueID>
    <Title>Removing zero initialization of locals upon entering a scope. (for locals captured by a local function).</Title>
    <Description>Fixes :#19119

While working on a blog article about Local Functions, I noticed a codegen artifact whose purpose I could not quite explain. We are zeroing out variables when entering a scope if the variables happen to be captured in a struct closure. 

See: bug #19119

The reason why this is happening is likely because the behavior was copied from the older codepath when closure is a class and we do have to `new` a new instance. We do not need to `new` the struct though.  
The code does not really create a new instance. It only clears the old state, which is not observable anyways by the guarantees provided by the Definite Assignment Analysis. 

== Risk

The risk is low.

If this zero-out is observable, we have a much bigger problem. It would indicate a Definite Assignment Analysis failure.

== Performance impact

We are removing redundant code.
In simple cases it is removed by the JIT as well, so we are mostly just making the IL a bit cleaner.

I could imagine that in more complicated cases - bigger display structs or a JIT that is not as smart, zeroing out would incur run-time penalties.

== Is this a regression from a previous update?

No. We had that redundancy since we have shipped the feature.</Description>
    <CreatedDate>29/04/2017</CreatedDate>
    <ClosedDate>02/05/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>19119</IssueID>
        <Title>Should not zero-out locals when entering a scope, regardless if lifted in a struct.</Title>
        <Description>The whole purpose of Definite Assignment Analysis is to ensure that uninitialized locals cannot be observed. That allows us to not zero-initialize locals when entering a scope because the uninitialized/previous state cannot be observed. 

It appears we do zero-initialization when locals happen to be captured in a display struct because of use in Local Functions.  It seems to be a remnant of frame allocation code that is needed in a case where the frame is a class.
We should not do this when frame is a struct. It is redundant. 

NOTE: we do not do the redundant zeroing for async struct captures. The problem is specific to Local Functions.

</Description>
        <CreatedDate>29/04/2017</CreatedDate>
        <ClosedDate>02/05/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19119</IssueID>
        <Title>Should not zero-out locals when entering a scope, regardless if lifted in a struct.</Title>
        <Description>The whole purpose of Definite Assignment Analysis is to ensure that uninitialized locals cannot be observed. That allows us to not zero-initialize locals when entering a scope because the uninitialized/previous state cannot be observed. 

It appears we do zero-initialization when locals happen to be captured in a display struct because of use in Local Functions.  It seems to be a remnant of frame allocation code that is needed in a case where the frame is a class.
We should not do this when frame is a struct. It is redundant. 

NOTE: we do not do the redundant zeroing for async struct captures. The problem is specific to Local Functions.

</Description>
        <CreatedDate>29/04/2017</CreatedDate>
        <ClosedDate>02/05/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/LambdaRewriter.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenDynamicTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenLocalFunctionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenRefReturnTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>19114</IssueID>
    <Title>support of C# 7.0 foreach in ENC</Title>
    <Description>**Customer scenario**

Enabling support of C#7.0 foreach statemets by ENC: tuples and deconstructions.
Also verified enabling manually. The only issue I see to consider is when we change tuple to deconstruction (or the opposite) as a foreach variable, it displays a rude edit saying "ENC0060	Adding 'foreach statement' around an active statement will prevent the debug session from continuing." Should we consider fixing this?

**Bugs this fixes:**

Works towards to fix #17891

**Workarounds, if any**

**Risk**
Low

**Performance impact**
Low

**Is this a regression from a previous update?**

**Root cause analysis:**

How did we miss it?  What tests are we adding to guard against it in the future?

**How was the bug found?**
Planned</Description>
    <CreatedDate>28/04/2017</CreatedDate>
    <ClosedDate>04/05/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>7</IssueID>
        <Title>Feature: Parameter Name Aliasing</Title>
        <Description>The human meaning of parameters may vary from method caller's perspective.

It would be useful if the language provides an ability to assign aliases to the parameters.

``` C#
[Alias({second: [secondAndHalf, quarterToThree], first: [Initial]})] 
public static void Member1(string first, string second) { 
  // Here the user will always use the given names: first and second.
  // which means the user cannot use the param by its nickname
  // inside the method scope.
}

private static void Caller1() {
  Member1(secondAndHalf: "secondly, this is not a bad idea after all",
          Initial: "Initially it sounded moot... :)  ");
}

private static void Caller2() {
  Member1(first: "1st",
          quarterToThree: "almost there");
}

private static void Caller3() {
  Member1("one", "two");
}
```

vs. this current approach:

``` c#
public static void Member1(string first, string second) {  }

public static void Member1(string first, string secondAndHalf, string devNull = null) { 
  Member1(first, secondAndHalf);
}
```

Note: the parameter `devNull` may violate [CA1026](http://msdn.microsoft.com/en-us/library/ms182135.aspx), in case of `overridden` methods. On the flip side, setting `devNull` as non-default parameter would yield "unused parameter".

Related / Real world example: https://github.com/madskristensen/WebEssentials2013/pull/380#issuecomment-31402391
</Description>
        <CreatedDate>15/01/2015</CreatedDate>
        <ClosedDate>26/08/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>17891</IssueID>
        <Title>Enable EnC support for C#7 features</Title>
        <Description>- [x] https://github.com/dotnet/roslyn/issues/17896 ENC support for out Var
- [x] https://github.com/dotnet/roslyn/issues/12435 ENC support for pattern matching
- [x] https://github.com/dotnet/roslyn/issues/17991 ENC support for switch
- [x] https://github.com/dotnet/roslyn/issues/5156   ENC support for local functions
- [x] https://github.com/dotnet/roslyn/issues/17681 ENC for expression-bodied methods
- [x] https://github.com/dotnet/roslyn/issues/16960 ENC for out variable declarations
- [x] https://github.com/dotnet/roslyn/issues/12438 ENC improvements for C# 7
- [x] https://github.com/dotnet/roslyn/issues/12436 ENC for Tuples

See also https://github.com/dotnet/roslyn/issues/12438 https://github.com/dotnet/roslyn/issues/12379
</Description>
        <CreatedDate>15/03/2017</CreatedDate>
        <ClosedDate>08/09/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Test/Emit/Emit/EditAndContinue/EditAndContinueTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Emit/EditAndContinue/LocalSlotMappingTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/EditAndContinue/ActiveStatementTests.cs</File>
      <File>src/Features/CSharp/Portable/EditAndContinue/CSharpEditAndContinueAnalyzer.cs</File>
      <File>src/Features/CSharp/Portable/EditAndContinue/StatementSyntaxComparer.cs</File>
      <File>src/Features/Core/Portable/EditAndContinue/AbstractEditAndContinueAnalyzer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>18976</IssueID>
    <Title>Ensure that we get a well formed child IOperation tree even for bound…</Title>
    <Description>… nodes for whom IOperation support is not yet implemented

**Customer scenario**

Due to large number of unimplemented IOperation APIs for new language and existing features, all the IOperation analyzers (such as FXCop analyzers) do not receive any operation callbacks for code containing these features (tuples, string interpolation, query expressions, object and collection initializers, etc.). This causes lot of false positives in the analyzer diagnostics as it doesn't see parameter or field references within such code. Additionally, the analyzers do not report *true* issues in expressions within this language features. This is one of the biggest blocker towards dogfooding the FXCop analyzers.

**Bugs this fixes:**

Fixes #8884

**Workarounds, if any**

Disable the rule or suppress all the false positives. All our three repos consuming the FXCop analyzers (Roslyn, Project system and Roslyn-analyzers) were forced to disable these rules due to extremely large number of false positives.

**Risk**

Low. Proposed fix is to introduce a temporary internal interface `IOperationWithChildren` for bound nodes for which we haven't designed the IOperation APIs or they have missing pieces. This will allow the OperationWalker to walk the descendants of such nodes and make analyzer callbacks and drastically reduce the false positives. This change doesn't modify the publically available IOperation tree or the API, so we should be able to remove it once we have fully designed and implemented IOperation (tracked by #19060)

**Performance impact**

Low. We will now walk additional IOperation nodes and make callbacks, but this is a functional requirement.

**Is this a regression from a previous update?**

No.

**Root cause analysis:**

IOperation based analyzers are still being developed and tested.

**How was the bug found?**

Lots of customer reports about false positives.</Description>
    <CreatedDate>25/04/2017</CreatedDate>
    <ClosedDate>04/05/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>8884</IssueID>
        <Title>IParameterReferenceExpression operation not generated for parameter access in a certain cases</Title>
        <Description>Sample test code:

``` C#
using System;

public class NeatCode
{
    // Used parameter methods
    public void UsedParameterMethod1(Action a)
    {
        Action a2 = new Action(() =&gt;
        {
            a(); // No parameter reference expression operation generated for this access
        });
    }
}
```

This does not repro for VB.
</Description>
        <CreatedDate>18/02/2016</CreatedDate>
        <ClosedDate>23/06/2018</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>19060</IssueID>
        <Title>Remove the IOperationWithChildren interface once we have designed all the IOperation APIs.</Title>
        <Description>
        </Description>
        <CreatedDate>27/04/2017</CreatedDate>
        <ClosedDate>06/09/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/BoundTree/Expression.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/Statement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IFieldReferenceExpression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IIfStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/IOperation/IOperationTests_IParameterReferenceExpression.cs</File>
      <File>src/Compilers/Core/Portable/Operations/IOperationWithChildren.cs</File>
      <File>src/Compilers/Core/Portable/Operations/OperationWalker.cs</File>
      <File>src/Compilers/Test/Utilities/CSharp/SemanticModelTestBase.cs</File>
      <File>src/Test/Utilities/Portable/Compilation/OperationTreeVerifier.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>18784</IssueID>
    <Title>Relax conversion requirements for pattern-matching involving type parameters.</Title>
    <Description>**Customer scenario**

This is a tiny language change for 7.1. See https://github.com/dotnet/csharplang/issues/154.

See #16195 for customer scenario. In short, pattern-matching can give a compile-time error unexpectedly when type parameters are involved. The compiler is correct to give these errors according to the spec, but we wish to relax the language to make it legal.

**Bugs this fixes:**

Fixes #16195

**Workarounds, if any**

Cast the expression being matched to `object`.

**Risk**

Low. This has little impact on existing code.

**Performance impact**

None expected.

**Is this a regression from a previous update?**

No.
</Description>
    <CreatedDate>18/04/2017</CreatedDate>
    <ClosedDate>08/05/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>16195</IssueID>
        <Title>Generic expression of a derived type cannot be handled by a pattern</Title>
        <Description>**Version Used**: 
Microsoft Visual Studio Professional 2017 RC
Version 15.0.26014.0 D15REL
Microsoft .NET Framework
Version 4.6.01586
Visual C# Compiler version 2.0.0.61213

**Steps to Reproduce**:

    public class Packet
    {
    }

    public class KeepalivePacket : Packet
    {
    }

    public void Send&lt;T&gt;(T packet)
        where T : Packet
    {
        if (packet is KeepalivePacket keepalive)
        {
            // Do stuff with keepalive
        }

        switch (packet)
        {
            case KeepalivePacket keepalivePacket:
                // Do stuff with keepalivePacket
                break;
        }
    }

I get a compilation error for both the if statement and case statement. 

&gt; CS8121: An expression of type T cannot be handled by a pattern of type KeepalivePacket

The code compiles successfully if the type is _not_ a derived type of `Packet` (ie. `packet is Packet keepalive` or `packet is object keepalive` works fine).

The code compiles without error if I first cast the parameter to `object`.

    if ((object)packet is KeepalivePacket keepalive)
    {
        // This works
    }

I couldn't find any mention of unsupported pattern matching with generic parameters/variables in the design notes/blog posts. 

Is this expected to fail? Does this compilation error need a more informative message?

Roslyn is recommending pattern matching for the following code with **IDE0019**. Applying the code fix to the following code results in the compilation error above.

    var keepalive = packet as KeepalivePacket;
    if (keepalive != null)
    {
        // Do stuff with keepalive
    }

Does **IDE0019** need to be updated to not apply when the variable/parameter is generic?</Description>
        <CreatedDate>03/01/2017</CreatedDate>
        <ClosedDate>08/05/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>16195</IssueID>
        <Title>Generic expression of a derived type cannot be handled by a pattern</Title>
        <Description>**Version Used**: 
Microsoft Visual Studio Professional 2017 RC
Version 15.0.26014.0 D15REL
Microsoft .NET Framework
Version 4.6.01586
Visual C# Compiler version 2.0.0.61213

**Steps to Reproduce**:

    public class Packet
    {
    }

    public class KeepalivePacket : Packet
    {
    }

    public void Send&lt;T&gt;(T packet)
        where T : Packet
    {
        if (packet is KeepalivePacket keepalive)
        {
            // Do stuff with keepalive
        }

        switch (packet)
        {
            case KeepalivePacket keepalivePacket:
                // Do stuff with keepalivePacket
                break;
        }
    }

I get a compilation error for both the if statement and case statement. 

&gt; CS8121: An expression of type T cannot be handled by a pattern of type KeepalivePacket

The code compiles successfully if the type is _not_ a derived type of `Packet` (ie. `packet is Packet keepalive` or `packet is object keepalive` works fine).

The code compiles without error if I first cast the parameter to `object`.

    if ((object)packet is KeepalivePacket keepalive)
    {
        // This works
    }

I couldn't find any mention of unsupported pattern matching with generic parameters/variables in the design notes/blog posts. 

Is this expected to fail? Does this compilation error need a more informative message?

Roslyn is recommending pattern matching for the following code with **IDE0019**. Applying the code fix to the following code results in the compilation error above.

    var keepalive = packet as KeepalivePacket;
    if (keepalive != null)
    {
        // Do stuff with keepalive
    }

Does **IDE0019** need to be updated to not apply when the variable/parameter is generic?</Description>
        <CreatedDate>03/01/2017</CreatedDate>
        <ClosedDate>08/05/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Patterns.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/SubsumptionDiagnosticBuilder.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/DecisionTree.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/DecisionTreeBuilder.cs</File>
      <File>src/Compilers/CSharp/Portable/CSharpResources.Designer.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/ErrorCode.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/MessageID.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_PatternSwitchStatement.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_Patterns.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/SyntheticBoundNodeFactory.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/SwitchTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/PDB/PDBTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternSwitchTests.cs</File>
      <File>src/Compilers/Test/Utilities/CSharp/TestOptions.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/UpgradeProject/UpgradeProjectTests.cs</File>
      <File>src/Features/CSharp/Portable/UpgradeProject/CSharpUpgradeProjectCodeFixProvider.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>17692</IssueID>
    <Title>Refine syntax error recovery for partial code to not interfere with non-error code.</Title>
    <Description>Related to #15885
Fixes #17683

@CyrusNajmabadi Would you like to have a look at this before I send it out for review?
</Description>
    <CreatedDate>10/03/2017</CreatedDate>
    <ClosedDate>15/03/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>15885</IssueID>
        <Title>Parse incomplete code differently to better reflect user intent.</Title>
        <Description>Fixes https://github.com/dotnet/roslyn/issues/15881

This is a port of a parsing strategy we took in TypeScript to better deal with code as the user is typing it.  Note that this is a change in how we parse code in *error*, and it involves heuristics to make the tree better match the user intent.  The code in question is code like:

```c#
Task.
await Task.Delay(...);
```

Today, the C# parser eagerly parses this as a local declaration of the form "Task.await Task".  i.e. the "Type" is "Task.await" and the VariableDeclarator is "Task".  This clearly doesn't match what the user intends, and it messes up higher layers of the stack.

Specifically, because "Task." is a QualifiedName, that changes how we treat it (when it really should be a MemberAccessExpression).  Similarly, because it looks like we're declaring a local called 'Task', we introduce a bogus LocalSymbol into scope, which messes up binding of names like "Task" (it finds the local instead of the type).

The fix is to tweak how we parse here.  We specifically look for the pattern:

```
Id dot new-line
Id id
```

And we do not think of it as a LocalDeclaration *unless* we see a following token that more definitely demonstrates that it is local-variable.  i.e.

```
X.
Y z;
```

In this case, there is no syntax error, so we have to accept this code as being a local variable declaration. 

</Description>
        <CreatedDate>14/12/2016</CreatedDate>
        <ClosedDate>19/12/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>17683</IssueID>
        <Title>Compiler sensitive to newline in parsing an expression</Title>
        <Description>In VS2017 (C# 7), the compiler now rejects the following. Eliminating the newline before `MinValue` allows it to compile. This code compiled in previous versions of the product.

See also our [internal VSO bug](https://devdiv.visualstudio.com/0bdbc590-a062-4c3f-b0f6-9383f67865ee/_workitems?id=393733&amp;_a=edit) tracking this and the [community feedback page](https://developercommunity.visualstudio.com/content/problem/25465/c-linq-expression-doesnt-compile-in-vs2017.html).

``` c#
using System;
using System.Linq;

namespace ConsoleApp1
{
    class Program
    {
        static void Main(string[] args)
        {
            var a = from t in Enumerable.Range(0, 10)
                    where
                    t == Int32.
                    MinValue
                    select t;
        }
    }
}
```
</Description>
        <CreatedDate>10/03/2017</CreatedDate>
        <ClosedDate>15/03/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Parser/LanguageParser.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/ExpressionParsingTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>17113</IssueID>
    <Title>Diagnostics from Parse Options</Title>
    <Description>Fixes #15900.
Fixes #15797.
Reverts #15798.</Description>
    <CreatedDate>13/02/2017</CreatedDate>
    <ClosedDate>14/03/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>15900</IssueID>
        <Title>Change how pre-processor symbols are verified</Title>
        <Description>Today the `CSharpParseOptions` type is inconsistent with how it verifies pre-processor symbols:

- The constructor will verify all symbols are valid identifiers and throw an exception when they are not. 
- The `WithPreProcessorSymbols` method does no verification. 

This inconsistency is bad for bot the compiler and consumers of the compiler API.  After some discussion the compiler team decided to change the API in the following way:

- The `CSharpParseOptions` type will never throw on pre-processor symbols that are invalid identifiers.
- Diagnostics will be produced for invalid identifiers in the pre-processor symbols

As a part of fixing this we should examine uses like in the following PR to see if they need to be cleaned up after the change.  

https://github.com/dotnet/roslyn/pull/15798

</Description>
        <CreatedDate>14/12/2016</CreatedDate>
        <ClosedDate>14/03/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>15797</IssueID>
        <Title>CSharpParseOptions doesn't validate preprocessor symbols in some entry points</Title>
        <Description>CSharpParseOptions validate given preprocessor names in ctor.

```csharp
public CSharpParseOptions(
            LanguageVersion languageVersion = LanguageVersion.Default,
            DocumentationMode documentationMode = DocumentationMode.Parse,
            SourceCodeKind kind = SourceCodeKind.Regular,
            IEnumerable&lt;string&gt; preprocessorSymbols = null)
            : this(languageVersion, documentationMode, kind, preprocessorSymbols.ToImmutableArrayOrEmpty())
        {
            // We test the mapped value, LanguageVersion, rather than the parameter, languageVersion,
            // which has not had "Latest" mapped to the latest version yet.
            if (!LanguageVersion.IsValid())
            {
                throw new ArgumentOutOfRangeException(nameof(languageVersion));
            }

            if (!kind.IsValid())
            {
                throw new ArgumentOutOfRangeException(nameof(kind));
            }

            if (preprocessorSymbols != null)
            {
                foreach (var preprocessorSymbol in preprocessorSymbols)
                {
                    if (!SyntaxFacts.IsValidIdentifier(preprocessorSymbol))
                    {
                        throw new ArgumentException(nameof(preprocessorSymbol));
                    }
                }
            }
        }
```

but, there are other API to update those preprocessor and those doesn't validate preprocessor which lead to invalidate preprocessor names in parse options.

for example, this (WithPreprocessorSymbols) doesnt validate preprocessor names.

```csharp
public CSharpParseOptions WithPreprocessorSymbols(ImmutableArray&lt;string&gt; symbols)
        {
            if (symbols.IsDefault)
            {
                symbols = ImmutableArray&lt;string&gt;.Empty;
            }

            if (symbols.Equals(this.PreprocessorSymbols))
            {
                return this;
            }

            return new CSharpParseOptions(this) { PreprocessorSymbols = symbols };
        }
```

this is causing serialization to fail since csharp parse option has a way for user to set preprocessor name that is not valid.</Description>
        <CreatedDate>09/12/2016</CreatedDate>
        <ClosedDate>17/02/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>15798</IssueID>
        <Title>fix watson bug for OOP serialization</Title>
        <Description>**Customer scenario**

Customer has preprocessor defined for his csproj project which is actually invalid preprocessor

**Bugs this fixes:** 
https://devdiv.visualstudio.com/DevDiv/_workitems/edit/295512

**Workarounds, if any**

no workaround

**Risk**

no risk. IDE already allow to set such preprocessor on CSharpParseOptions.

**Performance impact**

N/A

**Is this a regression from a previous update?**

no

**Root cause analysis:**

root issue is this
https://github.com/dotnet/roslyn/issues/15797

but regardless, if such option exist, then serialization should be able to clone it over RPC.

**How was the bug found?**

Watson
</Description>
        <CreatedDate>09/12/2016</CreatedDate>
        <ClosedDate>09/12/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/CSharpParseOptions.cs</File>
      <File>src/Compilers/CSharp/Portable/CSharpResources.Designer.cs</File>
      <File>src/Compilers/CSharp/Portable/CommandLine/CSharpCommandLineParser.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/CSharpCompilation.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/ErrorCode.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/MessageProvider.cs</File>
      <File>src/Compilers/CSharp/Test/CommandLine/CommandLineTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Diagnostics/GetDiagnosticsTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/ScriptSemanticsTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/CSharpParseOptionsTests.cs</File>
      <File>src/Compilers/Core/CodeAnalysisTest/CommonParseOptionsTests.cs</File>
      <File>src/Compilers/Core/Portable/Compilation/ParseOptions.cs</File>
      <File>src/Compilers/Core/Portable/Diagnostic/CommonMessageProvider.cs</File>
      <File>src/Compilers/Core/Portable/SourceCodeKind.cs</File>
      <File>src/Test/Utilities/Portable/Mocks/TestMessageProvider.cs</File>
      <File>src/Test/Utilities/Portable/ReflectionAssert.cs</File>
      <File>src/Workspaces/CSharp/Portable/Execution/CSharpOptionsSerializationService.cs</File>
      <File>src/Workspaces/CoreTest/WorkspaceTests/MSBuildWorkspaceTestBase.cs</File>
      <File>src/Workspaces/CoreTest/WorkspaceTests/MSBuildWorkspaceTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>17404</IssueID>
    <Title>Ensure script compilations properly inherit return type from first compilation</Title>
    <Description>This fixes #17403 which prevents Xamarin Workbooks from moving to the upstream Roslyn 2.0 NuGet. Related to, and expands upon, #8507 _(Compilation: use System.Object from target corlib)_.

### Before

&lt;img width="628" alt="screen shot 2017-02-26 at 3 44 52 pm" src="https://cloud.githubusercontent.com/assets/49539/23343577/cee69cf6-fc3b-11e6-9537-0c6ff8bd1f23.png"&gt;

### After

&lt;img width="628" alt="screen shot 2017-02-26 at 3 51 05 pm" src="https://cloud.githubusercontent.com/assets/49539/23343580/d6d61748-fc3b-11e6-9c25-b0f2c7695e21.png"&gt;

</Description>
    <CreatedDate>26/02/2017</CreatedDate>
    <ClosedDate>27/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>17403</IssueID>
        <Title>Script compilations created from a previous compilation have incorrect return type</Title>
        <Description>We are now finally able to use the Roslyn 2.0 NuGet for Xamarin Workbooks, which means I can finally leverage my work for [supporting compilations against a target (not host) corlib](https://github.com/dotnet/roslyn/pull/8507).

Unfortunately the tests I wrote for that fix were not extensive enough to catch an issue where subsequent compilations result in an implicit reference to host corlib and not the target corlib.

This is due to the implementation of `ScriptCompilationInfo.ReturnType`, which was desired to never return `null`:

```csharp
public Type ReturnType =&gt; ReturnTypeOpt ?? typeof(object);
```

I did not catch all the places in Roslyn that were using `ReturnType` but should now be using `ReturnTypeOpt`:

* `CSharpScriptCompilationInfo.WithPreviousScriptCompilation`
* `CSharpCompilation.WithScriptCompilationInfo`
* `VisualBasicScriptCompilationInfo.WithPreviousScriptCompilation`
* `VisualBasicCompilation.WithScriptCompilationInfo`

This is how the bug ends up manifesting in Workbooks:

&lt;img width="628" alt="screen shot 2017-02-26 at 3 44 52 pm" src="https://cloud.githubusercontent.com/assets/49539/23343501/99d63ee6-fc3a-11e6-898d-0511b0b706bc.png"&gt;
</Description>
        <CreatedDate>26/02/2017</CreatedDate>
        <ClosedDate>27/02/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>8507</IssueID>
        <Title>Compilation: use System.Object from target corlib</Title>
        <Description>When creating a script compilation without an explicit return type, `System.Object` was being resolved via reflection from the host.

This resulted in an implicit dependency of a script compilation on the host corlib, even if a different corlib was specified as a reference for the compilation (e.g. Xamarin.iOS).

Fix this by using `System.Object` as defined in the corlib resolved for the compilation.

This fixes https://github.com/dotnet/roslyn/issues/8506.
</Description>
        <CreatedDate>09/02/2016</CreatedDate>
        <ClosedDate>02/06/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Compilation/CSharpCompilation.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/CSharpScriptCompilationInfo.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Compilation/CompilationAPITests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>17372</IssueID>
    <Title>Avoid deadlock on solution close with linked files</Title>
    <Description>Fixes #17305
Fixes
https://devdiv.visualstudio.com/0bdbc590-a062-4c3f-b0f6-9383f67865ee/_workitems?id=388328&amp;_a=edit

Escrow Template
==========
**Customer scenario** I'm not exactly sure how to reproduce it, but multiple reports point to the same problem. When closing a solution, we close a linked file, which causes the running document table to tell us about a context change, which deadlocks. I believe it can hang **before saving the solution**.

**Bugs this fixes:** 

#17305
https://devdiv.visualstudio.com/0bdbc590-a062-4c3f-b0f6-9383f67865ee/_workitems?id=388328&amp;_a=edit

**Workarounds, if any**: Close all open documents before closing the solution.

**Risk**: Fairly low. We avoid taking a lock when the lock has already been taken for us.

**Performance impact**: Essentially none. No allocations or complexity changes. 

**Is this a regression from a previous update?**: Unknown, but probably. I can't repro it, but the reports seem to be on RC4+ builds.

**Root cause analysis:** I don't know what regressed it. This should have been fixed in https://github.com/dotnet/roslyn/pull/16889, but I missed the linked files case. Shared Projects and linked files are now both handled appropriately.

**How did we miss it?**  I didn't think there were any additional callers of a particular overload of OnDocumentContextUpdated.

**How was the bug found?** Customer reports and dogfooding.</Description>
    <CreatedDate>24/02/2017</CreatedDate>
    <ClosedDate>28/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>17305</IssueID>
        <Title>Deadlock in VS while unloading project at OnDocumentContextUpdated</Title>
        <Description>**Version Used**: d15rel/15.0.26221.0, Roslyn commit: 38afa69825db300e58aa6416dbb2c14ab340da7f

**Steps to Reproduce**:
(this seems to be very intermittant and probably not reproduce, please see attached dump)
1. Open solution with several projects and several open files
2. Close VS

**Expected Behavior**:
VS exits

**Actual Behavior**:
VS freezes at "Unloading project 6 of 31: [Project Name]"

**Callstack**:
```
 	mscorlib.dll!System.Threading.Monitor.Wait(object obj, int millisecondsTimeout, bool exitContext) Line 203	C#
 	mscorlib.dll!System.Threading.SemaphoreSlim.WaitUntilCountOrTimeout(int millisecondsTimeout, uint startTime, System.Threading.CancellationToken cancellationToken) Line 469	C#
 	mscorlib.dll!System.Threading.SemaphoreSlim.Wait(int millisecondsTimeout, System.Threading.CancellationToken cancellationToken) Line 439	C#
&gt;	Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Workspace.OnDocumentContextUpdated(Microsoft.CodeAnalysis.DocumentId documentId, Microsoft.CodeAnalysis.Text.SourceTextContainer container) Line 354	C#
 	Microsoft.VisualStudio.LanguageServices.dll!Microsoft.VisualStudio.LanguageServices.Implementation.ProjectSystem.DocumentProvider.OnHierarchyChanged(uint docCookie, Microsoft.VisualStudio.Shell.Interop.IVsHierarchy pHierOld, uint itemidOld, Microsoft.VisualStudio.Shell.Interop.IVsHierarchy pHierNew, uint itemidNew, bool itemidChanged) Line 547	C#
 	Microsoft.VisualStudio.LanguageServices.dll!Microsoft.VisualStudio.LanguageServices.Implementation.ProjectSystem.DocumentProvider.OnAfterAttributeChangeEx(uint docCookie, uint grfAttribs, Microsoft.VisualStudio.Shell.Interop.IVsHierarchy pHierOld, uint itemidOld, string pszMkDocumentOld, Microsoft.VisualStudio.Shell.Interop.IVsHierarchy pHierNew, uint itemidNew, string pszMkDocumentNew) Line 535	C#
 	Microsoft.VisualStudio.LanguageServices.dll!Microsoft.VisualStudio.LanguageServices.Implementation.ProjectSystem.DocumentProvider.RunningDocTableEventsSink.OnAfterAttributeChangeEx(uint docCookie, uint grfAttribs, Microsoft.VisualStudio.Shell.Interop.IVsHierarchy pHierOld, uint itemidOld, string pszMkDocumentOld, Microsoft.VisualStudio.Shell.Interop.IVsHierarchy pHierNew, uint itemidNew, string pszMkDocumentNew) Line 27	C#

```
See dump at: \\\\mlangfs1\public\pafenelo\Issue17305</Description>
        <CreatedDate>22/02/2017</CreatedDate>
        <ClosedDate>28/02/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>17305</IssueID>
        <Title>Deadlock in VS while unloading project at OnDocumentContextUpdated</Title>
        <Description>**Version Used**: d15rel/15.0.26221.0, Roslyn commit: 38afa69825db300e58aa6416dbb2c14ab340da7f

**Steps to Reproduce**:
(this seems to be very intermittant and probably not reproduce, please see attached dump)
1. Open solution with several projects and several open files
2. Close VS

**Expected Behavior**:
VS exits

**Actual Behavior**:
VS freezes at "Unloading project 6 of 31: [Project Name]"

**Callstack**:
```
 	mscorlib.dll!System.Threading.Monitor.Wait(object obj, int millisecondsTimeout, bool exitContext) Line 203	C#
 	mscorlib.dll!System.Threading.SemaphoreSlim.WaitUntilCountOrTimeout(int millisecondsTimeout, uint startTime, System.Threading.CancellationToken cancellationToken) Line 469	C#
 	mscorlib.dll!System.Threading.SemaphoreSlim.Wait(int millisecondsTimeout, System.Threading.CancellationToken cancellationToken) Line 439	C#
&gt;	Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Workspace.OnDocumentContextUpdated(Microsoft.CodeAnalysis.DocumentId documentId, Microsoft.CodeAnalysis.Text.SourceTextContainer container) Line 354	C#
 	Microsoft.VisualStudio.LanguageServices.dll!Microsoft.VisualStudio.LanguageServices.Implementation.ProjectSystem.DocumentProvider.OnHierarchyChanged(uint docCookie, Microsoft.VisualStudio.Shell.Interop.IVsHierarchy pHierOld, uint itemidOld, Microsoft.VisualStudio.Shell.Interop.IVsHierarchy pHierNew, uint itemidNew, bool itemidChanged) Line 547	C#
 	Microsoft.VisualStudio.LanguageServices.dll!Microsoft.VisualStudio.LanguageServices.Implementation.ProjectSystem.DocumentProvider.OnAfterAttributeChangeEx(uint docCookie, uint grfAttribs, Microsoft.VisualStudio.Shell.Interop.IVsHierarchy pHierOld, uint itemidOld, string pszMkDocumentOld, Microsoft.VisualStudio.Shell.Interop.IVsHierarchy pHierNew, uint itemidNew, string pszMkDocumentNew) Line 535	C#
 	Microsoft.VisualStudio.LanguageServices.dll!Microsoft.VisualStudio.LanguageServices.Implementation.ProjectSystem.DocumentProvider.RunningDocTableEventsSink.OnAfterAttributeChangeEx(uint docCookie, uint grfAttribs, Microsoft.VisualStudio.Shell.Interop.IVsHierarchy pHierOld, uint itemidOld, string pszMkDocumentOld, Microsoft.VisualStudio.Shell.Interop.IVsHierarchy pHierNew, uint itemidNew, string pszMkDocumentNew) Line 27	C#

```
See dump at: \\\\mlangfs1\public\pafenelo\Issue17305</Description>
        <CreatedDate>22/02/2017</CreatedDate>
        <ClosedDate>28/02/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Workspaces/Core/Portable/Workspace/Workspace_Editor.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>17366</IssueID>
    <Title>send servicehub log files along with NFW to help investigate HubClient.RequestServiceAsync issues.</Title>
    <Description>this doesn't change any user experience. but will help us to have more info on figuring out why this happens

[Watson] clr20r3: CLR_EXCEPTION_System.InvalidOperationException_DETOURS_80131509_Microsoft.CodeAnalysis.Workspaces.dll!Roslyn.Utilities.Contract.FailWithReturn[[System.__Canon,_mscorlib]]
(https://devdiv.visualstudio.com/0bdbc590-a062-4c3f-b0f6-9383f67865ee/_workitems?id=386567&amp;projectId=0bdbc590-a062-4c3f-b0f6-9383f67865ee&amp;src=alerts&amp;src-action=summary_id_link&amp;fullScreen=true&amp;_a=edit)

....

currently we identified 3 common cases that lead to the above problem. but we need more info to figure out the root cause of it.

this change let us send those info when this happens.

....

**Customer scenario**

VS suddenly crash while user is using solution with C#/VB projects.

**Bugs this fixes:** 

https://github.com/dotnet/roslyn/issues/17012

this doesn't actually fix the crash, but send more info to help us to fix the issue.

**Workarounds, if any**

turn off OOP through hidden registry key.

**Risk**

when customer hit the issue, now we send more info than before when sending NFW. but since NFW is throttled and not sent on every occurrences of the issue, most of time, should be okay. but when NFW is actually sent, it will take more time.

**Performance impact**

when NFW is actually sent, it will take more time to gather information.

**Is this a regression from a previous update?**

No

**Root cause analysis:**

we have found these 3 common patterns that cause HubClient.RequestServiceAsync to fail. people are tracking each issues separately. but requires more info to track down to root cause. this PR is to gather more data to help investigating the issues below.

#1, “StreamJsonRpc.RemoteInvocationException: Request locate failed with message: Cannot find service module info file '*/codeAnalysisService.servicehub.service.json' in 'C:\Program Files (x86)\Microsoft Visual Studio\2017\Enterprise\Common7\ServiceHub\Services', using discovery services failed: VsixServiceDiscovery: ExternalSettingsManager::GetScopePaths failed to initialize PkgDefManager”
 
 
#2, “StreamJsonRpc.RemoteInvocationException: Request locate failed with message: Cannot find service module info file '*/codeAnalysisService.servicehub.service.json' in 'C:\Program Files (x86)\Microsoft Visual Studio\2017\Enterprise\Common7\ServiceHub\Services', using discovery services failed: VsixServiceDiscovery: connect ENOENT \\?\pipe\a5e4cfe06cbe4adead96a3d5ff65a88d at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)”
 
#3, StreamJsonRpc.RemoteInvocationException: Request locate failed with message: Cannot find service config file 'C:\Users\[UserName]\AppData\Local\Temp\dev50B1.tmp'. at Microsoft.ServiceHub.HostLib.AppDomainIsolationServiceManager.GetDomainKey(ServiceModuleInfo smi) at Microsoft.ServiceHub.HostLib.AppDomainIsolationServiceManager.StartService(ServiceModuleInfo smi) at Microsoft.ServiceHub.HostLib.Host.startService(ServiceModuleInfo smi) at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at System.Runtime.CompilerServices.TaskAwaiter.ValidateEnd(Task task) at StreamJsonRpc.JsonRpc.&lt;InvokeCoreAsync&gt;d__56`1.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification

currently, we have these bugs to track each issues.

388344
[Watson] crash32: HEAP_CORRUPTION_c0000374_heap_corruption!ServiceHub.Host.CLR.x86.exe
https://devdiv.visualstudio.com/DevDiv/_workitems/edit/388344

388327
[Watson] crash32: HEAP_CORRUPTION_ACTIONABLE_BlockNotBusy_DOUBLE_FREE_c0000374_Microsoft.VisualStudio.Settings.15.0.dll!RegistryDetouring::InitializeRegRootHive
https://devdiv.visualstudio.com/DevDiv/_workitems/edit/388327

387392 Lock the app config file in %temp% in volatile pkgdef merge case for the lifetime of VS instance
https://devdiv.visualstudio.com/DevDiv/_workitems/edit/387392

**How was the bug found?**

Watson, customer report.</Description>
    <CreatedDate>24/02/2017</CreatedDate>
    <ClosedDate>27/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>1</IssueID>
        <Title>Initial port and addition of README.md</Title>
        <Description>This is a port of the readme from CodePlex.  Some of the links have been updated to point to locations on GitHub, but many of the links still point back to CodePlex as comparable GitHub locations are currently absent.
</Description>
        <CreatedDate>14/01/2015</CreatedDate>
        <ClosedDate>14/01/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>2</IssueID>
        <Title>Update links in README.md with ported wiki content</Title>
        <Description>
        </Description>
        <CreatedDate>14/01/2015</CreatedDate>
        <ClosedDate>14/01/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>3</IssueID>
        <Title>Add symbol files(.pdb/source) to NuGet packages</Title>
        <Description>It would be nice to be able to step inside Roslyn code when using NuGet packages.

This is nice guide on how to do this:
http://blog.davidebbo.com/2011/04/easy-way-to-publish-nuget-packages-with.html

&lt;!---
@huboard:{"order":6.0}
--&gt;
</Description>
        <CreatedDate>15/01/2015</CreatedDate>
        <ClosedDate>08/11/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/VisualStudio/Core/Def/Implementation/Watson/WatsonReporter.cs</File>
      <File>src/VisualStudio/Core/Next/Remote/ServiceHubRemoteHostClient.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>17294</IssueID>
    <Title>Put Local Function's type parameters in scope within function's signature for the purpose of SemanticModel lookup/binding.</Title>
    <Description>Fixes #16801.
Also fixes #17198.

@dotnet/roslyn-compiler, @agocke Please review.</Description>
    <CreatedDate>22/02/2017</CreatedDate>
    <ClosedDate>28/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>16801</IssueID>
        <Title>SemanticModel.LookupNames/LookupSymbols APIs do not return Local Function type parameters in any place within the function signature</Title>
        <Description>This is a clone of TestMethodParameterAndTypeParameterScope unit-test from src\compilers\csharp\test\semantic\semantics\lookuppositiontests.cs
```
        [Fact]
        public void TestLocalFunctionParameterAndTypeParameterScope()
        {
            var text = @"
class C
`{
    void Test()
    `{
        `void `M`&lt;T&gt;(int x) `{ `}
    `}
`}
";

            var expectedNames = MakeExpectedSymbols(
                Add( //Global
                    "C",
                    "System",
                    "Microsoft"),
                Add( //C
                    "void C.Test()",
                    "System.Boolean System.Object.Equals(System.Object obj)",
                    "System.Boolean System.Object.Equals(System.Object objA, System.Object objB)",
                    "System.Boolean System.Object.ReferenceEquals(System.Object objA, System.Object objB)",
                    "System.Int32 System.Object.GetHashCode()",
                    "System.Object System.Object.MemberwiseClone()",
                    "void System.Object.Finalize()",
                    "System.String System.Object.ToString()",
                    "System.Type System.Object.GetType()"),
                Add("void M&lt;T&gt;(System.Int32 x)"), // Test body
                Add("T"), s_pop, //C.C(int) return type
                Add("T"), //C.C(int) between name and body
                Add("System.Int32 x"), //C.C(int) body
                Combine(s_pop, s_pop), //C.C(int)
                s_pop, // Test body
                s_pop //C
            );

            TestLookupNames(text, expectedNames);
        }
```

```
Test 'Microsoft.CodeAnalysis.CSharp.UnitTests.LookupPositionTests.TestLocalFunctionParameterAndTypeParameterScope' failed:
	Lookup(46) - 'void' in 'void' after 3th '`' - "--&gt;" found but not expected, "++&gt;" expected but not found

Expected:
C,
Microsoft,
System,
System.Boolean System.Object.Equals(System.Object obj),
System.Boolean System.Object.Equals(System.Object objA, System.Object objB),
System.Boolean System.Object.ReferenceEquals(System.Object objA, System.Object objB),
System.Int32 System.Object.GetHashCode(),
System.Object System.Object.MemberwiseClone(),
System.String System.Object.ToString(),
System.Type System.Object.GetType(),
T,
void C.Test(),
void M&lt;T&gt;(System.Int32 x),
void System.Object.Finalize()
Actual:
C,
Microsoft,
System,
System.Boolean System.Object.Equals(System.Object obj),
System.Boolean System.Object.Equals(System.Object objA, System.Object objB),
System.Boolean System.Object.ReferenceEquals(System.Object objA, System.Object objB),
System.Int32 System.Object.GetHashCode(),
System.Object System.Object.MemberwiseClone(),
System.String System.Object.ToString(),
System.Type System.Object.GetType(),
void C.Test(),
void M&lt;T&gt;(System.Int32 x),
void System.Object.Finalize()
Differences:
    C,
    Microsoft,
    System,
    System.Boolean System.Object.Equals(System.Object obj),
    System.Boolean System.Object.Equals(System.Object objA, System.Object objB),
    System.Boolean System.Object.ReferenceEquals(System.Object objA, System.Object objB),
    System.Int32 System.Object.GetHashCode(),
    System.Object System.Object.MemberwiseClone(),
    System.String System.Object.ToString(),
    System.Type System.Object.GetType(),
--&gt; T,
    void C.Test(),
    void M&lt;T&gt;(System.Int32 x),
    void System.Object.Finalize()

Expected: True
Actual:   False
```</Description>
        <CreatedDate>27/01/2017</CreatedDate>
        <ClosedDate>28/02/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>17198</IssueID>
        <Title>MemberSemanticModel.GetDeclaredSymbol(LocalFunctionStatementSyntax shouldn't bind LocalFunctionStatementSyntax</Title>
        <Description>It should work similar to ```GetDeclaredSymbol(VariableDeclaratorSyntax```, which doesn't bind any syntax. </Description>
        <CreatedDate>16/02/2017</CreatedDate>
        <ClosedDate>28/02/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Compilation/MemberSemanticModel.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/LocalFunctionSymbol.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/LocalFunctionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/LookupPositionTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>17260</IssueID>
    <Title>Document that "additional files" are an input for determinism.</Title>
    <Description>Fixes #17121 

@jcouv @jaredpar Please verify that this is what you had in mind for #17121.
</Description>
    <CreatedDate>20/02/2017</CreatedDate>
    <ClosedDate>21/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>17121</IssueID>
        <Title>Compiler does not take all inputs into account for determinism</Title>
        <Description>In discussion about editorconfig today, a number of scenarios were mentioned that we know or suspect are not properly accounted for in determinism:
- additional files
- rulesets
- included rulesets from ruleset

FYI @jaredpar </Description>
        <CreatedDate>13/02/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>17121</IssueID>
        <Title>Compiler does not take all inputs into account for determinism</Title>
        <Description>In discussion about editorconfig today, a number of scenarios were mentioned that we know or suspect are not properly accounted for in determinism:
- additional files
- rulesets
- included rulesets from ruleset

FYI @jaredpar </Description>
        <CreatedDate>13/02/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>17227</IssueID>
    <Title>Eliminate bound method groups during local lowering</Title>
    <Description>Fixes #14882
Fixes #13840
Fixes #13915
(those three are mostly separate reports of the same issue)

It takes one line to lower method groups in local lowering, and we can then delete lots of code
that used to be required to handle them in later phases.

@dotnet/roslyn-compiler May I please have a couple of reviews for this?
</Description>
    <CreatedDate>18/02/2017</CreatedDate>
    <ClosedDate>23/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>14882</IssueID>
        <Title>Consider lowering method group conversions into delegate creation</Title>
        <Description>Currently we have a conflated bound node that can represent both high-level method group conversion and low-level delegate creation. Semantically these are slightly different actions and there are many places that need to adjust for this.
I think initially we reused the node, hoping to minimize rewriting, but as a result we still need to rewrite most method group conversions while the code dealing with unified node needs to deal with its peculiarities.

see for example comments like:
```cs
                // This can occur in a delegate creation expression because the method group
                // in the argument can have a "this" receiver even when "this"
                // is not captured because a static method is selected.  But we do preserve
                // the method group and its receiver in the bound tree, so the "this"
                // receiver must be rewritten.

                //TODO: It seems we may capture more than needed here.

                // TODO: Why don't we drop "this" while lowering if method is static? 
                //       Actually, considering that method group expression does not evaluate to a particular value 
                //       why do we have it in the lowered tree at all?
```

Note that VB already uses separate nodes for this and separation of responsibilities makes corresponding code simpler since certain scenarios (like fake "capturing" of "this" by a static method group in the example above)  simply cannot happen.</Description>
        <CreatedDate>02/11/2016</CreatedDate>
        <ClosedDate>23/02/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>13840</IssueID>
        <Title>BoundMethodGroup node sometimes survives local lowering phase </Title>
        <Description>@gafter 

This can be seen in the following bugs / prs
- https://github.com/dotnet/roslyn/pull/13832
- https://github.com/dotnet/roslyn/issues/13734
</Description>
        <CreatedDate>15/09/2016</CreatedDate>
        <ClosedDate>23/02/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>13915</IssueID>
        <Title>sometimes a method group remains in the bound tree after lowering</Title>
        <Description>There are cases where a method group is not lowered properly (i.e. a method group remains in the bound tree following the lowering phase), resulting in the need for compensating code in a number of other places in the compiler. The method group is kept in the tree as a handle on the receiver, but the lowered code should store the receiver explicitly.

See https://github.com/dotnet/roslyn/pull/13832#r79497612 for an example where compensating code had to be added recently.
</Description>
        <CreatedDate>19/09/2016</CreatedDate>
        <ClosedDate>23/02/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/CodeGen/EmitConversion.cs</File>
      <File>src/Compilers/CSharp/Portable/CodeGen/EmitExpression.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/AsyncRewriter/AwaitExpressionSpiller.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/ExpressionLambdaRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/LambdaRewriter.Analysis.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/LambdaRewriter.LocalFunctionReferenceRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/LambdaRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_Conversion.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_DelegateCreationExpression.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/MethodToClassRewriter.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Source/ExpressionCompiler/Rewriters/CapturedVariableRewriter.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>16789</IssueID>
    <Title>Always create dedicated InitializerSemanticModel for parameter default value.</Title>
    <Description>Even for cases when the parameter is not part of a type member declaration, i.e. owned by an anonymous method or a local function.
Fixes #16748. Fixes #16374.

Also implement SemanticModel.GetDeclaredSymbol(ParameterSyntax) for parameters of a Local Function.
Fixes #16757.

@dotnet/roslyn-compiler Please review.</Description>
    <CreatedDate>27/01/2017</CreatedDate>
    <ClosedDate>30/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>16748</IssueID>
        <Title>Crash in SemanticModel when an expression variable is declared in default parameter value of an Anonymous Method</Title>
        <Description>```
        [Fact]
        public void DeclarationInAnonymousMethodParameterDefault()
        {
            var text = @"
class C
{
    public static void Main(int arg)
    {
        System.Action&lt;bool, int&gt; d1 = delegate (
                                                bool b = M(M(out int z1), z1), 
                                                int s2 = z1) 
                                            { var t = z1; };
        System.Action&lt;bool, int&gt; d2 = delegate (
                                                bool b = M(M(out var z2), z2), 
                                                int s2 = z2)  
                                            { var t = z2; };

        int x = z1 + z2;
        d1 = d2 = null;
    }
    static int M(out int z) =&gt; z = 1;
    static int M(int a, int b) =&gt; a+b;
}
";
            var compilation = CreateCompilationWithMscorlib45(text);

            var tree = compilation.SyntaxTrees[0];
            var model = compilation.GetSemanticModel(tree);

            var z1 = tree.GetRoot().DescendantNodes().OfType&lt;IdentifierNameSyntax&gt;().Where(id =&gt; id.Identifier.ValueText == "z1").First();
            Assert.Equal("", model.GetTypeInfo(z1).Type.ToTestDisplayString());
        }
```

```
Test 'DeclarationInAnonymousMethodParameterDefault' failed: 
    System.InvalidOperationException : This program location is thought to be unreachable.
	at Microsoft.CodeAnalysis.CSharp.Binder.BindOutVariableDeclarationArgument(DeclarationExpressionSyntax declarationExpression, DiagnosticBag diagnostics)
	at Microsoft.CodeAnalysis.CSharp.Binder.BindOutVariableArgument(DeclarationExpressionSyntax declarationExpression, DiagnosticBag diagnostics)
	at Microsoft.CodeAnalysis.CSharp.Binder.BindArgumentValue(DiagnosticBag diagnostics, ArgumentSyntax argumentSyntax, Boolean allowArglist, RefKind refKind)
	at Microsoft.CodeAnalysis.CSharp.Binder.BindArgumentAndName(AnalyzedArguments result, DiagnosticBag diagnostics, Boolean hadError, ArgumentSyntax argumentSyntax, Boolean allowArglist, Boolean isDelegateCreation)
	at Microsoft.CodeAnalysis.CSharp.Binder.BindArgumentsAndNames(SeparatedSyntaxList`1 arguments, DiagnosticBag diagnostics, AnalyzedArguments result, Boolean allowArglist, Boolean isDelegateCreation)
	at Microsoft.CodeAnalysis.CSharp.Binder.BindArgumentsAndNames(ArgumentListSyntax argumentListOpt, DiagnosticBag diagnostics, AnalyzedArguments result, Boolean allowArglist, Boolean isDelegateCreation)
	at Microsoft.CodeAnalysis.CSharp.Binder.BindInvocationExpression(InvocationExpressionSyntax node, DiagnosticBag diagnostics)
	at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed)
	at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionAllowArgList(ExpressionSyntax node, DiagnosticBag diagnostics)
	at Microsoft.CodeAnalysis.CSharp.Binder.BindValueAllowArgList(ExpressionSyntax node, DiagnosticBag diagnostics, BindValueKind valueKind)
	at Microsoft.CodeAnalysis.CSharp.Binder.BindArgumentExpression(DiagnosticBag diagnostics, ExpressionSyntax argumentExpression, RefKind refKind, Boolean allowArglist)
	at Microsoft.CodeAnalysis.CSharp.Binder.BindArgumentValue(DiagnosticBag diagnostics, ArgumentSyntax argumentSyntax, Boolean allowArglist, RefKind refKind)
	at Microsoft.CodeAnalysis.CSharp.Binder.BindArgumentAndName(AnalyzedArguments result, DiagnosticBag diagnostics, Boolean hadError, ArgumentSyntax argumentSyntax, Boolean allowArglist, Boolean isDelegateCreation)
	at Microsoft.CodeAnalysis.CSharp.Binder.BindArgumentsAndNames(SeparatedSyntaxList`1 arguments, DiagnosticBag diagnostics, AnalyzedArguments result, Boolean allowArglist, Boolean isDelegateCreation)
	at Microsoft.CodeAnalysis.CSharp.Binder.BindArgumentsAndNames(ArgumentListSyntax argumentListOpt, DiagnosticBag diagnostics, AnalyzedArguments result, Boolean allowArglist, Boolean isDelegateCreation)
	at Microsoft.CodeAnalysis.CSharp.Binder.BindInvocationExpression(InvocationExpressionSyntax node, DiagnosticBag diagnostics)
	at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed)
	at Microsoft.CodeAnalysis.CSharp.Binder.BindExpression(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed)
	at Microsoft.CodeAnalysis.CSharp.Binder.BindNamespaceOrTypeOrExpression(ExpressionSyntax node, DiagnosticBag diagnostics)
	at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics)
	at Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics)
	at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node)
	at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLowerBoundNode(CSharpSyntaxNode node)
	at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node, CSharpSyntaxNode&amp; bindableNode, BoundNode&amp; lowestBoundNode, BoundNode&amp; highestBoundNode, BoundNode&amp; boundParent)
	at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetTypeInfoWorker(CSharpSyntaxNode node, CancellationToken cancellationToken)
	at Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetTypeInfoWorker(CSharpSyntaxNode node, CancellationToken cancellationToken)
	at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfo(ExpressionSyntax expression, CancellationToken cancellationToken)
	at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoFromNode(SyntaxNode node, CancellationToken cancellationToken)
	at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoCore(SyntaxNode node, CancellationToken cancellationToken)
	at Microsoft.CodeAnalysis.SemanticModel.GetTypeInfo(SyntaxNode node, CancellationToken cancellationToken)
	Semantics\OutVarTests.cs(28978,0): at Microsoft.CodeAnalysis.CSharp.UnitTests.OutVarTests.DeclarationInAnonymousMethodParameterDefault()
```</Description>
        <CreatedDate>25/01/2017</CreatedDate>
        <ClosedDate>30/01/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>16374</IssueID>
        <Title>Bound nodes not preserved for local function parameter default values</Title>
        <Description>The following proposed test (for `OutVarTests.cs`) would fail because a few of the SemanticModel APIs don't work without bound nodes, and we don't have bound nodes for the parameter default values.

I would not be surprised if we have similar issues for other contexts requiring constants.

```cs
        [Fact, WorkItem(16167, "https://github.com/dotnet/roslyn/issues/16167")]
        public void DeclarationInLocalFunctionParameterDefault()
        {
            var text = @"
class C
{
    public static void Main(int arg)
    {
        void Local2(bool b = M(M(out int z1), z1), int s2 = z1) {}
        void Local5(bool b = M(M(out var z2), z2), int s2 = z2) {}

        int x = z1 + z2;
    }
    static int M(out int z) =&gt; z = 1;
    static int M(int a, int b) =&gt; a+b;
}
";
            // the scope of an expression variable introduced in the default expression
            // of a local function parameter is that default expression.
            var compilation = CreateCompilationWithMscorlib45(text);
            compilation.VerifyDiagnostics(
                // (6,30): error CS1736: Default parameter value for 'b' must be a compile-time constant
                //         void Local2(bool b = M(M(out int z1), z1), int s2 = z1) {}
                Diagnostic(ErrorCode.ERR_DefaultValueMustBeConstant, "M(M(out int z1), z1)").WithArguments("b").WithLocation(6, 30),
                // (6,61): error CS0103: The name 'z1' does not exist in the current context
                //         void Local2(bool b = M(M(out int z1), z1), int s2 = z1) {}
                Diagnostic(ErrorCode.ERR_NameNotInContext, "z1").WithArguments("z1").WithLocation(6, 61),
                // (6,56): error CS1750: A value of type '?' cannot be used as a default parameter because there are no standard conversions to type 'int'
                //         void Local2(bool b = M(M(out int z1), z1), int s2 = z1) {}
                Diagnostic(ErrorCode.ERR_NoConversionForDefaultParam, "s2").WithArguments("?", "int").WithLocation(6, 56),
                // (7,30): error CS1736: Default parameter value for 'b' must be a compile-time constant
                //         void Local5(bool b = M(M(out var z2), z2), int s2 = z2) {}
                Diagnostic(ErrorCode.ERR_DefaultValueMustBeConstant, "M(M(out var z2), z2)").WithArguments("b").WithLocation(7, 30),
                // (7,61): error CS0103: The name 'z2' does not exist in the current context
                //         void Local5(bool b = M(M(out var z2), z2), int s2 = z2) {}
                Diagnostic(ErrorCode.ERR_NameNotInContext, "z2").WithArguments("z2").WithLocation(7, 61),
                // (7,56): error CS1750: A value of type '?' cannot be used as a default parameter because there are no standard conversions to type 'int'
                //         void Local5(bool b = M(M(out var z2), z2), int s2 = z2) {}
                Diagnostic(ErrorCode.ERR_NoConversionForDefaultParam, "s2").WithArguments("?", "int").WithLocation(7, 56),
                // (9,17): error CS0103: The name 'z1' does not exist in the current context
                //         int x = z1 + z2;
                Diagnostic(ErrorCode.ERR_NameNotInContext, "z1").WithArguments("z1").WithLocation(9, 17),
                // (9,22): error CS0103: The name 'z2' does not exist in the current context
                //         int x = z1 + z2;
                Diagnostic(ErrorCode.ERR_NameNotInContext, "z2").WithArguments("z2").WithLocation(9, 22),
                // (6,14): warning CS0168: The variable 'Local2' is declared but never used
                //         void Local2(bool b = M(M(out int z1), z1), int s2 = z1) {}
                Diagnostic(ErrorCode.WRN_UnreferencedVar, "Local2").WithArguments("Local2").WithLocation(6, 14),
                // (7,14): warning CS0168: The variable 'Local5' is declared but never used
                //         void Local5(bool b = M(M(out var z2), z2), int s2 = z2) {}
                Diagnostic(ErrorCode.WRN_UnreferencedVar, "Local5").WithArguments("Local5").WithLocation(7, 14)
                );
            var tree = compilation.SyntaxTrees[0];
            var model = compilation.GetSemanticModel(tree);

            for (int i = 1; i &lt;= 2; i++)
            {
                var name = $"z{i}";
                var decl = GetOutVarDeclaration(tree, name);
                var refs = GetReferences(tree, name).ToArray();
                Assert.Equal(3, refs.Length);
                VerifyModelForOutVarInNotExecutableCode(model, decl, refs[0]);
                VerifyNotInScope(model, refs[1]);
                VerifyNotInScope(model, refs[2]);
                var symbol = (ILocalSymbol)model.GetDeclaredSymbol(decl.Designation);
                Assert.Equal("System.Int32", symbol.Type.ToTestDisplayString());
            }
        }
```
</Description>
        <CreatedDate>10/01/2017</CreatedDate>
        <ClosedDate>30/01/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>16757</IssueID>
        <Title>SemanticModel.GetDeclaredSymbol(ParameterSyntax) doesn't work for parameters of a Local Function</Title>
        <Description>This is going to affect IDE experience. I noticed that IDE doesn't show tooltips on the parameters and "Find All References" finds nothing when invoked on the parameters. This issue is the likely reason for the behavior.</Description>
        <CreatedDate>25/01/2017</CreatedDate>
        <ClosedDate>26/01/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Expressions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/LocalBinderFactory.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/MemberSemanticModel.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/SyntaxTreeSemanticModel.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceComplexParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/LocalFunctionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/OutVarTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>16659</IssueID>
    <Title>Implements GetDeclaredSymbol for tuple literals and GetSymbolInfo for elements of tuple literals.</Title>
    <Description>Implements GetDeclaredSymbol for tuple literals and GetSymbolInfo for elements of tuple literals.
Unimplemented GetDeclaredSymbol was responsible for erratic behavior and crashes in IDE.

Fixes:#14600
Fixes:#11013
Fixes:#14116
Fixes:#16168

**Customer scenario**

Even though tuple literals are expressions, they implicitly declare tuple types and elements.
Tuple literals do not provide semantic information about tuple literals.
(note: we do produce correct semantic info for tuple types we do not do so for tuple literals)

That leads to crashes in some "rename" scenarios, incorrect colorization, erratic behavior of "go to definition" and other misbehavior of IDE features built on top of "find all references" engine.

The root cause is that inferred references could be incorrectly computed - i.e. 
In the following code "Customer" and "Orders" could be understood by IDE as references to types, members or locals as long as they have same name.

```cs
var x = (Customer: 1, Orders: 2);
```
 
**Bugs this fixes:** 

Primarily #14600, 
there are several other bugs caused by the same issue.
#11013
#14116
#16168

**Workarounds, if any**

User must ignore incorrect colorization and should not try renaming symbols that are erroneously considered references from the tuple element.

I.E. when IDE thinks that a tuple element name is actually a reference to a containing type, renaming the element will be allowed (even though renaming elements is otherwise blocked). That could lead to both the element and the incorrectly referred to type being renamed, leading to crashes.

**Risk**

Risk is low. 

This fix does not enable renaming tuple elements. Enabling that is a 2.1 item.
It however makes the blocking to be more effective.
I.E. crashing scenarios that should be blocked will be blocked as intended.

**Performance impact**

Low.
Just correctly implementing an existing semantic info API. It is not any special in terms of complexity.

**Is this a regression from a previous update?**

New feature

**Root cause analysis:**

Tuple literal expression are special since they declare types and elements. An API for returning info on those was not implemented. The effects of not providing semantic info for those was not believed as potentially crashing, so the fix was pushed to 2.1
Now we know about crashing scenarios.

**How was the bug found?**

Ad hock testing. Customer reports.
</Description>
    <CreatedDate>20/01/2017</CreatedDate>
    <ClosedDate>26/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>14600</IssueID>
        <Title>GetDeclaredSymbol is not working for tuple names in tuple literals</Title>
        <Description>GTD for   "greeting"  in IDE goes nowhere

``` cs
var tuple = (number: 5, greeting: "Hello");
```

When I debugged, I noticed that  `CSharpSemanticModel::GetDeclaredSymbolCore` just returns `null` - it does not have a case for the element name in a tuple literal. 

I think the expected behavior is to return the symbol for the tuple element defined by the literal.

As a result of this, many other scenarios like FAR, rename, etc may get confused. They seem to be able to trace element references to the declaration syntax, but declaration syntax itself refuses to bind to what it declares.

== Crash repro:

```cs
    class Program
    {
        static void Main(string[] args)
        {
            var x = (Program: 1, Bob: 2);

            var Alice = x.Program;                
        }

    }
```

Try renaming “Program” in the tuple literal to be “Main”   (Also notice clearly wrong colorization)



</Description>
        <CreatedDate>19/10/2016</CreatedDate>
        <ClosedDate>26/01/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>11013</IssueID>
        <Title>Tuple conversion implementation appears confused</Title>
        <Description>The tuple conversion implementation appears either confused or confusing. A method

``` cs
        private BoundExpression CreateTupleConversion(CSharpSyntaxNode syntax, BoundTupleLiteral sourceTuple, Conversion conversion, bool isCast, TypeSymbol destination, DiagnosticBag diagnostics)
```

results in a bound node that does not have the `destination` type (but instead a type that is a combination of the destination type with names from the source tuple). I don't think that's right.
</Description>
        <CreatedDate>02/05/2016</CreatedDate>
        <ClosedDate>26/01/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>14116</IssueID>
        <Title>Rename local variable that matches tuple name does not behave very rationally</Title>
        <Description>**Steps to Reproduce**:
1.  Create a new C# project
2.  Have some code like:

``` C#
var tuple = (number: 5, greeting: "Hello");
var number = tuple.number;
var greeting = tuple.greeting;
```
1. select `greeting` in variable `var greeting`
2. attempt to rename `greeting`

**Expected Behavior**:
Inline rename is offered

**Actual Behavior**:
Visual Studio Crashes

```
System.Collections.Generic.KeyNotFoundException : The given key was not present in the dictionary.
   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)
   at Microsoft.CodeAnalysis.CSharp.Rename.CSharpRenameConflictLanguageService.&lt;&gt;c__DisplayClass3_0.&lt;ComputeDeclarationConflictsAsync&gt;b__0(SyntaxToken t) in D:\A\_work\24\s\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs:line 814
   at System.Linq.Enumerable.WhereSelectEnumerableIterator`2.MoveNext()
   at System.Collections.Generic.List`1.InsertRange(Int32 index, IEnumerable`1 collection)
   at System.Collections.Generic.List`1.AddRange(IEnumerable`1 collection)
   at Microsoft.CodeAnalysis.CSharp.Rename.CSharpRenameConflictLanguageService.&lt;ComputeDeclarationConflictsAsync&gt;d__3.MoveNext() in D:\A\_work\24\s\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs:line 814
```
</Description>
        <CreatedDate>27/09/2016</CreatedDate>
        <ClosedDate>26/01/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>16168</IssueID>
        <Title>Bug: Lambda parameters are incorrectly associated with tuple elements of the same name</Title>
        <Description>**Version Used**: VS 2017 RC, 2.0.0.61104 (obtained via `csc /?` from the command line)

**Steps to Reproduce**:

1.

```cs
class RoslynBug
{
    public static void Foo()
    {
        IEnumerable&lt;int&gt; ints = null;

        ints.Select(x[|] =&gt; (x: x, y: x));
    }
}
```

2. Hit backspace and rename the lambda argument `x` to `z`.
3. Press Ctrl + . and select "rename 'x' to 'z'".

**Expected Behavior**: The naming of the tuple element `x` should not be affected.

```cs
class RoslynBug
{
    public static void Foo()
    {
        IEnumerable&lt;int&gt; ints = null;

        ints.Select(z =&gt; (x: z, y: z));
    }
}
```

**Actual Behavior**: The tuple element `x` is renamed to `z`.

```cs
class RoslynBug
{
    public static void Foo()
    {
        IEnumerable&lt;int&gt; ints = null;

        ints.Select(z =&gt; (z: z, y: z));
    }
}
```

**Other Notes:** I also noticed that when I place my cursor next to the first `x`, both the tuple name and the actual argument `x` are highlighted.

![roslynbug](https://cloud.githubusercontent.com/assets/9159214/21579696/78f6d654-cf8a-11e6-8724-df8c1b34c1f8.PNG)
</Description>
        <CreatedDate>31/12/2016</CreatedDate>
        <ClosedDate>26/01/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>14600</IssueID>
        <Title>GetDeclaredSymbol is not working for tuple names in tuple literals</Title>
        <Description>GTD for   "greeting"  in IDE goes nowhere

``` cs
var tuple = (number: 5, greeting: "Hello");
```

When I debugged, I noticed that  `CSharpSemanticModel::GetDeclaredSymbolCore` just returns `null` - it does not have a case for the element name in a tuple literal. 

I think the expected behavior is to return the symbol for the tuple element defined by the literal.

As a result of this, many other scenarios like FAR, rename, etc may get confused. They seem to be able to trace element references to the declaration syntax, but declaration syntax itself refuses to bind to what it declares.

== Crash repro:

```cs
    class Program
    {
        static void Main(string[] args)
        {
            var x = (Program: 1, Bob: 2);

            var Alice = x.Program;                
        }

    }
```

Try renaming “Program” in the tuple literal to be “Main”   (Also notice clearly wrong colorization)



</Description>
        <CreatedDate>19/10/2016</CreatedDate>
        <ClosedDate>26/01/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>11013</IssueID>
        <Title>Tuple conversion implementation appears confused</Title>
        <Description>The tuple conversion implementation appears either confused or confusing. A method

``` cs
        private BoundExpression CreateTupleConversion(CSharpSyntaxNode syntax, BoundTupleLiteral sourceTuple, Conversion conversion, bool isCast, TypeSymbol destination, DiagnosticBag diagnostics)
```

results in a bound node that does not have the `destination` type (but instead a type that is a combination of the destination type with names from the source tuple). I don't think that's right.
</Description>
        <CreatedDate>02/05/2016</CreatedDate>
        <ClosedDate>26/01/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>14116</IssueID>
        <Title>Rename local variable that matches tuple name does not behave very rationally</Title>
        <Description>**Steps to Reproduce**:
1.  Create a new C# project
2.  Have some code like:

``` C#
var tuple = (number: 5, greeting: "Hello");
var number = tuple.number;
var greeting = tuple.greeting;
```
1. select `greeting` in variable `var greeting`
2. attempt to rename `greeting`

**Expected Behavior**:
Inline rename is offered

**Actual Behavior**:
Visual Studio Crashes

```
System.Collections.Generic.KeyNotFoundException : The given key was not present in the dictionary.
   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)
   at Microsoft.CodeAnalysis.CSharp.Rename.CSharpRenameConflictLanguageService.&lt;&gt;c__DisplayClass3_0.&lt;ComputeDeclarationConflictsAsync&gt;b__0(SyntaxToken t) in D:\A\_work\24\s\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs:line 814
   at System.Linq.Enumerable.WhereSelectEnumerableIterator`2.MoveNext()
   at System.Collections.Generic.List`1.InsertRange(Int32 index, IEnumerable`1 collection)
   at System.Collections.Generic.List`1.AddRange(IEnumerable`1 collection)
   at Microsoft.CodeAnalysis.CSharp.Rename.CSharpRenameConflictLanguageService.&lt;ComputeDeclarationConflictsAsync&gt;d__3.MoveNext() in D:\A\_work\24\s\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs:line 814
```
</Description>
        <CreatedDate>27/09/2016</CreatedDate>
        <ClosedDate>26/01/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>16168</IssueID>
        <Title>Bug: Lambda parameters are incorrectly associated with tuple elements of the same name</Title>
        <Description>**Version Used**: VS 2017 RC, 2.0.0.61104 (obtained via `csc /?` from the command line)

**Steps to Reproduce**:

1.

```cs
class RoslynBug
{
    public static void Foo()
    {
        IEnumerable&lt;int&gt; ints = null;

        ints.Select(x[|] =&gt; (x: x, y: x));
    }
}
```

2. Hit backspace and rename the lambda argument `x` to `z`.
3. Press Ctrl + . and select "rename 'x' to 'z'".

**Expected Behavior**: The naming of the tuple element `x` should not be affected.

```cs
class RoslynBug
{
    public static void Foo()
    {
        IEnumerable&lt;int&gt; ints = null;

        ints.Select(z =&gt; (x: z, y: z));
    }
}
```

**Actual Behavior**: The tuple element `x` is renamed to `z`.

```cs
class RoslynBug
{
    public static void Foo()
    {
        IEnumerable&lt;int&gt; ints = null;

        ints.Select(z =&gt; (z: z, y: z));
    }
}
```

**Other Notes:** I also noticed that when I place my cursor next to the first `x`, both the tuple name and the actual argument `x` are highlighted.

![roslynbug](https://cloud.githubusercontent.com/assets/9159214/21579696/78f6d654-cf8a-11e6-8724-df8c1b34c1f8.PNG)
</Description>
        <CreatedDate>31/12/2016</CreatedDate>
        <ClosedDate>26/01/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Conversions.cs</File>
      <File>src/Compilers/CSharp/Portable/CSharpExtensions.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/CSharpSemanticModel.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/MemberSemanticModel.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/SyntaxTreeSemanticModel.cs</File>
      <File>src/Compilers/CSharp/Portable/GlobalSuppressions.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Tuples/TupleTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/SyntaxFacts.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTupleTest.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Compilation/SemanticModelGetDeclaredSymbolAPITests.cs</File>
      <File>src/Workspaces/CSharp/Portable/Simplification/CSharpSimplificationService.Expander.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>16597</IssueID>
    <Title>Don't emit casing-related naming violations when the violating character has no casing (making the feature noisy/unusable in other cultures)</Title>
    <Description>Fixes #15326, #15486

Escrow Template
================

**Customer scenario**: A Japanese user (for example) has the default Naming Styles applied but uses an identifier where the first character is neither upper-case nor lower-case. We currently flag this as a violation of that Naming Style. Note that this will be their default experience out-of-the-box.

**Bugs this fixes:** #15326, #15486

**Workarounds, if any:** They can manually turn off all Naming Rules.

**Risk**: Low. We just add a check to see if the character being inspected has casing at all to 4 different places. This is specific to the Naming Styles feature, and nothing else relies on this code.

**Performance impact**: For the more common naming styles, it can create an additional struct per symbol (the .ToUpper or .ToLower'd version of the first character). For the less common naming styles, it can create an additional struct per character in each symbol analyzed.

**Is this a regression from a previous update?** No.

**Root cause analysis:** It was missed as part of the original feature work. There are unit tests to validate and protect against regressions.

**How was the bug found?** Customer reports and dogfooding.</Description>
    <CreatedDate>18/01/2017</CreatedDate>
    <ClosedDate>20/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>15326</IssueID>
        <Title>Naming style "require uppercase" doesn't allow numerics or non-Latin characters</Title>
        <Description>From: https://developercommunity.visualstudio.com/content/problem/2440/uppercase-naming-with-number.html

```C#
internal enum ButtonState : uint
{
    FROM_LEFT_1ST_BUTTON_PRESSED = 0x01,
    RIGHTMOST_BUTTON_PRESSED = 0x02,
    FROM_LEFT_2ND_BUTTON_PRESSED = 0x04,
    FROM_LEFT_3RD_BUTTON_PRESSED = 0x08,
    FROM_LEFT_4TH_BUTTON_PRESSED = 0x10
}
```

All of the enums that contain a number 1,2,3,4 fail the naming convention of uppercase.  Is there anyway to configure naming to force uppercase and allow numbers?</Description>
        <CreatedDate>17/11/2016</CreatedDate>
        <ClosedDate>20/01/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>15486</IssueID>
        <Title>The naming rule violation is inadequate for non-Latin languages</Title>
        <Description>**Version Used**: 

Visual Studio 2017 RC

**Steps to Reproduce**:

1. Use Japanese characters for identifiers

**Expected Behavior**:

There is no message.

**Actual Behavior**:

The code analyzer says "Naming rule violation: These words must begin with upper case characters".

![image](https://cloud.githubusercontent.com/assets/3760955/20550074/54470168-b175-11e6-9e91-c85d06d6ccce.png)

However, Japanese characters don't have such a classification. There is no upper case in Japanese characters. This message may be inadequate for many non-Latin languages.

You should not simply use `char.IsLower`/`IsUpper` methods for this purpose.
https://github.com/dotnet/roslyn/blob/7a105a46a735d8c3b21a9c1990cecbe6ac4dde8c/src/Features/Core/Portable/Diagnostics/Analyzers/NamingStyles/Serialization/NamingStyle.cs#L136
</Description>
        <CreatedDate>23/11/2016</CreatedDate>
        <ClosedDate>31/12/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>15326</IssueID>
        <Title>Naming style "require uppercase" doesn't allow numerics or non-Latin characters</Title>
        <Description>From: https://developercommunity.visualstudio.com/content/problem/2440/uppercase-naming-with-number.html

```C#
internal enum ButtonState : uint
{
    FROM_LEFT_1ST_BUTTON_PRESSED = 0x01,
    RIGHTMOST_BUTTON_PRESSED = 0x02,
    FROM_LEFT_2ND_BUTTON_PRESSED = 0x04,
    FROM_LEFT_3RD_BUTTON_PRESSED = 0x08,
    FROM_LEFT_4TH_BUTTON_PRESSED = 0x10
}
```

All of the enums that contain a number 1,2,3,4 fail the naming convention of uppercase.  Is there anyway to configure naming to force uppercase and allow numbers?</Description>
        <CreatedDate>17/11/2016</CreatedDate>
        <ClosedDate>20/01/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>15486</IssueID>
        <Title>The naming rule violation is inadequate for non-Latin languages</Title>
        <Description>**Version Used**: 

Visual Studio 2017 RC

**Steps to Reproduce**:

1. Use Japanese characters for identifiers

**Expected Behavior**:

There is no message.

**Actual Behavior**:

The code analyzer says "Naming rule violation: These words must begin with upper case characters".

![image](https://cloud.githubusercontent.com/assets/3760955/20550074/54470168-b175-11e6-9e91-c85d06d6ccce.png)

However, Japanese characters don't have such a classification. There is no upper case in Japanese characters. This message may be inadequate for many non-Latin languages.

You should not simply use `char.IsLower`/`IsUpper` methods for this purpose.
https://github.com/dotnet/roslyn/blob/7a105a46a735d8c3b21a9c1990cecbe6ac4dde8c/src/Features/Core/Portable/Diagnostics/Analyzers/NamingStyles/Serialization/NamingStyle.cs#L136
</Description>
        <CreatedDate>23/11/2016</CreatedDate>
        <ClosedDate>31/12/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Workspaces/Core/Portable/NamingStyles/NamingStyle.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>16593</IssueID>
    <Title>Expand the lifetime of locals declared within CasePatternSwitchLabelSyntax to the entire switch body.</Title>
    <Description>**Customer scenario**
When a lambda or a local function references a local declared within CasePatternSwitchLabelSyntax, either compiler crashes or an application crashes at runtime because corresponding closure isn't properly initialized.  

**Bugs this fixes:** 
Fixes #15536. 
Fixes #16066. 
Tracked by VSO https://devdiv.visualstudio.com/DevDiv/_workitems?id=369824

**Workarounds, if any**
Avoid directly referencing such locals in a lambda or a local function. 

**Risk**
Low. The fix is a targeted change for a pattern switch feature, which is the only feature affected by this issue. 

**Performance impact**
Low. We allocate one additional bound tree node per switch section with locals.

**Is this a regression from a previous update?**
No. New feature.

**Root cause analysis:**
A test gap for a new feature. Tests added.

**How was the bug found?**
Customer reported.

@dotnet/roslyn-compiler, @gafter, @agocke Please review.  </Description>
    <CreatedDate>18/01/2017</CreatedDate>
    <ClosedDate>19/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>15536</IssueID>
        <Title>Bad codegen in call-forward to local function in different switch block</Title>
        <Description>From #15322:

```csharp
class Program
{
    static void Main(string[] args)
    {
        object o = null;
        switch (o)
        {
            case string x:
                Assign();
                Foo();
                break;
            case int x:
                void Assign() { x = 5; }
                void Foo() =&gt; System.Console.WriteLine(x);
                break;
        }
    }
}
```

The problem seems to be getting the information for the local in CodeGen. It's not clear if this is an issue </Description>
        <CreatedDate>26/11/2016</CreatedDate>
        <ClosedDate>19/01/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>16066</IssueID>
        <Title>Pattern matching crashes if lambda captures pattern variable</Title>
        <Description>**Version Used**: 
Microsoft Visual Studio Enterprise 2017 RC
Version 15.0.26014.0 D15REL
Microsoft .NET Framework
Version 4.6.01055

**Steps to Reproduce**:
Run the following app:

```
using System.Collections.Generic;
using System.Linq;

namespace ConsoleApp2017
{
    class Program
    {
        class A
        {
        }
        
        static void Main(string[] args)
        {                           
            var dummy = new List&lt;int&gt;();

            switch((object)new A())
            {
                case A a:
                    {
                        dummy.Any(x =&gt; a != null);
                    }
                    break;
            }
        }
    }
}
```
**Expected Behavior**:
App just runs, no output.

**Actual Behavior**:
Null-reference on the switch statement, when trying to initialize not created instance of a hidden class &lt;&gt;c__DisplayClass27_0 CS$&lt;&gt;8__locals0;

Unhandled Exception: System.NullReferenceException: Object reference not set to an instance of an object.
   at ConsoleApp2017.Program.Main(String[] args) in D:\Temp\ConsoleApp2017\ConsoleApp2017\Program.cs:line 16
</Description>
        <CreatedDate>22/12/2016</CreatedDate>
        <ClosedDate>19/01/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/CodeGen/EmitStatement.cs</File>
      <File>src/Compilers/CSharp/Portable/CodeGen/Optimizer.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/PreciseAbstractFlowPass.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/LambdaCapturedVariable.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/LambdaRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_PatternSwitchStatement.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/MethodToClassRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/StateMachineRewriter/MethodToStateMachineRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/LocalSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceLocalSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/SynthesizedLocal.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Synthesized/TypeSubstitutedLocalSymbol.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/PDB/PDBTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/LocalFunctionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternSwitchTests.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Source/ExpressionCompiler/Symbols/EELocalSymbolBase.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Test/ExpressionCompiler/LocalsTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>16592</IssueID>
    <Title>Change the order of operands to object.Equals() for constant pattern match</Title>
    <Description>**Customer scenario**

The semantics of pattern-matching against a constant are different between the `is` operator and the `switch` statement. They were intended to be the same, but the order of operands to `object.Equals` in the generated code is backwards for the `is` operator. We need to fix this today, before RTM, so that users do not come to depend on the incorrect behavior (now-or-never language change). See also #16513.

**Bugs this fixes:** 

Fixes #16513

**Workarounds, if any**

Avoid using the new `is` operator with a constant right-hand-side.

**Risk**

Tiny. The fix is a one-line change to place the operands in the correct order.

**Performance impact**

None, as we are still executing the same code as before, albeit in a different order. However, with the changed order it will be possible for us to generate much better code in the future.

**Is this a regression from a previous update?**

No, as the feature is new.

**Root cause analysis:**

A subtle oversight in code generation. This might have been caught earlier if the compiler team had followed through on its plan to assign a developer to perform adversarial testing of each new feature under development.

**How was the bug found?**

Customer reported.

@dotnet/roslyn-compiler Please review this teensy tiny RTM fix.
</Description>
    <CreatedDate>18/01/2017</CreatedDate>
    <ClosedDate>19/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>16513</IssueID>
        <Title>The semantic of constant pattern</Title>
        <Description>I propose to change the semantic of constant pattern match from current:
```c#
foo is 42 /* == */ object.Equals(foo, 42)
```
…to the opposite:
```c#
foo is 42 /* == */ object.Equals(42, foo)
```

And this is how `object.Equals(object, object)` is implemented:
```c#
public static bool Equals(Object objA, Object objB) {
  if (objA==objB) {
    return true;
  }
  if (objA==null || objB==null) {
    return false;
  }
  return objA.Equals(objB);
}
```

The reasons behind proposed change:
1. Currently the "constant patterns" are not that "constant": generated code involves the execution of arbitrary 'object.Equals(object)' implementation on `foo` instance (in the case it is not `null`), since `object.Equals(object, object)` invokes it on first argument.
2. The idiom `foo is null` do not actually means `((object) foo) == null` as most of users would expect. It is easy to define a type that would pass `foo is null` check while being not-`null` (how would this play with future non-nullable types and their dataflow analysis?).
3. You won't be able to get rid of suboptimal code for constant patterns of reference types #13247, since such optimizations would change the semantic of matching.
4. If the arguments of `object.Equals()` would be reversed, the nice property of `is` expression would be restored — if right operand (type or pattern) has a type, the `is` expression only produce `true` if the left operand is of implicitly convertible type. Constant patterns do have types, literal expression do have types, `42` is of type `int`… who would expect `(int) foo` after successful `foo is 42` check to throw `InvalidCastException`?

p.s. Maybe it's a good idea to behave like F#: literal patterns of type `int` are only allowed when pattern is matched against the value of `int` type (but that's because of ML's "no implicit conversions" rule, I think).

cc @gafter</Description>
        <CreatedDate>14/01/2017</CreatedDate>
        <ClosedDate>19/01/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>16513</IssueID>
        <Title>The semantic of constant pattern</Title>
        <Description>I propose to change the semantic of constant pattern match from current:
```c#
foo is 42 /* == */ object.Equals(foo, 42)
```
…to the opposite:
```c#
foo is 42 /* == */ object.Equals(42, foo)
```

And this is how `object.Equals(object, object)` is implemented:
```c#
public static bool Equals(Object objA, Object objB) {
  if (objA==objB) {
    return true;
  }
  if (objA==null || objB==null) {
    return false;
  }
  return objA.Equals(objB);
}
```

The reasons behind proposed change:
1. Currently the "constant patterns" are not that "constant": generated code involves the execution of arbitrary 'object.Equals(object)' implementation on `foo` instance (in the case it is not `null`), since `object.Equals(object, object)` invokes it on first argument.
2. The idiom `foo is null` do not actually means `((object) foo) == null` as most of users would expect. It is easy to define a type that would pass `foo is null` check while being not-`null` (how would this play with future non-nullable types and their dataflow analysis?).
3. You won't be able to get rid of suboptimal code for constant patterns of reference types #13247, since such optimizations would change the semantic of matching.
4. If the arguments of `object.Equals()` would be reversed, the nice property of `is` expression would be restored — if right operand (type or pattern) has a type, the `is` expression only produce `true` if the left operand is of implicitly convertible type. Constant patterns do have types, literal expression do have types, `42` is of type `int`… who would expect `(int) foo` after successful `foo is 42` check to throw `InvalidCastException`?

p.s. Maybe it's a good idea to behave like F#: literal patterns of type `int` are only allowed when pattern is matched against the value of `int` type (but that's because of ML's "no implicit conversions" rule, I think).

cc @gafter</Description>
        <CreatedDate>14/01/2017</CreatedDate>
        <ClosedDate>19/01/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_Patterns.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>16589</IssueID>
    <Title>Do not fail in the NamingStyleCodeFix when we cannot find the symbol (causes the failure InfoBar to be shown)</Title>
    <Description>Fixes #15788 


We should always be able to find the symbol that generated this
diagnostic, but this cannot always be done by simply asking for the
declared symbol on the node from the symbol's declaration location.
Issue #16588 is tracking a more complete fix for this that always
successfully finds the symbol.

Escrow Template
================

**Customer scenario**: In the known cases of this, the customer has an invalid declaration that we believe violates naming rules. We issue the naming violation diagnostic, but then the CodeFix for it fails and shows the infobar.

**Bugs this fixes:** #15788 

**Workarounds, if any:** It can be avoided in the first place by deleting all Naming Rules. Once the error has happened, the InfoBar shows and the user can disable Naming Rules for the rest of the VS session, or re-enable it.

**Risk**: Low. This just introduces a null check and does not provide a CodeFix if we cannot find the symbol with the offending name. Nothing sits on top of this code.

**Performance impact**: None. This is just a null check.

**Is this a regression from a previous update?**: No.

**Root cause analysis:** Not enough testing was initially done around the analysis and fixing of invalid identifiers.

**How was the bug found?** Dogfooding</Description>
    <CreatedDate>18/01/2017</CreatedDate>
    <ClosedDate>20/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>15788</IssueID>
        <Title>NamingStyleCodeFixProvider crashes on const readonly</Title>
        <Description>Obviously not a normal scenario, but for the moment that I had `const readonly`, the naming style code fix provider crashed. Possibly related rules (in precedence order):
(Private|Protected) Static Readonly (Property|Field) -&gt; PascalCase
(Internal|Private|Protected|Protected Internal) Static Field -&gt; s_ prefix.

Tested on d15rel/26008.00.

```
System.NullReferenceException : Object reference not set to an instance of an object.
   at async Microsoft.CodeAnalysis.CodeFixes.NamingStyles.NamingStyleCodeFixProvider.RegisterCodeFixesAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.Extensions.IExtensionManagerExtensions.PerformActionAsync(&lt;Unknown Parameters&gt;)
   at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject)
```</Description>
        <CreatedDate>08/12/2016</CreatedDate>
        <ClosedDate>20/01/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>16588</IssueID>
        <Title>NamingStyleCodeFixProvider should always be able to find the symbol that generated the diagnostic</Title>
        <Description>As an example of where it cannot, see https://github.com/dotnet/roslyn/issues/15788</Description>
        <CreatedDate>18/01/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>15788</IssueID>
        <Title>NamingStyleCodeFixProvider crashes on const readonly</Title>
        <Description>Obviously not a normal scenario, but for the moment that I had `const readonly`, the naming style code fix provider crashed. Possibly related rules (in precedence order):
(Private|Protected) Static Readonly (Property|Field) -&gt; PascalCase
(Internal|Private|Protected|Protected Internal) Static Field -&gt; s_ prefix.

Tested on d15rel/26008.00.

```
System.NullReferenceException : Object reference not set to an instance of an object.
   at async Microsoft.CodeAnalysis.CodeFixes.NamingStyles.NamingStyleCodeFixProvider.RegisterCodeFixesAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.Extensions.IExtensionManagerExtensions.PerformActionAsync(&lt;Unknown Parameters&gt;)
   at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject)
```</Description>
        <CreatedDate>08/12/2016</CreatedDate>
        <ClosedDate>20/01/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Features/Core/Portable/CodeFixes/NamingStyle/AbstractNamingStyleCodeFixProvider.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>16586</IssueID>
    <Title>Avoid GUID conflicts for Naming Styles Symbol Specifications (causes Naming Styles to not work and the Tools | Options page to not load)</Title>
    <Description>Fixes #16431

Escrow Template
================

**Customer scenario**: The user adds two Naming Styles Symbol Specifications in the same VS session, and the Naming Styles analyzer stops working altogether, and the Naming Styles Tools | Options page will no longer load if one of these symbol specifications are actually used in a rule.

**Bugs this fixes:** #16431

**Workarounds, if any**: The user can only add one Symbol Specification per VS session. Once two have been added, fixing it requires manual edits to your CurrentSettings.vssettings file.

**Risk**: Very low. This code is in the Naming Styles option pages code, and nothing sits on top of that layer. It's essentially the same code as before, we just create a new guid for each new Symbol Specification instead of accidentally caching the guid.

**Performance impact**: We make a new SymbolSpecification object each time the user adds a symbol specification, but that is extremely minor and is done extremely infrequently.

**Is this a regression from a previous update?** Yes, this is a regression from RC.2

**Root cause analysis:** I believe a refactoring was done as part of a larger effort which introduced the caching of the new Symbol Specification guid.

**How was the bug found?**: Ad-hoc testing</Description>
    <CreatedDate>18/01/2017</CreatedDate>
    <ClosedDate>20/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>16431</IssueID>
        <Title>Naming Styles can be completely broken by adding multiple specifications</Title>
        <Description>To the point where the option page won't even load.

Rough repro steps:
1. Add two symbol specifications
2. Create two rules, that use the two symbol specifications
3. Save the options. Try to reopen the option page. It'll fail to load.

It doesn't repro if you do the analogous thing with Styles instead of Specifications.</Description>
        <CreatedDate>11/01/2017</CreatedDate>
        <ClosedDate>20/01/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>16431</IssueID>
        <Title>Naming Styles can be completely broken by adding multiple specifications</Title>
        <Description>To the point where the option page won't even load.

Rough repro steps:
1. Add two symbol specifications
2. Create two rules, that use the two symbol specifications
3. Save the options. Try to reopen the option page. It'll fail to load.

It doesn't repro if you do the analogous thing with Styles instead of Specifications.</Description>
        <CreatedDate>11/01/2017</CreatedDate>
        <ClosedDate>20/01/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/VisualStudio/Core/Impl/Options/Style/NamingPreferences/SymbolSpecification/SymbolSpecificationViewModel.cs</File>
      <File>src/Workspaces/Core/Portable/NamingStyles/Serialization/NamingStylePreferences.cs</File>
      <File>src/Workspaces/Core/Portable/NamingStyles/Serialization/SymbolSpecification.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>16569</IssueID>
    <Title>Harden pattern-matching binding in error cases.</Title>
    <Description>**Customer scenario**

Code using the new pattern-matching feature, and some erroneous code using the existing is-expression, can cause the compiler to crash.

**Bugs this fixes:** 

Fixes https://devdiv.visualstudio.com/DefaultCollection/DevDiv/_workitems?id=336030
Fixes https://devdiv.visualstudio.com/DefaultCollection/DevDiv/_workitems?id=294570
Fixes https://devdiv.visualstudio.com/DefaultCollection/DevDiv/_workitems?id=368942
Fixes https://devdiv.visualstudio.com/DefaultCollection/DevDiv/_workitems?id=363714
Fixes https://devdiv.visualstudio.com/DefaultCollection/DevDiv/_workitems?id=364165
Fixes #16296
Also adds test for #16559 

**Workarounds, if any**

Don't use the new features, and don't make any mistakes when using the is-operator.

**Risk**

Low; this is the addition of error-reporting and defensive code to handle error conditions.

**Performance impact**

Low; No additional allocations on normal code paths.

**Is this a regression from a previous update?**

Yes: the crash on erroneous use of the is-operator is a regression.

**Root cause analysis:**

Insufficient test coverage. Lack of dedicated testing team. Failure to follow through on our engineering test plan to pair a developer to "break" each feature under development.

**How was the bug found?**

These were all customer reported.
</Description>
    <CreatedDate>17/01/2017</CreatedDate>
    <ClosedDate>19/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>16296</IssueID>
        <Title>ArgumentNullException binding a pattern switch</Title>
        <Description>When running some custom static code analysis on Roslyn.sln, I get an "Unknown hard error". In the Windows EventViewer, I find the following error:
```
Application: csc.exe
Framework Version: v4.0.30319
Description: The application requested process termination through System.Environment.FailFast(string message).
Message: System.ArgumentNullException: Value cannot be null.
Parameter name: key
   at System.Collections.Generic.Dictionary`2.FindEntry(TKey key)
   at System.Collections.Generic.Dictionary`2.TryGetValue(TKey key, TValue&amp; value)
   at Microsoft.CodeAnalysis.CSharp.SubsumptionDiagnosticBuilder.CheckSubsumed(BoundPattern pattern, DecisionTree decisionTree, Boolean inputCouldBeNull)
   at Microsoft.CodeAnalysis.CSharp.SubsumptionDiagnosticBuilder.CheckSubsumed(BoundPattern pattern, DecisionTree decisionTree, Boolean inputCouldBeNull)
   at Microsoft.CodeAnalysis.CSharp.SubsumptionDiagnosticBuilder.AddLabel(BoundPatternSwitchLabel label, DiagnosticBag diagnostics, Boolean&amp; valueMatched)
   at Microsoft.CodeAnalysis.CSharp.PatternSwitchBinder.BindPatternSwitchSection(BoundExpression boundSwitchExpression, SwitchSectionSyntax node, Binder originalBinder, BoundPatternSwitchLabel&amp; defaultLabel, Boolean&amp; someValueMatched, SubsumptionDiagnosticBuilder subsumption, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.PatternSwitchBinder.BindPatternSwitchSections(BoundExpression boundSwitchExpression, SyntaxList`1 sections, Binder originalBinder, BoundPatternSwitchLabel&amp; defaultLabel, Boolean&amp; isComplete, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.PatternSwitchBinder.BindSwitchExpressionAndSections(SwitchStatementSyntax node, Binder originalBinder, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindBlockParts(BlockSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.ForLoopBinder.BindForParts(ForStatementSyntax node, Binder originalBinder, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindBlockParts(BlockSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.BindMethodBody(MethodSymbol method, TypeCompilationState compilationState, DiagnosticBag diagnostics, ImportChain&amp; importChain, Boolean&amp; originalBodyNested)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethod(MethodSymbol methodSymbol, Int32 methodOrdinal, ProcessedFieldInitializers&amp; processedInitializers, SynthesizedSubmissionFields previousSubmissionFields, TypeCompilationState compilationState)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(NamedTypeSymbol containingType)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.&lt;&gt;c__DisplayClass20_0.&lt;CompileNamedTypeAsTask&gt;b__0()
Stack:
   at System.Environment.FailFast(System.String, System.Exception)
   at Microsoft.CodeAnalysis.FatalError.Report(System.Exception, System.Action`1&lt;System.Exception&gt;)
   at Microsoft.CodeAnalysis.FatalError.ReportUnlessCanceled(System.Exception)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler+&lt;&gt;c__DisplayClass20_0.&lt;CompileNamedTypeAsTask&gt;b__0()
   at System.Collections.Generic.Dictionary`2[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089],[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].FindEntry(System.__Canon)
   at System.Collections.Generic.Dictionary`2[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089],[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].TryGetValue(System.__Canon, System.__Canon ByRef)
   at Microsoft.CodeAnalysis.CSharp.SubsumptionDiagnosticBuilder.CheckSubsumed(Microsoft.CodeAnalysis.CSharp.BoundPattern, Microsoft.CodeAnalysis.CSharp.DecisionTree, Boolean)
   at Microsoft.CodeAnalysis.CSharp.SubsumptionDiagnosticBuilder.CheckSubsumed(Microsoft.CodeAnalysis.CSharp.BoundPattern, Microsoft.CodeAnalysis.CSharp.DecisionTree, Boolean)
   at Microsoft.CodeAnalysis.CSharp.SubsumptionDiagnosticBuilder.AddLabel(Microsoft.CodeAnalysis.CSharp.BoundPatternSwitchLabel, Microsoft.CodeAnalysis.DiagnosticBag, Boolean ByRef)
   at Microsoft.CodeAnalysis.CSharp.PatternSwitchBinder.BindPatternSwitchSection(Microsoft.CodeAnalysis.CSharp.BoundExpression, Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax, Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.CSharp.BoundPatternSwitchLabel ByRef, Boolean ByRef, Microsoft.CodeAnalysis.CSharp.SubsumptionDiagnosticBuilder, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.PatternSwitchBinder.BindPatternSwitchSections(Microsoft.CodeAnalysis.CSharp.BoundExpression, Microsoft.CodeAnalysis.SyntaxList`1&lt;Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax&gt;, Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.CSharp.BoundPatternSwitchLabel ByRef, Boolean ByRef, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.PatternSwitchBinder.BindSwitchExpressionAndSections(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax, Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindBlockParts(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.ForLoopBinder.BindForParts(Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax, Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindBlockParts(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.BindMethodBody(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol, Microsoft.CodeAnalysis.CSharp.TypeCompilationState, Microsoft.CodeAnalysis.DiagnosticBag, Microsoft.CodeAnalysis.CSharp.ImportChain ByRef, Boolean ByRef)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethod(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol, Int32, ProcessedFieldInitializers ByRef, Microsoft.CodeAnalysis.CSharp.SynthesizedSubmissionFields, Microsoft.CodeAnalysis.CSharp.TypeCompilationState)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler+&lt;&gt;c__DisplayClass20_0.&lt;CompileNamedTypeAsTask&gt;b__0()
   at Roslyn.Utilities.UICultureUtilities+&lt;&gt;c__DisplayClass5_0.&lt;WithCurrentUICulture&gt;b__0()
   at System.Threading.Tasks.Task.Execute()
   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)
   at System.Threading.Tasks.Task.ExecuteEntry(Boolean)
   at System.Threading.Tasks.ThreadPoolTaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task, Boolean)
   at System.Threading.Tasks.TaskScheduler.TryRunInline(System.Threading.Tasks.Task, Boolean)
   at System.Threading.Tasks.Task.WrappedTryRunInline()
   at System.Threading.Tasks.Task.InternalWait(Int32, System.Threading.CancellationToken)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(System.Threading.Tasks.Task)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.WaitForWorkers()
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethodBodies(Microsoft.CodeAnalysis.CSharp.CSharpCompilation, Microsoft.CodeAnalysis.CSharp.Emit.PEModuleBuilder, Boolean, Boolean, Microsoft.CodeAnalysis.DiagnosticBag, System.Predicate`1&lt;Microsoft.CodeAnalysis.CSharp.Symbol&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnosticsForAllMethodBodies(Microsoft.CodeAnalysis.DiagnosticBag, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnostics(Microsoft.CodeAnalysis.CompilationStage, Boolean, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnostics(System.Threading.CancellationToken)
   at SonarAnalyzer.Rules.CSharp.PrivateFieldUsedAsLocalVariable.ExcludePrivateFieldsBasedOnCompilerErrors(System.Collections.Immutable.IImmutableDictionary`2&lt;Microsoft.CodeAnalysis.ISymbol,PrivateField&gt;, System.Collections.Generic.IDictionary`2&lt;Microsoft.CodeAnalysis.ISymbol,System.Collections.Generic.IDictionary`2&lt;Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.ISymbol&gt;&gt;, System.Collections.Immutable.IImmutableSet`1&lt;Microsoft.CodeAnalysis.ISymbol&gt;, Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax)
   at SonarAnalyzer.Rules.CSharp.PrivateFieldUsedAsLocalVariable+&lt;&gt;c.&lt;Initialize&gt;b__9_0(Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext)
   at SonarAnalyzer.Helpers.DiagnosticAnalyzerContextHelper+&lt;&gt;c__DisplayClass0_0`1[[Microsoft.CodeAnalysis.CSharp.SyntaxKind, Microsoft.CodeAnalysis.CSharp, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]].&lt;RegisterSyntaxNodeActionInNonGenerated&gt;b__0(Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext)
   at SonarAnalyzer.Helpers.SonarAnalysisContext+&lt;&gt;c__DisplayClass12_0`1[[Microsoft.CodeAnalysis.CSharp.SyntaxKind, Microsoft.CodeAnalysis.CSharp, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]].&lt;RegisterSyntaxNodeAction&gt;b__0(Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor+&lt;&gt;c__DisplayClass42_1`1[[Microsoft.CodeAnalysis.CSharp.SyntaxKind, Microsoft.CodeAnalysis.CSharp, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]].&lt;ExecuteSyntaxNodeAction&gt;b__1()
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.ExecuteAndCatchIfThrows_NoLock(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer, System.Action, System.Nullable`1&lt;Microsoft.CodeAnalysis.Diagnostics.AnalysisContextInfo&gt;)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.ExecuteAndCatchIfThrows(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer, System.Action, System.Nullable`1&lt;Microsoft.CodeAnalysis.Diagnostics.AnalysisContextInfo&gt;)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.ExecuteSyntaxNodeAction[[Microsoft.CodeAnalysis.CSharp.SyntaxKind, Microsoft.CodeAnalysis.CSharp, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalyzerAction`1&lt;Microsoft.CodeAnalysis.CSharp.SyntaxKind&gt;, Microsoft.CodeAnalysis.SyntaxNode, Microsoft.CodeAnalysis.ISymbol, Microsoft.CodeAnalysis.SemanticModel, System.Action`1&lt;Microsoft.CodeAnalysis.Diagnostic&gt;, SyntaxNodeAnalyzerStateData)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.ExecuteSyntaxNodeActions[[Microsoft.CodeAnalysis.CSharp.SyntaxKind, Microsoft.CodeAnalysis.CSharp, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](Microsoft.CodeAnalysis.SyntaxNode, System.Collections.Generic.IDictionary`2&lt;Microsoft.CodeAnalysis.CSharp.SyntaxKind,System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalyzerAction`1&lt;Microsoft.CodeAnalysis.CSharp.SyntaxKind&gt;&gt;&gt;, Microsoft.CodeAnalysis.ISymbol, Microsoft.CodeAnalysis.SemanticModel, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.SyntaxKind&gt;, System.Action`1&lt;Microsoft.CodeAnalysis.Diagnostic&gt;, SyntaxNodeAnalyzerStateData)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.ExecuteSyntaxNodeActions[[Microsoft.CodeAnalysis.CSharp.SyntaxKind, Microsoft.CodeAnalysis.CSharp, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](System.Collections.Generic.IEnumerable`1&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;, System.Collections.Generic.IDictionary`2&lt;Microsoft.CodeAnalysis.CSharp.SyntaxKind,System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalyzerAction`1&lt;Microsoft.CodeAnalysis.CSharp.SyntaxKind&gt;&gt;&gt;, Microsoft.CodeAnalysis.ISymbol, Microsoft.CodeAnalysis.SemanticModel, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.SyntaxKind&gt;, System.Action`1&lt;Microsoft.CodeAnalysis.Diagnostic&gt;, SyntaxNodeAnalyzerStateData)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.ExecuteSyntaxNodeActionsCore[[Microsoft.CodeAnalysis.CSharp.SyntaxKind, Microsoft.CodeAnalysis.CSharp, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](System.Collections.Generic.IEnumerable`1&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;, System.Collections.Generic.IDictionary`2&lt;Microsoft.CodeAnalysis.CSharp.SyntaxKind,System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalyzerAction`1&lt;Microsoft.CodeAnalysis.CSharp.SyntaxKind&gt;&gt;&gt;, Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer, Microsoft.CodeAnalysis.ISymbol, Microsoft.CodeAnalysis.SemanticModel, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.SyntaxKind&gt;, Microsoft.CodeAnalysis.Text.TextSpan, SyntaxNodeAnalyzerStateData, Boolean)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.TryExecuteSyntaxNodeActions[[Microsoft.CodeAnalysis.CSharp.SyntaxKind, Microsoft.CodeAnalysis.CSharp, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](System.Collections.Generic.IEnumerable`1&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;, System.Collections.Generic.IDictionary`2&lt;Microsoft.CodeAnalysis.CSharp.SyntaxKind,System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalyzerAction`1&lt;Microsoft.CodeAnalysis.CSharp.SyntaxKind&gt;&gt;&gt;, Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer, Microsoft.CodeAnalysis.SemanticModel, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.SyntaxKind&gt;, Microsoft.CodeAnalysis.Text.TextSpan, Microsoft.CodeAnalysis.SyntaxReference, Int32, Microsoft.CodeAnalysis.ISymbol, Microsoft.CodeAnalysis.Diagnostics.AnalysisScope, Microsoft.CodeAnalysis.Diagnostics.AnalysisState, Boolean)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver`1[[Microsoft.CodeAnalysis.CSharp.SyntaxKind, Microsoft.CodeAnalysis.CSharp, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]].TryExecuteDeclaringReferenceActions(Microsoft.CodeAnalysis.SyntaxReference, Int32, Microsoft.CodeAnalysis.Diagnostics.SymbolDeclaredCompilationEvent, Microsoft.CodeAnalysis.Diagnostics.AnalysisScope, Microsoft.CodeAnalysis.Diagnostics.AnalysisState, Boolean, Boolean, Boolean, Boolean, Boolean, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver`1[[Microsoft.CodeAnalysis.CSharp.SyntaxKind, Microsoft.CodeAnalysis.CSharp, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]].TryExecuteDeclaringReferenceActions(Microsoft.CodeAnalysis.Diagnostics.SymbolDeclaredCompilationEvent, Microsoft.CodeAnalysis.Diagnostics.AnalysisScope, Microsoft.CodeAnalysis.Diagnostics.AnalysisState, Boolean, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.TryProcessSymbolDeclared(Microsoft.CodeAnalysis.Diagnostics.SymbolDeclaredCompilationEvent, Microsoft.CodeAnalysis.Diagnostics.AnalysisScope, Microsoft.CodeAnalysis.Diagnostics.AnalysisState, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.TryProcessEventCore(Microsoft.CodeAnalysis.Diagnostics.CompilationEvent, Microsoft.CodeAnalysis.Diagnostics.AnalysisScope, Microsoft.CodeAnalysis.Diagnostics.AnalysisState, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver+&lt;ProcessCompilationEventsCoreAsync&gt;d__70.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].Start[[Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver+&lt;ProcessCompilationEventsCoreAsync&gt;d__70, Microsoft.CodeAnalysis, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;ProcessCompilationEventsCoreAsync&gt;d__70 ByRef)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.ProcessCompilationEventsCoreAsync(Microsoft.CodeAnalysis.Diagnostics.AnalysisScope, Microsoft.CodeAnalysis.Diagnostics.AnalysisState, Boolean, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver+&lt;&gt;c__DisplayClass69_0+&lt;&lt;ProcessCompilationEventsAsync&gt;b__0&gt;d.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].Start[[Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver+&lt;&gt;c__DisplayClass69_0+&lt;&lt;ProcessCompilationEventsAsync&gt;b__0&gt;d, Microsoft.CodeAnalysis, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;&lt;ProcessCompilationEventsAsync&gt;b__0&gt;d ByRef)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver+&lt;&gt;c__DisplayClass69_0.&lt;ProcessCompilationEventsAsync&gt;b__0()
   at System.Threading.Tasks.Task`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].InnerInvoke()
   at System.Threading.Tasks.Task.Execute()
   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)
   at System.Threading.Tasks.Task.ExecuteEntry(Boolean)
   at System.Threading.ThreadPoolWorkQueue.Dispatch()
```

I have no easy repro of the issue. But from the stacktrace it seems that `null` is being passed to the `TryGetValue` of the dictionary in `SubsumptionDiagnosticBuilder.CheckSubsumed`: `byValue.ValueAndDecision.TryGetValue(constantPattern.Value.ConstantValue.Value, out decision)`. 

Sidenote: I have no easy repro of the issue, because I can't identify what input source code and code analyzer produces this error. I'm trying to run a SonarQube analysis of the Roslyn project based on this: http://docs.sonarqube.org/display/SCAN/From+the+Command+Line. Internally what happens is that when `msbuild Roslyn.sln` is called, then a custom analyzer DLLs are being passed to CSC with the help of a targets file. In general this approach is working, and it was also working for the Roslyn.sln, however as the Roslyn.sln dogfeeds the latest CSC to itself, due to the above bug, the analysis also fails. </Description>
        <CreatedDate>06/01/2017</CreatedDate>
        <ClosedDate>19/01/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>16559</IssueID>
        <Title>Stack Overflow in BindPatternSwitchLabelForInference</Title>
        <Description>**Version Used**: VS2015 RC3

**Steps to Reproduce**:

Attempt to compile this code:

```cs
public class Program5815
{
    public static void Main(string[] args)
    {
        switch ((int)M())
        {
            case var x3:
            case true ? x3 : 4:
                break;
        }
    }
    private static object M() =&gt; null;
}
```

**Expected Behavior**: Compiler error about case label not being a constant

**Actual Behavior**: Compiler stack overflow

See also https://devdiv.visualstudio.com/DefaultCollection/DevDiv/_workitems?_a=edit&amp;id=369796</Description>
        <CreatedDate>17/01/2017</CreatedDate>
        <ClosedDate>25/01/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Operators.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/SubsumptionDiagnosticBuilder.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/DecisionTreeBuilder.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>16467</IssueID>
    <Title>Expression variables declared in a local function parameter default are given a scope</Title>
    <Description>**Customer scenario**

If you declare an expression variable (e.g. out variable) inside the default value
expression of a parameter to a local function, **the IDE crashes**.

**Bugs this fixes:** 

Fixes #16167

**Workarounds, if any**

Don't make that mistake.

**Risk**

Small. Corrects a small oversight in the implementation of the interaction of new language features.

**Performance impact**

Trivial.

**Is this a regression from a previous update?**

No.

**Root cause analysis:**

Missing test for interaction between multiple new language features. Lack of dedicated testing team. Lack of coordinated testing role for new features and interactions between new features.

**How was the bug found?**

Customer reported. It occurred accidentally when the customer pasted XML inside a method body instead of inside the doc comment.

@jcouv @cston previously reviewed this fix in #16315; this moves it to the rc3 branch.
</Description>
    <CreatedDate>12/01/2017</CreatedDate>
    <ClosedDate>13/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>16167</IssueID>
        <Title>VS crashes if xml is pasted in C# editor</Title>
        <Description>**Version Used**: 

**Steps to Reproduce**:

1. create new C# console app
2. paste text below as a body of `Main`
```xml
      &lt;summary&gt;Copies a range of elements from an &lt;see cref="T:System.Array" /&gt; starting at the first element and pastes them into another &lt;see cref="T:System.Array" /&gt; starting at the first element. The length is specified as a 32-bit integer.&lt;/summary&gt;
      &lt;param name="sourceArray"&gt;The &lt;see cref="T:System.Array" /&gt; that contains the data to copy.&lt;/param&gt;
      &lt;param name="destinationArray"&gt;The &lt;see cref="T:System.Array" /&gt; that receives the data.&lt;/param&gt;
      &lt;param name="length"&gt;A 32-bit integer that represents the number of elements to copy.&lt;/param&gt;
      &lt;exception cref="T:System.ArgumentNullException"&gt;
        &lt;paramref name="sourceArray" /&gt; is null.-or-&lt;paramref name="destinationArray" /&gt; is null.&lt;/exception&gt;
      &lt;exception cref="T:System.RankException"&gt;
        &lt;paramref name="sourceArray" /&gt; and &lt;paramref name="destinationArray" /&gt; have different ranks.&lt;/exception&gt;
      &lt;exception cref="T:System.ArrayTypeMismatchException"&gt;
        &lt;paramref name="sourceArray" /&gt; and &lt;paramref name="destinationArray" /&gt; are of incompatible types.&lt;/exception&gt;
      &lt;exception cref="T:System.InvalidCastException"&gt;At least one element in &lt;paramref name="sourceArray" /&gt; cannot be cast to the type of &lt;paramref name="destinationArray" /&gt;.&lt;/exception&gt;
      &lt;exception cref="T:System.ArgumentOutOfRangeException"&gt;
        &lt;paramref name="length" /&gt; is less than zero.&lt;/exception&gt;
      &lt;exception cref="T:System.ArgumentException"&gt;
        &lt;paramref name="length" /&gt; is greater than the number of elements in &lt;paramref name="sourceArray" /&gt;.-or-&lt;paramref name="length" /&gt; is greater than the number of elements in &lt;paramref name="destinationArray" /&gt;.&lt;/exception&gt;

```

**Expected Behavior**:
Sea of red in the editor.

**Actual Behavior**:
VS crashes:
```
Application: devenv.exe
Framework Version: v4.0.30319
Description: The application requested process termination through System.Environment.FailFast(string message).
Message: System.NullReferenceException: Object reference not set to an instance of an object.
   at Microsoft.CodeAnalysis.CSharp.Binder.BindDeclarationPattern(DeclarationPatternSyntax node, BoundExpression operand, TypeSymbol operandType, Boolean hasErrors, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindPattern(PatternSyntax node, BoundExpression operand, TypeSymbol operandType, Boolean hasErrors, DiagnosticBag diagnostics, Boolean wasSwitchCase)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindIsPatternExpression(IsPatternExpressionSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpression(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindNamespaceOrTypeOrExpression(ExpressionSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLowerBoundNode(CSharpSyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node, CSharpSyntaxNode&amp; bindableNode, BoundNode&amp; lowestBoundNode, BoundNode&amp; highestBoundNode, BoundNode&amp; boundParent)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetSymbolInfoWorker(CSharpSyntaxNode node, SymbolInfoOptions options, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(ExpressionSyntax expression, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.ClassifyTypeSyntax(NameSyntax name, SemanticModel semanticModel, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.ClassifyNode(SyntaxNode syntax, SemanticModel semanticModel, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService.Worker.ClassifyNode(SyntaxNode syntax)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService.Worker.ProcessNodes()
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService.Worker.Classify(Workspace workspace, SemanticModel semanticModel, TextSpan textSpan, List`1 list, Func`2 getNodeClassifiers, Func`2 getTokenClassifiers, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService.&lt;AddSemanticClassificationsAsync&gt;d__5.MoveNext()
Stack:
   at System.Environment.FailFast(System.String, System.Exception)
   at Microsoft.CodeAnalysis.FailFast.OnFatalException(System.Exception)
   at Microsoft.CodeAnalysis.ErrorReporting.FatalError.Report(System.Exception, System.Action`1&lt;System.Exception&gt;)
   at Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportUnlessCanceled(System.Exception)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__5.MoveNext()
   at Microsoft.CodeAnalysis.CSharp.Binder.BindDeclarationPattern(Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationPatternSyntax, Microsoft.CodeAnalysis.CSharp.BoundExpression, Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, Boolean, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindPattern(Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax, Microsoft.CodeAnalysis.CSharp.BoundExpression, Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, Boolean, Microsoft.CodeAnalysis.DiagnosticBag, Boolean)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindIsPatternExpression(Microsoft.CodeAnalysis.CSharp.Syntax.IsPatternExpressionSyntax, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, Microsoft.CodeAnalysis.DiagnosticBag, Boolean, Boolean)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, Microsoft.CodeAnalysis.DiagnosticBag, Boolean, Boolean)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindNamespaceOrTypeOrExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Bind(Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.Bind(Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLowerBoundNode(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetSymbolInfoWorker(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, SymbolInfoOptions, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.ClassifyTypeSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax, Microsoft.CodeAnalysis.SemanticModel, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.ClassifyNode(Microsoft.CodeAnalysis.SyntaxNode, Microsoft.CodeAnalysis.SemanticModel, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService+Worker.ClassifyNode(Microsoft.CodeAnalysis.SyntaxNode)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService+Worker.ProcessNodes()
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService+Worker.Classify(Microsoft.CodeAnalysis.Workspace, Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.Text.TextSpan, System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__5.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Classification.AbstractClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__5, Microsoft.CodeAnalysis.Workspaces, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;AddSemanticClassificationsAsync&gt;d__5 ByRef)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Document, Microsoft.CodeAnalysis.Text.TextSpan, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.AbstractEditorClassificationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Document, Microsoft.CodeAnalysis.Text.TextSpan, System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ClassifySpansAsync&gt;d__2.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ClassifySpansAsync&gt;d__2, Microsoft.CodeAnalysis.EditorFeatures, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;ClassifySpansAsync&gt;d__2 ByRef)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.ClassifySpansAsync(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IEditorClassificationService, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;TryClassifyContainingMemberSpan&gt;d__1.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].Start[[Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;TryClassifyContainingMemberSpan&gt;d__1, Microsoft.CodeAnalysis.EditorFeatures, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;TryClassifyContainingMemberSpan&gt;d__1 ByRef)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.TryClassifyContainingMemberSpan(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IEditorClassificationService, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ProduceTagsAsync&gt;d__0.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ProduceTagsAsync&gt;d__0, Microsoft.CodeAnalysis.EditorFeatures, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;ProduceTagsAsync&gt;d__0 ByRef)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.ProduceTagsAsync(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IEditorClassificationService, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationViewTaggerProvider.ProduceTagsAsync(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;)
   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource+&lt;RecomputeTagsAsync&gt;d__83[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource+&lt;RecomputeTagsAsync&gt;d__83[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Microsoft.CodeAnalysis.EditorFeatures, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;RecomputeTagsAsync&gt;d__83&lt;System.__Canon&gt; ByRef)
   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].RecomputeTagsAsync(System.Object, System.Nullable`1&lt;Microsoft.VisualStudio.Text.SnapshotPoint&gt;, System.Nullable`1&lt;Microsoft.CodeAnalysis.Text.TextChangeRange&gt;, System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan&gt;, System.Collections.Immutable.ImmutableDictionary`2&lt;Microsoft.VisualStudio.Text.ITextBuffer,Microsoft.CodeAnalysis.Editor.Shared.Tagging.TagSpanIntervalTree`1&lt;System.__Canon&gt;&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource+&lt;&gt;c__DisplayClass74_0[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].&lt;RecomputeTagsForeground&gt;b__0(System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.Shared.Threading.AsynchronousSerialWorkQueue+&lt;&gt;c__DisplayClass11_0.&lt;EnqueueBackgroundTask&gt;b__0(System.Threading.Tasks.Task)
   at System.Threading.Tasks.ContinuationResultTaskFromTask`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].InnerInvoke()
   at System.Threading.Tasks.Task.Execute()
   at System.Threading.Tasks.Task.ExecutionContextCallback(System.Object)
   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)
   at System.Threading.Tasks.Task.ExecuteEntry(Boolean)
   at System.Threading.Tasks.Task.System.Threading.IThreadPoolWorkItem.ExecuteWorkItem()
   at System.Threading.ThreadPoolWorkQueue.Dispatch()
   at System.Threading._ThreadPoolWaitCallback.PerformWaitCallback()

```
</Description>
        <CreatedDate>31/12/2016</CreatedDate>
        <ClosedDate>13/01/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>16315</IssueID>
        <Title>Expression variables declared in a local function parameter default are given a scope</Title>
        <Description>**Customer scenario**

If you declare an expression variable (e.g. out variable) inside the default value
expression of a parameter to a local function, the IDE crashes.

**Bugs this fixes:** 

Fixes #16167

**Workarounds, if any**

Don't make that mistake.

**Risk**

Small. Corrects a small oversight in the implementation of the interaction of new language features.

**Performance impact**

Trivial.

**Is this a regression from a previous update?**

No.

**Root cause analysis:**

Missing test for interaction between multiple new language features. Lack of dedicated testing team. Lack of coordinated testing role for new features and interactions between new features.

**How was the bug found?**

Customer reported.

@AlekseyTs @agocke @dotnet/roslyn-compiler May I please have a couple of reviews for this very small bug fix?
</Description>
        <CreatedDate>07/01/2017</CreatedDate>
        <ClosedDate>12/01/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/LocalBinderFactory.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceComplexParameterSymbol.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/FuzzTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/LocalFunctionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/OutVarTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>16409</IssueID>
    <Title>Do not run Naming Styles on overrides, etc.</Title>
    <Description>Fixes #15345

Do not run Naming Styles on overrides or known explicit/implicit interface implementations.

Escrow Template
================

**Customer scenario**: Customers who enable Naming Rules for members currently see the rules enforced on overrides and interface implementations, which can be noisy. This is particularly bad when the name is not fixable (when the name being overridden is in metadata), or when we eventually enable closed file analysis for this analyzer.

**Bugs this fixes:**: #15345

**Workarounds, if any**: None

**Risk**: Low. This is at the top of the stack and should just cause Naming Styles to be enforced less places.

**Performance impact**: For every Method/Property/Event without the "override" keyword and without being an explicit implementation of something, we will now do the work of examining each member of all base types and implemented interfaces to see if the given Method/Property/Event implements that member.

**Is this a regression from a previous update?**: No

**Root cause analysis:** This case was missed during the original feature work. Unit tests have been added to prevent regressions.

**How was the bug found?**: Dogfooding</Description>
    <CreatedDate>11/01/2017</CreatedDate>
    <ClosedDate>12/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>15345</IssueID>
        <Title>Naming rules fire on overrides</Title>
        <Description>The naming rules are firing on overrides - instead, it should be firing on the original declaration, the override cannot do anything about the name.

Like we did in FxCop you should also watch out for:

1. C# Implicit interface implementations
2. C# explicit interface implementations
3. VB explicit interface implementation
4. Overrides</Description>
        <CreatedDate>18/11/2016</CreatedDate>
        <ClosedDate>12/01/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>15345</IssueID>
        <Title>Naming rules fire on overrides</Title>
        <Description>The naming rules are firing on overrides - instead, it should be firing on the original declaration, the override cannot do anything about the name.

Like we did in FxCop you should also watch out for:

1. C# Implicit interface implementations
2. C# explicit interface implementations
3. VB explicit interface implementation
4. Overrides</Description>
        <CreatedDate>18/11/2016</CreatedDate>
        <ClosedDate>12/01/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/NamingStyles/NamingStylesTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/NamingStyles/NamingStylesTests_OptionSets.cs</File>
      <File>src/Workspaces/Core/Portable/NamingStyles/NamingStyleRules.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>16407</IssueID>
    <Title>Foreach deconstruction should mark iteration variables as assigned.</Title>
    <Description>Fixes:#16106

**Customer scenario**

When deconstruction is used in a context of foreach, the deconstructed variables are not marked as assigned. As a result, if a deconstruction variable is a struct (KeyValuePair, etc...). Dotting off the variable in the loop body would result in a false definite assignment error.

**Bugs this fixes:** 

#16106

No workarounds other than not using the given language construct when structs are involved.
The bug would block a sizeable fraction of user scenarios for the feature.

**Risk**

The change is specific to the deconstruction foreach. 
It basically just marks the iteration variables introduced by deconstruction all definitely assigned at the beginning of the loop body

**Performance impact**

Low.

**Is this a regression from a previous update?**

**Root cause analysis:**

How did we miss it?  What tests are we adding to guard against it in the future?

The bug is at intersection of "foreach" and "deconstruction" features. It also requires that deconstruction targets are structs. 
We seem to have missed this combination in testing.

**How was the bug found?**

Customer report.</Description>
    <CreatedDate>10/01/2017</CreatedDate>
    <ClosedDate>11/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>16106</IssueID>
        <Title>False error CS0170: Use of possibly unassigned field 'Item1'</Title>
        <Description>```
public class MyClass
{
    public void Test4(IEnumerable&lt;((int, int), string)&gt; en)
    {
        foreach ((ValueTuple&lt;int,int&gt; t, string s) in en)
        {
            var a =t.Item1; // false error CS0170: Use of possibly unassigned field
        }
    }

    public void Test5(IEnumerable&lt;((int, int), string)&gt; en)
    {
        foreach (((int,int) t, string s) in en)
        {
            var a = t.k; // false error CS0170: Use of possibly unassigned field
        }
    }
}
```</Description>
        <CreatedDate>26/12/2016</CreatedDate>
        <ClosedDate>10/01/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>16106</IssueID>
        <Title>False error CS0170: Use of possibly unassigned field 'Item1'</Title>
        <Description>```
public class MyClass
{
    public void Test4(IEnumerable&lt;((int, int), string)&gt; en)
    {
        foreach ((ValueTuple&lt;int,int&gt; t, string s) in en)
        {
            var a =t.Item1; // false error CS0170: Use of possibly unassigned field
        }
    }

    public void Test5(IEnumerable&lt;((int, int), string)&gt; en)
    {
        foreach (((int,int) t, string s) in en)
        {
            var a = t.k; // false error CS0170: Use of possibly unassigned field
        }
    }
}
```</Description>
        <CreatedDate>26/12/2016</CreatedDate>
        <ClosedDate>10/01/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/ForEachLoopBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/Statement.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/DataFlowPass.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/DataFlowsOutWalker.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/PreciseAbstractFlowPass.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/ReadWriteWalker.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/VariablesDeclaredWalker.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_ForEachStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenDeconstructTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/ForEachTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>16381</IssueID>
    <Title>Have Narrator announce that an Inline Rename session has started</Title>
    <Description>Fixes part of #9960

Escrow Template
===========

**Customer scenario**: When a sight-impaired user invokes the Inline Rename command, they have no way of knowing that they've entered Inline Rename mode.

**Bugs this fixes:** This fixes part of #9960

**Workarounds, if any**: None really. The user could just *believe* that inline rename has started and proceed, but that's not really acceptable.

**Risk**: Low. This is at the top of the stack and only impacts accessibility.

**Performance impact**: Essentially none. We now explicitly make an AutomationPeer instead of using the built-in one. I'm not sure if that's an extra allocation or not, but it's only once per Inline Rename session anyway.

**Is this a regression from a previous update?** No

**Root cause analysis:** This was simply not done as part of the original feature work

**How was the bug found?** The Inline Rename Dashboard was known to have accessibility problems internally basically since it was introduced.</Description>
    <CreatedDate>10/01/2017</CreatedDate>
    <ClosedDate>12/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>9960</IssueID>
        <Title>Inline Rename unusable under Narrator</Title>
        <Description>1. No indication that Inline Rename has started
2. No indication that Inline Rename has been cancelled or completed
3. No way to focus the Dashboard &amp; read options
</Description>
        <CreatedDate>22/03/2016</CreatedDate>
        <ClosedDate>26/05/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>9960</IssueID>
        <Title>Inline Rename unusable under Narrator</Title>
        <Description>1. No indication that Inline Rename has started
2. No indication that Inline Rename has been cancelled or completed
3. No way to focus the Dashboard &amp; read options
</Description>
        <CreatedDate>22/03/2016</CreatedDate>
        <ClosedDate>26/05/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/Core/EditorFeaturesResources.Designer.cs</File>
      <File>src/EditorFeatures/Core/Implementation/InlineRename/Dashboard/Dashboard.xaml.cs</File>
      <File>src/EditorFeatures/Core/Implementation/InlineRename/Dashboard/DashboardAutomationPeer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>16380</IssueID>
    <Title>Make the General Code Style &amp; Naming Style options pages accessible</Title>
    <Description>Fixes #13579
Fixes #13099

Fixes for tabbing and Narrator.

Escrow Template
===========

**Customer scenario**: Sight-impaired users could not use the General Code Style &amp; Naming Style option pages.

**Bugs this fixes:**  #13579, #13099

**Workarounds, if any**: None. I suppose the sight-impaired user could find a sighted person to explain what's going on, but that is unacceptable.

**Risk**: Very little. This change is at the very top of the stack, and it doesn't change any non-accessibility-related product functionality.

**Performance impact**: Essentially none. There will be at least one additional allocation every time the option pages are shown, but this is negligible, especially because it's on an infrequent user action. 

**Is this a regression from a previous update?**: No

**Root cause analysis:** This work was simply not done as part of the original feature work for either option page.

**How was the bug found?** Directed testing (thanks @rchande)</Description>
    <CreatedDate>10/01/2017</CreatedDate>
    <ClosedDate>11/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>13579</IssueID>
        <Title>CodeStyle Tools Options window : improve keyboard navigation</Title>
        <Description>1. Have to tab twice to select severity/preference
2. should show drop down on some key (space ?)
</Description>
        <CreatedDate>02/09/2016</CreatedDate>
        <ClosedDate>12/01/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>13099</IssueID>
        <Title>CodeStyle -&gt; General and Naming Styles do not support Narrator</Title>
        <Description>Windows Narrator reads the name of the view model type if you highlight one of these combo boxes.

![image](https://cloud.githubusercontent.com/assets/3751401/17602243/a4ef8d94-5fc0-11e6-9470-3bb0560c0009.png)
</Description>
        <CreatedDate>11/08/2016</CreatedDate>
        <ClosedDate>12/01/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>13579</IssueID>
        <Title>CodeStyle Tools Options window : improve keyboard navigation</Title>
        <Description>1. Have to tab twice to select severity/preference
2. should show drop down on some key (space ?)
</Description>
        <CreatedDate>02/09/2016</CreatedDate>
        <ClosedDate>12/01/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>13099</IssueID>
        <Title>CodeStyle -&gt; General and Naming Styles do not support Narrator</Title>
        <Description>Windows Narrator reads the name of the view model type if you highlight one of these combo boxes.

![image](https://cloud.githubusercontent.com/assets/3751401/17602243/a4ef8d94-5fc0-11e6-9470-3bb0560c0009.png)
</Description>
        <CreatedDate>11/08/2016</CreatedDate>
        <ClosedDate>12/01/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/VisualStudio/Core/Def/ServicesVSResources.Designer.cs</File>
      <File>src/VisualStudio/Core/Impl/Options/ColumnToTabStopConverter.cs</File>
      <File>src/VisualStudio/Core/Impl/Options/Style/NamingPreferences/NamingStyleOptionPageViewModel.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>16357</IssueID>
    <Title>Have VisualStudioDocumentNavigationService perform bounds checks</Title>
    <Description>Fixes #7660
Fixes internal bugs 112211, 136895, 224318, 235409

We have a number of bugs (listed above) that show features trying to
navigate to positions that are not within the bounds of the documents in
which they are navigating. I have not been able to figure out the common
root cause of this problem, but they all flow through the
VisualStudioDocumentNavigationService, so adding bounds checks there
should alleviate the symptoms (reported as crashes, hangs, and error
dialogs).

Ask Mode
============

**Customer scenario**: The customer tries to navigate using the Navigation Bar or initiate a rename in a Razor file, and they are sometimes met with a crash, a hang, or an error dialog. **The total hit count from the Watson is currently 6686**. It is unclear why this only happens occasionally, and we have not been able to reproduce the failure locally.

**Bugs this fixes:** 

#7660
https://devdiv.visualstudio.com/DevDiv/_workitems?id=112211
https://devdiv.visualstudio.com/DevDiv/_workitems?id=136895
https://devdiv.visualstudio.com/DevDiv/_workitems?id=224318
https://devdiv.visualstudio.com/DevDiv/_workitems?id=235409

**Workarounds, if any**: None. The product crashes, hangs, or shows an error dialog.

**Risk**: Fairly low. We now return false instead of true for CanNavigateTo* for ContainedDocuments if their navigation target is outside the bounds of the document, which will cause rename to give a "You cannot rename this element" dialog instead of an "ArgumentOutOfRange" dialog. For the actual TryNavigateTo* methods, we are just adjusting the requested bounds to be within the bounds of the Document's length. In the worst case that I can imagine, we will navigate to the end of the document instead of some non-existent (and crashing) location that was requested of us.

**Performance impact**: Low perf impact, it's just a few math operations and one allocation, and it's only done on infrequent user-initiated actions.

**Is this a regression from a previous update?** No

**Root cause analysis:** We do not understand the root cause at this time. However, this change should address the symptoms being reported by customers (and Watson).

**How was the bug found?** Watson and customer reports</Description>
    <CreatedDate>09/01/2017</CreatedDate>
    <ClosedDate>10/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>7660</IssueID>
        <Title>VS2015.1: ArgumentOutOfRangeException while inline renaming in razor</Title>
        <Description>With `Index.cshtml` looking like

``` cshtml
@using ArgumentOutOfRangeTest.Controllers
@model Some
@Html.GetTest().TestMethod(x =&gt;
{
    x.SomeMethod(new { Controller = "Test", Action = nameof(TestController.Other) });
}).GetHtml()
```

I set the cursor to `Other`, pressed `F2` and got an error MessageBox telling me about a ArgumentOutOfRangeException for parametername position.
Pressing `F2` again, it did the same error again.
Attaching Visual Studio got me this stacktrace:

```
ArgumentOutOfRangeException: param: position
   at Microsoft.VisualStudio.Text.Implementation.BinaryStringRebuilder.GetLineNumberFromPosition(Int32 position)
   at Microsoft.VisualStudio.Text.Implementation.TextSnapshot.GetLineNumberFromPosition(Int32 position)
   at Microsoft.CodeAnalysis.Text.Extensions.SnapshotSourceText.LineInfo.IndexOf(Int32 position)
   at Microsoft.CodeAnalysis.Text.Extensions.SnapshotSourceText.LineInfo.GetLineFromPosition(Int32 position)
   at Microsoft.CodeAnalysis.Shared.Extensions.SourceTextExtensions.GetLineAndOffset(SourceText text, Int32 position, Int32&amp; lineNumber, Int32&amp; offset)
   at Microsoft.VisualStudio.LanguageServices.Implementation.Extensions.SourceTextExtensions.GetVsTextSpanForSpan(SourceText text, TextSpan textSpan)
   at Microsoft.VisualStudio.LanguageServices.Implementation.VisualStudioDocumentNavigationService.CanNavigateToSpan(Workspace workspace, DocumentId documentId, TextSpan textSpan)
   at Microsoft.CodeAnalysis.Editor.Implementation.InlineRename.AbstractEditorInlineRenameService.GetRenameInfo(IEnumerable`1 refactorNotifyServices, Document document, SyntaxToken triggerToken, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Editor.Implementation.InlineRename.AbstractEditorInlineRenameService.GetRenameInfo(Document document, Int32 position, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Editor.Implementation.InlineRename.AbstractEditorInlineRenameService.GetRenameInfoAsync(Document document, Int32 position, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Editor.Implementation.InlineRename.InlineRenameService.StartInlineSession(Document document, TextSpan textSpan, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Editor.Implementation.InlineRename.RenameCommandHandler.ExecuteRenameWorker(RenameCommandArgs args, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Editor.Implementation.InlineRename.RenameCommandHandler.&lt;&gt;c__DisplayClass37_0.&lt;ExecuteCommand&gt;b__0(IWaitContext waitContext)
   at Microsoft.VisualStudio.LanguageServices.Implementation.Utilities.VisualStudioWaitIndicator.Wait(String title, String message, Boolean allowCancel, Action`1 action)
   at Microsoft.CodeAnalysis.Editor.Implementation.InlineRename.RenameCommandHandler.ExecuteCommand(RenameCommandArgs args, Action nextHandler)
   at Microsoft.CodeAnalysis.Editor.Implementation.Commands.CommandHandlerService.ExecuteHandlers[T](IList`1 commandHandlers, T args, Action lastHandler)
   at Microsoft.CodeAnalysis.Editor.Implementation.Commands.CommandHandlerService.Microsoft.CodeAnalysis.Editor.ICommandHandlerService.Execute[T](IContentType contentType, T args, Action lastHandler)
   at Microsoft.VisualStudio.LanguageServices.Implementation.AbstractOleCommandTarget.ExecuteRename(ITextBuffer subjectBuffer, IContentType contentType, Action executeNextCommandTarget)
   at Microsoft.VisualStudio.LanguageServices.Implementation.AbstractOleCommandTarget.ExecuteVisualStudio2000(Guid&amp; pguidCmdGroup, UInt32 commandId, UInt32 executeInformation, IntPtr pvaIn, IntPtr pvaOut, ITextBuffer subjectBuffer, IContentType contentType)
   at Microsoft.VisualStudio.LanguageServices.Implementation.AbstractOleCommandTarget.Exec(Guid&amp; pguidCmdGroup, UInt32 commandId, UInt32 executeInformation, IntPtr pvaIn, IntPtr pvaOut)
   at Microsoft.VisualStudio.Html.Interop.OleToCommandTargetShim.Invoke(Guid group, Int32 id, Object inputArg, Object&amp; outputArg)
   at Microsoft.Html.Editor.Commands.HtmlMainController.Invoke(Guid group, Int32 id, Object inputArg, Object&amp; outputArg)
   at Microsoft.VisualStudio.Html.Interop.CommandTargetToOleShim.Exec(Guid&amp; guidCommandGroup, UInt32 commandID, UInt32 commandExecOpt, IntPtr variantIn, IntPtr variantOut)
   at Microsoft.VisualStudio.Editor.Implementation.CommandChainNode.InnerExec(Guid&amp; pguidCmdGroup, UInt32 nCmdID, UInt32 nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut)
   at Microsoft.VisualStudio.Editor.Implementation.SimpleTextViewWindow.Exec(Guid&amp; pguidCmdGroup, UInt32 nCmdID, UInt32 nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut)
   at Microsoft.VisualStudio.Editor.Implementation.CompoundTextViewWindow.Exec(Guid&amp; pguidCmdGroup, UInt32 nCmdID, UInt32 nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut)
   at Microsoft.VisualStudio.Platform.WindowManagement.DocumentObjectSite.Exec(Guid&amp; pguidCmdGroup, UInt32 nCmdID, UInt32 nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut)
   at Microsoft.VisualStudio.Platform.WindowManagement.WindowFrame.Exec(Guid&amp; pguidCmdGroup, UInt32 nCmdID, UInt32 nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut)
```

While trying to create a minimal reproduction (see `Index.cshtml` above), VS bugged me all the time with an messagebox, telling me `You cannot rename this element` (translated from german).
After restarting Visual Studio it was able to rename it without problems.

Unfortunately i couldn't reproduce it and also the renaming in the originally affected solution worked after restarting Visual Studio, so i'm opening this issue in the hope that someone will figure it out eventually.

EDIT: but i just run into it again so it seems to happen after some time.
</Description>
        <CreatedDate>22/12/2015</CreatedDate>
        <ClosedDate>11/01/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>7660</IssueID>
        <Title>VS2015.1: ArgumentOutOfRangeException while inline renaming in razor</Title>
        <Description>With `Index.cshtml` looking like

``` cshtml
@using ArgumentOutOfRangeTest.Controllers
@model Some
@Html.GetTest().TestMethod(x =&gt;
{
    x.SomeMethod(new { Controller = "Test", Action = nameof(TestController.Other) });
}).GetHtml()
```

I set the cursor to `Other`, pressed `F2` and got an error MessageBox telling me about a ArgumentOutOfRangeException for parametername position.
Pressing `F2` again, it did the same error again.
Attaching Visual Studio got me this stacktrace:

```
ArgumentOutOfRangeException: param: position
   at Microsoft.VisualStudio.Text.Implementation.BinaryStringRebuilder.GetLineNumberFromPosition(Int32 position)
   at Microsoft.VisualStudio.Text.Implementation.TextSnapshot.GetLineNumberFromPosition(Int32 position)
   at Microsoft.CodeAnalysis.Text.Extensions.SnapshotSourceText.LineInfo.IndexOf(Int32 position)
   at Microsoft.CodeAnalysis.Text.Extensions.SnapshotSourceText.LineInfo.GetLineFromPosition(Int32 position)
   at Microsoft.CodeAnalysis.Shared.Extensions.SourceTextExtensions.GetLineAndOffset(SourceText text, Int32 position, Int32&amp; lineNumber, Int32&amp; offset)
   at Microsoft.VisualStudio.LanguageServices.Implementation.Extensions.SourceTextExtensions.GetVsTextSpanForSpan(SourceText text, TextSpan textSpan)
   at Microsoft.VisualStudio.LanguageServices.Implementation.VisualStudioDocumentNavigationService.CanNavigateToSpan(Workspace workspace, DocumentId documentId, TextSpan textSpan)
   at Microsoft.CodeAnalysis.Editor.Implementation.InlineRename.AbstractEditorInlineRenameService.GetRenameInfo(IEnumerable`1 refactorNotifyServices, Document document, SyntaxToken triggerToken, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Editor.Implementation.InlineRename.AbstractEditorInlineRenameService.GetRenameInfo(Document document, Int32 position, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Editor.Implementation.InlineRename.AbstractEditorInlineRenameService.GetRenameInfoAsync(Document document, Int32 position, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Editor.Implementation.InlineRename.InlineRenameService.StartInlineSession(Document document, TextSpan textSpan, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Editor.Implementation.InlineRename.RenameCommandHandler.ExecuteRenameWorker(RenameCommandArgs args, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Editor.Implementation.InlineRename.RenameCommandHandler.&lt;&gt;c__DisplayClass37_0.&lt;ExecuteCommand&gt;b__0(IWaitContext waitContext)
   at Microsoft.VisualStudio.LanguageServices.Implementation.Utilities.VisualStudioWaitIndicator.Wait(String title, String message, Boolean allowCancel, Action`1 action)
   at Microsoft.CodeAnalysis.Editor.Implementation.InlineRename.RenameCommandHandler.ExecuteCommand(RenameCommandArgs args, Action nextHandler)
   at Microsoft.CodeAnalysis.Editor.Implementation.Commands.CommandHandlerService.ExecuteHandlers[T](IList`1 commandHandlers, T args, Action lastHandler)
   at Microsoft.CodeAnalysis.Editor.Implementation.Commands.CommandHandlerService.Microsoft.CodeAnalysis.Editor.ICommandHandlerService.Execute[T](IContentType contentType, T args, Action lastHandler)
   at Microsoft.VisualStudio.LanguageServices.Implementation.AbstractOleCommandTarget.ExecuteRename(ITextBuffer subjectBuffer, IContentType contentType, Action executeNextCommandTarget)
   at Microsoft.VisualStudio.LanguageServices.Implementation.AbstractOleCommandTarget.ExecuteVisualStudio2000(Guid&amp; pguidCmdGroup, UInt32 commandId, UInt32 executeInformation, IntPtr pvaIn, IntPtr pvaOut, ITextBuffer subjectBuffer, IContentType contentType)
   at Microsoft.VisualStudio.LanguageServices.Implementation.AbstractOleCommandTarget.Exec(Guid&amp; pguidCmdGroup, UInt32 commandId, UInt32 executeInformation, IntPtr pvaIn, IntPtr pvaOut)
   at Microsoft.VisualStudio.Html.Interop.OleToCommandTargetShim.Invoke(Guid group, Int32 id, Object inputArg, Object&amp; outputArg)
   at Microsoft.Html.Editor.Commands.HtmlMainController.Invoke(Guid group, Int32 id, Object inputArg, Object&amp; outputArg)
   at Microsoft.VisualStudio.Html.Interop.CommandTargetToOleShim.Exec(Guid&amp; guidCommandGroup, UInt32 commandID, UInt32 commandExecOpt, IntPtr variantIn, IntPtr variantOut)
   at Microsoft.VisualStudio.Editor.Implementation.CommandChainNode.InnerExec(Guid&amp; pguidCmdGroup, UInt32 nCmdID, UInt32 nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut)
   at Microsoft.VisualStudio.Editor.Implementation.SimpleTextViewWindow.Exec(Guid&amp; pguidCmdGroup, UInt32 nCmdID, UInt32 nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut)
   at Microsoft.VisualStudio.Editor.Implementation.CompoundTextViewWindow.Exec(Guid&amp; pguidCmdGroup, UInt32 nCmdID, UInt32 nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut)
   at Microsoft.VisualStudio.Platform.WindowManagement.DocumentObjectSite.Exec(Guid&amp; pguidCmdGroup, UInt32 nCmdID, UInt32 nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut)
   at Microsoft.VisualStudio.Platform.WindowManagement.WindowFrame.Exec(Guid&amp; pguidCmdGroup, UInt32 nCmdID, UInt32 nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut)
```

While trying to create a minimal reproduction (see `Index.cshtml` above), VS bugged me all the time with an messagebox, telling me `You cannot rename this element` (translated from german).
After restarting Visual Studio it was able to rename it without problems.

Unfortunately i couldn't reproduce it and also the renaming in the originally affected solution worked after restarting Visual Studio, so i'm opening this issue in the hope that someone will figure it out eventually.

EDIT: but i just run into it again so it seems to happen after some time.
</Description>
        <CreatedDate>22/12/2015</CreatedDate>
        <ClosedDate>11/01/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/VisualStudio/Core/Def/Implementation/Workspace/VisualStudioDocumentNavigationService.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>15687</IssueID>
    <Title>Add a code refactoring to add argument names</Title>
    <Description>Fixes #9883 (previous PR: #9934)

/cc @CyrusNajmabadi </Description>
    <CreatedDate>05/12/2016</CreatedDate>
    <ClosedDate>09/12/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>9883</IssueID>
        <Title>Request: Analyzer for named arguments</Title>
        <Description>Named arguments are a great feature to write self-documented code, but if the original author didn't write them you should write every argument by hand which is kinda cumbersome. Also, when you write named arguments you might write them in a random order that makes the compiler to introduce locals to preserve side-effects in order. It would be nice to (1) have an analyzer add all named arguments for a method call (2) and suggest correction if they are not in the same order as method parameters.
</Description>
        <CreatedDate>18/03/2016</CreatedDate>
        <ClosedDate>18/03/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>9934</IssueID>
        <Title>Add a code refactoring for adding named arguments</Title>
        <Description>Fixes #9883
</Description>
        <CreatedDate>21/03/2016</CreatedDate>
        <ClosedDate>04/12/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/CodeActions/UseNamedArguments/UseNamedArgumentsTests.cs</File>
      <File>src/EditorFeatures/TestUtilities/Traits.cs</File>
      <File>src/Features/CSharp/Portable/CodeRefactorings/UseNamedArguments/CSharpUseNamedArgumentsCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/CodeRefactorings/UseNamedArguments/AbstractUseNamedArgumentsCodeRefactoringProvider.cs</File>
      <File>src/Features/Core/Portable/FeaturesResources.Designer.cs</File>
      <File>src/Workspaces/CSharp/Portable/Extensions/BaseArgumentListSyntaxExtensions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>15655</IssueID>
    <Title>Add editorconfig option for PreferExplicitTupleName</Title>
    <Description>**Customer scenario**

Allows the user to specify that they want to use explicit tuple names using editorconfig

**Bugs this fixes:** 

#15307

**Workarounds, if any**

Use can specify this option manually in VS.  Changing the option manually for each project.

**Risk**

Low, , it is reusing all existing editoconfig code.

**Performance impact**

Low, it is reusing all existing editoconfig code.

**Is this a regression from a previous update?**

No, this is a follow up to this option being added in PR #15202

**Root cause analysis:**

editor config support for code style options was in review when this was merged into master.

**How was the bug found?**

bug was filed as part of PR #15202
</Description>
    <CreatedDate>03/12/2016</CreatedDate>
    <ClosedDate>08/12/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>15307</IssueID>
        <Title>Need .editor_config option for PreferExplicitTupleName.</Title>
        <Description>Related pr: https://github.com/dotnet/roslyn/pull/15202

@jmarolf </Description>
        <CreatedDate>17/11/2016</CreatedDate>
        <ClosedDate>08/12/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>15202</IssueID>
        <Title>Add a feature to suggest using explicit tuple names when they are available.</Title>
        <Description>
        </Description>
        <CreatedDate>13/11/2016</CreatedDate>
        <ClosedDate>17/11/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>15202</IssueID>
        <Title>Add a feature to suggest using explicit tuple names when they are available.</Title>
        <Description>
        </Description>
        <CreatedDate>13/11/2016</CreatedDate>
        <ClosedDate>17/11/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Workspaces/Core/Portable/CodeStyle/CodeStyleOptions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>15646</IssueID>
    <Title>Fix DeclaredInside for expression variables and deconstruction</Title>
    <Description>@dotnet/roslyn-compiler Please review.

**Customer scenario**

`DeclaredInside` is used for extract method, so the bugs fixed here result in incorrect behavior for that IDE feature. Also, it fixes a `NullReferenceException` that would result in an IDE crash when extract method is used in some circumstances.

**Bugs this fixes:** 

Fixes #12940
Fixes #14110
Fixes #15640

**Workarounds, if any**

Don't use extract method (or any other IDE features that use `DeclaredInside`).

**Risk**

Fairly low; the changes are localized to the affected scenarios, and significantly simplify the implementation.

**Performance impact**

Small. Slightly larger node for `BoundLocal`, which is transiently used during semantic analysis and in the `SemanticModel`

**Is this a regression from a previous update?**

No. The bugs have been present as long as the feature implementations have been in the code base.

**Root cause analysis:**

Implementing this API for expression variables has been a known laggard in the implementation of the new features. Because it wasn't implemented, it also wasn't tested. This PR adds tests for the affected scenarios.

**How was the bug found?**

Ad-hoc and unit testing while completing the feature.
</Description>
    <CreatedDate>02/12/2016</CreatedDate>
    <ClosedDate>15/12/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>12940</IssueID>
        <Title>Missing bound node for out variable declaration</Title>
        <Description>We have a design invariant for the bound nodes that the initial bound tree is roughly isomorphic to the shape of the syntax. We create and retain bound nodes even when they do not represent runtime operations, e.g. local variable declarations.

The out variable declaration is not retained in the initial bound trees. It should be. This would slightly simplify the handling of the diagnostic reporting it being unsupported in expression trees, for example, and would simplify the handling of some error cases in flow analysis. It is necessary for region analysis to compute the "declared inside" property.
</Description>
        <CreatedDate>04/08/2016</CreatedDate>
        <ClosedDate>15/12/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>14110</IssueID>
        <Title>DataFlowAnalysis.VariablesDeclared does not handle deconstruction declarations</Title>
        <Description>The following proposed unit test fails.

``` cs
        [Fact, WorkItem(14110, "https://github.com/dotnet/roslyn/issues/14110")]
        public void Test14110()
        {
            var dataFlowAnalysisResults = CompileAndAnalyzeDataFlowStatements(@"
using System;

class Program
{
    static void Main()
    {
/*&lt;bind&gt;*/
        var (x, y) = (1, 2);
        (var a, var b) = (3, 4);
/*&lt;/bind&gt;*/
        Console.WriteLine(x + a);
    }
}
");
            Assert.Equal("a, b, x, y", GetSymbolNamesJoined(dataFlowAnalysisResults.VariablesDeclared));
        }
```

One symptom of this is #14108.
</Description>
        <CreatedDate>27/09/2016</CreatedDate>
        <ClosedDate>15/12/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>15640</IssueID>
        <Title>NullReferenceException in DeclaredInside for deconstruction foreach loop</Title>
        <Description>The following test fails with a `NullReferenceException`.

```cs
        [Fact, WorkItem(15640, "https://github.com/dotnet/roslyn/issues/15640")]
        public void Test15640()
        {
            var dataFlowAnalysisResults = CompileAndAnalyzeDataFlowStatements(@"
using System;

class Program
{
    static void Main()
    {
/*&lt;bind&gt;*/
        foreach (var (a, b) in new[] { (1, 2) }) {}
/*&lt;/bind&gt;*/
    }
}
");
            Assert.Equal("a, b", GetSymbolNamesJoined(dataFlowAnalysisResults.VariablesDeclared));
        }
```
</Description>
        <CreatedDate>02/12/2016</CreatedDate>
        <ClosedDate>15/12/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Deconstruct.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Expressions.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/BoundExpression.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/DeconstructionVariablePendingInference.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/OutVariablePendingInference.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/VariablesDeclaredWalker.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/FlowAnalysis/RegionAnalysisTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>15548</IssueID>
    <Title>Combine deconstruction assignment and declaration, and support discards.</Title>
    <Description>- Combine deconstruction assignment and declaration, and support discards.
- Because tuples may contain declarations, adjust lambda disambiguation
  and adjust parsing of argument lists.
- Diagnose tuple element names on the left of a deconstruction.
- Add relational operators to disambiguating tokens in 7.5.4.2
- Remove `BoundVoid`

~~Fixes #15548 
Fixes #15549~~

Update (from jcouv): the bug numbers seem wrong. I think the correct ones were #14794
 and #14832

/cc @jcouv @AlekseyTs @VSadov @dotnet/roslyn-compiler </Description>
    <CreatedDate>27/11/2016</CreatedDate>
    <ClosedDate>12/12/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>15548</IssueID>
        <Title>Combine deconstruction assignment and declaration, and support discards.</Title>
        <Description>- Combine deconstruction assignment and declaration, and support discards.
- Because tuples may contain declarations, adjust lambda disambiguation
  and adjust parsing of argument lists.
- Diagnose tuple element names on the left of a deconstruction.
- Add relational operators to disambiguating tokens in 7.5.4.2
- Remove `BoundVoid`

~~Fixes #15548 
Fixes #15549~~

Update (from jcouv): the bug numbers seem wrong. I think the correct ones were #14794
 and #14832

/cc @jcouv @AlekseyTs @VSadov @dotnet/roslyn-compiler </Description>
        <CreatedDate>27/11/2016</CreatedDate>
        <ClosedDate>12/12/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>15549</IssueID>
        <Title>Cleanup in FindReferences engine.</Title>
        <Description>1. For areas where we don't actually use parallalism, remove use of concurrent collections.
We can switch back to concurrent collections if we ever need them.

2. Use using aliases to make types clearer.

3. Simplify how progress was tracked in FAR.</Description>
        <CreatedDate>27/11/2016</CreatedDate>
        <ClosedDate>28/11/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>14794</IssueID>
        <Title>Proposed changes for deconstruction, declaration expressions, and discards</Title>
        <Description>This week's LDM meetings (2016-10-25 and 2016-10-26) proposed some possible changes to the handling of deconstruction, declaration expressions, and wildcards that, even if done later, would affect the shape of compiler APIs today. That suggests we would want to consider what to do today so that we are compatible with that possible future. This is a summary of the proposed changes and their API impact.
### Wildcards

The LDM is proposing to change the character that we would use to represent a "wildcard" from `*` to `_`. We also considered some alternatives, but both `*` and `?` have a logical (if not technical) ambiguity, because `int?` and `int*` are valid types. `_` doesn't likely have the same kind of syntactic ambiguity, because it is already an identifier in all of the places where we want to support wildcards. But it may be a _semantic_ ambiguity for that  same reason. The reason we like `_` is that users already introduce variables, for example parameters, named `_` when their intention is to ignore them.

We want to support both the "short form" `_` and the "long form" `var _` just in case there is an ambiguity with, for example, a field in scope. We'll return to this later.
### Declaration Expressions

We currently represent an out variable declaration using a "declaration expression" node in the syntax model. That was done because we were thinking that we may want to generalize declaration expressions in the future.

There is some slight discomfort with declaration expressions as they appear in the current API and proposed language spec, because while they are expressions in the syntax model, they are not expressions in the draft spec, and do not have types, and therefore there are special rules called out for them wherever they may appear in the specification. Besides the mismatch between the spec and model, we expect we may want to allow declaration expressions in more contexts in the future, in which case we will want them to be treated as expressions. In that case we will be better served by treating them as expressions (i.e. they can have a type) today.
### Deconstruction

Possibly generalizing declaration expressions in the future makes us want to reconsider our syntax model for deconstruction today. For example, given the statement

``` cs
(int x, int y) = e;
```

We can think of this as a special deconstruction declaration statement (as it is today), or alternatively we can think of it as a statement expressions containing an assignment expression with a tuple expression on the left-hand-side. In that case the tuple expression contains two declaration expressions. The latter formulation makes more sense in the possible future in which we generalize declaration expressions.

Similarly, given the statement

``` cs
var (x, y) = e;
```

We can think of this as a special deconstruction declaration statement (as it is today), or alternatively we can think of it as a statement expressions containing an assignment expression with a declaration expression on the left-hand-side. The latter formulation makes more sense in the possible future in which we generalize declaration expressions.

This reformulation of deconstruction allows us to remove from the syntax model the new statement form for a deconstruction declaration. It also allows us to generalize what we allow in the future:

``` cs
int x;
(x, int y) = e;
```

Here, the left-hand-side contains a mixture of already-existing variables (in this case `x`) and newly declared variables (`int y`). And it can be used in an expression context as well (e.g. as the body of an expression-bodied method).
### Wildcards (revisited)

Given this new understanding of the direction of the syntax, there are four forms that wildcards can take. First, it can take the place of an identifier in a _designator_ (i.e. in a declaration expression):

``` cs
var (x, _) = e;
(int x, int _) = e;
M(out int _);
```

Since `_` is already an identifier, no syntax model change is required. However, semantically we want this to create an anonymous variable, and shadow any true variable (e.g. parameter or field) from an enclosing scope named `_`. There is no name conflict error if wildcards are declared this way more than once in a scope.

Second, it can similarly be used to declare a pattern variable:

``` cs
switch (o)
{
    case int _:
    case long _:
        Console.WriteLine("int or long");
        break;
}
```

Third, it can take the place of an identifier in a simple expression where an lvalue is expected and is used as a target in a deconstruction assignment or out parameter, but in that case its special behavior as a wildcard only occurs if looking up `_` doesn't find a variable of that name

``` cs
M(out _);
(x, _) = e;
```

This special name lookup is similar to the way we handle `var`.

Finally, it can be used where a parameter can be declared today. However, we relax the single-definition rule to allow multiple conflicting declarations (same scope or nested scopes), in which case the identifier `_` binds as a wildcard.

``` cs
Func&lt;int, int, int&gt; f = (_,_) =&gt; 3;
```

We have to be careful with these changes so that any program that uses `_` as an identifier and is legal today continues to compile with the same meaning under these revised rules. 
### Syntax model changes

This allows us to simplify the handling of the `for` loop to handle deconstruction. Now the deconstruction is just one of the expressions in the expression list of the initializer part, and doesn't require its own placeholder in the syntax. That means that the syntax node for the `for` loop remains unchanged from the C# 6 version.

This requires a change to the way we handle the deconstruction form of the `foreach` loop. Because we want the left-hand-side to be capable of representing all of these forms

``` cs
foreach ((int x, int y) in e) ...
foreach ((int x, _) in e) ...
foreach (var (x, _) in e) ...
```

we now need to use _expression_ for the syntax node before the `in` keyword.

We can remove the syntax node for the _deconstruction declaration statement_, because that is just an assignment statement in this model.
### Syntax.xml changes

The following changes are proposed compared to the current [implementation in master](https://github.com/dotnet/roslyn/blob/master/src/Compilers/CSharp/Portable/Syntax/Syntax.xml). We **remove**

``` xml
  &lt;AbstractNode Name="VariableComponentSyntax" Base="CSharpSyntaxNode"&gt;
  &lt;/AbstractNode&gt;
  &lt;Node Name="TypedVariableComponentSyntax" Base="VariableComponentSyntax"&gt;
    &lt;Kind Name="TypedVariableComponent"/&gt;
    &lt;Field Name="Type" Type="TypeSyntax"/&gt;
    &lt;Field Name="Designation" Type="VariableDesignationSyntax"/&gt;
  &lt;/Node&gt;
  &lt;Node Name="ParenthesizedVariableComponentSyntax" Base="VariableComponentSyntax"&gt;
    &lt;Kind Name="ParenthesizedVariableComponent"/&gt;
    &lt;Field Name="OpenParenToken" Type="SyntaxToken"&gt;
      &lt;Kind Name="OpenParenToken"/&gt;
    &lt;/Field&gt;
    &lt;Field Name="Variables" Type="SeparatedSyntaxList&amp;lt;VariableComponentSyntax&amp;gt;"/&gt;
    &lt;Field Name="CloseParenToken" Type="SyntaxToken"&gt;
      &lt;Kind Name="CloseParenToken"/&gt;
    &lt;/Field&gt;
  &lt;/Node&gt;
  &lt;Node Name="DeconstructionDeclarationStatementSyntax" Base="StatementSyntax"&gt;
    &lt;Kind Name="DeconstructionDeclarationStatement"/&gt;
    &lt;Field Name="Modifiers" Type="SyntaxList&amp;lt;SyntaxToken&amp;gt;"/&gt;
    &lt;Field Name="Assignment" Type="VariableComponentAssignmentSyntax"/&gt;
    &lt;Field Name="SemicolonToken" Type="SyntaxToken"&gt;
      &lt;Kind Name="SemicolonToken"/&gt;
    &lt;/Field&gt;
  &lt;/Node&gt;
  &lt;Node Name="VariableComponentAssignmentSyntax" Base="CSharpSyntaxNode"&gt;
    &lt;Kind Name="VariableComponentAssignment"/&gt;
    &lt;Field Name="VariableComponent" Type="VariableComponentSyntax"/&gt;
    &lt;Field Name="EqualsToken" Type="SyntaxToken"&gt;
      &lt;Kind Name="EqualsToken"/&gt;
    &lt;/Field&gt;
    &lt;Field Name="Value" Type="ExpressionSyntax"/&gt;
  &lt;/Node&gt;
```

and we remove the `Deconstruction` field from the `ForStatementSyntax`

We change the `VariableComponent` field of `ForEachComponentStatementSyntax` to be an `ExpressionSyntax`, and probably change the name of `ForEachComponentStatementSyntax`.

And we change

``` xml
  &lt;Node Name="DeclarationExpressionSyntax" Base="ExpressionSyntax"&gt;
    &lt;Kind Name="DeclarationExpression"/&gt;
    &lt;Field Name="VariableComponent" Type="VariableComponentSyntax"&gt;
    &lt;/Field&gt;
  &lt;/Node&gt;
```

to

``` xml
  &lt;Node Name="DeclarationExpressionSyntax" Base="ExpressionSyntax"&gt;
    &lt;Kind Name="DeclarationExpression"/&gt;
    &lt;Field Name="Type" Type="TypeSyntax"/&gt;
    &lt;Field Name="Designation" Type="VariableDesignationSyntax"/&gt;
  &lt;/Node&gt;
```

We leave unchanged

``` xml
  &lt;AbstractNode Name="VariableDesignationSyntax" Base="CSharpSyntaxNode"&gt;
  &lt;/AbstractNode&gt;
  &lt;Node Name="SingleVariableDesignationSyntax" Base="VariableDesignationSyntax"&gt;
    &lt;Kind Name="SingleVariableDesignation"/&gt;
    &lt;Field Name="Identifier" Type="SyntaxToken"&gt;
      &lt;Kind Name="IdentifierToken"/&gt;
    &lt;/Field&gt;
  &lt;/Node&gt;
  &lt;Node Name="ParenthesizedVariableDesignationSyntax" Base="VariableDesignationSyntax"&gt;
    &lt;Kind Name="ParenthesizedVariableDesignation"/&gt;
    &lt;Field Name="OpenParenToken" Type="SyntaxToken"&gt;
      &lt;Kind Name="OpenParenToken"/&gt;
    &lt;/Field&gt;
    &lt;Field Name="Variables" Type="SeparatedSyntaxList&amp;lt;VariableDesignationSyntax&amp;gt;"/&gt;
    &lt;Field Name="CloseParenToken" Type="SyntaxToken"&gt;
      &lt;Kind Name="CloseParenToken"/&gt;
    &lt;/Field&gt;
  &lt;/Node&gt;
```
### SemanticModel changes

We may want to change the behavior of `GetTypeInfo` on a declaration expression, depending on how the shape of the specification evolves.

We probably need to consider what the behavior of `SemanticModel` APIs should be on wildcards.
### Summary

The changes to declaration expressions and deconstruction should be done today so that we don't have an incompatible change later.

Wildcards are an interesting problem. Even if we don't want to implement them for C# 7, we want to wall off the semantic space so that valid C# 7 programs don't change meaning or become invalid in a later language version. I suspect the simplest way to do that is to implement wildcards today.

/cc @dotnet/ldm @dotnet/roslyn-compiler 
</Description>
        <CreatedDate>28/10/2016</CreatedDate>
        <ClosedDate>14/01/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>14832</IssueID>
        <Title>Work Breakdown for "Proposed changes for deconstruction, declaration expressions, and discards"</Title>
        <Description>This is a breakdown of the work needed to implement the changes described in https://github.com/dotnet/roslyn/issues/14794 ("Proposed changes for deconstruction, declaration expressions, and wildcards")

### Language design loose ends

- [x] We need to specify more precisely the interaction of existing declarations (named `_`) with wildcards. (1 LDM meeting or less)
- [x] We should record the spec decisions in a suite of tests that describe the principal design points. (&lt; 1 day)
- [x] There are some [parsing ambiguity resolutions](https://github.com/dotnet/roslyn/issues/14794#issuecomment-257030797) that need to be decided and implemented. (&lt; 1 day)

### Syntax and parser changes

- [x] The syntax changes described in that issue need to be made in Syntax.xml (&lt; 1 day)
- [x] Corresponding changes to the parser need to be made. (&lt; 1 day)
  - [x] For the purpose of parsing, a declaration expression should be accepted in a tuple literal
- [x] Tests need to be modified and augmented to reflect these changes (&lt; 1 day)
- [x] There are no parser changes needed to support wildcards.

### Semantic analysis changes

- [x] Semantic analysis should reject a declaration expression in a tuple literal except in a deconstruction context, which is (&lt; 1 day)
  - [x] On the left-hand-side of an assignment expression
  - [x] In the variable of a `foreach` statement (which is now an ExpressionSyntax)
  - [x] A declaration expression is permitted in an out argument
  - [x] Other contexts will be an error, but may be supported in the future
- [x] Binding of a deconstruction assignment needs to be modified to support a mixture of existing variables (i.e. lvalue expressions), wildcards, and declaration expressions. (&lt; 4 days)
- [x] (requires LDM review) Pattern, out, and deconstruction variables that are declared but not used should cause a warning to be produced (because if you didn't want to use the variable you could have used a wildcard). (&lt; 1 day)

### Scoping changes

There are a number of changes related to the scoping of `_` as an identifier.
- [x] Remove support for the deconstruction declaration statement. It is a special case of an expression statement. (&lt; 1 day)
- [x] When binding an lvalue for a deconstruction or out argument, if we are looking up the simple identifier `_` and find nothing, we treat it as a target-typed wildcard rather than an error. (&lt; 1 day)
  - [x] This probably requires a new bound node, so that its type can be inferred for the purposes of lowering and the `SemanticModel`
- [x] When a declaration expression for an out argument or in a tuple expression declares `_`, we treat it as a wildcard.
- [ ] Permit multiple declarations for `_` lambda parameters, but they introduce nothing into scope. (&lt; 2 days) https://github.com/dotnet/roslyn/issues/16255
- [x] Debuggers should ignore wildcards, except lambda parameters should be displayed as `_`. (&lt; 2 days)
- [x] There are probably other scope-related behavioral changes for `_` that need to be specified and implemented. (&lt; 4 days)
- [x] Although it is proposed to support wildcards in lambda parameters such as `(_,_)=&gt;1`, I propose we not implement that in the first iteration of changes. It is a separable and compatible change that can be done in the next iteration.

### Lowering changes

- [x] Remove support for deconstruction declaration. (&lt; 1 day)
- [x] Generalize the assignment expression to allow declaration expressions and wildcards inside a tuple lvalue. (&lt; 1 day when done together with related binding changes)
- [x] We should be careful to retain the optimization that we do not construct a tuple result of a deconstruction assignment when it is in a context that discards the value.

### Semantic Model changes

The behavior for the semantic model needs to be decided in a design meeting among compiler folks and IDE people.

- [x] GetTypeInfo on a NameSyntax that is a wildcard should give the type of the discarded value. (&lt; 1 day)
- [x] We need to define the behavior for a declaration expression whose identifier is `_`.
- [x] GetTypeInfo on a declaration expression that is not a tuple should give the type of the variable.
- [x] GetTypeInfo on a declaration expression that is a tuple (e.g. `var (x, (y, _))`) should give the type of the consumed tuple value.
- [x] We need to define and implement the behavior for a tuple designator, like `(y, _)` in `var (x, (y, _))`.
- [x] Need tests to confirm that SemanticModel behavior (e.g. GetTypeInfo) works for non-declaration discard expressions in deconstruction expression, foreach loop, and for loop initializer.

### IDE impact (per @CyrusNajmabadi)

IDE impact for existing features is fairly superficial. The IDE tests are mostly behavioral, and virtually all of them of them remain correct in their current form. Most of the changes will just "work right" once the `SemanticModel` has been adjusted to implement behavior for the new features. (&lt; 2 days)

The rename refactoring will have to be modified to prevent you from renaming something to `_` unless it has no references.

There will be some opportunities for new features. For example, fixing a "pattern/out/deconstruction variable declared but not used" warning would be a small refactor that changes it to use a wildcard (i.e. rename it to `_`). That is a new feature, optional, and not required as part of this work.

### Other items to follow-up on:
- [x] Consider renaming `IDiscardedSymbol` to `IDiscardSymbol`

### Overall estimate

This assumes work done by area owners

Language design wrapup &lt; 1 day
Syntax changes &lt; 3 days
Scope changes &lt; 4 days
Semantics changes &lt; 4 days
Lowering changes &lt; 4 days
IDE changes &lt; 2 days

If the work herein is shared among area owners (e.g. scope work done or assisted by @AlekseyTs, deconstruction lowering done or assisted by @jcouv) this work can be largely completed over the duration of one sprint; it is less than one half of the team's work for the duration of a sprint, with a few smaller issues trailing into the following sprint.
</Description>
        <CreatedDate>31/10/2016</CreatedDate>
        <ClosedDate>24/01/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Deconstruct.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Expressions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Invocation.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Patterns.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Statements.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/ExpressionVariableFinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/ForEachLoopBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/OverloadResolution/OverloadResolution.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/OverloadResolution/OverloadResolutionResult.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/BoundDiscardExpression.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/Expression.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/Formatting.cs</File>
      <File>src/Compilers/CSharp/Portable/CSharpResources.Designer.cs</File>
      <File>src/Compilers/CSharp/Portable/CodeGen/EmitExpression.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/ErrorCode.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/MessageID.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/PreciseAbstractFlowPass.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_AssignmentOperator.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_DeconstructionAssignmentOperator.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_Patterns.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LoweredDynamicOperationFactory.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/SyntheticBoundNodeFactory.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/LanguageParser.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/LanguageParser_Patterns.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/SyntaxParser.cs</File>
      <File>src/Compilers/CSharp/Portable/SymbolDisplay/SymbolDisplayVisitor.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/DiscardSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceLocalSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Symbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/SymbolVisitor.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/SymbolVisitor`1.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/SymbolVisitor`2.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/InternalSyntax/TypeSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/SyntaxExtensions.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/SyntaxKind.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/TypeSyntax.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenDeconstructTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTupleTest.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Diagnostics/DiagnosticAnalyzerTests.AllInOne.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/DeconstructionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/ForEachTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/LocalFunctionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/OutVarTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTestBase.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests_Global.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests_Scope.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternSwitchTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/Source/FieldTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/AwaitParsingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/DeclarationExpressionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/DeconstructionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/LambdaParameterParsingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/LocalFunctionParsingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/ParserErrorMessageTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/ParsingErrorRecoveryTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/ParsingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/PatternParsingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/SeparatedSyntaxListParsingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/ValueTupleTests.cs</File>
      <File>src/Compilers/Core/Portable/Symbols/IDiscardSymbol.cs</File>
      <File>src/Compilers/Core/Portable/Symbols/SymbolKind.cs</File>
      <File>src/Compilers/Core/Portable/Symbols/SymbolVisitor.cs</File>
      <File>src/Compilers/Core/Portable/Symbols/SymbolVisitor`1.cs</File>
      <File>src/EditorFeatures/CSharpTest/Completion/CompletionProviders/SymbolCompletionProviderTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/DiagnosticAnalyzerDriver/DiagnosticAnalyzerDriverTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/GenerateMethod/GenerateMethodTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Formatting/Indentation/SmartIndenterTests.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Source/ExpressionCompiler/EvaluationContext.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Source/ExpressionCompiler/Rewriters/MayHaveSideEffectsVisitor.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Test/ExpressionCompiler/DeclarationTests.cs</File>
      <File>src/Workspaces/CSharp/Portable/Extensions/ContextQuery/SyntaxTreeExtensions.cs</File>
      <File>src/Workspaces/CSharp/Portable/LanguageServices/CSharpTypeInferenceService.TypeInferrer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>15257</IssueID>
    <Title>Localize code style option previews</Title>
    <Description>Fixes part 3 of #9674

## Ask Mode Info

**Customer scenario**: The previews for Code Styles were not localized, making it hard for non-English users to understand which choice resulted in which code.
**Bugs this fixes**: Part 3 of #9674
**Workarounds**: None
**Risk**: Very low
**Performance impact**: None.
**Is this a regression from a previous update?**: No, this has been broken since the UI was introduced
**Root cause analysis**: It was skipped as part of the original feature work.
**How was the bug found?**: Ad hoc testing (see screenshot from #9674)</Description>
    <CreatedDate>15/11/2016</CreatedDate>
    <ClosedDate>07/12/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>9674</IssueID>
        <Title>[PR Available] Missing localization in new Code Style UX</Title>
        <Description>**Version Used**: Current code from 2.0 Milestone

![image](https://cloud.githubusercontent.com/assets/235241/13687249/075307ce-e6cf-11e5-86ab-05b8e60b74a2.png)

Not positive about 2, maybe those terms don't normally get loc'd? Need to check...
</Description>
        <CreatedDate>10/03/2016</CreatedDate>
        <ClosedDate>08/12/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>9674</IssueID>
        <Title>[PR Available] Missing localization in new Code Style UX</Title>
        <Description>**Version Used**: Current code from 2.0 Milestone

![image](https://cloud.githubusercontent.com/assets/235241/13687249/075307ce-e6cf-11e5-86ab-05b8e60b74a2.png)

Not positive about 2, maybe those terms don't normally get loc'd? Need to check...
</Description>
        <CreatedDate>10/03/2016</CreatedDate>
        <ClosedDate>08/12/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>9674</IssueID>
        <Title>[PR Available] Missing localization in new Code Style UX</Title>
        <Description>**Version Used**: Current code from 2.0 Milestone

![image](https://cloud.githubusercontent.com/assets/235241/13687249/075307ce-e6cf-11e5-86ab-05b8e60b74a2.png)

Not positive about 2, maybe those terms don't normally get loc'd? Need to check...
</Description>
        <CreatedDate>10/03/2016</CreatedDate>
        <ClosedDate>08/12/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/VisualStudio/CSharp/Impl/Options/Formatting/StyleViewModel.cs</File>
      <File>src/VisualStudio/Core/Def/ServicesVSResources.Designer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>10053</IssueID>
    <Title>Change Signature - Show ref returns in signature preview</Title>
    <Description>Fixes #8437

## Ask Mode Info

**Customer scenario**: The signature preview in Change Signature will now accurately reflect the ref return-ness of the method being updated.
**Bugs this fixes**: #8437
**Workarounds**: None
**Risk**: Very low, it's just consuming a simple new API in symbol display from the compiler.
**Performance impact**: None.
**Is this a regression from a previous update?**: No, this has been broken since we introduced ref returns.
**Root cause analysis**: It was not implemented as part of the original ref returns work.
**How was the bug found?**: Initial testing of ref returns.</Description>
    <CreatedDate>24/03/2016</CreatedDate>
    <ClosedDate>07/12/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>8437</IssueID>
        <Title>[PR Available] Ref returns/locals: Change Signature - "ref" not shown in updated signature preview</Title>
        <Description>![image](https://cloud.githubusercontent.com/assets/235241/12863164/af07f38e-cc27-11e5-86f1-6c8d8a9a39d9.png)
</Description>
        <CreatedDate>06/02/2016</CreatedDate>
        <ClosedDate>07/12/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>8437</IssueID>
        <Title>[PR Available] Ref returns/locals: Change Signature - "ref" not shown in updated signature preview</Title>
        <Description>![image](https://cloud.githubusercontent.com/assets/235241/12863164/af07f38e-cc27-11e5-86f1-6c8d8a9a39d9.png)
</Description>
        <CreatedDate>06/02/2016</CreatedDate>
        <ClosedDate>07/12/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/VisualStudio/Core/Def/Implementation/ChangeSignature/ChangeSignatureDialogViewModel.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>15597</IssueID>
    <Title>Port 3 fixes from master to rc2</Title>
    <Description>**Customer scenario**

it fixes 2 customer issues.

1. random crash when user builds solution using special "devenv /build" command line argument (#15490)
2. various issues reported from new OOP features released in RC (#14978, #15110).

**Bugs this fixes:** 
#15490, #14978, #15110

**Workarounds, if any**
there is no workaround. these fixes are better to be in early so that we can catch more issues before RTM.

**Risk**

Fix for the first issue is very low risk. simple and very specific fix. no broad impact.
Fix for the second issue will not make OOP any less stable than before. it either makes it more stable or let us have better dump if it happens again. 

**Performance impact**

these fixes are not related to any major perf releated code.

**Is this a regression from a previous update?**
No. both of them are issues we first found out. especially second fix is for feature which released in RC.

**Root cause analysis:**
issue for the first fix is due to a race. 
OOP related issues has multiple root causes. one is due to some failure in service hub, another is due to us not setting option correctly in some code path or not catching exception we should have and etc.

How did we miss it?  What tests are we adding to guard against it in the future?
race is hard to test and catch. OOP is new feature so there were missing test holes and pattern we didn't thought of.

unit tests are added for found issues.

**How was the bug found?**
customer reports and watsons.
</Description>
    <CreatedDate>30/11/2016</CreatedDate>
    <ClosedDate>30/11/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>15490</IssueID>
        <Title>random crash on devenv /build</Title>
        <Description>**Version Used**: 
VS 2017 RC

this bug is from customer report.

...

It  appears that devenv.exe will crash periodically when it is used to invoke a build, and there is a C# project present in the solution.
The failures are intermittent and we saw them happening about once in 3-10 builds on our virtual machines 
 
The command line that we  used  to reproduce the issue (multiple times):
"C:\Program Files (x86)\Microsoft Visual Studio\2017\Enterprise\Common7\IDE\devenv.com" "C:\Users\Administrator\Documents\Visual Studio 2017\Projects\ConsoleApplication2\ConsoleApplication2.sln" /rebuild  "Debug|x86" 

We saw this sort of behavior even with solutions that consist of a single C# console application project.
The devenv.exe build with which we saw the problem is  15.0.25909.2 

As IncrediBuild invokes a DevEnv command for every executed build, IncrediBuild will fail whenever DevEnv crashes.

</Description>
        <CreatedDate>23/11/2016</CreatedDate>
        <ClosedDate>28/11/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>14978</IssueID>
        <Title>Fix All for Code Styles is broken</Title>
        <Description>If I `Ctrl+.` to convert 'var' to 'explicit' type and then 'Fix All in Document', the entire lightbulb menu+preview dialog disappears and nothing happens (no code fix is applied). </Description>
        <CreatedDate>04/11/2016</CreatedDate>
        <ClosedDate>29/11/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>15110</IssueID>
        <Title>fixed 2 known OOP issues</Title>
        <Description>1. there is a known issue where RequestServiceAsync might fail randomly.
   people are looking at the root cause, but until that is fixed,
   we will retry rather than failing right away.

2. if we close named pipe stream in the middle of object writer/reader is
   using them, we can get various exceptions. make sure we check cancellation
   before propagating that exception.</Description>
        <CreatedDate>09/11/2016</CreatedDate>
        <ClosedDate>28/11/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>15490</IssueID>
        <Title>random crash on devenv /build</Title>
        <Description>**Version Used**: 
VS 2017 RC

this bug is from customer report.

...

It  appears that devenv.exe will crash periodically when it is used to invoke a build, and there is a C# project present in the solution.
The failures are intermittent and we saw them happening about once in 3-10 builds on our virtual machines 
 
The command line that we  used  to reproduce the issue (multiple times):
"C:\Program Files (x86)\Microsoft Visual Studio\2017\Enterprise\Common7\IDE\devenv.com" "C:\Users\Administrator\Documents\Visual Studio 2017\Projects\ConsoleApplication2\ConsoleApplication2.sln" /rebuild  "Debug|x86" 

We saw this sort of behavior even with solutions that consist of a single C# console application project.
The devenv.exe build with which we saw the problem is  15.0.25909.2 

As IncrediBuild invokes a DevEnv command for every executed build, IncrediBuild will fail whenever DevEnv crashes.

</Description>
        <CreatedDate>23/11/2016</CreatedDate>
        <ClosedDate>28/11/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>14978</IssueID>
        <Title>Fix All for Code Styles is broken</Title>
        <Description>If I `Ctrl+.` to convert 'var' to 'explicit' type and then 'Fix All in Document', the entire lightbulb menu+preview dialog disappears and nothing happens (no code fix is applied). </Description>
        <CreatedDate>04/11/2016</CreatedDate>
        <ClosedDate>29/11/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>15110</IssueID>
        <Title>fixed 2 known OOP issues</Title>
        <Description>1. there is a known issue where RequestServiceAsync might fail randomly.
   people are looking at the root cause, but until that is fixed,
   we will retry rather than failing right away.

2. if we close named pipe stream in the middle of object writer/reader is
   using them, we can get various exceptions. make sure we check cancellation
   before propagating that exception.</Description>
        <CreatedDate>09/11/2016</CreatedDate>
        <ClosedDate>28/11/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Features/Core/Portable/SolutionCrawler/WorkCoordinator.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/LanguageService/AbstractPackage`2.cs</File>
      <File>src/VisualStudio/Core/Next/Remote/ServiceHubRemoteHostClient.cs</File>
      <File>src/Workspaces/Remote/Core/Services/SolutionService.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Services/CodeAnalysisService_Diagnostics.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Services/ServiceHubServiceBase.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Shared/Extensions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>15584</IssueID>
    <Title>Ignore use-before-declaration in local functions (#15339)</Title>
    <Description>Prior to C# 7 we tried to avoid giving duplicate errors
when the user used a variable before it was declared (which
is both a use-before-declared and a use-before-assigned error),
but the line here is blurred with local functions, which can
use variables before they are declared in subtle ways that can't
be detected based on declaration order in syntax.

It may be possible to provide the earlier behavior, but the
current optimization is definitely insufficient and hides
legitimate errors in user programs.

Fixes #15298
Fixes #15322

(cherry picked from commit 1c8372cea14d7b75e8b55c6c38314291af165d5f)</Description>
    <CreatedDate>29/11/2016</CreatedDate>
    <ClosedDate>30/11/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>15298</IssueID>
        <Title>Call to local function referencing then-undeclared variable incorrectly allowed</Title>
        <Description>**Version Used**: 2.0.0.61104 - which is in the recent VS2017RC release.

(Don't have a dev build set up, so I apologize if this has been fixed already - scanned through local function issues and couldn't find any related items, and didn't quickly see any tests with this specific case)

**Repro code**:

```csharp
class Program
{
    static void Main(string[] args)
    {
        Foo();
        int x = 2;
        void Foo() =&gt; System.Console.WriteLine(x); // prints "0"
    }
}
```

**Expected Behavior**:

Something similar to the following example:

```csharp
class Program
{
    static void Main(string[] args)
    {
        int x;
        Foo(); // CS0165: Use of unassigned local variable 'x'
        x = 2;
        void Foo() =&gt; System.Console.WriteLine(x);
    }
}
```

Ping @dotnet/roslyn-compiler - probably @agocke in particular?</Description>
        <CreatedDate>16/11/2016</CreatedDate>
        <ClosedDate>29/11/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>15322</IssueID>
        <Title>Roslyn fails to enforce definitely assigned rules and cannot emit code for local functions with closures over pattern variables in switch statements</Title>
        <Description>Following code should have error CS0165: Use of unassigned local variable 'x'

```cs
class Program
{
    static void Main(object[] args)
    {
        switch(args[0])
        {
            case string x:
                Foo(); // missing error
                break;
            case int x:
                void Foo() =&gt; System.Console.WriteLine(x);
                break;
        }
    }
}
```

Roslyn doesn't detect the error and fails to compile the code, this is VS2017 RC output:
```
csc.exe exited with code 255
```

Note that if you reorder the cases you get correct error i.e.
```cs
class Program
{
    static void Main(object[] args)
    {
        switch(args[0])
        {
            case int x:
                void Foo() =&gt; System.Console.WriteLine(x);
                break;
            case string x:
                Foo(); // error CS0165: Use of unassigned local variable 'x'
                break;
        }
    }
}
```

TryRoslyn emits following stacktrace for original code (it may be a bit outdated though):
```
The given key was not present in the dictionary. 
at System.Collections.Generic.Dictionary`2.get_Item(TKey key) 
at Microsoft.CodeAnalysis.CodeGen.LocalSlotManager.GetLocal(ILocalSymbol symbol) in ...\Src\Compilers\Core\Portable\CodeGen\LocalSlotManager.cs:line 148 
at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.GetLocal(LocalSymbol symbol) in ...\Src\Compilers\CSharp\Portable\CodeGen\EmitStatement.cs:line 1387 
at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.GetLocal(BoundLocal localExpression) in ...\Src\Compilers\CSharp\Portable\CodeGen\EmitStatement.cs:line 1382 
at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitLocalAddress(BoundLocal localAccess) in ...\Src\Compilers\CSharp\Portable\CodeGen\EmitAddress.cs:line 167 
at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitAddress(BoundExpression expression, AddressKind addressKind) in ...\Src\Compilers\CSharp\Portable\CodeGen\EmitAddress.cs:line 38 
at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitArgument(BoundExpression argument, RefKind refKind) in ...\Src\Compilers\CSharp\Portable\CodeGen\EmitExpression.cs:line 594 
at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitArguments(ImmutableArray`1 arguments, ImmutableArray`1 parameters) in ...\Src\Compilers\CSharp\Portable\CodeGen\EmitExpression.cs:line 769 
at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitCallExpression(BoundCall call, UseKind useKind) in ...\Src\Compilers\CSharp\Portable\CodeGen\EmitExpression.cs:line 1480 
at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitExpressionCore(BoundExpression expression, Boolean used) in ...\Src\Compilers\CSharp\Portable\CodeGen\EmitExpression.cs:line 92 
at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitExpressionCoreWithStackGuard(BoundExpression expression, Boolean used) in ...\Src\Compilers\CSharp\Portable\CodeGen\EmitExpression.cs:line 72 
at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitExpression(BoundExpression expression, Boolean used) in ...\Src\Compilers\CSharp\Portable\CodeGen\EmitExpression.cs:line 60 
```

ping @agocke </Description>
        <CreatedDate>17/11/2016</CreatedDate>
        <ClosedDate>29/11/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/DataFlowPass.LocalFunctions.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/DataFlowPass.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenLocalFunctionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/FlowAnalysis/LocalFunctions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>15501</IssueID>
    <Title>Address issues with SemanticModel behavior around TupleElementSyntax.</Title>
    <Description>Fixes #14881.
Fixes #15476.

@dotnet/roslyn-compiler, @VSadov, @jcouv Please review.
  </Description>
    <CreatedDate>23/11/2016</CreatedDate>
    <ClosedDate>28/11/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>14881</IssueID>
        <Title>Tuple member highlighting and find refs gets confused if there's a local with same name</Title>
        <Description>**Version Used**: 

**Steps to Reproduce**:

```
using System;

static class Program
{
    static void Main()
    {
        (int foo, int bar) tuple;
        int bar;

        tuple = (5, 6);
        tuple.bar = 23;
        bar = 10;

        Console.WriteLine(tuple.bar);
        Console.WriteLine(bar);
    }
}
```

Put you cursor on the various `bar`s. See what gets highlighted, and what's shown if Find References is invoked.

**Expected Behavior**: The highlighter and find references logic should always be able to select the right `bar`s.

**Actual Behavior**: In most cases, the highlighting and find refs logic gets very confused and highlights both `bar` declarations. It only seems to be correct when the cursor is on `tuple.b$$ar` expressions.

Possibly related to #10576.
</Description>
        <CreatedDate>02/11/2016</CreatedDate>
        <ClosedDate>28/11/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>15476</IssueID>
        <Title>GetDeclaredSymbol should work for tuple elements in a TupleTypeSyntax</Title>
        <Description>This is related to https://github.com/dotnet/roslyn/issues/14881

We should make sure that GetDeclaredSymbol  API works for tuple elements in TupleTypeSyntax.

NOTE: this applies to both VB and C#</Description>
        <CreatedDate>22/11/2016</CreatedDate>
        <ClosedDate>28/11/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Symbols.cs</File>
      <File>src/Compilers/CSharp/Portable/CSharpExtensions.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/CSharpSemanticModel.cs</File>
      <File>src/Compilers/CSharp/Portable/GlobalSuppressions.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/LanguageParser.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTupleTest.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/DeconstructionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/StatementParsingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/ValueTupleTests.cs</File>
      <File>src/Workspaces/CSharp/Portable/Extensions/ITypeSymbolExtensions.TypeSyntaxGeneratorVisitor.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>15454</IssueID>
    <Title>Adapting discard branch to latest RC2 changes</Title>
    <Description>In order to clean up the features/wildcard branch and allow for a PR to dev15-rc2, I reset the branch to latest RC2 (Jason's change below), cherry-picked four discard changes, and I'm doing a PR for the last change (to run everything through CI).


```
commit 19c9c3f93b1ca04ec3493170441adb5dd5f153d5
Author: Julien Couvreur &lt;julien.couvreur@gmail.com&gt;
Date:   Mon Nov 21 21:18:53 2016 -0800

    Adapting discard branch to latest RC2 changes


commit 993daf631e36f33dd264abc141fb04617e3287e7
Author: Julien Couvreur &lt;jcouv@users.noreply.github.com&gt;
Date:   Mon Nov 21 20:23:17 2016 -0800

    Removing PROTOTYPE markers (#15452)

commit 3a8774eefaeb22f10fcb4b8433a68a9e666616f6
Author: Julien Couvreur &lt;jcouv@users.noreply.github.com&gt;
Date:   Mon Nov 21 19:33:18 2016 -0800

    Discard in deconstruction, out var and patterns  (#15192)

commit 278f9a14d4d3781848592aaadd57ab6729b6cc13
Author: Neal Gafter &lt;neal@gafter.com&gt;
Date:   Wed Nov 16 10:12:54 2016 -0800

    Add IDiscardedSymbol and initial discard binding (#15139)

    Fixes #7895

commit 59a2a0c7679db6d763254fe99acd05ecda9c23d3
Author: Neal Gafter &lt;neal@gafter.com&gt;
Date:   Thu Nov 10 08:49:35 2016 -0800

    Use a DesignatorSyntax for declaration patterns, and add DiscardedToken for wildcards (#15107)

    Also add wildcards.work.md to track outstanding work.

commit 29e1cfd0fa546fc691c2ffc2a1f0f09c57e1ca2b
Merge: abf9a6b 390f4d5
Author: Jason Malinowski &lt;jason@jason-m.com&gt;
Date:   Mon Nov 21 17:15:04 2016 -0800

    Merge pull request #15382 from jasonmalinowski/fix-temppe-crash

    Don't crash if we can't resolve a file during a TempPE build
```

If this needs to be undone for some reason, the last commits on the features/wildcard branch were:
```
commit a81226771b7bbbe0c8a17ceaf658a1058e5eb647
Author: Julien Couvreur &lt;jcouv@users.noreply.github.com&gt;
Date:   Mon Nov 21 20:23:17 2016 -0800

    Removing PROTOTYPE markers (#15452)

commit 3ec7cb47af26d3ad7e696ee5b81e097c80a271b5
Author: Julien Couvreur &lt;jcouv@users.noreply.github.com&gt;
Date:   Mon Nov 21 19:33:18 2016 -0800

    Discard in deconstruction, out var and patterns  (#15192)
```</Description>
    <CreatedDate>22/11/2016</CreatedDate>
    <ClosedDate>22/11/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>15452</IssueID>
        <Title>Removing PROTOTYPE markers</Title>
        <Description>@dotnet/roslyn-compiler for review (a single review should be good, since only updating comments). Then I can make a PR to push discards to RC2.</Description>
        <CreatedDate>22/11/2016</CreatedDate>
        <ClosedDate>22/11/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>15192</IssueID>
        <Title>Discard in deconstruction and out var </Title>
        <Description>Adds binding and lowering logic to support discards in deconstruction, out var and assignment.

```C#
(var x, var _, _) = e;
foreach ((var y, var _, _) in e) { }
M(out var _, out _);
_ = e;
```

Some test code is commented out (with PROTOTYPE marker) until semantic model is updated (`GetTypeInfo` and `GetSymbolInfo`).

From discussion with Neal, we won't do `case _:` for now (he'll ping LDM).

@dotnet/roslyn-compiler for review.</Description>
        <CreatedDate>12/11/2016</CreatedDate>
        <ClosedDate>22/11/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>15139</IssueID>
        <Title>Add IDiscardedSymbol</Title>
        <Description>Added IDiscardedSymbol, DiscardedSymbol.cs, BoundDiscardedExpression, and some of the binding logic.
Note that the implementation is incomplete and tests are still absent, as described in the .work.md document. This is intended to provide the public API changes and to help unblock further concurrent development.

@jcouv @dotnet/roslyn-compiler Please review.</Description>
        <CreatedDate>10/11/2016</CreatedDate>
        <ClosedDate>16/11/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>7895</IssueID>
        <Title>Local variable type is bound twice</Title>
        <Description>The type of a local variable is bound _twice_ in the C# compiler. Here are the two places

In Binder_Statements.cs

``` cs
        private BoundStatement BindDeclarationStatement(LocalDeclarationStatementSyntax node, DiagnosticBag diagnostics)
        {
            var typeSyntax = node.Declaration.Type;
            bool isConst = node.IsConst;

            bool isVar;
            AliasSymbol alias;
            TypeSymbol declType = BindVariableType(node, diagnostics, typeSyntax, ref isConst, isVar: out isVar, alias: out alias);
```

In SourceLocalSymbol.cs (where diagnostics are computed and dropped on the floor):

``` cs
        private TypeSymbol GetTypeSymbol()
        {
            var diagnostics = DiagnosticBag.GetInstance();

            Binder typeBinder = this.binder;

            bool isVar;
            TypeSymbol declType = typeBinder.BindType(_typeSyntax, diagnostics, out isVar);
```

For efficiency the compiler should bind each construct once.
</Description>
        <CreatedDate>12/01/2016</CreatedDate>
        <ClosedDate>18/01/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>15107</IssueID>
        <Title>Use a DesignatorSyntax for declaration patterns, and add DiscardedToken for wildcards</Title>
        <Description>This is a syntax model change for pattern-matching is the next step in order to add wildcards.

@dotnet/roslyn-compiler Please review.</Description>
        <CreatedDate>09/11/2016</CreatedDate>
        <ClosedDate>10/11/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>15382</IssueID>
        <Title>Don't crash if we can't resolve a file during a TempPE build</Title>
        <Description>Since this involves the filesystem, there's always the possibility
the file might disappear out from underneath you. Let's accept that
might happen.

Fixes dotnet/roslyn#15101.

**Customer scenario**

This is a sporatic crash due to a race for files existing in the file system. @CyrusNajmabadi encountered this during dogfooding.

**Bugs this fixes:** #15101

**Workarounds, if any**

It's a random crash that would be encountered during a rebuild, or maybe git clean. Only workaround would be to not do those.

**Risk**

Low. This is a constrained API used for certain legacy scenarios.

**Performance impact**

Low. Only additional perf is some type checks.

**Is this a regression from a previous update?**

This was rewritten as a part of the Big Switch, so it's been present in Visual Studio 2015 RTM and onwards.

**Root cause analysis**

When this was rewritten, error handling cases in the old code wasn't carefully understood. The old code is sufficiently opaque that it's really hard to figure out without a lot of debug time. A unit test has been added.

**How was the bug found?**

@CyrusNajmabadi hit this.</Description>
        <CreatedDate>19/11/2016</CreatedDate>
        <ClosedDate>22/11/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>15452</IssueID>
        <Title>Removing PROTOTYPE markers</Title>
        <Description>@dotnet/roslyn-compiler for review (a single review should be good, since only updating comments). Then I can make a PR to push discards to RC2.</Description>
        <CreatedDate>22/11/2016</CreatedDate>
        <ClosedDate>22/11/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>15192</IssueID>
        <Title>Discard in deconstruction and out var </Title>
        <Description>Adds binding and lowering logic to support discards in deconstruction, out var and assignment.

```C#
(var x, var _, _) = e;
foreach ((var y, var _, _) in e) { }
M(out var _, out _);
_ = e;
```

Some test code is commented out (with PROTOTYPE marker) until semantic model is updated (`GetTypeInfo` and `GetSymbolInfo`).

From discussion with Neal, we won't do `case _:` for now (he'll ping LDM).

@dotnet/roslyn-compiler for review.</Description>
        <CreatedDate>12/11/2016</CreatedDate>
        <ClosedDate>22/11/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Deconstruct.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>15382</IssueID>
    <Title>Don't crash if we can't resolve a file during a TempPE build</Title>
    <Description>Since this involves the filesystem, there's always the possibility
the file might disappear out from underneath you. Let's accept that
might happen.

Fixes dotnet/roslyn#15101.

**Customer scenario**

This is a sporatic crash due to a race for files existing in the file system. @CyrusNajmabadi encountered this during dogfooding.

**Bugs this fixes:** #15101

**Workarounds, if any**

It's a random crash that would be encountered during a rebuild, or maybe git clean. Only workaround would be to not do those.

**Risk**

Low. This is a constrained API used for certain legacy scenarios.

**Performance impact**

Low. Only additional perf is some type checks.

**Is this a regression from a previous update?**

This was rewritten as a part of the Big Switch, so it's been present in Visual Studio 2015 RTM and onwards.

**Root cause analysis**

When this was rewritten, error handling cases in the old code wasn't carefully understood. The old code is sufficiently opaque that it's really hard to figure out without a lot of debug time. A unit test has been added.

**How was the bug found?**

@CyrusNajmabadi hit this.</Description>
    <CreatedDate>19/11/2016</CreatedDate>
    <ClosedDate>22/11/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>15101</IssueID>
        <Title>Crash in TempPECompilerService</Title>
        <Description>Stack is:

```
Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Compilation.ValidateReferences&lt;Microsoft.CodeAnalysis.CSharp.CSharpCompilationReference&gt;(System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.MetadataReference&gt; references) Line 471	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpCompilation.Create(string assemblyName, Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions options, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTree&gt; syntaxTrees, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.MetadataReference&gt; references, Microsoft.CodeAnalysis.CSharp.CSharpCompilation previousSubmission, System.Type returnType, System.Type hostObjectType, bool isSubmission) Line 248	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpCompilation.Create(string assemblyName, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTree&gt; syntaxTrees, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.MetadataReference&gt; references, Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions options) Line 197	C#
&gt;	Microsoft.VisualStudio.LanguageServices.CSharp.dll!Microsoft.VisualStudio.LanguageServices.CSharp.ProjectSystemShim.TempPECompilerService.CompileTempPE(string pszOutputFileName, int sourceCount, string[] fileNames, string[] fileContents, int optionCount, string[] optionNames, object[] optionValues) Line 54	C#
```

Crash is at:

```c#
                var peReference = reference as PortableExecutableReference;
                if (peReference == null &amp;&amp; !(reference is T))
                {
                    Debug.Assert(reference is UnresolvedMetadataReference || reference is CompilationReference);
                    throw new ArgumentException(string.Format(CodeAnalysisResources.ReferenceOfTypeIsInvalid1, reference.GetType()),
                                    $"{nameof(references)}[{i}]");
                }
```

Looks like we're passing in a "UnresolvedMetadataReference".  Seems like we'll need ot filter those out beforehand.</Description>
        <CreatedDate>08/11/2016</CreatedDate>
        <ClosedDate>22/11/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>15101</IssueID>
        <Title>Crash in TempPECompilerService</Title>
        <Description>Stack is:

```
Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Compilation.ValidateReferences&lt;Microsoft.CodeAnalysis.CSharp.CSharpCompilationReference&gt;(System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.MetadataReference&gt; references) Line 471	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpCompilation.Create(string assemblyName, Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions options, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTree&gt; syntaxTrees, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.MetadataReference&gt; references, Microsoft.CodeAnalysis.CSharp.CSharpCompilation previousSubmission, System.Type returnType, System.Type hostObjectType, bool isSubmission) Line 248	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpCompilation.Create(string assemblyName, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTree&gt; syntaxTrees, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.MetadataReference&gt; references, Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions options) Line 197	C#
&gt;	Microsoft.VisualStudio.LanguageServices.CSharp.dll!Microsoft.VisualStudio.LanguageServices.CSharp.ProjectSystemShim.TempPECompilerService.CompileTempPE(string pszOutputFileName, int sourceCount, string[] fileNames, string[] fileContents, int optionCount, string[] optionNames, object[] optionValues) Line 54	C#
```

Crash is at:

```c#
                var peReference = reference as PortableExecutableReference;
                if (peReference == null &amp;&amp; !(reference is T))
                {
                    Debug.Assert(reference is UnresolvedMetadataReference || reference is CompilationReference);
                    throw new ArgumentException(string.Format(CodeAnalysisResources.ReferenceOfTypeIsInvalid1, reference.GetType()),
                                    $"{nameof(references)}[{i}]");
                }
```

Looks like we're passing in a "UnresolvedMetadataReference".  Seems like we'll need ot filter those out beforehand.</Description>
        <CreatedDate>08/11/2016</CreatedDate>
        <ClosedDate>22/11/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/VisualStudio/CSharp/Impl/CSharpPackage.cs</File>
      <File>src/VisualStudio/CSharp/Impl/ProjectSystemShim/Interop/ICSharpTempPECompilerService.cs</File>
      <File>src/VisualStudio/CSharp/Impl/ProjectSystemShim/TempPECompilerService.cs</File>
      <File>src/VisualStudio/CSharp/Test/ProjectSystemShim/TempPECompilerServiceTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>15357</IssueID>
    <Title>always save changes to unopened documents</Title>
    <Description>This fixes a bug found when investigating #12531

This is an update to a prior PR #15183, with added integration tests that proves that a change in a single closed document is saved to disk.

This change makes it so InvisibleEditor's created via the vs workspace will always be set to save the document if the document is not open in the editor.

The problem this is fixing is one where an edit is made to just a single closed document. In this case we were failing to call SaveDocuments on the running document table. We generally only called SaveDocuments if there is a global undo transaction in effect, and there is only a global undo transaction if there is more than one document involved. Except closed documents cannot be saved manually by the user as they don't correspond to an open text buffer in the editor.

@dotnet/roslyn-ide please review</Description>
    <CreatedDate>18/11/2016</CreatedDate>
    <ClosedDate>22/11/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>12531</IssueID>
        <Title>Unable to apply changes to g.i.cs files generated by XAML compiler</Title>
        <Description>**Version Used**: 2.00.0.0 -- Dev15 preview

**Steps to Reproduce**:
1. Open a WPF or UWP project in Visual Studio.
2. Build
3. Obtain the Document object for one of the .g.i.cs files from the VisualStudioWorkspace.
4. Make a change to the document root.  I was adding a field to the (only) class in the file.
5. Call visualStudioWorkspace.TryApplyChanges(newDocument.Project.Solution).

**Expected Behavior**:
g.i.cs file on disk is updated with whatever change you made in step 4.

**Actual Behavior**:
g.i.cs file is not updated.  However, if you make the same change to some other file in the project (ex. MainPage.xaml.cs), the file _will_ be updated.
</Description>
        <CreatedDate>14/07/2016</CreatedDate>
        <ClosedDate>06/12/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>15183</IssueID>
        <Title>always save changes to unopened documents</Title>
        <Description>This fixes a bug found when investigating #12531 

This change makes it so InvisibleEditor's created via the vs workspace will always be set to save the document if the document is not open in the editor. 

The problem this is fixing is one where an edit is made to just a single closed document.  In this case we were failing to call SaveDocuments on the running document table.  We generally only called SaveDocuments if there is a global undo transaction in effect, and there is only a global undo transaction if there is more than one document involved. Except closed documents cannot be saved manually by the user as they don't correspond to an open text buffer in the editor.

@dotnet/roslyn-ide please review</Description>
        <CreatedDate>11/11/2016</CreatedDate>
        <ClosedDate>18/11/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/VisualStudio/Core/Impl/RoslynVisualStudioWorkspace.cs</File>
      <File>src/VisualStudio/IntegrationTests/AbstractEditorTest.cs</File>
      <File>src/VisualStudio/IntegrationTests/CSharp/CSharpCodeActions.cs</File>
      <File>src/VisualStudio/TestUtilities/Helper.cs</File>
      <File>src/VisualStudio/TestUtilities/HostWaitHelper.cs</File>
      <File>src/VisualStudio/TestUtilities/InProcess/Editor_InProc.cs</File>
      <File>src/VisualStudio/TestUtilities/InProcess/SolutionExplorer_InProc.cs</File>
      <File>src/VisualStudio/TestUtilities/LightBulbHelper.cs</File>
      <File>src/VisualStudio/TestUtilities/OutOfProcess/Editor_OutOfProc.cs</File>
      <File>src/VisualStudio/TestUtilities/OutOfProcess/SolutionExplorer_OutOfProc.cs</File>
      <File>src/VisualStudio/TestUtilities/TestUtilities.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>15339</IssueID>
    <Title>Always show use of unassigned var errors</Title>
    <Description>Prior to C# 7 we tried to avoid giving duplicate errors
when the user used a variable before it was defined (which
is both a use-before-defined and a use-before-assigned error),
but the line here is blurred with local functions, which can
use variables before they are declared in subtle ways that can't
be detected based on declaration order in syntax.

It may be possible to provide the earlier behavior, but the
current optimization is definitely insufficient and hides
legitimate errors in user programs.

Fixes #15322
Fixes #15298</Description>
    <CreatedDate>18/11/2016</CreatedDate>
    <ClosedDate>29/11/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>15322</IssueID>
        <Title>Roslyn fails to enforce definitely assigned rules and cannot emit code for local functions with closures over pattern variables in switch statements</Title>
        <Description>Following code should have error CS0165: Use of unassigned local variable 'x'

```cs
class Program
{
    static void Main(object[] args)
    {
        switch(args[0])
        {
            case string x:
                Foo(); // missing error
                break;
            case int x:
                void Foo() =&gt; System.Console.WriteLine(x);
                break;
        }
    }
}
```

Roslyn doesn't detect the error and fails to compile the code, this is VS2017 RC output:
```
csc.exe exited with code 255
```

Note that if you reorder the cases you get correct error i.e.
```cs
class Program
{
    static void Main(object[] args)
    {
        switch(args[0])
        {
            case int x:
                void Foo() =&gt; System.Console.WriteLine(x);
                break;
            case string x:
                Foo(); // error CS0165: Use of unassigned local variable 'x'
                break;
        }
    }
}
```

TryRoslyn emits following stacktrace for original code (it may be a bit outdated though):
```
The given key was not present in the dictionary. 
at System.Collections.Generic.Dictionary`2.get_Item(TKey key) 
at Microsoft.CodeAnalysis.CodeGen.LocalSlotManager.GetLocal(ILocalSymbol symbol) in ...\Src\Compilers\Core\Portable\CodeGen\LocalSlotManager.cs:line 148 
at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.GetLocal(LocalSymbol symbol) in ...\Src\Compilers\CSharp\Portable\CodeGen\EmitStatement.cs:line 1387 
at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.GetLocal(BoundLocal localExpression) in ...\Src\Compilers\CSharp\Portable\CodeGen\EmitStatement.cs:line 1382 
at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitLocalAddress(BoundLocal localAccess) in ...\Src\Compilers\CSharp\Portable\CodeGen\EmitAddress.cs:line 167 
at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitAddress(BoundExpression expression, AddressKind addressKind) in ...\Src\Compilers\CSharp\Portable\CodeGen\EmitAddress.cs:line 38 
at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitArgument(BoundExpression argument, RefKind refKind) in ...\Src\Compilers\CSharp\Portable\CodeGen\EmitExpression.cs:line 594 
at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitArguments(ImmutableArray`1 arguments, ImmutableArray`1 parameters) in ...\Src\Compilers\CSharp\Portable\CodeGen\EmitExpression.cs:line 769 
at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitCallExpression(BoundCall call, UseKind useKind) in ...\Src\Compilers\CSharp\Portable\CodeGen\EmitExpression.cs:line 1480 
at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitExpressionCore(BoundExpression expression, Boolean used) in ...\Src\Compilers\CSharp\Portable\CodeGen\EmitExpression.cs:line 92 
at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitExpressionCoreWithStackGuard(BoundExpression expression, Boolean used) in ...\Src\Compilers\CSharp\Portable\CodeGen\EmitExpression.cs:line 72 
at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitExpression(BoundExpression expression, Boolean used) in ...\Src\Compilers\CSharp\Portable\CodeGen\EmitExpression.cs:line 60 
```

ping @agocke </Description>
        <CreatedDate>17/11/2016</CreatedDate>
        <ClosedDate>29/11/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>15298</IssueID>
        <Title>Call to local function referencing then-undeclared variable incorrectly allowed</Title>
        <Description>**Version Used**: 2.0.0.61104 - which is in the recent VS2017RC release.

(Don't have a dev build set up, so I apologize if this has been fixed already - scanned through local function issues and couldn't find any related items, and didn't quickly see any tests with this specific case)

**Repro code**:

```csharp
class Program
{
    static void Main(string[] args)
    {
        Foo();
        int x = 2;
        void Foo() =&gt; System.Console.WriteLine(x); // prints "0"
    }
}
```

**Expected Behavior**:

Something similar to the following example:

```csharp
class Program
{
    static void Main(string[] args)
    {
        int x;
        Foo(); // CS0165: Use of unassigned local variable 'x'
        x = 2;
        void Foo() =&gt; System.Console.WriteLine(x);
    }
}
```

Ping @dotnet/roslyn-compiler - probably @agocke in particular?</Description>
        <CreatedDate>16/11/2016</CreatedDate>
        <ClosedDate>29/11/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/DataFlowPass.LocalFunctions.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/DataFlowPass.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenLocalFunctionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/FlowAnalysis/LocalFunctions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>14375</IssueID>
    <Title>Miscellaneous fixes to CPSProjectFactory/CPSProject</Title>
    <Description>1. Make sure that we notify the workspace hosts when IWorkspaceProjectContext.LastDesignTimeBuildSucceeded is updated.
   Fixes #14306
2. Ensure that we create an external error reporter per-project ID in the CPSProjectFactory.
   Fixes #14329
</Description>
    <CreatedDate>07/10/2016</CreatedDate>
    <ClosedDate>10/10/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>14306</IssueID>
        <Title>AbstractProject.LastDesignTimeBuildSucceeded is not always respected </Title>
        <Description>This flags is used to populate ProjectInfo.HasAllInformation, which is used to suppress all errors in the project when design time build is broken for the projects. However, this flag is only read in [CreateProjectInfoForCurrentState](http://source.roslyn.io/#Microsoft.VisualStudio.LanguageServices/Implementation/ProjectSystem/AbstractProject.cs,297), which is only invoked when we first start pushing project changes to workspace hosts. Any subsequent changes to this flag have no effect (we are seeing this behavior in CPS).

We should make sure that changing this property after we have started pushing to workspace hosts correctly updates HasAllInformation on the project state.
</Description>
        <CreatedDate>05/10/2016</CreatedDate>
        <ClosedDate>10/10/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>14329</IssueID>
        <Title>One ProjectExternalErrorReporter is created from 1st project and shared by all projects</Title>
        <Description>**Version Used**: latest preview5

**Steps to Reproduce**:
1. We need to hook up with ProjectExternalErrorReporter to report build errors from DPL.

**Expected Behavior**:
ProjectExternalErrorReporter for each deferred project.

**Actual Behavior**:
One ProjectExternalErrorReporter for all deferred projects:

https://github.com/dotnet/roslyn/blob/49be37c88d52624dd7ec5b4791be0a715426ff2f/src/VisualStudio/Core/Impl/ProjectSystem/CPS/CPSProjectFactory.cs

```
   private IVsReportExternalErrors GetExternalErrorReporter(ProjectId projectId, string languageName)
    {
        lock (_externalErrorReporterMap)
        {
            IVsReportExternalErrors errorReporter;
            if **(!_externalErrorReporterMap.TryGetValue(languageName, out errorReporter**))
            {
                string errorCodePrefix;
                if (!_projectLangaugeToErrorCodePrefixMap.TryGetValue(languageName, out errorCodePrefix))
                {
                    throw new NotSupportedException(nameof(languageName));
                }

                errorReporter = new ProjectExternalErrorReporter(**projectId**, errorCodePrefix, _serviceProvider);
                _externalErrorReporterMap.Add(languageName, errorReporter);
            }

            return errorReporter;
        }
    }
```

@mavasani 
</Description>
        <CreatedDate>06/10/2016</CreatedDate>
        <ClosedDate>10/10/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/AbstractProject.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/Legacy/AbstractLegacyProject_IIntellisenseBuildTarget.cs</File>
      <File>src/VisualStudio/Core/Impl/ProjectSystem/CPS/CPSProject.cs</File>
      <File>src/VisualStudio/Core/Impl/ProjectSystem/CPS/CPSProjectFactory.cs</File>
      <File>src/VisualStudio/Core/Impl/ProjectSystem/CPS/CPSProject_IWorkspaceProjectContext.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>14318</IssueID>
    <Title>Move semantic errors in pattern switch to the binding phase.</Title>
    <Description>Reorganize the use of the decision tree so that it is no longer an inter-phase
data structure. It is used transiently during binding to compute subsumption,
during which we report any use-site errors that arise. It is also used transiently
during lowering to produce the lowered form. We augment the bound nodes
to remove the decision tree and record, for each switch case, whether it is
reachable (a bool), and whether the switch as a whole is complete (another bool).
That summarizes all the semantic information that needs to remain from
initial binding for use by later phases.
Fixes #14296
Fixes #12175
</Description>
    <CreatedDate>06/10/2016</CreatedDate>
    <ClosedDate>18/10/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>14296</IssueID>
        <Title>Decision tree produced prematurely</Title>
        <Description>The decision tree for a pattern switch statement is part of the lowered form, and should therefore not be produced until lowering.
</Description>
        <CreatedDate>05/10/2016</CreatedDate>
        <ClosedDate>18/10/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>12175</IssueID>
        <Title>What to do with use-site diagnostics arising in ExpressionOfTypeMatchesPatternType?</Title>
        <Description>The extension method below was introduced in support of pattern-matching, but it discards use-site diagnostics. Is that correct?

``` cs
    internal static class PatternConversionExtensions
    {
        /// &lt;summary&gt;
        /// Does an expression of type &lt;paramref name="expressionType"/&gt; "match" a pattern that looks for
        /// type &lt;paramref name="patternType"/&gt;?
        /// 'true' if the matched type catches all of them, 'false' if it catches none of them, and
        /// 'null' if it might catch some of them. For this test we assume the expression's value
        /// isn't null.
        /// &lt;/summary&gt;
        public static bool? ExpressionOfTypeMatchesPatternType(this Conversions conversions, TypeSymbol expressionType, TypeSymbol patternType)
        {
            if (expressionType == patternType) return true;
            HashSet&lt;DiagnosticInfo&gt; useSiteDiagnostics = null;
            var conversion = conversions.ClassifyConversion(expressionType, patternType, ref useSiteDiagnostics, builtinOnly: true);
            // This is for classification purposes only; we discard use-site diagnostics. Use-site diagnostics will
            // be given if a conversion is actually used.
```
</Description>
        <CreatedDate>23/06/2016</CreatedDate>
        <ClosedDate>18/10/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/PatternSwitchBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/SubsumptionDiagnosticBuilder.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/DecisionTree.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/DecisionTreeBuilder.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/ControlFlowPass.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/DataFlowPass.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/PreciseAbstractFlowPass.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/PreciseAbstractFlowPass_Switch.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_PatternSwitchStatement.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_Patterns.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/PDB/PDBTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternSwitchTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/UseSiteErrorTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>14190</IssueID>
    <Title>Treat initial state after local func calls as unreachable</Title>
    <Description>Previously, calls to local functions that hadn't had their write
state settled were considered to definitely assign nothing. However,
that breaks with established design in C# where unreachable code is
treated as definitely assigning _everything_. Since we initially have no
information that a local function returns, calls to that local function
should be treated as initially having unreachable state after the call.

This also changes local function assignments to combine using
intersection instead of union, since we must now find the lower
bound, rather than the upper bound.

Fixes #14046, #13739.
</Description>
    <CreatedDate>29/09/2016</CreatedDate>
    <ClosedDate>03/10/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>14046</IssueID>
        <Title>Reads and writes are propagated differently from unreachable code in local functions and behavior is not consistent across different types of unrachable code.</Title>
        <Description>In the following code the call to 'Local' should either propagate both the write to 'x' and the read from 'y' or neither of them or mark all code after the call as unreachable.
Currently the call propagates write to 'x' though it is unreachable but doesn't propagate unreachable read from 'y'.

``` cs
class C
{
  public void M3()
  {
    int x, y;
    void Local()
    {
      while(true) continue;
      x = 5; // unreachable code
      System.Console.WriteLine(y);
    }

    Local(); // the call doesn't require 'y' to be assigned since its usage is unreachable
    System.Console.WriteLine(x); // 'x' is assigned here but it shouldn't since assignment is unreachable

    // the error here implies the branch itself is reachable
    System.Console.WriteLine(y); // error CS0165: Use of unassigned local variable 'y'
  }
}
```

unreachable code after a 'throw' statement behaves the same way.

``` cs
class C
{
  public void M3()
  {
    int x, y;
    void Local()
    {
      throw null;
      x = 5; // unreachable code
      System.Console.WriteLine(y);
    }

    Local(); // the call doesn't require 'y' to be assigned since its usage is unreachable
    System.Console.WriteLine(x); // 'x' is assigned here but it shouldn't since assignment is unreachable

    // the error here implies the branch itself is reachable
    System.Console.WriteLine(y); // error CS0165: Use of unassigned local variable 'y'
  }
}
```

Unreachable code after 'return' statement behaves differently and usages there don't affect compilation.

``` cs
class C
{
  public void M3()
  {
    int x, y;
    void Local()
    {
      return;
      x = 5;
      System.Console.WriteLine(y);
    }

    Local();
    System.Console.WriteLine(x); // error CS0165: Use of unassigned local variable 'x'
    System.Console.WriteLine(y);
  }
}
```
</Description>
        <CreatedDate>24/09/2016</CreatedDate>
        <ClosedDate>03/10/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>13739</IssueID>
        <Title>Incorrect definite assignment error with local functions</Title>
        <Description>The following program produces an incorrect error.

``` cs
using System;

class Program
{
    public static void Main(string[] args)
    {
        int u;
        M();
    https://github.com/dotnet/roslyn/issues/13739
        Console.WriteLine(u); // error: use of unassigned local variable 'u'
        return;

        void M()
        {
            goto La;
        Lb: return;
        La: u = 3;
            goto Lb;
        }
    }
}
```
</Description>
        <CreatedDate>12/09/2016</CreatedDate>
        <ClosedDate>04/10/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/DataFlowPass.LocalFunctions.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/DataFlowPass.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/FlowAnalysis/LocalFunctions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>14162</IssueID>
    <Title>Implement sequence points for pattern switch statements.</Title>
    <Description>Fixes #13971

We were previously undecided about when we would add support for a sequence
point at the when clause of a switch case. Since the when clause can call into other
user code, we need the sequence point to give sensible behavior when inspecting
the call stack. So we now support sequence points in the when clause.

Further work will be required to support setting a breakpoint in the when clause.
That is tracked by #12378

@dotnet/roslyn-compiler Please review.
</Description>
    <CreatedDate>28/09/2016</CreatedDate>
    <ClosedDate>05/10/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>13971</IssueID>
        <Title>Sequence points set to break statements in pattern switch</Title>
        <Description>Stepping through a pattern switch will step through the `break;` statements of preceding `case ... when ...:` statements rather than the `when ...` clauses.
</Description>
        <CreatedDate>22/09/2016</CreatedDate>
        <ClosedDate>05/10/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>12378</IssueID>
        <Title>Support breakpoints in the when clause of a switch case.</Title>
        <Description>
        </Description>
        <CreatedDate>07/07/2016</CreatedDate>
        <ClosedDate>11/10/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Lowering/Instrumentation/CompoundInstrumenter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/Instrumentation/DebugInfoInjector.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/Instrumentation/DynamicAnalysisInjector.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/Instrumentation/Instrumenter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_PatternSwitchStatement.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_SwitchStatement.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/PDB/PDBTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>14161</IssueID>
    <Title>Two bug fixes - disallow "new (int, int)()" and induce a failure if ValueTuple is not a struct.</Title>
    <Description>Fixes: #10891      - Forbid constructing tuples via "new"
Fixes: #11689      - Enforce that ValueTuple types are structs

Note that #11689 requires validation that ValueTuple is a value type only in common cases, That is - to convey that cases where ValueTuple happens to be a Class, Enum, Delegate, etc are clearly not supported.

From the language prospective, tuples are value types composed of their elements. That is visible through the semantics of definite assignment, conversions, nullable lifting, async capturing and so on. This change intentionally introduces emit failures when underlying ValueTuple types are not structs.

This is only C# part. 
VB will need exactly same fixes ported.
</Description>
    <CreatedDate>28/09/2016</CreatedDate>
    <ClosedDate>04/10/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>10891</IssueID>
        <Title>Forbid constructing tuples via "new"</Title>
        <Description>The following should work (or perhaps not):

new (int x1, int x2, ...., int x12) ( 1,2,...., 12);

It could be more complicated when constructor initializers are involved, like:
new (int x1, int x2, ...., int x12) ( 1,2,...., 12) { x1 = 1, x12 = 2};

If not, then    new (int, int)(1, 2)    should not work either.
</Description>
        <CreatedDate>26/04/2016</CreatedDate>
        <ClosedDate>04/10/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>11689</IssueID>
        <Title>Enforce that ValueTuple types are structs</Title>
        <Description>We seem to be gradually taking some direct or indirect dependencies on tuples being structs already - we allow nullable conversions, may consider ctor invocations equivalent to element-wise assignments into a local with default value, etc...

There is no point in having special support for a case where ValueTuple are classes and it is more robust to just require tuple underlying types to be structs.
</Description>
        <CreatedDate>01/06/2016</CreatedDate>
        <ClosedDate>04/10/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>11689</IssueID>
        <Title>Enforce that ValueTuple types are structs</Title>
        <Description>We seem to be gradually taking some direct or indirect dependencies on tuples being structs already - we allow nullable conversions, may consider ctor invocations equivalent to element-wise assignments into a local with default value, etc...

There is no point in having special support for a case where ValueTuple are classes and it is more robust to just require tuple underlying types to be structs.
</Description>
        <CreatedDate>01/06/2016</CreatedDate>
        <ClosedDate>04/10/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Expressions.cs</File>
      <File>src/Compilers/CSharp/Portable/Emitter/Model/PEModuleBuilder.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/ErrorCode.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/LanguageParser.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Tuples/TupleTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTupleTest.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/ParserErrorMessageTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/StatementParsingTests.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Test/ExpressionCompiler/TupleTests.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Test/ResultProvider/TupleTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>13877</IssueID>
    <Title>Fixes 7 failing pattern matching tests due to an incorrect assumption about standard cultural settings</Title>
    <Description>This fixes an issue related to #10362:

7 of the C# pattern matching tests in master fail due to the use of `Roslyn.Test.Utilities.EnsureEnglishCulture`: The tests print out some numbers, expecting them to be formatted using English formatting rules. To ensure this, the `EnsureEnglishCulture` class is used.
This class basically checks if the current culture's names starts with `en` (which it does in my case) and then does nothing -- otherwise, it sets the invariant culture. However, as shown in #10362, I use non-standard cultural settings for the `en` culture, in particular changing the decimal symbol. Thus, the `GeneralizedSwitchStatement` test, for instance, fails as it prints out `double 1,2` instead of `double 1.2`.

This issue can be fixed by always setting the invariant culture, in which case all 7 tests succeed. In that case, however, the entire class should probably be renamed to `EnsureInvariantCulture`. As the class is only used by the pattern matching tests, this change seems to be safe. 

This pull requests thus makes the necessary changes to fix the tests.
</Description>
    <CreatedDate>17/09/2016</CreatedDate>
    <ClosedDate>21/09/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>10362</IssueID>
        <Title>[Test Failure] Some tests fail due to non-standard cultural settings</Title>
        <Description>I'm encountering test failures on my local Windows machine (even though the build servers show all tests as passing). I'm on the latest commit 9bac4a6f86515f2d6f9a09d07dc73bc7e81dd7e4 in the master branch. The failing tests are:
- `Microsoft.CodeAnalysis.VisualBasic.UnitTests.Semantics.BinaryOperators.Test1`
- `Microsoft.CodeAnalysis.VisualBasic.UnitTests.AnonymousTypesCodeGenTests.TestAnonymousType_ToString`
- `Microsoft.CodeAnalysis.VisualBasic.UnitTests.AnonymousTypesCodeGenTests.TestAnonymousType_LocalAsNewWith`
- `Microsoft.CodeAnalysis.VisualBasic.UnitTests.StaticLocalsSemanticTests.Semantic_StaticLocalDeclaration_LateBound`
- `Microsoft.CodeAnalysis.CSharp.UnitTests.Symbols.AnonymousTypesSymbolTests.AnonymousType_ToString`

A quick investigation showed that the root cause seems to be my unusual culture settings in Windows:

![roslyn cultural settings](https://cloud.githubusercontent.com/assets/1945136/14309911/69a208f6-fbdf-11e5-9699-af5379cac41e.png)

In particular, I use the en-US culture, but modified the decimal symbol to be `,` and the digit grouping symbol to be `.`, like it is in German. Switching these back to the default cause all tests to succeed again, except for `BinaryOperators.Test1`. That one fails because I'm not using the US date time format and can thus be fixed by reverting to it.

**Fix**

I don't think that tests should depend on cultural settings. In fact, the tests (except for `BinaryOperators.Test1` as far as I can see) actually try to avoid this problem by changing the executing thread's current culture before executing the tests and reverting the culture afterwards. However, they are explicitly using the `en-US` culture, which I've modified with my Windows settings. Hence the output

```
Expected: { a = 1, b = text, c = 123.456 }
Actual:   { a = 1, b = text, c = 123,456 }
```

for `Microsoft.CodeAnalysis.VisualBasic.UnitTests.AnonymousTypesCodeGenTests.TestAnonymousType_ToString`, for instance.

The fix seems to be to replace the line `System.Threading.Thread.CurrentThread.CurrentCulture = New System.Globalization.CultureInfo("en-US")` with `System.Threading.Thread.CurrentThread.CurrentCulture = System.Globalization.CultureInfo.InvariantCulture`, which seems to be the correct culture to use in this case. From [MSDN](https://msdn.microsoft.com/en-us/library/system.globalization.cultureinfo.invariantculture%28v=vs.110%29.aspx?f=255&amp;MSPPError=-2147217396) (emphasis mine):

&gt; Unlike **culture-sensitive data**, which is **subject to change by user customization** or by updates to the .NET Framework or the operating system, **invariant culture data is stable over time and across installed cultures and cannot be customized by users**. This makes the invariant culture particularly useful for operations that **require culture-independent results**, such as formatting and parsing operations that persist formatted data, or sorting and ordering operations **that require that data be displayed in a fixed order regardless of culture**. 

The other tests could be fixed in a similar way. Let me know if you think this fix is correct and I'll submit a pull request. 
</Description>
        <CreatedDate>06/04/2016</CreatedDate>
        <ClosedDate>21/09/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>10362</IssueID>
        <Title>[Test Failure] Some tests fail due to non-standard cultural settings</Title>
        <Description>I'm encountering test failures on my local Windows machine (even though the build servers show all tests as passing). I'm on the latest commit 9bac4a6f86515f2d6f9a09d07dc73bc7e81dd7e4 in the master branch. The failing tests are:
- `Microsoft.CodeAnalysis.VisualBasic.UnitTests.Semantics.BinaryOperators.Test1`
- `Microsoft.CodeAnalysis.VisualBasic.UnitTests.AnonymousTypesCodeGenTests.TestAnonymousType_ToString`
- `Microsoft.CodeAnalysis.VisualBasic.UnitTests.AnonymousTypesCodeGenTests.TestAnonymousType_LocalAsNewWith`
- `Microsoft.CodeAnalysis.VisualBasic.UnitTests.StaticLocalsSemanticTests.Semantic_StaticLocalDeclaration_LateBound`
- `Microsoft.CodeAnalysis.CSharp.UnitTests.Symbols.AnonymousTypesSymbolTests.AnonymousType_ToString`

A quick investigation showed that the root cause seems to be my unusual culture settings in Windows:

![roslyn cultural settings](https://cloud.githubusercontent.com/assets/1945136/14309911/69a208f6-fbdf-11e5-9699-af5379cac41e.png)

In particular, I use the en-US culture, but modified the decimal symbol to be `,` and the digit grouping symbol to be `.`, like it is in German. Switching these back to the default cause all tests to succeed again, except for `BinaryOperators.Test1`. That one fails because I'm not using the US date time format and can thus be fixed by reverting to it.

**Fix**

I don't think that tests should depend on cultural settings. In fact, the tests (except for `BinaryOperators.Test1` as far as I can see) actually try to avoid this problem by changing the executing thread's current culture before executing the tests and reverting the culture afterwards. However, they are explicitly using the `en-US` culture, which I've modified with my Windows settings. Hence the output

```
Expected: { a = 1, b = text, c = 123.456 }
Actual:   { a = 1, b = text, c = 123,456 }
```

for `Microsoft.CodeAnalysis.VisualBasic.UnitTests.AnonymousTypesCodeGenTests.TestAnonymousType_ToString`, for instance.

The fix seems to be to replace the line `System.Threading.Thread.CurrentThread.CurrentCulture = New System.Globalization.CultureInfo("en-US")` with `System.Threading.Thread.CurrentThread.CurrentCulture = System.Globalization.CultureInfo.InvariantCulture`, which seems to be the correct culture to use in this case. From [MSDN](https://msdn.microsoft.com/en-us/library/system.globalization.cultureinfo.invariantculture%28v=vs.110%29.aspx?f=255&amp;MSPPError=-2147217396) (emphasis mine):

&gt; Unlike **culture-sensitive data**, which is **subject to change by user customization** or by updates to the .NET Framework or the operating system, **invariant culture data is stable over time and across installed cultures and cannot be customized by users**. This makes the invariant culture particularly useful for operations that **require culture-independent results**, such as formatting and parsing operations that persist formatted data, or sorting and ordering operations **that require that data be displayed in a fixed order regardless of culture**. 

The other tests could be fixed in a similar way. Let me know if you think this fix is correct and I'll submit a pull request. 
</Description>
        <CreatedDate>06/04/2016</CreatedDate>
        <ClosedDate>21/09/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests.cs</File>
      <File>src/Test/Utilities/Shared/FX/EnsureEnglishCulture.cs</File>
      <File>src/Test/Utilities/Shared/FX/EnsureInvariantCulture.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>13865</IssueID>
    <Title>Ensure proper validation of operator signatures when tuple types are involved.</Title>
    <Description>Fixes #11986.
Fixes #11530.

@dotnet/roslyn-compiler, @VSadov, @jcouv Please review.
</Description>
    <CreatedDate>16/09/2016</CreatedDate>
    <ClosedDate>20/09/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>11986</IssueID>
        <Title>Tuple implementation rejects implicit operators</Title>
        <Description>Related to #11530, the following code is improperly rejected by the tuple implementation in `master`.

``` cs
namespace System
{
    public struct ValueTuple&lt;T1, T2&gt;
    {
        public T1 Item1;
        public T2 Item2;
        public ValueTuple(T1 item1, T2 item2)
        {
            this.Item1 = item1;
            this.Item2 = item2;
        }

        // error: conversion must convert to or from enclosing type
        public static explicit operator int((T1, T2)? source)
        {
            return 1;
        }
        // error: conversion must convert to or from enclosing type
        public static explicit operator long(Nullable&lt;(T1, T2)&gt; source)
        {
            return 1;
        }
        // error: conversion must convert to or from enclosing type
        public static explicit operator string(Nullable&lt;ValueTuple&lt;T1, T2&gt;&gt; source)
        {
            return "";
        }
        // error: conversion must convert to or from enclosing type
        public static explicit operator double(ValueTuple&lt;T1, T2&gt;? source)
        {
            return 1;
        }
    }
}
```
</Description>
        <CreatedDate>14/06/2016</CreatedDate>
        <ClosedDate>20/09/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>11530</IssueID>
        <Title>Tuple implementation rejects implicit operators</Title>
        <Description>The following code is improperly rejected by the tuple implementation

``` cs
namespace System
{
    public struct ValueTuple&lt;T1, T2&gt;
    {
        public T1 Item1;
        public T2 Item2;

        // error: conversion must convert to or from enclosing type
        public static implicit operator Collections.Generic.KeyValuePair&lt;T1, T2&gt;(ValueTuple&lt;T1, T2&gt; tuple)
        {
            T1 k;
            T2 v;
            (k, v) = tuple;
            return new KeyValuePair&lt;T1, T2&gt;(k, v);
        }

        // error: conversion must convert to or from enclosing type
        public static implicit operator ValueTuple&lt;T1, T2&gt;(Collections.Generic.KeyValuePair&lt;T1, T2&gt; kvp)
        {
            return (kvp.Key, kvp.Value);
        }
    }
}
```

This was tested against https://github.com/jcouv/roslyn/tree/tuple-deconstruction (from https://github.com/dotnet/roslyn/pull/11457) at commit https://github.com/jcouv/roslyn/commit/c7b60a478ce0f5993d1e7a85af17545b96611a9e
</Description>
        <CreatedDate>24/05/2016</CreatedDate>
        <ClosedDate>20/09/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceUserDefinedOperatorSymbolBase.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTupleTest.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>13851</IssueID>
    <Title>Adding tests to close #13661 and #12802</Title>
    <Description>Both issues no longer repro.

Chuck noticed an assertion with long tuples with missing names, such as `var o = (A: 1, 2, C: 3, D: 4, E: 5, F: 6, G: 7, 8, I: 9);`. This is issue #13661. This was fixed by Vlad's preview 5 fix to rationalize `TupleTypeSymbol.CreateMembers` and align it between C# and VB.

I'd noticed a refactoring problem with decontruction, #12802. The generated code was not simplified far enough. This no longer repros.

@dotnet/roslyn-compiler for review.
</Description>
    <CreatedDate>16/09/2016</CreatedDate>
    <ClosedDate>17/09/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>13661</IssueID>
        <Title>Assert failure in TupleVirtualElementFieldSymbol..ctor</Title>
        <Description>Compiling the following results in an assert failure in `TupleVirtualElementFieldSymbol..ctor`: `Debug.Assert(name != null)`.

```
class C
{
    static void Main()
    {
        var o = (A: 1, 2, C: 3, D: 4, E: 5, F: 6, G: 7, 8, I: 9);
    }
}
```
</Description>
        <CreatedDate>07/09/2016</CreatedDate>
        <ClosedDate>17/09/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>12802</IssueID>
        <Title>Un-necessary parens and type arguments introduced by inline variable on deconstruction</Title>
        <Description>This is probably a problem in the IDE simplification logic.

![extra-parens](https://cloud.githubusercontent.com/assets/12466233/17224519/11ccbd76-54b6-11e6-889b-a0101fdb5ea0.png)
</Description>
        <CreatedDate>28/07/2016</CreatedDate>
        <ClosedDate>14/09/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTupleTest.cs</File>
      <File>src/EditorFeatures/CSharpTest/CodeActions/InlineTemporary/InlineTemporaryTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>13818</IssueID>
    <Title>Handle Out Variable Declarations in a Script.</Title>
    <Description>Fixes #13450.
Fixes #13590.

@dotnet/roslyn-compiler Please review.
</Description>
    <CreatedDate>15/09/2016</CreatedDate>
    <ClosedDate>16/09/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>13450</IssueID>
        <Title>Out variables in top level script causes .GetDiagnostics() to throw an exception</Title>
        <Description>**Version Used**: Commit 9e6ecbd6 (8/27/2016)

**Steps to Reproduce**:
1. Create a console project with the code below:

``` csharp
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;

namespace SemanticsCS
{
    class Program
    {
        static void Main(string[] args)
        {
            SyntaxTree tree = CSharpSyntaxTree.ParseText(
@"using System;
using System.Collections.Generic;
using System.Text;

OutVar(out string q);

void OutVar(out string s)
{
    s = null;
}", options: new CSharpParseOptions(kind: SourceCodeKind.Script ));

            var root = (CompilationUnitSyntax)tree.GetRoot();

            var compilation = CSharpCompilation.Create("HelloWorld")
                                               .AddReferences(
                                                    MetadataReference.CreateFromFile(
                                                        typeof(object).Assembly.Location))
                                               .AddSyntaxTrees(tree);

            Console.WriteLine("Just before .GetDiagnostics()");
            var diags = compilation.GetDiagnostics(); //Exception occurs here.
        }
    }
}
```
1. Reference the M.CodeAnalysis and M.CodeAnalysis.CSharp libraries compiled from the source tree (not from Nuget)

**Expected Behavior**: Get diagnostics.

**Actual Behavior**: Throws InvalidOperationException "This program location is thought to be unreachable."

```
StackTrace:

   at Microsoft.CodeAnalysis.CSharp.Binder.BindArgumentValue(DiagnosticBag diagnostics, ArgumentSyntax argumentSyntax, Boolean allowArglist, RefKind refKind) in F:\Roslyn_Project\Roslyn\roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 2076
   at Microsoft.CodeAnalysis.CSharp.Binder.BindArgumentAndName(AnalyzedArguments result, DiagnosticBag diagnostics, Boolean hadError, ArgumentSyntax argumentSyntax, Boolean allowArglist, Boolean isDelegateCreation) in F:\Roslyn_Project\Roslyn\roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 2010
   at Microsoft.CodeAnalysis.CSharp.Binder.BindInvocationExpression(InvocationExpressionSyntax node, DiagnosticBag diagnostics) in F:\Roslyn_Project\Roslyn\roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Invocation.cs:line 145
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed) in F:\Roslyn_Project\Roslyn\roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 452
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpression(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed) in F:\Roslyn_Project\Roslyn\roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 396
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionStatement(CSharpSyntaxNode node, ExpressionSyntax syntax, Boolean allowsAnyExpression, DiagnosticBag diagnostics) in F:\Roslyn_Project\Roslyn\roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 533
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionStatement(ExpressionStatementSyntax node, DiagnosticBag diagnostics) in F:\Roslyn_Project\Roslyn\roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 526
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics) in F:\Roslyn_Project\Roslyn\roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 50
   at Microsoft.CodeAnalysis.CSharp.Binder.BindGlobalStatement(Binder binder, SynthesizedInteractiveInitializerMethod scriptInitializer, StatementSyntax statementNode, DiagnosticBag diagnostics, Boolean isLast) in F:\Roslyn_Project\Roslyn\roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Initializers.cs:line 212
   at Microsoft.CodeAnalysis.CSharp.Binder.BindScriptFieldInitializers(CSharpCompilation compilation, SynthesizedInteractiveInitializerMethod scriptInitializer, ImmutableArray`1 initializers, ArrayBuilder`1 boundInitializers, DiagnosticBag diagnostics, ImportChain&amp; firstDebugImports) in F:\Roslyn_Project\Roslyn\roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Initializers.cs:line 192
   at Microsoft.CodeAnalysis.CSharp.Binder.BindFieldInitializers(CSharpCompilation compilation, SynthesizedInteractiveInitializerMethod scriptInitializerOpt, ImmutableArray`1 initializers, DiagnosticBag diagnostics, ImportChain&amp; firstImportChain) in F:\Roslyn_Project\Roslyn\roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Initializers.cs:line 57
   at Microsoft.CodeAnalysis.CSharp.Binder.BindFieldInitializers(CSharpCompilation compilation, SynthesizedInteractiveInitializerMethod scriptInitializerOpt, ImmutableArray`1 fieldInitializers, DiagnosticBag diagnostics, ProcessedFieldInitializers&amp; processedInitializers) in F:\Roslyn_Project\Roslyn\roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Initializers.cs:line 28
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(NamedTypeSymbol containingType) in F:\Roslyn_Project\Roslyn\roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 369
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.&lt;&gt;c__DisplayClass20_0.&lt;CompileNamedTypeAsTask&gt;b__0() in F:\Roslyn_Project\Roslyn\roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 323
   at Roslyn.Utilities.UICultureUtilities.&lt;&gt;c__DisplayClass5_0.&lt;WithCurrentUICulture&gt;b__0() in F:\Roslyn_Project\Roslyn\roslyn\src\Compilers\Core\Portable\InternalUtilities\UICultureUtilities.cs:line 136
   at System.Threading.Tasks.Task.InnerInvoke()
   at System.Threading.Tasks.Task.Execute()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.WaitForWorkers() in F:\Roslyn_Project\Roslyn\roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 238
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethodBodies(CSharpCompilation compilation, PEModuleBuilder moduleBeingBuiltOpt, Boolean generateDebugInfo, Boolean hasDeclarationErrors, DiagnosticBag diagnostics, Predicate`1 filterOpt, CancellationToken cancellationToken) in F:\Roslyn_Project\Roslyn\roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 137
   at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnosticsForAllMethodBodies(DiagnosticBag diagnostics, CancellationToken cancellationToken) in F:\Roslyn_Project\Roslyn\roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs:line 2004
   at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnostics(CompilationStage stage, Boolean includeEarlierStages, CancellationToken cancellationToken) in F:\Roslyn_Project\Roslyn\roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs:line 1971
   at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnostics(CancellationToken cancellationToken) in F:\Roslyn_Project\Roslyn\roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs:line 1910
   at SemanticsCS.Program.Main(String[] args) in c:\users\code\documents\visual studio 2015\Projects\TestSemanticAnalysis\TestSemanticAnalysis\Program.cs:line 33
   at System.AppDomain._nExecuteAssembly(RuntimeAssembly assembly, String[] args)
   at System.AppDomain.ExecuteAssembly(String assemblyFile, Evidence assemblySecurity, String[] args)
   at Microsoft.VisualStudio.HostingProcess.HostProc.RunUsersAssembly()
   at System.Threading.ThreadHelper.ThreadStart_Context(Object state)
   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   at System.Threading.ThreadHelper.ThreadStart()
```
</Description>
        <CreatedDate>30/08/2016</CreatedDate>
        <ClosedDate>16/09/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>13590</IssueID>
        <Title>Declaration of a fixed buffer in a top level script code causes a System.InvalidCastException</Title>
        <Description>```
        [Fact]
        public void Variables()
        {
            string source =
@"fixed int x[3];
";
            var tree = Parse(source, options: TestOptions.Script);
            var compilation = CreateCompilationWithMscorlib45(new[] { tree });

            compilation.VerifyDiagnostics(
                );
        }
```

Observed:

```
Exception thrown: 'System.InvalidCastException' in Microsoft.CodeAnalysis.CSharp.dll

Additional information: Unable to cast object of type 'PENamedTypeSymbolNonGeneric' to type 'Microsoft.CodeAnalysis.CSharp.Symbols.PointerTypeSymbol'.

&gt;   Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberFieldSymbol.GetFieldType(Roslyn.Utilities.ConsList&lt;Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol&gt; fieldsBeingBound) Line 278    C#
    Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberFieldSymbol.ForceComplete(Microsoft.CodeAnalysis.SourceLocation locationOpt, System.Threading.CancellationToken cancellationToken) Line 505 C#
    Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.ForceComplete(Microsoft.CodeAnalysis.SourceLocation locationOpt, System.Threading.CancellationToken cancellationToken) Line 492 C#
    Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Symbol.ForceCompleteMemberByLocation(Microsoft.CodeAnalysis.SourceLocation locationOpt, Microsoft.CodeAnalysis.CSharp.Symbol member, System.Threading.CancellationToken cancellationToken) Line 709 C#
    Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamespaceSymbol.ForceComplete(Microsoft.CodeAnalysis.SourceLocation locationOpt, System.Threading.CancellationToken cancellationToken) Line 72    C#
    Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Symbols.SourceModuleSymbol.ForceComplete(Microsoft.CodeAnalysis.SourceLocation locationOpt, System.Threading.CancellationToken cancellationToken) Line 254  C#
    Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol.ForceComplete(Microsoft.CodeAnalysis.SourceLocation locationOpt, System.Threading.CancellationToken cancellationToken) Line 893    C#
    Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetSourceDeclarationDiagnostics(Microsoft.CodeAnalysis.SyntaxTree syntaxTree, Microsoft.CodeAnalysis.Text.TextSpan? filterSpanWithinTree, System.Func&lt;System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.Diagnostic&gt;, Microsoft.CodeAnalysis.SyntaxTree, Microsoft.CodeAnalysis.Text.TextSpan?, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.Diagnostic&gt;&gt; locationFilterOpt, System.Threading.CancellationToken cancellationToken) Line 2080  C#
    Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnostics(Microsoft.CodeAnalysis.CompilationStage stage, bool includeEarlierStages, System.Threading.CancellationToken cancellationToken) Line 1958  C#
    Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnostics(System.Threading.CancellationToken cancellationToken) Line 1910    C#
    Roslyn.Test.Utilities.Desktop.dll!Microsoft.CodeAnalysis.DiagnosticExtensions.VerifyDiagnostics&lt;Microsoft.CodeAnalysis.CSharp.CSharpCompilation&gt;(Microsoft.CodeAnalysis.CSharp.CSharpCompilation c, Microsoft.CodeAnalysis.Test.Utilities.DiagnosticDescription[] expected) Line 98 C#
```
</Description>
        <CreatedDate>02/09/2016</CreatedDate>
        <ClosedDate>16/09/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Expressions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Initializers.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Invocation.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Statements.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/ExpressionVariableFinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/OverloadResolution/OverloadResolution.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/OverloadResolution/OverloadResolutionResult.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/Expression.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/Formatting.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/OutVarLocalPendingInference.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/OutVariablePendingInference.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/CSharpSemanticModel.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/SyntaxTreeSemanticModel.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/PreciseAbstractFlowPass.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_LocalDeclaration.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceEventFieldSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceFixedFieldSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceMemberContainerSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceMemberFieldSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceMemberFieldSymbolFromDesignation.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/SyntaxExtensions.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/SyntaxFacts.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/IteratorTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/OutVarTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/ScriptSemanticsTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>13814</IssueID>
    <Title>Implement new syntactic disambiguation rule for pattern-matching</Title>
    <Description>Fixes #10492
The behavior is specified in #13813 

@dotnet/roslyn-compiler Please review.
</Description>
    <CreatedDate>15/09/2016</CreatedDate>
    <ClosedDate>22/09/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>10492</IssueID>
        <Title>Precedence errors in parsing the relational "is" expression</Title>
        <Description>The following short program illustrates two errors in the Roslyn expression parser. These issues interfere with the extension of the parser to support pattern-matching.

``` cs
using System;

class Program
{
    const bool B = true;

    public static void Main(string[] args)
    {
        object a = null;
        B c = null;
        Console.WriteLine(a is B &amp; c); // prints 5 (correct)
        Console.WriteLine(a is B &gt; c); // prints 6 (correct)
        Console.WriteLine(a is B &lt; c); // syntax error but should print 7
        Console.WriteLine(a is B + c); // should be syntax error but prints 8
    }
}

class B
{
    public static int operator &amp;(bool left, B right) =&gt; 5;
    public static int operator &gt;(bool left, B right) =&gt; 6;
    public static int operator &lt;(bool left, B right) =&gt; 7;
    public static int operator +(bool left, B right) =&gt; 8;
}
```

The last of these cases is most problematic for pattern-matching. While `a is B + c` should have been a syntax error in C# 6, in C# 7 it should mean `a is (B + c)`, which works if `B + c` is a constant value. However, we parse it incorrectly as `(a is B) + b`, which is an inversion of the precedence required by the language specification.
</Description>
        <CreatedDate>12/04/2016</CreatedDate>
        <ClosedDate>16/12/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>13813</IssueID>
        <Title>New syntactic disambiguation rule for pattern-matching</Title>
        <Description>Related to #10492, there is now a new syntactic ambiguity due to patterns. The case is this

``` cs
M(e is A &lt; B, C &gt; x)
```

Where we are either passing two arguments to `M`, or declaring a pattern variable `x`.

The existing (C# 6) rules say it is two arguments because the token after the `&gt;` isn’t one of the ones on the list in the section entitled _Grammar Ambiguities_ in the _Lexical Structure_ chapter. That seems wrong in the presence of pattern-matching, because there is no other way to write the type so as to disambiguate and give it the meaning of matching the type `A&lt;B,C&gt;`.

Fortunately, previous compilers were unable to parse this according to the specification, and simply gave a syntax error (unable to handle an _is-expression_ on the left of a `&lt;`). That suggests we may have some room to change the rules.

However, if we simply add _identifier_ to the list, we’d get this case wrong

``` cs
M(A &lt; B, C &gt; D)
```

Maybe we only add _identifier_ to the list only when the type is being parsed for a pattern? That is the solution I have currently implemented, and it seems to do the right thing.

This will have to go in the language spec.
</Description>
        <CreatedDate>14/09/2016</CreatedDate>
        <ClosedDate>27/03/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Parser/LanguageParser.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/LanguageParser_Patterns.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/ParserErrorMessageTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>13798</IssueID>
    <Title>Never offer to remove an unboxing cast, as it can cause an exception.</Title>
    <Description>Fixes #12572 
Fixes #10306

It turns out the underlying bug has nothing to do with pattern-matching, or anything in the compiler.

@DustinCampbell @mavasani Can you please review this?
@dotnet/roslyn-compiler Any additional reviews are welcome.
</Description>
    <CreatedDate>14/09/2016</CreatedDate>
    <ClosedDate>14/09/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>12572</IssueID>
        <Title>Incorrect "Cast is redundant" when switch on an `object`</Title>
        <Description>**Version Used**: 

Master branch, commit d9b6e87a1b08f2f12f5fbd5eb0b071d82b672beb (latest when submitted this issue)

**Steps to Reproduce**:

``` C#
public static void TestSwitchInt(object i)
{
    switch ((int)i)
    {
        case 0:
            Console.WriteLine("0");
            break;
        case 1:
            Console.WriteLine("1");
            break;
        case 2:
            Console.WriteLine("2");
            break;
    }
}
```

**Expected Behavior**:

No "Cast is redundant" suggestion.

**Actual Behavior**:

"Cast is redundant" on `(int)i`.

Removing it will cause the compiler to generate more complicated code (to check the type of `i`).
</Description>
        <CreatedDate>17/07/2016</CreatedDate>
        <ClosedDate>14/09/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>10306</IssueID>
        <Title>[Bug] Redundant "Remove Unnecessary Cast" with pattern-matching</Title>
        <Description>**Version Used**: 
Microsoft Visual Studio Enterprise 15 Preview
Version 15.0.25123.0 PREVIEW
Microsoft .NET Framework
Version 4.6.01038

**Steps to Reproduce**:
Write a code:

``` cs
static class Program
{
  static void Main(string[] args) {
    switch((object)args) {
        // ^~~~~~~^ cast marked as IDE0004  C# Cast is redundant.
    case int[] i:
      break;
    }
  }
}
```
1. Compile code: succeeded
2. Remove cast and compile code: error CS0030: Cannot convert type 'string[]' to 'int[]'

**Expected Behavior**:
Do not suggest to remove a type cast.
</Description>
        <CreatedDate>03/04/2016</CreatedDate>
        <ClosedDate>14/09/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/RemoveUnnecessaryCast/RemoveUnnecessaryCastTests.cs</File>
      <File>src/Workspaces/CSharp/Portable/Extensions/CastExpressionSyntaxExtensions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>13781</IssueID>
    <Title>this is port of 7 different changes from master. and enabled remote host by default</Title>
    <Description>6 changes ported from master as they are.
#13694
#13721
#13703
#13743
#13756
#13779
#13787

all these changes are signed off from master.

...

only change in preview 5 branch is making remotehost to be on by default.

public static readonly Option&lt;bool&gt; RemoteHost = new Option&lt;bool&gt;(OptionName, nameof(RemoteHost), defaultValue: true);
</Description>
    <CreatedDate>14/09/2016</CreatedDate>
    <ClosedDate>14/09/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>13694</IssueID>
        <Title>make checksum build time of roslyn-internal from 1 min to 8 seconds</Title>
        <Description>got rid of as much async as possible. it can't be completely non-async due to getting text is async.

made building any async part concurrent.
</Description>
        <CreatedDate>08/09/2016</CreatedDate>
        <ClosedDate>09/09/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>13721</IssueID>
        <Title>added OpenFileOnly in IBuiltInAnalyzer and removed RunInProcess</Title>
        <Description>now, all builtin analyzer that is not set to only run on open files will run in OOP.

any builtin analyzer that can't run in OOP should mark it as open file only.

for analyzers that return only hidden severity but return different severity on runtime should use the new API to control whether it want to run full solution or not. if set to run on full solution, it will run in OOP.
</Description>
        <CreatedDate>09/09/2016</CreatedDate>
        <ClosedDate>12/09/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>13703</IssueID>
        <Title>support options in asset builder and send over option set to OOP</Title>
        <Description>
        </Description>
        <CreatedDate>09/09/2016</CreatedDate>
        <ClosedDate>13/09/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>13743</IssueID>
        <Title>check whether options that require OOP are enabled.</Title>
        <Description>no code lens check yet since we don't have option yet. but as soon as I have one, we will check that as well.
</Description>
        <CreatedDate>12/09/2016</CreatedDate>
        <ClosedDate>12/09/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>13756</IssueID>
        <Title>add codelen option check</Title>
        <Description>
        </Description>
        <CreatedDate>13/09/2016</CreatedDate>
        <ClosedDate>13/09/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>13779</IssueID>
        <Title>Add out of proc CodeLens processing</Title>
        <Description>@heejaechang Here is the move to have the CodeLens service run out of proc. (It also include for the moment the other PR about fixing the extra parameter, but you can ignore that in this PR.) Let me know what you think...
</Description>
        <CreatedDate>14/09/2016</CreatedDate>
        <ClosedDate>14/09/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>13787</IssueID>
        <Title>Update OOP analyzers to calculate OpenFileOnly based on options</Title>
        <Description>Only Error- and Warning-level Code Style options will run on closed files.
Suggestions will only run on open files.

This will help with perf (I believe), and is part of @heejaechang 's larger effort for OOP.
</Description>
        <CreatedDate>14/09/2016</CreatedDate>
        <ClosedDate>14/09/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/DiagnosticAnalyzerDriver/DiagnosticAnalyzerDriverTests.cs</File>
      <File>src/EditorFeatures/Core/Implementation/RenameTracking/RenameTrackingDiagnosticAnalyzer.cs</File>
      <File>src/EditorFeatures/Test/CodeLens/AbstractCodeLensTest.cs</File>
      <File>src/EditorFeatures/Test/Diagnostics/AbstractSuppressionAllCodeTests.cs</File>
      <File>src/Features/CSharp/Portable/AddBraces/CSharpAddBracesDiagnosticAnalyzer.cs</File>
      <File>src/Features/CSharp/Portable/Diagnostics/Analyzers/CSharpPreferFrameworkTypeDiagnosticAnalyzer.cs</File>
      <File>src/Features/CSharp/Portable/Diagnostics/Analyzers/CSharpQualifyMemberAccessDiagnosticAnalyzer.cs</File>
      <File>src/Features/CSharp/Portable/Diagnostics/Analyzers/CSharpTypeStyleDiagnosticAnalyzerBase.State.cs</File>
      <File>src/Features/CSharp/Portable/Diagnostics/Analyzers/CSharpTypeStyleDiagnosticAnalyzerBase.cs</File>
      <File>src/Features/CSharp/Portable/InvokeDelegateWithConditionalAccess/InvokeDelegateWithConditionalAccessAnalyzer.cs</File>
      <File>src/Features/Core/Portable/CodeLens/CodeLensReferencesService.cs</File>
      <File>src/Features/Core/Portable/CodeLens/CodeLensReferencesServiceFactory.cs</File>
      <File>src/Features/Core/Portable/CodeLens/ReferenceLocationDescriptor.cs</File>
      <File>src/Features/Core/Portable/CodeLens/ReferenceMethodDescriptor.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/AnalyzerHelper.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/Analyzers/NamingStyles/NamingStyleDiagnosticAnalyzerBase.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/Analyzers/PreferFrameworkTypeDiagnosticAnalyzerBase.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/Analyzers/QualifyMemberAccessDiagnosticAnalyzerBase.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/Analyzers/RemoveUnnecessaryCastDiagnosticAnalyzerBase.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/Analyzers/RemoveUnnecessaryImportsDiagnosticAnalyzerBase.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/Analyzers/RudeEditUserDiagnosticAnalyzer.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/Analyzers/SimplifyTypeNamesDiagnosticAnalyzerBase.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/Analyzers/UnboundIdentifiersDiagnosticAnalyzerBase.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/BaseDiagnosticIncrementalAnalyzer.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/EngineV2/DiagnosticIncrementalAnalyzer_IncrementalAnalyzer.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/IBuiltInAnalyzer.cs</File>
      <File>src/Features/Core/Portable/PopulateSwitch/PopulateSwitchDiagnosticAnalyzer.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Remote/RemoteHostClient.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Remote/RemoteHostClientServiceFactory.RemoteHostClientService.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Remote/RemoteHostClientServiceFactory.SolutionChecksumUpdater.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Remote/RemoteHostClientServiceFactory.cs</File>
      <File>src/VisualStudio/Next/CodeLens/RemoteCodeLensReferencesService.cs</File>
      <File>src/VisualStudio/Next/Diagnostics/OutOfProcDiagnosticAnalyzerExecutor.cs</File>
      <File>src/Workspaces/CSharp/Portable/Execution/CSharpOptionsSerializationService.cs</File>
      <File>src/Workspaces/Core/Portable/CodeStyle/CodeStyleOption.cs</File>
      <File>src/Workspaces/Core/Portable/CodeStyle/NotificationOption.cs</File>
      <File>src/Workspaces/Core/Portable/Execution/AbstractOptionsSerializationService.cs</File>
      <File>src/Workspaces/Core/Portable/Execution/AssetBuilder.cs</File>
      <File>src/Workspaces/Core/Portable/Execution/ChecksumObject.cs</File>
      <File>src/Workspaces/Core/Portable/Execution/ChecksumTreeBuilder.cs</File>
      <File>src/Workspaces/Core/Portable/Execution/ChecksumTreeCollection.TreeNodes.cs</File>
      <File>src/Workspaces/Core/Portable/Execution/ChecksumTreeCollection.cs</File>
      <File>src/Workspaces/Core/Portable/Execution/IChecksumTreeNodes.cs</File>
      <File>src/Workspaces/Core/Portable/Execution/IOptionsSerializationService.cs</File>
      <File>src/Workspaces/Core/Portable/Execution/Serializer.cs</File>
      <File>src/Workspaces/Core/Portable/Execution/Serializer_ChecksumObjectWithChildren.cs</File>
      <File>src/Workspaces/Core/Portable/Execution/Serializer_OptionSet.cs</File>
      <File>src/Workspaces/Core/Portable/Log/FunctionId.cs</File>
      <File>src/Workspaces/CoreTest/Execution/SnapshotSerializationTests.cs</File>
      <File>src/Workspaces/Remote/Core/Services/AssetService.cs</File>
      <File>src/Workspaces/Remote/Core/Services/SolutionService.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/CodeLens/CodeLensArguments.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Diagnostics/DiagnosticArguments.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Services/CodeAnalysisService_CodeLens.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Services/CodeAnalysisService_Diagnostics.cs</File>
      <File>src/Workspaces/Remote/ServiceHub/Shared/WellKnownServiceHubServices.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>13765</IssueID>
    <Title>Implement code gen for expression-bodied ctor and dtor</Title>
    <Description>Fixes #13578
Fixes #13691
Fixes #13692 
@dotnet/roslyn-compiler @lachbaer Please Review.
</Description>
    <CreatedDate>13/09/2016</CreatedDate>
    <ClosedDate>22/09/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>13578</IssueID>
        <Title>Need tests for expression-bodied ctors, dtors, and accessors</Title>
        <Description>including semantic model tests targeting those scenarios.

Addendum: This is now mostly done in https://github.com/dotnet/roslyn/pull/13695, but there is a suggestion in https://github.com/dotnet/roslyn/pull/13695#discussion_r78219131 for additional tests:

&gt; Looking back at the change with the feature code (PR 13543), some additional test suggestions:
&gt; - features disabled (errors for IDS_FeatureExpressionBodiedAccessor and IDS_FeatureExpressionBodiedDeOrConstructor)
&gt; - a direct parsing test for expression and constructor/deconstructor
</Description>
        <CreatedDate>02/09/2016</CreatedDate>
        <ClosedDate>22/09/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>13691</IssueID>
        <Title>expression-bodied ctor fails to generate call to base()</Title>
        <Description>The following test fails on the `features/exprbody` branch:

``` cs
        [Fact]
        public void RunCtorProp()
        {
            string source = @"
using System;
public class Program 
{
    static void Main()
    {
        var p = new Program();
        p.Prop = 2;
    }
    Program() =&gt; Console.Write(1);
    int Prop { set =&gt; Console.Write(value); }
    ~Program() =&gt; Console.Write(string.Empty);
}
";
            CompileAndVerify(source, expectedOutput: "12");
        }
```

with

``` none
Test 'Microsoft.CodeAnalysis.CSharp.Semantic.UnitTests.Semantics.ExpressionBodiedMemberTests.RunCtorProp' failed: Microsoft.CodeAnalysis.Test.Utilities.PeVerifyException : 
PeVerify failed for assembly 'C:\Users\ngafter\AppData\Local\Temp\':
[ : Program::.ctor][mdToken=0x6000002][offset 0x00000006] Return from .ctor when this is uninitialized.


    RuntimeAssemblyManager.cs(471,0): at Microsoft.CodeAnalysis.Test.Utilities.RuntimeAssemblyManager.PeVerifyModules(String[] modulesToVerify, Boolean throwOnError)
    at Microsoft.CodeAnalysis.Test.Utilities.RuntimeAssemblyManager.PeVerifyModules(String[] modulesToVerify, Boolean throwOnError)
    HostedRuntimeEnvironment.cs(304,0): at Microsoft.CodeAnalysis.Test.Utilities.HostedRuntimeEnvironment.PeVerify()
    CommonTestBase.CompilationVerifier.cs(99,0): at Microsoft.CodeAnalysis.Test.Utilities.CommonTestBase.CompilationVerifier.Emit(String expectedOutput, IEnumerable`1 manifestResources, EmitOptions emitOptions, Boolean peVerify, SignatureDescription[] expectedSignatures)
    D:\Roslyn\src\Test\Utilities\Desktop\CommonTestBase.cs(212,0): at Microsoft.CodeAnalysis.Test.Utilities.CommonTestBase.Emit(Compilation compilation, IEnumerable`1 dependencies, IEnumerable`1 manifestResources, SignatureDescription[] expectedSignatures, String expectedOutput, Action`1 assemblyValidator, Action`1 symbolValidator, EmitOptions emitOptions, Boolean verify)
    D:\Roslyn\src\Test\Utilities\Desktop\CommonTestBase.cs(135,0): at Microsoft.CodeAnalysis.Test.Utilities.CommonTestBase.CompileAndVerify(Compilation compilation, IEnumerable`1 manifestResources, IEnumerable`1 dependencies, Action`1 sourceSymbolValidator, Action`1 assemblyValidator, Action`1 symbolValidator, SignatureDescription[] expectedSignatures, String expectedOutput, EmitOptions emitOptions, Boolean verify)
    D:\Roslyn\src\Test\Utilities\Desktop\CommonTestBase.cs(89,0): at Microsoft.CodeAnalysis.Test.Utilities.CommonTestBase.CompileAndVerify(String[] sources, IEnumerable`1 additionalRefs, IEnumerable`1 dependencies, Action`1 sourceSymbolValidator, Action`1 assemblyValidator, Action`1 symbolValidator, SignatureDescription[] expectedSignatures, String expectedOutput, CompilationOptions options, ParseOptions parseOptions, EmitOptions emitOptions, Boolean verify)
    D:\Roslyn\src\Test\Utilities\Desktop\CommonTestBase.cs(53,0): at Microsoft.CodeAnalysis.Test.Utilities.CommonTestBase.CompileAndVerify(String source, IEnumerable`1 additionalRefs, IEnumerable`1 dependencies, Action`1 sourceSymbolValidator, Action`1 assemblyValidator, Action`1 symbolValidator, SignatureDescription[] expectedSignatures, String expectedOutput, CompilationOptions options, ParseOptions parseOptions, EmitOptions emitOptions, Boolean verify)
    D:\Roslyn\src\Compilers\Test\Utilities\CSharp.Desktop\CSharpTestBase.cs(81,0): at Microsoft.CodeAnalysis.CSharp.Test.Utilities.CSharpTestBase.CompileAndVerify(String source, IEnumerable`1 additionalRefs, IEnumerable`1 dependencies, Action`1 sourceSymbolValidator, Action`1 assemblyValidator, Action`1 symbolValidator, SignatureDescription[] expectedSignatures, String expectedOutput, CompilationOptions options, ParseOptions parseOptions, EmitOptions emitOptions, Boolean verify)
    Semantics\ExpressionBodiedMemberTests.cs(366,0): at Microsoft.CodeAnalysis.CSharp.Semantic.UnitTests.Semantics.ExpressionBodiedMemberTests.RunCtorProp()
```
</Description>
        <CreatedDate>08/09/2016</CreatedDate>
        <ClosedDate>22/09/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>13692</IssueID>
        <Title>expression-bodied dtor fails to generate call to ~base()</Title>
        <Description>The following test fails on the `features/exprbody` branch:

``` cs
        [Fact]
        public void ExpressionBodiedClassDestructor()
        {
            var text = @"
using System;

public class Base
{
    ~Base() =&gt; Console.WriteLine(""~Base"");
}

public class Program
{
    public static void Main()
    {
        Base b = new Base();
        b = null;
        GC.Collect(GC.MaxGeneration);
        GC.WaitForPendingFinalizers();
    }
}
";
            var validator = GetDestructorValidator("Base");
            var compVerifier = CompileAndVerify(text,
                sourceSymbolValidator: validator,
                symbolValidator: validator,
                expectedOutput: @"~Base",
                expectedSignatures: new[]
                {
                    Signature("Base", "Finalize", ".method family hidebysig virtual instance System.Void Finalize() cil managed")
                });

            compVerifier.VerifyIL("Base.Finalize", @"
{
  // Code size       20 (0x14)
  .maxstack  1
  .try
  {
    IL_0000:  ldstr      ""~Base""
    IL_0005:  call       ""void System.Console.WriteLine(string)""
    IL_000a:  leave.s    IL_0013
  }
  finally
  {
    IL_000c:  ldarg.0
    IL_000d:  call       ""void object.Finalize()""
    IL_0012:  endfinally
  }
  IL_0013:  ret
}
");
        }
```

with

``` none
------ Test started: Assembly: Roslyn.Compilers.CSharp.Emit.UnitTests.dll ------

Unknown .NET Framework Version: v4.6
Test 'Microsoft.CodeAnalysis.CSharp.UnitTests.CodeGen.DestructorTests.ExpressionBodiedClassDestructor' failed: 
Expected:
{
  // Code size       20 (0x14)
  .maxstack  1
  .try
  {
    IL_0000:  ldstr      ""~Base""
    IL_0005:  call       ""void System.Console.WriteLine(string)""
    IL_000a:  leave.s    IL_0013
  }
  finally
  {
    IL_000c:  ldarg.0
    IL_000d:  call       ""void object.Finalize()""
    IL_0012:  endfinally
  }
  IL_0013:  ret
}
Actual:
{
  // Code size       11 (0xb)
  .maxstack  1
  IL_0000:  ldstr      ""~Base""
  IL_0005:  call       ""void System.Console.WriteLine(string)""
  IL_000a:  ret
}
Differences:
    {
++&gt;   // Code size       11 (0xb)
--&gt;   // Code size       20 (0x14)
      .maxstack  1
++&gt;   IL_0000:  ldstr      ""~Base""
++&gt;   IL_0005:  call       ""void System.Console.WriteLine(string)""
++&gt;   IL_000a:  ret
--&gt;   .try
--&gt;   {
--&gt;     IL_0000:  ldstr      ""~Base""
--&gt;     IL_0005:  call       ""void System.Console.WriteLine(string)""
--&gt;     IL_000a:  leave.s    IL_0013
--&gt;   }
--&gt;   finally
--&gt;   {
--&gt;     IL_000c:  ldarg.0
--&gt;     IL_000d:  call       ""void object.Finalize()""
--&gt;     IL_0012:  endfinally
--&gt;   }
--&gt;   IL_0013:  ret
    }

Expected: True
Actual:   False
    D:\Roslyn\src\Test\Utilities\Shared\Assert\AssertEx.cs(340,0): at Roslyn.Test.Utilities.AssertEx.AssertEqualToleratingWhitespaceDifferences(String expected, String actual, Boolean escapeQuotes, String expectedValueSourcePath, Int32 expectedValueSourceLine)
    CommonTestBase.CompilationVerifier.cs(187,0): at Microsoft.CodeAnalysis.Test.Utilities.CommonTestBase.CompilationVerifier.VerifyILImpl(String qualifiedMethodName, String expectedIL, Boolean realIL, String sequencePoints, String callerPath, Int32 callerLine, Boolean escapeQuotes)
    CommonTestBase.CompilationVerifier.cs(157,0): at Microsoft.CodeAnalysis.Test.Utilities.CommonTestBase.CompilationVerifier.VerifyIL(String qualifiedMethodName, String expectedIL, Boolean realIL, String sequencePoints, String callerPath, Int32 callerLine)
    CodeGen\DestructorTests.cs(110,0): at Microsoft.CodeAnalysis.CSharp.UnitTests.CodeGen.DestructorTests.ExpressionBodiedClassDestructor()

0 passed, 1 failed, 0 skipped, took 4.02 seconds (xUnit.net 2.1.0 build 3179).
```
</Description>
        <CreatedDate>08/09/2016</CreatedDate>
        <ClosedDate>22/09/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Compiler/MethodBodySynthesizer.cs</File>
      <File>src/Compilers/CSharp/Portable/Compiler/MethodCompiler.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/DestructorTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/ExpressionBodiedMemberTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/DeclarationParsingTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>13747</IssueID>
    <Title>Fix crash on "is type" operator with typeless tuple expression.</Title>
    <Description>Add tests for non-reproducible issue #13723
Fixes #13746 
Also rename an error code for clarity.

@VSadov @jcouv Please review
@dotnet/roslyn-compiler More reviews welcome!
</Description>
    <CreatedDate>12/09/2016</CreatedDate>
    <ClosedDate>13/09/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>13723</IssueID>
        <Title>Compiler crashes when using a constant pattern against an expression that doesn't have a type</Title>
        <Description>```
        [Fact]
        public void ExpressionWithoutAType()
        {
            var source =
@"
public class Vec
{
    public static void Main()
    {
        if (null is 1)
        {}
    }
}
";

            CreateCompilationWithMscorlib45(source, options: TestOptions.DebugExe).VerifyDiagnostics(
                );
        }
```

Observed:

```
Test 'M:Microsoft.CodeAnalysis.CSharp.UnitTests.PatternMatchingTests.ExpressionWithoutAType' failed: Object reference not set to an instance of an object.
    System.NullReferenceException: Object reference not set to an instance of an object.
    Binder\Semantics\Conversions\ConversionsBase.cs(1065,0): at Microsoft.CodeAnalysis.CSharp.ConversionsBase.HasImplicitEnumerationConversion(BoundExpression source, TypeSymbol destination)
    Binder\Semantics\Conversions\ConversionsBase.cs(786,0): at Microsoft.CodeAnalysis.CSharp.ConversionsBase.ClassifyImplicitBuiltInConversionFromExpression(BoundExpression sourceExpression, TypeSymbol source, TypeSymbol destination, HashSet`1&amp; useSiteDiagnostics)
    Binder\Semantics\Conversions\ConversionsBase.cs(57,0): at Microsoft.CodeAnalysis.CSharp.ConversionsBase.ClassifyImplicitConversionFromExpression(BoundExpression sourceExpression, TypeSymbol destination, HashSet`1&amp; useSiteDiagnostics)
    Binder\Binder_Statements.cs(2369,0): at Microsoft.CodeAnalysis.CSharp.Binder.GenerateConversionForAssignment(TypeSymbol targetType, BoundExpression expression, DiagnosticBag diagnostics, Boolean isDefaultParameter, RefKind refKind)
    Binder\Binder_Patterns.cs(140,0): at Microsoft.CodeAnalysis.CSharp.Binder.ConvertPatternExpression(TypeSymbol inputType, CSharpSyntaxNode node, BoundExpression expression, ConstantValue&amp; constantValue, DiagnosticBag diagnostics)
    Binder\Binder_Patterns.cs(124,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindConstantPattern(CSharpSyntaxNode node, BoundExpression operand, TypeSymbol operandType, ExpressionSyntax patternExpression, Boolean hasErrors, DiagnosticBag diagnostics, Boolean&amp; wasExpression, Boolean wasSwitchCase)
    Binder\Binder_Patterns.cs(38,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindPattern(PatternSyntax node, BoundExpression operand, TypeSymbol operandType, Boolean hasErrors, DiagnosticBag diagnostics, Boolean wasSwitchCase)
    Binder\Binder_Patterns.cs(17,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindIsPatternExpression(IsPatternExpressionSyntax node, DiagnosticBag diagnostics)
    Binder\Binder_Expressions.cs(623,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed)
    Binder\Binder_Expressions.cs(396,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindExpression(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed)
    Binder\Binder_Statements.cs(2848,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindBooleanExpression(ExpressionSyntax node, DiagnosticBag diagnostics)
    Binder\Binder_Statements.cs(2804,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindIfStatement(IfStatementSyntax node, DiagnosticBag diagnostics)
    Binder\Binder_Statements.cs(50,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics)
    Binder\Binder_Statements.cs(2315,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindBlockParts(BlockSyntax node, DiagnosticBag diagnostics)
    Compiler\MethodCompiler.cs(1550,0): at Microsoft.CodeAnalysis.CSharp.MethodCompiler.BindMethodBody(MethodSymbol method, TypeCompilationState compilationState, DiagnosticBag diagnostics, ImportChain&amp; importChain, Boolean&amp; originalBodyNested)
    Compiler\MethodCompiler.cs(878,0): at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethod(MethodSymbol methodSymbol, Int32 methodOrdinal, ProcessedFieldInitializers&amp; processedInitializers, SynthesizedSubmissionFields previousSubmissionFields, TypeCompilationState compilationState)
    Compiler\MethodCompiler.cs(433,0): at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(NamedTypeSymbol containingType)
    Compiler\MethodCompiler.cs(323,0): at Microsoft.CodeAnalysis.CSharp.MethodCompiler.&lt;&gt;c__DisplayClass20_0.&lt;CompileNamedTypeAsTask&gt;b__0()
    InternalUtilities\UICultureUtilities.cs(136,0): at Roslyn.Utilities.UICultureUtilities.&lt;&gt;c__DisplayClass5_0.&lt;WithCurrentUICulture&gt;b__0()
    at System.Threading.Tasks.Task.InnerInvoke()
    at System.Threading.Tasks.Task.Execute()
    --- End of stack trace from previous location where exception was thrown ---
    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
    Compiler\MethodCompiler.cs(238,0): at Microsoft.CodeAnalysis.CSharp.MethodCompiler.WaitForWorkers()
    Compiler\MethodCompiler.cs(137,0): at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethodBodies(CSharpCompilation compilation, PEModuleBuilder moduleBeingBuiltOpt, Boolean generateDebugInfo, Boolean hasDeclarationErrors, DiagnosticBag diagnostics, Predicate`1 filterOpt, CancellationToken cancellationToken)
    Compilation\CSharpCompilation.cs(2004,0): at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnosticsForAllMethodBodies(DiagnosticBag diagnostics, CancellationToken cancellationToken)
    Compilation\CSharpCompilation.cs(1971,0): at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnostics(CompilationStage stage, Boolean includeEarlierStages, CancellationToken cancellationToken)
    Compilation\CSharpCompilation.cs(1910,0): at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnostics(CancellationToken cancellationToken)
    DiagnosticExtensions.cs(98,0): at Microsoft.CodeAnalysis.DiagnosticExtensions.VerifyDiagnostics[TCompilation](TCompilation c, DiagnosticDescription[] expected)
    Semantics\PatternMatchingTests.cs(14567,0): at Microsoft.CodeAnalysis.CSharp.UnitTests.PatternMatchingTests.ExpressionWithoutAType()
```
</Description>
        <CreatedDate>10/09/2016</CreatedDate>
        <ClosedDate>13/09/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>13746</IssueID>
        <Title>Compiler crashes with typeless tuple on the left of an is-type operator</Title>
        <Description>``` cs
        [Fact]
        public void ExpressionWithoutAType()
        {
            var source =
@"
public class Vec
{
    public static void Main()
    {
        if ((1, null) is Vec)
        {}
    }
}
";

            CreateCompilationWithMscorlib45(source, options: TestOptions.DebugExe).VerifyDiagnostics(
                );
        }
```

this crashes the C# compiler.
</Description>
        <CreatedDate>12/09/2016</CreatedDate>
        <ClosedDate>13/09/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Operators.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/SwitchBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/CSharpResources.Designer.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/ErrorCode.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternSwitchTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/SwitchTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/PatternParsingTests.cs</File>
      <File>src/Test/Utilities/Shared/Traits/CompilerFeature.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>13720</IssueID>
    <Title>Remove an incorrect ContainsDiagnostics test in LanguageParser</Title>
    <Description>by which the presence of a nested warning could suppress
what should be an error. Also adds a test for #13719, which is
related.
Fixes #13667 

@VSadov @jcouv @dotnet/roslyn-compiler Please review
@jaredpar You might want to look at this too, since you were **_sooooo**_ interested in the issue ;)
</Description>
    <CreatedDate>09/09/2016</CreatedDate>
    <ClosedDate>12/09/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>13719</IssueID>
        <Title>Roslyn fails to give syntax error for incomplete member that contains a lexical warning</Title>
        <Description>The following program contains an obvious syntax error, but Roslyn compiles it successfully!

``` cs
class A
{
    [Obsolete(2l)]
    public int
}
```

This was discovered while investigating #13667. Each of the places in the parser that tests whether or not a node contains diagnostics should be checked to see if that test is correct.
</Description>
        <CreatedDate>09/09/2016</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>13667</IssueID>
        <Title>Untested code in parsing tuples.</Title>
        <Description>The following code appears in `LanguageParser.cs`:

``` cs
                if (!result.ContainsDiagnostics &amp;&amp; list.Count &lt; 2)
                {
                    result = this.AddError(result, ErrorCode.ERR_TupleTooFewElements);
                }
```

but the condition `result.ContainsDiagnostics` doesn't make a difference in any compiler tests. It should probably be removed or tested.

(Note that `ContainsDiagnostics` does not test for errors in the node, or even errors anywhere beneath the node)
</Description>
        <CreatedDate>07/09/2016</CreatedDate>
        <ClosedDate>12/09/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Parser/LanguageParser.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenExprLambdaTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Compilation/CompilationAPITests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/ParserRegressionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/ValueTupleTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>13675</IssueID>
    <Title>Handle names correctly in long tuples in EE</Title>
    <Description>Port #13651 to dev15-preview-5.

Fixes #13625.
</Description>
    <CreatedDate>08/09/2016</CreatedDate>
    <ClosedDate>08/09/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>13651</IssueID>
        <Title>Handle names in long tuples in EE</Title>
        <Description>Handle names in long tuples in EE

Fixes #13625
</Description>
        <CreatedDate>07/09/2016</CreatedDate>
        <ClosedDate>07/09/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>13625</IssueID>
        <Title>Incorrect names in the EE in long tuple</Title>
        <Description>Names in the last nested tuple of `C.F` are incorrect in the EE.

```
class C
{
    static ((int A, (int B, int C) D, int E, int F, int G, int H, int I, int J) K, (int L, int M, int N) O) F =
        ((1, (2, 3), 4, 5, 6, 7, 8, 9), (10, 11, 12));
}
```

Result:

```
((int A, (int B, int C) D, int E, int F, int G, int H, int I, int J) K, (int, int L, int M) O)
```
</Description>
        <CreatedDate>06/09/2016</CreatedDate>
        <ClosedDate>07/09/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/ExpressionEvaluator/CSharp/Test/ResultProvider/TupleTests.cs</File>
      <File>src/ExpressionEvaluator/Core/Source/ExpressionCompiler/CustomTypeInfo.cs</File>
      <File>src/ExpressionEvaluator/Core/Source/ResultProvider/Formatter.TypeNames.cs</File>
      <File>src/ExpressionEvaluator/Core/Source/ResultProvider/Helpers/AttributeHelpers.cs</File>
      <File>src/ExpressionEvaluator/Core/Source/ResultProvider/Helpers/CustomTypeInfoTypeArgumentMap.cs</File>
      <File>src/ExpressionEvaluator/Core/Source/ResultProvider/Helpers/TypeHelpers.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>13648</IssueID>
    <Title>Revert an incorrect optimization in binary operator overload resolution</Title>
    <Description>from PR #9543; issue #13380 shows why the optimization is not correct.

@dotnet/roslyn-compiler Please review
/cc @VSadov @tmat @agocke @AlekseyTs
</Description>
    <CreatedDate>07/09/2016</CreatedDate>
    <ClosedDate>12/09/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>9543</IssueID>
        <Title>more allocation reduction.</Title>
        <Description>- avoid instantiating nullable type when doing operator overloading on enums
- avoid instantiating generics when checking for impossibly rare case of duplicated interface implementations
- skipping materializing of sequence point array
</Description>
        <CreatedDate>08/03/2016</CreatedDate>
        <ClosedDate>08/03/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>13380</IssueID>
        <Title>Error combining nullable and implicit operators</Title>
        <Description>Consider the following code

``` csharp
public class Class1
{
    public Class1()
    {
        var a = new Registration&lt;Something&gt;();
        var x = (a == Something.Bad);                    //this line fails in VS2015.3
    }
}

public struct Registration&lt;T&gt; where T : struct
{
    public static implicit operator T? (Registration&lt;T&gt; registration)
    {
        return null;
    }
}

public enum Something
{
    Good,
    Bad
}

```

This compiled fine in VS 2013 and VS 2015 Update 2 (not fully verified).  Need to make sure we fix this regression for the next version. 
</Description>
        <CreatedDate>25/08/2016</CreatedDate>
        <ClosedDate>12/09/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/Operators/BinaryOperatorOverloadResolution.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/Operators/UnaryOperatorOverloadResolution.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/OverloadResolutionTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>12841</IssueID>
    <Title>We introduce a "ref type" for use in declarations</Title>
    <Description>  (e.g. ref local variable declaration)
We introduce a "ref expression" for use in expressions
  (e.g. right-hand-side of a ref variable initialization)
Also improve the diagnostic for local functions.
Fixes #12749, #12580 

@VSadov @dotnet/roslyn-compiler Please review.
</Description>
    <CreatedDate>30/07/2016</CreatedDate>
    <ClosedDate>06/08/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>12749</IssueID>
        <Title>SyntaxExtensions deletions around ref</Title>
        <Description>**From API Review**

The `SyntaxExtensions` class has two methods which should be deleted once the `ref` changes go through:

```
        public static IndexerDeclarationSyntax Update(this IndexerDeclarationSyntax syntax, SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, SyntaxToken refKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList);
        public static MethodDeclarationSyntax Update(this MethodDeclarationSyntax syntax, SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, SyntaxToken refKeyword, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt; constraintClauses, BlockSyntax block, SyntaxToken semicolonToken);
```
</Description>
        <CreatedDate>26/07/2016</CreatedDate>
        <ClosedDate>06/08/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>12580</IssueID>
        <Title>Change syntax model of ref returns/locals/assignments.</Title>
        <Description>For declarations, we want to:

1)  Put ‘ref’ in the modifiers list for declarations.  i.e. with ‘public ref int Foo()’,  ‘ref’ and ‘public’ will be in the same list.
2)  ‘ref’ can be parsed in any order (for error tolerance) in the modifier list, but we will enforce that it must be the last modifier if it is there.
3)  If ‘partial’ is in the list, it can be second to last if and only if it is followed by ‘ref’.

For expressions, we want to:

1)  Introduce a new ‘RefExpression’.  It has the intuitive form:  ref &lt;expression&gt;
2)  We will fix up ‘ParseExpression’ in the parser to pass a value saying if ‘ref expressions’ are allowed or not.  In the cases where we allow them (like “return ref …”) we will pass true, and in all other cases we pass false.  The parser will always parse out a ref expression when possible, but will error if the flag is false.  This means we will produce a good tree for expressions like  “foo ? ref Bar() : ref Baz()”, though we will still emit errors that this form isn’t legal.
3)  We will still produce the same tree nodes for ref arguments.  i.e.  “Foo(ref a)” will have an argument node that has a ref keyword and an ‘a’ expression, it will _not_ have a RefExpression of ‘ref a’.

For for-statements, we want to:

1)  Add a DeclarationModifiers list where ‘ref’ can go.  
2)  We called it ‘DeclarationModifiers’ because we were wary that ‘Modifiers’ might conflict with us adding modifiers to the actual ‘for’ statement in the future.  It also makes it clear what part of the for-statement these modifiers apply to.
</Description>
        <CreatedDate>18/07/2016</CreatedDate>
        <ClosedDate>06/08/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Expressions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Patterns.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Statements.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Symbols.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/CatchClauseBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/FixedStatementBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/ForLoopBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/LocalScopeBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/PatternVariableBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/PatternVariableFinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/UsingStatementBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/UnboundLambda.cs</File>
      <File>src/Compilers/CSharp/Portable/CSharpResources.Designer.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/CSharpSemanticModel.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/MemberSemanticModel.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/DiagnosticsPass_ExpressionTrees.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/Instrumentation/DynamicAnalysisInjector.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/LanguageParser.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/LocalFunctionSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceDelegateMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceLocalSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceMemberMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourcePropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/ArrowExpressionClauseSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/DelegateDeclarationSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/EqualsValueClauseSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/ForStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/IncompleteMemberSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/IndexerDeclarationSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/LocalDeclarationStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/MethodDeclarationSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/ParenthesizedLambdaExpressionSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/PropertyDeclarationSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/ReturnStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/SimpleLambdaExpressionSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/SyntaxExtensions.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/SyntaxKind.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/SyntaxNodeExtensions.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenRefLocalTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenRefReturnTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/ConstantTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/LocalFunctionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/Source/MethodTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/DeclarationParsingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/ExpressionParsingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/LocalFunctionParsingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/StatementParsingTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/CodeActions/InlineTemporary/InlineTemporaryTests.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Source/ExpressionCompiler/Binders/PlaceholderLocalBinder.cs</File>
      <File>src/Features/CSharp/Portable/ChangeSignature/CSharpChangeSignatureService.cs</File>
      <File>src/Features/CSharp/Portable/CodeFixes/Async/CSharpAddAsyncCodeFixProvider.cs</File>
      <File>src/Features/CSharp/Portable/CodeRefactorings/InlineTemporary/InlineTemporaryCodeRefactoringProvider.cs</File>
      <File>src/Features/CSharp/Portable/ExtractMethod/CSharpMethodExtractor.CSharpCodeGenerator.CallSiteContainerRewriter.cs</File>
      <File>src/Features/CSharp/Portable/ExtractMethod/CSharpMethodExtractor.CSharpCodeGenerator.cs</File>
      <File>src/Features/CSharp/Portable/Organizing/Organizers/IndexerDeclarationOrganizer.cs</File>
      <File>src/Features/CSharp/Portable/Organizing/Organizers/MethodDeclarationOrganizer.cs</File>
      <File>src/Samples/CSharp/APISampleUnitTests/SyntaxTrees.cs</File>
      <File>src/VisualStudio/CSharp/Test/Debugging/LocationInfoGetterTests.cs</File>
      <File>src/Workspaces/CSharp/Portable/CodeGeneration/CSharpSyntaxGenerator.cs</File>
      <File>src/Workspaces/CSharp/Portable/CodeGeneration/MethodGenerator.cs</File>
      <File>src/Workspaces/CSharp/Portable/Extensions/ITypeSymbolExtensions.cs</File>
      <File>src/Workspaces/CSharp/Portable/Simplification/CSharpMiscellaneousReducer.cs</File>
      <File>src/Workspaces/CSharp/Portable/Simplification/CSharpSimplificationService.Expander.cs</File>
      <File>src/Workspaces/CSharpTest/Formatting/FormattingElasticTriviaTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>12692</IssueID>
    <Title>Fix #12421 - Make CSharpSyntaxFactsService a singleton</Title>
    <Description>Closes #12421 (the C# half #12424), making `CSharpSyntaxFactsService` a singleton.
</Description>
    <CreatedDate>23/07/2016</CreatedDate>
    <ClosedDate>01/08/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>12421</IssueID>
        <Title>SyntaxTokenExtensions.IsWord is inefficient</Title>
        <Description>The implementation of [`SyntaxTokenExtensions.IsWord`](https://github.com/dotnet/roslyn/blob/1ccc08dc3006342822f4bcd4f9cde8230c117943/src/Workspaces/CSharp/Portable/Extensions/SyntaxTokenExtensions.cs#L77) could do with some tuning around allocations:

```
private static bool IsWord(SyntaxToken token)
{
    return new CSharpSyntaxFactsService().IsWord(token);
}
```

Just typing up a simple method declaration in C# I got nearly 2500 breakpoint hits on this method, and VB has a [similar implementation](https://github.com/dotnet/roslyn/blob/1ccc08dc3006342822f4bcd4f9cde8230c117943/src/Workspaces/VisualBasic/Portable/Extensions/SyntaxTokenExtensions.vb#L242).
</Description>
        <CreatedDate>10/07/2016</CreatedDate>
        <ClosedDate>01/08/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>12424</IssueID>
        <Title>VisualBasicSyntaxFactService shared default instance.</Title>
        <Description>implements #12421
</Description>
        <CreatedDate>10/07/2016</CreatedDate>
        <ClosedDate>19/07/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/ExtractMethod/MiscTests.cs</File>
      <File>src/EditorFeatures/Test/TestExportProvider.cs</File>
      <File>src/Workspaces/CSharp/Portable/Extensions/SyntaxTokenExtensions.cs</File>
      <File>src/Workspaces/CSharp/Portable/LanguageServices/CSharpSyntaxFactsService.cs</File>
      <File>src/Workspaces/CSharp/Portable/LanguageServices/CSharpSyntaxFactsServiceFactory.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>12353</IssueID>
    <Title>Add support for embedding C# source in portable pdb</Title>
    <Description>Implement #12625 for C# and portable PDBs. Native PDB and VB implementation to follow as separate change once this is approved. 

Also fix #12814
</Description>
    <CreatedDate>06/07/2016</CreatedDate>
    <ClosedDate>11/08/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>12625</IssueID>
        <Title>Proposal: Embed sources in PDBs</Title>
        <Description># Implementation progress
- [x] Portable PDB support (#12353)
- [x] C# support (#12353)
- [x] VB support (#13137)

Windows PDB support is tracked by #13707.

This proposal addresses #5397, which requests a feature for embedding source code inside of a PDB.
# Scenarios
## Recap from #5397

&gt; - During the build, source code is auto-generated and then compiled. This auto-generated source does not exist on source control server and is often not preserved as a build artifact. Even if it is preserved, it can't be indexed on a symbol server making acquisition difficult at debug time. 
&gt; - A company is OK from an IP standpoint to release source for some of their projects, but their source control system is behind a firewall. Their IT security policies prevent giving any external access to the source control system, which prevents typical usage of source server. They already provide PDBs to customers, and by including source in the PDBs the customer's debugging experience improves with minimal additional work.
&gt; - An Open Source project is doing all their development on GitHub and they current use source server to distribute source, but they don't like additional configuration necessary in VS to enable it. By distributing the source in the PDB they eliminate this additional configuration.
## Also
- See #12390, which requests embedding PDBs in PE files and argues for the power of combining that with this.
- Binary analysis is often chosen due to the ease of acquiring binaries over integrating in to someone else's build, but comes at the cost of precision. This is a step towards having tools that can be pointed at a binaries, but analyze source, which was my primary motivation for contributing to this. There's more that I want to see in that direction: e.g. serialized compilation options, reference MVIDs in PDB -- ultimately enough to reproduce the compilation from a binary. Access to generated code was just one piece of that, but it overlaps with with the use cases noted above and provides substantial value on its own. 
# Command Line Usage

Since common usage will already leverage a source server and only require generated code to be embedded, we need to be able to specify the files to embed individually.

**Proposal:** Add a new `/embed` switch for vbc.exe and csc.exe: 
-   `/embed`: embeds all source files in the PDB.
-   `/embed:&lt;file list&gt;`:  embeds specific files in the PDB. 
-  `&lt;file list&gt;` shall be parsed exactly as `/additionalfile` with semicolon separation and wildcard expansion.
- If specific source files are to be embedded, they need to be specified as source files in the usual way AND passed to `/embed`. 
  &gt; NOTE: Some care should be taken in the compiler not to read the same files twice. The approach we landed on in design review is that if the `/embed` argument and source argument expand to the exact same full path (without normalization applied and case-sensitively), then we will not re-read the text of the source file. However, in the edge case, different spelling of the same file on the command line can lead to reading the same file more than once. It may also lead to repeated document entries in the PDB unless the difference is eliminated by the path normalization or the language specific case-sensitivity policy in place by the underlying debug document table. An earlier version of this proposal attempted to address these issues by having distinct mechanism for embedding source files (without repeating their paths) and additional files. However, it was decided in design review that the complexity added to the command line and API was not worth the marginal gain.
- It is **not** an error to pass a file that does not represent source in the compilation to /embed. Such files will simply be added to the PDB, which is a deliberate feature.
- It **is** an error to pass `/embed` without /debug: we can't embed text in the PDB if we're not emitting a PDB.
- All files passed to `/embed` shall be included in the PDB regardless of whether or not there are sequence points targeting it.
## Examples
- Embed no sources in PDB (default)

```
csc /debug+ *.cs 
```
- Embed all sources in PDB

```
csc /debug+ /embed
```
- Embed only some sources in PDB

```
csc /debug+ src\*.cs /embed:generated\*.cs
```
# #line directives

There is also a scenario where debugging requires external files that are not part of the compilation and are lined up to the actual source code via #line directives. 

**Proposal:**  A file targeted by a #line directive shall be embedded in the PDB if either the target file or the referencing source file are embedded.
### Example
#### source.cs

``` C#
class P {
    static void Main() {
#line 1 "example.xyz"
          System.Console.WriteLine("Hello World");
    }
}
```
#### example.xyz

```
print "Hello World"
```
- Compile source.cs and embed only example.xyz in pdb 
- Here we're explicitly asking to embed only example.xyz

```
csc source.cs /embed:example.xyz /debug+   
```
- Compile source.cs and embed both source.cs  
  - Here's we're asking to embed all source and some source further pulls in example.xyz via #line.

```
csc source.cs /embed /debug+
```
- Compile source.cs and embed source.cs and example.xyz in pdb 
  - Here we're explicitly asking to embed source.cs, which further pulls in example.xyz via #line. 

```
csc source.cs /embed:source.cs /debug+
```
## Source Generators

This feature would pair nicely with https://github.com/dotnet/roslyn/blob/features/source-generators/docs/features/generators.md if/when both land, allowing generator output to be debugged without any requirement to acquire (or regenerate) the output by some other means.

We might choose to handle embedding source generator output in one of 3 ways:
1. Always embed generator output if a PDB is being emitted.
2. Add a way to decorate a generator as opting in (or out) of having its output embedded.
3. Add a command-line 

After much discussion about an earlier version of this proposal, there was a strong desire to keep the command-line interface minimal, so I think (1) or (2) should be preferred. I personally think always embedding generator output is the best option as it means that generators get good debuggability with no fuss. We could always add a command-line or generator API opt-out later if there was anyone pushing back on embedding the generator output.

I propose that we open a separate follow-up issue to track how to integrate these two features after both have arrived in a common branch and discuss 1-3 or other alternatives there.
## Command Line API

**Proposal**: Add a property to `Microsoft.CodeAnalysis.CommandLineArguments` to indicate a list of files to be embedded in the PDB.

``` C#
public class CommandLineArguments {
    ...
    // New property: file to be embedded in the PDB.
    public IEnumerable&lt;CommandLineSourceFile&gt; EmbeddedFiles { get; }
}
```

Note that if /embed is specified without arguments it is surfaced here by appending the full set of source files to this list and not via a separate API.
## Emit API

It should be possible to embed source and additional text via public API without routing through the command-line compiler interface.

**Proposal**: 
_NOTE:_ Additions of optional parameters below to be done in the usual binary-compat-preserving way.

``` C#
namespace Microsoft.CodeAnalysis.Text {
     // ...
     public abstract class SourceText {
           //...
           public static SourceText From(
              // existing parameters
              Stream stream,
              Encoding encoding = null,
              SourceHashAlgorithm checksumAlgorithm = SourceHashAlgorithm.Sha1,
              bool throwIfBinaryDetected = false,

              // new parameter: capture enough information to save exact original bytes to PDB 
              bool canBeEmbedded = false);

        public static SourceText From(
              // existing parameters
              byte[] buffer, 
              int length, 
              Encoding encoding = null, 
              SourceHashAlgorithm checksumAlgorithm = SourceHashAlgorithm.Sha1,
              bool throwIfBinaryDetected = false,

              // new parameter: capture enough information to save exact original bytes to PDB 
              bool canBeEmbedded = false);

         // new property: indicates if it is possible to create EmbeddedText from instance. 
         // Either canBeEmbedded=true must have been specified with original bytes, or, 
         // if not constructed from bytes/stream, must have Encoding.
         public bool CanBeEmbedded { get; }
     }
}

namespace Microsoft.CodeAnalysis {
    public abstract class Compilation {
        // ...
        public EmitResult Emit(
            // Existing parameters 
            Stream peStream,
            Stream pdbStream = null,
            Stream xmlDocumentationStream = null,
            Stream win32Resources = null,
            IEnumerable&lt;ResourceDescription&gt; manifestResources = null,
            EmitOptions options = null,
            IMethodSymbol debugEntryPoint = null,

             // New parameter: specify the texts (with their paths) to embed
            IEnumerable&lt;EmbeddedText&gt; embeddedTexts = null,

            // Existing parameter
            CancellationToken cancellationToken = default(CancellationToken));
    }

    // new type
    public sealed class EmbeddedText {
        private  EmbeddedText();

        public string FilePath { get; }
        public SourceHashAlgorithm ChecksumAlgorithm { get; }
        public ImmutableArray&lt;byte&gt; Checksum { get; }

         // create embedded text from source text, SourceText.CanBeEmbedded must be true
        public static EmbeddedText FromSource(string filePath, SourceText text)

        // create embedded text from a stream (for file that is not source)
        public static EmbeddedText FromStream(string filePath, Stream stream, SourceHashAlgorithm checksumAlgorithm = SourceHashAlgorithm.Sha1)

       // create embedded text from bytes in memory (for file that is not source)
       public static EmbeddedText FromBytes(string filePath, ArraySegment&lt;byte&gt; bytes, SourceHashAlgorithm checksumAlgorithm = SourceHashAlgorithm.Sha1)
    }
}
```

Note that it is the caller's responsibility to the gather source and non-source text as appropriate. Text will line up with corresponding source/sequence points by the existing mechanism for de-duping debug documents generated by source trees, `#line`, and `#pragma checksum`: i.e. paths will be normalized and then compared case-insensitively for VB and case-sensitively for C#. 
## Compression

Files beyond a trivial size should be compressed in the PDB. Deflate format will be used. Tiny files do not benefit from compression and can even waste cycles making the file bigger so we should have a threshold at which we start to compress.
## Encoding

Any source text created from raw bytes/stream shall be copied (or compressed and copied) to the PDB without decoding and re-encoding bytes -&gt; chars -&gt; bytes. This is required since encodings do not always round-trip and the checksum must match the original stream.

A source text created by other means (e.g. string + encoding) in which its checksum will be calculated by encoding to bytes via SoruceText.Encoding, will have its text encoded with SourceText.Encoding. 

See also CanBeEmbedded requirements above, 
## Portable PDB Representation

In portable PDBs, we will put the embedded source as a custom debug info entry (with a new GUID allocated for it) parented by the document entry. 

The blob will have a leading int32, which when zero indicate the remaining bytes are the raw, uncompressed text, and when positive indicates that the remaining bytes are comrpessed by deflate and the positive value is the byte size when decompressed.

Portable PDB spec is being updated accordingly: https://github.com/dotnet/corefx/pull/10560
## Windows PDB Representation

The traditional Windows PDB already had a provision for embedded source, which we will use via [ISymUnmanagedDocumentWriter::SetSource](https://msdn.microsoft.com/en-us/library/ms233148%28v=vs.110%29.aspx).

The corresponding method for reading back the embedded source returned E_NOTIMPL until recently, but I have  made the change to implement it and an update to the [nuget package](https://www.nuget.org/packages/Microsoft.DiaSymReader.Native/) is pending.

The blob format will be identical to the portable PDB. This is already a diasymreader custom PDB "injected source" so we can define the source portion as we wish. Using the same blob for Windows and portable PDBs opens up optimizations in the implementation (less copying) and also simplifies it.
</Description>
        <CreatedDate>19/07/2016</CreatedDate>
        <ClosedDate>09/09/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>12814</IssueID>
        <Title>Gargantuan source files can be silently treated as being much smaller</Title>
        <Description>**Version Used**: 1.3.1.60616 and recent sync to master

**Steps to Reproduce**:
- Run the following script

``` C#
string program = "class P { static void Main() { System.Console.WriteLine(\"hello\"); } }";
string garbage = "@#%@#^@#^!#%#@$%@^";

File.WriteAllText("big.cs", program + garbage, Encoding.ASCII);

using (var s = File.OpenWrite("big.cs"))
{
    s.SetLength((long)uint.MaxValue + 1 + program.Length);
}
```
-  `csc big.cs`

**Expected Behavior**:
Compilation fails (either with a deliberate diagnostic that the stream is too long or with the correct errors that match the full text).

**Actual Behavior**:
Compilation succeeds as it only reads up to `program.Length` due to unchecked cast of stream length to `int`.
</Description>
        <CreatedDate>29/07/2016</CreatedDate>
        <ClosedDate>11/08/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/CSharpResources.Designer.cs</File>
      <File>src/Compilers/CSharp/Portable/CommandLine/CSharpCommandLineParser.cs</File>
      <File>src/Compilers/CSharp/Portable/CommandLine/CSharpCompiler.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/CSharpCompilation.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/ErrorCode.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/MessageProvider.cs</File>
      <File>src/Compilers/CSharp/Test/CommandLine/CommandLineTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/PDB/PDBTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/PDB/PortablePdbTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Compilation/CompilationAPITests.cs</File>
      <File>src/Compilers/Core/CodeAnalysisTest/EmbeddedTextTests.cs</File>
      <File>src/Compilers/Core/CodeAnalysisTest/Text/LargeTextTests.cs</File>
      <File>src/Compilers/Core/CodeAnalysisTest/Text/SourceTextTests.cs</File>
      <File>src/Compilers/Core/CodeAnalysisTest/Text/TextChangeTests.cs</File>
      <File>src/Compilers/Core/MSBuildTask/Shared/ManagedCompiler.cs</File>
      <File>src/Compilers/Core/Portable/AdditionalTextFile.cs</File>
      <File>src/Compilers/Core/Portable/CodeAnalysisResources.Designer.cs</File>
      <File>src/Compilers/Core/Portable/CommandLine/CommonCommandLineArguments.cs</File>
      <File>src/Compilers/Core/Portable/CommandLine/CommonCommandLineParser.cs</File>
      <File>src/Compilers/Core/Portable/CommandLine/CommonCompiler.cs</File>
      <File>src/Compilers/Core/Portable/Compilation/Compilation.cs</File>
      <File>src/Compilers/Core/Portable/Diagnostic/CommonMessageProvider.cs</File>
      <File>src/Compilers/Core/Portable/EmbeddedText.cs</File>
      <File>src/Compilers/Core/Portable/Emit/CommonPEModuleBuilder.cs</File>
      <File>src/Compilers/Core/Portable/Emit/DebugDocumentsBuilder.cs</File>
      <File>src/Compilers/Core/Portable/Emit/DebugInformationFormat.cs</File>
      <File>src/Compilers/Core/Portable/EncodedStringText.cs</File>
      <File>src/Compilers/Core/Portable/GlobalSuppressions.cs</File>
      <File>src/Compilers/Core/Portable/InternalUtilities/BlobBuildingStream.cs</File>
      <File>src/Compilers/Core/Portable/InternalUtilities/EncodingExtensions.cs</File>
      <File>src/Compilers/Core/Portable/InternalUtilities/SpecializedCollections.Empty.Set.cs</File>
      <File>src/Compilers/Core/Portable/InternalUtilities/SpecializedCollections.ReadOnly.Set.cs</File>
      <File>src/Compilers/Core/Portable/InternalUtilities/SpecializedCollections.cs</File>
      <File>src/Compilers/Core/Portable/NativePdbWriter/PdbWriter.cs</File>
      <File>src/Compilers/Core/Portable/PEWriter/DebugSourceDocument.cs</File>
      <File>src/Compilers/Core/Portable/PEWriter/DebugSourceInfo.cs</File>
      <File>src/Compilers/Core/Portable/PEWriter/MetadataWriter.DynamicAnalysis.cs</File>
      <File>src/Compilers/Core/Portable/PEWriter/MetadataWriter.PortablePdb.cs</File>
      <File>src/Compilers/Core/Portable/PEWriter/PeWriter.cs</File>
      <File>src/Compilers/Core/Portable/PEWriter/PooledBlobBuilder.cs</File>
      <File>src/Compilers/Core/Portable/PEWriter/Units.cs</File>
      <File>src/Compilers/Core/Portable/Syntax/SyntaxTree.cs</File>
      <File>src/Compilers/Core/Portable/Text/LargeText.cs</File>
      <File>src/Compilers/Core/Portable/Text/LargeTextWriter.cs</File>
      <File>src/Compilers/Core/Portable/Text/SourceText.cs</File>
      <File>src/Compilers/Core/Portable/Text/StringText.cs</File>
      <File>src/Dependencies/CodeAnalysis.Metadata/PortableCustomDebugInfoKinds.cs</File>
      <File>src/Scripting/Core/Hosting/CommandLine/CommandLineRunner.cs</File>
      <File>src/Test/Utilities/Shared/Compilation/CompilationExtensions.cs</File>
      <File>src/Test/Utilities/Shared/Compilation/IRuntimeEnvironment.cs</File>
      <File>src/Test/Utilities/Shared/Metadata/MetadataReaderUtils.cs</File>
      <File>src/Test/Utilities/Shared/Mocks/TestMessageProvider.cs</File>
      <File>src/Workspaces/Core/Portable/WorkspacesResources.Designer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>12462</IssueID>
    <Title>Fix remaining fast up to date check issues</Title>
    <Description>With these workarounds, I'm able to do an incremental F6 in Visual Studio and it says everything is up to date. 
#12461 and #12458 have been filed tracking the two portable flavor issues I ran into. Internal bugs 239691 and 239697 have been filed on the two other native project system bugs.

_Review_: @TyOverby, @rchande, @jaredpar, @dotnet/roslyn-infrastructure, @tmat
</Description>
    <CreatedDate>12/07/2016</CreatedDate>
    <ClosedDate>13/07/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>12461</IssueID>
        <Title>Targeting netstandard1.3 with multiple imports breaks portable project flavor</Title>
        <Description>**Version Used**: Visual Studio 2015 Update 3 Microupdate 3.1

**Steps to Reproduce**:
1. Open Roslyn.sln at 255596ba195819fa2668b9a2c709a4105e2ac762
2. Look at the error list.

**Expected Behavior**: No warnings are in the error list.

**Actual Behavior**: There are warnings about incompatible PCL projects. If you look at 9df214f1507154b3486fd5e9f0366d27535cad6d you can see that removing imports that are lists made some of them go away.
</Description>
        <CreatedDate>12/07/2016</CreatedDate>
        <ClosedDate>25/07/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>12458</IssueID>
        <Title>Project targeting netcoreapp1.0 isn't recognized as netstandard targeting</Title>
        <Description>**Version Used**: Visual Studio 2015 Update 3 Microupdate 3.1

**Steps to Reproduce**:
1. Open Roslyn.sln from 423afea10482f2231a30f0e50aacfdb17c37fa80
2. Look at the error list

**Expected Behavior**: I don't see any warnings.

**Actual Behavior**: I get warnings like:

&gt; Unable to add a reference to project 'VisualBasicSyntaxGenerator'. The targets of Portable Library project 'VisualBasicSyntaxGenerator' are not the same or compatible with the targets of the current Portable Library project.
</Description>
        <CreatedDate>12/07/2016</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>12411</IssueID>
    <Title>Handling remaining PROTOTYPE markers in features/tuples branch</Title>
    <Description>Filed the following issues:
- Correct the evaluation order of conversions in deconstructions #12400
- Optimize the parsing ahead for deconstruction-declarations to avoid allocations #12399
- Verify the behavior of dynamic in deconstructions #12398
- Parsing ahead for 'for' and 'foreach' ambiguities should recognize deconstructions #12402
- Support typeless tuple literals in deconstruction declarations #12410

I spent some time today trying to come up with a better solution for the last one, but after discussion with Vlad, I prefer to unblock the merge back to master and resolve the difficult language questions later. For now, I report errors if you try to use typeless tuple literals in a d-declaration (which is better than previous crashing behavior).

@dotnet/roslyn-compiler for review.
Related to https://github.com/dotnet/roslyn/issues/11299
</Description>
    <CreatedDate>09/07/2016</CreatedDate>
    <ClosedDate>11/07/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>12400</IssueID>
        <Title>Correct the evaluation order of conversions in deconstructions</Title>
        <Description>When deconstructing an object that has a `Deconstruct` method, the order of evaluation should be:
1. evaluate the left-hand side for side-effects
2. evaluate the right-hand side and evaluate the `Deconstruct` method (or methods in the case of nested deconstruction)
3. convert all the results
4. assign the results
5. construct a tuple representing the result of the assignment
</Description>
        <CreatedDate>08/07/2016</CreatedDate>
        <ClosedDate>18/08/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>12399</IssueID>
        <Title>Optimize the parsing ahead for deconstruction-declarations to avoid allocations</Title>
        <Description>``` C#
        /// &lt;summary&gt;
        /// Check ahead for a deconstruction declaration. This requires at least one good-looking variable and the presence of an equals sign.
        /// Doesn't move the cursor.
        /// PROTOTYPE(tuples) Can this be done without allocations?
        /// &lt;/summary&gt;
        private bool IsPossibleDeconstructionDeclaration()
```

in `LanguageParser.cs`
</Description>
        <CreatedDate>08/07/2016</CreatedDate>
        <ClosedDate>06/12/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>12398</IssueID>
        <Title>Verify the behavior of dynamic in deconstructions</Title>
        <Description>Confirm whether the following code is correct:

``` C#
    private ImmutableArray&lt;BoundExpression&gt; LeftHandSideSideEffects(ImmutableArray&lt;BoundExpression&gt; variables, ArrayBuilder&lt;LocalSymbol&gt; temps, ArrayBuilder&lt;BoundExpression&gt; stores)
        {
            var lhsReceivers = ArrayBuilder&lt;BoundExpression&gt;.GetInstance(variables.Length);

            foreach (var variable in variables)
            {
                // PROTOTYPE(tuples) should the dynamic flag always be false?
                lhsReceivers.Add(TransformCompoundAssignmentLHS(variable, stores, temps, isDynamicAssignment: false));
            }

            return lhsReceivers.ToImmutableAndFree();
        }
```

in `LocalRewriter_DeconstructionAssignmentOperator.cs`
</Description>
        <CreatedDate>08/07/2016</CreatedDate>
        <ClosedDate>12/09/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>12402</IssueID>
        <Title>Parsing ahead for 'for' and 'foreach' ambiguities should recognize deconstructions</Title>
        <Description>``` C#
        [Fact(Skip = "PROTOTYPE(tuples)")]
        public void ConfusedForWithDeconstruction()
        {
            var text = "for ((int x, var (y, z)) in foo) { }";
            var statement = SyntaxFactory.ParseStatement(text, offset: 0, options: TestOptions.Regular.WithTuplesFeature());

            // This expectation is wrong. We should expect a foreach statement (because the 'in' keyword is there)
            Assert.True(statement.Kind() == SyntaxKind.ForStatement);
        }
```
</Description>
        <CreatedDate>08/07/2016</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>12410</IssueID>
        <Title>Support typeless tuple literals in deconstruction declarations</Title>
        <Description>From discussion with Vlad, there are some language decisions required to fully resolve this.
In the meantime, I am treating those scenarios as errors.

Even if the decision is to keep those scenarios as errors, the error message should be improved.

``` C#
        [Fact]
        public void TypelessDeclaration()
        {
            string source = @"
class C
{
    static void Main()
    {
        var (x1, x2) = (1, null);
    }
}
";
            var comp = CreateCompilationWithMscorlib(source, references: new[] { ValueTupleRef, SystemRuntimeFacadeRef });
            comp.VerifyDiagnostics(
                // (6,24): error CS8210: Deconstruct assignment requires an expression with a type on the right-hand-side.
                //         var (x1, x2) = (1, null);
                Diagnostic(ErrorCode.ERR_DeconstructRequiresExpression, "(1, null)").WithLocation(6, 24)
                );
        }

        [Fact]
        public void InferTypeOfTypelessDeclaration()
        {
            string source = @"
class C
{
    static void Main()
    {
        (var (x1, x2), string x3) = ((1, 2), null);
        System.Console.WriteLine(x1 + "" "" + x2 + "" "" + x3);
    }
}
";
            var comp = CreateCompilationWithMscorlib(source, references: new[] { ValueTupleRef, SystemRuntimeFacadeRef });
            comp.VerifyDiagnostics(
                // (6,37): error CS8210: Deconstruct assignment requires an expression with a type on the right-hand-side.
                //         (var (x1, x2), string x3) = ((1, 2), null);
                Diagnostic(ErrorCode.ERR_DeconstructRequiresExpression, "((1, 2), null)").WithLocation(6, 37)
                );
        }
```

in `CodeGenDeconstructTest.cs`
</Description>
        <CreatedDate>09/07/2016</CreatedDate>
        <ClosedDate>20/07/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Deconstruct.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_DeconstructionAssignmentOperator.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/LanguageParser.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/EventFieldDeclarationSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/FieldDeclarationSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/FixedStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/LocalDeclarationStatementSyntax.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/SyntaxFactory.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenDeconstructTests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/DeconstructionTest.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>12250</IssueID>
    <Title>Resolve a number of issues in typeswitch</Title>
    <Description>- Reflect the most recent LDM decisions regarding reachability and subsumption
- Implement LDM-specified handling for constant switch expression in flow analysis and `default:`
- A type pattern cannot test a static type
- Augment `TestResource.AllInOneCSharpCode` to handle all supported pattern forms. 
- Pattern variables are mutable per latest LDM.
- Additional tests and some changes per review comments
  Fixes #9422, #10487, #10932, #9277, #11379, #10633

(I believe there is a merge issue affecting some interactive window unit tests. I will resolve it before merging)

@AlekseyTs @agocke Please review
@dotnet/roslyn-compiler Any additional review will be appreciated
</Description>
    <CreatedDate>28/06/2016</CreatedDate>
    <ClosedDate>07/07/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>9422</IssueID>
        <Title>PreciseAbstractFlowPass doesn't override visit for BoundMatchCase and BoundConstantPattern nodes</Title>
        <Description>If the visit methods can be called, they should be overridden and should visit constituent BoundExpressions as appropriate (either as a condition or as an RValue). Failing to properly visit constituent BoundExpressions can result in a NullReferenceExpression because we might run into conditional state when we don't expect to be in a conditional state.

If we don't expect the visit methods to be ever called, I suggest to still override them in this fashion:

```
        public sealed override BoundNode VisitMatchCase(BoundMatchCase node)
        {
            // Should be handled by VisitMatchExpression
            throw ExceptionUtilities.Unreachable;
        }

        public sealed override BoundNode VisitConstantPattern(BoundConstantPattern node)
        {
            // Should be handled by VisitPattern.
            // There is no reason to visit BoundConstantPattern.Value at the moment because it 
            // is supposed to be a constant.
            throw ExceptionUtilities.Unreachable;
        }
```
</Description>
        <CreatedDate>02/03/2016</CreatedDate>
        <ClosedDate>07/07/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>10487</IssueID>
        <Title>A reference to a pattern variable inside a lambda within a field initializer causes a crash</Title>
        <Description>```
        [Fact]
        public void FieldInitializers_31()
        {
            var source =
@"
public class X
{
    public static void Main()
    {
        System.Console.WriteLine(Test1);
    }

    static bool Test1 = 1 is int x1 &amp;&amp; Dummy(() =&gt; x1); 

    static bool Dummy(System.Func&lt;int&gt; x) 
    {
        System.Console.WriteLine(x());
        return true;
    }
}
";
            var compilation = CreateCompilationWithMscorlib45(source, options: TestOptions.DebugExe, parseOptions: patternParseOptions);
            CompileAndVerify(compilation, expectedOutput: @"1
True");
        }
```

Test 'Microsoft.CodeAnalysis.CSharp.UnitTests.PatternMatchingTests.FieldInitializers_31' failed: Microsoft.CodeAnalysis.ThrowingTraceListener+DebugAssertFailureException : 

```
ThrowingTraceListener.cs(25,0): at Microsoft.CodeAnalysis.ThrowingTraceListener.Fail(String message, String detailMessage)
at System.Diagnostics.TraceListener.Fail(String message)
at System.Diagnostics.TraceInternal.Fail(String message)
at System.Diagnostics.Debug.Assert(Boolean condition)
Symbols\TypeMap.cs(169,0): at Microsoft.CodeAnalysis.CSharp.Symbols.TypeMap.WithConcatAlphaRename(MethodSymbol oldOwner, Symbol newOwner, ImmutableArray`1&amp; newTypeParameters, ImmutableArray`1&amp; oldTypeParameters, MethodSymbol stopAt)
Lowering\LambdaRewriter\SynthesizedLambdaMethod.cs(52,0): at Microsoft.CodeAnalysis.CSharp.SynthesizedLambdaMethod..ctor(NamedTypeSymbol containingType, ImmutableArray`1 structClosures, ClosureKind closureKind, MethodSymbol topLevelMethod, DebugId topLevelMethodId, IBoundLambdaOrFunction lambdaNode, DebugId lambdaId)
Lowering\LambdaRewriter\LambdaRewriter.cs(1267,0): at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.RewriteLambdaOrLocalFunction(IBoundLambdaOrFunction node, ClosureKind&amp; closureKind, NamedTypeSymbol&amp; translatedLambdaContainer, LambdaFrame&amp; containerAsFrame, BoundNode&amp; lambdaScope, DebugId&amp; topLevelMethodId, DebugId&amp; lambdaId)
Lowering\LambdaRewriter\LambdaRewriter.cs(1347,0): at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.RewriteLambdaConversion(BoundLambda node)
Lowering\LambdaRewriter\LambdaRewriter.cs(1052,0): at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.VisitConversion(BoundConversion conversion)
F:\GitHub\AlekseyTs\roslyn\Binaries\Obj\CSharpCodeAnalysis\Debug\BoundNodes.xml.Generated.cs(1605,0): at Microsoft.CodeAnalysis.CSharp.BoundConversion.Accept(BoundTreeVisitor visitor)
BoundTree\BoundTreeVisitors.cs(147,0): at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.Visit(BoundNode node)
BoundTree\BoundTreeRewriter.cs(96,0): at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.VisitExpressionWithoutStackGuard(BoundExpression node)
BoundTree\BoundTreeVisitors.cs(202,0): at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
BoundTree\BoundTreeRewriter.cs(83,0): at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.Visit(BoundNode node)
BoundTree\BoundTreeRewriter.cs(36,0): at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriter.DoVisitList[T](ImmutableArray`1 list)
BoundTree\BoundTreeRewriter.cs(25,0): at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriter.VisitList[T](ImmutableArray`1 list)
Lowering\MethodToClassRewriter.cs(212,0): at Microsoft.CodeAnalysis.CSharp.Symbols.MethodToClassRewriter.VisitCall(BoundCall node)
Lowering\LambdaRewriter\LambdaRewriter.cs(808,0): at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.VisitCall(BoundCall node)
F:\GitHub\AlekseyTs\roslyn\Binaries\Obj\CSharpCodeAnalysis\Debug\BoundNodes.xml.Generated.cs(3957,0): at Microsoft.CodeAnalysis.CSharp.BoundCall.Accept(BoundTreeVisitor visitor)
BoundTree\BoundTreeVisitors.cs(147,0): at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.Visit(BoundNode node)
BoundTree\BoundTreeRewriter.cs(96,0): at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.VisitExpressionWithoutStackGuard(BoundExpression node)
BoundTree\BoundTreeVisitors.cs(202,0): at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
BoundTree\BoundTreeRewriter.cs(83,0): at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.Visit(BoundNode node)
F:\GitHub\AlekseyTs\roslyn\Binaries\Obj\CSharpCodeAnalysis\Debug\BoundNodes.xml.Generated.cs(7953,0): at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriter.VisitBinaryOperator(BoundBinaryOperator node)
F:\GitHub\AlekseyTs\roslyn\Binaries\Obj\CSharpCodeAnalysis\Debug\BoundNodes.xml.Generated.cs(940,0): at Microsoft.CodeAnalysis.CSharp.BoundBinaryOperator.Accept(BoundTreeVisitor visitor)
BoundTree\BoundTreeVisitors.cs(147,0): at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.Visit(BoundNode node)
BoundTree\BoundTreeRewriter.cs(96,0): at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.VisitExpressionWithoutStackGuard(BoundExpression node)
BoundTree\BoundTreeVisitors.cs(202,0): at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
BoundTree\BoundTreeRewriter.cs(83,0): at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.Visit(BoundNode node)
Lowering\LambdaRewriter\LambdaRewriter.cs(846,0): at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.RewriteSequence(BoundSequence node, ArrayBuilder`1 prologue, ArrayBuilder`1 newLocals)
Lowering\LambdaRewriter\LambdaRewriter.cs(969,0): at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.&lt;&gt;c__DisplayClass54_0.&lt;VisitSequence&gt;b__0(ArrayBuilder`1 prologue, ArrayBuilder`1 newLocals)
Lowering\LambdaRewriter\LambdaRewriter.cs(591,0): at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.IntroduceFrame[T](BoundNode node, LambdaFrame frame, Func`3 F)
Lowering\LambdaRewriter\LambdaRewriter.cs(967,0): at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.VisitSequence(BoundSequence node)
F:\GitHub\AlekseyTs\roslyn\Binaries\Obj\CSharpCodeAnalysis\Debug\BoundNodes.xml.Generated.cs(2035,0): at Microsoft.CodeAnalysis.CSharp.BoundSequence.Accept(BoundTreeVisitor visitor)
BoundTree\BoundTreeVisitors.cs(147,0): at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.Visit(BoundNode node)
BoundTree\BoundTreeRewriter.cs(96,0): at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.VisitExpressionWithoutStackGuard(BoundExpression node)
BoundTree\BoundTreeVisitors.cs(202,0): at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
BoundTree\BoundTreeRewriter.cs(83,0): at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.Visit(BoundNode node)
F:\GitHub\AlekseyTs\roslyn\Binaries\Obj\CSharpCodeAnalysis\Debug\BoundNodes.xml.Generated.cs(7974,0): at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriter.VisitAssignmentOperator(BoundAssignmentOperator node)
Lowering\MethodToClassRewriter.cs(354,0): at Microsoft.CodeAnalysis.CSharp.Symbols.MethodToClassRewriter.VisitAssignmentOperator(BoundAssignmentOperator node)
F:\GitHub\AlekseyTs\roslyn\Binaries\Obj\CSharpCodeAnalysis\Debug\BoundNodes.xml.Generated.cs(1081,0): at Microsoft.CodeAnalysis.CSharp.BoundAssignmentOperator.Accept(BoundTreeVisitor visitor)
BoundTree\BoundTreeVisitors.cs(147,0): at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.Visit(BoundNode node)
BoundTree\BoundTreeRewriter.cs(96,0): at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.VisitExpressionWithoutStackGuard(BoundExpression node)
BoundTree\BoundTreeVisitors.cs(225,0): at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(BoundExpression node)
BoundTree\BoundTreeVisitors.cs(206,0): at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
BoundTree\BoundTreeRewriter.cs(83,0): at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.Visit(BoundNode node)
F:\GitHub\AlekseyTs\roslyn\Binaries\Obj\CSharpCodeAnalysis\Debug\BoundNodes.xml.Generated.cs(8152,0): at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriter.VisitExpressionStatement(BoundExpressionStatement node)
F:\GitHub\AlekseyTs\roslyn\Binaries\Obj\CSharpCodeAnalysis\Debug\BoundNodes.xml.Generated.cs(2209,0): at Microsoft.CodeAnalysis.CSharp.BoundExpressionStatement.Accept(BoundTreeVisitor visitor)
BoundTree\BoundTreeVisitors.cs(147,0): at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.Visit(BoundNode node)
BoundTree\BoundTreeRewriter.cs(86,0): at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.Visit(BoundNode node)
F:\GitHub\AlekseyTs\roslyn\Binaries\Obj\CSharpCodeAnalysis\Debug\BoundNodes.xml.Generated.cs(8090,0): at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriter.VisitSequencePointWithSpan(BoundSequencePointWithSpan node)
F:\GitHub\AlekseyTs\roslyn\Binaries\Obj\CSharpCodeAnalysis\Debug\BoundNodes.xml.Generated.cs(1818,0): at Microsoft.CodeAnalysis.CSharp.BoundSequencePointWithSpan.Accept(BoundTreeVisitor visitor)
BoundTree\BoundTreeVisitors.cs(147,0): at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.Visit(BoundNode node)
BoundTree\BoundTreeRewriter.cs(86,0): at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.Visit(BoundNode node)
BoundTree\BoundTreeRewriter.cs(36,0): at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriter.DoVisitList[T](ImmutableArray`1 list)
BoundTree\BoundTreeRewriter.cs(25,0): at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriter.VisitList[T](ImmutableArray`1 list)
F:\GitHub\AlekseyTs\roslyn\Binaries\Obj\CSharpCodeAnalysis\Debug\BoundNodes.xml.Generated.cs(8335,0): at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriter.VisitStatementList(BoundStatementList node)
Lowering\LambdaRewriter\LambdaRewriter.cs(1000,0): at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.VisitStatementList(BoundStatementList node)
F:\GitHub\AlekseyTs\roslyn\Binaries\Obj\CSharpCodeAnalysis\Debug\BoundNodes.xml.Generated.cs(3516,0): at Microsoft.CodeAnalysis.CSharp.BoundStatementList.Accept(BoundTreeVisitor visitor)
BoundTree\BoundTreeVisitors.cs(147,0): at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.Visit(BoundNode node)
BoundTree\BoundTreeRewriter.cs(86,0): at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.Visit(BoundNode node)
Lowering\LambdaRewriter\LambdaRewriter.cs(240,0): at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.Rewrite(BoundStatement loweredBody, NamedTypeSymbol thisType, ParameterSymbol thisParameter, MethodSymbol method, Int32 methodOrdinal, MethodSymbol substitutedSourceMethod, ArrayBuilder`1 lambdaDebugInfoBuilder, ArrayBuilder`1 closureDebugInfoBuilder, VariableSlotAllocator slotAllocatorOpt, TypeCompilationState compilationState, DiagnosticBag diagnostics, Boolean assignLocals)
Compiler\MethodCompiler.cs(1229,0): at Microsoft.CodeAnalysis.CSharp.MethodCompiler.LowerBodyOrInitializer(MethodSymbol method, Int32 methodOrdinal, BoundStatement body, SynthesizedSubmissionFields previousSubmissionFields, TypeCompilationState compilationState, DiagnosticBag diagnostics, VariableSlotAllocator&amp; lazyVariableSlotAllocator, ArrayBuilder`1 lambdaDebugInfoBuilder, ArrayBuilder`1 closureDebugInfoBuilder, StateMachineTypeSymbol&amp; stateMachineTypeOpt)
Compiler\MethodCompiler.cs(1031,0): at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethod(MethodSymbol methodSymbol, Int32 methodOrdinal, ProcessedFieldInitializers&amp; processedInitializers, SynthesizedSubmissionFields previousSubmissionFields, TypeCompilationState compilationState)
Compiler\MethodCompiler.cs(432,0): at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(NamedTypeSymbol containingType)
Compiler\MethodCompiler.cs(322,0): at Microsoft.CodeAnalysis.CSharp.MethodCompiler.&lt;&gt;c__DisplayClass20_0.&lt;CompileNamedTypeAsTask&gt;b__0()
InternalUtilities\UICultureUtilities.cs(136,0): at Roslyn.Utilities.UICultureUtilities.&lt;&gt;c__DisplayClass5_0.&lt;WithCurrentUICulture&gt;b__0()
at System.Threading.Tasks.Task.InnerInvoke()
at System.Threading.Tasks.Task.Execute()
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
Compiler\MethodCompiler.cs(237,0): at Microsoft.CodeAnalysis.CSharp.MethodCompiler.WaitForWorkers()
Compiler\MethodCompiler.cs(137,0): at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethodBodies(CSharpCompilation compilation, PEModuleBuilder moduleBeingBuiltOpt, Boolean generateDebugInfo, Boolean hasDeclarationErrors, DiagnosticBag diagnostics, Predicate`1 filterOpt, CancellationToken cancellationToken)
Compilation\CSharpCompilation.cs(2356,0): at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CompileImpl(CommonPEModuleBuilder moduleBuilder, Stream win32Resources, Stream xmlDocStream, Boolean emittingPdb, DiagnosticBag diagnostics, Predicate`1 filterOpt, CancellationToken cancellationToken)
Compilation\Compilation.cs(1350,0): at Microsoft.CodeAnalysis.Compilation.Compile(CommonPEModuleBuilder moduleBuilder, Stream win32Resources, Stream xmlDocStream, Boolean emittingPdb, DiagnosticBag diagnostics, Predicate`1 filterOpt, CancellationToken cancellationToken)
Compilation\Compilation.cs(1714,0): at Microsoft.CodeAnalysis.Compilation.Emit(EmitStreamProvider peStreamProvider, EmitStreamProvider pdbStreamProvider, EmitStreamProvider xmlDocumentationStreamProvider, EmitStreamProvider win32ResourcesStreamProvider, IEnumerable`1 manifestResources, EmitOptions options, IMethodSymbol debugEntryPoint, CompilationTestData testData, Func`1 getHostDiagnostics, CancellationToken cancellationToken)
Compilation\Compilation.cs(1543,0): at Microsoft.CodeAnalysis.Compilation.Emit(Stream peStream, Stream pdbStream, Stream xmlDocumentationStream, Stream win32Resources, IEnumerable`1 manifestResources, EmitOptions options, IMethodSymbol debugEntryPoint, CompilationTestData testData, Func`1 getHostDiagnostics, CancellationToken cancellationToken)
HostedRuntimeEnvironment.cs(364,0): at Microsoft.CodeAnalysis.Test.Utilities.HostedRuntimeEnvironment.EmitCompilationCore(Compilation compilation, IEnumerable`1 manifestResources, DiagnosticBag diagnostics, CompilationTestData testData)
HostedRuntimeEnvironment.cs(343,0): at Microsoft.CodeAnalysis.Test.Utilities.HostedRuntimeEnvironment.EmitCompilation(Compilation compilation, IEnumerable`1 manifestResources, List`1 dependencies, DiagnosticBag diagnostics, CompilationTestData testData)
HostedRuntimeEnvironment.cs(406,0): at Microsoft.CodeAnalysis.Test.Utilities.HostedRuntimeEnvironment.Emit(Compilation mainCompilation, IEnumerable`1 manifestResources, Boolean usePdbForDebugging)
CommonTestBase.CompilationVerifier.cs(133,0): at Microsoft.CodeAnalysis.Test.Utilities.CommonTestBase.CompilationVerifier.Emit(HostedRuntimeEnvironment testEnvironment, IEnumerable`1 manifestResources)
CommonTestBase.CompilationVerifier.cs(99,0): at Microsoft.CodeAnalysis.Test.Utilities.CommonTestBase.CompilationVerifier.Emit(String expectedOutput, IEnumerable`1 manifestResources, Boolean peVerify, SignatureDescription[] expectedSignatures)
F:\GitHub\AlekseyTs\roslyn\src\Test\Utilities\Desktop\CommonTestBase.cs(204,0): at Microsoft.CodeAnalysis.Test.Utilities.CommonTestBase.Emit(Compilation compilation, IEnumerable`1 dependencies, IEnumerable`1 manifestResources, SignatureDescription[] expectedSignatures, String expectedOutput, Action`1 assemblyValidator, Action`1 symbolValidator, Boolean verify)
F:\GitHub\AlekseyTs\roslyn\src\Test\Utilities\Desktop\CommonTestBase.cs(129,0): at Microsoft.CodeAnalysis.Test.Utilities.CommonTestBase.CompileAndVerify(Compilation compilation, IEnumerable`1 manifestResources, IEnumerable`1 dependencies, Action`1 sourceSymbolValidator, Action`1 assemblyValidator, Action`1 symbolValidator, SignatureDescription[] expectedSignatures, String expectedOutput, Boolean verify)
F:\GitHub\AlekseyTs\roslyn\src\Compilers\Test\Utilities\CSharp.Desktop\CSharpTestBase.cs(194,0): at Microsoft.CodeAnalysis.CSharp.Test.Utilities.CSharpTestBase.CompileAndVerify(Compilation compilation, IEnumerable`1 manifestResources, IEnumerable`1 dependencies, Action`1 sourceSymbolValidator, Action`1 validator, Action`1 symbolValidator, SignatureDescription[] expectedSignatures, String expectedOutput, Boolean verify)
Semantics\PatternMatchingTests.cs(5396,0): at Microsoft.CodeAnalysis.CSharp.UnitTests.PatternMatchingTests.FieldInitializers_31()
```
</Description>
        <CreatedDate>11/04/2016</CreatedDate>
        <ClosedDate>07/07/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>10932</IssueID>
        <Title>Need precise rules for constant pattern conversions</Title>
        <Description>The LDM suggested that we use the semantics of == for a constant pattern when applied to an integral constant, but I think it would be better to use something like the (asymmetric) semantics of switch:

``` cs
byte b = whatever;
if (b is 1000) // error: cannot convert 1000 to byte
```

These semantics should work across all the types (including decimal, float, bool?, etc).
</Description>
        <CreatedDate>27/04/2016</CreatedDate>
        <ClosedDate>07/07/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>9277</IssueID>
        <Title>Region analysis APIs versus pattern matching</Title>
        <Description>In an expression such as `(o is int i)` the region analysis APIs should say that `i` is assigned inside, but is not _always assigned_ inside. If the pattern is irrefutable (i.e. cannot fail to match), then the variables are _always assigned_ inside. That will cause those APIs to interact properly with _extract method_. We need tests for these situations and possibly fixes in the compiler to ensure it works that way.

/cc @jaredpar @AlekseyTs @CyrusNajmabadi 
</Description>
        <CreatedDate>28/02/2016</CreatedDate>
        <ClosedDate>07/07/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>11379</IssueID>
        <Title>Add unit test for declaration pattern with static class</Title>
        <Description>A static class should cause an error when used in a declaration pattern. Need a unit test to verify.
</Description>
        <CreatedDate>17/05/2016</CreatedDate>
        <ClosedDate>07/07/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>10633</IssueID>
        <Title>Augment `TestResource.AllInOneCSharpCode` to handle all supported pattern forms.</Title>
        <Description>
        </Description>
        <CreatedDate>15/04/2016</CreatedDate>
        <ClosedDate>07/07/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Operators.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Patterns.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/SwitchBinder_BindPatternSwitch.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/DecisionTree.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/PreciseAbstractFlowPass.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/PreciseAbstractFlowPass_Switch.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/VariablesDeclaredWalker.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/LocalSymbol.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Diagnostics/DiagnosticAnalyzerTests.AllInOne.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/FlowAnalysis/PatternsVsRegions.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/FlowAnalysis/RegionAnalysisTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/OutVarTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternSubsumptionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/SwitchTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/DiagnosticAnalyzerDriver/DiagnosticAnalyzerDriverTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>12092</IssueID>
    <Title>Add partial-type-name suggestions to C# and some fixes for VB</Title>
    <Description>- Closes #7213. Refactors the VB provider, creating a base class and a C# implementation.
- Fixes #4137. In VB, when a user commits a generic type using `(` only the type name will be inserted.
- Fixes an issue in the VB provider where suggestions we pulled from all ancestor types and namespaces, instead of just the directly enclosing container.
- Fixes an issue in the VB provider where types wouldn't be suggested because their spans overlapped, despite being in different documents.
</Description>
    <CreatedDate>18/06/2016</CreatedDate>
    <ClosedDate>15/07/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>7213</IssueID>
        <Title>Completion: list partial classes after "partial class"</Title>
        <Description>``` C#
namespace blah
{
    partial class $$
}
```

Would be nice to see a builder and a list of all the partial classes in my namespace.
</Description>
        <CreatedDate>03/12/2015</CreatedDate>
        <ClosedDate>15/07/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>4137</IssueID>
        <Title>VB partial type completion is incorrect for generic types when commit with parenthesis</Title>
        <Description>Consider the following code:

``` VB
Partial Class C(Of T)
End Class

Partial Class $$
```

At the $$, the completion list should show "C(Of T)". When completion this item with a left parenthesis, it should complete to "C(" like other symbol completions. However, it completes as "C(Of T)(". This is a regression from Visual Studio 2013.
</Description>
        <CreatedDate>27/07/2015</CreatedDate>
        <ClosedDate>15/07/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Test/Symbol/Compilation/SemanticModelGetDeclaredSymbolAPITests.cs</File>
      <File>src/Compilers/Core/Portable/SymbolDisplay/SymbolDisplayFormat.cs</File>
      <File>src/EditorFeatures/CSharpTest/Completion/CompletionProviders/PartialMethodCompletionProviderTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Completion/CompletionProviders/PartialTypeCompletionProviderTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Completion/CompletionProviders/SuggestionModeCompletionProviderTests.cs</File>
      <File>src/Features/CSharp/Portable/CSharpFeaturesResources.Designer.cs</File>
      <File>src/Features/CSharp/Portable/Completion/CSharpCompletionService.cs</File>
      <File>src/Features/CSharp/Portable/Completion/CompletionProviders/PartialMethodCompletionProvider.cs</File>
      <File>src/Features/CSharp/Portable/Completion/CompletionProviders/PartialTypeCompletionProvider.cs</File>
      <File>src/Features/CSharp/Portable/Completion/SuggestionMode/CSharpSuggestionModeCompletionProvider.cs</File>
      <File>src/Features/Core/Portable/Completion/Providers/AbstractPartialMethodCompletionProvider.cs</File>
      <File>src/Features/Core/Portable/Completion/Providers/AbstractPartialTypeCompletionProvider.cs</File>
      <File>src/Workspaces/CSharp/Portable/Extensions/ContextQuery/SyntaxTreeExtensions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>11914</IssueID>
    <Title>Throw BadImageFormatException decoding TypeRef with resolution scope with nil ModuleRef or TypeRef</Title>
    <Description>See comment in #11772. Fixes #11795.
</Description>
    <CreatedDate>10/06/2016</CreatedDate>
    <ClosedDate>07/07/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>11772</IssueID>
        <Title>Throw BadImageFormatException decoding TypeRef with resolution scope with nil AssemblyRef</Title>
        <Description>Throw BadImageFormatException decoding TypeRef with resolution scope with nil AssemblyRef.

BadImageFormatException is handled by callers and the type is typically treated as an error type. Previously the nil AssemblyRef would result in an unhandled IndexOutOfRangeException.

Fixes #217689.
</Description>
        <CreatedDate>05/06/2016</CreatedDate>
        <ClosedDate>06/06/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>11795</IssueID>
        <Title>Throw BadImageFormatException decoding TypeRef with resolution scope with nil ModuleRef or TypeRef</Title>
        <Description>See comment in #11772.
</Description>
        <CreatedDate>06/06/2016</CreatedDate>
        <ClosedDate>07/07/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/Core/Portable/MetadataReader/MetadataDecoder.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>9975</IssueID>
    <Title>Only run Naming Rules on "Ordinary" methods</Title>
    <Description>Fixes #9710, Fixes #9711 
</Description>
    <CreatedDate>22/03/2016</CreatedDate>
    <ClosedDate>20/07/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>9710</IssueID>
        <Title>[PR Available] Naming Style: Analyzer treats constructor name as .ctor</Title>
        <Description>**Steps to Reproduce**:
1. Create a rule that all methods should be PascalCased, and set it as an error
2. Write a class with a constructor

**Expected Behavior**:
Ignore constructors, since their naming rule should come from the type.

**Actual Behavior**:
Violation flagged, and fix suggests renaming `.ctor`.
</Description>
        <CreatedDate>12/03/2016</CreatedDate>
        <ClosedDate>07/09/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>9711</IssueID>
        <Title>[PR Available] Naming style: Property accessors shouldn't be analyzed</Title>
        <Description>**Steps to Reproduce**:
1. Create a rule that Methods should be PascalCased and make violations an error
2. Write a property

**Expected Behavior**:
No violations.

**Actual Behavior**:
`get` and `set` are squiggled, and the fix suggests to rename `get_Property` or `set_Property`.
</Description>
        <CreatedDate>12/03/2016</CreatedDate>
        <ClosedDate>07/09/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/NamingStyles/NamingStylesTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/NamingStyles/NamingStylesTests_OptionSets.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/Analyzers/NamingStyles/NamingStylePreferencesInfo.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/Analyzers/NamingStyles/Serialization/SymbolSpecification.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>12268</IssueID>
    <Title>Add some unit-tests.</Title>
    <Description>Related to #9021, #12078, #12266, #12267.

@dotnet/roslyn-compiler Please review.
</Description>
    <CreatedDate>28/06/2016</CreatedDate>
    <ClosedDate>29/06/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>9021</IssueID>
        <Title>WRN_UnreferencedVarAssg "The variable '...' is assigned but its value is never used" is not reported for pattern variables</Title>
        <Description>```
    void Test3()
    {
        let x3 = 12;
        var x4 = 12;
    }
```

Observed:

```
    // (11,13): warning CS0219: The variable 'x4' is assigned but its value is never used
    //         var x4 = 12;
    Diagnostic(ErrorCode.WRN_UnreferencedVarAssg, "x4").WithArguments("x4").WithLocation(11, 13)
```

Expected:
WRN_UnreferencedVarAssg should also be reported for x3.
</Description>
        <CreatedDate>22/02/2016</CreatedDate>
        <ClosedDate>01/12/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>12078</IssueID>
        <Title>Port Scope_Query_05 ... Scope_Query_10 and Query_01 unit-tests for Out Variable Declarations to pattern-matching</Title>
        <Description>These are scenarios that are not covered currently by existing pattern-matching unit-tests.
</Description>
        <CreatedDate>17/06/2016</CreatedDate>
        <ClosedDate>20/10/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>12266</IssueID>
        <Title>C# 6 implicitly typed locals are not using Pattern/OutVar locals binder to bind initializer during inference.</Title>
        <Description>```
        [Fact]
        public void LocalVariableTypeInferenceAndOutVar_01()
        {
            var text = @"
public class Cls
{
    public static void Main()
    {
        var y = Test1(out var x);
        System.Console.WriteLine(y);
    }

    static int Test1(out int x)
    {
        x = 123;
        return 124;
    }
}";
            var compilation = CreateCompilationWithMscorlib(text,
                                                            options: TestOptions.ReleaseExe,
                                                            parseOptions: TestOptions.Regular);

            CompileAndVerify(compilation, expectedOutput: @"124").VerifyDiagnostics();

            var tree = compilation.SyntaxTrees.Single();
            var model = compilation.GetSemanticModel(tree);

            var yRef = tree.GetRoot().DescendantNodes().OfType&lt;IdentifierNameSyntax&gt;().Where(id =&gt; id.Identifier.ValueText == "y").Single();

            Assert.Equal("System.Int32", model.GetTypeInfo(yRef).Type.ToTestDisplayString());
        }

        [Fact]
        public void LocalVariableTypeInferenceAndOutVar_02()
        {
            var text = @"
public class Cls
{
    public static void Main()
    {
        var y = Test1(out int x) + x;
        System.Console.WriteLine(y);
    }

    static int Test1(out int x)
    {
        x = 123;
        return 124;
    }
}";
            var compilation = CreateCompilationWithMscorlib(text,
                                                            options: TestOptions.ReleaseExe,
                                                            parseOptions: TestOptions.Regular);

            CompileAndVerify(compilation, expectedOutput: @"247").VerifyDiagnostics();

            var tree = compilation.SyntaxTrees.Single();
            var model = compilation.GetSemanticModel(tree);

            var yRef = tree.GetRoot().DescendantNodes().OfType&lt;IdentifierNameSyntax&gt;().Where(id =&gt; id.Identifier.ValueText == "y").Single();

            Assert.Equal("System.Int32", model.GetTypeInfo(yRef).Type.ToTestDisplayString());
        }
```
</Description>
        <CreatedDate>28/06/2016</CreatedDate>
        <ClosedDate>29/06/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>12267</IssueID>
        <Title>Element names of a tuple type are not propagating through type constraints in metadata</Title>
        <Description>```
        [Fact]
        public void ConstraintsAndNames()
        {
            var source1 = @"
using System.Collections.Generic;

public abstract class Base
{
    public abstract void M&lt;T&gt;(T x) where T : IEnumerable&lt;(int a, int b)&gt;;
}
";

            var source2 = @"
class Derived : Base
{
    public override void M&lt;T&gt;(T x)
    {
        foreach (var y in x)
        {
            System.Console.WriteLine(y.a);
        }
    }
}";

            var comp1 = CreateCompilationWithMscorlib(source1 + trivial2uple + source2);
            comp1.VerifyDiagnostics();

            var comp2 = CreateCompilationWithMscorlib45(source1 + trivial2uple);
            comp2.VerifyDiagnostics();

            // Retargeting (different version of mscorlib)
            var comp3 = CreateCompilationWithMscorlib46(source2, references: new[] { new CSharpCompilationReference(comp2)});
            comp3.VerifyDiagnostics();

            // Metadata
            var comp4 = CreateCompilationWithMscorlib45(source2, references: new[] { comp2.EmitToImageReference() });

            // No errors expected !!!
            comp4.VerifyDiagnostics(
                // (8,40): error CS1061: '(int, int)' does not contain a definition for 'a' and no extension method 'a' accepting a first argument of type '(int, int)' could be found (are you missing a using directive or an assembly reference?)
                //             System.Console.WriteLine(y.a);
                Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "a").WithArguments("(int, int)", "a").WithLocation(8, 40)
                );
        }
```
</Description>
        <CreatedDate>28/06/2016</CreatedDate>
        <ClosedDate>09/08/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTupleTest.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/OutVarTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>12195</IssueID>
    <Title>Only compute entry points when compiling everything.</Title>
    <Description>Fixes #12113 
Previously reviewed as #12120
</Description>
    <CreatedDate>24/06/2016</CreatedDate>
    <ClosedDate>24/06/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>12113</IssueID>
        <Title>Calculating diagnostics for a single file realizes all symbols in GetEntryPoint</Title>
        <Description>Calculating the diagnostics even for a single file in a project producing an exe still realizes all of the symbols for the compilation.

In [`MethodCompiler.CompileMethodBodies`](http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Compiler/MethodCompiler.cs,179), we call `GetEntryPoint` regardless of the value of `filterOpt`.  This is causing performance and memory use for at least one customer who has ~4,000 source files in their main exe.

We should investigate to see if we can skip calling `GetEntryPoint` in the case where we are filtering to a single file.  If we can't, maybe we can use the declaration table to only realize methods called `Main` instead of all symbols in the compilation?
</Description>
        <CreatedDate>20/06/2016</CreatedDate>
        <ClosedDate>21/06/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>12120</IssueID>
        <Title>Only compute entry points when compiling everything.</Title>
        <Description>Fixes #12113 

@dotnet/roslyn-compiler Please review. I suspect we will want to port this to an update.
</Description>
        <CreatedDate>21/06/2016</CreatedDate>
        <ClosedDate>21/06/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Compiler/MethodCompiler.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Emit/EntryPointTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>12191</IssueID>
    <Title>Add unit-tests for issues #12058 and #12182.</Title>
    <Description>Related to #12058 and #12182.

@dotnet/roslyn-compiler Please review.
</Description>
    <CreatedDate>23/06/2016</CreatedDate>
    <ClosedDate>24/06/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>12058</IssueID>
        <Title>Spurious errors in out var error scenarios</Title>
        <Description>The `out var` implementation depends on an internal method, `BuildArgumentsForErrorRecovery`, to do work for semantic analysis that it wasn't designed to do. This is fragile and results in incorrect behavior. An example test case is as follows:

``` cs
class Program
{
    public static void Main(string[] args)
    {
        if (M(s: out var s))
        {
            string s2 = s;
        }
    }
    public static bool M(int i, out string s)
    {
        s = i.ToString();
        return true;
    }
}
```

This should produce the single error

``` none
(5,13): error CS7036: There is no argument given that corresponds to the required formal parameter 'i' of 'Program.M(int, out string)'
        if (M(s: out var s))
```

but the implementation also produces the spurious error

``` none
(7,25): error CS0029: Cannot implicitly convert type 'int' to 'string'
            string s2 = s;
```

Here is this issue in the form of a unit test:

``` cs
        [Fact]
        public void MissingArgumentAndNamedOutVarArgument()
        {
            var source =
@"class Program
{
    public static void Main(string[] args)
    {
        if (M(s: out var s))
        {
            string s2 = s;
        }
    }
    public static bool M(int i, out string s)
    {
        s = i.ToString();
        return true;
    }
}
";
            var compilation = CreateCompilationWithMscorlib(source,
                                                            options: TestOptions.ReleaseExe,
                                                            parseOptions: TestOptions.Regular.WithOutVarFeature());
            compilation.VerifyDiagnostics(
                // (5,13): error CS7036: There is no argument given that corresponds to the required formal parameter 'i' of 'Program.M(int, out string)'
                //         if (M(s: out var s))
                Diagnostic(ErrorCode.ERR_NoCorrespondingArgument, "M").WithArguments("i", "Program.M(int, out string)").WithLocation(5, 13)
                );
        }
```
</Description>
        <CreatedDate>16/06/2016</CreatedDate>
        <ClosedDate>21/09/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>12182</IssueID>
        <Title>Generate constructor code fix is not offered when Out Variable Declarations feature is not available</Title>
        <Description>See unit-test in https://github.com/dotnet/roslyn/pull/12159, src/EditorFeatures/CSharpTest/Diagnostics/GenerateConstructor/GenerateConstructorTests.cs:
- TestOutVariableDeclaration_ImplicitlyTyped
- TestOutVariableDeclaration_ImplicitlyTyped_NamedArgument
- TestOutVariableDeclaration_ExplicitlyTyped
- TestOutVariableDeclaration_ExplicitlyTyped_NamedArgument

They fail when parse options used make Out Variable Declarations feature unavailable.

The code fix machinery relies on semantic diagnostic to offer the fix, but it looks like the presence of parser errors about feature unavailability suppresses the diagnostics that triggers the fix. 
</Description>
        <CreatedDate>23/06/2016</CreatedDate>
        <ClosedDate>12/01/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/OutVarTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/GenerateConstructor/GenerateConstructorTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/GenerateMethod/GenerateMethodTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>12068</IssueID>
    <Title>Added initial support for explicit tuple conversions</Title>
    <Description>By itself supporting explicit tuple conversions is fairly trivial. We just apply explicit conversions element-wise. Similar to implicit tuple conversions.

The complicated part is interaction between implicit and explicit conversions. In particular C# permits cases where T converts to U via distinct implicit and explicit conversions. In such and cases a cast in code can act as disambiguator.

``` C#
 T t = new T();
 U u = t;          // implicit cast T-&gt;U is used
 U u = (U)t;       // explicit cast T-&gt;U is preferred
```

In this change we are trying to generalize this rule to tuple conversions. (yet to be confirmed with LDM).

``` c#
 (T, T) tt = (new T(), new T());
 (U, U) uu = tt;                // implicit cast T-&gt;U is used
 (U, U) uu = ((U, U))tt         // explicit cast T-&gt;U is preferred
 (U, U)? uu = ((U, U)?)tt       // explicit cast T-&gt;U is preferred 
```

UNDONE in this change:
- In the last case lowering does not yet match the desired behavior (implicit conversion wins). The work to enable that is tracked by https://github.com/dotnet/roslyn/issues/12064
- Explicit conversions from literals are not supported pending LDM decision.
  tracked by https://github.com/dotnet/roslyn/issues/11804
- Now that Conversion can contain nested conversions, just for the IsValid purpose, it would seem to be useful to just store it on the bound conversion nodes and reduce cases where we need to classify casts at lowering.
  This could be a big but fairly mechanical change, not affecting any functionality (hopefully) so better be done separately.
  As a part of this change it could make sense to make Conversion type more compact, possibly even make it a reference type.
  Tracked by https://github.com/dotnet/roslyn/issues/12067
- ConversionBase could use some refactoring. 
  Some similar helper are separated between two files, some helpers for conversions from expressions and types and those that handle casts in code are not named uniformly. It is possible there is some duplication.
  Makes sense to bundle with #12067 
- Coverage of conversion classification through APIs could be improved. For now there is some coverage coming from preexisting tests, however there would be a need to test some corner case scenarios.
  Especially once #12064 and #11804 are resolved and it is confirmed that the whole deal with distributing "Cast In Code" stays.
</Description>
    <CreatedDate>17/06/2016</CreatedDate>
    <ClosedDate>18/06/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>12067</IssueID>
        <Title>Consider storing Conversion on bound conversion nodes and use at lowering.</Title>
        <Description>Currently, in many cases, we classify conversions during semantic analysis and then again at lowering.

There are two issues with this:
- classification has costs. That is possibly offset by not having to keep conversions around. 
  With tuples, classification is recursive, so costs are higher. Since we keep some conversion parts anyways, why not whole conversion.
- There is a possibility of a disconnect between analysis and lowering if different classification helpers are used (and there are many of them). Just fetching the conversion from the node would make this part less prone to errors.

There could be some concerns with the size of bound conversion node since Conversion is a relatively large struct.
That could be mitigated by shifting less used traits of Conversion into an optional reference field. It may even make sense to make the Conversion itself a reference type. Most conversions are singletons anyways.
</Description>
        <CreatedDate>17/06/2016</CreatedDate>
        <ClosedDate>10/07/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>12064</IssueID>
        <Title>Propagate preferences between explicit and implicit conversions into nullable conversions</Title>
        <Description>It is possible to have different implicit and explicit conversion between T an U. Having explicit cast in the code acts as a disambiguator in such cases.

Currently,when lowering nullable conversions we do not consider whether it was cast in code or not. It is very likely that before tuples, it did not matter since the problem was unique to reference types.

Now, assuming that explicit tuple conversions inherit this trait from underlying conversions, it becomes an observable difference.
</Description>
        <CreatedDate>16/06/2016</CreatedDate>
        <ClosedDate>10/07/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>11804</IssueID>
        <Title>Implement ExplicitTupleLiteralConversion</Title>
        <Description>That is - explicit conversion from expression.

consider scenarios like `int x = 1; y = ((byte, string))(x, null)`
</Description>
        <CreatedDate>06/06/2016</CreatedDate>
        <ClosedDate>10/07/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Conversions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Expressions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Statements.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/Conversions/Conversion.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/Conversions/Conversions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/Conversions/ConversionsBase.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/Formatting.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_Conversion.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTupleTest.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>12019</IssueID>
    <Title>Enable release nugets</Title>
    <Description>This change makes it so that we will always try to generate release nugets except if they depend on prerelease packages. If one of our nuget packages happens to depend on prerelease packages, then when building release nugets, we will simply print a message in the build output and skip release nuget generation for that package (and allow the overall build to succeed).

(This is a continuation of PR #11550 and #12006)
</Description>
    <CreatedDate>14/06/2016</CreatedDate>
    <ClosedDate>15/06/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>11550</IssueID>
        <Title>Enable release nugets</Title>
        <Description>This commit makes it so that we will always try to generate release nugets except if they depend on prerelease packages. If they depend on prerelease packages, then we print a warning message and skip release nuget generation.

Also changes the version suffix for packages from beta1 to rc1.
</Description>
        <CreatedDate>25/05/2016</CreatedDate>
        <ClosedDate>14/06/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>12006</IssueID>
        <Title>Enable release nugets</Title>
        <Description>This commit makes it so that we will always try to generate release nugets except if they depend on prerelease packages. If one of our nugget packages happens to depend on prerelease packages, then when building release nugets, we will simply print a message in the build output and skip release nuget generation for that package (and allow the overall build to succeed).

(This is a continuation of PR #11550)

NOTE: I don't intend to check this in to stabilization right away and haven't finished testing fully. I am just sending the PR so that folks can provide feedback.
</Description>
        <CreatedDate>14/06/2016</CreatedDate>
        <ClosedDate>14/06/2016</ClosedDate>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>12015</IssueID>
    <Title>Add test for var local-func return type</Title>
    <Description>Support for using `var` in a local function return type was already
removed in PR #7916. This PR adds a test to verify that.

Closes #10392.
</Description>
    <CreatedDate>14/06/2016</CreatedDate>
    <ClosedDate>15/06/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>7916</IssueID>
        <Title>Remove support for inferring the return type of a local function.</Title>
        <Description>Fixes #7832 

@dotnet/roslyn-compiler Please review.
</Description>
        <CreatedDate>13/01/2016</CreatedDate>
        <ClosedDate>14/01/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>10392</IssueID>
        <Title>Local functions: Remove support for `var` return type</Title>
        <Description>May possibly be relaxed later.
</Description>
        <CreatedDate>06/04/2016</CreatedDate>
        <ClosedDate>15/06/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/LocalFunctionTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>11389</IssueID>
    <Title>Lookup for new well-known types to fail if duplicates are found</Title>
    <Description>The lookup for well-known types currently succeeds (with a `WRN_MultiplePredefTypes` warning) when more than one candidate is found.
Per LDM discussion last week, well-known types introduced with C# 7 or later will adopt a stricter behavior. Their lookup will fail if the result is ambiguous.

Overview: 
This change introduces `CSharp7Sentinel` as a marker in the `WellKnownType` enum. The `GetWellKnownType` method passes a new `allowAmbiguity` flag during the lookup. 
The method that used to issue a warning, now could generate an error.
Also, to fix #11322, we'll lookup the proper VT types even for tuple literals that don't have a natural type.

I didn't have to add a test to verify the old behavior (for old well-known types), as we already have a couple.

Fixes #11327 and #11322

CC @dotnet/roslyn-compiler for review.
</Description>
    <CreatedDate>18/05/2016</CreatedDate>
    <ClosedDate>18/05/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>11322</IssueID>
        <Title>Tuple literals should not be allowed if the corresponding VT cannot be unambiguously looked up.</Title>
        <Description>Based on the latest LDM decision:
- Tuple literals are not allowed if the corresponding VT cannot be unambiguously looked up.

I'll submit unit-tests shortly. The tests are passing right now because they reflect existing behavior, but comments are indicating places that should change behavior according to the decision above.
</Description>
        <CreatedDate>16/05/2016</CreatedDate>
        <ClosedDate>18/05/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>11327</IssueID>
        <Title>We should require uniqueness of well known types over picking an arbitrary one for types added for C# 7 and later versions.</Title>
        <Description>This is about WRN_MultiplePredefTypes warning. For new types, that warning shouldn't be reported, the lookup should fail instead.
</Description>
        <CreatedDate>16/05/2016</CreatedDate>
        <ClosedDate>18/05/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>11322</IssueID>
        <Title>Tuple literals should not be allowed if the corresponding VT cannot be unambiguously looked up.</Title>
        <Description>Based on the latest LDM decision:
- Tuple literals are not allowed if the corresponding VT cannot be unambiguously looked up.

I'll submit unit-tests shortly. The tests are passing right now because they reflect existing behavior, but comments are indicating places that should change behavior according to the decision above.
</Description>
        <CreatedDate>16/05/2016</CreatedDate>
        <ClosedDate>18/05/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Expressions.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Compilation_WellKnownMembers.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Tuples/TupleTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTupleTest.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/MissingSpecialMember.cs</File>
      <File>src/Compilers/Core/Portable/WellKnownMembers.cs</File>
      <File>src/Compilers/Core/Portable/WellKnownTypes.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>11341</IssueID>
    <Title>Add more tests for recently-fixed dynamic bugs</Title>
    <Description>More tests for issues #9945 and #10463 as discussed in PRs #11219 and #11256 as well as in-person.

Ping @dotnet/roslyn-compiler for review.
</Description>
    <CreatedDate>16/05/2016</CreatedDate>
    <ClosedDate>23/05/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>9945</IssueID>
        <Title>CSC crashes (instead of emitting error CS0154) when dotting off a setter-only property of type dynamic</Title>
        <Description>**Version Used**: 
VS2015 Update 2 RC

**Steps to Reproduce**:

Create a console app with the following code, and build it:

``` cs
class Program
{
    static void Main()
    {
        I i = null;
        System.Type ts = i.s.GetType();  // compile-time error CS0154
        System.Type td = i.d.GetType();  // compile-time CRASH with error code -2146232797
    }

    public interface I
    {
        string s { set; }
        dynamic d { set; }
    }
}
```

**Expected Behavior**:

Both `GetType()` lines should emit CS0154 "property cannot be used in this context because it lacks a get accessor"

**Actual Behavior**:

The second `GetType()` line causes a compiler crash with
</Description>
        <CreatedDate>21/03/2016</CreatedDate>
        <ClosedDate>12/05/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>10463</IssueID>
        <Title>Invalid IL generated for field initializer with dynamic</Title>
        <Description>**Version Used**: 1.2.0.60317

**Steps to Reproduce**:
1. Compile

```
using System;

public class B2
{
    public Action a = () =&gt; {
            dynamic d = 1;
            Test (d);
        };

    static decimal Test (dynamic arg)
    {
        return 3m;
    }
}

class M
{
    static void Main ()
    {
        new B2 ();
    }   
}
```
1. peverify output .exe 

**Expected Behavior**:

Valid IL produced by compiler.

**Actual Behavior**:

Microsoft (R) .NET Framework PE Verifier.  Version  4.0.30319.0
Copyright (c) Microsoft Corporation.  All rights reserved.

[IL]: Error: [c.exe : B2::.ctor][offset 0x00000008][found &lt;uninitialized&gt; ref ('this' ptr) 'B2'][expected ref 'System.Object'] Unexpected type on the stack.
</Description>
        <CreatedDate>11/04/2016</CreatedDate>
        <ClosedDate>12/05/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>11219</IssueID>
        <Title>Fix #9945: Check if dynamic property is set-only when dotting off it</Title>
        <Description>When a set-only property (whose type is dynamic) is accessed via another member access, CS0154 ("property cannot be used in this context because it lacks a get accessor") was not produced, and instead crashed during emit.

Ping @jaredpar @gafter for review.
</Description>
        <CreatedDate>10/05/2016</CreatedDate>
        <ClosedDate>12/05/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>11256</IssueID>
        <Title>Generalize dynamic static-only restriction to include field initializers</Title>
        <Description>Fixes #10463

Native compiler handled all cases, Roslyn generated invalid IL when using dynamic in a field initializer. Roslyn _does_ already handle dynamic in a constructor initializer, like the following case:

```
public M() : base((object)Test((dynamic)2)) // as imagined inserted into test case in this PR
```

This PR simply hooks into that logic and extends it to field initializers as well (which also run before the base constructor call).

Ping @dotnet/roslyn-compiler for review.
</Description>
        <CreatedDate>11/05/2016</CreatedDate>
        <ClosedDate>12/05/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/DynamicTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>11334</IssueID>
    <Title>Add better error messages for public signing</Title>
    <Description>Fixes #9150 and #9153

These messages are added:
- `error CS7104: Option 'CryptoKeyFile' must be an absolute path.`
- `error BC36983: Option 'CryptoKeyFile' must be an absolute path.`
- `warning CS7103: Attribute 'System.Reflection.AssemblyKeyFileAttribute' is ignored when public signing is specified.`
- CS7103 Title: `Attribute is ignored when public signing is specified.`

The first is emitted when public signing and the path provided is a relative path. The message used to be `error CS7088: Invalid 'CryptoKeyFile' value: 'test.snk'.` (with appropriate path).

There is no VB version of the message due to what I think is a bug - VB only emits diagnostics related to the attribute when compiling a netmodule, and I'd like to figure that out before modifying it. I'll add a reference to the issue number if/when it's made.

The second is emitted when public signing and either the AssemblyKeyFile or the AssemblyKeyName attributes were specified. Here's a chart for the behavior.

|  |  |  |
| :-: | :-: | :-: |
| All with /publicsign | No command line | /keyfile specified |
| No attribute | Error (key not found) | Compilation success |
| KeyFileAttribute | Old: Error(key not found), New: Error(key not found), Warning(attribute ignored) | Old:Compilation success (silently ignoring attribute), New: Compilation success, Warning(attribute ignored) |

Ping @dotnet/roslyn-compiler for review.
</Description>
    <CreatedDate>16/05/2016</CreatedDate>
    <ClosedDate>24/05/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>9150</IssueID>
        <Title>Provide better error message when setting key file using attributes</Title>
        <Description>For in progress PR #9130
</Description>
        <CreatedDate>24/02/2016</CreatedDate>
        <ClosedDate>24/05/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>9153</IssueID>
        <Title>Provide better error message for a relative path passed to CryptoKeyFile in CompilationOptions</Title>
        <Description>In progress PR: https://github.com/dotnet/roslyn/pull/9130
</Description>
        <CreatedDate>24/02/2016</CreatedDate>
        <ClosedDate>24/05/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/CSharpResources.Designer.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/ErrorCode.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/ErrorFacts.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/MessageProvider.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceAssemblySymbol.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Attributes/InternalsVisibleToAndStrongNameTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Compilation/CompilationAPITests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Diagnostics/DiagnosticTest.cs</File>
      <File>src/Compilers/Core/Portable/Compilation/CompilationOptions.cs</File>
      <File>src/Compilers/Core/Portable/Diagnostic/CommonMessageProvider.cs</File>
      <File>src/Test/Utilities/Shared/Mocks/TestMessageProvider.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>11328</IssueID>
    <Title>Fix some issues around tuples and add unit-tests for others.</Title>
    <Description>Fixed: #11287, #11323.
Added unit-tests for: #11282, #11288, #11289, #11291, #11322, #11325, #11326.
</Description>
    <CreatedDate>16/05/2016</CreatedDate>
    <ClosedDate>17/05/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>11287</IssueID>
        <Title>An error for missing 'System.ValueTuple`8' is not reported</Title>
        <Description>```
        [Fact]
        public void GenericTupleWithoutTupleLibrary_02()
        {
            var source = @"
class C
{
    static void Main()
    {
    }

    static (T1, T2, T3, T4, T5, T6, T7, T8, T9) M&lt;T1, T2, T3, T4, T5, T6, T7, T8, T9&gt;()
    {
        throw new System.NotSupportedException();
    }
}
" + trivial2uple;

            var comp = CreateCompilationWithMscorlib(source, parseOptions: TestOptions.Regular.WithTuplesFeature());
            comp.VerifyDiagnostics(
                // (8,12): error CS0518: Predefined type 'System.ValueTuple`8' is not defined or imported
                //     static (T1, T2, T3, T4, T5, T6, T7, T8, T9) M&lt;T1, T2, T3, T4, T5, T6, T7, T8, T9&gt;()
                Diagnostic(ErrorCode.ERR_PredefinedTypeNotFound, "(T1, T2, T3, T4, T5, T6, T7, T8, T9)").WithArguments("System.ValueTuple`8").WithLocation(8, 12)
                );
        }
```

Observed: No error reported.

Expected:
error CS0518: Predefined type 'System.ValueTuple`8' is not defined or imported
</Description>
        <CreatedDate>13/05/2016</CreatedDate>
        <ClosedDate>17/05/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>11323</IssueID>
        <Title>Optimization around identity conversion from a tuple literal results in an incorrect result of "7.5.3.4 Exactly matching Expression" check.</Title>
        <Description>I will submit a unit-test shortly.
</Description>
        <CreatedDate>16/05/2016</CreatedDate>
        <ClosedDate>17/05/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>11282</IssueID>
        <Title>Binder.GenerateImplicitConversionError is missing special handling for an erroneous conversion from a tuple literal </Title>
        <Description>```
        [Fact]
        public void TupleTypeMismatch_02()
        {
            var source = @"
class C
{
    static void Main()
    {
        (int, string) x = (1, null, 2);
    }
}
" + trivial2uple + trivial3uple;

            CreateCompilationWithMscorlib(source, parseOptions: TestOptions.Regular.WithTuplesFeature()).VerifyDiagnostics(
                );
        }
```

------ Test started: Assembly: Roslyn.Compilers.CSharp.Emit.UnitTests.dll ------

Unknown .NET Framework Version: v4.6
Test 'Microsoft.CodeAnalysis.CSharp.UnitTests.CodeGen.CodeGenTupleTests.TupleTypeMismatch_02' failed: Microsoft.CodeAnalysis.ThrowingTraceListener+DebugAssertFailureException : Missing a case in implicit conversion error reporting

```
ThrowingTraceListener.cs(25,0): at Microsoft.CodeAnalysis.ThrowingTraceListener.Fail(String message, String detailMessage)
at System.Diagnostics.TraceListener.Fail(String message)
at System.Diagnostics.TraceInternal.Fail(String message)
at System.Diagnostics.Debug.Assert(Boolean condition, String message)
Binder\Binder_Statements.cs(2766,0): at Microsoft.CodeAnalysis.CSharp.Binder.GenerateImplicitConversionError(DiagnosticBag diagnostics, CSharpSyntaxNode syntax, Conversion conversion, BoundExpression expression, TypeSymbol targetType)
Binder\Binder_Statements.cs(2411,0): at Microsoft.CodeAnalysis.CSharp.Binder.GenerateConversionForAssignment(TypeSymbol targetType, BoundExpression expression, DiagnosticBag diagnostics, Boolean isDefaultParameter, RefKind refKind)
Binder\Binder_Statements.cs(850,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindVariableDeclaration(SourceLocalSymbol localSymbol, LocalDeclarationKind kind, Boolean isVar, VariableDeclaratorSyntax declarator, TypeSyntax typeSyntax, TypeSymbol declTypeOpt, AliasSymbol aliasOpt, DiagnosticBag diagnostics, CSharpSyntaxNode associatedSyntaxNode)
Binder\Binder_Statements.cs(753,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindVariableDeclaration(LocalDeclarationKind kind, Boolean isVar, VariableDeclaratorSyntax declarator, TypeSyntax typeSyntax, TypeSymbol declTypeOpt, AliasSymbol aliasOpt, DiagnosticBag diagnostics, CSharpSyntaxNode associatedSyntaxNode)
Binder\Binder_Statements.cs(578,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindDeclarationStatementParts(LocalDeclarationStatementSyntax node, DiagnosticBag diagnostics)
Binder\Binder_Statements.cs(553,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindLocalDeclarationStatement(LocalDeclarationStatementSyntax node, DiagnosticBag diagnostics)
Binder\Binder_Statements.cs(45,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics)
Binder\Binder_Statements.cs(2339,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindBlockParts(BlockSyntax node, DiagnosticBag diagnostics)
Binder\Binder_Statements.cs(2327,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindBlock(BlockSyntax node, DiagnosticBag diagnostics)
Binder\Binder_Statements.cs(2319,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindEmbeddedBlock(BlockSyntax node, DiagnosticBag diagnostics)
Compiler\MethodCompiler.cs(1510,0): at Microsoft.CodeAnalysis.CSharp.MethodCompiler.BindMethodBody(MethodSymbol method, TypeCompilationState compilationState, DiagnosticBag diagnostics, ImportChain&amp; importChain, Boolean&amp; originalBodyNested)
Compiler\MethodCompiler.cs(875,0): at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethod(MethodSymbol methodSymbol, Int32 methodOrdinal, ProcessedFieldInitializers&amp; processedInitializers, SynthesizedSubmissionFields previousSubmissionFields, TypeCompilationState compilationState)
Compiler\MethodCompiler.cs(432,0): at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(NamedTypeSymbol containingType)
Compiler\MethodCompiler.cs(322,0): at Microsoft.CodeAnalysis.CSharp.MethodCompiler.&lt;&gt;c__DisplayClass20_0.&lt;CompileNamedTypeAsTask&gt;b__0()
InternalUtilities\UICultureUtilities.cs(136,0): at Roslyn.Utilities.UICultureUtilities.&lt;&gt;c__DisplayClass5_0.&lt;WithCurrentUICulture&gt;b__0()
at System.Threading.Tasks.Task.InnerInvoke()
at System.Threading.Tasks.Task.Execute()
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
Compiler\MethodCompiler.cs(237,0): at Microsoft.CodeAnalysis.CSharp.MethodCompiler.WaitForWorkers()
Compiler\MethodCompiler.cs(137,0): at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethodBodies(CSharpCompilation compilation, PEModuleBuilder moduleBeingBuiltOpt, Boolean generateDebugInfo, Boolean hasDeclarationErrors, DiagnosticBag diagnostics, Predicate`1 filterOpt, CancellationToken cancellationToken)
Compilation\CSharpCompilation.cs(1996,0): at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnosticsForAllMethodBodies(DiagnosticBag diagnostics, CancellationToken cancellationToken)
Compilation\CSharpCompilation.cs(1963,0): at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnostics(CompilationStage stage, Boolean includeEarlierStages, CancellationToken cancellationToken)
Compilation\CSharpCompilation.cs(1902,0): at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnostics(CancellationToken cancellationToken)
Utilities\Shared\Diagnostics\DiagnosticExtensions.cs(98,0): at Microsoft.CodeAnalysis.DiagnosticExtensions.VerifyDiagnostics[TCompilation](TCompilation c, DiagnosticDescription[] expected)
CodeGen\CodeGenTupleTest.cs(857,0): at Microsoft.CodeAnalysis.CSharp.UnitTests.CodeGen.CodeGenTupleTests.TupleTypeMismatch_02()
```

0 passed, 1 failed, 0 skipped, took 7.34 seconds (xUnit.net 2.1.0 build 3179).
</Description>
        <CreatedDate>13/05/2016</CreatedDate>
        <ClosedDate>14/06/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>11288</IssueID>
        <Title>Binder.BindCastCore is missing special handling for an erroneous conversion from a tuple literal</Title>
        <Description>```
        [Fact]
        public void TupleConversion02()
        {
            var source = @"
class C
{
    static void Main()
    {
        (int a, int b) x4 = ((long c, long d))(1, null, 2);
    }
}
" + trivial2uple + trivial3uple;

            CreateCompilationWithMscorlib(source, references: new[] { ValueTupleRef, SystemRuntimeFacadeRef }, parseOptions: TestOptions.Regular.WithTuplesFeature()).VerifyDiagnostics(
            );
        }
```

------ Test started: Assembly: Roslyn.Compilers.CSharp.Emit.UnitTests.dll ------

Unknown .NET Framework Version: v4.6
Test 'Microsoft.CodeAnalysis.CSharp.UnitTests.CodeGen.CodeGenTupleTests.TupleConversion02' failed: Microsoft.CodeAnalysis.ThrowingTraceListener+DebugAssertFailureException : 

```
ThrowingTraceListener.cs(25,0): at Microsoft.CodeAnalysis.ThrowingTraceListener.Fail(String message, String detailMessage)
at System.Diagnostics.TraceListener.Fail(String message)
at System.Diagnostics.TraceInternal.Fail(String message)
at System.Diagnostics.Debug.Assert(Boolean condition)
Binder\Binder_Expressions.cs(1770,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindCastCore(ExpressionSyntax node, BoundExpression operand, TypeSymbol targetType, Boolean wasCompilerGenerated, DiagnosticBag diagnostics)
Binder\Binder_Expressions.cs(1713,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindCast(CastExpressionSyntax node, DiagnosticBag diagnostics)
Binder\Binder_Expressions.cs(479,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed)
Binder\Binder_Expressions.cs(403,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindExpression(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed)
Binder\Binder_Expressions.cs(312,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindValue(ExpressionSyntax node, DiagnosticBag diagnostics, BindValueKind valueKind)
Binder\Binder_Statements.cs(2276,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindPossibleArrayInitializer(ExpressionSyntax node, TypeSymbol destinationType, BindValueKind valueKind, DiagnosticBag diagnostics)
Binder\Binder_Statements.cs(846,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindVariableDeclaration(SourceLocalSymbol localSymbol, LocalDeclarationKind kind, Boolean isVar, VariableDeclaratorSyntax declarator, TypeSyntax typeSyntax, TypeSymbol declTypeOpt, AliasSymbol aliasOpt, DiagnosticBag diagnostics, CSharpSyntaxNode associatedSyntaxNode)
Binder\Binder_Statements.cs(753,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindVariableDeclaration(LocalDeclarationKind kind, Boolean isVar, VariableDeclaratorSyntax declarator, TypeSyntax typeSyntax, TypeSymbol declTypeOpt, AliasSymbol aliasOpt, DiagnosticBag diagnostics, CSharpSyntaxNode associatedSyntaxNode)
Binder\Binder_Statements.cs(578,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindDeclarationStatementParts(LocalDeclarationStatementSyntax node, DiagnosticBag diagnostics)
Binder\Binder_Statements.cs(553,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindLocalDeclarationStatement(LocalDeclarationStatementSyntax node, DiagnosticBag diagnostics)
Binder\Binder_Statements.cs(45,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics)
Binder\Binder_Statements.cs(2339,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindBlockParts(BlockSyntax node, DiagnosticBag diagnostics)
Binder\Binder_Statements.cs(2327,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindBlock(BlockSyntax node, DiagnosticBag diagnostics)
Binder\Binder_Statements.cs(2319,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindEmbeddedBlock(BlockSyntax node, DiagnosticBag diagnostics)
Compiler\MethodCompiler.cs(1510,0): at Microsoft.CodeAnalysis.CSharp.MethodCompiler.BindMethodBody(MethodSymbol method, TypeCompilationState compilationState, DiagnosticBag diagnostics, ImportChain&amp; importChain, Boolean&amp; originalBodyNested)
Compiler\MethodCompiler.cs(875,0): at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethod(MethodSymbol methodSymbol, Int32 methodOrdinal, ProcessedFieldInitializers&amp; processedInitializers, SynthesizedSubmissionFields previousSubmissionFields, TypeCompilationState compilationState)
Compiler\MethodCompiler.cs(432,0): at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(NamedTypeSymbol containingType)
Compiler\MethodCompiler.cs(322,0): at Microsoft.CodeAnalysis.CSharp.MethodCompiler.&lt;&gt;c__DisplayClass20_0.&lt;CompileNamedTypeAsTask&gt;b__0()
InternalUtilities\UICultureUtilities.cs(136,0): at Roslyn.Utilities.UICultureUtilities.&lt;&gt;c__DisplayClass5_0.&lt;WithCurrentUICulture&gt;b__0()
at System.Threading.Tasks.Task.InnerInvoke()
at System.Threading.Tasks.Task.Execute()
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
Compiler\MethodCompiler.cs(237,0): at Microsoft.CodeAnalysis.CSharp.MethodCompiler.WaitForWorkers()
Compiler\MethodCompiler.cs(137,0): at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethodBodies(CSharpCompilation compilation, PEModuleBuilder moduleBeingBuiltOpt, Boolean generateDebugInfo, Boolean hasDeclarationErrors, DiagnosticBag diagnostics, Predicate`1 filterOpt, CancellationToken cancellationToken)
Compilation\CSharpCompilation.cs(1996,0): at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnosticsForAllMethodBodies(DiagnosticBag diagnostics, CancellationToken cancellationToken)
Compilation\CSharpCompilation.cs(1963,0): at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnostics(CompilationStage stage, Boolean includeEarlierStages, CancellationToken cancellationToken)
Compilation\CSharpCompilation.cs(1902,0): at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnostics(CancellationToken cancellationToken)
Utilities\Shared\Diagnostics\DiagnosticExtensions.cs(98,0): at Microsoft.CodeAnalysis.DiagnosticExtensions.VerifyDiagnostics[TCompilation](TCompilation c, DiagnosticDescription[] expected)
CodeGen\CodeGenTupleTest.cs(4460,0): at Microsoft.CodeAnalysis.CSharp.UnitTests.CodeGen.CodeGenTupleTests.TupleConversion02()
```

0 passed, 1 failed, 0 skipped, took 3.85 seconds (xUnit.net 2.1.0 build 3179).
</Description>
        <CreatedDate>13/05/2016</CreatedDate>
        <ClosedDate>03/09/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>11289</IssueID>
        <Title>An assert in LocalRewriter.RewriteUserDefinedConversion for a user defined conversion from tuple literal</Title>
        <Description>```
        [Fact]
        public void TupleConvertedTypeUDC02()
        {
            var source = @"
class C
{
    static void Main()
    {
        C1 x = (1, ""qq"");
        System.Console.WriteLine(x.ToString());
    }

    class C1
    {
        private (byte, string) val;

        private C1((byte, string) arg)
        {
            val = arg;
        }

        public static implicit operator C1 ((byte, string) arg)
        {
            return new C1(arg);
        }

        public override string ToString()
        {
            return val.ToString();       
        }
    }
}
" + trivial2uple;

            var tree = Parse(source, options: TestOptions.Regular.WithTuplesFeature());
            var comp = CreateCompilationWithMscorlib(tree, options: TestOptions.ReleaseExe);

            comp.VerifyDiagnostics();

            var model = comp.GetSemanticModel(tree, ignoreAccessibility: false);
            var nodes = tree.GetCompilationUnitRoot().DescendantNodes();
            var node = nodes.OfType&lt;TupleExpressionSyntax&gt;().Single();

            Assert.Equal(@"(1, ""qq"")", node.ToString());
            var typeInfo = model.GetTypeInfo(node);
            Assert.Equal("(System.Int32, System.String)", typeInfo.Type.ToTestDisplayString());
            Assert.Equal("C.C1", typeInfo.ConvertedType.ToTestDisplayString());
            Assert.Equal(ConversionKind.ImplicitUserDefined, model.GetConversion(node).Kind);

            CompileAndVerify(comp, expectedOutput: "{1, qq}");
        }
```

Test 'Microsoft.CodeAnalysis.CSharp.UnitTests.CodeGen.CodeGenTupleTests.TupleConvertedTypeUDC02' failed: Microsoft.CodeAnalysis.ThrowingTraceListener+DebugAssertFailureException : 

```
ThrowingTraceListener.cs(25,0): at Microsoft.CodeAnalysis.ThrowingTraceListener.Fail(String message, String detailMessage)
at System.Diagnostics.TraceListener.Fail(String message)
at System.Diagnostics.TraceInternal.Fail(String message)
at System.Diagnostics.Debug.Assert(Boolean condition)
Lowering\LocalRewriter\LocalRewriter_Conversion.cs(960,0): at Microsoft.CodeAnalysis.CSharp.LocalRewriter.RewriteUserDefinedConversion(CSharpSyntaxNode syntax, BoundExpression rewrittenOperand, MethodSymbol method, TypeSymbol rewrittenType, ConversionKind conversionKind)
Lowering\LocalRewriter\LocalRewriter_Conversion.cs(150,0): at Microsoft.CodeAnalysis.CSharp.LocalRewriter.MakeConversion(BoundConversion oldNode, CSharpSyntaxNode syntax, BoundExpression rewrittenOperand, ConversionKind conversionKind, MethodSymbol symbolOpt, Boolean checked, Boolean explicitCastInCode, Boolean isExtensionMethod, Boolean isArrayIndex, ConstantValue constantValueOpt, TypeSymbol rewrittenType)
Lowering\LocalRewriter\LocalRewriter_Conversion.cs(27,0): at Microsoft.CodeAnalysis.CSharp.LocalRewriter.VisitConversion(BoundConversion node)
F:\GitHub\AlekseyTs\roslyn\Binaries\Obj\CSharpCodeAnalysis\Debug\BoundNodes.xml.Generated.cs(1599,0): at Microsoft.CodeAnalysis.CSharp.BoundConversion.Accept(BoundTreeVisitor visitor)
BoundTree\BoundTreeVisitors.cs(147,0): at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.Visit(BoundNode node)
BoundTree\BoundTreeRewriter.cs(96,0): at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.VisitExpressionWithoutStackGuard(BoundExpression node)
BoundTree\BoundTreeVisitors.cs(225,0): at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(BoundExpression node)
BoundTree\BoundTreeVisitors.cs(206,0): at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
BoundTree\BoundTreeRewriter.cs(91,0): at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.VisitExpressionWithStackGuard(BoundExpression node)
Lowering\LocalRewriter\LocalRewriter.cs(189,0): at Microsoft.CodeAnalysis.CSharp.LocalRewriter.VisitExpressionImpl(BoundExpression node)
Lowering\LocalRewriter\LocalRewriter.cs(163,0): at Microsoft.CodeAnalysis.CSharp.LocalRewriter.VisitExpression(BoundExpression node)
Lowering\LocalRewriter\LocalRewriter_LocalDeclaration.cs(15,0): at Microsoft.CodeAnalysis.CSharp.LocalRewriter.VisitLocalDeclaration(BoundLocalDeclaration node)
F:\GitHub\AlekseyTs\roslyn\Binaries\Obj\CSharpCodeAnalysis\Debug\BoundNodes.xml.Generated.cs(1924,0): at Microsoft.CodeAnalysis.CSharp.BoundLocalDeclaration.Accept(BoundTreeVisitor visitor)
Lowering\LocalRewriter\LocalRewriter.cs(152,0): at Microsoft.CodeAnalysis.CSharp.LocalRewriter.Visit(BoundNode node)
Lowering\LocalRewriter\LocalRewriter_Block.cs(32,0): at Microsoft.CodeAnalysis.CSharp.LocalRewriter.VisitBlock(BoundBlock node)
F:\GitHub\AlekseyTs\roslyn\Binaries\Obj\CSharpCodeAnalysis\Debug\BoundNodes.xml.Generated.cs(1848,0): at Microsoft.CodeAnalysis.CSharp.BoundBlock.Accept(BoundTreeVisitor visitor)
Lowering\LocalRewriter\LocalRewriter.cs(152,0): at Microsoft.CodeAnalysis.CSharp.LocalRewriter.Visit(BoundNode node)
Lowering\LocalRewriter\LocalRewriter.cs(72,0): at Microsoft.CodeAnalysis.CSharp.LocalRewriter.Rewrite(CSharpCompilation compilation, MethodSymbol method, Int32 methodOrdinal, NamedTypeSymbol containingType, BoundStatement statement, TypeCompilationState compilationState, SynthesizedSubmissionFields previousSubmissionFields, Boolean allowOmissionOfConditionalCalls, DiagnosticBag diagnostics, Boolean&amp; sawLambdas, Boolean&amp; sawLocalFunctions, Boolean&amp; sawAwaitInExceptionHandler)
Compiler\MethodCompiler.cs(1181,0): at Microsoft.CodeAnalysis.CSharp.MethodCompiler.LowerBodyOrInitializer(MethodSymbol method, Int32 methodOrdinal, BoundStatement body, SynthesizedSubmissionFields previousSubmissionFields, TypeCompilationState compilationState, DiagnosticBag diagnostics, VariableSlotAllocator&amp; lazyVariableSlotAllocator, ArrayBuilder`1 lambdaDebugInfoBuilder, ArrayBuilder`1 closureDebugInfoBuilder, StateMachineTypeSymbol&amp; stateMachineTypeOpt)
Compiler\MethodCompiler.cs(988,0): at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethod(MethodSymbol methodSymbol, Int32 methodOrdinal, ProcessedFieldInitializers&amp; processedInitializers, SynthesizedSubmissionFields previousSubmissionFields, TypeCompilationState compilationState)
Compiler\MethodCompiler.cs(432,0): at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(NamedTypeSymbol containingType)
Compiler\MethodCompiler.cs(322,0): at Microsoft.CodeAnalysis.CSharp.MethodCompiler.&lt;&gt;c__DisplayClass20_0.&lt;CompileNamedTypeAsTask&gt;b__0()
InternalUtilities\UICultureUtilities.cs(136,0): at Roslyn.Utilities.UICultureUtilities.&lt;&gt;c__DisplayClass5_0.&lt;WithCurrentUICulture&gt;b__0()
at System.Threading.Tasks.Task.InnerInvoke()
at System.Threading.Tasks.Task.Execute()
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
Compiler\MethodCompiler.cs(237,0): at Microsoft.CodeAnalysis.CSharp.MethodCompiler.WaitForWorkers()
Compiler\MethodCompiler.cs(137,0): at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethodBodies(CSharpCompilation compilation, PEModuleBuilder moduleBeingBuiltOpt, Boolean generateDebugInfo, Boolean hasDeclarationErrors, DiagnosticBag diagnostics, Predicate`1 filterOpt, CancellationToken cancellationToken)
Compilation\CSharpCompilation.cs(2359,0): at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CompileImpl(CommonPEModuleBuilder moduleBuilder, Stream win32Resources, Stream xmlDocStream, Boolean emittingPdb, DiagnosticBag diagnostics, Predicate`1 filterOpt, CancellationToken cancellationToken)
Compilation\Compilation.cs(1430,0): at Microsoft.CodeAnalysis.Compilation.Compile(CommonPEModuleBuilder moduleBuilder, Stream win32Resources, Stream xmlDocStream, Boolean emittingPdb, DiagnosticBag diagnostics, Predicate`1 filterOpt, CancellationToken cancellationToken)
Compilation\Compilation.cs(1794,0): at Microsoft.CodeAnalysis.Compilation.Emit(EmitStreamProvider peStreamProvider, EmitStreamProvider pdbStreamProvider, EmitStreamProvider xmlDocumentationStreamProvider, EmitStreamProvider win32ResourcesStreamProvider, IEnumerable`1 manifestResources, EmitOptions options, IMethodSymbol debugEntryPoint, CompilationTestData testData, Func`1 getHostDiagnostics, CancellationToken cancellationToken)
Compilation\Compilation.cs(1623,0): at Microsoft.CodeAnalysis.Compilation.Emit(Stream peStream, Stream pdbStream, Stream xmlDocumentationStream, Stream win32Resources, IEnumerable`1 manifestResources, EmitOptions options, IMethodSymbol debugEntryPoint, CompilationTestData testData, Func`1 getHostDiagnostics, CancellationToken cancellationToken)
Utilities\Shared\Compilation\IRuntimeEnvironment.cs(209,0): at Roslyn.Test.Utilities.RuntimeUtilities.EmitCompilationCore(Compilation compilation, IEnumerable`1 manifestResources, DiagnosticBag diagnostics, CompilationTestData testData)
Utilities\Shared\Compilation\IRuntimeEnvironment.cs(188,0): at Roslyn.Test.Utilities.RuntimeUtilities.EmitCompilation(Compilation compilation, IEnumerable`1 manifestResources, List`1 dependencies, DiagnosticBag diagnostics, CompilationTestData testData)
HostedRuntimeEnvironment.cs(198,0): at Microsoft.CodeAnalysis.Test.Utilities.HostedRuntimeEnvironment.Emit(Compilation mainCompilation, IEnumerable`1 manifestResources, Boolean usePdbForDebugging)
CommonTestBase.CompilationVerifier.cs(128,0): at Microsoft.CodeAnalysis.Test.Utilities.CommonTestBase.CompilationVerifier.Emit(IRuntimeEnvironment testEnvironment, IEnumerable`1 manifestResources)
CommonTestBase.CompilationVerifier.cs(94,0): at Microsoft.CodeAnalysis.Test.Utilities.CommonTestBase.CompilationVerifier.Emit(String expectedOutput, IEnumerable`1 manifestResources, Boolean peVerify, SignatureDescription[] expectedSignatures)
F:\GitHub\AlekseyTs\roslyn\src\Test\Utilities\Desktop\CommonTestBase.cs(204,0): at Microsoft.CodeAnalysis.Test.Utilities.CommonTestBase.Emit(Compilation compilation, IEnumerable`1 dependencies, IEnumerable`1 manifestResources, SignatureDescription[] expectedSignatures, String expectedOutput, Action`1 assemblyValidator, Action`1 symbolValidator, Boolean verify)
F:\GitHub\AlekseyTs\roslyn\src\Test\Utilities\Desktop\CommonTestBase.cs(129,0): at Microsoft.CodeAnalysis.Test.Utilities.CommonTestBase.CompileAndVerify(Compilation compilation, IEnumerable`1 manifestResources, IEnumerable`1 dependencies, Action`1 sourceSymbolValidator, Action`1 assemblyValidator, Action`1 symbolValidator, SignatureDescription[] expectedSignatures, String expectedOutput, Boolean verify)
F:\GitHub\AlekseyTs\roslyn\src\Compilers\Test\Utilities\CSharp.Desktop\CSharpTestBase.cs(194,0): at Microsoft.CodeAnalysis.CSharp.Test.Utilities.CSharpTestBase.CompileAndVerify(Compilation compilation, IEnumerable`1 manifestResources, IEnumerable`1 dependencies, Action`1 sourceSymbolValidator, Action`1 validator, Action`1 symbolValidator, SignatureDescription[] expectedSignatures, String expectedOutput, Boolean verify)
CodeGen\CodeGenTupleTest.cs(5058,0): at Microsoft.CodeAnalysis.CSharp.UnitTests.CodeGen.CodeGenTupleTests.TupleConvertedTypeUDC02()
```
</Description>
        <CreatedDate>13/05/2016</CreatedDate>
        <ClosedDate>03/09/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>11291</IssueID>
        <Title>Misleading errors are reported when compiler fails to infer natural type of a tuple literal</Title>
        <Description>```
        [Fact]
        public void TargetTyping_01()
        {
            var source = @"
class C
{
    static void Main()
    {
        var x0 = new {tuple = (null, null)};
        System.Console.WriteLine(x0.ToString());
        System.ValueType x1 = (null, ""1"");
    }
}
" + trivial2uple;

            var comp = CreateCompilationWithMscorlib(source, parseOptions: TestOptions.Regular.WithTuplesFeature(), references: new[] { SystemRef });
            comp.VerifyDiagnostics(
                // (6,23): error CS0828: Cannot assign &lt;tuple&gt; to anonymous type property
                //         var x0 = new {tuple = (null, null)};
                Diagnostic(ErrorCode.ERR_AnonymousTypePropertyAssignedBadValue, "tuple = (null, null)").WithArguments("&lt;tuple&gt;").WithLocation(6, 23)
                );
        }
```

Expected: Something more specific, pointing to the actual element (even if in a nested tuple) , which is causing the inference to fail. For example:

```
                // (6,32): error CS####: Type of the tuple element cannot be infered from '&lt;null&gt;'.
                //         var x0 = new {tuple = (null, null)};
                Diagnostic(ErrorCode.Unknown, "null").WithArguments("&lt;null&gt;").WithLocation(6, 32),
                // (6,38): error CS####: Type of the tuple element cannot be infered from '&lt;null&gt;'.
                //         var x0 = new {tuple = (null, null)};
                Diagnostic(ErrorCode.Unknown, "null").WithArguments("&lt;null&gt;").WithLocation(6, 38),
```
</Description>
        <CreatedDate>13/05/2016</CreatedDate>
        <ClosedDate>26/02/2019</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>11322</IssueID>
        <Title>Tuple literals should not be allowed if the corresponding VT cannot be unambiguously looked up.</Title>
        <Description>Based on the latest LDM decision:
- Tuple literals are not allowed if the corresponding VT cannot be unambiguously looked up.

I'll submit unit-tests shortly. The tests are passing right now because they reflect existing behavior, but comments are indicating places that should change behavior according to the decision above.
</Description>
        <CreatedDate>16/05/2016</CreatedDate>
        <ClosedDate>18/05/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>11325</IssueID>
        <Title>Conversions between instances of tuple types backed by different VT definitions should be supported.</Title>
        <Description>I will submit a unit-test shortly. It reflects the current behavior, but there is a comment indicating where it should be  different.
</Description>
        <CreatedDate>16/05/2016</CreatedDate>
        <ClosedDate>20/12/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>11326</IssueID>
        <Title>Behavior of SemanticModel.GetTypeInfo API for tuple literals is inconsistent with behavior for other literals</Title>
        <Description>I will submit a unit-test shortly. In general, I think that behavior for a tuple literal that has natural type should be consistent with behavior for an integer literal. For literals without natural type, behavior should be consistent with behavior for `null` literal.   
</Description>
        <CreatedDate>16/05/2016</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/OverloadResolution/OverloadResolution.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceUserDefinedOperatorSymbolBase.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Tuples/TupleTypeSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/TypeSymbolExtensions.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTupleTest.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>10334</IssueID>
    <Title>Merge signed build fix into future</Title>
    <Description>This is just #10291 and #10333 going into future so the fix is there too.
</Description>
    <CreatedDate>04/04/2016</CreatedDate>
    <ClosedDate>05/04/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>10291</IssueID>
        <Title>More precisely control when we should include NuGet packages in VSIXes</Title>
        <Description>Back in 84d7856e, I updated our targets to always include all dependencies from NuGet packages in our VSIXes. This was quick, but had a few problems:
1. we would force-include everything, including VS SDK assemblies
2. we would include the same assembly in multiple VSIXes, even when
   we really didn't need them.

This is mostly a change to address the former. Now you have to
explicitly state which NuGet packages you do want to bring in, and only
those will get brought in to your VSIX. The rest are excluded.

_Review:_ @dotnet/roslyn-infrastructure for general oversight, and then @dotnet/roslyn-compiler, @dotnet/roslyn-ide, and @dotnet/roslyn-interactive to review their respective changes to each VSIX.
</Description>
        <CreatedDate>02/04/2016</CreatedDate>
        <ClosedDate>04/04/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>10333</IssueID>
        <Title>Don't show the NuGetPackageToIncludeInVsix items in Visual Studio</Title>
        <Description>Review: @KevinH-MS
</Description>
        <CreatedDate>04/04/2016</CreatedDate>
        <ClosedDate>05/04/2016</ClosedDate>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>10256</IssueID>
    <Title>Port Microsoft.VisualStudio.AppDesigner and Microsoft.VisualStudio.Editors to Roslyn</Title>
    <Description>This is a port of Microsoft.VisualStudio.AppDesigner and Microsoft.VisualStudio.Editors to Roslyn, which includes the Application Designer, associated property pages, settings and resources editors. My changes were related to code clean up and build.

Things remaining:
- Port existing tests (#10255)
- Versioning (#10254)
- Fix pkgdef to be auto-generated, instead of a hand-written + pre-processed file. (#10253)

While I welcome feedback on the code itself, this is a _port_ so I'll be filing bugs for any feedback unrelated to my changes and won't block the merge on it
</Description>
    <CreatedDate>01/04/2016</CreatedDate>
    <ClosedDate>12/04/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>10255</IssueID>
        <Title>Project System: Port AppDesigner/Editors tests</Title>
        <Description>We need to AppDesigner/Editors tests from internal.
</Description>
        <CreatedDate>01/04/2016</CreatedDate>
        <ClosedDate>13/05/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>10254</IssueID>
        <Title>Project System: Fix versioning of AppDesigner/Editors</Title>
        <Description>AppDesigner/Editors are opt'ing into Roslyn's versioning. We should fix this, to match VS versions.
</Description>
        <CreatedDate>01/04/2016</CreatedDate>
        <ClosedDate>12/04/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>10253</IssueID>
        <Title>Project System: Fix Microsoft.VisualStudio.Editors package def to be auto-generated</Title>
        <Description>Currently, Microsoft.VisualStudio.Editor's pkgdef is hand-written + expected to be pre-processed. We should move it an auto-generated model.
</Description>
        <CreatedDate>01/04/2016</CreatedDate>
        <ClosedDate>13/05/2016</ClosedDate>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>10160</IssueID>
    <Title>Implement code action to complete switch statements on enums</Title>
    <Description>Close #6766 and #10322. I was unable to figure out how to set the cursor to a certain position as described in the issue, and I am unsure if everything else is done the way it should be. Should it be an IDE issue, or should it be a CS and VB issue? I mostly copied the pattern from the Remove Unnecessary Cast issue, so that is why I made it an IDE issue.
</Description>
    <CreatedDate>29/03/2016</CreatedDate>
    <ClosedDate>06/04/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>6766</IssueID>
        <Title>Switch statement population should be available as a refactoring (not just as a snippet function)</Title>
        <Description>If you have the following in a method:

``` C#
System.ConsoleModifiers c = default(System.ConsoleModifiers);
```

And on the next line you type `switch&lt;tab&gt;&lt;tab&gt;c&lt;enter&gt;&lt;enter&gt;`, the snippet function auto-populates the switch body with all cases.

This same functionality should be available in a refactoring (many people don't know about the snippet function, and it can only be used upon creation).
</Description>
        <CreatedDate>13/11/2015</CreatedDate>
        <ClosedDate>06/04/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>10322</IssueID>
        <Title>Bug in SyntaxGenerator for Visual Basic</Title>
        <Description>**Version Used**: Latest Master

**Steps to Reproduce**:
1. Create an instance of a `SyntaxGenerator`
2. Call `generator.DefaultSwitchSection(statements)`
3. Enjoy the crash

**Expected Behavior**:

It should not crash.

**Actual Behavior**:

It crashes because it expects an `Else` switch clause, but it does not receive an `Else` switch clause.

**Fix**:

This is the current code:

```
Public Overrides Function DefaultSwitchSection(statements As IEnumerable(Of SyntaxNode)) As SyntaxNode
    Return SyntaxFactory.CaseBlock(
        SyntaxFactory.CaseStatement(SyntaxFactory.ElseCaseClause()),
        GetStatementList(statements))
End Function
```

It should be:

```
Public Overrides Function DefaultSwitchSection(statements As IEnumerable(Of SyntaxNode)) As SyntaxNode
    Return SyntaxFactory.CaseElseBlock(
        SyntaxFactory.CaseElseStatement(SyntaxFactory.ElseCaseClause()),
        GetStatementList(statements))
End Function
```

**Notes**:

Fixed in #10160.
</Description>
        <CreatedDate>04/04/2016</CreatedDate>
        <ClosedDate>06/04/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/PopulateSwitch/PopulateSwitchTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/PopulateSwitch/PopulateSwitchTests_FixAllTests.cs</File>
      <File>src/EditorFeatures/TestUtilities/Traits.cs</File>
      <File>src/Features/CSharp/Portable/PopulateSwitch/CSharpPopulateSwitchCodeFixProvider.cs</File>
      <File>src/Features/CSharp/Portable/PopulateSwitch/CSharpPopulateSwitchDiagnosticAnalyzer.cs</File>
      <File>src/Features/CSharp/Portable/PopulateSwitch/CSharpPopulateSwitchHelpers.cs</File>
      <File>src/Features/Core/Portable/CodeFixes/PredefinedCodeFixProviderNames.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/Analyzers/IDEDiagnosticIds.cs</File>
      <File>src/Features/Core/Portable/FeaturesResources.Designer.cs</File>
      <File>src/Features/Core/Portable/PopulateSwitch/AbstractPopulateSwitchCodeFixProvider.cs</File>
      <File>src/Features/Core/Portable/PopulateSwitch/AbstractPopulateSwitchDiagnosticAnalyzer.cs</File>
      <File>src/Workspaces/Core/Portable/WorkspacesResources.Designer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>9440</IssueID>
    <Title>Ensure rename works for property pattern members</Title>
    <Description>Closes #9079 #9080
</Description>
    <CreatedDate>03/03/2016</CreatedDate>
    <ClosedDate>03/03/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>9079</IssueID>
        <Title>Rename does not update usages in complex patterns.</Title>
        <Description>``` c#
    public class Expression { }
    public class Constant : Expression
    {
        public readonly int Value;
        public Constant(int Value)
        {
            this.Value = Value;
        }
    }
    public class Plus : Expression
    {
        public readonly Expression Left, Right;     // rename Left here.
        public Plus(Expression Left, Expression Right)
        {
            this.Left = Left;
            this.Right = Right;
        }
    }
    public class X
    {
        public static void Main()
        {
            Expression expr = new Plus(new Plus(new Constant(1), new Plus(new Constant(2), new Constant(3))), new Constant(6));

            if (expr is Plus { Left is Plus p,Right is Constant c })
            {
            }
```

Renaming Plus.Left does not update reference in the complex pattern.
</Description>
        <CreatedDate>23/02/2016</CreatedDate>
        <ClosedDate>03/03/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>9080</IssueID>
        <Title>Rename cannot be triggered from complex pattern member.</Title>
        <Description>``` c#
 public class Expression { }
    public class Constant : Expression
    {
        public readonly int Value;
        public Constant(int Value)
        {
            this.Value = Value;
        }
    }
    public class Plus : Expression
    {
        public readonly Expression Left, Right;    
        public Plus(Expression Left, Expression Right)
        {
            this.Left = Left;
            this.Right = Right;
        }
    }
    public class X
    {
        public static void Main()
        {
            Expression expr = new Plus(new Plus(new Constant(1), new Plus(new Constant(2), new Constant(3))), new Constant(6));

            if (expr is Plus { Left is Plus p,Right is Constant c })  // try to rename Left here.
            {
            }
```

Error occurs saying that symbol cannot be renamed.
</Description>
        <CreatedDate>23/02/2016</CreatedDate>
        <ClosedDate>03/03/2016</ClosedDate>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>9396</IssueID>
    <Title>Preserve order of visiting subexpressions in PatternVariableFinder</Title>
    <Description>Fixes #9258

Previously reviewed as #9329
</Description>
    <CreatedDate>02/03/2016</CreatedDate>
    <ClosedDate>08/03/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>9258</IssueID>
        <Title>Please preserve order of subexpression visiting in PatternVariableFinder</Title>
        <Description>See https://github.com/dotnet/roslyn/pull/9216/files#r54207731

/cc @AlekseyTs 
</Description>
        <CreatedDate>26/02/2016</CreatedDate>
        <ClosedDate>08/03/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>9329</IssueID>
        <Title>Preserve order of visiting subexpressions in PatternVariableFinder</Title>
        <Description>Fixes #9258 

/cc @AlekseyTs @jaredpar
</Description>
        <CreatedDate>01/03/2016</CreatedDate>
        <ClosedDate>02/03/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/PatternVariableFinder.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>9363</IssueID>
    <Title>allow find-all-references to navigate across portable/desktop boundaries</Title>
    <Description>_Given that the current behavior is incorrect and that a similar PR (#9056) was approved for ask-mode, this one is up for consideration, too._

Find All References didn't take into account assembly retargeting when comparing symbols so a method in a desktop assembly that overrides a method in a portable assembly wasn't detected.  This was a simple case of updating the comparison used in FAR.

I also manually tested the scenario in #4936 (`Workspace.ApplyDocumentTextChanged` and `MSBuildWorkspace.ApplyDocumentTextChanged`).

Thanks to @balajikris for finding the exact line that needed to be updated.

Tagging @dotnet/roslyn-ide for review.

Fixes #4936.
</Description>
    <CreatedDate>01/03/2016</CreatedDate>
    <ClosedDate>01/03/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>9056</IssueID>
        <Title>Use smarter type equality in `DependentTypeFinder`</Title>
        <Description>_This is the same as #7164 but against `stabilization`._

Due to potential assembly retargeting, simple type equivalence (e.g., `==`) can't be used in `DependentTypeFinder` so instead equivalence is checked via an added `AbstractReferenceFinder.OriginalSymbolsMatch` shortened stub.

All added tests force retargeting by referencing the _portable_ mscorlib in the base test assembly and the _normal_ mscorlib in the other.

The end-user impact is that when right-clicking on a type in the Solution Explorer and selecting "Derived Types" or "Implements", the complete (correct) set of types is shown.

Fixes #4973.
</Description>
        <CreatedDate>23/02/2016</CreatedDate>
        <ClosedDate>01/03/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>4936</IssueID>
        <Title>FAR doesn't cascade from virtual method to overrides</Title>
        <Description>If you start a find-all-references by pointing at a base class virtual method declaration or a call to it, you only find the base declaration of the method with the references, but none of the overridden declarations in derived classes.

Repro.
1. Try FAR on Workspace.ApplyDocumentTextChanged in Workspace.cs
This should produce a list of one declaration and 3 references (all from the same source file)
2. Try FAR from MSBuildWorkspace.ApplyDocumentTextChanged in MSBuildWorkspace.cs
This will produce a list with many overridden declarations (msbuild, vs workspace, etc).
</Description>
        <CreatedDate>01/09/2015</CreatedDate>
        <ClosedDate>27/05/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>4936</IssueID>
        <Title>FAR doesn't cascade from virtual method to overrides</Title>
        <Description>If you start a find-all-references by pointing at a base class virtual method declaration or a call to it, you only find the base declaration of the method with the references, but none of the overridden declarations in derived classes.

Repro.
1. Try FAR on Workspace.ApplyDocumentTextChanged in Workspace.cs
This should produce a list of one declaration and 3 references (all from the same source file)
2. Try FAR from MSBuildWorkspace.ApplyDocumentTextChanged in MSBuildWorkspace.cs
This will produce a list with many overridden declarations (msbuild, vs workspace, etc).
</Description>
        <CreatedDate>01/09/2015</CreatedDate>
        <ClosedDate>27/05/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Workspaces/Core/Portable/FindSymbols/SymbolFinder_Hierarchy.cs</File>
      <File>src/Workspaces/CoreTest/DependentTypeFinderTests.cs</File>
      <File>src/Workspaces/CoreTest/FindReferencesTests.cs</File>
      <File>src/Workspaces/CoreTest/ServicesTestBase.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>9350</IssueID>
    <Title>Remove unnecessary Suppress operation around Else Statement</Title>
    <Description>Fixes #6628

During some code refactoring an unnecessary suppress operation got
 included. This fix removes the unnecessary addition

Porting the PR #8403 

Review: @dotnet/roslyn-ide @dpoeschl @Pilchie
</Description>
    <CreatedDate>01/03/2016</CreatedDate>
    <ClosedDate>01/03/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>6628</IssueID>
        <Title>Formatting doesn't fix curly brace for else-clause</Title>
        <Description>![elseformatting](https://cloud.githubusercontent.com/assets/4564579/11009952/34e7bbe0-8490-11e5-99d3-8eb2a1e7d851.gif)
</Description>
        <CreatedDate>06/11/2015</CreatedDate>
        <ClosedDate>01/03/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>8403</IssueID>
        <Title>Remove unnecessary Suppress operation around Else Statement</Title>
        <Description>Fixes #6628

During some code refactoring an unnecessary suppress operation got
included. This fix removes the unnecessary addition

Review: @dotnet/roslyn-ide 
</Description>
        <CreatedDate>05/02/2016</CreatedDate>
        <ClosedDate>01/03/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Workspaces/CSharp/Portable/Formatting/Rules/WrappingFormattingRule.cs</File>
      <File>src/Workspaces/CSharpTest/Formatting/FormattingTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>9318</IssueID>
    <Title>[Ask Mode] Prevent a set of crashes in IOperation implementations</Title>
    <Description>FIxes #8774 #8829 #8848 #8849 #9018

The edits all involve hardening IOperation implementations against structural surprises in the bound trees that can arise in compiling malformed input programs.

Some of the issues were found by actual testing and are covered by tests there. Others @AlekseyTs found by inspection and have so far eluded simple testing.

@genlu @AlekseyTs @MattGertz @ManishJayaswal , please?
</Description>
    <CreatedDate>29/02/2016</CreatedDate>
    <ClosedDate>02/03/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>8774</IssueID>
        <Title>IOperation: VB - BoundCall.IIsVirtual should probably do a null check for ReceiverOpt</Title>
        <Description>```
        Private ReadOnly Property IIsVirtual As Boolean Implements IInvocationExpression.IsVirtual
            Get
                Dim method As IMethodSymbol = Me.Method

                Return (method.IsVirtual OrElse method.IsAbstract OrElse method.IsOverride) AndAlso Me.ReceiverOpt.Kind &lt;&gt; BoundKind.MyBaseReference AndAlso Me.ReceiverOpt.Kind &lt;&gt; BoundKind.MyClassReference
            End Get
        End Property
```
</Description>
        <CreatedDate>16/02/2016</CreatedDate>
        <ClosedDate>02/03/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>8829</IssueID>
        <Title>IOperation: VB - BoundUserDefinedUnaryOperator possibly has issues in implementation of IUnaryOperatorExpression </Title>
        <Description>```
        Private ReadOnly Property IOperator As IMethodSymbol Implements IHasOperatorMethodExpression.OperatorMethod
            Get
                Return Me.Call.Method
            End Get
        End Property

        Private ReadOnly Property IUsesOperatorMethod As Boolean Implements IHasOperatorMethodExpression.UsesOperatorMethod
            Get
                Return True
            End Get
        End Property

        Private ReadOnly Property IOperand As IOperation Implements IUnaryOperatorExpression.Operand
            Get
                Return Me.Operand
            End Get
        End Property
```

In error scenarios the Call and Operand properties are going to throw an InvalidCastException because UnderlyingExpression is not going to be a BoundCall node.

Probably IUsesOperatorMethod  should return False and IOperator should return Nothing in this case. IOperand, however, should still be able to get the operand, which will be a child of the node stored in UnderlyingExpression property.
</Description>
        <CreatedDate>17/02/2016</CreatedDate>
        <ClosedDate>02/03/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>8848</IssueID>
        <Title>IOperation: VB - BoundUserDefinedBinaryOperator implementation of IBinaryOperatorExpression.BinaryOperationKind doesn't handle some operators</Title>
        <Description>It looks like BinaryOperatorKind.Power is not handled and will cause UnexpectedValue exception.
I didn't confirm that all other operators are handled properly.
</Description>
        <CreatedDate>17/02/2016</CreatedDate>
        <ClosedDate>26/08/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>8849</IssueID>
        <Title>IOperation: VB - BoundUserDefinedBinaryOperator possibly has issues in implementation of IBinaryOperatorExpression for error scenarios</Title>
        <Description>```
        Private ReadOnly Property ILeft As IOperation Implements IBinaryOperatorExpression.Left
            Get
                Return Me.Left
            End Get
        End Property

        Private ReadOnly Property IRight As IOperation Implements IBinaryOperatorExpression.Right
            Get
                Return Me.Right
            End Get
        End Property

        Private ReadOnly Property IOperator As IMethodSymbol Implements IHasOperatorMethodExpression.OperatorMethod
            Get
                Return Me.Call.Method
            End Get
        End Property

        Private ReadOnly Property IUsesOperatorMethod As Boolean Implements IHasOperatorMethodExpression.UsesOperatorMethod
            Get
                Return True
            End Get
        End Property
```

In error scenarios the Call, Left and Right properties are going to throw an InvalidCastException because UnderlyingExpression is not going to be a BoundCall node.

Probably IUsesOperatorMethod should return False and IOperator should return Nothing in this case. ILeft and IRight, however, should still be able to get the operands, which will be children of the node stored in UnderlyingExpression property.

```
        Protected Overrides Function ExpressionKind() As OperationKind
            Select Case Me.OperatorKind And BinaryOperatorKind.OpMask
                Case BinaryOperatorKind.Add, BinaryOperatorKind.Concatenate, BinaryOperatorKind.Subtract, BinaryOperatorKind.Multiply, BinaryOperatorKind.Divide,
                    BinaryOperatorKind.IntegerDivide, BinaryOperatorKind.Modulo, BinaryOperatorKind.Power, BinaryOperatorKind.LeftShift, BinaryOperatorKind.RightShift,
                    BinaryOperatorKind.And, BinaryOperatorKind.Or, BinaryOperatorKind.Xor, BinaryOperatorKind.AndAlso, BinaryOperatorKind.OrElse,
                    BinaryOperatorKind.LessThan, BinaryOperatorKind.LessThanOrEqual, BinaryOperatorKind.Equals, BinaryOperatorKind.NotEquals,
                    BinaryOperatorKind.Is, BinaryOperatorKind.IsNot, BinaryOperatorKind.Like, BinaryOperatorKind.GreaterThanOrEqual, BinaryOperatorKind.GreaterThan

                    Return OperationKind.BinaryOperatorExpression
            End Select

            Throw ExceptionUtilities.UnexpectedValue(Me.OperatorKind And BinaryOperatorKind.OpMask)
        End Function
```

I think ExpressionKind should never throw and should always return OperationKind.BinaryOperatorExpression. Especially that Accept methods always visit node as BinaryOperatorExpression.
</Description>
        <CreatedDate>17/02/2016</CreatedDate>
        <ClosedDate>02/03/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>9018</IssueID>
        <Title>InvalidCastException in BoundUserDefinedBinaryOperator.Left</Title>
        <Description>Crash with InvalidCastException in `BoundUserDefinedBinaryOperator.Left` when hooked up with OperationWalker with test

```
Microsoft.CodeAnalysis.VisualBasic.UnitTests.Semantics.BinaryOperators.IntrinsicSymbols
```

Here's the stack trace:

```
Test 'Microsoft.CodeAnalysis.VisualBasic.UnitTests.Semantics.BinaryOperators.IntrinsicSymbols' failed: System.InvalidCastException : Unable to cast object of type 'Microsoft.CodeAnalysis.VisualBasic.BoundBadExpression' to type 'Microsoft.CodeAnalysis.VisualBasic.BoundCall'.
    BoundTree\BoundUserDefinedBinaryOperator.vb(25,0): at Microsoft.CodeAnalysis.VisualBasic.BoundUserDefinedBinaryOperator.get_Call()
    BoundTree\BoundUserDefinedBinaryOperator.vb(13,0): at Microsoft.CodeAnalysis.VisualBasic.BoundUserDefinedBinaryOperator.get_Left()
    BoundTree\Expression.vb(727,0): at Microsoft.CodeAnalysis.VisualBasic.BoundUserDefinedBinaryOperator.get_IBinaryOperatorExpression_LeftOperand()
    Compilation\OperationWalker.cs(285,0): at Microsoft.CodeAnalysis.Semantics.OperationWalker.VisitBinaryOperatorExpression(IBinaryOperatorExpression operation)
    BoundTree\Expression.vb(809,0): at Microsoft.CodeAnalysis.VisualBasic.BoundUserDefinedBinaryOperator.Accept(OperationVisitor visitor)
    Compilation\OperationWalker.cs(34,0): at Microsoft.CodeAnalysis.Semantics.OperationWalker.Visit(IOperation operation)
    Compilation\OperationWalker.cs(55,0): at Microsoft.CodeAnalysis.Semantics.OperationWalker.VisitVariableDeclaration(IVariableDeclaration operation)
    Compilation\Statement.cs(35,0): at Microsoft.CodeAnalysis.Semantics.VariableDeclaration.Accept(OperationVisitor visitor)
    Compilation\OperationWalker.cs(34,0): at Microsoft.CodeAnalysis.Semantics.OperationWalker.Visit(IOperation operation)
    Compilation\OperationWalker.cs(21,0): at Microsoft.CodeAnalysis.Semantics.OperationWalker.VisitArray[T](ImmutableArray`1 list)
    Compilation\OperationWalker.cs(50,0): at Microsoft.CodeAnalysis.Semantics.OperationWalker.VisitVariableDeclarationStatement(IVariableDeclarationStatement operation)
    BoundTree\Statement.vb(1081,0): at Microsoft.CodeAnalysis.VisualBasic.BoundDimStatement.Accept(OperationVisitor visitor)
    Compilation\OperationWalker.cs(34,0): at Microsoft.CodeAnalysis.Semantics.OperationWalker.Visit(IOperation operation)
    CompilationTestUtils.vb(247,0): at Microsoft.CodeAnalysis.VisualBasic.UnitTests.CompilationUtils.WalkOperationTrees(VisualBasicCompilation compilation)
    CompilationTestUtils.vb(228,0): at Microsoft.CodeAnalysis.VisualBasic.UnitTests.CompilationUtils.CreateCompilationWithReferences(IEnumerable`1 sourceTrees, IEnumerable`1 references, VisualBasicCompilationOptions options, String assemblyName)
    CompilationTestUtils.vb(199,0): at Microsoft.CodeAnalysis.VisualBasic.UnitTests.CompilationUtils.CreateCompilationWithReferences(XElement sources, IEnumerable`1 references, VisualBasicCompilationOptions options, IEnumerable`1&amp; spans, VisualBasicParseOptions parseOptions)
    CompilationTestUtils.vb(74,0): at Microsoft.CodeAnalysis.VisualBasic.UnitTests.CompilationUtils.CreateCompilationWithMscorlib(XElement sources, VisualBasicCompilationOptions options, IEnumerable`1 references, IEnumerable`1&amp; spans, VisualBasicParseOptions parseOptions)
    Semantics\BinaryOperators.vb(932,0): at Microsoft.CodeAnalysis.VisualBasic.UnitTests.Semantics.BinaryOperators.IntrinsicSymbols()
```

Even though I found this crash through IOperation interface, it doesn't seems to be a bug at this layer.
</Description>
        <CreatedDate>22/02/2016</CreatedDate>
        <ClosedDate>02/03/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/BoundTree/Expression.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Diagnostics/OperationAnalyzerTests.cs</File>
      <File>src/Compilers/Core/CodeAnalysisTest/Diagnostics/OperationTestAnalyzer.cs</File>
      <File>src/Compilers/Core/Portable/Compilation/IExpression.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>9208</IssueID>
    <Title>don't assume all reference spans in an inline rename session are projected into the current view</Title>
    <Description>_This is the same as #8646 but against `stabilization`._

The Razor directives `@model` and `@inherits` have reference spans in the underlying generated file that aren't projected to the current Razor view and inline rename makes an incorrect assumption that all reference spans are projected.

This removes that assumption.

Also included in this PR is a temporary workaround for `@model` projections getting out of sync with the backing buffer that disables live-preview in Razor files during inline rename.  Below is the out-of-sync behavior that can lead to a crash:

![model](https://cloud.githubusercontent.com/assets/926281/13019862/bc2e90a4-d186-11e5-968d-e353b37f8a8c.gif)

The new no-live-update behavior is previewed below.  In an offline discussion this behavior was considered acceptable as a workaround for the crash/out-of-sync-projections because the user only notices it if both .cs and .cshtml files are visible at the same time (Razor currently doesn't support invoking cross-file reference inline rename directly from the .cshtml editor anyways.)

![no-live-update](https://cloud.githubusercontent.com/assets/926281/13019779/3806f28a-d186-11e5-93ba-58d2d93e92f7.gif)

Partially fixes #6821 and internal bug 182787.
### Other fixes included here:

There was also an issue discovered while testing that could cause a crash regarding certain Razor directives when typing and that's addressed in commit 8b48c5b.  This issue doesn't repro in released builds of VS but does repro on the latest internal-only builds.  I was able to confirm the crash and subsequently the fix by building the latest bits locally.
</Description>
    <CreatedDate>25/02/2016</CreatedDate>
    <ClosedDate>08/03/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>8646</IssueID>
        <Title>don't assume all reference spans in an inline rename session are projected into the current view</Title>
        <Description>_This is the same as #9208 but against `master`._

The Razor directives `@model` and `@inherits` have reference spans in the underlying generated file that aren't projected to the current Razor view and inline rename makes an incorrect assumption that all reference spans are projected.

This removes that assumption.

Also included in this PR is a temporary workaround for `@model` projections getting out of sync with the backing buffer that disables live-preview in Razor files during inline rename.  Below is the out-of-sync behavior that can lead to a crash:

![model](https://cloud.githubusercontent.com/assets/926281/13019862/bc2e90a4-d186-11e5-968d-e353b37f8a8c.gif)

The new no-live-update behavior is previewed below.  In an offline discussion this behavior was considered acceptable as a workaround for the crash/out-of-sync-projections because the user only notices it if both .cs and .cshtml files are visible at the same time (Razor currently doesn't support invoking cross-file reference inline rename directly from the .cshtml editor anyways.)

![no-live-update](https://cloud.githubusercontent.com/assets/926281/13019779/3806f28a-d186-11e5-93ba-58d2d93e92f7.gif)

Partially fixes #6821 and internal bug 182787.
</Description>
        <CreatedDate>12/02/2016</CreatedDate>
        <ClosedDate>01/03/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>6821</IssueID>
        <Title>VS2015.1 RC: Crash when inline renaming model type</Title>
        <Description>Stacktrace obtained from attaching VS to VS:

```
System.InvalidOperationException: Sequence contains no elements
   at System.Linq.Enumerable.Single[TSource](IEnumerable`1 source)
   at Microsoft.CodeAnalysis.Editor.Implementation.InlineRename.InlineRenameSession.OpenTextBufferManager.SelectionTracking.&lt;&gt;c__DisplayClass5_0.&lt;.ctor&gt;b__0(KeyValuePair`2 kvp)
   at System.Linq.Enumerable.WhereSelectEnumerableIterator`2.MoveNext()
   at System.Linq.Enumerable.WhereEnumerableIterator`1.MoveNext()
   at Microsoft.CodeAnalysis.Editor.Implementation.InlineRename.InlineRenameSession.OpenTextBufferManager.SelectionTracking..ctor(OpenTextBufferManager openTextBufferManager)
   at Microsoft.CodeAnalysis.Editor.Implementation.InlineRename.InlineRenameSession.OpenTextBufferManager.ApplyConflictResolutionEdits(IInlineRenameReplacementInfo conflictResolution, IEnumerable`1 documents, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Editor.Implementation.InlineRename.InlineRenameSession.ApplyReplacements(IInlineRenameReplacementInfo replacementInfo, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Editor.Implementation.InlineRename.InlineRenameSession.&lt;&gt;c__DisplayClass63_0.&lt;UpdateConflictResolutionTask&gt;b__1(Task`1 t)
   at Roslyn.Utilities.TaskExtensions.&lt;&gt;c__DisplayClass4_0`1.&lt;SafeContinueWith&gt;b__0(Task antecedent)
   at Roslyn.Utilities.TaskExtensions.&lt;&gt;c__DisplayClass1_0.&lt;SafeContinueWith&gt;b__0(Task antecedent)
   at Roslyn.Utilities.TaskExtensions.&lt;&gt;c__DisplayClass5_0`1.&lt;SafeContinueWith&gt;b__0(Task t)
```

I have two files, `Models.cs` and `EmailTemplate.cshtml` (latter using RazorEngine as email templating engine) in a web Project. The `EmailTemplate.cshtml` has a `@model SampleType` directive. When both files are opened and i try to rename `SampleType` inside `Models.cs`, VS will Crash. When i close `EmailTemplate.cshtml` prior to starting the inline rename, VS won't Crash.
</Description>
        <CreatedDate>17/11/2015</CreatedDate>
        <ClosedDate>08/03/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/Core/Implementation/InlineRename/InlineRenameSession.OpenTextBufferManager.cs</File>
      <File>src/Workspaces/Core/Portable/Formatting/Rules/BaseIndentationFormattingRule.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>9056</IssueID>
    <Title>Use smarter type equality in `DependentTypeFinder`</Title>
    <Description>_This is the same as #7164 but against `stabilization`._

Due to potential assembly retargeting, simple type equivalence (e.g., `==`) can't be used in `DependentTypeFinder` so instead equivalence is checked via an added `AbstractReferenceFinder.OriginalSymbolsMatch` shortened stub.

All added tests force retargeting by referencing the _portable_ mscorlib in the base test assembly and the _normal_ mscorlib in the other.

The end-user impact is that when right-clicking on a type in the Solution Explorer and selecting "Derived Types" or "Implements", the complete (correct) set of types is shown.

Fixes #4973.
</Description>
    <CreatedDate>23/02/2016</CreatedDate>
    <ClosedDate>01/03/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>7164</IssueID>
        <Title>Use smarter type equality in `DependentTypeFinder`</Title>
        <Description>_This is the same as #9056 but against `master`._

Due to potential assembly retargeting, simple type equivalence (e.g., `==`) can't be used in `DependentTypeFinder` so instead equivalence is checked via an added `AbstractReferenceFinder.OriginalSymbolsMatch` shortened stub.

All added tests force retargeting by referencing the _portable_ mscorlib in the base test assembly and the _normal_ mscorlib in the other.

The end-user impact is that when right-clicking on a type in the Solution Explorer and selecting "Derived Types" or "Implements", the complete (correct) set of types is shown.

Fixes #4973.
</Description>
        <CreatedDate>01/12/2015</CreatedDate>
        <ClosedDate>01/03/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>4973</IssueID>
        <Title>Solution Explorer "Derived Types" missing some derived types</Title>
        <Description>1. Open Roslyn.sln in VS.
2. Navigate to [PreviewWorkspace](http://source.roslyn.io/#Microsoft.CodeAnalysis.EditorFeatures/Shared/Preview/PreviewWorkspace.cs,aa6ee406a52b5a53,references) type node in Solution Explorer.
3. Right click and choose "Derived Types"

**Expected**: It should find [`PreviewDialogWorkspace : PreviewWorkspace`](http://source.roslyn.io/#Microsoft.VisualStudio.LanguageServices/Implementation/Preview/PreviewUpdater.PreviewDialogWorkspace.cs,4b37df9c924a4540)
**Actual**: No derived types found.
</Description>
        <CreatedDate>03/09/2015</CreatedDate>
        <ClosedDate>03/03/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/Core/Shared/IDocumentSupportsFeatureService.cs</File>
      <File>src/Workspaces/Core/Portable/FindSymbols/FindReferences/DependentTypeFinder.cs</File>
      <File>src/Workspaces/Core/Portable/FindSymbols/FindReferences/Finders/AbstractReferenceFinder.cs</File>
      <File>src/Workspaces/CoreTest/DependentTypeFinderTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>8642</IssueID>
    <Title>New Performance Test Runner</Title>
    <Description>Closes #8737
Closes #8734

View this change commit-by-commit.
</Description>
    <CreatedDate>12/02/2016</CreatedDate>
    <ClosedDate>16/03/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>8737</IssueID>
        <Title>Implement "TestRunner.csx" (iterate and invoke tests)</Title>
        <Description>
        </Description>
        <CreatedDate>16/02/2016</CreatedDate>
        <ClosedDate>16/03/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>8734</IssueID>
        <Title>Implement "GetSolutionsForTesting.csx"</Title>
        <Description> Downloads "RealWorldProjects.zip" from Azure blob storage 
</Description>
        <CreatedDate>16/02/2016</CreatedDate>
        <ClosedDate>16/03/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Test/Perf/HelloWorld.cs</File>
      <File>src/Test/Perf/helloworld/HelloWorld.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>4882</IssueID>
    <Title>Pattern Matching</Title>
    <Description>An implementation of pattern matching as specified in #206. You can follow the progress here. Much of this work will be pulling pieces of the implementation from https://github.com/semihokur/pattern-matching-csharp

Related features possibly to be added at the same time as pattern-matching:
- [x] #5154 expression-based switch ("match")
- [x] #5143 make "throw expression" an expression form
- [ ] #6183 "out var" declarations
- [ ] #188 Completeness checking for "match" and Algebraic Data Types
- [x] #6400 destructuring assignment
- [ ] #206 Record types, #5172 "with" expressions, #5757 Algebraic Data Types

Progress checklist:
- [X] Scoping for variables introduced in patterns (binders)
- [x] `SemanticModel.GetDeclaredSymbol` for pattern variable declarations.
- [X] Simple pattern matching expressions `expression is Type Identifier` in most statements.
- [x] Extend the parser to handle all of the other specified pattern-matching operations.
  - [x] Add tests for the parser, including precedence tests for the edge cases.
  - [ ] Augment `TestResource.AllInOneCSharpCode` to handle all pattern forms.
- [x] Check for feature availability in the parser (error if feature not supported).
- [X] Error pattern matching to a nullable value type
- [x] Implement pattern matching to a type that is an unconstrained type variable (requires a double type test)
- [ ] Implement and test scoping in remaining "odd" contexts (where the scope is not the enclosing statement)
  - [x] pattern matching in ctor-initializers
  - [x] pattern matching in catch filters
  - [x] pattern matching in field initializers
  - [x] pattern matching in expression-bodied methods and properties
  - [x] pattern matching in an expression-bodied lambda
  - [x] pattern matching in an expression-bodied local function
  - [x] pattern matching in attributes and parameter defaults (lookup and error recovery)
  - [x] test these "odd" contexts in `SemanticModel`.
- [ ] Semantics and code-gen for all pattern forms
  - [X] Type ID
  - [x] *
  - [x] 3
    - [X] matching with exact type for integral constants (as a short-term hack)
    - [ ] matching with appropriate integral conversions
  - [x] `var` ID
  - [x] Type { ID is Pattern ... }
  - ~~Type ( Pattern ... )~~ This will be done when Records are integrated.
- [ ] Extend the switch statement to handle patterns
  - [x] Parser
  - [ ] Syntax Tests
  - [x] Binding
  - [ ] Binding (failure cases) tests
  - [x] Flow analysis
  - [x] Lowering
  - [x] Code-gen tests
- ~~Allow declaration of `operator is`~~ This will be done when Records are integrated.
- [x] An expression form for mutli-armed pattern-matching (`match`?)
- [ ] Extend the scope of a pattern variable declared in a catch filter to the catch block.
  - [ ] Test for error on reusing a variable name, and lambda-capturing.
- [ ] Add a decision tree to enable
  - [ ] completeness checking: a mutli-armed pattern-matching expression is required to be complete
  - [ ] subsumption checking: a branch of a switch statement or match expression may not be subsumed by the totality of previous branches
- [ ] Generate efficient code like `switch` does in corresponding situations.
- [ ] Test for name conflicts with locals in enclosing scopes for normal and "odd" contexts.
- [ ] Lots more Tests!

Records will be added in a separate feature branch.
</Description>
    <CreatedDate>29/08/2015</CreatedDate>
    <ClosedDate>01/03/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>206</IssueID>
        <Title>Proposal: Pattern matching and record types</Title>
        <Description>### The spec has been moved

The specs for pattern matching and records have been moved to https://github.com/dotnet/roslyn/blob/features/patterns/docs/features/patterns.md and https://github.com/dotnet/roslyn/blob/features/records/docs/features/records.md

There are new discussion threads at #10153 for pattern-matching and #10154 for records.
</Description>
        <CreatedDate>03/02/2015</CreatedDate>
        <ClosedDate>28/03/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>5154</IssueID>
        <Title>Proposal: expression-based switch ("match") for pattern matching</Title>
        <Description>### The spec has been moved

The spec for the proposed match expression has been moved to https://github.com/dotnet/roslyn/blob/future/docs/features/patterns.md

Below is a snapshot that may be out of date.

---
## Match Expression

A _match-expression_ is added to support `switch`-like semantics for an expression context.

The C# language syntax is augmented with the following syntactic productions:

``` antlr
relational-expression
    : match-expression
    ;
```

We add the _match-expression_ as a new kind of _relational-expression_.

``` antlr
match-expression
    : relational-expression 'switch' match-block
    ;

match-block
    : '(' match-sections ','? ')'
    ;

match-sections
    : match-section
    | match-sections ',' match-section
    ;
```

At least one _match-section_ is required.

``` antlr
match-section
    : 'case' pattern case-guard? ':' expression
    ;

case-guard
    : 'when' expression
    ;
```

The _match-expression_ is not allowed as an _expression-statement_.

The type of the _match-expression_ is the _least common type_ of the expressions appearing to the right of the `:` tokens of the _match section_s.

It is an error if the compiler can prove (using a set of techniques that has not yet been specified) that some _match-section_'s pattern cannot affect the result because some previous pattern will always match.

At runtime, the result of the _match-expression_ is the value of the _expression_ of the first _match-section_ for which the expression on the left-hand-side of the _match-expression_ matches the _match-section_'s pattern, and for which the _case-guard_ of the _match-section_, if present, evaluates to `true`.
</Description>
        <CreatedDate>11/09/2015</CreatedDate>
        <ClosedDate>28/01/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>5143</IssueID>
        <Title>Proposal: Make "throw expression" an expression form</Title>
        <Description>### The spec has been moved

The spec for the proposed throw expression has been moved to https://github.com/dotnet/roslyn/blob/future/docs/features/patterns.md

Below is a snapshot that may be out of date.

---

I propose to extend the set of expression forms to include

&gt; _throw-expression_:
&gt; &amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;`throw` _null-coalescing-expression_
&gt; _null-coalescing-expression_:
&gt; &amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;_throw-expression_

The type rules are as follows:

&gt; A _throw-expression_ has no type.
&gt; A _throw-expression_ is convertible to every type by an implicit conversion.

The flow-analysis rules are as follows:

&gt; For every variable _v_,
&gt; - _v_ is definitely assigned before the _null-coalescing-expression_ of a _throw-expression_ iff it is definitely assigned before the _throw-expression_.
&gt; - _v_ is definitely assigned after _throw-expression_.

A _throw expression_ is allowed in only the following contexts:
- As the second operand of a ternary conditional operator `?:`
- As the third operand of a ternary conditional operator `?:`
- As the second operand of a null coalescing operator `??`
- After the colon of a _match section_ (see #5154)
- As the body of an expression-bodied lambda or method.

---

This proposal is intended to facilitate a move toward expression-oriented programming, adding convenience in a number of scenarios. For example

An expression-bodied method may now throw

``` cs
void M() =&gt; throw new NotImplementedException();
```

A conditional expression may throw on one branch:

``` cs
var foo = term.HasValue ? term.Value.Foo() : throw new ArgumentException("term");
```

I am proposing this to facilitate a proposal (#5154) for an expression form of a pattern-matching switch, where one may want to throw in some branch.

This is related to #59 and #1226.
</Description>
        <CreatedDate>10/09/2015</CreatedDate>
        <ClosedDate>28/01/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>6183</IssueID>
        <Title>Proposal: out var declaration</Title>
        <Description>This feature would allow a variable be declared at the same time that is it passed as an out parameter:

&gt; _argument-value_:
&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;`out` _type_ _identifier_

A variable declared this way is read-only and scoped to the enclosing statement. More specifically, the scope will be the same as for a _pattern-variable_ introduced via pattern-matching.

You should be able to use the contextual keyword `var` for the variable's type, in which case the specification for overload resolution would have to be modified to account for that possibility.
</Description>
        <CreatedDate>20/10/2015</CreatedDate>
        <ClosedDate>13/01/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>188</IssueID>
        <Title>Proposal: Add completeness checking to pattern matching draft specification</Title>
        <Description># Background

As noted in issue #180, many modern programming programs are data-focused, especially distributed applications which tend to store, manipulate, and move sets of data between different storage and computation points. One solution proposed to deal with this issue is a combination of records and pattern matching. Records provide a simple way to declare and structure the data types and pattern matching provides a way to destructure and manipulate the data. 
# Problem

Records provide a great way to represent the data and pattern matching provides a great way to manipulate the data, but there is currently no mechanism in the #180 proposal to ensure that the data and the logic remain in sync. The nature of records and pattern matching is that the data declaration code is often far from the data consumption code. In a distributed system it's even more likely that a single data structure will be consumed and manipulated in various parts of the code base. If the data structure is ever modified, there is currently no mechanism in the draft to alert the programmer that all instances of manipulation logic must be updated.
# Solution

Add completeness checking to certain `switch` statements on certain record types. The core of this proposal is to provide a warning when a `switch` statement does not handle every possible match on a type hierarchy. This proposal features two possible designs for this idea, presented in order of increasingly intrusive modification to the language.
## Design 1

This design actually features no new syntax or semantics beyond that of proposal #180. The suggestion is to create a C# type heirarchy which can be guaranteed 'complete' with existing language features. In this case, complete means that it is not possible for a new subclass of the root member of the type hierarchy, so the compiler can be sure that any and all subclasses of the chosen switching type are visible in the current compilation.

We can construct this type hierarchy in existing C# with the following rules:
1. All subclasses of the root type must be sealed, preventing any subclassing of any existing leaf types in the hierarchy.
2. All constructors of the root type must be private, prevent any subclassing of the root type.
   - As a consequence, all subclasses must be inner classes and thus must be in source in the current compilation

Here's an example of the structure of this type hierarchy:

``` csharp
abstract class C
{
  private C() {}
  public sealed class C_1 : C {}
  public sealed class C_2 : C {}
      ...
  public sealed class C_n : C {}
}
```

This guarantees that `switch`ing on an instance of type `C` which explicitly matches `C_1`...`C_n` has matched against every possible instance of `C`. The only thing which changes about the language specification is a requirement that the compiler produce a warning when not all cases are matched.
## Design 2

There are a few disadvantages to Design 1:
1. The mandated structure is complicated and brittle. Forgetting to mark any of the subclasses as `sealed` or adding any public constructors won't produce a compiler error or warning, but the compiler will now silently skip the completeness check.
2. The structure is verbose -- most of the `sealed` or `private` markers are mostly part of the 'incantation' of completeness and are not directly related to the task at hand.
3. The relevant record instances are all nested classes, so all references require an extra layer of naming indirection.

Design 2 attempts to fix these problems by replacing much of the boiler plate with a new combination of modifiers on a type -- `abstract` + `sealed`. Under Design 2, marking the root type of a hierarchy as `abstract sealed` will cause the structure from Design 1 to be generated by the compiler in lowering. The following example demonstrates what the structure from Design 1 looks like with an `abstract sealed` type:

``` csharp
abstract sealed class C {}
public class C_1 : C {}
public class C_2 : C {}
   ...
public class C_n : C {}
```

In this case, most of the problems with Design 1 are solved, but new semantics are required to be added to the language.
</Description>
        <CreatedDate>31/01/2015</CreatedDate>
        <ClosedDate>21/04/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>6400</IssueID>
        <Title>Proposal: Destructuring (assignment?) statement</Title>
        <Description>### The spec has been moved

The spec for the proposed `let` statement has been moved to https://github.com/dotnet/roslyn/blob/future/docs/features/patterns.md

Below is a snapshot that may be out of date.

---

Inspired by an [F# feature](https://msdn.microsoft.com/en-us/library/dd233238.aspx) and a [conversation on github](https://github.com/dotnet/roslyn/issues/5154#issuecomment-151974994), we could support decomposition like this:

``` antlr
block-statement
    : let-statement
    ;

let-statement
    : 'let' identifier '=' expression ';'
    | 'let' complex-pattern '=' expression ';'
    | 'let' complex-pattern '=' expression 'else' embedded-statement
    ;
```

`let` is an existing contextual keyword.

The form

&gt; `let` _identifier_ `=` _expression_ `;`

is shorthand for 

&gt; `let` `var` _identifier_ `=` _expression_ `;`

(i.e. a _var-pattern_) and is a convenient way for declaring a read-only local variable.

Semantically, it is an error unless precisely one of the following is true
1. the compiler can prove that the expression always matches the pattern; or
2. an `else` clause is present.

If an `else` clause is present, it is an error if the endpoint of its _embedded-statement_ is reachable.

Any pattern variables in the _pattern_ are in scope throughout the enclosing block. They are not definitely assigned before the `else` clause, and are definitely assigned after the _let-statement_. It is an error to use these variables before their point of definition.

A _let-statement_ is a _block-statement_ and not an _embedded-statement_ because its primary purpose is to introduce names into the enclosing scope. It therefore does not introduce a dangling-else ambiguity.
</Description>
        <CreatedDate>28/10/2015</CreatedDate>
        <ClosedDate>28/01/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>206</IssueID>
        <Title>Proposal: Pattern matching and record types</Title>
        <Description>### The spec has been moved

The specs for pattern matching and records have been moved to https://github.com/dotnet/roslyn/blob/features/patterns/docs/features/patterns.md and https://github.com/dotnet/roslyn/blob/features/records/docs/features/records.md

There are new discussion threads at #10153 for pattern-matching and #10154 for records.
</Description>
        <CreatedDate>03/02/2015</CreatedDate>
        <ClosedDate>28/03/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>5172</IssueID>
        <Title>Proposal: "with" expressions for record types</Title>
        <Description>This is a proposed enhancement to the proposal for _records_ in #206.

A new expression form is proposed:

&gt; _primary-expression_:
&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;_with-expression_:
&gt; _with-expression_:
&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;_primary-expression_ `with` `{` _with-initializer-list_ `}`
&gt; _with-initializer-list_:
&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;_with-initializer_
&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;_with-initializer_ `,` _with-initializer-list_
&gt; _with-initializer_:
&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;_identifier_ `=` _expression_

The token `with` is a new context-sensitive keyword.
### Semantics

The _with-expression_ is translated into a primary constructor invocation that copies members from the _primary-expression_ on the left-hand-side into constructor's parameters, but with some of those replaced by values from the initializer list. Because it depends on the presence of a primary constructor, this is only defined for record types (#206).

(This needs to be described in more detail, including specifying that the left-hand-side expression is evaluated once, the constraints on its type, that identifiers in a _with-intiializer_ bind to a property (or field) of that type, and that the correspondence between constructor parameters and properties are used according to the spec for _records_. Similarly it needs to give definite assignment rules, order of evaluation, etc.)
### Example:

``` cs
class Person(string FirstName, string LastName);
...
    Person p = new Person(FirstName: "Neil", LastName: "Gafter");
    Person q = p with { FirstName = "Neal" };
```

The latter is translated into

``` cs
    Person q = new Person(FirstName: "Neal", LastName: p.LastName);
```

To be clear, the `Person` declaration's expansion includes the following:

``` cs
class Person
{
    public string FirstName { get; }
    public string LastName { get; }
    public Person(string FirstName, string LastName)
        { this.FirstName = FirstName; this.LastName = LastName; }
    // as well as other members not relevant to this issue
}
```

Because the semantics of this new expression form require a language-defined mapping between constructor arguments and properties of the type, and a _primary_ constructor, it is only defined for record types as specified in #206. Expanding this construct to other types may be the subject of a separate proposal.
</Description>
        <CreatedDate>11/09/2015</CreatedDate>
        <ClosedDate>27/03/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>5757</IssueID>
        <Title>Notes on Records and Pattern Matching for 2015-10-07 design review</Title>
        <Description>### Records and Pattern Matching (https://github.com/dotnet/roslyn/issues/206)

Prototyped together last year by @semihokur, but that prototype is
based on very out-of-date Roslyn code. We also have some design changes
since that time and we want to separate a pattern-matching prototype from
records/ADTs so we can make independent decisions about whether
and when to include them in the language(s).

First step is to port pattern matching to the latest sources.
In-progress port at https://github.com/dotnet/roslyn/pull/4882
### Spec changes since the 2014 prototype

For pattern matching:
1. Scoping of pattern-introduced variables (with "funny" rule for `if`)
2. Rules for `switch` statement that make it a compatible extension of the existing construct (https://github.com/dotnet/roslyn/issues/4944)
3. An expression form of multi-arm pattern-matching (https://github.com/dotnet/roslyn/issues/5154)
4. A `when` clause added to `switch` cases.

And, for records:
1. No `record` keyword necessary
2. `with` expressions (https://github.com/dotnet/roslyn/issues/5172)
3. Approach for for algebraic data types
### Implementation status of prototype port
1. For pattern matching, checklist at https://github.com/dotnet/roslyn/pull/4882 tracking the progress
2. For records, port not started
### Making the extension of `switch` backward-compatible
- We say that the cases are matched in order, except `default` which is always the last
  resort.
- Integral-typed case labels match any integral-valued control expression with the same value.
- One issue around user-defined conversions to switchable types is
  resolved (https://github.com/dotnet/roslyn/issues/4944). In the draft spec,
  a conversion will be applied on the `case`s, not on the control-expression unilaterally.
  Instead of converting only to `swithable` types, each
  `case` arm will consider any conversions that allow the `case` to be applied.
  Any given conversion would be applied at most once. 

``` cs
Foo foo = ...; // has a conversion to int
switch (foo)
{
    case 1: // uses the converted value
    case Foo(2): // uses the original value
    case 3: // uses the converted value
}
```
- The `goto case` statement is extended to allow any expression as its argument.
### Expression form of multi-arm pattern matching (https://github.com/dotnet/roslyn/issues/5154)

``` cs
var areas =
    from primitive in primitives
    let area = primitive match (
        case Line l: 0
        case Rectangle r: r.Width * r.Height
        case Circle c: Math.PI * c.Radius * c.Radius
        case *: throw new ApplicationException()
    )
    select new { Primitive = primitive, Area = area };
```

There is no `default` here, so cases are handled strictly in order.

I propose the spec require that the compiler "prove" that all cases are handled
in a `match` expression using not-yet-specified rules. Writing those rules
is an open work item, but I imagine it will require the compiler to build
a decision tree and check it for completeness. That will also be needed to
implement checks that no case is subsumed by a previous case, which will
cause a warning (for `switch`) or error (for `match`).
### With-expressions (https://github.com/dotnet/roslyn/issues/5172)

``` cs
class Point(int X, int Y, int Z);
...
    Point p = ...;
    Point q = p with { Y = 2 };
```

The latter is translated into

``` cs
    Point q = new Point(X: p.X, Y: 2, Z: p.Z);
```

We know how to do this for record types (because the language specifies the
mapping between constructor parameters and properties). We're examining how
to extend it to more general types.

To support inheritance, rather than directly using the constructor (as above) the generated code will
invoke a compiler-generated (but user-overridable) factory method.

``` cs
    Point q = p.With(X: p.X, Y: 2, Z: p.Z);
```
### Draft approach for algebraic data types

``` cs
abstract sealed class Expression
{
    class Binary(Operator Operator, Expression Left, Expression Right) : Expression;
    class Constant(int Value) : Expression;
}
```

None of these classes would be permitted to be extended elsewhere.
a `match` expression that handles both `Binary` and `Constant` cases
would not need a `*` (default) case, as the compiler can prove it
is complete.
### Remaining major issues
1. We need to specify the rules for checking
   - If the set of cases in a `match` is complete 
   - If a `case` is subsumed by a previous `case`
2. We need more experience with algebraic data types and active patterns.
3. Can we extend `with` expressions to non-record types?
</Description>
        <CreatedDate>07/10/2015</CreatedDate>
        <ClosedDate>25/04/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Conversions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Expressions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Initializers.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Operators.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Patterns.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Query.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Statements.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Symbols.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/BlockBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/BuckStopsHereBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/CatchClauseBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/FixedStatementBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/InMethodBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/LocalBinderFactory.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/LocalScopeBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/PatternVariableBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/PatternVariableFinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/Conversions/Conversion.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/Conversions/ConversionKind.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/Conversions/ConversionKindExtensions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/Conversions/Conversions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/Conversions/UserDefinedImplicitConversions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/SwitchBinder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/SwitchBinder_BindPatternSwitch.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/BoundNodeExtensions.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/BoundStatementExtensions.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/Constructors.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/Expression.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/Statement.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/UnboundLambda.cs</File>
      <File>src/Compilers/CSharp/Portable/CSharpExtensions.cs</File>
      <File>src/Compilers/CSharp/Portable/CSharpParseOptions.cs</File>
      <File>src/Compilers/CSharp/Portable/CSharpResources.Designer.cs</File>
      <File>src/Compilers/CSharp/Portable/CodeGen/EmitConversion.cs</File>
      <File>src/Compilers/CSharp/Portable/CodeGen/EmitExpression.cs</File>
      <File>src/Compilers/CSharp/Portable/CodeGen/EmitStatement.cs</File>
      <File>src/Compilers/CSharp/Portable/CodeGen/Optimizer.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/CSharpSemanticModel.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/MemberSemanticModel.NodeMapBuilder.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/MemberSemanticModel.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/SyntaxTreeSemanticModel.cs</File>
      <File>src/Compilers/CSharp/Portable/Compiler/AnonymousTypeMethodBodySynthesizer.cs</File>
      <File>src/Compilers/CSharp/Portable/Compiler/MethodBodySynthesizer.Lowered.cs</File>
      <File>src/Compilers/CSharp/Portable/Compiler/MethodCompiler.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/ErrorCode.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/MessageID.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/ControlFlowPass.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/DataFlowPass.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/DataFlowsOutWalker.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/PreciseAbstractFlowPass.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/PreciseAbstractFlowPass_Switch.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/VariablesDeclaredWalker.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/AsyncRewriter/AsyncExceptionHandlerRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/AsyncRewriter/AsyncMethodToStateMachineRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/AsyncRewriter/AsyncRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/AsyncRewriter/AwaitExpressionSpiller.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/IteratorRewriter/IteratorMethodToStateMachineRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/IteratorRewriter/IteratorRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_Block.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_Call.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_Conversion.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_FixedStatement.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_IfStatement.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_MatchStatement.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_Patterns.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_SwitchStatement.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/MethodToClassRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/StateMachineRewriter/StateMachineRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/SyntheticBoundNodeFactory.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/LanguageParser.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/LanguageParser_Patterns.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/Lexer.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/SyntaxParser.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/LocalDeclarationKind.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/LocalSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/MemberSymbolExtensions.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceLocalSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/LambdaUtilities.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/LookupPosition.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/SyntaxFacts.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/SyntaxKind.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/SyntaxKindFacts.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/SyntaxNodeExtensions.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Diagnostics/DiagnosticAnalyzerTests.AllInOne.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/ConstantTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/LocalFunctionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/NameOfTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/OperatorTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/SwitchTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/UnsafeTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Compilation/SemanticModelAPITests.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/Parsing/PatternParsingTests.cs</File>
      <File>src/Compilers/Test/Utilities/CSharp/CompilingTestBase.cs</File>
      <File>src/EditorFeatures/CSharpTest/Diagnostics/DiagnosticAnalyzerDriver/DiagnosticAnalyzerDriverTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/ExtractMethod/ExtractMethodBase.cs</File>
      <File>src/EditorFeatures/CSharpTest/ExtractMethod/ExtractMethodTests.LanguageInteraction.cs</File>
      <File>src/EditorFeatures/CSharpTest/Formatting/Indentation/SmartIndenterEnterOnTokenTests.cs</File>
      <File>src/EditorFeatures/CSharpTest/Formatting/Indentation/SmartIndenterTests.cs</File>
      <File>src/EditorFeatures/Test/Workspaces/TestWorkspace_Create.cs</File>
      <File>src/EditorFeatures/Test/Workspaces/TestWorkspace_XmlConsumption.cs</File>
      <File>src/EditorFeatures/Test/Workspaces/TestWorkspace_XmlCreation.cs</File>
      <File>src/Features/CSharp/Portable/CSharpFeaturesResources.Designer.cs</File>
      <File>src/Features/CSharp/Portable/EditAndContinue/CSharpEditAndContinueAnalyzer.cs</File>
      <File>src/Features/CSharp/Portable/ExtractMethod/CSharpSelectionValidator.cs</File>
      <File>src/Test/Utilities/Shared/Diagnostics/TrackingDiagnosticAnalyzer.cs</File>
      <File>src/Workspaces/CSharp/Portable/Extensions/SyntaxNodeExtensions.cs</File>
      <File>src/Workspaces/CSharp/Portable/Formatting/Rules/IndentBlockFormattingRule.cs</File>
      <File>src/Workspaces/CSharp/Portable/Formatting/Rules/SuppressFormattingRule.cs</File>
      <File>src/Workspaces/CSharp/Portable/Formatting/Rules/TokenBasedFormattingRule.cs</File>
      <File>src/Workspaces/CSharpTest/Formatting/FormattingTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>9265</IssueID>
    <Title>Test/fix scoping of pattern variables in expression-bodied functions and properties.</Title>
    <Description>Fixes #8810.
Related to #8816.

@gafter, @jaredpar, @dotnet/roslyn-compiler Please review. 
</Description>
    <CreatedDate>27/02/2016</CreatedDate>
    <ClosedDate>28/02/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>8810</IssueID>
        <Title>Scoping for pattern variables in an expression-bodied local function</Title>
        <Description>We should (implement if necessary and) test the correctness of pattern variables defined at the top level of a local function

``` cs
public static void Main(string[] args)
{
    bool Three(object o) =&gt; o is int i &amp;&amp; i == 3;
}
```
</Description>
        <CreatedDate>17/02/2016</CreatedDate>
        <ClosedDate>29/02/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>8816</IssueID>
        <Title>Scope of a pattern variable in an expression-bodied property or method or field initializer</Title>
        <Description>The scope of a pattern variable declared in an expression-bodied property or method should include the whole body. This should be (implemented if necessary and) tested. For example:

``` cs
bool M(object o) =&gt; o is int i &amp;&amp; i == 3;
bool P =&gt; SomeObject is int i &amp;&amp; i == 3;
bool F = SomeObject is int i &amp;&amp; i == 3;
```

In the case of multiple field declarators, pattern variables should encompass the whole field declaration, but we need to ensure that definite assignment prevents using a pattern variable that is not definitely assigned.
</Description>
        <CreatedDate>17/02/2016</CreatedDate>
        <ClosedDate>02/03/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Statements.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/LocalBinderFactory.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/MemberSemanticModel.cs</File>
      <File>src/Compilers/CSharp/Portable/Compiler/MethodCompiler.cs</File>
      <File>src/Compilers/CSharp/Portable/Syntax/SyntaxNodeExtensions.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>9251</IssueID>
    <Title>Disable extract method on pattern matching features</Title>
    <Description>This addresses #9104 in the following ways:
- Fixes the gaps in data flow analysis that were causing the original assert in the bug.
- Disables extract method on pattern matching for now.  Filed #9244 to design scenarios here.

In order to fill in the data flow gaps I used commit 9d36a64af34a9a622a662398fd88478f79da7330 as a guide.  This change removed declaration expressions from the code base and hence gave a good outline of where data flow would be affected by pattern declaration expressions.

closes #9104
</Description>
    <CreatedDate>26/02/2016</CreatedDate>
    <ClosedDate>28/02/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>9104</IssueID>
        <Title>Assert in the DataFlowsOutWalker when trying to extract method on a patttern variable.</Title>
        <Description>tried to extract method on `ccc` in:

``` c#
            if (v is Class1 ccc)  //&lt;-- this one.
            {
                Console.WriteLine(ccc);
            }
```

---
## Assertion Failed: Abort=Quit, Retry=Debug, Ignore=Continue

   at Microsoft.CodeAnalysis.CSharp.DataFlowsOutWalker.Analyze(CSharpCompilation compilation, Symbol member, BoundNode node, BoundNode firstInRegion, BoundNode lastInRegion, HashSet`1 unassignedVariables, ImmutableArray`1 dataFlowsIn)

   at Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.get_DataFlowsOut()

   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GenerateVariableInfoMap(SemanticModel model, DataFlowAnalysis dataFlowAnalysisData, Dictionary`2 symbolMap)

   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.&lt;AnalyzeAsync&gt;d__10.MoveNext()

   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.Start[TStateMachine](TStateMachine&amp; stateMachine)

   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.AnalyzeAsync()

   at Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpMethodExtractor.CSharpAnalyzer.AnalyzeAsync(SelectionResult selectionResult, CancellationToken cancellationToken)

   at Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharp......
## &lt;truncated&gt;
## Abort   Retry   Ignore   
</Description>
        <CreatedDate>23/02/2016</CreatedDate>
        <ClosedDate>28/02/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>9244</IssueID>
        <Title>Consider pattern matching for extract method scenarios</Title>
        <Description>As a part of fixing #9104 for preview pattern matching is being blanket excluded from extract method.  For RTM though we should be looking at this and considering what valid extractions could be done an pattern expressions. 
</Description>
        <CreatedDate>26/02/2016</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
      <Issue>
        <IssueID>9104</IssueID>
        <Title>Assert in the DataFlowsOutWalker when trying to extract method on a patttern variable.</Title>
        <Description>tried to extract method on `ccc` in:

``` c#
            if (v is Class1 ccc)  //&lt;-- this one.
            {
                Console.WriteLine(ccc);
            }
```

---
## Assertion Failed: Abort=Quit, Retry=Debug, Ignore=Continue

   at Microsoft.CodeAnalysis.CSharp.DataFlowsOutWalker.Analyze(CSharpCompilation compilation, Symbol member, BoundNode node, BoundNode firstInRegion, BoundNode lastInRegion, HashSet`1 unassignedVariables, ImmutableArray`1 dataFlowsIn)

   at Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.get_DataFlowsOut()

   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GenerateVariableInfoMap(SemanticModel model, DataFlowAnalysis dataFlowAnalysisData, Dictionary`2 symbolMap)

   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.&lt;AnalyzeAsync&gt;d__10.MoveNext()

   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.Start[TStateMachine](TStateMachine&amp; stateMachine)

   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.AnalyzeAsync()

   at Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpMethodExtractor.CSharpAnalyzer.AnalyzeAsync(SelectionResult selectionResult, CancellationToken cancellationToken)

   at Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharp......
## &lt;truncated&gt;
## Abort   Retry   Ignore   
</Description>
        <CreatedDate>23/02/2016</CreatedDate>
        <ClosedDate>28/02/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/DataFlowsOutWalker.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/VariablesDeclaredWalker.cs</File>
      <File>src/EditorFeatures/CSharpTest/ExtractMethod/ExtractMethodBase.cs</File>
      <File>src/EditorFeatures/CSharpTest/ExtractMethod/ExtractMethodTests.LanguageInteraction.cs</File>
      <File>src/EditorFeatures/Test/Workspaces/TestWorkspace_Create.cs</File>
      <File>src/EditorFeatures/Test/Workspaces/TestWorkspace_XmlConsumption.cs</File>
      <File>src/EditorFeatures/Test/Workspaces/TestWorkspace_XmlCreation.cs</File>
      <File>src/Features/CSharp/Portable/CSharpFeaturesResources.Designer.cs</File>
      <File>src/Features/CSharp/Portable/ExtractMethod/CSharpSelectionValidator.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>9233</IssueID>
    <Title>Implement SymbolInfo for the property name of a property pattern</Title>
    <Description>Fixes #9072 #9073 #9079 #9080 

/cc @jaredpar @AlekseyTs @CyrusNajmabadi FYI
</Description>
    <CreatedDate>26/02/2016</CreatedDate>
    <ClosedDate>28/02/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>9072</IssueID>
        <Title>Goto def on complex pattern member name doesn't work.</Title>
        <Description>Given this code:

``` c#
    public class Expression { }
    public class Constant : Expression
    {
        public readonly int Value;
        public Constant(int Value)
        {
            this.Value = Value;
        }
    }
    public class Plus : Expression
    {
        public readonly Expression Left, Right;
        public Plus(Expression Left, Expression Right)
        {
            this.Left = Left;
            this.Right = Right;
        }
    }
    public class X
    {
        public static void Main()
        {
            Expression expr = null;
            if (expr is Plus { $$Left is Plus })
```

Goto def on Left (in the last line) does not work.
</Description>
        <CreatedDate>23/02/2016</CreatedDate>
        <ClosedDate>03/03/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>9073</IssueID>
        <Title>Find all refs doesn't find field/prop used in complex pattern member.</Title>
        <Description>Given the following:

``` c#
    public class Expression { }
    public class Constant : Expression
    {
        public readonly int Value;
        public Constant(int Value)
        {
            this.Value = Value;
        }
    }
    public class Plus : Expression
    {
        public readonly Expression $$Left, Right;   // Find All Refs on 'Left'
        public Plus(Expression Left, Expression Right)
        {
            this.Left = Left;
            this.Right = Right;
        }
    }
    public class X
    {
        public static void Main()
        {
            Expression expr = null;
            if (expr is Plus { Left is Plus })
```

Find all Refs on Plus.Left does not find the match in the complex pattern.
</Description>
        <CreatedDate>23/02/2016</CreatedDate>
        <ClosedDate>03/03/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>9079</IssueID>
        <Title>Rename does not update usages in complex patterns.</Title>
        <Description>``` c#
    public class Expression { }
    public class Constant : Expression
    {
        public readonly int Value;
        public Constant(int Value)
        {
            this.Value = Value;
        }
    }
    public class Plus : Expression
    {
        public readonly Expression Left, Right;     // rename Left here.
        public Plus(Expression Left, Expression Right)
        {
            this.Left = Left;
            this.Right = Right;
        }
    }
    public class X
    {
        public static void Main()
        {
            Expression expr = new Plus(new Plus(new Constant(1), new Plus(new Constant(2), new Constant(3))), new Constant(6));

            if (expr is Plus { Left is Plus p,Right is Constant c })
            {
            }
```

Renaming Plus.Left does not update reference in the complex pattern.
</Description>
        <CreatedDate>23/02/2016</CreatedDate>
        <ClosedDate>03/03/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>9080</IssueID>
        <Title>Rename cannot be triggered from complex pattern member.</Title>
        <Description>``` c#
 public class Expression { }
    public class Constant : Expression
    {
        public readonly int Value;
        public Constant(int Value)
        {
            this.Value = Value;
        }
    }
    public class Plus : Expression
    {
        public readonly Expression Left, Right;    
        public Plus(Expression Left, Expression Right)
        {
            this.Left = Left;
            this.Right = Right;
        }
    }
    public class X
    {
        public static void Main()
        {
            Expression expr = new Plus(new Plus(new Constant(1), new Plus(new Constant(2), new Constant(3))), new Constant(6));

            if (expr is Plus { Left is Plus p,Right is Constant c })  // try to rename Left here.
            {
            }
```

Error occurs saying that symbol cannot be renamed.
</Description>
        <CreatedDate>23/02/2016</CreatedDate>
        <ClosedDate>03/03/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Patterns.cs</File>
      <File>src/Compilers/CSharp/Portable/CSharpExtensions.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/CSharpSemanticModel.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/MemberSemanticModel.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/SyntaxTreeSemanticModel.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/DataFlowPass.cs</File>
      <File>src/Compilers/CSharp/Portable/FlowAnalysis/PreciseAbstractFlowPass_Switch.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_Patterns.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/LanguageParser_Patterns.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>9230</IssueID>
    <Title>Test/fix scoping of pattern variables in an expression-bodied lambdas and query expressions.</Title>
    <Description>Fixes #8809.
Related to #9210.

@gafter, @jaredpar, @dotnet/roslyn-compiler Please review.  
</Description>
    <CreatedDate>26/02/2016</CreatedDate>
    <ClosedDate>26/02/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>8809</IssueID>
        <Title>Scoping for pattern variables in an expression-bodied lambda</Title>
        <Description>We need to (implement if necessary and) test that pattern variables work correctly in an expression-bodied lambda such as

``` cs
Func&lt;object, bool&gt; f = o =&gt; (o is int i &amp;&amp; i == 3);
```

similarly, the corresponding cases should work for Linq expressions

``` cs
var b = from o in objectSequence select o is int i &amp;&amp; i == 3;
```
</Description>
        <CreatedDate>17/02/2016</CreatedDate>
        <ClosedDate>26/02/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>9210</IssueID>
        <Title>Scope of pattern variables in join clause</Title>
        <Description>The expression in a `join` clause, i.e. _e_ in `... join x in e ...`, does _not_ turn into a lambda body. This expression needs to define a scope for any pattern variables that are declared in that expression. The scope of those pattern variables does not extend outside that expression.
</Description>
        <CreatedDate>25/02/2016</CreatedDate>
        <ClosedDate>26/02/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Query.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Statements.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/PatternVariableFinder.cs</File>
      <File>src/Compilers/CSharp/Portable/BoundTree/UnboundLambda.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/PatternMatchingTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>9175</IssueID>
    <Title>[Ask Mode] Add `OperatorMethodIntegerDivide` to `BinaryOperationKind`</Title>
    <Description>Add `BinaryOperationKind.OperatorMethodIntegerDivide` to represent `\` in VB.
This fixes crash in #9129. But there are several other binary opertors from VB are still not in IOperation (see #9174)

@JohnHamby @AlekseyTs @dotnet/roslyn-interactive 
</Description>
    <CreatedDate>25/02/2016</CreatedDate>
    <ClosedDate>27/02/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>9129</IssueID>
        <Title>Unexpected value 'IntegerDivide' of type 'Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind'</Title>
        <Description>Test for repro this crash (with OperationWalker hooked up):

```
Microsoft.CodeAnalysis.VisualBasic.UnitTests.Semantics.UserDefinedBinaryOperators.BasicTest
```

Stack trace:

```
Test 'Microsoft.CodeAnalysis.VisualBasic.UnitTests.Semantics.UserDefinedBinaryOperators.BasicTest' failed: Microsoft.CodeAnalysis.ThrowingTraceListener+DebugAssertFailureException : Unexpected value 'IntegerDivide' of type 'Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind'

    ThrowingTraceListener.cs(25,0): at Microsoft.CodeAnalysis.ThrowingTraceListener.Fail(String message, String detailMessage)
    at System.Diagnostics.TraceListener.Fail(String message)
    at System.Diagnostics.TraceInternal.Fail(String message)
    at System.Diagnostics.Debug.Assert(Boolean condition, String message)
    InternalUtilities\ExceptionUtilities.cs(13,0): at Roslyn.Utilities.ExceptionUtilities.UnexpectedValue(Object o)
    BoundTree\Expression.vb(771,0): at Microsoft.CodeAnalysis.VisualBasic.BoundUserDefinedBinaryOperator.get_IBinaryOperatorExpression_BinaryOperationKind()
    c:\GitHub\roslyn-internal\Open\src\Test\Utilities\Shared\Compilation\TestOperationWalker.cs(360,0): at Microsoft.CodeAnalysis.Test.Utilities.TestOperationWalker.VisitBinaryOperatorExpression(IBinaryOperatorExpression operation)
    BoundTree\Expression.vb(809,0): at Microsoft.CodeAnalysis.VisualBasic.BoundUserDefinedBinaryOperator.Accept(OperationVisitor visitor)
    Compilation\OperationWalker.cs(34,0): at Microsoft.CodeAnalysis.Semantics.OperationWalker.Visit(IOperation operation)
    c:\GitHub\roslyn-internal\Open\src\Test\Utilities\Shared\Compilation\TestOperationWalker.cs(41,0): at Microsoft.CodeAnalysis.Test.Utilities.TestOperationWalker.Visit(IOperation operation)
    Compilation\OperationWalker.cs(374,0): at Microsoft.CodeAnalysis.Semantics.OperationWalker.VisitAssignmentExpression(IAssignmentExpression operation)
    c:\GitHub\roslyn-internal\Open\src\Test\Utilities\Shared\Compilation\TestOperationWalker.cs(482,0): at Microsoft.CodeAnalysis.Test.Utilities.TestOperationWalker.VisitAssignmentExpression(IAssignmentExpression operation)
    BoundTree\Expression.vb(141,0): at Microsoft.CodeAnalysis.VisualBasic.BoundAssignmentOperator.Accept(OperationVisitor visitor)
    Compilation\OperationWalker.cs(34,0): at Microsoft.CodeAnalysis.Semantics.OperationWalker.Visit(IOperation operation)
    c:\GitHub\roslyn-internal\Open\src\Test\Utilities\Shared\Compilation\TestOperationWalker.cs(41,0): at Microsoft.CodeAnalysis.Test.Utilities.TestOperationWalker.Visit(IOperation operation)
    Compilation\OperationWalker.cs(181,0): at Microsoft.CodeAnalysis.Semantics.OperationWalker.VisitExpressionStatement(IExpressionStatement operation)
    c:\GitHub\roslyn-internal\Open\src\Test\Utilities\Shared\Compilation\TestOperationWalker.cs(185,0): at Microsoft.CodeAnalysis.Test.Utilities.TestOperationWalker.VisitExpressionStatement(IExpressionStatement operation)
    BoundTree\Statement.vb(1477,0): at Microsoft.CodeAnalysis.VisualBasic.BoundExpressionStatement.Accept(OperationVisitor visitor)
    Compilation\OperationWalker.cs(34,0): at Microsoft.CodeAnalysis.Semantics.OperationWalker.Visit(IOperation operation)
    c:\GitHub\roslyn-internal\Open\src\Test\Utilities\Shared\Compilation\TestOperationWalker.cs(41,0): at Microsoft.CodeAnalysis.Test.Utilities.TestOperationWalker.Visit(IOperation operation)
    CompilationTestUtils.vb(279,0): at Microsoft.CodeAnalysis.VisualBasic.UnitTests.CompilationUtils.WalkOperationTrees(VisualBasicCompilation compilation)
    CompilationTestUtils.vb(230,0): at Microsoft.CodeAnalysis.VisualBasic.UnitTests.CompilationUtils.CreateCompilationWithReferences(IEnumerable`1 sourceTrees, IEnumerable`1 references, VisualBasicCompilationOptions options, String assemblyName)
    CompilationTestUtils.vb(200,0): at Microsoft.CodeAnalysis.VisualBasic.UnitTests.CompilationUtils.CreateCompilationWithReferences(XElement sources, IEnumerable`1 references, VisualBasicCompilationOptions options, IEnumerable`1&amp; spans, VisualBasicParseOptions parseOptions)
    BasicTestBase.vb(162,0): at Microsoft.CodeAnalysis.VisualBasic.UnitTests.BasicTestBase.CompileAndVerify(XElement source, IEnumerable`1 allReferences, String expectedOutput, IEnumerable`1 dependencies, Action`1 sourceSymbolValidator, Action`1 validator, Action`1 symbolValidator, SignatureDescription[] expectedSignatures, VisualBasicCompilationOptions options, VisualBasicParseOptions parseOptions, Boolean verify)
    BasicTestBase.vb(129,0): at Microsoft.CodeAnalysis.VisualBasic.UnitTests.BasicTestBase.CompileAndVerify(XElement source, String expectedOutput, MetadataReference[] additionalRefs, IEnumerable`1 dependencies, Action`1 sourceSymbolValidator, Action`1 validator, Action`1 symbolValidator, SignatureDescription[] expectedSignatures, VisualBasicCompilationOptions options, VisualBasicParseOptions parseOptions, Boolean verify, Boolean useLatestFramework)
    BasicTestBase.vb(51,0): at Microsoft.CodeAnalysis.VisualBasic.UnitTests.BasicTestBase.CompileAndVerify(XElement source, XCData expectedOutput, MetadataReference[] additionalRefs, IEnumerable`1 dependencies, Action`1 sourceSymbolValidator, Action`1 validator, Action`1 symbolValidator, SignatureDescription[] expectedSignatures, VisualBasicCompilationOptions options, VisualBasicParseOptions parseOptions, Boolean verify)
    Semantics\UserDefinedBinaryOperators.vb(163,0): at Microsoft.CodeAnalysis.VisualBasic.UnitTests.Semantics.UserDefinedBinaryOperators.BasicTest()
```
</Description>
        <CreatedDate>24/02/2016</CreatedDate>
        <ClosedDate>27/02/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>9174</IssueID>
        <Title>Several binary operators of VB is not represented in IOperation</Title>
        <Description>`^` (power), `Like` and `&amp;` (concat) are not a part of `IOperation`.

Here's how to repro this bug:
- In the case of user defined operator, it will crash in `BoundUserDefinedBinaryOperator.get_IBinaryOperatorExpression_BinaryOperationKind()` with message `Unexpected value 'Power' of type 'Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind'
  `
- In the case of none user-defined operator, its `BinaryOperationKind` property will have value `Invalid`
  (returned by `Expression.DeriveBinaryOperationKind` method`

``` vb
Public Class B2
    Public Shared Operator ^(x As B2, y As B2) As B2 
        System.Console.WriteLine("^")
        Return x
    End Operator

    Public Shared Operator Like(x As B2, y As B2) As B2
        System.Console.WriteLine("Like")
        Return x
    End Operator

    Public Shared Operator &amp;(x As B2, y As B2) As B2 
        System.Console.WriteLine("&amp;")
        Return x
    End Operator
End Class

Module Module1
    Sub Main() 
        Dim x, y As New B2()
        Dim r As B2

        r = x ^ y
        r = x Like y 
        r = x &amp; y    

        dim i = 2 ^ 3
    End Sub
End Module
```
</Description>
        <CreatedDate>25/02/2016</CreatedDate>
        <ClosedDate>29/09/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/Core/CodeAnalysisTest/Diagnostics/OperationTestAnalyzer.cs</File>
      <File>src/Compilers/Core/Portable/Compilation/IExpression.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>8920</IssueID>
    <Title>Prevent DeriveArgument methods from trying to access parameter symbols that don't exist.</Title>
    <Description>This change set is expected to fix #8901 . There are no tests provided in the change set because attempts to produce a small repro have failed. The fix is to take defensive action against a situation the compilers are expected to screen out--semantically invalid invocations that include an argument that doesn't match a parameter.

@mavasani , does this change set actually fix #8901 ?
</Description>
    <CreatedDate>19/02/2016</CreatedDate>
    <ClosedDate>20/02/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>8901</IssueID>
        <Title>IndexOutOfRangeException at Microsoft.CodeAnalysis.CSharp.BoundCall.DeriveArgument while running Operation analyzers</Title>
        <Description>1. Clean your RoslynDev hive
2. Get latest sources of roslyn and roslyn-analyzers and build
3. devenv /rootsuffix RoslynDev
4. Open Roslyn.sln and source file `Compilation.cs` in project `CodeAnalysis` (I am unable to come up with a minimal repro that doesn't require opening Roslyn.sln)
5. Attach a debugger to this instance of VS.
6. Paste the below code at the beginning of class definition for `Compilation` and wait for a few seconds till the diagnostics are computed - you should hit the crash.

``` C#
    private object F(Assembly assembly)
    {
        var type = (from t in assembly.GetTypes()
                    select t.Attributes).FirstOrDefault();
        return type;
    }
```

&gt; &gt; Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.FatalError.Report(System.Exception exception, System.Action&lt;System.Exception&gt; handler) Line 151   C#
&gt; &gt;     Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.ProcessCompilationEventsCoreAsync(Microsoft.CodeAnalysis.Diagnostics.AnalysisScope analysisScope, Microsoft.CodeAnalysis.Diagnostics.AnalysisState analysisStateOpt, bool prePopulatedEventQueue, System.Threading.CancellationToken cancellationToken) Line 770   C#
&gt; &gt;     [Resuming Async Method] 
&gt; &gt;     [External Code] 
&gt; &gt;     Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.BoundCall.DeriveArgument.AnonymousMethod__0(Microsoft.CodeAnalysis.CSharp.BoundExpression argument) Line 175    C#
&gt; &gt;     [External Code] 
&gt; &gt;     Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.BoundCall.DeriveArgument(int parameterIndex, int argumentIndex, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.CSharp.BoundExpression&gt; boundArguments, System.Collections.Immutable.ImmutableArray&lt;string&gt; argumentNames, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.RefKind&gt; argumentRefKinds, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol&gt; parameters, Microsoft.CodeAnalysis.SyntaxNode invocationSyntax) Line 148 C#
&gt; &gt;     Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.BoundCall.Microsoft.CodeAnalysis.Semantics.IInvocationExpression.ArgumentsInSourceOrder.get() Line 54   C#
&gt; &gt;     Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Semantics.OperationWalker.VisitInvocationExpression(Microsoft.CodeAnalysis.Semantics.IInvocationExpression operation) Line 196    C#
&gt; &gt;     Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.BoundCall.Accept(Microsoft.CodeAnalysis.Semantics.OperationVisitor visitor) Line 77 C#
&gt; &gt;     Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Semantics.OperationWalker.Visit(Microsoft.CodeAnalysis.IOperation operation) Line 34  C#
&gt; &gt;     Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Semantics.OperationExtensions.OperationCollector.Visit(Microsoft.CodeAnalysis.IOperation operation) Line 64   C#
&gt; &gt;     Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Semantics.OperationWalker.VisitVariableDeclaration(Microsoft.CodeAnalysis.Semantics.IVariableDeclaration operation) Line 55   C#
&gt; &gt;     Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Semantics.VariableDeclaration.Accept(Microsoft.CodeAnalysis.Semantics.OperationVisitor visitor) Line 35   C#
&gt; &gt;     Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Semantics.OperationWalker.Visit(Microsoft.CodeAnalysis.IOperation operation) Line 34  C#
&gt; &gt;     Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Semantics.OperationExtensions.OperationCollector.Visit(Microsoft.CodeAnalysis.IOperation operation) Line 64   C#
&gt; &gt;     Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Semantics.OperationWalker.VisitArray&lt;Microsoft.CodeAnalysis.Semantics.IVariableDeclaration&gt;(System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Semantics.IVariableDeclaration&gt; list) Line 21  C#
&gt; &gt;     Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Semantics.OperationWalker.VisitVariableDeclarationStatement(Microsoft.CodeAnalysis.Semantics.IVariableDeclarationStatement operation) Line 50 C#
&gt; &gt;     Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.BoundLocalDeclaration.Accept(Microsoft.CodeAnalysis.Semantics.OperationVisitor visitor) Line 614    C#
&gt; &gt;     Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Semantics.OperationWalker.Visit(Microsoft.CodeAnalysis.IOperation operation) Line 34  C#
&gt; &gt;     Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Semantics.OperationExtensions.OperationCollector.Visit(Microsoft.CodeAnalysis.IOperation operation) Line 64   C#
&gt; &gt;     Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Semantics.OperationWalker.VisitArray&lt;Microsoft.CodeAnalysis.IOperation&gt;(System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.IOperation&gt; list) Line 21  C#
&gt; &gt;     Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Semantics.OperationWalker.VisitBlockStatement(Microsoft.CodeAnalysis.Semantics.IBlockStatement operation) Line 45 C#
&gt; &gt;     Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.BoundBlock.Accept(Microsoft.CodeAnalysis.Semantics.OperationVisitor visitor) Line 52    C#
&gt; &gt;     Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Semantics.OperationWalker.Visit(Microsoft.CodeAnalysis.IOperation operation) Line 34  C#
&gt; &gt;     Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Semantics.OperationExtensions.OperationCollector.Visit(Microsoft.CodeAnalysis.IOperation operation) Line 64   C#
&gt; &gt;     Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Semantics.OperationExtensions.DescendantsAndSelf(Microsoft.CodeAnalysis.IOperation operation) Line 32 C#
&gt; &gt;     Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver&lt;Microsoft.CodeAnalysis.CSharp.SyntaxKind&gt;.GetOperationsToAnalyze(System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.IOperation&gt; operationBlocks) Line 1777 C#
&gt; &gt;     Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver&lt;Microsoft.CodeAnalysis.CSharp.SyntaxKind&gt;.ExecuteDeclaringReferenceActions(Microsoft.CodeAnalysis.SyntaxReference decl, int declarationIndex, Microsoft.CodeAnalysis.Diagnostics.SymbolDeclaredCompilationEvent symbolEvent, Microsoft.CodeAnalysis.Diagnostics.AnalysisScope analysisScope, Microsoft.CodeAnalysis.Diagnostics.AnalysisState analysisStateOpt, bool shouldExecuteSyntaxNodeActions, bool shouldExecuteOperationActions, bool shouldExecuteCodeBlockActions, bool shouldExecuteOperationBlockActions, bool isInGeneratedCode, System.Threading.CancellationToken cancellationToken) Line 1542  C#
&gt; &gt;     Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver&lt;Microsoft.CodeAnalysis.CSharp.SyntaxKind&gt;.ExecuteDeclaringReferenceActions(Microsoft.CodeAnalysis.Diagnostics.SymbolDeclaredCompilationEvent symbolEvent, Microsoft.CodeAnalysis.Diagnostics.AnalysisScope analysisScope, Microsoft.CodeAnalysis.Diagnostics.AnalysisState analysisStateOpt, bool isGeneratedCodeSymbol, System.Threading.CancellationToken cancellationToken) Line 1401   C#
</Description>
        <CreatedDate>19/02/2016</CreatedDate>
        <ClosedDate>20/02/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>8901</IssueID>
        <Title>IndexOutOfRangeException at Microsoft.CodeAnalysis.CSharp.BoundCall.DeriveArgument while running Operation analyzers</Title>
        <Description>1. Clean your RoslynDev hive
2. Get latest sources of roslyn and roslyn-analyzers and build
3. devenv /rootsuffix RoslynDev
4. Open Roslyn.sln and source file `Compilation.cs` in project `CodeAnalysis` (I am unable to come up with a minimal repro that doesn't require opening Roslyn.sln)
5. Attach a debugger to this instance of VS.
6. Paste the below code at the beginning of class definition for `Compilation` and wait for a few seconds till the diagnostics are computed - you should hit the crash.

``` C#
    private object F(Assembly assembly)
    {
        var type = (from t in assembly.GetTypes()
                    select t.Attributes).FirstOrDefault();
        return type;
    }
```

&gt; &gt; Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.FatalError.Report(System.Exception exception, System.Action&lt;System.Exception&gt; handler) Line 151   C#
&gt; &gt;     Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.ProcessCompilationEventsCoreAsync(Microsoft.CodeAnalysis.Diagnostics.AnalysisScope analysisScope, Microsoft.CodeAnalysis.Diagnostics.AnalysisState analysisStateOpt, bool prePopulatedEventQueue, System.Threading.CancellationToken cancellationToken) Line 770   C#
&gt; &gt;     [Resuming Async Method] 
&gt; &gt;     [External Code] 
&gt; &gt;     Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.BoundCall.DeriveArgument.AnonymousMethod__0(Microsoft.CodeAnalysis.CSharp.BoundExpression argument) Line 175    C#
&gt; &gt;     [External Code] 
&gt; &gt;     Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.BoundCall.DeriveArgument(int parameterIndex, int argumentIndex, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.CSharp.BoundExpression&gt; boundArguments, System.Collections.Immutable.ImmutableArray&lt;string&gt; argumentNames, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.RefKind&gt; argumentRefKinds, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol&gt; parameters, Microsoft.CodeAnalysis.SyntaxNode invocationSyntax) Line 148 C#
&gt; &gt;     Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.BoundCall.Microsoft.CodeAnalysis.Semantics.IInvocationExpression.ArgumentsInSourceOrder.get() Line 54   C#
&gt; &gt;     Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Semantics.OperationWalker.VisitInvocationExpression(Microsoft.CodeAnalysis.Semantics.IInvocationExpression operation) Line 196    C#
&gt; &gt;     Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.BoundCall.Accept(Microsoft.CodeAnalysis.Semantics.OperationVisitor visitor) Line 77 C#
&gt; &gt;     Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Semantics.OperationWalker.Visit(Microsoft.CodeAnalysis.IOperation operation) Line 34  C#
&gt; &gt;     Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Semantics.OperationExtensions.OperationCollector.Visit(Microsoft.CodeAnalysis.IOperation operation) Line 64   C#
&gt; &gt;     Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Semantics.OperationWalker.VisitVariableDeclaration(Microsoft.CodeAnalysis.Semantics.IVariableDeclaration operation) Line 55   C#
&gt; &gt;     Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Semantics.VariableDeclaration.Accept(Microsoft.CodeAnalysis.Semantics.OperationVisitor visitor) Line 35   C#
&gt; &gt;     Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Semantics.OperationWalker.Visit(Microsoft.CodeAnalysis.IOperation operation) Line 34  C#
&gt; &gt;     Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Semantics.OperationExtensions.OperationCollector.Visit(Microsoft.CodeAnalysis.IOperation operation) Line 64   C#
&gt; &gt;     Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Semantics.OperationWalker.VisitArray&lt;Microsoft.CodeAnalysis.Semantics.IVariableDeclaration&gt;(System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Semantics.IVariableDeclaration&gt; list) Line 21  C#
&gt; &gt;     Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Semantics.OperationWalker.VisitVariableDeclarationStatement(Microsoft.CodeAnalysis.Semantics.IVariableDeclarationStatement operation) Line 50 C#
&gt; &gt;     Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.BoundLocalDeclaration.Accept(Microsoft.CodeAnalysis.Semantics.OperationVisitor visitor) Line 614    C#
&gt; &gt;     Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Semantics.OperationWalker.Visit(Microsoft.CodeAnalysis.IOperation operation) Line 34  C#
&gt; &gt;     Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Semantics.OperationExtensions.OperationCollector.Visit(Microsoft.CodeAnalysis.IOperation operation) Line 64   C#
&gt; &gt;     Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Semantics.OperationWalker.VisitArray&lt;Microsoft.CodeAnalysis.IOperation&gt;(System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.IOperation&gt; list) Line 21  C#
&gt; &gt;     Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Semantics.OperationWalker.VisitBlockStatement(Microsoft.CodeAnalysis.Semantics.IBlockStatement operation) Line 45 C#
&gt; &gt;     Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.BoundBlock.Accept(Microsoft.CodeAnalysis.Semantics.OperationVisitor visitor) Line 52    C#
&gt; &gt;     Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Semantics.OperationWalker.Visit(Microsoft.CodeAnalysis.IOperation operation) Line 34  C#
&gt; &gt;     Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Semantics.OperationExtensions.OperationCollector.Visit(Microsoft.CodeAnalysis.IOperation operation) Line 64   C#
&gt; &gt;     Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Semantics.OperationExtensions.DescendantsAndSelf(Microsoft.CodeAnalysis.IOperation operation) Line 32 C#
&gt; &gt;     Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver&lt;Microsoft.CodeAnalysis.CSharp.SyntaxKind&gt;.GetOperationsToAnalyze(System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.IOperation&gt; operationBlocks) Line 1777 C#
&gt; &gt;     Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver&lt;Microsoft.CodeAnalysis.CSharp.SyntaxKind&gt;.ExecuteDeclaringReferenceActions(Microsoft.CodeAnalysis.SyntaxReference decl, int declarationIndex, Microsoft.CodeAnalysis.Diagnostics.SymbolDeclaredCompilationEvent symbolEvent, Microsoft.CodeAnalysis.Diagnostics.AnalysisScope analysisScope, Microsoft.CodeAnalysis.Diagnostics.AnalysisState analysisStateOpt, bool shouldExecuteSyntaxNodeActions, bool shouldExecuteOperationActions, bool shouldExecuteCodeBlockActions, bool shouldExecuteOperationBlockActions, bool isInGeneratedCode, System.Threading.CancellationToken cancellationToken) Line 1542  C#
&gt; &gt;     Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver&lt;Microsoft.CodeAnalysis.CSharp.SyntaxKind&gt;.ExecuteDeclaringReferenceActions(Microsoft.CodeAnalysis.Diagnostics.SymbolDeclaredCompilationEvent symbolEvent, Microsoft.CodeAnalysis.Diagnostics.AnalysisScope analysisScope, Microsoft.CodeAnalysis.Diagnostics.AnalysisState analysisStateOpt, bool isGeneratedCodeSymbol, System.Threading.CancellationToken cancellationToken) Line 1401   C#
</Description>
        <CreatedDate>19/02/2016</CreatedDate>
        <ClosedDate>20/02/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/BoundTree/Expression.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>8832</IssueID>
    <Title>Do not offer to create p2p references if the project system will not allow those references.</Title>
    <Description>Fixes #8771,    #8777, #8779, #8785

Note: this resurrects the work to make it so that code actoins can do a final applicability check on the UI thread. This is necessary because the APIs we need to call are COM STA affinitized. Once we move to CPS we should actually be able to safely call this stuff on the background thread and we can remove these internal APIs.
</Description>
    <CreatedDate>17/02/2016</CreatedDate>
    <ClosedDate>20/02/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>8771</IssueID>
        <Title>[project reference add using] Reference desktop class library from UWP project crashes codefix</Title>
        <Description>1. Create UWP app
2. Create Desktop class library `Class1`
3. Add code that will reference `var a = new Class1();`

![image](https://cloud.githubusercontent.com/assets/9797472/13094328/d1eac99a-d4be-11e5-8fda-208aa4123598.png)

**Expected**: Add Using is not offered because it is invalid to referece Desktop from UWP

**Actual**: Codefix crashes with following stack

```
User canceled out of save dialog (Exception from HRESULT: 0x8004000C (OLE_E_PROMPTSAVECANCELLED))
 at VSLangProj.References.AddProject(Project pProject)
 at Microsoft.VisualStudio.LanguageServices.Implementation.ProjectSystem.VisualStudioWorkspaceImpl.ApplyProjectReferenceAdded(ProjectId projectId, ProjectReference projectReference)
 at Microsoft.CodeAnalysis.Workspace.ApplyProjectChanges(ProjectChanges projectChanges)
 at Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Solution newSolution)
 at Microsoft.VisualStudio.LanguageServices.Implementation.ProjectSystem.VisualStudioWorkspaceImpl.TryApplyChanges(Solution newSolution)
 at Microsoft.CodeAnalysis.CodeActions.ApplyChangesOperation.Apply(Workspace workspace, CancellationToken cancellationToken)
 at Microsoft.CodeAnalysis.Editor.Implementation.CodeActions.CodeActionEditHandlerService.ProcessOperations(Workspace workspace, Document fromDocument, String title, Solution oldSolution, Solution updatedSolution, List`1 operationsList, CancellationToken cancellationToken)
 at Microsoft.CodeAnalysis.Editor.Implementation.CodeActions.CodeActionEditHandlerService.Apply(Workspace workspace, Document fromDocument, IEnumerable`1 operations, String title, CancellationToken cancellationToken)
 at Microsoft.CodeAnalysis.Editor.Implementation.Suggestions.SuggestedAction.&lt;InvokeWorkerAsync&gt;d__18.MoveNext() --- End of stack trace from previous location where exception was thrown ---
 at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
 at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
 at System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter.GetResult()
 at Microsoft.CodeAnalysis.Editor.Implementation.Suggestions.SuggestedAction.&lt;&gt;c__DisplayClass17_0.&lt;&lt;InvokeCoreAsync&gt;b__0&gt;d.MoveNext() --- End of stack trace from previous location where exception was thrown ---
 at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
 at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
 at System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter.GetResult()
 at Microsoft.CodeAnalysis.Extensions.IExtensionManagerExtensions.&lt;PerformActionAsync&gt;d__2.MoveNext()
```
</Description>
        <CreatedDate>16/02/2016</CreatedDate>
        <ClosedDate>01/03/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>8777</IssueID>
        <Title>[project reference add using] Reference desktop class library from Website project crashes codefix</Title>
        <Description>1. Create ASP.NET Empty Web Site
2. Add a new class in the App_Code folder
3. Create a Desktop class library `ClassLibrary1`
4. Add code that will reference `ClassLibrary1` `var a = new Class2();`

**Expected**: Add Usings is not offered because WebSite projects cannot reference other projects

**Actual**: Add Usings is offered and crashes due to COM exception

![image](https://cloud.githubusercontent.com/assets/9797472/13095225/1e8e30a6-d4c5-11e5-9156-e1de57acb521.png)

```
Unable to cast COM object of type 'System.__ComObject' to interface type 'VSLangProj.VSProject'. This operation failed because the QueryInterface call on the COM component for the interface with IID '{2CFB826F-F6BF-480D-A546-95A0381CC411}' failed due to the following error: No such interface supported (Exception from HRESULT: 0x80004002 (E_NOINTERFACE)).
 at Microsoft.VisualStudio.LanguageServices.Implementation.ProjectSystem.VisualStudioWorkspaceImpl.ApplyProjectReferenceAdded(ProjectId projectId, ProjectReference projectReference)
 at Microsoft.CodeAnalysis.Workspace.ApplyProjectChanges(ProjectChanges projectChanges)
 at Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Solution newSolution)
 at Microsoft.VisualStudio.LanguageServices.Implementation.ProjectSystem.VisualStudioWorkspaceImpl.TryApplyChanges(Solution newSolution)
 at Microsoft.CodeAnalysis.CodeActions.ApplyChangesOperation.Apply(Workspace workspace, CancellationToken cancellationToken)
 at Microsoft.CodeAnalysis.Editor.Implementation.CodeActions.CodeActionEditHandlerService.ProcessOperations(Workspace workspace, Document fromDocument, String title, Solution oldSolution, Solution updatedSolution, List`1 operationsList, CancellationToken cancellationToken)
 at Microsoft.CodeAnalysis.Editor.Implementation.CodeActions.CodeActionEditHandlerService.Apply(Workspace workspace, Document fromDocument, IEnumerable`1 operations, String title, CancellationToken cancellationToken)
 at Microsoft.CodeAnalysis.Editor.Implementation.Suggestions.SuggestedAction.&lt;InvokeWorkerAsync&gt;d__18.MoveNext() --- End of stack trace from previous location where exception was thrown ---
 at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
 at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
 at System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter.GetResult()
 at Microsoft.CodeAnalysis.Editor.Implementation.Suggestions.SuggestedAction.&lt;&gt;c__DisplayClass17_0.&lt;&lt;InvokeCoreAsync&gt;b__0&gt;d.MoveNext() --- End of stack trace from previous location where exception was thrown ---
 at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
 at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
 at System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter.GetResult()
 at Microsoft.CodeAnalysis.Extensions.IExtensionManagerExtensions.&lt;PerformActionAsync&gt;d__2.MoveNext()
```
</Description>
        <CreatedDate>16/02/2016</CreatedDate>
        <ClosedDate>01/03/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>8779</IssueID>
        <Title>[project reference add using] Referencing ASP.NET Core 1.0 from ASP.NET 4.6 WebForms project crashes codefix</Title>
        <Description>Create ASP.NET 4.6 WebForms project
Add a new ASP.NET Core 1.0 Class Library `ClassLibrary1`
Add code that will reference ClassLibrary1 `var a = new Class1();`

**Expected**: Add Usings is not offered because ASP.NET Core 1.0projects cannot be referenced from ASP.NET 4.6 WebForms projects

**Actual**: Add Usings is offered and crashes due to Unspecified error

![image](https://cloud.githubusercontent.com/assets/9797472/13095402/56d14c04-d4c6-11e5-8748-bc7f10a6538a.png)

```
Unspecified error (Exception from HRESULT: 0x80004005 (E_FAIL))
 at VSLangProj.References.AddProject(Project pProject)
 at Microsoft.VisualStudio.LanguageServices.Implementation.ProjectSystem.VisualStudioWorkspaceImpl.ApplyProjectReferenceAdded(ProjectId projectId, ProjectReference projectReference)
 at Microsoft.CodeAnalysis.Workspace.ApplyProjectChanges(ProjectChanges projectChanges)
 at Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Solution newSolution)
 at Microsoft.VisualStudio.LanguageServices.Implementation.ProjectSystem.VisualStudioWorkspaceImpl.TryApplyChanges(Solution newSolution)
 at Microsoft.CodeAnalysis.CodeActions.ApplyChangesOperation.Apply(Workspace workspace, CancellationToken cancellationToken)
 at Microsoft.CodeAnalysis.Editor.Implementation.CodeActions.CodeActionEditHandlerService.ProcessOperations(Workspace workspace, Document fromDocument, String title, Solution oldSolution, Solution updatedSolution, List`1 operationsList, CancellationToken cancellationToken)
 at Microsoft.CodeAnalysis.Editor.Implementation.CodeActions.CodeActionEditHandlerService.Apply(Workspace workspace, Document fromDocument, IEnumerable`1 operations, String title, CancellationToken cancellationToken)
 at Microsoft.CodeAnalysis.Editor.Implementation.Suggestions.SuggestedAction.&lt;InvokeWorkerAsync&gt;d__18.MoveNext() --- End of stack trace from previous location where exception was thrown ---
 at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
 at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
 at System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter.GetResult()
 at Microsoft.CodeAnalysis.Editor.Implementation.Suggestions.SuggestedAction.&lt;&gt;c__DisplayClass17_0.&lt;&lt;InvokeCoreAsync&gt;b__0&gt;d.MoveNext() --- End of stack trace from previous location where exception was thrown ---
 at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
 at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
 at System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter.GetResult()
 at Microsoft.CodeAnalysis.Extensions.IExtensionManagerExtensions.&lt;PerformActionAsync&gt;d__2.MoveNext()
```
</Description>
        <CreatedDate>17/02/2016</CreatedDate>
        <ClosedDate>01/03/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>8785</IssueID>
        <Title>[project reference add using] Reference desktop class library from Phone 8 project crashes codefix </Title>
        <Description>1. Create Phone 8 project app
2. Create Desktop class library `Class1`
3. Add code that will reference `var a = new Class1();`

**Expected**: Add Using is not offered because it is invalid to reference Desktop from Phone 8

**Actual**: Codefix crashes with following stack _and_ blocks the UI attempting to add the using to the file 

![image](https://cloud.githubusercontent.com/assets/9797472/13096617/8232628a-d4cf-11e5-9bc5-9e8ac16ef0ca.png)

```
User canceled out of save dialog (Exception from HRESULT: 0x8004000C (OLE_E_PROMPTSAVECANCELLED))
 at VSLangProj.References.AddProject(Project pProject)
 at Microsoft.VisualStudio.LanguageServices.Implementation.ProjectSystem.VisualStudioWorkspaceImpl.ApplyProjectReferenceAdded(ProjectId projectId, ProjectReference projectReference)
 at Microsoft.CodeAnalysis.Workspace.ApplyProjectChanges(ProjectChanges projectChanges)
 at Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Solution newSolution)
 at Microsoft.VisualStudio.LanguageServices.Implementation.ProjectSystem.VisualStudioWorkspaceImpl.TryApplyChanges(Solution newSolution)
 at Microsoft.CodeAnalysis.CodeActions.ApplyChangesOperation.Apply(Workspace workspace, CancellationToken cancellationToken)
 at Microsoft.CodeAnalysis.Editor.Implementation.CodeActions.CodeActionEditHandlerService.ProcessOperations(Workspace workspace, Document fromDocument, String title, Solution oldSolution, Solution updatedSolution, List`1 operationsList, CancellationToken cancellationToken)
 at Microsoft.CodeAnalysis.Editor.Implementation.CodeActions.CodeActionEditHandlerService.Apply(Workspace workspace, Document fromDocument, IEnumerable`1 operations, String title, CancellationToken cancellationToken)
 at Microsoft.CodeAnalysis.Editor.Implementation.Suggestions.SuggestedAction.&lt;InvokeWorkerAsync&gt;d__18.MoveNext() --- End of stack trace from previous location where exception was thrown ---
 at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
 at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
 at System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter.GetResult()
 at Microsoft.CodeAnalysis.Editor.Implementation.Suggestions.SuggestedAction.&lt;&gt;c__DisplayClass17_0.&lt;&lt;InvokeCoreAsync&gt;b__0&gt;d.MoveNext() --- End of stack trace from previous location where exception was thrown ---
 at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
 at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
 at System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter.GetResult()
 at Microsoft.CodeAnalysis.Extensions.IExtensionManagerExtensions.&lt;PerformActionAsync&gt;d__2.MoveNext()
```

**NOTE**: The add using operation never completes unless the user clicks _cancel_.  
</Description>
        <CreatedDate>17/02/2016</CreatedDate>
        <ClosedDate>20/02/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/Core/Implementation/CodeFixes/CodeFixService.ProjectCodeFixProvider.cs</File>
      <File>src/EditorFeatures/Core/Implementation/CodeFixes/CodeFixService.cs</File>
      <File>src/EditorFeatures/Core/Implementation/CodeFixes/ICodeFixService.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Suggestions/SuggestedActionsSourceProvider.cs</File>
      <File>src/Features/Core/Portable/CodeFixes/AddImport/AbstractAddImportCodeFixProvider.SymbolReference.cs</File>
      <File>src/Features/Core/Portable/CodeFixes/AddImport/AbstractAddImportCodeFixProvider.cs</File>
      <File>src/Features/Core/Portable/CodeRefactorings/CodeRefactoring.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/VisualStudioWorkspaceImpl.cs</File>
      <File>src/Workspaces/Core/Portable/CodeActions/CodeAction.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/Workspace.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>8184</IssueID>
    <Title>Bug Fix 5607: VB Parenthesis overtyping</Title>
    <Description>Fixes #5607

The bug was that automatic brace completion will not overtype close
parenthesis if the close parenthesis token was preceded by a numeric
literal. The bug was in `IsEntirelyWithinStringOrCharOrNumericLiteral`,
where we were imposing checks meant for chars and strings on numeric
literals, which was likely introduced in PR #1763. This change addresses
it by not enforcing checks meant for chars/strings on numeric literals.
</Description>
    <CreatedDate>26/01/2016</CreatedDate>
    <ClosedDate>26/01/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>5607</IssueID>
        <Title>VB "match closing parenthesis" fails for some constructs (works for others)</Title>
        <Description>![matchclosingparenthesis](https://cloud.githubusercontent.com/assets/3316258/10220871/76d1e1e6-6818-11e5-86e8-cb7359d407af.gif)

Here's a minimal video repro. In all three lines I'm typing the closing parenthesis `)` rather than cursoring-right over it. Observe that "match closing parenthesis" feature works fine when I write the generic type, and when I write console.writeline, but it fails on list.RemoveAt.

I've noticed this failure a lot in my day-to-day coding. I haven't figured out which things work and which don't.
</Description>
        <CreatedDate>01/10/2015</CreatedDate>
        <ClosedDate>26/01/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>1763</IssueID>
        <Title>Don't trigger completion within numeric literals</Title>
        <Description>Or, in VB, date literals. Fixes #1736 

May be interested: @brettfo @jasonmalinowski @Pilchie @dpoeschl @basoundr @balajikris 
</Description>
        <CreatedDate>02/04/2015</CreatedDate>
        <ClosedDate>03/04/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/Test/AutomaticCompletion/AbstractAutomaticBraceCompletionTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>8102</IssueID>
    <Title>made diagnostic tags to be removed faster and inserted slower.</Title>
    <Description>experience seems actually quite better than before.

anyway, 2 main changes are
1. active file analysis delay got shorten to 400ms from 800ms.
2. notification to editor on removed tags are now 50ms but added tags are now 1.5 seconds.

...

more detail explanations below

for #1. the delay change is only for 1 file (a file that has focus). all other file analysis delay is same as before (1.5 seconds). so I believe perf impact due to this should be fairly small. and it is still better than RTM which was 200ms. also, after RTM, we already made LB behavior not to be affected by this delay. so this change shouldn't affect LB behavior.

for #2. tagger actually has many small delays in them.
2 main ones are

1) delay to produce tags
2) delay to notify editor about changed tags.

1) is to reduce doing repeated works to generate tags. for diagnostic tagger, this actually is not needed since unlike any other tagger, diagnostic tagger uses external service (diagnostic service) which already does all these things (basically #1 delay is logically doing what 1) is trying to do)

now 1) delay is set to NearImmediate (50ms)

2) is to prevent us from abusing editors too much with a lot of notifications. basically this delay make sure we only ping editor once in a while (used to be 50ms) and aggregate events between them.

now, 2) is split into 2 different delays. one for adding new tags and the other for removing old tags.

adding new tags is now set to 1.5 seconds and removing old tags is set to 50ms.
</Description>
    <CreatedDate>22/01/2016</CreatedDate>
    <ClosedDate>25/01/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>1</IssueID>
        <Title>Initial port and addition of README.md</Title>
        <Description>This is a port of the readme from CodePlex.  Some of the links have been updated to point to locations on GitHub, but many of the links still point back to CodePlex as comparable GitHub locations are currently absent.
</Description>
        <CreatedDate>14/01/2015</CreatedDate>
        <ClosedDate>14/01/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>2</IssueID>
        <Title>Update links in README.md with ported wiki content</Title>
        <Description>
        </Description>
        <CreatedDate>14/01/2015</CreatedDate>
        <ClosedDate>14/01/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>1</IssueID>
        <Title>Initial port and addition of README.md</Title>
        <Description>This is a port of the readme from CodePlex.  Some of the links have been updated to point to locations on GitHub, but many of the links still point back to CodePlex as comparable GitHub locations are currently absent.
</Description>
        <CreatedDate>14/01/2015</CreatedDate>
        <ClosedDate>14/01/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/Core/Implementation/Classification/SyntacticClassificationTaggerProvider.Tagger.cs</File>
      <File>src/EditorFeatures/Core/Implementation/Diagnostics/AbstractDiagnosticsTaggerProvider.TaggerProvider.cs</File>
      <File>src/EditorFeatures/Core/Tagging/AbstractAsynchronousTaggerProvider.TagSource.cs</File>
      <File>src/EditorFeatures/Core/Tagging/AbstractAsynchronousTaggerProvider.TagSource_ProduceTags.cs</File>
      <File>src/EditorFeatures/Core/Tagging/AbstractAsynchronousTaggerProvider.Tagger.cs</File>
      <File>src/EditorFeatures/Core/Tagging/AbstractAsynchronousTaggerProvider.cs</File>
      <File>src/Features/Core/Portable/SolutionCrawler/InternalSolutionCrawlerOptions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>8027</IssueID>
    <Title>Disallow TypeSpec after CLASS and VALUETYPE in signatures</Title>
    <Description>Addresses issue #7970. This change makes the compiler behave the same as native csc.

Also adds a test for issue #7971.
</Description>
    <CreatedDate>19/01/2016</CreatedDate>
    <ClosedDate>21/01/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>7970</IssueID>
        <Title>Referencing assembly with improper use of TypeSpec compiles but does not run</Title>
        <Description>There is an issue in the ECMA-335 CLI specification where it is implied that `(CLASS | VALUETYPE)` can be followed by a `TypeSpec` token, when in fact only `TypeRef` and `TypeDef` are valid. When referencing a bad assembly that has such a signature, Roslyn recurses into the `TypeSpec`. It then emits the signature in the proper way, with the `TypeSpec` contents embedded into the `MemberRef` signature, but the call cannot bind to the bad method at runtime.

I have started to document such spec issues in https://github.com/dotnet/corefx/pull/5435 and I'm now filing the bugs I found while experimenting to write that up.

Native csc.exe produced an error at compilation time.
# Repro steps
- git clone https://github.com/nguerrera/signature-repros
- cd signature-repros
- build.bat
- csc.exe UseTypeSpecInWrongPlace.cs /r:TypeSpecInWrongPlace.exe
- UseTypeSpecInWrongPlace.exe
# Expected result

Compilation fails with suitable error message.
# Actual result
## Roslyn
- compilation succeeds without warnings
- run fails

```
System.MissingMethodException: Method not found:  
    'Void User.X(System.Collections.Generic.List`1&lt;Int32&gt;)'.
```
## Native csc
- compilation fails as expected:

```
UseTypeSpecInWrongPlace.cs(19,9): error CS0570: 'X' is not supported by the language
```

cc @tmat @gafter @AlekseyTs 
</Description>
        <CreatedDate>14/01/2016</CreatedDate>
        <ClosedDate>01/02/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>7971</IssueID>
        <Title>Invalid cyclical TypeSpec in referenced assembly causes stack overflow</Title>
        <Description>Although the EMCA-335 CLI specification does not permit `TypeSpec` tokens as modifiers, they are allowed in practice by ilasm, peverify, the CLR, and Roslyn. However, they open up the possibility of circular signatures, and the compiler hits a stack overflow while trying to decode one.

I have started to document such spec issues in https://github.com/dotnet/corefx/pull/5435 and I'm now filing the bugs I found while experimenting to write that up.

Native csc.exe had the same problem.
# Repro steps
- git clone https://github.com/nguerrera/signature-repros
- cd signature-repros
- build.bat
- csc.exe UseSignatureCycle2.cs /r:SignatureCycle2.exe
# Expected result
-  Compilation fails with suitable error message.
# Actual result
- Stack overflow

cc @tmat @gafter @AlekseyTs 
</Description>
        <CreatedDate>14/01/2016</CreatedDate>
        <ClosedDate>
        </ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/Metadata/PE/LoadingMethods.cs</File>
      <File>src/Compilers/Core/Portable/MetadataReader/MetadataDecoder.cs</File>
      <File>src/Compilers/Test/Resources/Core/TestResources.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>7986</IssueID>
    <Title>Use Enumerable.Repeat and code cleanup</Title>
    <Description>I try again :)

Fixes #5080 

Did some code cleanup too with C#6 goodies :)
</Description>
    <CreatedDate>15/01/2016</CreatedDate>
    <ClosedDate>15/01/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>5080</IssueID>
        <Title>Consider if it is appropriate to use Enumerable.Repeat to implement DefaultLowerBounds function in src/Compilers/CSharp/Portable/Emitter/Model/ArrayTypeSymbolAdapter.cs</Title>
        <Description>In code review for PR #5060 @gafter asked if we should use `Enumerable.Repeat` to implement DefaultLowerBounds, which is currently implemented as follows:

```
private static IEnumerable&lt;int&gt; DefaultLowerBounds(int rank)
{
    for (int i = 0; i &lt; rank; ++i)
        yield return 0;
}
```
</Description>
        <CreatedDate>08/09/2015</CreatedDate>
        <ClosedDate>15/01/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>6</IssueID>
        <Title>Corrected documentation on FullSpan and Span</Title>
        <Description>As per the [Incorrect Docs on FullSpan/Span properties](http://roslyn.codeplex.com/workitem/260) issue, the documentation was reversed on a few of these pairs.

&lt;!---
@huboard:{"order":8.0}
--&gt;
</Description>
        <CreatedDate>15/01/2015</CreatedDate>
        <ClosedDate>09/02/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Emitter/Model/ArrayTypeSymbolAdapter.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>7981</IssueID>
    <Title>Improves location used for base interface errors when partial classes are used</Title>
    <Description>Fixes #7878 for interfaces

Continuation of #7947.

Notes:
- I removed `?? Location[0]` as `baseTypeLocation` will be non-null in the error cases.
</Description>
    <CreatedDate>15/01/2016</CreatedDate>
    <ClosedDate>16/01/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>7878</IssueID>
        <Title>Wrong source code location for CS0060 error</Title>
        <Description>```
internal class NV
{
}

public partial class C1
{
}

partial class C1 : NV
{
}
```

Produces error message like `x.cs(5,22): error CS0060: Inconsistent accessibility: base class 'NV' is less accessible than class 'C1'` but I'd expect the error row to be 9 not 5.
</Description>
        <CreatedDate>11/01/2016</CreatedDate>
        <ClosedDate>15/01/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>7947</IssueID>
        <Title>Improves location used for base class errors when partial classes are used</Title>
        <Description>Fixes #7878
</Description>
        <CreatedDate>14/01/2016</CreatedDate>
        <ClosedDate>15/01/2016</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceNamedTypeSymbol_Bases.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/Source/BaseClassTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>7837</IssueID>
    <Title>update auto-merge tool to support multiple repositories and options</Title>
    <Description>Update the merge tool to support various options at the command line to enable creating PRs for different repos.  Also includes the NuGet package Mono.Options to make command line parsing easier.

For test-only PRs created with this code see #7836 and dotnet/roslyn-internal#501.

FYI @dotnet/roslyn-infrastructure, specifically @amcasey, @davkean, @tannergooding, and @TyOverby.

Remaining work items:
- Auto-merge if there were no conflicts and all tests pass.
- List all files with merge conflicts and add a comment to the PR that those files need additional signoff.
</Description>
    <CreatedDate>07/01/2016</CreatedDate>
    <ClosedDate>09/01/2016</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>7836</IssueID>
        <Title>Merge master into future</Title>
        <Description>This is an automatically generated pull request from master into future.

@dotnet/roslyn-infrastructure:

``` bash
git remote add roslyn-bot-roslyn "https://github.com/roslyn-bot/roslyn.git"
git fetch roslyn-bot-roslyn
git checkout merge-master-into-future20160107-220205
git reset --hard upstream/future
git merge upstream/master
# Fix merge conflicts
git commit
git push roslyn-bot-roslyn merge-master-into-future20160107-220205 --force
```

Once the merge can be made and all the tests pass, you are free to merge the pull request.
</Description>
        <CreatedDate>07/01/2016</CreatedDate>
        <ClosedDate>07/01/2016</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>501</IssueID>
        <Title>Change version from rc1 to rc2. Fixes #432</Title>
        <Description>
        </Description>
        <CreatedDate>14/02/2015</CreatedDate>
        <ClosedDate>16/02/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Tools/Github/GitMergeBot/Mono.Options/Options.cs</File>
      <File>src/Tools/Github/GitMergeBot/Options.cs</File>
      <File>src/Tools/Github/GitMergeBot/Program.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>7401</IssueID>
    <Title>This change fixes a few issues for Operation analyzers in lDE live an…</Title>
    <Description>…alysis:
1. Ensure that CompilationWithAnalyzers processes symbol declared events for analyzers with just Operation actions (Fixes #7308)
2. Fix the InvalidOperationException from operation action reporting a diagnostic in live analysis (Fixes #7324)
3. Add telemetry for Operation action counts registered per-analyzer. This involves a public API change, basically extending the existing telemetry API for other action counts.
</Description>
    <CreatedDate>10/12/2015</CreatedDate>
    <ClosedDate>10/12/2015</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>7308</IssueID>
        <Title>Operation analyzers don't work for IDE live analysis</Title>
        <Description>For analyzer execution via `CompilationWithAnalyzers` (current IDE live analysis is the only consumer in Roslyn code base), we process each compilation event for every analyzer to see if it has relevant actions for the event, and if not bail out early. These checks haven't been updated with Operation actions, so we seem to not execute the operation actions during live analysis, but they work fine from unit tests and build. We need to modify the methods [here](http://source.roslyn.io/Microsoft.CodeAnalysis/R/25576833f10a2cd5.html) and [here](http://source.roslyn.io/Microsoft.CodeAnalysis/R/2b1f73681b8fa261.html) to account for newly added Operation actions, and also add unit tests for them.

/cc @JohnHamby 
</Description>
        <CreatedDate>07/12/2015</CreatedDate>
        <ClosedDate>10/12/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>7324</IssueID>
        <Title>InvalidOperationException when reporting a diagnostic on OperationAnalysisContext</Title>
        <Description>Running any Operation analyzer in live IDE analysis causing an exception with below call stack:

```
&gt;   Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Diagnostics.DiagnosticQueue.CategorizedDiagnosticQueue.Enqueue(Microsoft.CodeAnalysis.Diagnostic diagnostic) Line 111 C#
    Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.GetDiagnosticSink.AnonymousMethod__0(Microsoft.CodeAnalysis.Diagnostic diagnostic) Line 831    C#
    Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext.ReportDiagnostic(Microsoft.CodeAnalysis.Diagnostic diagnostic) Line 942  C#
    Microsoft.Maintainability.Analyzers.dll!Microsoft.Maintainability.Analyzers.DoNotIgnoreMethodResultsAnalyzer.Initialize.AnonymousMethod__2(Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext opContext) Line 123  C#
    Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.ExecuteOperationActionAsync.AnonymousMethod__1() Line 472    C#
    Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.ExecuteAndCatchIfThrows_NoLock(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer analyzer, System.Action analyze) Line 983   C#
    Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.ExecuteAndCatchIfThrowsAsync(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer analyzer, System.Action analyze) Line 964 C#
    Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.ExecuteOperationActionAsync(Microsoft.CodeAnalysis.Diagnostics.OperationAnalyzerAction operationAction, Microsoft.CodeAnalysis.Semantics.IOperation operation, System.Action&lt;Microsoft.CodeAnalysis.Diagnostic&gt; addDiagnostic, Microsoft.CodeAnalysis.Diagnostics.AnalysisState.OperationAnalyzerStateData analyzerStateOpt) Line 472    C#
    Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.ExecuteOperationActionsAsync(Microsoft.CodeAnalysis.Semantics.IOperation operation, System.Collections.Generic.IDictionary&lt;Microsoft.CodeAnalysis.Semantics.OperationKind, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Diagnostics.OperationAnalyzerAction&gt;&gt; operationActionsByKind, System.Action&lt;Microsoft.CodeAnalysis.Diagnostic&gt; addDiagnostic, Microsoft.CodeAnalysis.Diagnostics.AnalysisState.OperationAnalyzerStateData analyzerStateOpt) Line 931   C#
    Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.ExecuteOperationActionsAsync(System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.Semantics.IOperation&gt; operationsToAnalyze, System.Collections.Generic.IDictionary&lt;Microsoft.CodeAnalysis.Semantics.OperationKind, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Diagnostics.OperationAnalyzerAction&gt;&gt; operationActionsByKind, System.Action&lt;Microsoft.CodeAnalysis.Diagnostic&gt; addDiagnostic, Microsoft.CodeAnalysis.Diagnostics.AnalysisState.OperationAnalyzerStateData analyzerStateOpt) Line 915 C#
    Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.ExecuteBlockActionsCoreAsync&lt;Microsoft.CodeAnalysis.Diagnostics.OperationBlockStartAnalyzerAction, Microsoft.CodeAnalysis.Diagnostics.OperationBlockAnalyzerAction, Microsoft.CodeAnalysis.Diagnostics.OperationAnalyzerAction, Microsoft.CodeAnalysis.Diagnostics.AnalysisState.OperationAnalyzerStateData, Microsoft.CodeAnalysis.Semantics.IOperation, int&gt;(System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.Diagnostics.OperationBlockStartAnalyzerAction&gt; startActions, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.Diagnostics.OperationBlockAnalyzerAction&gt; actions, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.Diagnostics.OperationBlockAnalyzerAction&gt; endActions, Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer analyzer, Microsoft.CodeAnalysis.SyntaxNode declaredNode, Microsoft.CodeAnalysis.ISymbol declaredSymbol, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Semantics.IOperation&gt; executableBlocks, System.Func&lt;System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Semantics.IOperation&gt;, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.Semantics.IOperation&gt;&gt; getNodesToAnalyze, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Func&lt;Microsoft.CodeAnalysis.SyntaxNode, int&gt; getKind, Microsoft.CodeAnalysis.Diagnostics.AnalysisState.BlockAnalyzerStateData&lt;Microsoft.CodeAnalysis.Diagnostics.OperationBlockAnalyzerAction, Microsoft.CodeAnalysis.Diagnostics.AnalysisState.OperationAnalyzerStateData&gt; analyzerStateOpt) Line 661 C#
    Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.ExecuteOperationBlockActionsAsync(System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.Diagnostics.OperationBlockStartAnalyzerAction&gt; operationBlockStartActions, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.Diagnostics.OperationBlockAnalyzerAction&gt; operationBlockActions, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.Diagnostics.OperationBlockAnalyzerAction&gt; operationBlockEndActions, Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer analyzer, Microsoft.CodeAnalysis.SyntaxNode declaredNode, Microsoft.CodeAnalysis.ISymbol declaredSymbol, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Semantics.IOperation&gt; operationBlocks, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Semantics.IOperation&gt; operations, Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.SyntaxReference declaration, Microsoft.CodeAnalysis.Diagnostics.AnalysisScope analysisScope, Microsoft.CodeAnalysis.Diagnostics.AnalysisState analysisStateOpt) Line 532    C#
    Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver&lt;Microsoft.CodeAnalysis.CSharp.SyntaxKind&gt;.ExecuteDeclaringReferenceActionsAsync(Microsoft.CodeAnalysis.SyntaxReference decl, Microsoft.CodeAnalysis.Diagnostics.SymbolDeclaredCompilationEvent symbolEvent, Microsoft.CodeAnalysis.Diagnostics.AnalysisScope analysisScope, Microsoft.CodeAnalysis.Diagnostics.AnalysisState analysisStateOpt, bool shouldExecuteSyntaxNodeActions, bool shouldExecuteOperationActions, bool shouldExecuteCodeBlockActions, bool shouldExecuteOperationBlockActions, System.Threading.CancellationToken cancellationToken) Line 1381   C#
    Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver&lt;Microsoft.CodeAnalysis.CSharp.SyntaxKind&gt;.ExecuteDeclaringReferenceActionsAsync(Microsoft.CodeAnalysis.Diagnostics.SymbolDeclaredCompilationEvent symbolEvent, Microsoft.CodeAnalysis.Diagnostics.AnalysisScope analysisScope, Microsoft.CodeAnalysis.Diagnostics.AnalysisState analysisStateOpt, System.Threading.CancellationToken cancellationToken) Line 1176  C#
    Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.ProcessSymbolDeclaredAsync(Microsoft.CodeAnalysis.Diagnostics.SymbolDeclaredCompilationEvent symbolEvent, Microsoft.CodeAnalysis.Diagnostics.AnalysisScope analysisScope, Microsoft.CodeAnalysis.Diagnostics.AnalysisState analysisStateOpt, System.Threading.CancellationToken cancellationToken) Line 707    C#
    Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.ProcessEventCoreAsync(Microsoft.CodeAnalysis.Diagnostics.CompilationEvent e, Microsoft.CodeAnalysis.Diagnostics.AnalysisScope analysisScope, Microsoft.CodeAnalysis.Diagnostics.AnalysisState analysisStateOpt, System.Threading.CancellationToken cancellationToken) Line 665 C#
    Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.ProcessEventAsync(Microsoft.CodeAnalysis.Diagnostics.CompilationEvent e, Microsoft.CodeAnalysis.Diagnostics.AnalysisScope analysisScope, Microsoft.CodeAnalysis.Diagnostics.AnalysisState analysisStateOpt, System.Threading.CancellationToken cancellationToken) Line 650 C#
    Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.ProcessCompilationEventsCoreAsync(Microsoft.CodeAnalysis.Diagnostics.AnalysisScope analysisScope, Microsoft.CodeAnalysis.Diagnostics.AnalysisState analysisStateOpt, bool prePopulatedEventQueue, System.Threading.CancellationToken cancellationToken) Line 637   C#
    Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.ProcessCompilationEventsAsync(Microsoft.CodeAnalysis.Diagnostics.AnalysisScope analysisScope, Microsoft.CodeAnalysis.Diagnostics.AnalysisState analysisStateOpt, bool prePopulatedEventQueue, System.Threading.CancellationToken cancellationToken) Line 572   C#
    Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.ExecutePrimaryAnalysisTaskAsync(Microsoft.CodeAnalysis.Diagnostics.AnalysisScope analysisScope, Microsoft.CodeAnalysis.Diagnostics.AnalysisState analysisStateOpt, bool usingPrePopulatedEventQueue, System.Threading.CancellationToken cancellationToken) Line 282    C#
    Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.AttachQueueAndProcessAllEventsAsync(Microsoft.CodeAnalysis.Diagnostics.AsyncQueue&lt;Microsoft.CodeAnalysis.Diagnostics.CompilationEvent&gt; eventQueue, Microsoft.CodeAnalysis.Diagnostics.AnalysisScope analysisScope, Microsoft.CodeAnalysis.Diagnostics.AnalysisState analysisStateOpt, System.Threading.CancellationToken cancellationToken) Line 211   C#
    Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.ComputeAnalyzerDiagnosticsCoreAsync(Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver driver, Microsoft.CodeAnalysis.Diagnostics.AsyncQueue&lt;Microsoft.CodeAnalysis.Diagnostics.CompilationEvent&gt; eventQueue, Microsoft.CodeAnalysis.Diagnostics.AnalysisScope analysisScope, System.Threading.CancellationToken cancellationToken) Line 681  C#
    Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.ComputeAnalyzerDiagnosticsAsync.AnonymousMethod__1() Line 560    C#
    mscorlib.dll!System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;.InnerInvoke() Unknown
    mscorlib.dll!System.Threading.Tasks.Task.Execute()  Unknown
    mscorlib.dll!System.Threading.Tasks.Task.ExecutionContextCallback(object obj)   Unknown
    mscorlib.dll!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state, bool preserveSyncCtx)   Unknown
    mscorlib.dll!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state, bool preserveSyncCtx)   Unknown
    mscorlib.dll!System.Threading.Tasks.Task.ExecuteWithThreadLocal(ref System.Threading.Tasks.Task currentTaskSlot)    Unknown
    mscorlib.dll!System.Threading.Tasks.Task.ExecuteEntry(bool bPreventDoubleExecution) Unknown
    mscorlib.dll!System.Threading.Tasks.Task.System.Threading.IThreadPoolWorkItem.ExecuteWorkItem() Unknown
    mscorlib.dll!System.Threading.ThreadPoolWorkQueue.Dispatch()    Unknown
    mscorlib.dll!System.Threading._ThreadPoolWaitCallback.PerformWaitCallback() Unknown
```

We need to change [this](http://source.roslyn.io/#Microsoft.CodeAnalysis/DiagnosticAnalyzer/AnalyzerExecutor.cs,471) line to pass the `addDiagnostic` parameter instead of `_addDiagnostic` field - the parameter is basically the correct addDiagnostic delegate for IDE and compiler context (points to [_addLocalDiagnosticOpt](http://source.roslyn.io/#Microsoft.CodeAnalysis/DiagnosticAnalyzer/AnalyzerExecutor.cs,37) or [_addNonLocalDiagnosticOpt](http://source.roslyn.io/#Microsoft.CodeAnalysis/DiagnosticAnalyzer/AnalyzerExecutor.cs,38) for execution via CompilationWithAnayzers and points to [_addDiagnostic](http://source.roslyn.io/#Microsoft.CodeAnalysis/DiagnosticAnalyzer/AnalyzerExecutor.cs,36) for execution without categorized local/non-local diagnostics, i.e. batch build.

We may also want to clean up the AnalyzerExecutor to prevent such cases in future.
</Description>
        <CreatedDate>08/12/2015</CreatedDate>
        <ClosedDate>10/12/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/Core/Portable/DiagnosticAnalyzer/AnalysisState.PerAnalyzerState.cs</File>
      <File>src/Compilers/Core/Portable/DiagnosticAnalyzer/AnalysisState.cs</File>
      <File>src/Compilers/Core/Portable/DiagnosticAnalyzer/AnalyzerActionCounts.cs</File>
      <File>src/Compilers/Core/Portable/DiagnosticAnalyzer/AnalyzerDriver.cs</File>
      <File>src/Compilers/Core/Portable/DiagnosticAnalyzer/AnalyzerExecutor.cs</File>
      <File>src/Compilers/Core/Portable/DiagnosticAnalyzer/AnalyzerTelemetry.cs</File>
      <File>src/Compilers/Core/Portable/DiagnosticAnalyzer/DiagnosticStartAnalysisScope.cs</File>
      <File>src/Features/Core/Portable/Diagnostics/Log/DiagnosticLogAggregator.cs</File>
      <File>src/Test/Utilities/Desktop/CommonDiagnosticAnalyzers.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>7212</IssueID>
    <Title>Ensure that an EnvDTE.CodeParameter.Name returns the correct value for parameters defined in metadata</Title>
    <Description>Fixes #7210

The issue is that the symbol display system will not return a name for a parameter unless SymbolDisplayParameterOptions.IncludeName is set. This behavior seems like it might ultimately be a bug in symbol display as that option is intended to control the display the parameters owned by the targeted symbol, but probably shouldn't affect the display of the targeted symbol. However, rather than updating symbol display (which would potentially have larger downstream impact), we'll just include the option in this case.
#7211 has been filed for the symbol display issue.

Tagging @dotnet/roslyn-ide for review
</Description>
    <CreatedDate>03/12/2015</CreatedDate>
    <ClosedDate>04/12/2015</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>7210</IssueID>
        <Title>Code Model: CodeParameter2 in DTE code model has no value for Name after Update 1</Title>
        <Description>This appears to have regressed in Update 1.
</Description>
        <CreatedDate>03/12/2015</CreatedDate>
        <ClosedDate>04/12/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>7211</IssueID>
        <Title>Symbol Display does not display the name for a parameter symbol unless SymbolDisplayParameterOptions.IncludeName is specified</Title>
        <Description>From the title, it might initially seem like the behavior is correct, but it's actually a misuse of the `SymbolDisplayParameterOptions`. Consider the following code:

``` C#
class C
{
    void M(int p) { }
}
```

Given the parameter symbol, `p`, calling `ToDisplayString()` will return the following:

```
"int"
```

This is especially bizarre because `SymbolDisplayParameterOptions.IncludeType` is _not_ specified by default.

By default, `SymbolDisplayTypeQualificationStyle.NameOnly` is specified, which should affect the symbol that that `ToDisplayString()` is being called for. `SymbolDisplayParameterOptions` should control the display of any parameters owned by that symbol, not the symbol itself if it happens to be a parameter.
</Description>
        <CreatedDate>03/12/2015</CreatedDate>
        <ClosedDate>04/12/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/VisualStudio/CSharp/Impl/CodeModel/CSharpCodeModelService.cs</File>
      <File>src/VisualStudio/Core/Impl/CodeModel/ExternalElements/ExternalCodeParameter.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>7187</IssueID>
    <Title>Fix test issues</Title>
    <Description>This fixes as couple of test issues:
- CultureAttributeMismatch: this was a flaky suite whose flakiness was
  fixed via the PEVerify changes.  The hardened rules revealed the suite
  was setup to consistently fail verification because it didn't fully load
  it's dependencies into the Compilation object.  This behavior is
  actually expected, we want to get the compiler errors that result from
  such a compilation.  Hence we disable verification in those cases.
- Return07_2: This was directly fixed by the PEVerify hardenning.

closes #4300
closes #5866
</Description>
    <CreatedDate>02/12/2015</CreatedDate>
    <ClosedDate>02/12/2015</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>4300</IssueID>
        <Title>Fix flaky suite CodeGenAsyncTests.Return07_2</Title>
        <Description>The Return07_2 test is periodically failing with the below stack trace.  Need to fix the flaky behavior and re-enable the suite:

```
Microsoft.CodeAnalysis.CSharp.UnitTests.CodeGen.CodeGenAsyncTests.Return07_2 : Microsoft.CodeAnalysis.Test.Utilities.ExecutionException : Execution failed for assembly 'C:\Users\acasey\AppData\Local\Temp\RoslynTestFailureDump\de5c3197-023b-4a93-af6d-6f556d27c828'. Exception: System.AccessViolationException: Attempted to read or write protected memory. This is often an indication that other memory is corrupt. at TestCase.&lt;&gt;c__DisplayClass6.&lt;&lt;Run&gt;b__9&gt;d__0.MoveNext() at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.Start[TStateMachine](TStateMachine&amp; stateMachine) at TestCase.&lt;&gt;c__DisplayClass6.&lt;Run&gt;b__9() at TestCase.&lt;Run&gt;d__1.MoveNext() at System.Runtime.CompilerServices.AsyncVoidMethodBuilder.Start[TStateMachine](TStateMachine&amp; stateMachine) at TestCase.Run() at Driver.Main() ---- System.AccessViolationException : Attempted to read or write protected memory. This is often an indication that other memory is corrupt.
   at Microsoft.CodeAnalysis.Test.Utilities.HostedRuntimeEnvironment.Execute(String moduleName, Int32 expectedOutputLength, String&amp; processOutput) in F:\Enlistments\Roslyn1\Open\Test\Utilities\HostedRuntimeEnvironment.cs:line 257
   at Microsoft.CodeAnalysis.Test.Utilities.HostedRuntimeEnvironment.Execute(String moduleName, String expectedOutput) in F:\Enlistments\Roslyn1\Open\Test\Utilities\HostedRuntimeEnvironment.cs:line 264
   at Microsoft.CodeAnalysis.Test.Utilities.CommonTestBase.CompilationVerifier.Emit(String expectedOutput, IEnumerable`1 manifestResources, Boolean peVerify, SignatureDescription[] expectedSignatures) in F:\Enlistments\Roslyn1\Open\Test\Utilities\CommonTestBase.CompilationVerifier.cs:line 114
   at Microsoft.CodeAnalysis.Test.Utilities.CommonTestBase.Emit(CommonTestBase test, Compilation compilation, IEnumerable`1 dependencies, TestEmitters emitOptions, IEnumerable`1 manifestResources, SignatureDescription[] expectedSignatures, String expectedOutput, Action`2 assemblyValidator, Action`2 symbolValidator, Boolean collectEmittedAssembly, Boolean verify) in F:\Enlistments\Roslyn1\Open\Test\Utilities\CommonTestBase.cs:line 400
   at Microsoft.CodeAnalysis.Test.Utilities.CommonTestBase.CompileAndVerify(Compilation compilation, IEnumerable`1 manifestResources, IEnumerable`1 dependencies, TestEmitters emitOptions, Action`2 sourceSymbolValidator, Action`2 assemblyValidator, Action`2 symbolValidator, SignatureDescription[] expectedSignatures, String expectedOutput, Boolean collectEmittedAssembly, Boolean verify) in F:\Enlistments\Roslyn1\Open\Test\Utilities\CommonTestBase.cs:line 202
   at Microsoft.CodeAnalysis.CSharp.Test.Utilities.CSharpTestBase.CompileAndVerify(Compilation compilation, IEnumerable`1 manifestResources, IEnumerable`1 dependencies, TestEmitters emitOptions, Action`1 sourceSymbolValidator, Action`2 validator, Action`1 symbolValidator, SignatureDescription[] expectedSignatures, String expectedOutput, Boolean collectEmittedAssembly, Boolean verify) in F:\Enlistments\Roslyn1\Open\Compilers\Test\Utilities\CSharp\CSharpTestBase.cs:line 165
   at Microsoft.CodeAnalysis.CSharp.UnitTests.CodeGen.CodeGenAsyncTests.CompileAndVerify(String source, String expectedOutput, IEnumerable`1 references, TestEmitters emitOptions, CSharpCompilationOptions compOptions) in F:\Enlistments\Roslyn1\Open\Compilers\CSharp\Test\Emit\CodeGen\CodeGenAsyncTests.cs:line 35
   at Microsoft.CodeAnalysis.CSharp.UnitTests.CodeGen.CodeGenAsyncTests.Return07_2() in F:\Enlistments\Roslyn1\Open\Compilers\CSharp\Test\Emit\CodeGen\CodeGenAsyncTests.cs:line 1984
----- Inner Stack Trace -----
   at TestCase.&lt;&gt;c__DisplayClass6.&lt;&lt;Run&gt;b__9&gt;d__0.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.Start[TStateMachine](TStateMachine&amp; stateMachine)
   at TestCase.&lt;&gt;c__DisplayClass6.&lt;Run&gt;b__9()
   at TestCase.&lt;Run&gt;d__1.MoveNext()
   at System.Runtime.CompilerServices.AsyncVoidMethodBuilder.Start[TStateMachine](TStateMachine&amp; stateMachine)
   at TestCase.Run()
   at Driver.Main()
```
</Description>
        <CreatedDate>03/08/2015</CreatedDate>
        <ClosedDate>02/12/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>5866</IssueID>
        <Title>CultureAttributeMismatch failing intermittently </Title>
        <Description>This suites is failing intermittently during runs.  Disabling until we can track down the issue.

```
at Microsoft.CodeAnalysis.Test.Utilities.RuntimeAssemblyManager.PeVerifyModules(String[] modulesToVerify, Boolean throwOnError) in d:\j\workspace\roslyn_prtest_win_dbg_unit32\src\Test\Utilities\Desktop\HostedRuntimeEnvironment.cs:line 812 
at Microsoft.CodeAnalysis.Test.Utilities.RuntimeAssemblyManager.PeVerifyModules(String[] modulesToVerify, Boolean throwOnError) 
at Microsoft.CodeAnalysis.Test.Utilities.HostedRuntimeEnvironment.PeVerify() in d:\j\workspace\roslyn_prtest_win_dbg_unit32\src\Test\Utilities\Desktop\HostedRuntimeEnvironment.cs:line 365 
at Microsoft.CodeAnalysis.Test.Utilities.CommonTestBase.CompilationVerifier.Emit(String expectedOutput, IEnumerable`1 manifestResources, Boolean peVerify, SignatureDescription[] expectedSignatures) in d:\j\workspace\roslyn_prtest_win_dbg_unit32\src\Test\Utilities\Desktop\CommonTestBase.CompilationVerifier.cs:line 104 
at Microsoft.CodeAnalysis.Test.Utilities.CommonTestBase.Emit(Compilation compilation, IEnumerable`1 dependencies, IEnumerable`1 manifestResources, SignatureDescription[] expectedSignatures, String expectedOutput, Action`1 assemblyValidator, Action`1 symbolValidator, Boolean verify) in d:\j\workspace\roslyn_prtest_win_dbg_unit32\src\Test\Utilities\Desktop\CommonTestBase.cs:line 204 at Microsoft.CodeAnalysis.Test.Utilities.CommonTestBase.CompileAndVerify(Compilation compilation, IEnumerable`1 manifestResources, IEnumerable`1 dependencies, Action`1 sourceSymbolValidator, Action`1 assemblyValidator, Action`1 symbolValidator, SignatureDescription[] expectedSignatures, String expectedOutput, Boolean verify) in d:\j\workspace\roslyn_prtest_win_dbg_unit32\src\Test\Utilities\Desktop\CommonTestBase.cs:line 129 
at Microsoft.CodeAnalysis.VisualBasic.UnitTests.BasicTestBase.CompileAndVerify(Compilation compilation, IEnumerable`1 manifestResources, IEnumerable`1 dependencies, Action`1 sourceSymbolValidator, Action`1 validator, Action`1 symbolValidator, SignatureDescription[] expectedSignatures, String expectedOutput, Boolean verify) in d:\j\workspace\roslyn_prtest_win_dbg_unit32\src\Compilers\Test\Utilities\VisualBasic\BasicTestBase.vb:line 77 
at AssemblyAttributeTests.CultureAttributeMismatch() in d:\j\workspace\roslyn_prtest_win_dbg_unit32\src\Compilers\VisualBasic\Test\Emit\Attributes\AssemblyAttributes.vb:line 455
```
</Description>
        <CreatedDate>11/10/2015</CreatedDate>
        <ClosedDate>02/12/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Test/Emit/Attributes/AttributeTests_Assembly.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenAsyncTests.cs</File>
      <File>src/Test/Utilities/Desktop/HostedRuntimeEnvironment.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>7161</IssueID>
    <Title>Revert test workaround for 64bit execution of TestAnalyzerLoading_Error</Title>
    <Description>See workaround added in #4960.
Test is now being executed only in 32bit.

Fixes #4959
</Description>
    <CreatedDate>01/12/2015</CreatedDate>
    <ClosedDate>04/12/2015</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>4960</IssueID>
        <Title>work around a bug when running an analyzer test in 64-bit</Title>
        <Description>This PR is to work around #4959 so we can have a passing 64-bit test run until the bug can be properly addressed.

FYI @amcasey @tannergooding
</Description>
        <CreatedDate>02/09/2015</CreatedDate>
        <ClosedDate>02/09/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>4959</IssueID>
        <Title>Analyzer test tries to load xUnit into app domain when executed in 64 bit.</Title>
        <Description>The unit test [`Microsoft.CodeAnalysis.UnitTests.AnalyzerFileReferenceTests.TestAnalyzerLoading_Error()`](http://source.roslyn.io/#Roslyn.Compilers.UnitTests/AnalyzerFileReferenceTests.cs,b04fd584904390af) fails in 64 bit because the assembly `xunit.dll` cannot be found.  The failing test is identical to [`TestAnalyzerLoading()`](http://source.roslyn.io/#Roslyn.Compilers.UnitTests/AnalyzerFileReferenceTests.cs,196491df9b713bdb) which passes except for the different calls to `TestSuccess()` vs. `TestTypeLoadException()` which in turn both subscribe to the `AnalyzerFileReference.AnalyzerLoadFailed` event.  In the `TestSuccess()` case [here](http://source.roslyn.io/#Roslyn.Compilers.UnitTests/AnalyzerFileReferenceTests.cs,67), the event is never fired when the test behaves as expected, but in `TestTypeLoadException()` [here](http://source.roslyn.io/#Roslyn.Compilers.UnitTests/AnalyzerFileReferenceTests.cs,67), the event **is** fired when the test behaves as expected, and the current theory is that the 64 bit app domain isn't using the [`RemoteAssert`](http://source.roslyn.io/#Roslyn.Compilers.UnitTests/AnalyzerFileReferenceTests.cs,c835ffe2520b5e62) object from the first app domain (which eventually calls `Assert.True()` in `xunit.dll`), but is instead loading its own causing the attempted load of `xunit.dll`.

FYI @amcasey @tannergooding
</Description>
        <CreatedDate>02/09/2015</CreatedDate>
        <ClosedDate>04/12/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/Core/CodeAnalysisTest/AnalyzerFileReferenceTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>7146</IssueID>
    <Title>Fixes CS7038 when calling methods expecting ref/out delegate argument</Title>
    <Description>Fixes #7089.

In the legacy compiler, the following is reported

```
error CS1660: Cannot convert lambda expression to type 'ref System.Func&lt;string,string&gt;' because it is not a delegate type
```

That seems a bit confusing.
I have changed it to

```
error CS1503: Argument 1: cannot convert from 'lambda expression' to 'ref Func&lt;string, string&gt;'
```

Should I stick to the original error?

Related: #7047
</Description>
    <CreatedDate>01/12/2015</CreatedDate>
    <ClosedDate>08/12/2015</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>7089</IssueID>
        <Title>CS7038: Calling methods expecting ref/out delegate argument</Title>
        <Description>```
using System;
class p
{
    static void Foo&lt;T&gt;(ref Func&lt;T,T&gt; a) { }
    static void Bar&lt;T&gt;(out Func&lt;T, T&gt; a) { a = null; }
    static void Main()
    {
        Foo&lt;string&gt;(x =&gt; x);
        Bar&lt;string&gt;(x =&gt; x);
    }
}
```

Error (either case/both):

```
error CS7038: Failed to emit module '&lt;module-name&gt;'
```

Related: #6236
</Description>
        <CreatedDate>26/11/2015</CreatedDate>
        <ClosedDate>08/12/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>7047</IssueID>
        <Title>Do not allow any form of inline lambda to be ref/out</Title>
        <Description>Fixes #6646. Specifically for `new Action&lt;string&gt;(ref b =&gt; b = "hello")` that is not for compat with legacy compiler. The case is handled correctly for strict mode. `new Action&lt;string&gt;(ref Foo)` is valid for compat.

Added tests for both compat and strict mode.

Side-note: Many tests missing for this. There are probably more syntax kinds not allowed. 
</Description>
        <CreatedDate>25/11/2015</CreatedDate>
        <ClosedDate>04/12/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/OverloadResolution/OverloadResolutionResult.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/OverloadResolutionTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>7028</IssueID>
    <Title>Fix handling of abstract/virtual in structs</Title>
    <Description>Fixes #6590 and #7026
</Description>
    <CreatedDate>25/11/2015</CreatedDate>
    <ClosedDate>02/12/2015</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>6590</IssueID>
        <Title>C# compiler erroneously allows declarations of abstract members in a struct</Title>
        <Description>The following code compiles, but should  not:

```
struct Foo
{
    public abstract void Bar();
}

new Foo().Bar() //TypeLoadException at runtime: 'Abstract method in non-abstract class.'
```
</Description>
        <CreatedDate>05/11/2015</CreatedDate>
        <ClosedDate>02/12/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>7026</IssueID>
        <Title>Incorrect error message for virtual method/property/event in struct</Title>
        <Description>```
struct Foo {
    public virtual void Baz() { }
}
error CS0549: 'Foo.Baz()' is a new virtual member in sealed class 'Foo'
```

Should be:

```
error CS0106: The modifier 'virtual' is not valid for this item
```

Related: #6590
</Description>
        <CreatedDate>25/11/2015</CreatedDate>
        <ClosedDate>05/12/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceEventSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourceMemberMethodSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourcePropertyAccessorSymbol.cs</File>
      <File>src/Compilers/CSharp/Portable/Symbols/Source/SourcePropertySymbol.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/SymbolErrorTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>6701</IssueID>
    <Title>Adjust ErrorLogger to conform to current SARIF draft </Title>
    <Description>- Add doc about log format
- Change structure from:

```
   {
      "version": &lt;version&gt;,
      "toolInfo": &lt;toolInfo&gt;,
      "issues": [ &lt;issue&gt;* ]
   }
```

to:

```
    {
      "version": &lt;version&gt;,
      "runLogs": [
        {
          "toolInfo": &lt;toolInfo&gt;,
           "issues": [ &lt;issue&gt;* ]
        }
      ]
    }
```
- Flatten custom properties to conform to requirement for all issue
  property values to be strings:

```
   "customProperties": { "a": "b", "c": "d" }
-&gt; "customProperties.a": "b", "customProperties.c": "d"
```
- Rename toolName -&gt; name
- Rename productVersion -&gt; version
- Let original fileVersion through without trimming off 4th part
- Use actual URI syntax for "uri" elements
- Make region start/end line/column 1-based

cc @mavasani @srivatsn @lgolding @michaelcfanning 

Fix #3670 
Fix #5752

(Side note: I've made the changes as minimally as possible. Separately, I think there could be significant benefit to the following refactoring, but didn't want to mix it with the functional change here:
1. Split out a separate, forward-only internal JsonWriter from ErrorLogger
2. Write everything out directly via (1) without intermediate Issue, Value, ImmutableArray objects

I could look at doing that as a follow-up if you'd like and agree it would be valuable.)
</Description>
    <CreatedDate>10/11/2015</CreatedDate>
    <ClosedDate>12/11/2015</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>3670</IssueID>
        <Title>Document /errorlog file format</Title>
        <Description>The csc and vbc command lines now include an /errorlog option for specifying a file to which diagnostic information is written. The output format is some kind of json.

Please document the precise format of this file. I suggest adding the documentation to `docs/compilers` in markdown format.
</Description>
        <CreatedDate>24/06/2015</CreatedDate>
        <ClosedDate>12/11/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>5752</IssueID>
        <Title>SARIF output contains a sub-object within properties</Title>
        <Description>The Roslyn compiler produces SARIF output as follows:

```
      "ruleId": "CC0057",
      "locations": [
        {
          "analysisTarget": [
            {
              "uri": "c:\Users\sschen\Documents\Visual Studio 2015\Projects\DemoSolution\AliceProject\Program.cs",
              "region": {
                "startLine": 10,
                "startColumn": 25,
                "endLine": 10,
                "endColumn": 38
              }
            }
          ]
        }
      ],
      "shortMessage": "Parameter 'args' is not used.",
      "fullMessage": "When a method declares a parameter and does not use it might bring incorrect conclusions for anyone reading the code and also demands the parameter when the method is called, unnecessarily.
You should delete the parameter in such cases.",
      "properties": {
        "severity": "Warning",
        "warningLevel": "1",
        "defaultSeverity": "Warning",
        "title": "Unused parameters",
        "category": "Usage",
        "helpLink": "https://code-cracker.github.io/diagnostics/CC0057.html",
        "isEnabledByDefault": "True",
        "customTags": "Unnecessary",
        "customProperties": {
          "identifier": "args"
        }
      }
    },

```

Note that the `properties` property has a sub-property name `customProperties`, whose value is a JSON object, rather than a string as required by the spec.

If necessary, you could "namespace" this, for example:

```
    "customProperties.identifier": "args"
```
</Description>
        <CreatedDate>07/10/2015</CreatedDate>
        <ClosedDate>12/11/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Test/CommandLine/ErrorLoggerTests.cs</File>
      <File>src/Compilers/Core/Portable/CommandLine/ErrorLogger.WellKnownStrings.cs</File>
      <File>src/Compilers/Core/Portable/CommandLine/ErrorLogger.cs</File>
      <File>src/Test/Utilities/Desktop/CommonDiagnosticAnalyzers.cs</File>
      <File>src/Test/Utilities/Shared/Diagnostics/DiagnosticExtensions.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>6513</IssueID>
    <Title>csi: Update ScriptOptions with the latest values of current dir, search paths</Title>
    <Description>Note this change is built on top of #6458. Only the last commit is actually relevant to this feature.

Fixes #6469.
</Description>
    <CreatedDate>02/11/2015</CreatedDate>
    <ClosedDate>02/11/2015</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>6458</IssueID>
        <Title>Inherit references from previous submissions</Title>
        <Description>Moves the logic of reusing metadata references from Script down to ReferenceManager. This is necessary to avoid duplication of PE assembly symbols due to repeatedly resolved missing references. 

The metadata resolver creates a new reference whenever asked to resolve a missing assembly identity. That results in creating new PE assembly symbol. We could implement deduplication in the resolver. However the lifetime of the resolver isn't necessarily related to the lifetime of the interactive session. hence it is better to implement it in the ReferenceManager. This work item was previously suggested for U1 but postponed for U2 (#5301) since the thinking was that it only affects performance. However, as described in #6457 it is critical for correctness of basic scenarios in csi and Hosting APIs, which don't use shadow copying.

Also fixes #6474.
</Description>
        <CreatedDate>30/10/2015</CreatedDate>
        <ClosedDate>02/11/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>6469</IssueID>
        <Title>csi: Changing the current directory doesn't affect reference/source search paths </Title>
        <Description>The current directory at the time #r is evaluated should be used to look up references.

```
&gt; Directory.SetCurrentDirectory(@"C:\library")
&gt; #r "a.dll"
(1,1): error CS0006: Metadata file 'a.dll' could not be found
```

Currently the current directory at the time the first submission is created is used.

BTW, works in VS REPL.
</Description>
        <CreatedDate>30/10/2015</CreatedDate>
        <ClosedDate>03/11/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Symbols/ReferenceManager.cs</File>
      <File>src/Compilers/CSharp/Test/CommandLine/CommandLineScriptTests.cs</File>
      <File>src/Compilers/Core/Portable/CommandLine/CommonCompiler.LoggingSourceFileResolver.cs</File>
      <File>src/Compilers/Core/Portable/CorLightup.cs</File>
      <File>src/Compilers/Core/Portable/ReferenceManager/CommonReferenceManager.Binding.cs</File>
      <File>src/Compilers/Core/Portable/ReferenceManager/CommonReferenceManager.Resolution.cs</File>
      <File>src/Compilers/Core/Portable/ReferenceManager/CommonReferenceManager.State.cs</File>
      <File>src/Interactive/EditorFeatures/Core/Extensibility/Interactive/InteractiveEvaluator.cs</File>
      <File>src/Interactive/Features/Interactive/Core/InteractiveHost.Service.cs</File>
      <File>src/Interactive/HostTest/InteractiveHostTests.cs</File>
      <File>src/Scripting/CSharpTest.Desktop/CsiTests.cs</File>
      <File>src/Scripting/CSharpTest.Desktop/InteractiveSessionTests.cs</File>
      <File>src/Scripting/CSharpTest/CommandLineRunnerTests.cs</File>
      <File>src/Scripting/CSharpTest/InteractiveSessionTests.cs</File>
      <File>src/Scripting/Core/Hosting/AssemblyLoader/InteractiveAssemblyLoader.cs</File>
      <File>src/Scripting/Core/Hosting/AssemblyLoader/InteractiveAssemblyLoaderException.cs</File>
      <File>src/Scripting/Core/Hosting/CommandLine/CommandLineHelpers.cs</File>
      <File>src/Scripting/Core/Hosting/CommandLine/CommandLineRunner.cs</File>
      <File>src/Scripting/Core/Hosting/Resolvers/RuntimeMetadataReferenceResolver.cs</File>
      <File>src/Scripting/Core/Script.cs</File>
      <File>src/Scripting/Core/ScriptBuilder.cs</File>
      <File>src/Scripting/CoreTest/TestCompilationFactory.cs</File>
      <File>src/Test/Utilities/Desktop/ProcessUtilities.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>6458</IssueID>
    <Title>Inherit references from previous submissions</Title>
    <Description>Moves the logic of reusing metadata references from Script down to ReferenceManager. This is necessary to avoid duplication of PE assembly symbols due to repeatedly resolved missing references. 

The metadata resolver creates a new reference whenever asked to resolve a missing assembly identity. That results in creating new PE assembly symbol. We could implement deduplication in the resolver. However the lifetime of the resolver isn't necessarily related to the lifetime of the interactive session. hence it is better to implement it in the ReferenceManager. This work item was previously suggested for U1 but postponed for U2 (#5301) since the thinking was that it only affects performance. However, as described in #6457 it is critical for correctness of basic scenarios in csi and Hosting APIs, which don't use shadow copying.

Also fixes #6474.
</Description>
    <CreatedDate>30/10/2015</CreatedDate>
    <ClosedDate>02/11/2015</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>5301</IssueID>
        <Title>Submission references should be inherited from previous submissions</Title>
        <Description>
        </Description>
        <CreatedDate>17/09/2015</CreatedDate>
        <ClosedDate>03/11/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>6457</IssueID>
        <Title>REPL reports error CS0029: Cannot implicitly convert type T to T in common cases</Title>
        <Description>Consider source compiled into a library a.dll:

```
public class C
{
    public System.Diagnostics.Process P;
}
```

and session:

``` C#
&gt;  #r "a.dll"
&gt; C c;
&gt; c = new C();
(1,6): error CS0029: Cannot implicitly convert type 'C [a.dll]' to 'C [a, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null]'
```

The problem is that we resolved a missing reference to System.Configuration.dll (thru System.dll) reference twice and constructed two PE symbols for it. That caused other PE assembly symbols to not be reused ultimately resulting in creating two PE type symbols for the same class C.
</Description>
        <CreatedDate>30/10/2015</CreatedDate>
        <ClosedDate>03/11/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>6474</IssueID>
        <Title>Reuse already loaded assemblies if they are identical</Title>
        <Description>Scenario:
Solution with 3 projects that don't build into a common directory but rather each builds into their own:

```
Shared\bin\debug\Shared.dll
Lib1\bin\debug\Lib1.dll 
               Shared.dll (copy)
Lib2\bin\debug\Lib2.dll
               Shared.dll (copy)
```

Now in a REPL:

``` C#
&gt; #r "Lib1\bin\debug\Lib1.dll" 
&gt; Lib1 l1 = new Lib1();  // loads Lib1 and Shared from Lib1\bin\debug dir
&gt; #r "Lib2\bin\debug\Lib2.dll" 
&gt; Lib2 l2 = new Lib2();   // loads Lib1 and Shared from Lib2\bin\debug dir
&gt; l2.libBase
Field not found: 'Lib2.libBase'.
  + System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[TResult].Start(TStateMachine&amp; stateMachine)
```

The problem is that we load Shared twice at runtime because it's in a different directory. The compiler correctly dedups it since both copies have the same identity. The loader should check whether the assemblies are the same. If they are then we can reuse the existing one. Otherwise we should report an error.
</Description>
        <CreatedDate>30/10/2015</CreatedDate>
        <ClosedDate>03/11/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Symbols/ReferenceManager.cs</File>
      <File>src/Compilers/CSharp/Test/CommandLine/CommandLineScriptTests.cs</File>
      <File>src/Compilers/Core/Portable/CorLightup.cs</File>
      <File>src/Compilers/Core/Portable/ReferenceManager/CommonReferenceManager.Binding.cs</File>
      <File>src/Compilers/Core/Portable/ReferenceManager/CommonReferenceManager.Resolution.cs</File>
      <File>src/Compilers/Core/Portable/ReferenceManager/CommonReferenceManager.State.cs</File>
      <File>src/Interactive/EditorFeatures/Core/Extensibility/Interactive/InteractiveEvaluator.cs</File>
      <File>src/Interactive/Features/Interactive/Core/InteractiveHost.Service.cs</File>
      <File>src/Interactive/HostTest/InteractiveHostTests.cs</File>
      <File>src/Scripting/CSharpTest.Desktop/InteractiveSessionTests.cs</File>
      <File>src/Scripting/CSharpTest/CommandLineRunnerTests.cs</File>
      <File>src/Scripting/CSharpTest/InteractiveSessionTests.cs</File>
      <File>src/Scripting/Core/Hosting/AssemblyLoader/InteractiveAssemblyLoader.cs</File>
      <File>src/Scripting/Core/Hosting/AssemblyLoader/InteractiveAssemblyLoaderException.cs</File>
      <File>src/Scripting/Core/Hosting/CommandLine/CommandLineRunner.cs</File>
      <File>src/Scripting/Core/Hosting/Resolvers/RuntimeMetadataReferenceResolver.cs</File>
      <File>src/Scripting/Core/Script.cs</File>
      <File>src/Scripting/Core/ScriptBuilder.cs</File>
      <File>src/Scripting/CoreTest/TestCompilationFactory.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>6432</IssueID>
    <Title>Add expansion rule to add cast to lambda expression bodies</Title>
    <Description>Fixes #6306
Fixes #6308

This change also fixes two outstanding (though not yet reported) bugs in the expansion engine:
- Generic type arguments should _not_ be addded to a name if they contain anonymous types
- A lambda parameter should not be expanded if its type is an anonymous type

Tagging @dotnet/roslyn-ide 
</Description>
    <CreatedDate>29/10/2015</CreatedDate>
    <ClosedDate>07/11/2015</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>6306</IssueID>
        <Title>Rename doesn't resolve conflicts by value of uncastable lambda</Title>
        <Description>``` C#
void X&lt;T&gt;(T t, Func&lt;T, long&gt; e) { X(new { a = 1 }, a =&gt; a.a); }
[Obsolete]
void Y&lt;T&gt;(T t, Func&lt;T, int&gt; e) { }
```

Rename `Y` to `X`.

&lt;strike&gt;
**Expected**:

``` C#
X(new { a = (long)1 }, a =&gt; a.a);
```

&lt;/strike&gt;

**Expected**:

``` C#
X(new { a = 1 }, a =&gt; (long)a.a);
```
</Description>
        <CreatedDate>25/10/2015</CreatedDate>
        <ClosedDate>07/11/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>6308</IssueID>
        <Title>Rename doesn't resolve conflicts by inserting identity conversion</Title>
        <Description>``` C#
[Obsolete]
void M&lt;T&gt;(T t, Func&lt;T,int, int&gt; e) { }
int M&lt;T&gt;(T t, Func&lt;T, long, long&gt; e) =&gt; M(new { }, (_, a) =&gt; X(a));

long X(long a) =&gt; a;
int Y(int a) =&gt; a;
```

Rename `Y` to `X`.

**Expected**:

``` C#
M(new { }, (_, a) =&gt; X((long)a));
```
</Description>
        <CreatedDate>25/10/2015</CreatedDate>
        <ClosedDate>07/11/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Features/CSharp/Portable/CodeRefactorings/InlineTemporary/InlineTemporaryCodeRefactoringProvider.cs</File>
      <File>src/Workspaces/CSharp/Portable/Extensions/ExpressionSyntaxExtensions.cs</File>
      <File>src/Workspaces/CSharp/Portable/Simplification/CSharpSimplificationService.Expander.cs</File>
      <File>src/Workspaces/Core/Portable/Simplification/SimplificationHelpers.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>6398</IssueID>
    <Title>Added Restore.cmd to simplify restore for contributors</Title>
    <Description>This replaces #6335.

Restore.cmd can now be called to simplify the number of
projects you need to restore until we've resolved #6336.

This also reduces the number of restores we do during CI
builds, as we were restoring Roslyn and the samples twice
and the toolset 3 times.

Make note, I removed -nocache. This does _nothing_
for project.json projects, it does not stop NuGet from
using the Global Packages folder
(%USERPROFILE%.nuget\packages) and it does not
validate this folder's contents with what's in the source.
</Description>
    <CreatedDate>28/10/2015</CreatedDate>
    <ClosedDate>29/10/2015</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>6335</IssueID>
        <Title>Added: Restore.cmd for restoring NuGet packages in open.</Title>
        <Description>We currently need to restore both Toolset and Rolsyn currently.
This is simplifies this, until we make end-to-end "just open Roslyn.sln
and build" work.
</Description>
        <CreatedDate>26/10/2015</CreatedDate>
        <ClosedDate>28/10/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>6336</IssueID>
        <Title>Contributors should be able to clone, Open Roslyn.sln and build</Title>
        <Description>This issue is tracking the following story:

&gt; Contributors should be able to clone github.com/dotnet/roslyn, Open Roslyn.sln, build and everything should just work
- [x] Stop failing design-time builds if packages are not restored. Owner: **@Pilchie** Resolved in #6298.
- [ ] Make sure all projects either directly or indirectly depend on the toolset packages
- [ ] Don't show downstream errors in ErrorList if root projects fail (ie avoid ~100,000 errors in Error List). Owner **@jasonmalinowski**
- [ ] Make sure end-to-end works on clean machine (try Azure VM with preinstall VS)
- [ ] Update wiki
</Description>
        <CreatedDate>26/10/2015</CreatedDate>
        <ClosedDate>30/03/2018</ClosedDate>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6386</IssueID>
    <Title>Update MS.DSR.N and SRM to RTM versions</Title>
    <Description>Fixes #6010, #4398 and #5813.
</Description>
    <CreatedDate>28/10/2015</CreatedDate>
    <ClosedDate>28/10/2015</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>6010</IssueID>
        <Title>[ask mode] Update Roslyn to use Microsoft.DiaSymReader.Native 1.3.0</Title>
        <Description>Currently we use 1.2.0-rc, which doesn't support deterministic PDB ID. The new version should be available by the EOW -- we are waiting for the C++ team to deliver it.
</Description>
        <CreatedDate>15/10/2015</CreatedDate>
        <ClosedDate>28/10/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>4398</IssueID>
        <Title>System.Reflection.Metadata dependency is 'PreRelease'</Title>
        <Description>Our current System.Reflect.Metadata dependency is considered 'PreRelease'. This will need to be updated to a 'Release' version before v1.1 can be released.

Once this issue has been resolved, Setup.proj needs to have Release packaging re-enabled.
</Description>
        <CreatedDate>07/08/2015</CreatedDate>
        <ClosedDate>28/10/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>5813</IssueID>
        <Title>Re-Enable 5 Failing Emit tests</Title>
        <Description>These five tests need to be fixed and re-enabled

```
Microsoft.CodeAnalysis.VisualBasic.UnitTests.Emit.DeterministicTests.CompareAllBytesEmitted_Debug
Microsoft.CodeAnalysis.VisualBasic.UnitTests.Emit.DeterministicTests.CompareAllBytesEmitted_Release
Microsoft.CodeAnalysis.CSharp.UnitTests.Emit.DeterministicTests.Simple 
Microsoft.CodeAnalysis.CSharp.UnitTests.Emit.DeterministicTests.CompareAllBytesEmitted_Debug
Microsoft.CodeAnalysis.CSharp.UnitTests.Emit.DeterministicTests.CompareAllBytesEmitted_Release
```
</Description>
        <CreatedDate>09/10/2015</CreatedDate>
        <ClosedDate>28/10/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Test/Emit/Emit/DeterministicTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>6294</IssueID>
    <Title>Log low VM telemetry at most once per session</Title>
    <Description>Fixes #6279 

Supersedes #6281 

@Pilchie @heejaechang 
</Description>
    <CreatedDate>24/10/2015</CreatedDate>
    <ClosedDate>27/10/2015</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>6279</IssueID>
        <Title>make vb/ide/vbcs/virtualmemory/lowmemory fire only once when we get into low memory situation.</Title>
        <Description>currently we fire it every time it is raised even if we are already in that mode.
</Description>
        <CreatedDate>23/10/2015</CreatedDate>
        <ClosedDate>29/10/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>6281</IssueID>
        <Title>Log low VM telemetry at most once per session</Title>
        <Description>Fixes #6279 

@heejaechang @Pilchie 

This is the simplest fix for Update 1.

Note: The shell will keep broadcasting VSM_VIRTUALMEMORYLOW/CRITICAL once a minute while the low VM situation persists. There is no corresponding message indicating "VM is back to normal".

Another approach might be to do some rate limiting on the telemetry. i.e. note the time of the last notification and log telemetry only if it's been more than some interval (say 30 minutes or an hour). Thoughts?
</Description>
        <CreatedDate>23/10/2015</CreatedDate>
        <ClosedDate>24/10/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/VisualStudio/Core/Def/Implementation/VirtualMemoryNotificationListener.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>6254</IssueID>
    <Title>Handle in-memory assemblies correctly in ScriptOptions.AddReference and when adding reference to the host object</Title>
    <Description>Throw NotSupportedException when a reference to an assembly without a location is added to script.
Don't try to implicitly add a reference to host assembly if it is an in-memory assembly.

Fixes #2246 

(originally PR #6246)
</Description>
    <CreatedDate>22/10/2015</CreatedDate>
    <ClosedDate>23/10/2015</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>2246</IssueID>
        <Title>Can't use object from a dynamic assembly as global object for script</Title>
        <Description>To reproduce, create a dynamic assembly using Roslyn:

```
SyntaxTree syntaxTree = CSharpSyntaxTree.ParseText(@"
    public class MyGlobals
    {
        ...
    }
");
CSharpCompilation compilation = CSharpCompilation.Create("DynamicAssembly")
    .WithOptions(new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary))
    .AddSyntaxTrees(syntaxTree)
    .AddReferences(...);
byte[] assemblyBytes;
using (MemoryStream ms = new MemoryStream())
{
    compilation.Emit(ms);
    assemblyBytes = ms.ToArray();
}
Assembly assembly = Assembly.Load(assemblyBytes);
Type globalsType = assembly.GetType("MyGlobals");
object globals = Activator.CreateInstance(globalsType);
```

Then try and use the dynamic globals object in a script:

```
ScriptOptions options = new ScriptOptions()
    .AddNamespaces(...)
    .AddReferences(...);
CSharpScript.Eval(@"...", options, globals);
```

It throws an exception `System.ArgumentException : Empty path name is not legal.`. This is the same exception you see if you attempt to call `MetadataReference.CreateFromAssembly()` with a dynamic assembly. Since dynamic assemblies don't have a `Location`, the following call in `MetadataReference.cs" fails:

```
string location = AssemblyLocationLightUp.GetAssemblyLocation(assembly);
Stream peStream = FileStreamLightUp.OpenFileStream(location);
```

Normally I get around this in a compilation by creating my `MetadataReference` from a `Stream`:

```
MetadataReference dynamicReference;
using (MemoryStream ms = new MemoryStream(assemblyBytes))
{
    dynamicReference = MetadataReference.CreateFromStream(ms);
}
```

However, this doesn't work for script globals because of the following line in `Core\Script.cs` (https://github.com/dotnet/roslyn/blob/master/src/Scripting/Core/Script.cs#L375):

```
var globalsTypeAssembly = MetadataReference.CreateFromAssembly(this.GlobalsType.Assembly);
```

**TL;DR: A script always tries to use `MetadataReference.CreateFromAssembly()` to get the assembly metadata for the global object, and that approach doesn't work for global objects defined in dynamic assemblies.**

Not sure what a good fix would be. Perhaps allowing the specification of a `MetadataReference` for the global object to be used? Or checking the provided assembly references for one that contains the global object _before_ attempting to get one? Alternatively, any fix for dynamic assemblies causing an exception with `MetadataReference.CreateFromAssembly()` would also resolve this more specific, but related issue.
</Description>
        <CreatedDate>24/04/2015</CreatedDate>
        <ClosedDate>23/10/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>6246</IssueID>
        <Title>Handle in-memory assemblies correctly in ScriptOptions.AddReference and when adding reference to the host object</Title>
        <Description>Throw NotSupportedException when a reference to an assembly without a location is added to script.
Don't try to implicitly add a reference to host assembly if it is an in-memory assembly.

Fixes https://github.com/dotnet/roslyn/issues/2246
</Description>
        <CreatedDate>22/10/2015</CreatedDate>
        <ClosedDate>23/10/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/Core/CodeAnalysisTest/MetadataReferences/MetadataReferenceTests.cs</File>
      <File>src/Compilers/Core/Portable/CodeAnalysisResources.Designer.cs</File>
      <File>src/Compilers/Core/Portable/MetadataReference/MetadataReference.cs</File>
      <File>src/Scripting/CSharpTest.Desktop/InteractiveSessionTests.cs</File>
      <File>src/Scripting/Core/Script.cs</File>
      <File>src/Scripting/Core/ScriptOptions.cs</File>
      <File>src/Scripting/CoreTest/TestCompilationFactory.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>6230</IssueID>
    <Title>Port commit from PR #6194 to stabilization branch</Title>
    <Description>Explicitly invoke diagnostic re-analysis whenever any bulk suppression fix is invoked from the error list or solution explorer.

Ported from #6194 - Already [approved](https://github.com/dotnet/roslyn/pull/6194#issuecomment-150046678) for 1.1 by MattGe.

Fixes #6007
</Description>
    <CreatedDate>21/10/2015</CreatedDate>
    <ClosedDate>22/10/2015</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>6194</IssueID>
        <Title>Explicitly invoke diagnostic re-analysis whenever any bulk suppressio…</Title>
        <Description>…n fix is invoked from the error list or solution explorer.

**User Scenario:** User installs an analyzer with syntax diagnostics (e.g. CodeCracker), and bulk suppresses the syntax diagnostics from the error list or using the solution explorer "Suppress active issues" command. The code fix correctly adds suppressions to the global suppressions file, but the error list entries never get cleared. Even doing a rebuild doesn't clear the error list.

**Reason:** Our IDE diagnostic service assumes that syntax diagnostics only depend on text version of the document. Adding a global suppression to other file invalidates this assumption. We cannot run all syntax analyzers on every single edit, that would cause perf problems.

**Fix:** We explicitly invoke diagnostic re-analysis whenever any bulk suppression fix is invoked from the error list or solution explorer. This ensures that the error list gets refreshed.

**Testing:** Verified that syntax diagnostics are correctly removed from the error list for bulk suppression scenarios.

**Fixes #6007**
</Description>
        <CreatedDate>20/10/2015</CreatedDate>
        <ClosedDate>21/10/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>6007</IssueID>
        <Title>Syntax analysis is not re-executed in the IDE diagnostic service on adding global suppressions</Title>
        <Description>1. Create a new C# class library with below code:
   
   ``` C#
   class Class1
   {
       // Comment with trailing whitespaces     
   }
   ```
2. Install [codecracker](http://www.nuget.org/packages/codecracker/1.0.0-rc3) analyzer nuget package (check "Include prerelease" checkbox in Nuget package manager).
3. Change rule _"CC0065 (Remove trailing whitespace)"_ to be a warning from the ruleset editor.
4. Build project and see CC0065 diagnostic:
   
   ```
   Severity    Code    Description Project File    Line    Suppression State
   Warning CC0065  Remove trailing whitespace  ClassLibrary14  c:\users\mavasani\documents\visual studio 2015\Projects\ClassLibrary14\ClassLibrary14\Class1.cs 3   
   
   ```
5. From the lightbulb menu select "Suppress CC0065" -&gt; "In Suppression File" and hit enter
6. Verify suppression added to GlobalSuppressions.cs
   
   **Expected:** Diagnostic is suppressed in the error list + squiggle disappears.
   **Actual:** Diagnostic is retained in the error list and squiggle also doesn't go away. If you rebuild the project, the output window doesn't show the original diagnostic (though it shows 2 more instances of CC0065 in the newly added GlobalSuppressions file), but the error list still shows the origin CC0065 intellisense diagnostic.
7. Edit Class1.cs at an unrelated location - say hit enter at the end of the last line of the source file.
   You will now see the expected behavior, and the diagnostic and squiggle disappear.

**Details:** The reason for this bug is that CC0065 is a syntax diagnostic (syntax tree analyzer action), and our IDE diagnostic service assumes that syntax diagnostics only depend on text version of the document. Adding a global suppression to other file invalidates this assumption. We cannot run all syntax analyzers on every single edit, that would cause perf problems - we need to figure out how to implement this reasonably.
</Description>
        <CreatedDate>15/10/2015</CreatedDate>
        <ClosedDate>21/10/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/VisualStudio/Core/Def/Implementation/TableDataSource/Suppression/VisualStudioSuppressionFixService.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>5014</IssueID>
    <Title>Fixes a subtle bug in branch optimizer.</Title>
    <Description>"branch over branch" optimization eliminates chains of trivial basic blocks from the graph, which is correct as long as trivial blocks are not reachable individually from outside via branches.
The "same as next" optimization can make a block trivial and if it was targeted by a branch, break the assumption, leading to a rare situation of some branches having stale offsets.

The fix makes sure if a block becomes trivial, its labels are moved to the next nontrivial block.

Fixes #4838
Fixes #4839
</Description>
    <CreatedDate>04/09/2015</CreatedDate>
    <ClosedDate>05/09/2015</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>4838</IssueID>
        <Title>Incorrect compiler output for code involving async, loop, switch.</Title>
        <Description>I've spotted an issue with compilation output from VS 2015 Enterprise (RTM version).

The following code involving async, loop and switch constructs causes  `ArgumentOutOfRangeException` from `default:` branch when run, whereas a return from `case 0:` is expected. Apparently the compiler generates code without `case 0:` branch.

**Code**

```
using System;
using System.Threading.Tasks;

namespace ConsoleApplication11
{
    class Program
    {
        static void Main()
        {
            M(0).Wait();
        }

        static async Task M(int input)
        {
            for (;;)
            {
                var value = await Task.FromResult(input);
                switch (value)
                {
                    case 0:
                        return;
                    case 3:
                        return;
                    case 4:
                        continue;
                    case 100:
                        return;
                    default:
                        throw new ArgumentOutOfRangeException("Unknown value: " + value);
                }
            }
        }
    }
}
```

**Compile with optimizations**

```
D:\dev\bugs&gt;"c:\Program Files (x86)\MSBuild\14.0\Bin\csc.exe" Program1.cs /o+
Microsoft (R) Visual C# Compiler version 1.0.0.50618
Copyright (C) Microsoft Corporation. All rights reserved.
```

**Output**

```

Unhandled Exception: System.AggregateException: One or more errors occurred. ---&gt; System.ArgumentOutOfRangeException: Specified argument was out of the range of valid values.
Parameter name: Unknown value: 0
   at ConsoleApplication11.Program.&lt;M&gt;d__1.MoveNext()
   --- End of inner exception stack trace ---
   at System.Threading.Tasks.Task.ThrowIfExceptional(Boolean includeTaskCanceledExceptions)
   at System.Threading.Tasks.Task.Wait(Int32 millisecondsTimeout, CancellationToken cancellationToken)
   at ConsoleApplication11.Program.Main()
```
</Description>
        <CreatedDate>27/08/2015</CreatedDate>
        <ClosedDate>05/09/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>4839</IssueID>
        <Title>Invalid compilation output for code involving async and switch</Title>
        <Description>I've spotted an issue with compilation output from VS 2015 Enterprise (RTM version).

The compiler generates invalid IL for the following code involving async and switch constructs.

**Code**

```
using System;
using System.Threading.Tasks;

namespace ConsoleApplication11
{
    class Program
    {
        static void Main()
        {
            M(0).Wait();
        }

        static async Task M(int input)
        {
            var value = await Task.FromResult(input);
            switch (value)
            {
                case 0:
                    return;
                case 1:
                    return;
            }
        }
    }
}
```

**Compile with optimizations**

```
D:\dev\bugs&gt;"c:\Program Files (x86)\MSBuild\14.0\Bin\csc.exe" Program2.cs /o+
Microsoft (R) Visual C# Compiler version 1.0.0.50618
Copyright (C) Microsoft Corporation. All rights reserved.
```

**Output**

```
Unhandled Exception: System.InvalidProgramException: Common Language Runtime detected an invalid program.
   at ConsoleApplication11.Program.&lt;M&gt;d__1.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[TStateMachine](TStateMachine&amp; stateMachine)
   at ConsoleApplication11.Program.M(Int32 input)
   at ConsoleApplication11.Program.Main()
```
</Description>
        <CreatedDate>27/08/2015</CreatedDate>
        <ClosedDate>05/09/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenAsyncTests.cs</File>
      <File>src/Compilers/Core/Portable/CodeGen/BasicBlock.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>4979</IssueID>
    <Title>Making stack scheduling optimizations more robust and fixing #4828</Title>
    <Description>Stack scheduler performs two kinds of transformations -
1) it turns local slots into ephemeral locals that live on the evaluation stack.
2) It also tries to Dup previous expressions when the next one is exactly the same and other condittions allow.

The operation # 2 is basically a workaround for cases like

   temp = ...
   result = temp + temp;

Since ephemeral locals are modeled as occupying the space "below" the eval values, having temp on eval stack prevents that same temp from loading as a stack local.
The self-interference situations like above are fairly common, so the stack scheduler tries to reduce some of the cases by attempting a peephole optimization where value of previous expression could be Dup-ed if the following one is the same. (thus in our example it would look like the second load of the temp does not happen at all).

This # 2 optimization has numerous conditions where it is not applicable and as bug #4828 shows it is still fairly fragile. It relies on the presence of the value produced by the previous expression and that is not always guaranteed to be there if the expression has no sideeffects.

Instead of adding more conditions, I am removing the # 2 entirely.

It appears that it can be removed without any serious regression in # 1 as long as we track not only the depth of the eval stack but also what we have on it. That way we can detect self-interference cases by just examining our best knowledge of the stack and handle definite self-interference cases as not prohibiting.

The result of this change is that many dups have disappeared from the code, but in most cases they were dups of trivial local/parameter loads and as such are not a concern.
On the other hand most cases where local slots can be optimized away are still there and in some cases we actually are slightly better.

The most important part is that the whole scheduling got simpler and uses fewer assumptions about what emit might do.

Fixes #4828
</Description>
    <CreatedDate>03/09/2015</CreatedDate>
    <ClosedDate>05/09/2015</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>4828</IssueID>
        <Title>Compiler emits invalid MSIL</Title>
        <Description>I have a problem with the compiler in VS2015. The following code will crash the application with an InvalidProgramException. (But only if /optimize+ is passed). Is this a bug in the compiler, or am I doing something wrong?

**Compiler command line:**

```
"C:\Program Files (x86)\MSBuild\14.0\bin\csc.exe" /nostdlib+ /reference:C:\Windows\Microsoft.NET\Framework\v2.0.50727\mscorlib.dll  /optimize+ /out:App.exe /target:exe Program.cs
```

**Contents of Program.cs:**

```
namespace App
{
    class Program
    {
        static void Main(string[] args)
        {
            int a = 0;
            int b = a + a / 1;
        }
    }
}
```

**Emitted MSIL of the method that fails:**

```
.method private hidebysig static void  Main(string[] args) cil managed
{
  .entrypoint
  // Code size       7 (0x7)
  .maxstack  8
  IL_0000:  ldc.i4.0
  IL_0001:  pop
  IL_0002:  dup
  IL_0003:  ldc.i4.1
  IL_0004:  div
  IL_0005:  pop
  IL_0006:  ret
} // end of method Program::Main
```

**Exception message:**

```
Unhandled Exception: System.InvalidProgramException: Common Language Runtime detected an invalid program.
   at App.Program.Main(String[] args)
```

**Output from PEVerify.exe:**

```
"C:\Program Files (x86)\Microsoft SDKs\Windows\v10.0A\bin\NETFX 4.6 Tools\PEVerify.exe" /nologo App.exe
[IL]: Error: [C:\Src\OutsideTFS\RslnBug\RslnBug\App\App.exe : App.Program::Main][offset 0x00000002] Stack underflow.
1 Error(s) Verifying App.exe
```
</Description>
        <CreatedDate>27/08/2015</CreatedDate>
        <ClosedDate>05/09/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>4828</IssueID>
        <Title>Compiler emits invalid MSIL</Title>
        <Description>I have a problem with the compiler in VS2015. The following code will crash the application with an InvalidProgramException. (But only if /optimize+ is passed). Is this a bug in the compiler, or am I doing something wrong?

**Compiler command line:**

```
"C:\Program Files (x86)\MSBuild\14.0\bin\csc.exe" /nostdlib+ /reference:C:\Windows\Microsoft.NET\Framework\v2.0.50727\mscorlib.dll  /optimize+ /out:App.exe /target:exe Program.cs
```

**Contents of Program.cs:**

```
namespace App
{
    class Program
    {
        static void Main(string[] args)
        {
            int a = 0;
            int b = a + a / 1;
        }
    }
}
```

**Emitted MSIL of the method that fails:**

```
.method private hidebysig static void  Main(string[] args) cil managed
{
  .entrypoint
  // Code size       7 (0x7)
  .maxstack  8
  IL_0000:  ldc.i4.0
  IL_0001:  pop
  IL_0002:  dup
  IL_0003:  ldc.i4.1
  IL_0004:  div
  IL_0005:  pop
  IL_0006:  ret
} // end of method Program::Main
```

**Exception message:**

```
Unhandled Exception: System.InvalidProgramException: Common Language Runtime detected an invalid program.
   at App.Program.Main(String[] args)
```

**Output from PEVerify.exe:**

```
"C:\Program Files (x86)\Microsoft SDKs\Windows\v10.0A\bin\NETFX 4.6 Tools\PEVerify.exe" /nologo App.exe
[IL]: Error: [C:\Src\OutsideTFS\RslnBug\RslnBug\App\App.exe : App.Program::Main][offset 0x00000002] Stack underflow.
1 Error(s) Verifying App.exe
```
</Description>
        <CreatedDate>27/08/2015</CreatedDate>
        <ClosedDate>05/09/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/CodeGen/Optimizer.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenAsyncEHTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenClosureLambdaTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenDynamicTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenOperators.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenShortCircuitOperatorTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenTryFinally.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/ForLoopsTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/ExtensionMethodTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/GenericConstraintTests.cs</File>
      <File>src/ExpressionEvaluator/CSharp/Test/ExpressionCompiler/AccessibilityTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>4911</IssueID>
    <Title>fixing history to mimic developer command prompt behaviour...</Title>
    <Description>Fixes #4669 
This PR replaces PR #4857 which had merge conflicts that beyond compare was having trouble with. So I replayed the changes in a new branch after getting the latest.

@amcasey  FYI
</Description>
    <CreatedDate>01/09/2015</CreatedDate>
    <ClosedDate>01/09/2015</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>4669</IssueID>
        <Title>History in interactive window should not cycle</Title>
        <Description>It should stop when it reaches 1st item in the history list and user tries to go to previous and similarly when it is at the last item and user tries to go to next. This is the behavior in command window too.
</Description>
        <CreatedDate>20/08/2015</CreatedDate>
        <ClosedDate>01/09/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>4857</IssueID>
        <Title>Makes history navigation stop at top and bottom and and fixes several…</Title>
        <Description>… history navigation bugs. Fixes #4669 
</Description>
        <CreatedDate>28/08/2015</CreatedDate>
        <ClosedDate>01/09/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/InteractiveWindow/Editor/History.cs</File>
      <File>src/InteractiveWindow/Editor/InteractiveWindow_UIThread.cs</File>
      <File>src/InteractiveWindow/EditorTest/InteractiveWindowTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>4797</IssueID>
    <Title>Get document moniker from IVsProject instead of RDT</Title>
    <Description>Switching to IVsProject.GetMkDocument to get document moniker instead of
iterating through all the entries in the running document table. Also
cleaning up a bit of code while I'm here - It looks like we don't need
to determine Shared Hierarchy &amp; Shared ItemId here anymore. It was there
for error list and it looks like with PR #2399 error list switched to a
different implementation.

Fixes #3645.

Validations To Do:
- [x] Run Integration tests: Venus, Razor, LinkedFiles
- [x] Exploratory testing on Asp Net 5 projects (shared hierarchies!), other Web flavored projects
</Description>
    <CreatedDate>25/08/2015</CreatedDate>
    <ClosedDate>08/09/2015</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>2399</IssueID>
        <Title>made error list to report Project ID Guid to error list</Title>
        <Description>we decide to move away from IVsHierarchy and instead use Project Id Guid. we just need some kind of ID to distinguish between different projects. IVsHierarchy is just not right one to use for that purpose.
</Description>
        <CreatedDate>30/04/2015</CreatedDate>
        <ClosedDate>01/05/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>3645</IssueID>
        <Title>VsHierarchyExtensions.GetMonikerForHierarchyAndItemId loads unrelated docdata objects</Title>
        <Description>[This extension method](http://source.roslyn.io/#Microsoft.VisualStudio.LanguageServices/Implementation/Utilities/VsHierarchyExtensions.cs,8cd19b5d59b4a18a) calls IVsRunningDocumentTable.GetDocumentInfo in a loop until it finds a matching hierarchy, itemid pairing. However, each call to GetDocumentInfo ends up creating a docdata for the requested file, which means it might end up creating multiple docdata objects when it only needs to find the document's moniker. A better way to do this would be to use either MPF or IVsRunningDocumentTable4 to find this information.
</Description>
        <CreatedDate>23/06/2015</CreatedDate>
        <ClosedDate>08/09/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/VisualStudio/Core/Def/Implementation/Utilities/VsHierarchyExtensions.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Venus/ContainedDocument.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>4574</IssueID>
    <Title>Make expression trees involving enum literals to look like produced b…</Title>
    <Description>…y native compiler

Native compiler exposes results of constant folding in the expression trees.
In particular, conversion from an enum literal to an underlying type is fairly consistently folded by the native compiler as it can be observed in the expression trees.

Roslyn, on the other hand, was not very consistent here.
Some cases like explicitly converted literals were folded - Ex:  IntTakingMethod((int)E1.a)
Other cases like implicit conversions to underlying type introduced in the processs of type promotion in binary expressions were not.

This fixes known differences in this behavior.

Fixes #4085
Fixes #3292
</Description>
    <CreatedDate>15/08/2015</CreatedDate>
    <ClosedDate>15/08/2015</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>4085</IssueID>
        <Title>Differences in expression body for lambdas and enums</Title>
        <Description>I'm noticing some differences in expression bodies when using enums. Specifically, the Roslyn compiler appears to add a `Convert` expression whereas the previous compiler did not. Take the following code:

```
using System;
using System.Linq.Expressions;

public class Program
{
    public enum TestEnum
    {
        Foo,
        Bar
    }

    public static void Main()
    {
        Expression&lt;Func&lt;TestEnum, bool&gt;&gt; expected = x =&gt; TestEnum.Bar == x;
        Console.WriteLine(expected.Body.ToString());
    }
}
```

The old compiler outputs `(1 == Convert(x))`. Roslyn outputs `(Convert(Bar) == Convert(x))`.

I would understand if this is fixing a bug or a premature optimization or something with the old compiler, but the odd thing is that Roslyn itself doesn't seem to have the same hangups about optimizing the enum value when used directly (I.e., not via an `Expression`). If you put the following into TryRoslyn:

```
using System;
using System.Linq.Expressions;

public class C {
    public enum TestEnum
    {
        Foo,
        Bar
    }

    public void M() 
    {
        Func&lt;TestEnum, bool&gt; compiled = x =&gt; TestEnum.Bar == x;
    }
}
```

you can see that the relevant part decompiles to `return C.TestEnum.Bar == x` or the following IL which does not contain any type of conversion for `TestEnum.Bar`:

```
IL_0000: ldc.i4.1
IL_0001: ldarg.1
IL_0002: ceq
IL_0004: ret
```

This might be related to #3292, but it's different enough I figured I'd open a new issue so that it doesn't get lost in the noise. Feel free to close and reference from the other one if it's the same thing.
</Description>
        <CreatedDate>23/07/2015</CreatedDate>
        <ClosedDate>15/08/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>3292</IssueID>
        <Title>C# compiles enums in lambda expressions differently; consequence of overload resolution improvements?</Title>
        <Description>While trying out the Visual Studio 2015 RC, I received a run-time error on previously working code. Given the lambda  (x =&gt; x.CustomerStatusID == CustomerStatuses.Active) which was passed to a function as an Expression&lt;&gt;, the debugger shows a difference in the expression tree. Formerly it compiled as this:

.Lambda #Lambda1&lt;System.Func`2[Services.DataClasses.CustomerDC,System.Boolean]&gt;(Services.DataClasses.CustomerDC $x)
{
    (System.Int32)$x.CustomerStatusID == 0
}
But in C# 6.0 it now compiles as

.Lambda #Lambda1&lt;System.Func`2[Services.DataClasses.CustomerDC,System.Boolean]&gt;(Services.DataClasses.CustomerDC $x)
{
    (System.Int32)$x.CustomerStatusID == (System.Int32).Constant&lt;Services.DataClasses.CustomerStatuses&gt;(Active)
}
Although the fix to my tree-traversing code was straightforward and the additional detail is appreciated, does anyone know of any other gotchas floating around like this?

Alternately, does anyone have a link to information on the specifics of how overload resolution was improved? I cannot find any.
</Description>
        <CreatedDate>03/06/2015</CreatedDate>
        <ClosedDate>15/08/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Lowering/LambdaRewriter/ExpressionLambdaRewriter.cs</File>
      <File>src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_BinaryOperator.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenExprLambdaTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>4504</IssueID>
    <Title>Fix 4121and4125</Title>
    <Description>The root issue here was the call to AddInput method ( which echoes the command on the language buffer) which was being made even when the reset command was typed at the prompt instead of just when reset button was clicked. The language buffer actually gets marked as readonly when input on the prompt gets submitted. We now check to see if the language buffer is readonly and bail out of AddInput if it is.  Previously AddInput was trying to echo the reset command which did nothing as the buffer was readonly but the subsequent processing in AddInput was causing all these issues. 

Fixes #4121, #4125 and #4277
</Description>
    <CreatedDate>12/08/2015</CreatedDate>
    <ClosedDate>12/08/2015</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>4121</IssueID>
        <Title>Reset command in Interactive adds "reset \r\n" to history instead of "reset" </Title>
        <Description>Repro:
1. Open C# interactive window and type #reset and hit enter
2. Now type ctrl + up arrow.

expected: We see only reset command in the history.
actual: we see "reset \r\n"

We need to trim the snapshot before adding it to history. This is causing it to add the same command twice because it thinks it is a different command than previous one because of \r\n in the end..

![capture](https://cloud.githubusercontent.com/assets/9527491/8891484/d149ab9e-32e0-11e5-9238-829603b2d629.PNG)
</Description>
        <CreatedDate>25/07/2015</CreatedDate>
        <ClosedDate>12/08/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>4125</IssueID>
        <Title>executing #reset causes "reset \r\n" to appear on input prompt after the command has executed</Title>
        <Description>This is a recent regression.
Repro steps:
1. type #reset in interactive and hit enter
you see the following text in the prompt . Expected to see nothing after the prompt.
![capture](https://cloud.githubusercontent.com/assets/9527491/8893204/4cfc994e-333c-11e5-961e-dd498feba420.PNG)
</Description>
        <CreatedDate>26/07/2015</CreatedDate>
        <ClosedDate>25/08/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>4277</IssueID>
        <Title>Interactive window does not restore uncommitted input when reset button ...</Title>
        <Description>is pressed before submitting the input.
Repro:
1. Type the following in Interactive window ( note - do not hit enter after the closing curlies)
Class C1{
.
}
2. Hit the reset button

Reset is done but un committed input does not come back to input buffer
</Description>
        <CreatedDate>31/07/2015</CreatedDate>
        <ClosedDate>25/08/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/InteractiveWindow/Editor/InteractiveWindow_UIThread.cs</File>
      <File>src/InteractiveWindow/EditorTest/InteractiveWindowTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>4399</IssueID>
    <Title>Fix some analyzer load diagnostics IDs and a duplicate roslyn diagnostic ID</Title>
    <Description>Fixes #3805 and #2990
</Description>
    <CreatedDate>07/08/2015</CreatedDate>
    <ClosedDate>07/08/2015</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>3805</IssueID>
        <Title>MissingAnalyzerReference error</Title>
        <Description>Most errors reported from the compiler / IDE have ids that look like 'AB1234'. However looks like we have some errors such as the one mentioned in the title of this issue (not sure if this is being produced from core compiler or IDE) with camel cased errors ids. We should change this id to provide a consistent experience.

![capture](https://cloud.githubusercontent.com/assets/10579684/8467786/f9a29262-2017-11e5-9cf9-29efec357922.PNG)
</Description>
        <CreatedDate>02/07/2015</CreatedDate>
        <ClosedDate>07/08/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>2990</IssueID>
        <Title>RS0010 is used by two analyzers</Title>
        <Description>RS0010 is used by two diagnostic analyzers!!! See [RoslynDiagnosticIds](http://source.roslyn.io/Roslyn.Diagnostics.Analyzers/R/6b7b1b44b2f5eae4.html)

``` C#
    internal static class RoslynDiagnosticIds
    {
        public const string UseEmptyEnumerableRuleId = "RS0001";
        public const string UseSingletonEnumerableRuleId = "RS0002";
        public const string DirectlyAwaitingTaskAnalyzerRuleId = "RS0003";
        public const string UseSiteDiagnosticsCheckerRuleId = "RS0004";
        public const string DontUseCodeActionCreateRuleId = "RS0005";
        public const string MixedVersionsOfMefAttributesRuleId = "RS0006";
        public const string UseArrayEmptyRuleId = "RS0007";
        public const string ImplementIEquatableRuleId = "RS0008";
        public const string OverrideObjectEqualsRuleId = "RS0009";
        public const string MissingSharedAttributeRuleId = "RS0010";
        public const string DoNotUseVerbatimCrefsRuleId = "RS0010";
        public const string CancellationTokenMustBeLastRuleId = "RS0011";
        public const string DoNotCallToImmutableArrayRuleId = "RS0012";
        public const string DoNotAccessDiagnosticDescriptorRuleId = "RS0013";
        public const string DoNotCallLinqOnIndexable = "RS0014";
        public const string ConsumePreserveSigRuleId = "RS0015";
        public const string DeclarePublicApiRuleId = "RS0016";
        public const string RemoveDeletedApiRuleId = "RS0017";
        public const string DoNotCreateTasksWithoutTaskSchedulerRuleId = "RS0018";
        public const string SymbolDeclaredEventRuleId = "RS0019";
        public const string DeadCodeRuleId = "RS0020";
        public const string DeadCodeTriggerRuleId = "RS0021";
    }
```
</Description>
        <CreatedDate>21/05/2015</CreatedDate>
        <ClosedDate>07/08/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Diagnostics/Roslyn/Core/RoslynDiagnosticIds.cs</File>
      <File>src/EditorFeatures/Test/SolutionCrawler/WorkCoordinatorTests.cs</File>
      <File>src/Features/Core/Diagnostics/Analyzers/IDEDiagnosticIds.cs</File>
      <File>src/Features/Core/SolutionCrawler/InvocationReasons_Constants.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/AnalyzerDependencyCheckingService.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/AnalyzerFileWatcherService.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/AbstractProject.cs</File>
      <File>src/VisualStudio/Core/Def/ServicesVSResources.Designer.cs</File>
      <File>src/Workspaces/Core/Portable/CodeFixes/FixAllOccurrences/BatchFixAllProvider.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>4356</IssueID>
    <Title>Initial work to make Features layer portable</Title>
    <Description>This PR represents a couple of changes in service of making the Features layer portable (#3998). There are still outstanding work items before this work will be completed:
- Remove [Serializable] from EnC types (#4354)
- Update reflection code in Analyzer system to portable (#4355)
</Description>
    <CreatedDate>05/08/2015</CreatedDate>
    <ClosedDate>05/08/2015</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>3998</IssueID>
        <Title>Make Features Layer Portable</Title>
        <Description>This is required to expose Features APIs like completion for OmniSharp and VS Code.
</Description>
        <CreatedDate>17/07/2015</CreatedDate>
        <ClosedDate>23/10/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>4354</IssueID>
        <Title>Remove serialization from EnC types in Features layer</Title>
        <Description>Needed for #3998.
</Description>
        <CreatedDate>05/08/2015</CreatedDate>
        <ClosedDate>20/08/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>4355</IssueID>
        <Title>Make reflection code in Analyzer system portable</Title>
        <Description>Needed for #3998.
</Description>
        <CreatedDate>05/08/2015</CreatedDate>
        <ClosedDate>26/08/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Features/Core/Completion/CompletionOptions.cs</File>
      <File>src/Features/Core/Completion/CompletionOptionsProvider.cs</File>
      <File>src/Features/Core/Diagnostics/InternalDiagnosticsOptions.cs</File>
      <File>src/Features/Core/Diagnostics/InternalDiagnosticsOptionsProvider.cs</File>
      <File>src/Features/Core/ExtractMethod/ExtractMethodOptions.cs</File>
      <File>src/Features/Core/ExtractMethod/ExtractMethodOptionsProvider.cs</File>
      <File>src/Features/Core/Shared/Options/OrganizerOptions.cs</File>
      <File>src/Features/Core/Shared/Options/OrganizerOptionsProvider.cs</File>
      <File>src/Features/Core/Shared/Options/ServiceComponentOnOffOptions.cs</File>
      <File>src/Features/Core/Shared/Options/ServiceComponentOnOffOptionsProvider.cs</File>
      <File>src/Features/Core/Shared/Options/ServiceFeatureOnOffOptions.cs</File>
      <File>src/Features/Core/Shared/Options/ServiceFeatureOnOffOptionsProvider.cs</File>
      <File>src/Features/Core/SolutionCrawler/InternalSolutionCrawlerOptions.cs</File>
      <File>src/Features/Core/SolutionCrawler/InternalSolutionCrawlerOptionsProvider.cs</File>
      <File>src/Features/Core/Workspace/FileTracker.cs</File>
      <File>src/Features/Core/Workspace/Kernel32File.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>4305</IssueID>
    <Title>Fix VB TypeInferrer after ArgumentList</Title>
    <Description>[Copy of PR #3533 updated to target master, with previous signoff from @Pilchie, @DustinCampbell, and @balajikris]

Fixes #3518

When trying to figure out which Argument of an ArgumentList was being
inferred, we found the index and then returned "(index + 1) \ 2" without
checking if the index was out of bounds. When the index is out of bounds
its value is -1, so the above expression results in an index of 0, and
the rest of the system continues as though we're really trying to infer
the type of the first Argument (but really, the token we've passed is
the close paren for the entire invocation).
</Description>
    <CreatedDate>03/08/2015</CreatedDate>
    <ClosedDate>18/08/2015</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>3533</IssueID>
        <Title>Fix VB TypeInferrer after ArgumentList</Title>
        <Description>Fixes #3518 (related to the fix in PR #3519)

**Note**: There are two PRs for the same bug here -- this one and #3519. This fix has more potential risk, but also fixes the bug in the non-comment case.

**User scenario**: The user is typing in VB after an invocation where the first parameter is of an enum type. On the next line, enum preselection will kick in inappropriately, causing unexpected items to be committed. 

If the enum preselection is happening due to the `completionlist` doc comment tag, then this can even occur within comments (the specific case for which a fix is proposed in #3519).

**Issue description**: The VB TypeInferrer reports the type of the first parameter of the method invoked in the previous statement as the inferred type at any position between the end of that statement and the beginning of the next statement.

**Fix**: The long description is in the commit message, but basically we were assuming the PreviousToken at the provided position would be in the ArgumentListSyntax, but when it wasn't (in the case of the trailing parenthesis) we took its "index" (of -1) and returned "(index + 1) \ 2" which accidentally turned it into index 0. We now more carefully handle the -1 case, but I'm mostly relying on our tests to prove that nobody was depending on this behavior.

**Testing done**: Manual verification, unit testing. Relying on Jenkins to run all tests...

Potential Reviewers: @Pilchie @rchande @jasonmalinowski @DustinCampbell @balajikris @basoundr @brettfo
</Description>
        <CreatedDate>16/06/2015</CreatedDate>
        <ClosedDate>03/08/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>3518</IssueID>
        <Title>CompletionListTagCompletionProvider shows results in comments</Title>
        <Description>Split from #3506 (originally filed by @ljw1004):

*\* Reduced Repro**

``` VB
Class C
    Sub Test()
        M(Type2.A)
        ' $$
    End Sub

    Private Sub M(a As Type1)
        Throw New NotImplementedException()
    End Sub
End Class

''' &lt;completionlist cref="Type2"/&gt;
Public Class Type1
End Class

Public Class Type2
    Public Shared A As Type1
    Public Shared B As Type1
End Class
```

Remove the $$ and invoke completion.

Expected: no completion
Actual: `CompletionListTagCompletionProvider` provides items despite being in a comment
</Description>
        <CreatedDate>16/06/2015</CreatedDate>
        <ClosedDate>18/08/2015</ClosedDate>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4303</IssueID>
    <Title>Use default OS encoding to decode non-Unicode/non-UTF8 text, if available, instead of unconditionally falling back to cp1252 or Latin1.</Title>
    <Description>This brings Roslyn behavior close to VS2013. Fixes #4264. I also believe this change should address #4255, #4222 and #4022.

@gafter, @jaredpar, @VSadov, @agocke Please review.   
</Description>
    <CreatedDate>03/08/2015</CreatedDate>
    <ClosedDate>05/08/2015</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>4264</IssueID>
        <Title>Roslyn can't detect 932 encoding </Title>
        <Description>The encoding detection logic does not properly handle CP 932 (Shift JIS) files where previous compilers could.  This results from a change in the final fallback logic in our encoding detection scheme.  Roslyn will process in order the BOM, the specified code page and finally UTF8.  The native compiler had the same logic but used the active code page as the final fallback instead of UTF8.  The use of the active code page is how 932 encoded files were processed.  

As a work around the code page can be manually specified on the command line:

```
$&gt; csc /codepage:932 Program.cs
```
</Description>
        <CreatedDate>31/07/2015</CreatedDate>
        <ClosedDate>05/08/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>4255</IssueID>
        <Title>Chinese string is compiled to garbage characters</Title>
        <Description>A project that includes the following C# code：

``` csharp
public class Pager : Control
{
    protected string PreviousText = "上一页";
    protected string NextText = "下一页";

    //...
}
```

Build it with Visual Studio 2015 and get a assembly.
Decompile the assembly with ILSpy and get the following garbage characters.

``` csharp
public class Pager : Control
{
    protected string PreviousText = "ÉÏÒ»Ò³";
    protected string NextText = "ÏÂÒ»Ò³";
    //...
}
```

View IL code with ildasm and get the following result.

```
.maxstack  2
IL_0000:  ldarg.0
IL_0001:  ldstr      bytearray (C9 00 CF 00 D2 00 BB 00 D2 00 B3 00 ) 
IL_0006:  stfld      string BlogServer.Web.Controls.Pager::PreviousText
IL_000b:  ldarg.0
IL_000c:  ldstr      bytearray (CF 00 C2 00 D2 00 BB 00 D2 00 B3 00 ) 
IL_0011:  stfld      string BlogServer.Web.Controls.Pager::NextText
```

If build it with Visual Studio 2013, get right Chinese string and the following IL code.

```
.maxstack  2
IL_0000:  ldarg.0
IL_0001:  ldstr      bytearray (0A 4E 00 4E 75 98 )                               // .N.Nu.
IL_0006:  stfld      string BlogServer.Web.Controls.Pager::PreviousText
IL_000b:  ldarg.0
IL_000c:  ldstr      bytearray (0B 4E 00 4E 75 98 )                               // .N.Nu.
IL_0011:  stfld      string BlogServer.Web.Controls.Pager::NextText
```
</Description>
        <CreatedDate>31/07/2015</CreatedDate>
        <ClosedDate>05/08/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>4222</IssueID>
        <Title>VS2015 (MSBuild/14) compiler can't detect file ecoding correctly</Title>
        <Description>The same project builds correctly in VS2013 (MSBuild\12.0\bin\Csc.exe) and fails in VS2015 (MSBuild\14.0\bin\csc.exe) compiler. The file has codepage set to "Codepage 1251" and the content is very simple:

```
class Program
{
    static void Main(string[] args)
    {
        int ч;
    }
}
```

VS2013 build it with the following command:

&gt; "C:\Program Files (x86)\MSBuild\12.0\bin\Csc.exe" /noconfig /nowarn:1701,1702,2008 /nostdlib+ /platform:anycpu32bitpreferred /errorreport:prompt /warn:4 /define:DEBUG;TRACE /errorendlocation /preferreduilang:en-US /highentropyva+ /reference:"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework.NETFramework\v4.5.2\Microsoft.CSharp.dll" /reference:"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework.NETFramework\v4.5.2\mscorlib.dll" /reference:"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework.NETFramework\v4.5.2\System.Core.dll" /reference:"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework.NETFramework\v4.5.2\System.Data.DataSetExtensions.dll" /reference:"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework.NETFramework\v4.5.2\System.Data.dll" /reference:"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework.NETFramework\v4.5.2\System.dll" /reference:"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework.NETFramework\v4.5.2\System.Net.Http.dll" /reference:"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework.NETFramework\v4.5.2\System.Xml.dll" /reference:"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework.NETFramework\v4.5.2\System.Xml.Linq.dll" /debug+ /debug:full /filealign:512 /optimize- /out:obj\Debug\CodepageTest.exe /subsystemversion:6.00 /target:exe /utf8output Program.cs Properties\AssemblyInfo.cs "C:\Users\pmuzyka\AppData\Local\Temp.NETFramework,Version=v4.5.2.AssemblyAttributes.cs" obj\Debug\TemporaryGeneratedFile_E7A71F73-0F8D-4B9B-B56E-8E70B10BC5D3.cs obj\Debug\TemporaryGeneratedFile_036C0B5B-1481-4323-8D20-8F5ADCB23D92.cs obj\Debug\TemporaryGeneratedFile_5937a670-0e60-4077-877b-f7221da3dda1.cs

And the VS2015:

&gt; "C:\Program Files (x86)\MSBuild\14.0\bin\csc.exe" /noconfig /nowarn:1701,1702,2008 /nostdlib+ /platform:anycpu32bitpreferred /errorreport:prompt /warn:4 /define:DEBUG;TRACE /errorendlocation /preferreduilang:en-US /highentropyva+ /reference:"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework.NETFramework\v4.5.2\Microsoft.CSharp.dll" /reference:"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework.NETFramework\v4.5.2\mscorlib.dll" /reference:"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework.NETFramework\v4.5.2\System.Core.dll" /reference:"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework.NETFramework\v4.5.2\System.Data.DataSetExtensions.dll" /reference:"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework.NETFramework\v4.5.2\System.Data.dll" /reference:"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework.NETFramework\v4.5.2\System.dll" /reference:"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework.NETFramework\v4.5.2\System.Net.Http.dll" /reference:"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework.NETFramework\v4.5.2\System.Xml.dll" /reference:"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework.NETFramework\v4.5.2\System.Xml.Linq.dll" /debug+ /debug:full /filealign:512 /optimize- /out:obj\Debug\CodepageTest.exe /ruleset:"C:\Program Files (x86)\Microsoft Visual Studio 14.0\Team Tools\Static Analysis Tools\Rule Sets\MinimumRecommendedRules.ruleset" /subsystemversion:6.00 /target:exe /utf8output Program.cs Properties\AssemblyInfo.cs "C:\Users\pmuzyka\AppData\Local\Temp.NETFramework,Version=v4.5.2.AssemblyAttributes.cs" obj\Debug\TemporaryGeneratedFile_E7A71F73-0F8D-4B9B-B56E-8E70B10BC5D3.cs obj\Debug\TemporaryGeneratedFile_036C0B5B-1481-4323-8D20-8F5ADCB23D92.cs obj\Debug\TemporaryGeneratedFile_5937a670-0e60-4077-877b-f7221da3dda1.cs

The output in the first case is:

&gt; Program.cs(13,17,13,18): warning CS0168: The variable 'ч' is declared but never used

The output in the second case is:

&gt; Program.cs(13,17,13,18): error CS1001: Identifier expected
&gt; Program.cs(13,17,13,17): error CS1056: Unexpected character '├╖'

The problem symbol is russian "ч".

Changing file codepage to UTF-8 solves the problem in VS2015, but I have to do this for all files in all my projects to use VS2015. It's wired.

So I supppose it's regression bug in the latest compiler.
</Description>
        <CreatedDate>30/07/2015</CreatedDate>
        <ClosedDate>05/08/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>4022</IssueID>
        <Title>.NET compiler produces incorrect string constants in MSIL when C# source files encoded with non-UTF-8 encoding</Title>
        <Description>.NET compiler produces incorrect string constants in MSIL (as compared to previous version,  even to VS 2015 RC)  when C# source files encoded with non-UTF-8 encoding (e.g. UTF-8 without BOM or windows-1251 (Russian)) and contains string constants in international language (e.g. Russian text). The source text file encoding seems not respected anymore and treated as ASCII when encoding is not UTF-8. 

The similar issue also has resource compiler (*.resx) result in generating incorrect source file.

The issue appears after a transition from VS 2015 RC to VS 2015. VS 2015 RC works as expected.

Visual Studio info:

Microsoft Visual Studio Enterprise 2015
Version 14.0.23107.0 D14REL
Microsoft .NET Framework
Version 4.6.00079

OS info:

Microsoft Windows 10 Pro /  Version 10.0.10240 Build 10240

**Steps to reproduce the issue:**

Create console project with following source file in windows-1251 encoding and compile it.

``` C#
using System;

namespace EncodingTest
{
    class Program
    {
        static void Main(string[] args)
        {
            string test = "Тестовая строка";
            Console.WriteLine(test);
        }
    }
}
```

[Ready to use solution](https://connect.microsoft.com/VisualStudio/Feedback/DownloadFile?downloadLink=2110cc92-d654-4d3e-8f44-050700a428f4%3BEncodingTest.zip)

**Expected results:**

``` C#
.method private hidebysig static void Main(string[] args) cil managed
{
    .entrypoint
    .maxstack 1
    .locals init (
        [0] string str)
    L_0000: nop 
    L_0001: ldstr "\u0422\u0435\u0441\u0442\u043e\u0432\u0430\u044f \u0441\u0442\u0440\u043e\u043a\u0430"
    L_0006: stloc.0 
    L_0007: ldloc.0 
    L_0008: call void [mscorlib]System.Console::WriteLine(string)
    L_000d: nop 
    L_000e: ret 
}
```

To emphasize:

``` C#
L_0001: ldstr "\u0422\u0435\u0441\u0442\u043e\u0432\u0430\u044f \u0441\u0442\u0440\u043e\u043a\u0430"
```

**Actual results:**

``` C#
.method private hidebysig static void Main(string[] args) cil managed
{
    .entrypoint
    .maxstack 1
    .locals init (
        [0] string str)
    L_0000: nop 
    L_0001: ldstr "\u00d2\u00e5\u00f1\u00f2\u00ee\u00e2\u00e0\u00ff \u00f1\u00f2\u00f0\u00ee\u00ea\u00e0"
    L_0006: stloc.0 
    L_0007: ldloc.0 
    L_0008: call void [mscorlib]System.Console::WriteLine(string)
    L_000d: nop 
    L_000e: ret 
}
```

To emphasize:

``` C#
L_0001: ldstr "\u00d2\u00e5\u00f1\u00f2\u00ee\u00e2\u00e0\u00ff \u00f1\u00f2\u00f0\u00ee\u00ea\u00e0"
```

[Microsoft Connect Entry](https://connect.microsoft.com/VisualStudio/feedback/details/1571354/net-compiler-produces-incorrect-string-constants-in-msil-when-c-source-files-encoded-with-non-utf-8-encoding)
</Description>
        <CreatedDate>21/07/2015</CreatedDate>
        <ClosedDate>05/08/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/Core/Portable/EncodedStringText.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>3986</IssueID>
    <Title>Make InteractiveWindow states explicit</Title>
    <Description>Instead of having a collection of boolean flags, introduce a State enum
that captures all of the possible states of the window and document
transitions between them.  Furthermore, assert that state transitions only
happen on the UI thread (for synchronization purposes).

Fixes #3970

TODO: The transitions to and from the ReadingStandardInput state are not
well understood/handled (#3984).

TODO: Integration test to follow.

_Note: You'll probably want to review the commits separately - I've tried to isolate the broad refactorings in the second one._
</Description>
    <CreatedDate>17/07/2015</CreatedDate>
    <ClosedDate>23/07/2015</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>3970</IssueID>
        <Title>Interactive window Reset button inserts an extra prompt</Title>
        <Description>Clicking the button prints `&gt; &gt; Reset` to the Interactive window.
</Description>
        <CreatedDate>15/07/2015</CreatedDate>
        <ClosedDate>23/07/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>3984</IssueID>
        <Title>Make StandardInput in InteractiveWindow thread-safe</Title>
        <Description>It can happen at any time and can be cancelled at any time and it's not clear that either operation is handled gracefully.

We'll probably need some info on the API's intended function from @DinoV. 
</Description>
        <CreatedDate>16/07/2015</CreatedDate>
        <ClosedDate>25/08/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/InteractiveWindow/Editor/Commands/ResetCommand.cs</File>
      <File>src/InteractiveWindow/Editor/InteractiveWindow.cs</File>
      <File>src/InteractiveWindow/Editor/InteractiveWindowResources.Designer.cs</File>
      <File>src/InteractiveWindow/Editor/InteractiveWindow_UIThread.cs</File>
      <File>src/InteractiveWindow/Editor/Output/OutputBuffer.cs</File>
      <File>src/InteractiveWindow/EditorTest/InteractiveWindowTestHost.cs</File>
      <File>src/InteractiveWindow/EditorTest/InteractiveWindowTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>3811</IssueID>
    <Title>[EnC] Update UnitTests to use resource strings</Title>
    <Description>Fix #1853 and #2657
</Description>
    <CreatedDate>02/07/2015</CreatedDate>
    <ClosedDate>02/07/2015</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>1853</IssueID>
        <Title>Roslyn.Services.Editor.CSharp.UnitTests.dll - 24 unit-test fail on Russian OS with localized resources present</Title>
        <Description>## See #821 for repro steps.

Assemblies Run

Roslyn.Services.Editor.CSharp.UnitTests.dll

Summary

Tests run: 11063   Failures: 24, Skipped: 52, Run time: 424.894s

Failed tests

0.020s
✘
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Lambdas_Insert_Catch1 : Actual: Diagnostic(RudeEditKind.InsertLambdaWithMultiScopeCapture, "x1", "!VQ1Yq!lambda ЁЧ!", "x0", "x1") Differences: ++&gt; Diagnostic(RudeEditKind.InsertLambdaWithMultiScopeCapture, "x1", "!VQ1Yq!lambda ЁЧ!", "x0", "x1") --&gt; Diagnostic(RudeEditKind.InsertLambdaWithMultiScopeCapture, "x1", "lambda", "x0", "x1") 
   в Xunit.Assert.True(Boolean condition, String userMessage)
   в Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:строка 256
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:строка 16
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:строка 301
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 83
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 72
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 63
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Lambdas_Insert_Catch1() в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:строка 3002

0.015s
✘
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Lambdas_Insert_For1 : Actual: Diagnostic(RudeEditKind.InsertLambdaWithMultiScopeCapture, "x2", "!VQ1Yq!lambda ЁЧ!", "x0", "x2") Differences: ++&gt; Diagnostic(RudeEditKind.InsertLambdaWithMultiScopeCapture, "x2", "!VQ1Yq!lambda ЁЧ!", "x0", "x2") --&gt; Diagnostic(RudeEditKind.InsertLambdaWithMultiScopeCapture, "x2", "lambda", "x0", "x2") 
   в Xunit.Assert.True(Boolean condition, String userMessage)
   в Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:строка 256
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:строка 16
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:строка 301
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 83
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 72
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 63
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Lambdas_Insert_For1() в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:строка 2814

0.007s
✘
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Lambdas_Insert_ForEach1 : Actual: Diagnostic(RudeEditKind.InsertLambdaWithMultiScopeCapture, "x1", "!VQ1Yq!lambda ЁЧ!", "x0", "x1") Differences: ++&gt; Diagnostic(RudeEditKind.InsertLambdaWithMultiScopeCapture, "x1", "!VQ1Yq!lambda ЁЧ!", "x0", "x1") --&gt; Diagnostic(RudeEditKind.InsertLambdaWithMultiScopeCapture, "x1", "lambda", "x0", "x1") 
   в Xunit.Assert.True(Boolean condition, String userMessage)
   в Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:строка 256
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:строка 16
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:строка 301
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 83
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 72
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 63
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Lambdas_Insert_ForEach1() в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:строка 2729

0.023s
✘
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Lambdas_Insert_ForEach2 : Actual: Diagnostic(RudeEditKind.InsertLambdaWithMultiScopeCapture, "x1", "!VQ1Yq!lambda ЁЧ!", "x0", "x1") Differences: ++&gt; Diagnostic(RudeEditKind.InsertLambdaWithMultiScopeCapture, "x1", "!VQ1Yq!lambda ЁЧ!", "x0", "x1") --&gt; Diagnostic(RudeEditKind.InsertLambdaWithMultiScopeCapture, "x1", "lambda", "x0", "x1") 
   в Xunit.Assert.True(Boolean condition, String userMessage)
   в Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:строка 256
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:строка 16
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:строка 301
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 83
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 72
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 63
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Lambdas_Insert_ForEach2() в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:строка 2768

0.034s
✘
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Lambdas_Insert_Switch1 : Actual: Diagnostic(RudeEditKind.InsertLambdaWithMultiScopeCapture, "x0", "!VQ1Yq!lambda ЁЧ!", "x2", "x0") Differences: ++&gt; Diagnostic(RudeEditKind.InsertLambdaWithMultiScopeCapture, "x0", "!VQ1Yq!lambda ЁЧ!", "x2", "x0") --&gt; Diagnostic(RudeEditKind.InsertLambdaWithMultiScopeCapture, "x0", "lambda", "x2", "x0") 
   в Xunit.Assert.True(Boolean condition, String userMessage)
   в Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:строка 256
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:строка 16
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:строка 301
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 83
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 72
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 63
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Lambdas_Insert_Switch1() в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:строка 2888

0.013s
✘
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Lambdas_Insert_Using1 : Actual: Diagnostic(RudeEditKind.InsertLambdaWithMultiScopeCapture, "x1", "!VQ1Yq!lambda ЁЧ!", "x0", "x1") Differences: ++&gt; Diagnostic(RudeEditKind.InsertLambdaWithMultiScopeCapture, "x1", "!VQ1Yq!lambda ЁЧ!", "x0", "x1") --&gt; Diagnostic(RudeEditKind.InsertLambdaWithMultiScopeCapture, "x1", "lambda", "x0", "x1") 
   в Xunit.Assert.True(Boolean condition, String userMessage)
   в Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:строка 256
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:строка 16
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:строка 301
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 83
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 72
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 63
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Lambdas_Insert_Using1() в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:строка 2946

0.025s
✘
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_AccessingCapturedTransparentIdentifier1 : Actual: Diagnostic(RudeEditKind.ChangingQueryLambdaType, "select", "!PEpxp!select clause ЁЧ!") Differences: ++&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "select", "!PEpxp!select clause ЁЧ!") --&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "select", "select clause") 
   в Xunit.Assert.True(Boolean condition, String userMessage)
   в Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:строка 256
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:строка 16
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:строка 301
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 83
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 72
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 63
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_AccessingCapturedTransparentIdentifier1() в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:строка 5591

0.045s
✘
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_AccessingCapturedTransparentIdentifier2 : Actual: Diagnostic(RudeEditKind.AccessingCapturedVariableInLambda, "a", "a", "!PEpxp!select clause ЁЧ!") Differences: ++&gt; Diagnostic(RudeEditKind.AccessingCapturedVariableInLambda, "a", "a", "!PEpxp!select clause ЁЧ!") --&gt; Diagnostic(RudeEditKind.AccessingCapturedVariableInLambda, "a", "a", "select clause") 
   в Xunit.Assert.True(Boolean condition, String userMessage)
   в Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:строка 256
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:строка 16
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:строка 301
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 83
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 72
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 63
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_AccessingCapturedTransparentIdentifier2() в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:строка 5633

0.009s
✘
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_AccessingCapturedTransparentIdentifier3 : Actual: Diagnostic(RudeEditKind.AccessingCapturedVariableInLambda, "a", "a", "!PEpxp!select clause ЁЧ!"), Diagnostic(RudeEditKind.AccessingCapturedVariableInLambda, "a", "a", "!VQ1Yq!lambda ЁЧ!") Differences: ++&gt; Diagnostic(RudeEditKind.AccessingCapturedVariableInLambda, "a", "a", "!PEpxp!select clause ЁЧ!"), ++&gt; Diagnostic(RudeEditKind.AccessingCapturedVariableInLambda, "a", "a", "!VQ1Yq!lambda ЁЧ!") --&gt; Diagnostic(RudeEditKind.AccessingCapturedVariableInLambda, "a", "a", "select clause"), --&gt; Diagnostic(RudeEditKind.AccessingCapturedVariableInLambda, "a", "a", "lambda") 
   в Xunit.Assert.True(Boolean condition, String userMessage)
   в Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:строка 256
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:строка 16
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:строка 301
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 83
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 72
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 63
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_AccessingCapturedTransparentIdentifier3() в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:строка 5673

0.013s
✘
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_NotAccessingCapturedTransparentIdentifier1 : Actual: Diagnostic(RudeEditKind.NotAccessingCapturedVariableInLambda, "select", "a", "!PEpxp!select clause ЁЧ!") Differences: ++&gt; Diagnostic(RudeEditKind.NotAccessingCapturedVariableInLambda, "select", "a", "!PEpxp!select clause ЁЧ!") --&gt; Diagnostic(RudeEditKind.NotAccessingCapturedVariableInLambda, "select", "a", "select clause") 
   в Xunit.Assert.True(Boolean condition, String userMessage)
   в Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:строка 256
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:строка 16
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:строка 301
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 83
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 72
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 63
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_NotAccessingCapturedTransparentIdentifier1() в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:строка 5716

0.009s
✘
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_NotAccessingCapturedTransparentIdentifier2 : Actual: Diagnostic(RudeEditKind.AccessingCapturedVariableInLambda, "a", "a", "!PEpxp!select clause ЁЧ!"), Diagnostic(RudeEditKind.AccessingCapturedVariableInLambda, "a", "a", "!VQ1Yq!lambda ЁЧ!") Differences: ++&gt; Diagnostic(RudeEditKind.AccessingCapturedVariableInLambda, "a", "a", "!PEpxp!select clause ЁЧ!"), ++&gt; Diagnostic(RudeEditKind.AccessingCapturedVariableInLambda, "a", "a", "!VQ1Yq!lambda ЁЧ!") --&gt; Diagnostic(RudeEditKind.AccessingCapturedVariableInLambda, "a", "a", "select clause"), --&gt; Diagnostic(RudeEditKind.AccessingCapturedVariableInLambda, "a", "a", "lambda") 
   в Xunit.Assert.True(Boolean condition, String userMessage)
   в Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:строка 256
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:строка 16
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:строка 301
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 83
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 72
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 63
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_NotAccessingCapturedTransparentIdentifier2() в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:строка 5756

0.006s
✘
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_From1 : Actual: Diagnostic(RudeEditKind.ChangingQueryLambdaType, "from", "!5xC22!from clause ЁЧ!") Differences: ++&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "from", "!5xC22!from clause ЁЧ!") --&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "from", "from clause") 
   в Xunit.Assert.True(Boolean condition, String userMessage)
   в Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:строка 256
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:строка 16
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:строка 301
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 83
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 72
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 63
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_From1() в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:строка 4800

0.008s
✘
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_GroupBy1 : Actual: Diagnostic(RudeEditKind.ChangingQueryLambdaType, "group", "!p4EYV!groupby clause ЁЧ!") Differences: ++&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "group", "!p4EYV!groupby clause ЁЧ!") --&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "group", "groupby clause") 
   в Xunit.Assert.True(Boolean condition, String userMessage)
   в Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:строка 256
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:строка 16
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:строка 301
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 83
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 72
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 63
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_GroupBy1() в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:строка 5146

0.017s
✘
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_GroupBy2 : Actual: Diagnostic(RudeEditKind.ChangingQueryLambdaType, "group", "!p4EYV!groupby clause ЁЧ!") Differences: ++&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "group", "!p4EYV!groupby clause ЁЧ!") --&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "group", "groupby clause") 
   в Xunit.Assert.True(Boolean condition, String userMessage)
   в Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:строка 256
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:строка 16
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:строка 301
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 83
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 72
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 63
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_GroupBy2() в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:строка 5181

0.009s
✘
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_Join1 : Actual: Diagnostic(RudeEditKind.ChangingQueryLambdaType, "join", "!j4Xqe!join clause ЁЧ!") Differences: ++&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "join", "!j4Xqe!join clause ЁЧ!") --&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "join", "join clause") 
   в Xunit.Assert.True(Boolean condition, String userMessage)
   в Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:строка 256
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:строка 16
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:строка 301
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 83
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 72
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 63
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_Join1() в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:строка 5006

0.073s
✘
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_Join2 : Actual: Diagnostic(RudeEditKind.ChangingQueryLambdaType, "join", "!j4Xqe!join clause ЁЧ!") Differences: ++&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "join", "!j4Xqe!join clause ЁЧ!") --&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "join", "join clause") 
   в Xunit.Assert.True(Boolean condition, String userMessage)
   в Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:строка 256
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:строка 16
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:строка 301
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 83
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 72
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 63
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_Join2() в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:строка 5041

0.011s
✘
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_Join3 : Actual: Diagnostic(RudeEditKind.ChangingQueryLambdaType, "join", "!j4Xqe!join clause ЁЧ!") Differences: ++&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "join", "!j4Xqe!join clause ЁЧ!") --&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "join", "join clause") 
   в Xunit.Assert.True(Boolean condition, String userMessage)
   в Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:строка 256
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:строка 16
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:строка 301
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 83
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 72
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 63
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_Join3() в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:строка 5076

0.007s
✘
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_Join4 : Actual: Diagnostic(RudeEditKind.ChangingQueryLambdaType, "join", "!j4Xqe!join clause ЁЧ!") Differences: ++&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "join", "!j4Xqe!join clause ЁЧ!") --&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "join", "join clause") 
   в Xunit.Assert.True(Boolean condition, String userMessage)
   в Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:строка 256
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:строка 16
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:строка 301
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 83
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 72
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 63
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_Join4() в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:строка 5111

0.006s
✘
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_Let1 : Actual: Diagnostic(RudeEditKind.ChangingQueryLambdaType, "let", "!KmPDb!let clause ЁЧ!") Differences: ++&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "let", "!KmPDb!let clause ЁЧ!") --&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "let", "let clause") 
   в Xunit.Assert.True(Boolean condition, String userMessage)
   в Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:строка 256
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:строка 16
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:строка 301
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 83
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 72
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 63
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_Let1() в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:строка 4901

0.028s
✘
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_OrderBy1 : Actual: Diagnostic(RudeEditKind.ChangingQueryLambdaType, "a + 1.0 descending", "!wIIAy!orderby clause ЁЧ!") Differences: ++&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "a + 1.0 descending", "!wIIAy!orderby clause ЁЧ!") --&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "a + 1.0 descending", "orderby clause") 
   в Xunit.Assert.True(Boolean condition, String userMessage)
   в Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:строка 256
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:строка 16
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:строка 301
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 83
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 72
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 63
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_OrderBy1() в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:строка 4936

0.008s
✘
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_OrderBy2 : Actual: Diagnostic(RudeEditKind.ChangingQueryLambdaType, "a + 2.0 ascending", "!wIIAy!orderby clause ЁЧ!") Differences: ++&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "a + 2.0 ascending", "!wIIAy!orderby clause ЁЧ!") --&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "a + 2.0 ascending", "orderby clause") 
   в Xunit.Assert.True(Boolean condition, String userMessage)
   в Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:строка 256
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:строка 16
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:строка 301
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 83
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 72
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 63
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_OrderBy2() в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:строка 4971

0.004s
✘
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_Select1 : Actual: Diagnostic(RudeEditKind.ChangingQueryLambdaType, "select", "!PEpxp!select clause ЁЧ!") Differences: ++&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "select", "!PEpxp!select clause ЁЧ!") --&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "select", "select clause") 
   в Xunit.Assert.True(Boolean condition, String userMessage)
   в Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:строка 256
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:строка 16
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:строка 301
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 83
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 72
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 63
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_Select1() в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:строка 4734

0.007s
✘
 Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_Select2 : Actual: Diagnostic(RudeEditKind.ChangingQueryLambdaType, "select", "!PEpxp!select clause ЁЧ!") Differences: ++&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "select", "!PEpxp!select clause ЁЧ!") --&gt; Diagnostic(RudeEditKind.ChangingQueryLambdaType, "select", "select clause") 
   в Xunit.Assert.True(Boolean condition, String userMessage)
   в Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:строка 256
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:строка 16
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:строка 301
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, IEnumerable`1 additionalOldSources, IEnumerable`1 additionalNewSources, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 83
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemantics(EditScript`1 editScript, ActiveStatementsDescription activeStatements, SemanticEditDescription[] expectedSemanticEdits, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 72
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.Extensions.VerifySemanticDiagnostics(EditScript`1 editScript, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\Helpers\Extensions.cs:строка 63
   в Microsoft.CodeAnalysis.CSharp.EditAndContinue.UnitTests.RudeEditStatementTests.Queries_Update_Signature_Select2() в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\EditAndContinue\RudeEditStatementTests.cs:строка 4767

0.013s
✘
 Microsoft.CodeAnalysis.Editor.CSharp.UnitTests.Completion.CompletionSetSources.SymbolCompletionProviderTests.MethodOverloadDifferencesIgnored_ExtensionMethod2 : Assert.Equal() Failure Position: First difference is at position 1 Expected: (extension) void C.Do(string x) Actual: (!Qfuzb!extension ЁЧ!) void C.Do(string x)
   в Xunit.Assert.Equal[T](T expected, T actual, IEqualityComparer`1 comparer)
   в Xunit.Assert.Equal[T](T expected, T actual)
   в Microsoft.CodeAnalysis.Editor.UnitTests.Completion.AbstractCompletionProviderTests`1.VerifyItemInLinkedFiles(String xmlString, String expectedItem, String expectedDescription) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\Completion\AbstractCompletionProviderTests.cs:строка 542
   в Microsoft.CodeAnalysis.Editor.CSharp.UnitTests.Completion.CompletionSetSources.SymbolCompletionProviderTests.MethodOverloadDifferencesIgnored_ExtensionMethod2() в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\CSharpTest\Completion\CompletionProviders\SymbolCompletionProviderTests.cs:строка 7026
</Description>
        <CreatedDate>07/04/2015</CreatedDate>
        <ClosedDate>02/07/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>2657</IssueID>
        <Title>Roslyn.Services.Editor.VisualBasic.UnitTests.dll - 2 tests fail in presence of localized resources</Title>
        <Description>Assemblies Run

Roslyn.Services.Editor.VisualBasic.UnitTests.dll

Summary

Tests run: 8323   Failures: 2, Skipped: 63, Run time: 276.222s

Failed tests

0.005s
✘
 Microsoft.CodeAnalysis.VisualBasic.EditAndContinue.UnitTests.ActiveStatementTests.ForEach_Update_Lambda2 : Actual: Diagnostic(RudeEditKind.UpdateAroundActiveStatement, "For Each a In G(Function(a) a)", "!VU3Qz!For Each statement ЁЧЫ!") Differences: ++&gt; Diagnostic(RudeEditKind.UpdateAroundActiveStatement, "For Each a In G(Function(a) a)", "!VU3Qz!For Each statement ЁЧЫ!") --&gt; Diagnostic(RudeEditKind.UpdateAroundActiveStatement, "For Each a In G(Function(a) a)", "For Each statement") 
   в Xunit.Assert.True(Boolean condition, String userMessage)
   в Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:строка 257
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:строка 16
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifyRudeDiagnostics(EditScript`1 editScript, ActiveStatementsDescription description, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:строка 125
   в Microsoft.CodeAnalysis.VisualBasic.EditAndContinue.UnitTests.Extensions.VerifyRudeDiagnostics(EditScript`1 editScript, ActiveStatementsDescription description, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\VisualBasicTest\EditAndContinue\Helpers\Extensions.vb:строка 39
   в Microsoft.CodeAnalysis.VisualBasic.EditAndContinue.UnitTests.ActiveStatementTests.ForEach_Update_Lambda2() в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\VisualBasicTest\EditAndContinue\ActiveStatementTests.vb:строка 2909

0.044s
✘
 Microsoft.CodeAnalysis.VisualBasic.EditAndContinue.UnitTests.ActiveStatementTests.SyncLock_Update_Lambda2 : Actual: Diagnostic(RudeEditKind.UpdateAroundActiveStatement, "SyncLock G(Function(a) a)", "!lp9Rs!SyncLock statement ЁЧЫ!") Differences: ++&gt; Diagnostic(RudeEditKind.UpdateAroundActiveStatement, "SyncLock G(Function(a) a)", "!lp9Rs!SyncLock statement ЁЧЫ!") --&gt; Diagnostic(RudeEditKind.UpdateAroundActiveStatement, "SyncLock G(Function(a) a)", "SyncLock statement") 
   в Xunit.Assert.True(Boolean condition, String userMessage)
   в Roslyn.Test.Utilities.AssertEx.SetEqual[T](IEnumerable`1 expected, IEnumerable`1 actual, IEqualityComparer`1 comparer, String message, String itemSeparator) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\Test\Utilities\AssertEx.cs:строка 257
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.Extensions.Verify(IEnumerable`1 diagnostics, String newSource, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\Extensions.cs:строка 16
   в Microsoft.CodeAnalysis.EditAndContinue.UnitTests.EditAndContinueTestHelpers.VerifyRudeDiagnostics(EditScript`1 editScript, ActiveStatementsDescription description, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\Test\EditAndContinue\EditAndContinueTestHelpers.cs:строка 125
   в Microsoft.CodeAnalysis.VisualBasic.EditAndContinue.UnitTests.Extensions.VerifyRudeDiagnostics(EditScript`1 editScript, ActiveStatementsDescription description, RudeEditDiagnosticDescription[] expectedDiagnostics) в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\VisualBasicTest\EditAndContinue\Helpers\Extensions.vb:строка 39
   в Microsoft.CodeAnalysis.VisualBasic.EditAndContinue.UnitTests.ActiveStatementTests.SyncLock_Update_Lambda2() в C:\Builds\Roslyn\Main-PerCheckin-Debug\src\Open\src\EditorFeatures\VisualBasicTest\EditAndContinue\ActiveStatementTests.vb:строка 2621
</Description>
        <CreatedDate>11/05/2015</CreatedDate>
        <ClosedDate>02/07/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/CSharpTest/EditAndContinue/RudeEditStatementTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>3793</IssueID>
    <Title>Revert "Make APIs related to scripting and interactive internal for RTM"</Title>
    <Description>This reverts commit 15443a233a4cfb400e349f40f9d265ec341998a2.

Conflicts:
- src/Compilers/CSharp/Portable/CommandLine/CommandLineParser.cs
- src/Compilers/CSharp/Portable/PublicAPI.txt
- src/Compilers/Core/Portable/PublicAPI.txt
- src/Compilers/VisualBasic/Portable/CommandLine/CommandLineParser.vb

Fixes #3786 and #2888.
</Description>
    <CreatedDate>01/07/2015</CreatedDate>
    <ClosedDate>02/07/2015</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>3786</IssueID>
        <Title>Symbols from previous submissions are squiggled in the Interactive Window</Title>
        <Description>![interactivewindow](https://cloud.githubusercontent.com/assets/10508071/8463620/ba1b15dc-1ff0-11e5-9e80-916bed37e725.png)

They bind, but they're not available via Completion and they're squiggled.  They're probably not available through the SemanticModel.
</Description>
        <CreatedDate>01/07/2015</CreatedDate>
        <ClosedDate>02/07/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>2888</IssueID>
        <Title>Reenable interactive tests after RTM snaps</Title>
        <Description>Some tests had to be disabled due to removal of public API.
</Description>
        <CreatedDate>19/05/2015</CreatedDate>
        <ClosedDate>02/07/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/CommandLine/CommandLineParser.cs</File>
      <File>src/Compilers/CSharp/Portable/Compilation/CSharpCompilation.cs</File>
      <File>src/Compilers/Core/Portable/CommandLine/CommonCommandLineArguments.cs</File>
      <File>src/Compilers/Core/Portable/CommandLine/CommonCommandLineParser.cs</File>
      <File>src/Compilers/Core/Portable/Compilation/Compilation.cs</File>
      <File>src/EditorFeatures/CSharpTest/Interactive/CodeActions/InteractiveIntroduceVariableTests.cs</File>
      <File>src/Features/CSharp/IntroduceVariable/CSharpIntroduceVariableService_IntroduceField.cs</File>
      <File>src/Features/Core/IntroduceVariable/AbstractIntroduceVariableService.State.cs</File>
      <File>src/Interactive/EditorFeatures/CSharp/Interactive/CSharpInteractiveEvaluator.cs</File>
      <File>src/Interactive/EditorFeatures/CSharp/Interactive/CSharpRepl.cs</File>
      <File>src/Interactive/Features/Interactive/Core/InteractiveHost.Service.cs</File>
      <File>src/Workspaces/CSharp/Portable/LanguageServices/CSharpCompilationFactoryService.cs</File>
      <File>src/Workspaces/CSharp/Portable/LanguageServices/CSharpHostBuildDataFactory.cs</File>
      <File>src/Workspaces/Core/Portable/FindSymbols/FindReferences/DependentProjectsFinder.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/Solution/Project.cs</File>
      <File>src/Workspaces/Core/Portable/Workspace/Solution/Solution.CompilationTracker.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>2950</IssueID>
    <Title>Numeric literals (binary and digit separators)</Title>
    <Description>This PR implements binary literals for C# and VB, as well as digit separators (underscores) for both C# and VB. It also implements a feature check and two /features flags for binary literals and digit separators, again for both C# and VB.

This implements proposals #215 and #216

Original PR [here](https://github.com/dotnet/roslyn/pull/2730), closed due to branching reorganization.

@gafter @jaredpar @VSadov @AlekseyTs @agocke Please review
</Description>
    <CreatedDate>20/05/2015</CreatedDate>
    <ClosedDate>23/07/2015</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>215</IssueID>
        <Title>Proposal: Binary literals</Title>
        <Description>There’s a relatively common request to add binary literals to C# and VB. For bitmasks (e.g. flag enums) this seems genuinely useful, but it would also be great just for educational purposes.

Binary literals would look like this:

``` c#
int nineteen = 0b10011;
```

Syntactically and semantically they are identical to hexadecimal literals, except for using `b`/`B` instead of `x`/`X`, having only digits `0` and `1` and being interpreted in base 2 instead of 16.

There’s little cost to implementing these, and little conceptual overhead to users of the language.
# Syntax

The grammar would be as follows:

&gt; _integer-literal:_
&gt; &amp;emsp;  ...
&gt; &amp;emsp;  _binary-integer-literal_
&gt; 
&gt; _binary-integer-literal:_
&gt; &amp;emsp;  `0b`  &amp;emsp;  _binary-digits_  &amp;emsp;  _integer-type-suffixopt_
&gt; &amp;emsp;  `0B`  &amp;emsp;  _binary-digits_  &amp;emsp;  _integer-type-suffixopt_
&gt; 
&gt; _binary-digits:_
&gt; &amp;emsp;  _binary-digit_
&gt; &amp;emsp;  _binary-digits_  &amp;emsp;  _binary-digit_
&gt; 
&gt; _binary-digit:_  &amp;emsp; one of
&gt; &amp;emsp;  `0`  `1`
</Description>
        <CreatedDate>03/02/2015</CreatedDate>
        <ClosedDate>27/03/2017</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>216</IssueID>
        <Title>Proposal: Digit separators</Title>
        <Description>Being able to group digits in large numeric literals would have great readability impact and no significant downside. 

Adding binary literals (#215) would increase the likelihood of numeric literals being long, so the two features enhance each other. 

We would follow Java and others, and use an underscore `_` as a digit separator. It would be able to occur everywhere in a numeric literal (except as the first and last character), since different groupings may make sense in different scenarios and especially for different numeric bases:

``` c#
int bin = 0b1001_1010_0001_0100;
int hex = 0x1b_a0_44_fe;
int dec = 33_554_432;
int weird = 1_2__3___4____5_____6______7_______8________9;
double real = 1_000.111_1e-1_000;
```

Any sequence of digits may be separated by underscores, possibly more than one underscore between two consecutive digits. They are allowed in decimals as well as exponents, but following the previous rule, they may not appear next to the decimal (`10_.0`), next to the exponent character (`1.1e_1`), or next to the type specifier (`10_f`). When used in binary and hexadecimal literals, they may not appear immediately following the `0x` or `0b`.

The syntax is straightforward, and the separators have no semantic impact - they are simply ignored.

This has broad value and is easy to implement.
</Description>
        <CreatedDate>03/02/2015</CreatedDate>
        <ClosedDate>07/03/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/CSharpResources.Designer.cs</File>
      <File>src/Compilers/CSharp/Portable/Errors/MessageID.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/CharacterInfo.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/Lexer.cs</File>
      <File>src/Compilers/CSharp/Portable/Parser/SyntaxParser.cs</File>
      <File>src/Compilers/CSharp/Test/Syntax/LexicalAndXml/LexicalTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>3425</IssueID>
    <Title>made us to re-analyze some part of solution when assembly name have c…</Title>
    <Description>…hanged.

this is PR for master for #3414.

see #3414 for more detail.

Fixes #3410 
</Description>
    <CreatedDate>10/06/2015</CreatedDate>
    <ClosedDate>11/06/2015</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>3414</IssueID>
        <Title>made us to re-analyze some part of solution when assembly name have c…</Title>
        <Description>…hanged.

Customer Impact:
User changed assembly name (hence assembly identity), but all internal visible types are not re-analyzed. which ends up us to either incorrectly not report inaccessible internal types or report inaccessible internal types which just became accessible.

the fix should let diagnostic service to correctly track p2p dependencies and re-analyze those projects on assembly name change.
</Description>
        <CreatedDate>10/06/2015</CreatedDate>
        <ClosedDate>11/06/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>3414</IssueID>
        <Title>made us to re-analyze some part of solution when assembly name have c…</Title>
        <Description>…hanged.

Customer Impact:
User changed assembly name (hence assembly identity), but all internal visible types are not re-analyzed. which ends up us to either incorrectly not report inaccessible internal types or report inaccessible internal types which just became accessible.

the fix should let diagnostic service to correctly track p2p dependencies and re-analyze those projects on assembly name change.
</Description>
        <CreatedDate>10/06/2015</CreatedDate>
        <ClosedDate>11/06/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>3410</IssueID>
        <Title>Solution crawler not triggering project analysis on project rename (after the 1st rename)</Title>
        <Description>1. Create an Analyzer + Fix project (say Analyzer2) and replace the analyzer code with the below code:
   
   ``` C#
   using System.Collections.Immutable;
   using Microsoft.CodeAnalysis;
   using Microsoft.CodeAnalysis.Diagnostics;
   
   namespace Analyzer2
   {
   [DiagnosticAnalyzer(LanguageNames.CSharp)]
   public class Analyzer2Analyzer : DiagnosticAnalyzer
   {
       public const string DiagnosticId = "Analyzer2";
   
       // You can change these strings in the Resources.resx file. If you do not want your analyzer to be localize-able, you can use regular strings for Title and MessageFormat.
       internal static readonly LocalizableString Title = "MyProjectDiagnostic";
       internal static readonly LocalizableString MessageFormat = "MyProjectName: '{0}'";
       internal const string Category = "Naming";
   
       internal static DiagnosticDescriptor Rule = new DiagnosticDescriptor(DiagnosticId, Title, MessageFormat, Category, DiagnosticSeverity.Warning, isEnabledByDefault: true);
   
       public override ImmutableArray&lt;DiagnosticDescriptor&gt; SupportedDiagnostics { get { return ImmutableArray.Create(Rule); } }
   
       public override void Initialize(AnalysisContext context)
       {
           context.RegisterCompilationAction(OnCompilationAction);
       }
   
       private void OnCompilationAction(CompilationAnalysisContext context)
       {
           context.ReportDiagnostic(Diagnostic.Create(Rule, Location.None, context.Compilation.AssemblyName));
       }
   }
   }
   ```
2. Build solution and install the generated analyzer VSIX.
3. Start a new VS instance and create a new C# class lib application, `ClassLibrary1`.
4. Wait for some time, you should see a diagnostic `MyProjectName: 'ClassLibrary1'` in the error list.
5. Open project property pages and rename the project assembly name to a new name, say `ClassLibrary2` and hit save.
6. Wait for few seconds and see that the error list diagnostic is updated to `MyProjectName: 'ClassLibrary2'`, as expected.
7. Now again go back to project property pages and rename the project assembly name to a new name, say `ClassLibrary3` and hit save..

**Got:** Error list diagnostic does not change even after waiting for a few minutes.
Try 7 again with older names or any new names, and the diagnostic never changes.

The root cause seems to be that Solution crawler is invoking [AnalyzerProjectAsync](http://source.roslyn.io/Microsoft.CodeAnalysis.Features/R/f828748c0ec79d64.html) for steps 2-6 but not from step 7 onwards, causing us to never re-trigger project analysis after the first rename.
</Description>
        <CreatedDate>10/06/2015</CreatedDate>
        <ClosedDate>11/06/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/EditorFeatures/Test/SolutionCrawler/WorkCoordinatorTests.cs</File>
      <File>src/Features/Core/SolutionCrawler/WorkCoordinator.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>3416</IssueID>
    <Title>Avoid crashes calculating rename declaration conflicts</Title>
    <Description>**Bug** Fixes #3303 Avoid crashes calculating rename declaration conflicts

**Customer Scenario**

The scenario is during inline rename if you introduce a method declaration conflict in a partial type in another file **and** the conflict location is in a document that is unchanged by the rename itself. For example, we crash when attempting to rename a method in a .xaml.cs file to "InitializeComponent". This can crash during inline rename even when typing _through_ any method name declared in another part of the partial type (in another file), so renaming "a" to "abc" can crash if the intermediate state of "ab" conflicts with a member as described above (this is what actually happened in the customer report).

**Fix Description** (from commit message)

This is a very similar crash to the one from #2352. This change reverts
the specific fix that was done for that bug and instead generally
ensures that all potential declaration conflict spans are calculated
into reverseMappedLocations before calling AddDeclarationConflictsAsync
when processing the project that contains the rename symbol's
declaration.

This also updates the
RenamedSpansTracker.GetResolutionTextSpan(TextSpan, DocumentId) test
hook, which maps original spans to post-rename spans, to correctly
handle documents that were not changed during the rename operation. This
change is needed because the RenamedSpansTracker does not track
unresolved conflicts in unmodified locations (see the similar existing
comment in InlineRenameReplacementInfo.GetNonComplexifiedReplacements
for confirmation of this), and changing that for "1.0 (stable)" is
potentially risky as many things query the state of the
RenamedSpansTracker.

**Testing done** 

A unit test was added for this scenario, and all existing tests pass. I can also have someone buddy test if needed.

**Potential Reviewers**: @Pilchie @jasonmalinowski @rchande @balajikris @basoundr @brettfo @jmarolf 
</Description>
    <CreatedDate>10/06/2015</CreatedDate>
    <ClosedDate>11/06/2015</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>3303</IssueID>
        <Title>VS2015RC, Unhandled exception/crash in Microsoft.CodeAnalysis.Workspaces.dll</Title>
        <Description>**Reduced Repro**

``` C#
// In Class1.cs
partial class C
{
    private static void M() // Rename M to Method
    {
        M();
    }
}

// In Class2.cs
partial class C
{
    private static void Method()
    {
    }
}
```

**Original Report**

Unhandled exception/crash in Microsoft.CodeAnalysis.Workspaces.dll
version: 1.00.0.50411
original location: C:\Program Files (x86)\Microsoft Visual Studio 14.0\Common7\IDE\PrivateAssemblies\Microsoft.CodeAnalysis.Workspaces.dll

i cant find F:\Builds\6272\Roslyn\Dev14RC-Signed-Release\src\Open\src\Workspaces\Core\Portable\obj\Release\Microsoft.CodeAnalysis.Workspaces.pdb

so that all, cheers ;} select code, right click, action, extract method

System.Transactions Critical: 0 : &lt;TraceRecord xmlns="http://schemas.microsoft.com/2004/10/E2ETraceEvent/TraceRecord" 

Severity="Critical"&gt;&lt;TraceIdentifier&gt;http://msdn.microsoft.com/TraceCodes/System/ActivityTracing/2004/07/Reliability/Exception/Unhandled&lt;/TraceIdentifier&gt;&lt;Description&gt;Unhandl

ed exception&lt;/Description&gt;&lt;AppDomain&gt;DefaultDomain&lt;/AppDomain&gt;&lt;Exception&gt;&lt;ExceptionType&gt;System.Collections.Generic.KeyNotFoundException, mscorlib, Version=4.0.0.0, 

Culture=neutral, PublicKeyToken=b77a5c561934e089&lt;/ExceptionType&gt;&lt;Message&gt;The given key was not present in the dictionary.&lt;/Message&gt;&lt;StackTrace&gt;   at 

System.Collections.Generic.Dictionary`2.get_Item(TKey key)
   at Microsoft.CodeAnalysis.CSharp.Rename.CSharpRenameConflictLanguageService.&amp;amp;lt;&amp;amp;gt;c__DisplayClass3_0.&amp;amp;lt;ComputeDeclarationConflictsAsync&amp;amp;gt;b__2

(Location t)
   at System.Linq.Enumerable.WhereSelectEnumerableIterator`2.MoveNext()
   at System.Collections.Generic.List`1.InsertRange(Int32 index, IEnumerable`1 collection)
   at System.Collections.Generic.List`1.AddRange(IEnumerable`1 collection)
   at Microsoft.CodeAnalysis.CSharp.Rename.CSharpRenameConflictLanguageService.&amp;amp;lt;ComputeDeclarationConflictsAsync&amp;amp;gt;d__3.MoveNext

()&lt;/StackTrace&gt;&lt;ExceptionString&gt;System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.
   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)
   at Microsoft.CodeAnalysis.CSharp.Rename.CSharpRenameConflictLanguageService.&amp;amp;lt;&amp;amp;gt;c__DisplayClass3_0.&amp;amp;lt;ComputeDeclarationConflictsAsync&amp;amp;gt;b__2

(Location t)
   at System.Linq.Enumerable.WhereSelectEnumerableIterator`2.MoveNext()
   at System.Collections.Generic.List`1.InsertRange(Int32 index, IEnumerable`1 collection)
   at System.Collections.Generic.List`1.AddRange(IEnumerable`1 collection)
   at Microsoft.CodeAnalysis.CSharp.Rename.CSharpRenameConflictLanguageService.&amp;amp;lt;ComputeDeclarationConflictsAsync&amp;amp;gt;d__3.MoveNext

()&lt;/ExceptionString&gt;&lt;/Exception&gt;&lt;/TraceRecord&gt;

-------------------------------- copy of callstack

&gt;   Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.ErrorReporting.FatalError.Report(System.Exception exception, System.Action&lt;System.Exception&gt; handler)  

Unknown
    Microsoft.CodeAnalysis.CSharp.Workspaces.dll!&lt;Unknown function&gt; Unknown
    [Native to Managed Transition]  
    mscorlib.dll!System.Collections.Generic.Dictionary&lt;System.__Canon, System.__Canon&gt;.this[System.__Canon].get(System.__Canon key) Unknown
    Microsoft.CodeAnalysis.CSharp.Workspaces.dll!

Microsoft.CodeAnalysis.CSharp.Rename.CSharpRenameConflictLanguageService.ComputeDeclarationConflictsAsync.AnonymousMethod__2(Microsoft.CodeAnalysis.Location t) Unknown
    System.Core.dll!System.Linq.Enumerable.WhereSelectEnumerableIterator&lt;Microsoft.CodeAnalysis.Location, Microsoft.CodeAnalysis.Location&gt;.MoveNext()   Unknown
    mscorlib.dll!System.Collections.Generic.List&lt;Microsoft.CodeAnalysis.Location&gt;.InsertRange(int index = 0, 

System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.Location&gt; collection) Unknown
    mscorlib.dll!System.Collections.Generic.List&lt;System.__Canon&gt;.AddRange(System.Collections.Generic.IEnumerable&lt;System.__Canon&gt; collection)    Unknown
    Microsoft.CodeAnalysis.CSharp.Workspaces.dll!&lt;Unknown function&gt; Unknown
    mscorlib.dll!

System.Runtime.CompilerServices.AsyncTaskMethodBuilder&lt;System.__Canon&gt;.Start&lt;Microsoft.CodeAnalysis.CSharp.Rename.CSharpRenameConflictLanguageService.&lt;ComputeDeclarationConfl

ictsAsync&gt;d__3&gt;(ref Microsoft.CodeAnalysis.CSharp.Rename.CSharpRenameConflictLanguageService.&lt;ComputeDeclarationConflictsAsync&gt;d__3 stateMachine)   Unknown
    Microsoft.CodeAnalysis.CSharp.Workspaces.dll!Microsoft.CodeAnalysis.CSharp.Rename.CSharpRenameConflictLanguageService.ComputeDeclarationConflictsAsync(string 

replacementText, Microsoft.CodeAnalysis.ISymbol renamedSymbol, Microsoft.CodeAnalysis.ISymbol renameSymbol, 

System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.ISymbol&gt; referencedSymbols, Microsoft.CodeAnalysis.Solution baseSolution, Microsoft.CodeAnalysis.Solution 

newSolution, System.Collections.Generic.IDictionary&lt;Microsoft.CodeAnalysis.Location, Microsoft.CodeAnalysis.Location&gt; reverseMappedLocations, 

System.Threading.CancellationToken cancellationToken)   Unknown
    Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.AddDeclarationConflictsAsync(Microsoft.CodeAnalysis.ISymbol 

renamedSymbol = Method void NanoLABas.CoreData.Validator.EntryValidator.STATUS_ANTIPASS(NanoLABas.PlateInfo plateInfo), Microsoft.CodeAnalysis.ISymbol renameSymbol = 

{Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolution}, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.ISymbol&gt; referencedSymbols = Count = 3, 

Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolution conflictResolution = IsCancellationRequested = false, 

System.Collections.Generic.IDictionary&lt;Microsoft.CodeAnalysis.Location, Microsoft.CodeAnalysis.Location&gt; reverseMappedLocations = Method void 

NanoLABas.CoreData.Validator.EntryValidator.NewMethod(NanoLABas.PlateInfo plateInfo), System.Threading.CancellationToken cancellationToken = Count = 0) Unknown
    mscorlib.dll!

System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start&lt;Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.&lt;AddDeclarationConflictsAsync&gt;d__9&gt;(ref 

Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.&lt;AddDeclarationConflictsAsync&gt;d__9 stateMachine)  Unknown
    Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.AddDeclarationConflictsAsync(Microsoft.CodeAnalysis.ISymbol 

renamedSymbol, Microsoft.CodeAnalysis.ISymbol renameSymbol, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.ISymbol&gt; referencedSymbols, 

Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolution conflictResolution, System.Collections.Generic.IDictionary&lt;Microsoft.CodeAnalysis.Location, 

Microsoft.CodeAnalysis.Location&gt; reverseMappedLocations, System.Threading.CancellationToken cancellationToken)  Unknown
    Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.Session.IdentifyConflictsAsync

(System.Collections.Generic.HashSet&lt;Microsoft.CodeAnalysis.DocumentId&gt; documentIds = Count = 1, Microsoft.CodeAnalysis.ProjectId projectId = 

{Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolution}, Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolution conflictResolution = (ProjectId, 
# ef9ab61b-7466-4cab-86c4-0016601ad7cf - D:\gits\v2\Core\CoreData\CoreData.csproj))  Unknown

```
mscorlib.dll!
```

System.Runtime.CompilerServices.AsyncTaskMethodBuilder&lt;bool&gt;.Start&lt;Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.Session.&lt;IdentifyConflictsAsync&gt;d__18&gt;(ref 

Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.Session.&lt;IdentifyConflictsAsync&gt;d__18 stateMachine)   Unknown
    Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.Session.IdentifyConflictsAsync

(System.Collections.Generic.HashSet&lt;Microsoft.CodeAnalysis.DocumentId&gt; documentIds, Microsoft.CodeAnalysis.ProjectId projectId, 

Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolution conflictResolution) Unknown
    Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.Session.ResolveConflictsAsync() Unknown
    mscorlib.dll!

System.Runtime.CompilerServices.AsyncTaskMethodBuilder&lt;System.__Canon&gt;.Start&lt;Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.Session.&lt;ResolveConflictsAsync&gt;d__1

7&gt;(ref Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.Session.&lt;ResolveConflictsAsync&gt;d__17 stateMachine) Unknown
    Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.Session.ResolveConflictsAsync() Unknown
    Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.ResolveConflictsAsync

(Microsoft.CodeAnalysis.Rename.RenameLocationSet renameLocationSet, string originalText, string replacementText, Microsoft.CodeAnalysis.Options.OptionSet optionSet, 

System.Threading.CancellationToken cancellationToken)   Unknown
    Microsoft.CodeAnalysis.EditorFeatures.dll!

Microsoft.CodeAnalysis.Editor.Implementation.InlineRename.AbstractEditorInlineRenameService.InlineRenameLocationSet.GetReplacementsAsync(string replacementText = 

"STATUS_ANTIPASS", Microsoft.CodeAnalysis.Options.OptionSet optionSet = {Microsoft.CodeAnalysis.Options.OptionSet}, System.Threading.CancellationToken cancellationToken = 

IsCancellationRequested = false)    Unknown
    mscorlib.dll!

System.Runtime.CompilerServices.AsyncTaskMethodBuilder&lt;System.__Canon&gt;.Start&lt;Microsoft.CodeAnalysis.Editor.Implementation.InlineRename.AbstractEditorInlineRenameService.Inlin

eRenameLocationSet.&lt;GetReplacementsAsync&gt;d__7&gt;(ref 

Microsoft.CodeAnalysis.Editor.Implementation.InlineRename.AbstractEditorInlineRenameService.InlineRenameLocationSet.&lt;GetReplacementsAsync&gt;d__7 stateMachine)    Unknown
    Microsoft.CodeAnalysis.EditorFeatures.dll!

Microsoft.CodeAnalysis.Editor.Implementation.InlineRename.AbstractEditorInlineRenameService.InlineRenameLocationSet.GetReplacementsAsync(string replacementText, 

Microsoft.CodeAnalysis.Options.OptionSet optionSet, System.Threading.CancellationToken cancellationToken)   Unknown
    Microsoft.CodeAnalysis.EditorFeatures.dll!

Microsoft.CodeAnalysis.Editor.Implementation.InlineRename.InlineRenameSession.UpdateConflictResolutionTask.AnonymousMethod__0() Unknown
    mscorlib.dll!

System.Runtime.CompilerServices.AsyncTaskMethodBuilder&lt;System.__Canon&gt;.Start&lt;Microsoft.CodeAnalysis.Editor.Implementation.InlineRename.InlineRenameSession.(ref 

Microsoft.CodeAnalysis.Editor.Implementation.InlineRename.InlineRenameSession.&lt;&gt;c__DisplayClass61_0.&lt;&lt;UpdateConflictResolutionTask&gt;b__0&gt;d stateMachine) Unknown
    Microsoft.CodeAnalysis.EditorFeatures.dll!

Microsoft.CodeAnalysis.Editor.Implementation.InlineRename.InlineRenameSession.UpdateConflictResolutionTask.AnonymousMethod__0() Unknown
    mscorlib.dll!System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;Microsoft.CodeAnalysis.Editor.IInlineRenameReplacementInfo&gt;&gt;.InnerInvoke() Unknown
    mscorlib.dll!System.Threading.Tasks.Task.Execute()  Unknown
    mscorlib.dll!System.Threading.Tasks.Task.ExecutionContextCallback(object obj)   Unknown
    mscorlib.dll!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object 

state, bool preserveSyncCtx)    Unknown
    mscorlib.dll!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state, bool 

preserveSyncCtx)    Unknown
    mscorlib.dll!System.Threading.Tasks.Task.ExecuteWithThreadLocal(ref System.Threading.Tasks.Task currentTaskSlot = Id = 328901, Status = Running, Method = 

"System.Threading.Tasks.Task`1[Microsoft.CodeAnalysis.Editor.IInlineRenameReplacementInfo] &lt;UpdateConflictResolutionTask&gt;b__0()", Result = "{Not yet computed}")    

Unknown
    mscorlib.dll!System.Threading.Tasks.Task.ExecuteEntry(bool bPreventDoubleExecution) Unknown
    mscorlib.dll!System.Threading.Tasks.Task.System.Threading.IThreadPoolWorkItem.ExecuteWorkItem() Unknown
    mscorlib.dll!System.Threading.ThreadPoolWorkQueue.Dispatch()    Unknown
    mscorlib.dll!System.Threading._ThreadPoolWaitCallback.PerformWaitCallback() Unknown
</Description>
        <CreatedDate>04/06/2015</CreatedDate>
        <ClosedDate>11/06/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>2352</IssueID>
        <Title>VS crash during inline rename: KeyNotFoundException</Title>
        <Description>**Reduced Repro**

``` C#
// In File1.cs
class Program
{
    internal void A() { } // Rename to B
    internal void B() { }
}

// In File2.cs
class Program2
{
    void M()
    {
        Program p = null;
        p.A();
        p.B();
    }
}
```

`Program` and `Program2` must be in the same project, and File1.cs must not contain any references to `A`.

**Original Repro from @tmat**

Crash dump and repro:
%internal_share%\public\tomat\Bugs\2352

Repro:
1) Unzip Repro.zip, open src\System.Reflection.Metadata\System.Reflection.Metadata.sln
2) Open TypeDefinition.cs, go to line 79
3) Rename `GetNamespaceString` to `GetNamespace`

```

Stack trace:
&gt;   Microsoft.CodeAnalysis.CSharp.Workspaces.dll!Microsoft.CodeAnalysis.CSharp.Rename.CSharpRenameConflictLanguageService.ComputeDeclarationConflictsAsync.AnonymousMethod__2(Microsoft.CodeAnalysis.Location t) Line 780   C#
    System.Core.dll!System.Linq.Enumerable.WhereSelectEnumerableIterator&lt;Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.Location&gt;.MoveNext() Line 285   C#
    mscorlib.dll!System.Collections.Generic.List&lt;Microsoft.CodeAnalysis.Location&gt;.InsertRange(int index, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.Location&gt; collection) Line 737   C#
    mscorlib.dll!System.Collections.Generic.List&lt;System.__Canon&gt;.AddRange(System.Collections.Generic.IEnumerable&lt;System.__Canon&gt; collection) Line 249   C#
    Microsoft.CodeAnalysis.CSharp.Workspaces.dll!Microsoft.CodeAnalysis.CSharp.Rename.CSharpRenameConflictLanguageService.ComputeDeclarationConflictsAsync(System.Collections.Generic.IDictionary&lt;Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.Location&gt; reverseMappedLocations, Microsoft.CodeAnalysis.ISymbol renamedSymbol, System.Threading.CancellationToken cancellationToken, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.ISymbol&gt; referencedSymbols, Microsoft.CodeAnalysis.Solution baseSolution, string replacementText) Line 785 C#
    Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.AddDeclarationConflictsAsync(Microsoft.CodeAnalysis.ISymbol renamedSymbol, Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolution conflictResolution, System.Collections.Generic.IDictionary&lt;Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.Location&gt; reverseMappedLocations, System.Threading.CancellationToken cancellationToken, Microsoft.CodeAnalysis.ISymbol renameSymbol, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.ISymbol&gt; referencedSymbols) Line 187    C#
    Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.Session.IdentifyConflictsAsync(System.Collections.Generic.HashSet&lt;Microsoft.CodeAnalysis.DocumentId&gt; documentIds, Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolution conflictResolution, Microsoft.CodeAnalysis.ProjectId projectId) Line 296  C#
    Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.Session.ResolveConflictsAsync() Line 128    C#
    Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.ResolveConflictsAsync(Microsoft.CodeAnalysis.Rename.RenameLocationSet renameLocationSet, string originalText, string replacementText, Microsoft.CodeAnalysis.Options.OptionSet optionSet, System.Threading.CancellationToken cancellationToken) Line 60 C#
    Microsoft.CodeAnalysis.EditorFeatures.dll!Microsoft.CodeAnalysis.Editor.Implementation.InlineRename.AbstractEditorInlineRenameService.InlineRenameLocationSet.GetReplacementsAsync(string replacementText, Microsoft.CodeAnalysis.Options.OptionSet optionSet, System.Threading.CancellationToken cancellationToken) Line 42    C#
    Microsoft.CodeAnalysis.EditorFeatures.dll!Microsoft.CodeAnalysis.Editor.Implementation.InlineRename.InlineRenameSession.UpdateConflictResolutionTask() Line 424 C#

```
</Description>
        <CreatedDate>29/04/2015</CreatedDate>
        <ClosedDate>28/05/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Workspaces/Core/Portable/Rename/ConflictEngine/ConflictResolver.Session.cs</File>
      <File>src/Workspaces/Core/Portable/Rename/ConflictEngine/RenamedSpansTracker.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>3308</IssueID>
    <Title>Public API checker should ignore protected members on uninheritable types</Title>
    <Description>Fixes #3287

@tmeschter **Can I please have your help with this?** I think this is the right set of code changes for the checker for #3287 (can you please review the changes?), but I don't know how to do the following remaining steps:
1. For purposes of hand-testing, replace the checker nuget with the one built here, and hand-check that the set of errors reported against the various `PublicApi.txt` are the expected ones
2. Produce a nuget package for the Roslyn API checker that reflects the changes here
3. Update the referenced nuget package for the checker to the one produced.

Once that is done we will need to submit a new/updated pull request that has these code changes, the updated PublicApi.txt, and the project changes to reference the newly created nuget package.
</Description>
    <CreatedDate>04/06/2015</CreatedDate>
    <ClosedDate>11/06/2015</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>3287</IssueID>
        <Title>Public API checker should ignore protected members on uninheritable types</Title>
        <Description>This concerns APIs which are `protected` on `public` types which can't be inherited from by customers.  In particular:
- Types which are `sealed`
- Types whose constructors are all `internal` or `private`

For such types the effective accessibility to customers is `internal`.  We should be free to modify, delete, etc ... those members post RTM.  The Public API checker should be updated to reflect that. 

---- Additions 2015-06-09 by @gafter ----

In addition we will give an **error** when an API occurs with the following pattern:
1. `Type1` is public but has only `internal` (no `public` or `protected`) constructors.
2. `Type2` extends `Type1`, is `public` and is not `sealed`, and has a `public` or `protected` constructor.

In that case the public API checker will report an error on each offending constructor in `Type2`. The reason is that `Type2` might be exposing members of `Type1` that are not considered part of the public API of `Type1`. To put it another way, `Type1` is considered "not inheritable by customers" but `Type2` violates that by making it inheritable.
</Description>
        <CreatedDate>03/06/2015</CreatedDate>
        <ClosedDate>11/06/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>3287</IssueID>
        <Title>Public API checker should ignore protected members on uninheritable types</Title>
        <Description>This concerns APIs which are `protected` on `public` types which can't be inherited from by customers.  In particular:
- Types which are `sealed`
- Types whose constructors are all `internal` or `private`

For such types the effective accessibility to customers is `internal`.  We should be free to modify, delete, etc ... those members post RTM.  The Public API checker should be updated to reflect that. 

---- Additions 2015-06-09 by @gafter ----

In addition we will give an **error** when an API occurs with the following pattern:
1. `Type1` is public but has only `internal` (no `public` or `protected`) constructors.
2. `Type2` extends `Type1`, is `public` and is not `sealed`, and has a `public` or `protected` constructor.

In that case the public API checker will report an error on each offending constructor in `Type2`. The reason is that `Type2` might be exposing members of `Type1` that are not considered part of the public API of `Type1`. To put it another way, `Type1` is considered "not inheritable by customers" but `Type2` violates that by making it inheritable.
</Description>
        <CreatedDate>03/06/2015</CreatedDate>
        <ClosedDate>11/06/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Diagnostics/Roslyn/Core/ApiDesign/DeclarePublicAPIAnalyzer.cs</File>
      <File>src/Diagnostics/Roslyn/Core/RoslynDiagnosticIds.cs</File>
      <File>src/Diagnostics/Roslyn/Core/RoslynDiagnosticsResources.Designer.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>3288</IssueID>
    <Title>Refactor Compilation to pull features from ParseOptions</Title>
    <Description>As discussed in #3232 and #3261, this PR "removes" the Features property from CompilationOptions, and makes Compilation pull features from ParseOptions instead of CompilationOptions.

(It doesn't actually remove the property, just all references to it and marks it with an obsolete attribute - once the PublicAPI.txt is updated with the new generator, then it can be removed properly.)

Many unit tests depended on CompilationOptions having a features property and Compilation pulling from it. These all had to be refactored to pass in the feature to ParseOptions instead, which is the reason for the large number of file changes.

The two concerns in the two PRs mentioned above were fixed: the two extra constructors were deleted, and features are now parsed properly (with equals signs and commas in the flag specifier).

@gafter @jaredpar @VSadov @AlekseyTs @agocke Please review.
</Description>
    <CreatedDate>03/06/2015</CreatedDate>
    <ClosedDate>04/06/2015</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>3232</IssueID>
        <Title>Add features flag support to parse options</Title>
        <Description>CSharpParseOptions was hardcoded to reject any /features flags passed in, and any unit tests that used feature flags. This PR changes that, which is required for any future C#7 experimental language features, as well as use sites of feature flags.

There is a stub in MessageID.cs where feature flag strings can be defined.

@gafter @jaredpar @VSadov @AlekseyTs @agocke Please review.
</Description>
        <CreatedDate>01/06/2015</CreatedDate>
        <ClosedDate>03/06/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>3261</IssueID>
        <Title>Add features flag support to parse options for VB</Title>
        <Description>This is the VB dual of #3232

This enables ParseOptions to accept feature flags, as well as adding the corresponding check in Parser.vb.

There is a stub where flag strings can be added in ParserFeature.vb

@gafter @jaredpar @VSadov @AlekseyTs @agocke Please review.
</Description>
        <CreatedDate>02/06/2015</CreatedDate>
        <ClosedDate>03/06/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/CSharpCompilationOptions.cs</File>
      <File>src/Compilers/CSharp/Portable/CSharpParseOptions.cs</File>
      <File>src/Compilers/CSharp/Portable/CommandLine/CommandLineParser.cs</File>
      <File>src/Compilers/CSharp/Test/CommandLine/CommandLineTests.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/BreakingChanges.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenOptimizedNullableOperators.cs</File>
      <File>src/Compilers/CSharp/Test/Emit/Emit/DeterministicTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/FlowAnalysis/StructTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/LockTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/OperatorTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/OverloadResolutionTests.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/SemanticErrorTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Compilation/CSharpCompilationOptionsTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/AnonymousTypesSemanticsTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/AnonymousTypesSymbolTests.cs</File>
      <File>src/Compilers/CSharp/Test/Symbol/Symbols/SymbolErrorTests.cs</File>
      <File>src/Compilers/CSharp/Test/WinRT/CodeGen/WinMdEventTests.cs</File>
      <File>src/Compilers/Core/Portable/CommandLine/CommonCommandLineParser.cs</File>
      <File>src/Compilers/Core/Portable/Compilation/Compilation.cs</File>
      <File>src/Compilers/Core/Portable/Compilation/CompilationOptions.cs</File>
      <File>src/Compilers/Test/Utilities/CSharp/BasicCompilationUtils.cs</File>
      <File>src/Compilers/Test/Utilities/CSharp/CSharpTestBase.cs</File>
      <File>src/Compilers/Test/Utilities/CSharp/TestOptions.cs</File>
      <File>src/Test/Utilities/CommonTestBase.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>3268</IssueID>
    <Title>Bug3092</Title>
    <Description>Fixes #3092 

There are two different ways to get token/lines to align with each other in a formatting rule. One is to use the align tokens operation and the other is to use the block indentation operation. Unfortunately, the align token operation is not property plumbed all the way down to the trivia formatters that get used when there are intervening comments, so it gets ignored and ends up aligning against the indentation rules. Ideally, this would get fixed so that the alignment operation is honored. However, this problem can also be fixed by switching to using a block indentation operation like xml literal blocks use.

@heejaechang @Pilchie please review  (already reviewed as #3128 against stabilization branch)
</Description>
    <CreatedDate>02/06/2015</CreatedDate>
    <ClosedDate>02/06/2015</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>3092</IssueID>
        <Title>VB prettylister gets indent wrong for "End Sub" of a multiline lambda whose final line is a comment</Title>
        <Description>In VB, if I have a multiline lambda whose last line is a comment, then it gets the spacing of the final "End Sub" incorrect.

REPRO:
![vb-prettylist](https://cloud.githubusercontent.com/assets/3316258/7822413/2d533c72-03aa-11e5-8202-373493fd3996.png)

Look at the above code. Try typing in a space or two or three spaces in front of either "End Sub" line, and then cursor off.

WHAT I EXPECT: the End Sub should snap to directly underneath the "Sub".
WHAT I GET: the End Sub snaps back to the start of the line.

Note that this problem doesn't repro if you put in enough spaces to have the End Sub directly line up under the Sub. In that case the End Sub stays exactly where you put it.

This problem also doesn't repro if the final line of the sub isn't a multiline comment.

(I haven't tried to see what happens with empty lines).
</Description>
        <CreatedDate>26/05/2015</CreatedDate>
        <ClosedDate>02/06/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>3128</IssueID>
        <Title>Use block indentation not token alignment rule for multiline lambdas</Title>
        <Description>Fixes #3092 

There are two different ways to get token/lines to align with each other in a formatting rule.  One is to use the align tokens operation and the other is to use the block indentation operation.  Unfortunately, the align token operation is not property plumbed all the way down to the trivia formatters that get used when there are intervening comments, so it gets ignored and ends up aligning against the indentation rules. Ideally, this would get fixed so that the alignment operation is honored.  However, this problem can also be fixed by switching to using a block indentation operation like xml literal blocks use.

@heejaechang @Pilchie please review
</Description>
        <CreatedDate>27/05/2015</CreatedDate>
        <ClosedDate>02/06/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Workspaces/CoreTest/CodeCleanup/AddMissingTokensTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>3247</IssueID>
    <Title>make formatting performance better</Title>
    <Description>this performance improvement is particularly for devdiv bug # 1089540

this makes the file in the bug to be formatted in several seconds compared to several minutes on my machine.

there were several issues. each one fixed by
#1, use concurrency on gathering operations.
#2, don't use too much time to split work to chunks if that requires more work than actually formatting.
#3, don't blindly set beginning of a file as inseparable start point for certain formatting options.

...

but these don't actually address the most impactful root cause of this perf issues. which is perf issue of GetPrevious/GetNextToken API in compiler.
(https://github.com/dotnet/roslyn/issues/3244)

formatter internally uses GetDescendantTokens to get all tokens at once and cache them which takes less than 1 second for the entire file (2M bytes size) in the bug. and use the cache internally.

but certain part of formatter (Rule Provider) can't use that internal cache, so it has to use the GetPrevious/GetNextToken to move around tokens, which in this particular bug, takes more than 40 seconds on my machine. and that is not even for entire file. (less than 1/12 of tokens)

I opened a bug to compiler team, hopely so that we can get better perf on those APIs.

in this PR, I mitigated the issue either by making more things to run concurrently or by changing logic which requires those APIs.
</Description>
    <CreatedDate>02/06/2015</CreatedDate>
    <ClosedDate>04/06/2015</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>1</IssueID>
        <Title>Initial port and addition of README.md</Title>
        <Description>This is a port of the readme from CodePlex.  Some of the links have been updated to point to locations on GitHub, but many of the links still point back to CodePlex as comparable GitHub locations are currently absent.
</Description>
        <CreatedDate>14/01/2015</CreatedDate>
        <ClosedDate>14/01/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>2</IssueID>
        <Title>Update links in README.md with ported wiki content</Title>
        <Description>
        </Description>
        <CreatedDate>14/01/2015</CreatedDate>
        <ClosedDate>14/01/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>3</IssueID>
        <Title>Add symbol files(.pdb/source) to NuGet packages</Title>
        <Description>It would be nice to be able to step inside Roslyn code when using NuGet packages.

This is nice guide on how to do this:
http://blog.davidebbo.com/2011/04/easy-way-to-publish-nuget-packages-with.html

&lt;!---
@huboard:{"order":6.0}
--&gt;
</Description>
        <CreatedDate>15/01/2015</CreatedDate>
        <ClosedDate>08/11/2017</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Workspaces/Core/Portable/Formatting/Context/FormattingContext.cs</File>
      <File>src/Workspaces/Core/Portable/Formatting/Engine/AbstractFormatEngine.Partitioner.cs</File>
      <File>src/Workspaces/Core/Portable/Formatting/Engine/AbstractFormatEngine.cs</File>
      <File>src/Workspaces/Core/Portable/Log/FunctionId.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>3227</IssueID>
    <Title>Pass correct itemIDs to IVsSymbolicNavigationNotify</Title>
    <Description>Retargeted to stabilization (originally reviewed at #2975)

Partial fix for internal TFS bug #1169405

We previously always passed Nil for all itemidCodeFile parameters in IVsSymbolicNavigationNotify to ensure the XAML language service heard our request (because their current implementation only processes request for Nil or 0-valued itemids.) This caused Go To Definition and Find All References to be slower than necessary in non-XAML cases and also resulted in unwanted behaviors on certain properties that are referenced in XAML.

Our two options for fixing this were to either:
1. Update our implementation to send the correct item ids for heuristically "non-generated" files and send Nil for "generated" files (to match the Dev12 behavior)
2. Always send the actual item ids, even for "generated" files, and update the XAML language service to do a fast initial check of the corresponding document to see if they're interested in processing it.

This changeset represents the Roslyn half of option 2. Any builds that contain this fix but do not contain the corresponding change to the XAML language service will see no Go To Definition navigation to .xaml files (e.g. when navigating from a reference to a named Button) and no .xaml file entries in Find All References.

Unfortunately, this does not remove all heuristics from this algorithm, because Roslyn must still decide which itemid to pass in the case of a definition spanning multiple documents (e.g. the MainWindow class created in default WPF projects). We always prefer the "generated" documents to give external language services the best opportunity to participate.

This change also adds asserts to verify all itemID handling during Rename &amp; Navigation happens on the UI thread.
</Description>
    <CreatedDate>01/06/2015</CreatedDate>
    <ClosedDate>02/06/2015</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>2975</IssueID>
        <Title>Pass correct itemIDs to IVsSymbolicNavigationNotify</Title>
        <Description>Partial fix for internal TFS bug #1169405

We previously always passed Nil for all itemidCodeFile parameters in IVsSymbolicNavigationNotify to ensure the XAML language service heard our request (because their current implementation only processes request for Nil or 0-valued itemids.) This caused Go To Definition and Find All References to be slower than necessary in non-XAML cases and also resulted in unwanted behaviors on certain properties that are referenced in XAML.

Our two options for fixing this were to either:
1. Update our implementation to send the correct item ids for heuristically "non-generated" files and send Nil for "generated" files (to match the Dev12 behavior)
2. Always send the actual item ids, even for "generated" files, and update the XAML language service to do a fast initial check of the corresponding document to see if they're interested in processing it.

This changeset represents the Roslyn half of option 2. Any builds that contain this fix but do not contain the corresponding change to the XAML language service will see no Go To Definition navigation to .xaml files (e.g. when navigating from a reference to a named Button) and no .xaml file entries in Find All References.

Unfortunately, this does not remove _all_ heuristics from this algorithm, because Roslyn must still decide which itemid to pass in the case of a definition spanning multiple documents (e.g. the MainWindow class created in default WPF projects). We always prefer the "generated" documents to give external language services the best opportunity to participate.

This change also adds asserts to verify all itemID handling during Rename &amp; Navigation happens on the UI thread.
</Description>
        <CreatedDate>21/05/2015</CreatedDate>
        <ClosedDate>01/06/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/DocumentProvider.StandardTextDocument.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Venus/ContainedDocument.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/VsRefactorNotifyService.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Workspace/VisualStudioSymbolNavigationService.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>2682</IssueID>
    <Title>A method declared with __arglist is not a candidate with a keyword argument list</Title>
    <Description>Fixes #2631

This repairs the compiler crash reported in #2631. The problem was we were not preventing an __arglist method from being considered a candidate when the argument list uses keyword notation. That ain't never gonna work because there would be no way to specify the __arglist parameter (it has no name).

@VSadov @AlekseyTs @agocke Please review.
</Description>
    <CreatedDate>12/05/2015</CreatedDate>
    <ClosedDate>13/05/2015</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>2631</IssueID>
        <Title>Crash with IndexOutOfRangeException in OverloadResolution.IsApplicable during SimplifyTypeNamesDiagnosticAnalyzer analysis</Title>
        <Description>Paste C# code:

``` C#
class C
{
    void M()
    {
        System.Console.WriteLine("", arg0: 0, arg1: 0, arg2: 0, );
    }
}
```

There's an assert and a crashing exception, both pasted below. First, the assert:

```
System.Exception: ASSERT FAILED 
5/10/2015 4:31:38 PM
Source:    at Roslyn.Editor.TestApp.OutputWindowTraceListener.Fail(String message, String detailMessage) in C:\Roslyn\Main\Closed\Hosting\EditorTestApp\UI\ToolWindows\Output\OutputWindowTraceListener.cs:line 50
   at System.Diagnostics.TraceListener.Fail(String message)
   at System.Diagnostics.TraceInternal.Fail(String message)
   at System.Diagnostics.Debug.Assert(Boolean condition)
   at Microsoft.CodeAnalysis.CSharp.OverloadResolution.IsApplicable(Symbol candidate, EffectiveParameters parameters, AnalyzedArguments arguments, ImmutableArray`1 argsToParameters, Boolean isVararg, Boolean hasAnyRefOmittedArgument, Boolean ignoreOpenTypes, HashSet`1&amp; useSiteDiagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolution.cs:line 2582
   at Microsoft.CodeAnalysis.CSharp.OverloadResolution.IsApplicable[TMember](TMember member, TMember leastOverriddenMember, ArrayBuilder`1 typeArgumentsBuilder, AnalyzedArguments arguments, EffectiveParameters originalEffectiveParameters, EffectiveParameters constructedEffectiveParameters, ImmutableArray`1 argsToParamsMap, Boolean hasAnyRefOmittedArgument, HashSet`1&amp; useSiteDiagnostics, Boolean inferWithDynamic) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolution.cs:line 2504
   at Microsoft.CodeAnalysis.CSharp.OverloadResolution.IsMemberApplicableInNormalForm[TMember](TMember member, TMember leastOverriddenMember, ArrayBuilder`1 typeArguments, AnalyzedArguments arguments, Boolean isMethodGroupConversion, Boolean allowRefOmittedArguments, Boolean inferWithDynamic, HashSet`1&amp; useSiteDiagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolution.cs:line 2325
   at Microsoft.CodeAnalysis.CSharp.OverloadResolution.AddMemberToCandidateSet[TMember](TMember member, ArrayBuilder`1 results, ArrayBuilder`1 members, ArrayBuilder`1 typeArguments, AnalyzedArguments arguments, Boolean completeResults, Boolean isMethodGroupConversion, Boolean allowRefOmittedArguments, Dictionary`2 containingTypeMapOpt, Boolean inferWithDynamic, HashSet`1&amp; useSiteDiagnostics, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolution.cs:line 495
   at Microsoft.CodeAnalysis.CSharp.OverloadResolution.PerformMemberOverloadResolution[TMember](ArrayBuilder`1 results, ArrayBuilder`1 members, ArrayBuilder`1 typeArguments, AnalyzedArguments arguments, Boolean completeResults, Boolean isMethodGroupConversion, Boolean allowRefOmittedArguments, HashSet`1&amp; useSiteDiagnostics, Boolean inferWithDynamic, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolution.cs:line 233
   at Microsoft.CodeAnalysis.CSharp.OverloadResolution.MethodOrPropertyOverloadResolution[TMember](ArrayBuilder`1 members, ArrayBuilder`1 typeArguments, AnalyzedArguments arguments, OverloadResolutionResult`1 result, Boolean isMethodGroupConversion, Boolean allowRefOmittedArguments, HashSet`1&amp; useSiteDiagnostics, Boolean inferWithDynamic, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolution.cs:line 136
   at Microsoft.CodeAnalysis.CSharp.OverloadResolution.MethodInvocationOverloadResolution(ArrayBuilder`1 methods, ArrayBuilder`1 typeArguments, AnalyzedArguments arguments, OverloadResolutionResult`1 result, HashSet`1&amp; useSiteDiagnostics, Boolean isMethodGroupConversion, Boolean allowRefOmittedArguments, Boolean inferWithDynamic, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolution.cs:line 101
   at Microsoft.CodeAnalysis.CSharp.Binder.ResolveDefaultMethodGroup(BoundMethodGroup node, AnalyzedArguments analyzedArguments, Boolean isMethodGroupConversion, HashSet`1&amp; useSiteDiagnostics, Boolean inferWithDynamic, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 6254
   at Microsoft.CodeAnalysis.CSharp.Binder.ResolveMethodGroupInternal(BoundMethodGroup methodGroup, CSharpSyntaxNode expression, String methodName, AnalyzedArguments analyzedArguments, Boolean isMethodGroupConversion, HashSet`1&amp; useSiteDiagnostics, Boolean inferWithDynamic, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 6147
   at Microsoft.CodeAnalysis.CSharp.Binder.ResolveMethodGroup(BoundMethodGroup node, CSharpSyntaxNode expression, String methodName, AnalyzedArguments analyzedArguments, Boolean isMethodGroupConversion, HashSet`1&amp; useSiteDiagnostics, Boolean inferWithDynamic, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 6122
   at Microsoft.CodeAnalysis.CSharp.Binder.BindMethodGroupInvocation(CSharpSyntaxNode syntax, CSharpSyntaxNode expression, String methodName, BoundMethodGroup methodGroup, AnalyzedArguments analyzedArguments, DiagnosticBag diagnostics, CSharpSyntaxNode queryClause, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Invocation.cs:line 452
   at Microsoft.CodeAnalysis.CSharp.Binder.BindInvocationExpression(CSharpSyntaxNode node, CSharpSyntaxNode expression, String methodName, BoundExpression boundExpression, AnalyzedArguments analyzedArguments, DiagnosticBag diagnostics, CSharpSyntaxNode queryClause, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Invocation.cs:line 222
   at Microsoft.CodeAnalysis.CSharp.Binder.BindInvocationExpression(InvocationExpressionSyntax node, DiagnosticBag diagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Invocation.cs:line 165
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 408
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpression(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 353
   at Microsoft.CodeAnalysis.CSharp.Binder.BindValue(ExpressionSyntax node, DiagnosticBag diagnostics, BindValueKind valueKind) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 288
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionStatement(CSharpSyntaxNode node, ExpressionSyntax syntax, Boolean allowsAnyExpression, DiagnosticBag diagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 418
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionStatement(ExpressionStatementSyntax node, DiagnosticBag diagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 411
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 49
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.IncrementalBinder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs:line 1639
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs:line 1996
   at Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\MethodBodySemanticModel.cs:line 48
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs:line 1397
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLowerBoundNode(CSharpSyntaxNode node) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs:line 369
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node, CSharpSyntaxNode&amp; bindableNode, BoundNode&amp; lowestBoundNode, BoundNode&amp; highestBoundNode, BoundNode&amp; boundParent) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs:line 896
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetSymbolInfoWorker(CSharpSyntaxNode node, SymbolInfoOptions options, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs:line 775
   at Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetSymbolInfoWorker(CSharpSyntaxNode node, SymbolInfoOptions options, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs:line 173
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(ExpressionSyntax expression, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs:line 504
   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\CSharpExtensions.cs:line 443
   at Microsoft.CodeAnalysis.CSharp.Extensions.ExpressionSyntaxExtensions.TryReplaceWithAlias(ExpressionSyntax node, SemanticModel semanticModel, Boolean preferAliasToQualifiedName, CancellationToken cancellationToken, IAliasSymbol&amp; aliasReplacement) in C:\Roslyn\Main\Open\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs:line 868
   at Microsoft.CodeAnalysis.CSharp.Extensions.ExpressionSyntaxExtensions.TryReduce(MemberAccessExpressionSyntax memberAccess, SemanticModel semanticModel, TypeSyntax&amp; replacementNode, TextSpan&amp; issueSpan, OptionSet optionSet, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs:line 722
   at Microsoft.CodeAnalysis.CSharp.Extensions.ExpressionSyntaxExtensions.TryReduceExplicitName(ExpressionSyntax expression, SemanticModel semanticModel, TypeSyntax&amp; replacementNode, TextSpan&amp; issueSpan, OptionSet optionSet, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs:line 665
   at Microsoft.CodeAnalysis.CSharp.Extensions.ExpressionSyntaxExtensions.TryReduceOrSimplifyExplicitName(ExpressionSyntax expression, SemanticModel semanticModel, ExpressionSyntax&amp; replacementNode, TextSpan&amp; issueSpan, OptionSet optionSet, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs:line 637
   at Microsoft.CodeAnalysis.CSharp.Diagnostics.SimplifyTypeNames.CSharpSimplifyTypeNamesDiagnosticAnalyzer.CanSimplifyTypeNameExpression(SemanticModel model, SyntaxNode node, OptionSet optionSet, TextSpan&amp; issueSpan, String&amp; diagnosticId, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Features\CSharp\Diagnostics\Analyzers\CSharpSimplifyTypeNamesDiagnosticAnalyzer.cs:line 132
   at Microsoft.CodeAnalysis.CSharp.Diagnostics.SimplifyTypeNames.CSharpSimplifyTypeNamesDiagnosticAnalyzer.CanSimplifyTypeNameExpressionCore(SemanticModel model, SyntaxNode node, OptionSet optionSet, TextSpan&amp; issueSpan, String&amp; diagnosticId, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Features\CSharp\Diagnostics\Analyzers\CSharpSimplifyTypeNamesDiagnosticAnalyzer.cs:line 93
   at Microsoft.CodeAnalysis.Diagnostics.SimplifyTypeNames.SimplifyTypeNamesDiagnosticAnalyzerBase`1.TrySimplifyTypeNameExpression(SemanticModel model, SyntaxNode node, AnalyzerOptions analyzerOptions, Diagnostic&amp; diagnostic, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Features\Core\Diagnostics\Analyzers\SimplifyTypeNamesDiagnosticAnalyzerBase.cs:line 83
   at Microsoft.CodeAnalysis.CSharp.Diagnostics.SimplifyTypeNames.CSharpSimplifyTypeNamesDiagnosticAnalyzer.&lt;&gt;c__DisplayClass2_0.&lt;AnalyzeNode&gt;b__1(SyntaxNode n) in C:\Roslyn\Main\Open\src\Features\CSharp\Diagnostics\Analyzers\CSharpSimplifyTypeNamesDiagnosticAnalyzer.cs:line 47
   at Microsoft.CodeAnalysis.SyntaxNode.ChildSyntaxListEnumeratorStack..ctor(SyntaxNode startingNode, Func`2 descendIntoChildren) in C:\Roslyn\Main\Open\src\Compilers\Core\Portable\Syntax\SyntaxNode.Iterators.cs:line 50
   at Microsoft.CodeAnalysis.SyntaxNode.&lt;DescendantNodesOnly&gt;d__157.MoveNext() in C:\Roslyn\Main\Open\src\Compilers\Core\Portable\Syntax\SyntaxNode.Iterators.cs:line 378
   at Microsoft.CodeAnalysis.CSharp.Diagnostics.SimplifyTypeNames.CSharpSimplifyTypeNamesDiagnosticAnalyzer.AnalyzeNode(SyntaxNodeAnalysisContext context) in C:\Roslyn\Main\Open\src\Features\CSharp\Diagnostics\Analyzers\CSharpSimplifyTypeNamesDiagnosticAnalyzer.cs:line 58
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.&lt;&gt;c__DisplayClass32_0`1.&lt;ExecuteSyntaxNodeAction&gt;b__1() in C:\Roslyn\Main\Open\src\Compilers\Core\AnalyzerDriver\AnalyzerExecutor.cs:line 298
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.ExecuteAndCatchIfThrows(DiagnosticAnalyzer analyzer, Action analyze, Action`3 onAnalyzerException, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Compilers\Core\AnalyzerDriver\AnalyzerExecutor.cs:line 501
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.ExecuteAndCatchIfThrows(DiagnosticAnalyzer analyzer, Action analyze) in C:\Roslyn\Main\Open\src\Compilers\Core\AnalyzerDriver\AnalyzerExecutor.cs:line 489
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.ExecuteSyntaxNodeAction[TLanguageKindEnum](SyntaxNodeAnalyzerAction`1 syntaxNodeAction, SyntaxNode node, SemanticModel semanticModel) in C:\Roslyn\Main\Open\src\Compilers\Core\AnalyzerDriver\AnalyzerExecutor.cs:line 298
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.ExecuteSyntaxNodeActions[TLanguageKindEnum](AnalyzerActions actions, IEnumerable`1 nodes, SemanticModel semanticModel, Func`2 getKind) in C:\Roslyn\Main\Open\src\Compilers\Core\AnalyzerDriver\AnalyzerExecutor.cs:line 284
   at Microsoft.CodeAnalysis.Diagnostics.EngineV1.AbstractSyntaxNodeAnalyzerService`1.ExecuteSyntaxNodeActions(AnalyzerActions actions, IEnumerable`1 descendantNodes, SemanticModel semanticModel, AnalyzerExecutor analyzerExecutor) in C:\Roslyn\Main\Open\src\Features\Core\Diagnostics\EngineV1\AbstractSyntaxNodeAnalyzerService.cs:line 25
   at Microsoft.CodeAnalysis.Diagnostics.EngineV1.DiagnosticAnalyzerDriver.&lt;GetSemanticDiagnosticsAsync&gt;d__40.MoveNext() in C:\Roslyn\Main\Open\src\Features\Core\Diagnostics\EngineV1\DiagnosticAnalyzerDriver.cs:line 378
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.Start[TStateMachine](TStateMachine&amp; stateMachine)
   at Microsoft.CodeAnalysis.Diagnostics.EngineV1.DiagnosticAnalyzerDriver.GetSemanticDiagnosticsAsync(DiagnosticAnalyzer analyzer)
   at Microsoft.CodeAnalysis.Diagnostics.EngineV1.DiagnosticIncrementalAnalyzer.&lt;GetSemanticDiagnosticsAsync&gt;d__81.MoveNext() in C:\Roslyn\Main\Open\src\Features\Core\Diagnostics\EngineV1\DiagnosticIncrementalAnalyzer.cs:line 828
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.Start[TStateMachine](TStateMachine&amp; stateMachine)
   at Microsoft.CodeAnalysis.Diagnostics.EngineV1.DiagnosticIncrementalAnalyzer.GetSemanticDiagnosticsAsync(DiagnosticAnalyzerDriver userDiagnosticDriver, DiagnosticAnalyzer analyzer)
   at Microsoft.CodeAnalysis.Diagnostics.EngineV1.DiagnosticIncrementalAnalyzer.AnalyzerExecutor.&lt;GetDocumentAnalysisDataAsync&gt;d__3.MoveNext() in C:\Roslyn\Main\Open\src\Features\Core\Diagnostics\EngineV1\DiagnosticIncrementalAnalyzer.AnalyzerExecutor.cs:line 70
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.Start[TStateMachine](TStateMachine&amp; stateMachine)
   at Microsoft.CodeAnalysis.Diagnostics.EngineV1.DiagnosticIncrementalAnalyzer.AnalyzerExecutor.GetDocumentAnalysisDataAsync(DiagnosticAnalyzerDriver analyzerDriver, StateSet stateSet, VersionArgument versions)
   at Microsoft.CodeAnalysis.Diagnostics.EngineV1.DiagnosticIncrementalAnalyzer.&lt;AnalyzeDocumentAsync&gt;d__52.MoveNext() in C:\Roslyn\Main\Open\src\Features\Core\Diagnostics\EngineV1\DiagnosticIncrementalAnalyzer.cs:line 278
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[TStateMachine](TStateMachine&amp; stateMachine)
   at Microsoft.CodeAnalysis.Diagnostics.EngineV1.DiagnosticIncrementalAnalyzer.AnalyzeDocumentAsync(Document document, VersionArgument versions, ImmutableHashSet`1 diagnosticIds, Boolean skipClosedFileChecks, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Diagnostics.EngineV1.DiagnosticIncrementalAnalyzer.&lt;AnalyzeDocumentAsync&gt;d__50.MoveNext() in C:\Roslyn\Main\Open\src\Features\Core\Diagnostics\EngineV1\DiagnosticIncrementalAnalyzer.cs:line 194
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[TStateMachine](TStateMachine&amp; stateMachine)
   at Microsoft.CodeAnalysis.Diagnostics.EngineV1.DiagnosticIncrementalAnalyzer.AnalyzeDocumentAsync(Document document, SyntaxNode bodyOpt, ImmutableHashSet`1 diagnosticIds, Boolean skipClosedFileChecks, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Diagnostics.EngineV1.DiagnosticIncrementalAnalyzer.&lt;AnalyzeDocumentAsync&gt;d__49.MoveNext() in C:\Roslyn\Main\Open\src\Features\Core\Diagnostics\EngineV1\DiagnosticIncrementalAnalyzer.cs:line 175
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[TStateMachine](TStateMachine&amp; stateMachine)
   at Microsoft.CodeAnalysis.Diagnostics.EngineV1.DiagnosticIncrementalAnalyzer.AnalyzeDocumentAsync(Document document, SyntaxNode bodyOpt, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerService.IncrementalAnalyzerDelegatee.AnalyzeDocumentAsync(Document document, SyntaxNode bodyOpt, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Features\Core\Diagnostics\DiagnosticAnalyzerService_IncrementalAnalyzer.cs:line 86
   at Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerRegistrationService.WorkCoordinator.IncrementalAnalyzerProcessor.&lt;&gt;c.&lt;ProcessDocumentAnalyzersAsync&gt;b__26_1(IIncrementalAnalyzer a, Document d, CancellationToken c) in C:\Roslyn\Main\Open\src\Features\Core\SolutionCrawler\WorkCoordinator.IncrementalAnalyzerProcessor.cs:line 175
   at Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerRegistrationService.WorkCoordinator.IncrementalAnalyzerProcessor.&lt;&gt;c__DisplayClass27_1`1.&lt;&lt;RunAnalyzersAsync&gt;b__0&gt;d.MoveNext() in C:\Roslyn\Main\Open\src\Features\Core\SolutionCrawler\WorkCoordinator.IncrementalAnalyzerProcessor.cs:line 197
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.Start[TStateMachine](TStateMachine&amp; stateMachine)
   at Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerRegistrationService.WorkCoordinator.IncrementalAnalyzerProcessor.&lt;&gt;c__DisplayClass27_1`1.&lt;RunAnalyzersAsync&gt;b__0(T v, CancellationToken c)
   at Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerRegistrationService.WorkCoordinator.IncrementalAnalyzerProcessor.&lt;GetOrDefaultAsync&gt;d__29`2.MoveNext() in C:\Roslyn\Main\Open\src\Features\Core\SolutionCrawler\WorkCoordinator.IncrementalAnalyzerProcessor.cs:line 240
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.Start[TStateMachine](TStateMachine&amp; stateMachine)
   at Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerRegistrationService.WorkCoordinator.IncrementalAnalyzerProcessor.GetOrDefaultAsync[TData,TResult](TData value, Func`3 funcAsync, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerRegistrationService.WorkCoordinator.IncrementalAnalyzerProcessor.&lt;RunAnalyzersAsync&gt;d__27`1.MoveNext() in C:\Roslyn\Main\Open\src\Features\Core\SolutionCrawler\WorkCoordinator.IncrementalAnalyzerProcessor.cs:line 195
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[TStateMachine](TStateMachine&amp; stateMachine)
   at Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerRegistrationService.WorkCoordinator.IncrementalAnalyzerProcessor.RunAnalyzersAsync[T](ImmutableArray`1 analyzers, T value, Func`4 runnerAsync, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerRegistrationService.WorkCoordinator.IncrementalAnalyzerProcessor.&lt;ProcessDocumentAnalyzersAsync&gt;d__26.MoveNext() in C:\Roslyn\Main\Open\src\Features\Core\SolutionCrawler\WorkCoordinator.IncrementalAnalyzerProcessor.cs:line 175
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.InvokeMoveNext(Object stateMachine)
   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.Run()
   at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(Action action, Boolean allowInlining, Task&amp; currentTask)
   at System.Threading.Tasks.Task.FinishContinuations()
   at System.Threading.Tasks.Task.FinishStageThree()
   at System.Threading.Tasks.Task`1.TrySetResult(TResult result)
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetResult(TResult result)
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.SetResult()
   at Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerRegistrationService.WorkCoordinator.IncrementalAnalyzerProcessor.&lt;RunAnalyzersAsync&gt;d__27`1.MoveNext() in C:\Roslyn\Main\Open\src\Features\Core\SolutionCrawler\WorkCoordinator.IncrementalAnalyzerProcessor.cs:line 201
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.InvokeMoveNext(Object stateMachine)
   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.Run()
   at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(Action action, Boolean allowInlining, Task&amp; currentTask)
   at System.Threading.Tasks.Task.FinishContinuations()
   at System.Threading.Tasks.Task.FinishStageThree()
   at System.Threading.Tasks.Task`1.TrySetResult(TResult result)
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetResult(TResult result)
   at Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerRegistrationService.WorkCoordinator.IncrementalAnalyzerProcessor.&lt;GetOrDefaultAsync&gt;d__29`2.MoveNext() in C:\Roslyn\Main\Open\src\Features\Core\SolutionCrawler\WorkCoordinator.IncrementalAnalyzerProcessor.cs:line 255
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.InvokeMoveNext(Object stateMachine)
   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.Run()
   at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(Action action, Boolean allowInlining, Task&amp; currentTask)
   at System.Threading.Tasks.Task.FinishContinuations()
   at System.Threading.Tasks.Task.FinishStageThree()
   at System.Threading.Tasks.Task`1.TrySetResult(TResult result)
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetResult(TResult result)
   at Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerRegistrationService.WorkCoordinator.IncrementalAnalyzerProcessor.&lt;&gt;c__DisplayClass27_1`1.&lt;&lt;RunAnalyzersAsync&gt;b__0&gt;d.MoveNext() in C:\Roslyn\Main\Open\src\Features\Core\SolutionCrawler\WorkCoordinator.IncrementalAnalyzerProcessor.cs:line 199
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.InvokeMoveNext(Object stateMachine)
   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.Run()
   at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(Action action, Boolean allowInlining, Task&amp; currentTask)
   at System.Threading.Tasks.Task.FinishContinuations()
   at System.Threading.Tasks.Task.FinishStageThree()
   at System.Threading.Tasks.Task`1.TrySetResult(TResult result)
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetResult(TResult result)
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.SetResult()
   at Microsoft.CodeAnalysis.Diagnostics.EngineV1.DiagnosticIncrementalAnalyzer.&lt;AnalyzeSyntaxAsync&gt;d__47.MoveNext() in C:\Roslyn\Main\Open\src\Features\Core\Diagnostics\EngineV1\DiagnosticIncrementalAnalyzer.cs:line 122
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.InvokeMoveNext(Object stateMachine)
   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.Run()
   at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(Action action, Boolean allowInlining, Task&amp; currentTask)
   at System.Threading.Tasks.Task.FinishContinuations()
   at System.Threading.Tasks.Task.FinishStageThree()
   at System.Threading.Tasks.Task`1.TrySetResult(TResult result)
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetResult(TResult result)
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.SetResult()
   at Microsoft.CodeAnalysis.Diagnostics.EngineV1.DiagnosticIncrementalAnalyzer.&lt;AnalyzeSyntaxAsync&gt;d__48.MoveNext() in C:\Roslyn\Main\Open\src\Features\Core\Diagnostics\EngineV1\DiagnosticIncrementalAnalyzer.cs:line 171
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.InvokeMoveNext(Object stateMachine)
   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.Run()
   at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(Action action, Boolean allowInlining, Task&amp; currentTask)
   at System.Threading.Tasks.Task.FinishContinuations()
   at System.Threading.Tasks.Task.FinishStageThree()
   at System.Threading.Tasks.Task`1.TrySetResult(TResult result)
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetResult(TResult result)
   at Microsoft.CodeAnalysis.Diagnostics.EngineV1.DiagnosticIncrementalAnalyzer.&lt;ShouldRunAnalyzerForStateTypeAsync&gt;d__62.MoveNext() in C:\Roslyn\Main\Open\src\Features\Core\Diagnostics\EngineV1\DiagnosticIncrementalAnalyzer.cs:line 486
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.InvokeMoveNext(Object stateMachine)
   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.Run()
   at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(Action action, Boolean allowInlining, Task&amp; currentTask)
   at System.Threading.Tasks.Task.FinishContinuations()
   at System.Threading.Tasks.Task.FinishStageThree()
   at System.Threading.Tasks.Task`1.TrySetResult(TResult result)
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetResult(TResult result)
   at Microsoft.CodeAnalysis.Diagnostics.EngineV1.DiagnosticIncrementalAnalyzer.&lt;ShouldRunAnalyzerForStateTypeAsync&gt;d__63.MoveNext() in C:\Roslyn\Main\Open\src\Features\Core\Diagnostics\EngineV1\DiagnosticIncrementalAnalyzer.cs:line 512
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.InvokeMoveNext(Object stateMachine)
   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.Run()
   at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(Action action, Boolean allowInlining, Task&amp; currentTask)
   at System.Threading.Tasks.Task.FinishContinuations()
   at System.Threading.Tasks.Task.FinishStageThree()
   at System.Threading.Tasks.Task`1.TrySetResult(TResult result)
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetResult(TResult result)
   at Microsoft.CodeAnalysis.Shared.Extensions.DiagnosticAnalyzerExtensions.&lt;SupportsSyntaxDiagnosticAnalysisAsync&gt;d__2.MoveNext() in C:\Roslyn\Main\Open\src\Features\Core\Shared\Extensions\DiagnosticAnalyzerExtensions.cs:line 84
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.InvokeMoveNext(Object stateMachine)
   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.Run()
   at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(Action action, Boolean allowInlining, Task&amp; currentTask)
   at System.Threading.Tasks.Task.FinishContinuations()
   at System.Threading.Tasks.Task.FinishStageThree()
   at System.Threading.Tasks.Task`1.TrySetResult(TResult result)
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetResult(TResult result)
   at Microsoft.CodeAnalysis.Shared.Extensions.DiagnosticAnalyzerExtensions.&lt;GetDiagnosticAnalyzerCategoryAsync&gt;d__0.MoveNext() in C:\Roslyn\Main\Open\src\Features\Core\Shared\Extensions\DiagnosticAnalyzerExtensions.cs:line 69
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.InvokeMoveNext(Object stateMachine)
   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.Run()
   at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(Action action, Boolean allowInlining, Task&amp; currentTask)
   at System.Threading.Tasks.Task.FinishContinuations()
   at System.Threading.Tasks.Task.FinishStageThree()
   at System.Threading.Tasks.Task`1.TrySetResult(TResult result)
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetResult(TResult result)
   at Microsoft.CodeAnalysis.Diagnostics.EngineV1.DiagnosticAnalyzerDriver.&lt;GetAnalyzerActionsAsync&gt;d__37.MoveNext() in C:\Roslyn\Main\Open\src\Features\Core\Diagnostics\EngineV1\DiagnosticAnalyzerDriver.cs:line 302
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.InvokeMoveNext(Object stateMachine)
   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.Run()
   at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(Action action, Boolean allowInlining, Task&amp; currentTask)
   at System.Threading.Tasks.Task.FinishContinuations()
   at System.Threading.Tasks.Task.FinishStageThree()
   at System.Threading.Tasks.Task`1.TrySetResult(TResult result)
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetResult(TResult result)
   at Microsoft.CodeAnalysis.Diagnostics.EngineV1.DiagnosticAnalyzerDriver.&lt;GetAnalyzerActionsAsync&gt;d__39.MoveNext() in C:\Roslyn\Main\Open\src\Features\Core\Diagnostics\EngineV1\DiagnosticAnalyzerDriver.cs:line 321
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.InvokeMoveNext(Object stateMachine)
   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.Run()
   at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(Action action, Boolean allowInlining, Task&amp; currentTask)
   at System.Threading.Tasks.Task.FinishContinuations()
   at System.Threading.Tasks.Task.FinishStageThree()
   at System.Threading.Tasks.Task`1.TrySetResult(TResult result)
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetResult(TResult result)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerManager.&lt;GetAnalyzerActionsAsync&gt;d__8.MoveNext() in C:\Roslyn\Main\Open\src\Compilers\Core\AnalyzerDriver\AnalyzerManager.cs:line 149
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.InvokeMoveNext(Object stateMachine)
   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.Run()
   at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(Action action, Boolean allowInlining, Task&amp; currentTask)
   at System.Threading.Tasks.Task.FinishContinuations()
   at System.Threading.Tasks.Task.FinishStageThree()
   at System.Threading.Tasks.Task`1.TrySetResult(TResult result)
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetResult(TResult result)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerManager.&lt;GetCompilationAnalysisScopeAsync&gt;d__5.MoveNext() in C:\Roslyn\Main\Open\src\Compilers\Core\AnalyzerDriver\AnalyzerManager.cs:line 95
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.InvokeMoveNext(Object stateMachine)
   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.Run()
   at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(Action action, Boolean allowInlining, Task&amp; currentTask)
   at System.Threading.Tasks.Task.FinishContinuations()
   at System.Threading.Tasks.Task.FinishStageThree()
   at System.Threading.Tasks.Task.FinishStageTwo()
   at System.Threading.Tasks.Task.Finish(Boolean bUserDelegateExecuted)
   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task&amp; currentTaskSlot)
   at System.Threading.Tasks.Task.ExecuteEntry(Boolean bPreventDoubleExecution)
   at System.Threading.Tasks.Task.System.Threading.IThreadPoolWorkItem.ExecuteWorkItem()
   at System.Threading.ThreadPoolWorkQueue.Dispatch()
   at System.Threading._ThreadPoolWaitCallback.PerformWaitCallback()

StackTrace: 
```

And then the crashing exception:

```
System.IndexOutOfRangeException: Index was outside the bounds of the array.
   at System.Collections.Immutable.ImmutableArray`1.Builder.get_Item(Int32 index)
   at Microsoft.CodeAnalysis.ArrayBuilder`1.get_Item(Int32 index) in C:\Roslyn\Main\Open\src\Compilers\Core\SharedCollections\ArrayBuilder.cs:line 83
   at Microsoft.CodeAnalysis.CSharp.AnalyzedArguments.Argument(Int32 i) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\AnalyzedArguments.cs:line 37
   at Microsoft.CodeAnalysis.CSharp.OverloadResolution.IsApplicable(Symbol candidate, EffectiveParameters parameters, AnalyzedArguments arguments, ImmutableArray`1 argsToParameters, Boolean isVararg, Boolean hasAnyRefOmittedArgument, Boolean ignoreOpenTypes, HashSet`1&amp; useSiteDiagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolution.cs:line 2594
   at Microsoft.CodeAnalysis.CSharp.OverloadResolution.IsApplicable[TMember](TMember member, TMember leastOverriddenMember, ArrayBuilder`1 typeArgumentsBuilder, AnalyzedArguments arguments, EffectiveParameters originalEffectiveParameters, EffectiveParameters constructedEffectiveParameters, ImmutableArray`1 argsToParamsMap, Boolean hasAnyRefOmittedArgument, HashSet`1&amp; useSiteDiagnostics, Boolean inferWithDynamic) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolution.cs:line 2504
   at Microsoft.CodeAnalysis.CSharp.OverloadResolution.IsMemberApplicableInNormalForm[TMember](TMember member, TMember leastOverriddenMember, ArrayBuilder`1 typeArguments, AnalyzedArguments arguments, Boolean isMethodGroupConversion, Boolean allowRefOmittedArguments, Boolean inferWithDynamic, HashSet`1&amp; useSiteDiagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolution.cs:line 2325
   at Microsoft.CodeAnalysis.CSharp.OverloadResolution.AddMemberToCandidateSet[TMember](TMember member, ArrayBuilder`1 results, ArrayBuilder`1 members, ArrayBuilder`1 typeArguments, AnalyzedArguments arguments, Boolean completeResults, Boolean isMethodGroupConversion, Boolean allowRefOmittedArguments, Dictionary`2 containingTypeMapOpt, Boolean inferWithDynamic, HashSet`1&amp; useSiteDiagnostics, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolution.cs:line 495
   at Microsoft.CodeAnalysis.CSharp.OverloadResolution.PerformMemberOverloadResolution[TMember](ArrayBuilder`1 results, ArrayBuilder`1 members, ArrayBuilder`1 typeArguments, AnalyzedArguments arguments, Boolean completeResults, Boolean isMethodGroupConversion, Boolean allowRefOmittedArguments, HashSet`1&amp; useSiteDiagnostics, Boolean inferWithDynamic, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolution.cs:line 233
   at Microsoft.CodeAnalysis.CSharp.OverloadResolution.MethodOrPropertyOverloadResolution[TMember](ArrayBuilder`1 members, ArrayBuilder`1 typeArguments, AnalyzedArguments arguments, OverloadResolutionResult`1 result, Boolean isMethodGroupConversion, Boolean allowRefOmittedArguments, HashSet`1&amp; useSiteDiagnostics, Boolean inferWithDynamic, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolution.cs:line 136
   at Microsoft.CodeAnalysis.CSharp.OverloadResolution.MethodInvocationOverloadResolution(ArrayBuilder`1 methods, ArrayBuilder`1 typeArguments, AnalyzedArguments arguments, OverloadResolutionResult`1 result, HashSet`1&amp; useSiteDiagnostics, Boolean isMethodGroupConversion, Boolean allowRefOmittedArguments, Boolean inferWithDynamic, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolution.cs:line 101
   at Microsoft.CodeAnalysis.CSharp.Binder.ResolveDefaultMethodGroup(BoundMethodGroup node, AnalyzedArguments analyzedArguments, Boolean isMethodGroupConversion, HashSet`1&amp; useSiteDiagnostics, Boolean inferWithDynamic, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 6254
   at Microsoft.CodeAnalysis.CSharp.Binder.ResolveMethodGroupInternal(BoundMethodGroup methodGroup, CSharpSyntaxNode expression, String methodName, AnalyzedArguments analyzedArguments, Boolean isMethodGroupConversion, HashSet`1&amp; useSiteDiagnostics, Boolean inferWithDynamic, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 6147
   at Microsoft.CodeAnalysis.CSharp.Binder.ResolveMethodGroup(BoundMethodGroup node, CSharpSyntaxNode expression, String methodName, AnalyzedArguments analyzedArguments, Boolean isMethodGroupConversion, HashSet`1&amp; useSiteDiagnostics, Boolean inferWithDynamic, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 6122
   at Microsoft.CodeAnalysis.CSharp.Binder.BindMethodGroupInvocation(CSharpSyntaxNode syntax, CSharpSyntaxNode expression, String methodName, BoundMethodGroup methodGroup, AnalyzedArguments analyzedArguments, DiagnosticBag diagnostics, CSharpSyntaxNode queryClause, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Invocation.cs:line 452
   at Microsoft.CodeAnalysis.CSharp.Binder.BindInvocationExpression(CSharpSyntaxNode node, CSharpSyntaxNode expression, String methodName, BoundExpression boundExpression, AnalyzedArguments analyzedArguments, DiagnosticBag diagnostics, CSharpSyntaxNode queryClause, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Invocation.cs:line 222
   at Microsoft.CodeAnalysis.CSharp.Binder.BindInvocationExpression(InvocationExpressionSyntax node, DiagnosticBag diagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Invocation.cs:line 165
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 408
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpression(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 353
   at Microsoft.CodeAnalysis.CSharp.Binder.BindValue(ExpressionSyntax node, DiagnosticBag diagnostics, BindValueKind valueKind) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 288
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionStatement(CSharpSyntaxNode node, ExpressionSyntax syntax, Boolean allowsAnyExpression, DiagnosticBag diagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 418
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionStatement(ExpressionStatementSyntax node, DiagnosticBag diagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 411
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 49
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.IncrementalBinder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs:line 1639
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs:line 1996
   at Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\MethodBodySemanticModel.cs:line 48
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs:line 1397
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLowerBoundNode(CSharpSyntaxNode node) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs:line 369
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node, CSharpSyntaxNode&amp; bindableNode, BoundNode&amp; lowestBoundNode, BoundNode&amp; highestBoundNode, BoundNode&amp; boundParent) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs:line 896
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetSymbolInfoWorker(CSharpSyntaxNode node, SymbolInfoOptions options, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs:line 775
   at Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetSymbolInfoWorker(CSharpSyntaxNode node, SymbolInfoOptions options, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs:line 173
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(ExpressionSyntax expression, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs:line 504
   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\CSharpExtensions.cs:line 443
   at Microsoft.CodeAnalysis.CSharp.Extensions.ExpressionSyntaxExtensions.TryReplaceWithAlias(ExpressionSyntax node, SemanticModel semanticModel, Boolean preferAliasToQualifiedName, CancellationToken cancellationToken, IAliasSymbol&amp; aliasReplacement) in C:\Roslyn\Main\Open\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs:line 868
   at Microsoft.CodeAnalysis.CSharp.Extensions.ExpressionSyntaxExtensions.TryReduce(MemberAccessExpressionSyntax memberAccess, SemanticModel semanticModel, TypeSyntax&amp; replacementNode, TextSpan&amp; issueSpan, OptionSet optionSet, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs:line 722
   at Microsoft.CodeAnalysis.CSharp.Extensions.ExpressionSyntaxExtensions.TryReduceExplicitName(ExpressionSyntax expression, SemanticModel semanticModel, TypeSyntax&amp; replacementNode, TextSpan&amp; issueSpan, OptionSet optionSet, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs:line 665
   at Microsoft.CodeAnalysis.CSharp.Extensions.ExpressionSyntaxExtensions.TryReduceOrSimplifyExplicitName(ExpressionSyntax expression, SemanticModel semanticModel, ExpressionSyntax&amp; replacementNode, TextSpan&amp; issueSpan, OptionSet optionSet, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs:line 637
   at Microsoft.CodeAnalysis.CSharp.Diagnostics.SimplifyTypeNames.CSharpSimplifyTypeNamesDiagnosticAnalyzer.CanSimplifyTypeNameExpression(SemanticModel model, SyntaxNode node, OptionSet optionSet, TextSpan&amp; issueSpan, String&amp; diagnosticId, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Features\CSharp\Diagnostics\Analyzers\CSharpSimplifyTypeNamesDiagnosticAnalyzer.cs:line 132
   at Microsoft.CodeAnalysis.CSharp.Diagnostics.SimplifyTypeNames.CSharpSimplifyTypeNamesDiagnosticAnalyzer.CanSimplifyTypeNameExpressionCore(SemanticModel model, SyntaxNode node, OptionSet optionSet, TextSpan&amp; issueSpan, String&amp; diagnosticId, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Features\CSharp\Diagnostics\Analyzers\CSharpSimplifyTypeNamesDiagnosticAnalyzer.cs:line 93
   at Microsoft.CodeAnalysis.Diagnostics.SimplifyTypeNames.SimplifyTypeNamesDiagnosticAnalyzerBase`1.TrySimplifyTypeNameExpression(SemanticModel model, SyntaxNode node, AnalyzerOptions analyzerOptions, Diagnostic&amp; diagnostic, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Features\Core\Diagnostics\Analyzers\SimplifyTypeNamesDiagnosticAnalyzerBase.cs:line 83
   at Microsoft.CodeAnalysis.CSharp.Diagnostics.SimplifyTypeNames.CSharpSimplifyTypeNamesDiagnosticAnalyzer.&lt;&gt;c__DisplayClass2_0.&lt;AnalyzeNode&gt;b__1(SyntaxNode n) in C:\Roslyn\Main\Open\src\Features\CSharp\Diagnostics\Analyzers\CSharpSimplifyTypeNamesDiagnosticAnalyzer.cs:line 47
   at Microsoft.CodeAnalysis.SyntaxNode.ChildSyntaxListEnumeratorStack..ctor(SyntaxNode startingNode, Func`2 descendIntoChildren) in C:\Roslyn\Main\Open\src\Compilers\Core\Portable\Syntax\SyntaxNode.Iterators.cs:line 50
   at Microsoft.CodeAnalysis.SyntaxNode.&lt;DescendantNodesOnly&gt;d__157.MoveNext() in C:\Roslyn\Main\Open\src\Compilers\Core\Portable\Syntax\SyntaxNode.Iterators.cs:line 378
   at Microsoft.CodeAnalysis.CSharp.Diagnostics.SimplifyTypeNames.CSharpSimplifyTypeNamesDiagnosticAnalyzer.AnalyzeNode(SyntaxNodeAnalysisContext context) in C:\Roslyn\Main\Open\src\Features\CSharp\Diagnostics\Analyzers\CSharpSimplifyTypeNamesDiagnosticAnalyzer.cs:line 58
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.&lt;&gt;c__DisplayClass32_0`1.&lt;ExecuteSyntaxNodeAction&gt;b__1() in C:\Roslyn\Main\Open\src\Compilers\Core\AnalyzerDriver\AnalyzerExecutor.cs:line 298
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.ExecuteAndCatchIfThrows(DiagnosticAnalyzer analyzer, Action analyze, Action`3 onAnalyzerException, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Compilers\Core\AnalyzerDriver\AnalyzerExecutor.cs:line 501
5/10/2015 4:31:38 PM
Source: First chance exception: System.Collections.Immutable
StackTrace:    at System.Collections.Immutable.ImmutableArray`1.Builder.get_Item(Int32 index)
   at Microsoft.CodeAnalysis.ArrayBuilder`1.get_Item(Int32 index) in C:\Roslyn\Main\Open\src\Compilers\Core\SharedCollections\ArrayBuilder.cs:line 83
   at Microsoft.CodeAnalysis.CSharp.AnalyzedArguments.Argument(Int32 i) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\AnalyzedArguments.cs:line 37
   at Microsoft.CodeAnalysis.CSharp.OverloadResolution.IsApplicable(Symbol candidate, EffectiveParameters parameters, AnalyzedArguments arguments, ImmutableArray`1 argsToParameters, Boolean isVararg, Boolean hasAnyRefOmittedArgument, Boolean ignoreOpenTypes, HashSet`1&amp; useSiteDiagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolution.cs:line 2594
   at Microsoft.CodeAnalysis.CSharp.OverloadResolution.IsApplicable[TMember](TMember member, TMember leastOverriddenMember, ArrayBuilder`1 typeArgumentsBuilder, AnalyzedArguments arguments, EffectiveParameters originalEffectiveParameters, EffectiveParameters constructedEffectiveParameters, ImmutableArray`1 argsToParamsMap, Boolean hasAnyRefOmittedArgument, HashSet`1&amp; useSiteDiagnostics, Boolean inferWithDynamic) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolution.cs:line 2504
   at Microsoft.CodeAnalysis.CSharp.OverloadResolution.IsMemberApplicableInNormalForm[TMember](TMember member, TMember leastOverriddenMember, ArrayBuilder`1 typeArguments, AnalyzedArguments arguments, Boolean isMethodGroupConversion, Boolean allowRefOmittedArguments, Boolean inferWithDynamic, HashSet`1&amp; useSiteDiagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolution.cs:line 2325
   at Microsoft.CodeAnalysis.CSharp.OverloadResolution.AddMemberToCandidateSet[TMember](TMember member, ArrayBuilder`1 results, ArrayBuilder`1 members, ArrayBuilder`1 typeArguments, AnalyzedArguments arguments, Boolean completeResults, Boolean isMethodGroupConversion, Boolean allowRefOmittedArguments, Dictionary`2 containingTypeMapOpt, Boolean inferWithDynamic, HashSet`1&amp; useSiteDiagnostics, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolution.cs:line 495
   at Microsoft.CodeAnalysis.CSharp.OverloadResolution.PerformMemberOverloadResolution[TMember](ArrayBuilder`1 results, ArrayBuilder`1 members, ArrayBuilder`1 typeArguments, AnalyzedArguments arguments, Boolean completeResults, Boolean isMethodGroupConversion, Boolean allowRefOmittedArguments, HashSet`1&amp; useSiteDiagnostics, Boolean inferWithDynamic, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolution.cs:line 233
   at Microsoft.CodeAnalysis.CSharp.OverloadResolution.MethodOrPropertyOverloadResolution[TMember](ArrayBuilder`1 members, ArrayBuilder`1 typeArguments, AnalyzedArguments arguments, OverloadResolutionResult`1 result, Boolean isMethodGroupConversion, Boolean allowRefOmittedArguments, HashSet`1&amp; useSiteDiagnostics, Boolean inferWithDynamic, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolution.cs:line 136
   at Microsoft.CodeAnalysis.CSharp.OverloadResolution.MethodInvocationOverloadResolution(ArrayBuilder`1 methods, ArrayBuilder`1 typeArguments, AnalyzedArguments arguments, OverloadResolutionResult`1 result, HashSet`1&amp; useSiteDiagnostics, Boolean isMethodGroupConversion, Boolean allowRefOmittedArguments, Boolean inferWithDynamic, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolution.cs:line 101
   at Microsoft.CodeAnalysis.CSharp.Binder.ResolveDefaultMethodGroup(BoundMethodGroup node, AnalyzedArguments analyzedArguments, Boolean isMethodGroupConversion, HashSet`1&amp; useSiteDiagnostics, Boolean inferWithDynamic, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 6254
   at Microsoft.CodeAnalysis.CSharp.Binder.ResolveMethodGroupInternal(BoundMethodGroup methodGroup, CSharpSyntaxNode expression, String methodName, AnalyzedArguments analyzedArguments, Boolean isMethodGroupConversion, HashSet`1&amp; useSiteDiagnostics, Boolean inferWithDynamic, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 6147
   at Microsoft.CodeAnalysis.CSharp.Binder.ResolveMethodGroup(BoundMethodGroup node, CSharpSyntaxNode expression, String methodName, AnalyzedArguments analyzedArguments, Boolean isMethodGroupConversion, HashSet`1&amp; useSiteDiagnostics, Boolean inferWithDynamic, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 6122
   at Microsoft.CodeAnalysis.CSharp.Binder.BindMethodGroupInvocation(CSharpSyntaxNode syntax, CSharpSyntaxNode expression, String methodName, BoundMethodGroup methodGroup, AnalyzedArguments analyzedArguments, DiagnosticBag diagnostics, CSharpSyntaxNode queryClause, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Invocation.cs:line 452
   at Microsoft.CodeAnalysis.CSharp.Binder.BindInvocationExpression(CSharpSyntaxNode node, CSharpSyntaxNode expression, String methodName, BoundExpression boundExpression, AnalyzedArguments analyzedArguments, DiagnosticBag diagnostics, CSharpSyntaxNode queryClause, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Invocation.cs:line 222
   at Microsoft.CodeAnalysis.CSharp.Binder.BindInvocationExpression(InvocationExpressionSyntax node, DiagnosticBag diagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Invocation.cs:line 165
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 408
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpression(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 353
   at Microsoft.CodeAnalysis.CSharp.Binder.BindValue(ExpressionSyntax node, DiagnosticBag diagnostics, BindValueKind valueKind) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 288
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionStatement(CSharpSyntaxNode node, ExpressionSyntax syntax, Boolean allowsAnyExpression, DiagnosticBag diagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 418
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionStatement(ExpressionStatementSyntax node, DiagnosticBag diagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 411
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 49
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.IncrementalBinder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs:line 1639
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs:line 1996
   at Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\MethodBodySemanticModel.cs:line 48
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs:line 1397
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLowerBoundNode(CSharpSyntaxNode node) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs:line 369
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node, CSharpSyntaxNode&amp; bindableNode, BoundNode&amp; lowestBoundNode, BoundNode&amp; highestBoundNode, BoundNode&amp; boundParent) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs:line 896
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetSymbolInfoWorker(CSharpSyntaxNode node, SymbolInfoOptions options, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs:line 775
   at Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetSymbolInfoWorker(CSharpSyntaxNode node, SymbolInfoOptions options, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs:line 173
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(ExpressionSyntax expression, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs:line 504
   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\CSharpExtensions.cs:line 443
   at Microsoft.CodeAnalysis.CSharp.Extensions.ExpressionSyntaxExtensions.TryReplaceWithAlias(ExpressionSyntax node, SemanticModel semanticModel, Boolean preferAliasToQualifiedName, CancellationToken cancellationToken, IAliasSymbol&amp; aliasReplacement) in C:\Roslyn\Main\Open\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs:line 868
   at Microsoft.CodeAnalysis.CSharp.Extensions.ExpressionSyntaxExtensions.TryReduce(MemberAccessExpressionSyntax memberAccess, SemanticModel semanticModel, TypeSyntax&amp; replacementNode, TextSpan&amp; issueSpan, OptionSet optionSet, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs:line 722
   at Microsoft.CodeAnalysis.CSharp.Extensions.ExpressionSyntaxExtensions.TryReduceExplicitName(ExpressionSyntax expression, SemanticModel semanticModel, TypeSyntax&amp; replacementNode, TextSpan&amp; issueSpan, OptionSet optionSet, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs:line 665
   at Microsoft.CodeAnalysis.CSharp.Extensions.ExpressionSyntaxExtensions.TryReduceOrSimplifyExplicitName(ExpressionSyntax expression, SemanticModel semanticModel, ExpressionSyntax&amp; replacementNode, TextSpan&amp; issueSpan, OptionSet optionSet, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs:line 637
   at Microsoft.CodeAnalysis.CSharp.Diagnostics.SimplifyTypeNames.CSharpSimplifyTypeNamesDiagnosticAnalyzer.CanSimplifyTypeNameExpression(SemanticModel model, SyntaxNode node, OptionSet optionSet, TextSpan&amp; issueSpan, String&amp; diagnosticId, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Features\CSharp\Diagnostics\Analyzers\CSharpSimplifyTypeNamesDiagnosticAnalyzer.cs:line 132
   at Microsoft.CodeAnalysis.CSharp.Diagnostics.SimplifyTypeNames.CSharpSimplifyTypeNamesDiagnosticAnalyzer.CanSimplifyTypeNameExpressionCore(SemanticModel model, SyntaxNode node, OptionSet optionSet, TextSpan&amp; issueSpan, String&amp; diagnosticId, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Features\CSharp\Diagnostics\Analyzers\CSharpSimplifyTypeNamesDiagnosticAnalyzer.cs:line 93
   at Microsoft.CodeAnalysis.Diagnostics.SimplifyTypeNames.SimplifyTypeNamesDiagnosticAnalyzerBase`1.TrySimplifyTypeNameExpression(SemanticModel model, SyntaxNode node, AnalyzerOptions analyzerOptions, Diagnostic&amp; diagnostic, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Features\Core\Diagnostics\Analyzers\SimplifyTypeNamesDiagnosticAnalyzerBase.cs:line 83
   at Microsoft.CodeAnalysis.CSharp.Diagnostics.SimplifyTypeNames.CSharpSimplifyTypeNamesDiagnosticAnalyzer.&lt;&gt;c__DisplayClass2_0.&lt;AnalyzeNode&gt;b__1(SyntaxNode n) in C:\Roslyn\Main\Open\src\Features\CSharp\Diagnostics\Analyzers\CSharpSimplifyTypeNamesDiagnosticAnalyzer.cs:line 47
   at Microsoft.CodeAnalysis.SyntaxNode.ChildSyntaxListEnumeratorStack..ctor(SyntaxNode startingNode, Func`2 descendIntoChildren) in C:\Roslyn\Main\Open\src\Compilers\Core\Portable\Syntax\SyntaxNode.Iterators.cs:line 50
   at Microsoft.CodeAnalysis.SyntaxNode.&lt;DescendantNodesOnly&gt;d__157.MoveNext() in C:\Roslyn\Main\Open\src\Compilers\Core\Portable\Syntax\SyntaxNode.Iterators.cs:line 378
   at Microsoft.CodeAnalysis.CSharp.Diagnostics.SimplifyTypeNames.CSharpSimplifyTypeNamesDiagnosticAnalyzer.AnalyzeNode(SyntaxNodeAnalysisContext context) in C:\Roslyn\Main\Open\src\Features\CSharp\Diagnostics\Analyzers\CSharpSimplifyTypeNamesDiagnosticAnalyzer.cs:line 58
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.&lt;&gt;c__DisplayClass32_0`1.&lt;ExecuteSyntaxNodeAction&gt;b__1() in C:\Roslyn\Main\Open\src\Compilers\Core\AnalyzerDriver\AnalyzerExecutor.cs:line 298
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.ExecuteAndCatchIfThrows(DiagnosticAnalyzer analyzer, Action analyze, Action`3 onAnalyzerException, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Compilers\Core\AnalyzerDriver\AnalyzerExecutor.cs:line 501
```

&lt;!---
@huboard:{"order":2603.5,"milestone_order":2631,"custom_state":""}
--&gt;
</Description>
        <CreatedDate>10/05/2015</CreatedDate>
        <ClosedDate>13/05/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>2631</IssueID>
        <Title>Crash with IndexOutOfRangeException in OverloadResolution.IsApplicable during SimplifyTypeNamesDiagnosticAnalyzer analysis</Title>
        <Description>Paste C# code:

``` C#
class C
{
    void M()
    {
        System.Console.WriteLine("", arg0: 0, arg1: 0, arg2: 0, );
    }
}
```

There's an assert and a crashing exception, both pasted below. First, the assert:

```
System.Exception: ASSERT FAILED 
5/10/2015 4:31:38 PM
Source:    at Roslyn.Editor.TestApp.OutputWindowTraceListener.Fail(String message, String detailMessage) in C:\Roslyn\Main\Closed\Hosting\EditorTestApp\UI\ToolWindows\Output\OutputWindowTraceListener.cs:line 50
   at System.Diagnostics.TraceListener.Fail(String message)
   at System.Diagnostics.TraceInternal.Fail(String message)
   at System.Diagnostics.Debug.Assert(Boolean condition)
   at Microsoft.CodeAnalysis.CSharp.OverloadResolution.IsApplicable(Symbol candidate, EffectiveParameters parameters, AnalyzedArguments arguments, ImmutableArray`1 argsToParameters, Boolean isVararg, Boolean hasAnyRefOmittedArgument, Boolean ignoreOpenTypes, HashSet`1&amp; useSiteDiagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolution.cs:line 2582
   at Microsoft.CodeAnalysis.CSharp.OverloadResolution.IsApplicable[TMember](TMember member, TMember leastOverriddenMember, ArrayBuilder`1 typeArgumentsBuilder, AnalyzedArguments arguments, EffectiveParameters originalEffectiveParameters, EffectiveParameters constructedEffectiveParameters, ImmutableArray`1 argsToParamsMap, Boolean hasAnyRefOmittedArgument, HashSet`1&amp; useSiteDiagnostics, Boolean inferWithDynamic) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolution.cs:line 2504
   at Microsoft.CodeAnalysis.CSharp.OverloadResolution.IsMemberApplicableInNormalForm[TMember](TMember member, TMember leastOverriddenMember, ArrayBuilder`1 typeArguments, AnalyzedArguments arguments, Boolean isMethodGroupConversion, Boolean allowRefOmittedArguments, Boolean inferWithDynamic, HashSet`1&amp; useSiteDiagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolution.cs:line 2325
   at Microsoft.CodeAnalysis.CSharp.OverloadResolution.AddMemberToCandidateSet[TMember](TMember member, ArrayBuilder`1 results, ArrayBuilder`1 members, ArrayBuilder`1 typeArguments, AnalyzedArguments arguments, Boolean completeResults, Boolean isMethodGroupConversion, Boolean allowRefOmittedArguments, Dictionary`2 containingTypeMapOpt, Boolean inferWithDynamic, HashSet`1&amp; useSiteDiagnostics, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolution.cs:line 495
   at Microsoft.CodeAnalysis.CSharp.OverloadResolution.PerformMemberOverloadResolution[TMember](ArrayBuilder`1 results, ArrayBuilder`1 members, ArrayBuilder`1 typeArguments, AnalyzedArguments arguments, Boolean completeResults, Boolean isMethodGroupConversion, Boolean allowRefOmittedArguments, HashSet`1&amp; useSiteDiagnostics, Boolean inferWithDynamic, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolution.cs:line 233
   at Microsoft.CodeAnalysis.CSharp.OverloadResolution.MethodOrPropertyOverloadResolution[TMember](ArrayBuilder`1 members, ArrayBuilder`1 typeArguments, AnalyzedArguments arguments, OverloadResolutionResult`1 result, Boolean isMethodGroupConversion, Boolean allowRefOmittedArguments, HashSet`1&amp; useSiteDiagnostics, Boolean inferWithDynamic, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolution.cs:line 136
   at Microsoft.CodeAnalysis.CSharp.OverloadResolution.MethodInvocationOverloadResolution(ArrayBuilder`1 methods, ArrayBuilder`1 typeArguments, AnalyzedArguments arguments, OverloadResolutionResult`1 result, HashSet`1&amp; useSiteDiagnostics, Boolean isMethodGroupConversion, Boolean allowRefOmittedArguments, Boolean inferWithDynamic, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolution.cs:line 101
   at Microsoft.CodeAnalysis.CSharp.Binder.ResolveDefaultMethodGroup(BoundMethodGroup node, AnalyzedArguments analyzedArguments, Boolean isMethodGroupConversion, HashSet`1&amp; useSiteDiagnostics, Boolean inferWithDynamic, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 6254
   at Microsoft.CodeAnalysis.CSharp.Binder.ResolveMethodGroupInternal(BoundMethodGroup methodGroup, CSharpSyntaxNode expression, String methodName, AnalyzedArguments analyzedArguments, Boolean isMethodGroupConversion, HashSet`1&amp; useSiteDiagnostics, Boolean inferWithDynamic, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 6147
   at Microsoft.CodeAnalysis.CSharp.Binder.ResolveMethodGroup(BoundMethodGroup node, CSharpSyntaxNode expression, String methodName, AnalyzedArguments analyzedArguments, Boolean isMethodGroupConversion, HashSet`1&amp; useSiteDiagnostics, Boolean inferWithDynamic, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 6122
   at Microsoft.CodeAnalysis.CSharp.Binder.BindMethodGroupInvocation(CSharpSyntaxNode syntax, CSharpSyntaxNode expression, String methodName, BoundMethodGroup methodGroup, AnalyzedArguments analyzedArguments, DiagnosticBag diagnostics, CSharpSyntaxNode queryClause, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Invocation.cs:line 452
   at Microsoft.CodeAnalysis.CSharp.Binder.BindInvocationExpression(CSharpSyntaxNode node, CSharpSyntaxNode expression, String methodName, BoundExpression boundExpression, AnalyzedArguments analyzedArguments, DiagnosticBag diagnostics, CSharpSyntaxNode queryClause, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Invocation.cs:line 222
   at Microsoft.CodeAnalysis.CSharp.Binder.BindInvocationExpression(InvocationExpressionSyntax node, DiagnosticBag diagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Invocation.cs:line 165
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 408
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpression(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 353
   at Microsoft.CodeAnalysis.CSharp.Binder.BindValue(ExpressionSyntax node, DiagnosticBag diagnostics, BindValueKind valueKind) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 288
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionStatement(CSharpSyntaxNode node, ExpressionSyntax syntax, Boolean allowsAnyExpression, DiagnosticBag diagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 418
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionStatement(ExpressionStatementSyntax node, DiagnosticBag diagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 411
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 49
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.IncrementalBinder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs:line 1639
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs:line 1996
   at Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\MethodBodySemanticModel.cs:line 48
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs:line 1397
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLowerBoundNode(CSharpSyntaxNode node) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs:line 369
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node, CSharpSyntaxNode&amp; bindableNode, BoundNode&amp; lowestBoundNode, BoundNode&amp; highestBoundNode, BoundNode&amp; boundParent) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs:line 896
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetSymbolInfoWorker(CSharpSyntaxNode node, SymbolInfoOptions options, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs:line 775
   at Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetSymbolInfoWorker(CSharpSyntaxNode node, SymbolInfoOptions options, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs:line 173
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(ExpressionSyntax expression, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs:line 504
   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\CSharpExtensions.cs:line 443
   at Microsoft.CodeAnalysis.CSharp.Extensions.ExpressionSyntaxExtensions.TryReplaceWithAlias(ExpressionSyntax node, SemanticModel semanticModel, Boolean preferAliasToQualifiedName, CancellationToken cancellationToken, IAliasSymbol&amp; aliasReplacement) in C:\Roslyn\Main\Open\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs:line 868
   at Microsoft.CodeAnalysis.CSharp.Extensions.ExpressionSyntaxExtensions.TryReduce(MemberAccessExpressionSyntax memberAccess, SemanticModel semanticModel, TypeSyntax&amp; replacementNode, TextSpan&amp; issueSpan, OptionSet optionSet, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs:line 722
   at Microsoft.CodeAnalysis.CSharp.Extensions.ExpressionSyntaxExtensions.TryReduceExplicitName(ExpressionSyntax expression, SemanticModel semanticModel, TypeSyntax&amp; replacementNode, TextSpan&amp; issueSpan, OptionSet optionSet, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs:line 665
   at Microsoft.CodeAnalysis.CSharp.Extensions.ExpressionSyntaxExtensions.TryReduceOrSimplifyExplicitName(ExpressionSyntax expression, SemanticModel semanticModel, ExpressionSyntax&amp; replacementNode, TextSpan&amp; issueSpan, OptionSet optionSet, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs:line 637
   at Microsoft.CodeAnalysis.CSharp.Diagnostics.SimplifyTypeNames.CSharpSimplifyTypeNamesDiagnosticAnalyzer.CanSimplifyTypeNameExpression(SemanticModel model, SyntaxNode node, OptionSet optionSet, TextSpan&amp; issueSpan, String&amp; diagnosticId, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Features\CSharp\Diagnostics\Analyzers\CSharpSimplifyTypeNamesDiagnosticAnalyzer.cs:line 132
   at Microsoft.CodeAnalysis.CSharp.Diagnostics.SimplifyTypeNames.CSharpSimplifyTypeNamesDiagnosticAnalyzer.CanSimplifyTypeNameExpressionCore(SemanticModel model, SyntaxNode node, OptionSet optionSet, TextSpan&amp; issueSpan, String&amp; diagnosticId, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Features\CSharp\Diagnostics\Analyzers\CSharpSimplifyTypeNamesDiagnosticAnalyzer.cs:line 93
   at Microsoft.CodeAnalysis.Diagnostics.SimplifyTypeNames.SimplifyTypeNamesDiagnosticAnalyzerBase`1.TrySimplifyTypeNameExpression(SemanticModel model, SyntaxNode node, AnalyzerOptions analyzerOptions, Diagnostic&amp; diagnostic, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Features\Core\Diagnostics\Analyzers\SimplifyTypeNamesDiagnosticAnalyzerBase.cs:line 83
   at Microsoft.CodeAnalysis.CSharp.Diagnostics.SimplifyTypeNames.CSharpSimplifyTypeNamesDiagnosticAnalyzer.&lt;&gt;c__DisplayClass2_0.&lt;AnalyzeNode&gt;b__1(SyntaxNode n) in C:\Roslyn\Main\Open\src\Features\CSharp\Diagnostics\Analyzers\CSharpSimplifyTypeNamesDiagnosticAnalyzer.cs:line 47
   at Microsoft.CodeAnalysis.SyntaxNode.ChildSyntaxListEnumeratorStack..ctor(SyntaxNode startingNode, Func`2 descendIntoChildren) in C:\Roslyn\Main\Open\src\Compilers\Core\Portable\Syntax\SyntaxNode.Iterators.cs:line 50
   at Microsoft.CodeAnalysis.SyntaxNode.&lt;DescendantNodesOnly&gt;d__157.MoveNext() in C:\Roslyn\Main\Open\src\Compilers\Core\Portable\Syntax\SyntaxNode.Iterators.cs:line 378
   at Microsoft.CodeAnalysis.CSharp.Diagnostics.SimplifyTypeNames.CSharpSimplifyTypeNamesDiagnosticAnalyzer.AnalyzeNode(SyntaxNodeAnalysisContext context) in C:\Roslyn\Main\Open\src\Features\CSharp\Diagnostics\Analyzers\CSharpSimplifyTypeNamesDiagnosticAnalyzer.cs:line 58
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.&lt;&gt;c__DisplayClass32_0`1.&lt;ExecuteSyntaxNodeAction&gt;b__1() in C:\Roslyn\Main\Open\src\Compilers\Core\AnalyzerDriver\AnalyzerExecutor.cs:line 298
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.ExecuteAndCatchIfThrows(DiagnosticAnalyzer analyzer, Action analyze, Action`3 onAnalyzerException, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Compilers\Core\AnalyzerDriver\AnalyzerExecutor.cs:line 501
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.ExecuteAndCatchIfThrows(DiagnosticAnalyzer analyzer, Action analyze) in C:\Roslyn\Main\Open\src\Compilers\Core\AnalyzerDriver\AnalyzerExecutor.cs:line 489
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.ExecuteSyntaxNodeAction[TLanguageKindEnum](SyntaxNodeAnalyzerAction`1 syntaxNodeAction, SyntaxNode node, SemanticModel semanticModel) in C:\Roslyn\Main\Open\src\Compilers\Core\AnalyzerDriver\AnalyzerExecutor.cs:line 298
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.ExecuteSyntaxNodeActions[TLanguageKindEnum](AnalyzerActions actions, IEnumerable`1 nodes, SemanticModel semanticModel, Func`2 getKind) in C:\Roslyn\Main\Open\src\Compilers\Core\AnalyzerDriver\AnalyzerExecutor.cs:line 284
   at Microsoft.CodeAnalysis.Diagnostics.EngineV1.AbstractSyntaxNodeAnalyzerService`1.ExecuteSyntaxNodeActions(AnalyzerActions actions, IEnumerable`1 descendantNodes, SemanticModel semanticModel, AnalyzerExecutor analyzerExecutor) in C:\Roslyn\Main\Open\src\Features\Core\Diagnostics\EngineV1\AbstractSyntaxNodeAnalyzerService.cs:line 25
   at Microsoft.CodeAnalysis.Diagnostics.EngineV1.DiagnosticAnalyzerDriver.&lt;GetSemanticDiagnosticsAsync&gt;d__40.MoveNext() in C:\Roslyn\Main\Open\src\Features\Core\Diagnostics\EngineV1\DiagnosticAnalyzerDriver.cs:line 378
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.Start[TStateMachine](TStateMachine&amp; stateMachine)
   at Microsoft.CodeAnalysis.Diagnostics.EngineV1.DiagnosticAnalyzerDriver.GetSemanticDiagnosticsAsync(DiagnosticAnalyzer analyzer)
   at Microsoft.CodeAnalysis.Diagnostics.EngineV1.DiagnosticIncrementalAnalyzer.&lt;GetSemanticDiagnosticsAsync&gt;d__81.MoveNext() in C:\Roslyn\Main\Open\src\Features\Core\Diagnostics\EngineV1\DiagnosticIncrementalAnalyzer.cs:line 828
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.Start[TStateMachine](TStateMachine&amp; stateMachine)
   at Microsoft.CodeAnalysis.Diagnostics.EngineV1.DiagnosticIncrementalAnalyzer.GetSemanticDiagnosticsAsync(DiagnosticAnalyzerDriver userDiagnosticDriver, DiagnosticAnalyzer analyzer)
   at Microsoft.CodeAnalysis.Diagnostics.EngineV1.DiagnosticIncrementalAnalyzer.AnalyzerExecutor.&lt;GetDocumentAnalysisDataAsync&gt;d__3.MoveNext() in C:\Roslyn\Main\Open\src\Features\Core\Diagnostics\EngineV1\DiagnosticIncrementalAnalyzer.AnalyzerExecutor.cs:line 70
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.Start[TStateMachine](TStateMachine&amp; stateMachine)
   at Microsoft.CodeAnalysis.Diagnostics.EngineV1.DiagnosticIncrementalAnalyzer.AnalyzerExecutor.GetDocumentAnalysisDataAsync(DiagnosticAnalyzerDriver analyzerDriver, StateSet stateSet, VersionArgument versions)
   at Microsoft.CodeAnalysis.Diagnostics.EngineV1.DiagnosticIncrementalAnalyzer.&lt;AnalyzeDocumentAsync&gt;d__52.MoveNext() in C:\Roslyn\Main\Open\src\Features\Core\Diagnostics\EngineV1\DiagnosticIncrementalAnalyzer.cs:line 278
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[TStateMachine](TStateMachine&amp; stateMachine)
   at Microsoft.CodeAnalysis.Diagnostics.EngineV1.DiagnosticIncrementalAnalyzer.AnalyzeDocumentAsync(Document document, VersionArgument versions, ImmutableHashSet`1 diagnosticIds, Boolean skipClosedFileChecks, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Diagnostics.EngineV1.DiagnosticIncrementalAnalyzer.&lt;AnalyzeDocumentAsync&gt;d__50.MoveNext() in C:\Roslyn\Main\Open\src\Features\Core\Diagnostics\EngineV1\DiagnosticIncrementalAnalyzer.cs:line 194
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[TStateMachine](TStateMachine&amp; stateMachine)
   at Microsoft.CodeAnalysis.Diagnostics.EngineV1.DiagnosticIncrementalAnalyzer.AnalyzeDocumentAsync(Document document, SyntaxNode bodyOpt, ImmutableHashSet`1 diagnosticIds, Boolean skipClosedFileChecks, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Diagnostics.EngineV1.DiagnosticIncrementalAnalyzer.&lt;AnalyzeDocumentAsync&gt;d__49.MoveNext() in C:\Roslyn\Main\Open\src\Features\Core\Diagnostics\EngineV1\DiagnosticIncrementalAnalyzer.cs:line 175
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[TStateMachine](TStateMachine&amp; stateMachine)
   at Microsoft.CodeAnalysis.Diagnostics.EngineV1.DiagnosticIncrementalAnalyzer.AnalyzeDocumentAsync(Document document, SyntaxNode bodyOpt, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerService.IncrementalAnalyzerDelegatee.AnalyzeDocumentAsync(Document document, SyntaxNode bodyOpt, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Features\Core\Diagnostics\DiagnosticAnalyzerService_IncrementalAnalyzer.cs:line 86
   at Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerRegistrationService.WorkCoordinator.IncrementalAnalyzerProcessor.&lt;&gt;c.&lt;ProcessDocumentAnalyzersAsync&gt;b__26_1(IIncrementalAnalyzer a, Document d, CancellationToken c) in C:\Roslyn\Main\Open\src\Features\Core\SolutionCrawler\WorkCoordinator.IncrementalAnalyzerProcessor.cs:line 175
   at Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerRegistrationService.WorkCoordinator.IncrementalAnalyzerProcessor.&lt;&gt;c__DisplayClass27_1`1.&lt;&lt;RunAnalyzersAsync&gt;b__0&gt;d.MoveNext() in C:\Roslyn\Main\Open\src\Features\Core\SolutionCrawler\WorkCoordinator.IncrementalAnalyzerProcessor.cs:line 197
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.Start[TStateMachine](TStateMachine&amp; stateMachine)
   at Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerRegistrationService.WorkCoordinator.IncrementalAnalyzerProcessor.&lt;&gt;c__DisplayClass27_1`1.&lt;RunAnalyzersAsync&gt;b__0(T v, CancellationToken c)
   at Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerRegistrationService.WorkCoordinator.IncrementalAnalyzerProcessor.&lt;GetOrDefaultAsync&gt;d__29`2.MoveNext() in C:\Roslyn\Main\Open\src\Features\Core\SolutionCrawler\WorkCoordinator.IncrementalAnalyzerProcessor.cs:line 240
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.Start[TStateMachine](TStateMachine&amp; stateMachine)
   at Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerRegistrationService.WorkCoordinator.IncrementalAnalyzerProcessor.GetOrDefaultAsync[TData,TResult](TData value, Func`3 funcAsync, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerRegistrationService.WorkCoordinator.IncrementalAnalyzerProcessor.&lt;RunAnalyzersAsync&gt;d__27`1.MoveNext() in C:\Roslyn\Main\Open\src\Features\Core\SolutionCrawler\WorkCoordinator.IncrementalAnalyzerProcessor.cs:line 195
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[TStateMachine](TStateMachine&amp; stateMachine)
   at Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerRegistrationService.WorkCoordinator.IncrementalAnalyzerProcessor.RunAnalyzersAsync[T](ImmutableArray`1 analyzers, T value, Func`4 runnerAsync, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerRegistrationService.WorkCoordinator.IncrementalAnalyzerProcessor.&lt;ProcessDocumentAnalyzersAsync&gt;d__26.MoveNext() in C:\Roslyn\Main\Open\src\Features\Core\SolutionCrawler\WorkCoordinator.IncrementalAnalyzerProcessor.cs:line 175
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.InvokeMoveNext(Object stateMachine)
   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.Run()
   at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(Action action, Boolean allowInlining, Task&amp; currentTask)
   at System.Threading.Tasks.Task.FinishContinuations()
   at System.Threading.Tasks.Task.FinishStageThree()
   at System.Threading.Tasks.Task`1.TrySetResult(TResult result)
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetResult(TResult result)
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.SetResult()
   at Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerRegistrationService.WorkCoordinator.IncrementalAnalyzerProcessor.&lt;RunAnalyzersAsync&gt;d__27`1.MoveNext() in C:\Roslyn\Main\Open\src\Features\Core\SolutionCrawler\WorkCoordinator.IncrementalAnalyzerProcessor.cs:line 201
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.InvokeMoveNext(Object stateMachine)
   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.Run()
   at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(Action action, Boolean allowInlining, Task&amp; currentTask)
   at System.Threading.Tasks.Task.FinishContinuations()
   at System.Threading.Tasks.Task.FinishStageThree()
   at System.Threading.Tasks.Task`1.TrySetResult(TResult result)
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetResult(TResult result)
   at Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerRegistrationService.WorkCoordinator.IncrementalAnalyzerProcessor.&lt;GetOrDefaultAsync&gt;d__29`2.MoveNext() in C:\Roslyn\Main\Open\src\Features\Core\SolutionCrawler\WorkCoordinator.IncrementalAnalyzerProcessor.cs:line 255
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.InvokeMoveNext(Object stateMachine)
   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.Run()
   at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(Action action, Boolean allowInlining, Task&amp; currentTask)
   at System.Threading.Tasks.Task.FinishContinuations()
   at System.Threading.Tasks.Task.FinishStageThree()
   at System.Threading.Tasks.Task`1.TrySetResult(TResult result)
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetResult(TResult result)
   at Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerRegistrationService.WorkCoordinator.IncrementalAnalyzerProcessor.&lt;&gt;c__DisplayClass27_1`1.&lt;&lt;RunAnalyzersAsync&gt;b__0&gt;d.MoveNext() in C:\Roslyn\Main\Open\src\Features\Core\SolutionCrawler\WorkCoordinator.IncrementalAnalyzerProcessor.cs:line 199
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.InvokeMoveNext(Object stateMachine)
   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.Run()
   at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(Action action, Boolean allowInlining, Task&amp; currentTask)
   at System.Threading.Tasks.Task.FinishContinuations()
   at System.Threading.Tasks.Task.FinishStageThree()
   at System.Threading.Tasks.Task`1.TrySetResult(TResult result)
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetResult(TResult result)
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.SetResult()
   at Microsoft.CodeAnalysis.Diagnostics.EngineV1.DiagnosticIncrementalAnalyzer.&lt;AnalyzeSyntaxAsync&gt;d__47.MoveNext() in C:\Roslyn\Main\Open\src\Features\Core\Diagnostics\EngineV1\DiagnosticIncrementalAnalyzer.cs:line 122
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.InvokeMoveNext(Object stateMachine)
   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.Run()
   at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(Action action, Boolean allowInlining, Task&amp; currentTask)
   at System.Threading.Tasks.Task.FinishContinuations()
   at System.Threading.Tasks.Task.FinishStageThree()
   at System.Threading.Tasks.Task`1.TrySetResult(TResult result)
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetResult(TResult result)
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.SetResult()
   at Microsoft.CodeAnalysis.Diagnostics.EngineV1.DiagnosticIncrementalAnalyzer.&lt;AnalyzeSyntaxAsync&gt;d__48.MoveNext() in C:\Roslyn\Main\Open\src\Features\Core\Diagnostics\EngineV1\DiagnosticIncrementalAnalyzer.cs:line 171
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.InvokeMoveNext(Object stateMachine)
   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.Run()
   at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(Action action, Boolean allowInlining, Task&amp; currentTask)
   at System.Threading.Tasks.Task.FinishContinuations()
   at System.Threading.Tasks.Task.FinishStageThree()
   at System.Threading.Tasks.Task`1.TrySetResult(TResult result)
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetResult(TResult result)
   at Microsoft.CodeAnalysis.Diagnostics.EngineV1.DiagnosticIncrementalAnalyzer.&lt;ShouldRunAnalyzerForStateTypeAsync&gt;d__62.MoveNext() in C:\Roslyn\Main\Open\src\Features\Core\Diagnostics\EngineV1\DiagnosticIncrementalAnalyzer.cs:line 486
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.InvokeMoveNext(Object stateMachine)
   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.Run()
   at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(Action action, Boolean allowInlining, Task&amp; currentTask)
   at System.Threading.Tasks.Task.FinishContinuations()
   at System.Threading.Tasks.Task.FinishStageThree()
   at System.Threading.Tasks.Task`1.TrySetResult(TResult result)
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetResult(TResult result)
   at Microsoft.CodeAnalysis.Diagnostics.EngineV1.DiagnosticIncrementalAnalyzer.&lt;ShouldRunAnalyzerForStateTypeAsync&gt;d__63.MoveNext() in C:\Roslyn\Main\Open\src\Features\Core\Diagnostics\EngineV1\DiagnosticIncrementalAnalyzer.cs:line 512
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.InvokeMoveNext(Object stateMachine)
   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.Run()
   at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(Action action, Boolean allowInlining, Task&amp; currentTask)
   at System.Threading.Tasks.Task.FinishContinuations()
   at System.Threading.Tasks.Task.FinishStageThree()
   at System.Threading.Tasks.Task`1.TrySetResult(TResult result)
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetResult(TResult result)
   at Microsoft.CodeAnalysis.Shared.Extensions.DiagnosticAnalyzerExtensions.&lt;SupportsSyntaxDiagnosticAnalysisAsync&gt;d__2.MoveNext() in C:\Roslyn\Main\Open\src\Features\Core\Shared\Extensions\DiagnosticAnalyzerExtensions.cs:line 84
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.InvokeMoveNext(Object stateMachine)
   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.Run()
   at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(Action action, Boolean allowInlining, Task&amp; currentTask)
   at System.Threading.Tasks.Task.FinishContinuations()
   at System.Threading.Tasks.Task.FinishStageThree()
   at System.Threading.Tasks.Task`1.TrySetResult(TResult result)
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetResult(TResult result)
   at Microsoft.CodeAnalysis.Shared.Extensions.DiagnosticAnalyzerExtensions.&lt;GetDiagnosticAnalyzerCategoryAsync&gt;d__0.MoveNext() in C:\Roslyn\Main\Open\src\Features\Core\Shared\Extensions\DiagnosticAnalyzerExtensions.cs:line 69
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.InvokeMoveNext(Object stateMachine)
   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.Run()
   at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(Action action, Boolean allowInlining, Task&amp; currentTask)
   at System.Threading.Tasks.Task.FinishContinuations()
   at System.Threading.Tasks.Task.FinishStageThree()
   at System.Threading.Tasks.Task`1.TrySetResult(TResult result)
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetResult(TResult result)
   at Microsoft.CodeAnalysis.Diagnostics.EngineV1.DiagnosticAnalyzerDriver.&lt;GetAnalyzerActionsAsync&gt;d__37.MoveNext() in C:\Roslyn\Main\Open\src\Features\Core\Diagnostics\EngineV1\DiagnosticAnalyzerDriver.cs:line 302
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.InvokeMoveNext(Object stateMachine)
   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.Run()
   at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(Action action, Boolean allowInlining, Task&amp; currentTask)
   at System.Threading.Tasks.Task.FinishContinuations()
   at System.Threading.Tasks.Task.FinishStageThree()
   at System.Threading.Tasks.Task`1.TrySetResult(TResult result)
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetResult(TResult result)
   at Microsoft.CodeAnalysis.Diagnostics.EngineV1.DiagnosticAnalyzerDriver.&lt;GetAnalyzerActionsAsync&gt;d__39.MoveNext() in C:\Roslyn\Main\Open\src\Features\Core\Diagnostics\EngineV1\DiagnosticAnalyzerDriver.cs:line 321
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.InvokeMoveNext(Object stateMachine)
   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.Run()
   at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(Action action, Boolean allowInlining, Task&amp; currentTask)
   at System.Threading.Tasks.Task.FinishContinuations()
   at System.Threading.Tasks.Task.FinishStageThree()
   at System.Threading.Tasks.Task`1.TrySetResult(TResult result)
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetResult(TResult result)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerManager.&lt;GetAnalyzerActionsAsync&gt;d__8.MoveNext() in C:\Roslyn\Main\Open\src\Compilers\Core\AnalyzerDriver\AnalyzerManager.cs:line 149
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.InvokeMoveNext(Object stateMachine)
   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.Run()
   at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(Action action, Boolean allowInlining, Task&amp; currentTask)
   at System.Threading.Tasks.Task.FinishContinuations()
   at System.Threading.Tasks.Task.FinishStageThree()
   at System.Threading.Tasks.Task`1.TrySetResult(TResult result)
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetResult(TResult result)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerManager.&lt;GetCompilationAnalysisScopeAsync&gt;d__5.MoveNext() in C:\Roslyn\Main\Open\src\Compilers\Core\AnalyzerDriver\AnalyzerManager.cs:line 95
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.InvokeMoveNext(Object stateMachine)
   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner.Run()
   at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(Action action, Boolean allowInlining, Task&amp; currentTask)
   at System.Threading.Tasks.Task.FinishContinuations()
   at System.Threading.Tasks.Task.FinishStageThree()
   at System.Threading.Tasks.Task.FinishStageTwo()
   at System.Threading.Tasks.Task.Finish(Boolean bUserDelegateExecuted)
   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task&amp; currentTaskSlot)
   at System.Threading.Tasks.Task.ExecuteEntry(Boolean bPreventDoubleExecution)
   at System.Threading.Tasks.Task.System.Threading.IThreadPoolWorkItem.ExecuteWorkItem()
   at System.Threading.ThreadPoolWorkQueue.Dispatch()
   at System.Threading._ThreadPoolWaitCallback.PerformWaitCallback()

StackTrace: 
```

And then the crashing exception:

```
System.IndexOutOfRangeException: Index was outside the bounds of the array.
   at System.Collections.Immutable.ImmutableArray`1.Builder.get_Item(Int32 index)
   at Microsoft.CodeAnalysis.ArrayBuilder`1.get_Item(Int32 index) in C:\Roslyn\Main\Open\src\Compilers\Core\SharedCollections\ArrayBuilder.cs:line 83
   at Microsoft.CodeAnalysis.CSharp.AnalyzedArguments.Argument(Int32 i) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\AnalyzedArguments.cs:line 37
   at Microsoft.CodeAnalysis.CSharp.OverloadResolution.IsApplicable(Symbol candidate, EffectiveParameters parameters, AnalyzedArguments arguments, ImmutableArray`1 argsToParameters, Boolean isVararg, Boolean hasAnyRefOmittedArgument, Boolean ignoreOpenTypes, HashSet`1&amp; useSiteDiagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolution.cs:line 2594
   at Microsoft.CodeAnalysis.CSharp.OverloadResolution.IsApplicable[TMember](TMember member, TMember leastOverriddenMember, ArrayBuilder`1 typeArgumentsBuilder, AnalyzedArguments arguments, EffectiveParameters originalEffectiveParameters, EffectiveParameters constructedEffectiveParameters, ImmutableArray`1 argsToParamsMap, Boolean hasAnyRefOmittedArgument, HashSet`1&amp; useSiteDiagnostics, Boolean inferWithDynamic) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolution.cs:line 2504
   at Microsoft.CodeAnalysis.CSharp.OverloadResolution.IsMemberApplicableInNormalForm[TMember](TMember member, TMember leastOverriddenMember, ArrayBuilder`1 typeArguments, AnalyzedArguments arguments, Boolean isMethodGroupConversion, Boolean allowRefOmittedArguments, Boolean inferWithDynamic, HashSet`1&amp; useSiteDiagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolution.cs:line 2325
   at Microsoft.CodeAnalysis.CSharp.OverloadResolution.AddMemberToCandidateSet[TMember](TMember member, ArrayBuilder`1 results, ArrayBuilder`1 members, ArrayBuilder`1 typeArguments, AnalyzedArguments arguments, Boolean completeResults, Boolean isMethodGroupConversion, Boolean allowRefOmittedArguments, Dictionary`2 containingTypeMapOpt, Boolean inferWithDynamic, HashSet`1&amp; useSiteDiagnostics, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolution.cs:line 495
   at Microsoft.CodeAnalysis.CSharp.OverloadResolution.PerformMemberOverloadResolution[TMember](ArrayBuilder`1 results, ArrayBuilder`1 members, ArrayBuilder`1 typeArguments, AnalyzedArguments arguments, Boolean completeResults, Boolean isMethodGroupConversion, Boolean allowRefOmittedArguments, HashSet`1&amp; useSiteDiagnostics, Boolean inferWithDynamic, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolution.cs:line 233
   at Microsoft.CodeAnalysis.CSharp.OverloadResolution.MethodOrPropertyOverloadResolution[TMember](ArrayBuilder`1 members, ArrayBuilder`1 typeArguments, AnalyzedArguments arguments, OverloadResolutionResult`1 result, Boolean isMethodGroupConversion, Boolean allowRefOmittedArguments, HashSet`1&amp; useSiteDiagnostics, Boolean inferWithDynamic, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolution.cs:line 136
   at Microsoft.CodeAnalysis.CSharp.OverloadResolution.MethodInvocationOverloadResolution(ArrayBuilder`1 methods, ArrayBuilder`1 typeArguments, AnalyzedArguments arguments, OverloadResolutionResult`1 result, HashSet`1&amp; useSiteDiagnostics, Boolean isMethodGroupConversion, Boolean allowRefOmittedArguments, Boolean inferWithDynamic, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolution.cs:line 101
   at Microsoft.CodeAnalysis.CSharp.Binder.ResolveDefaultMethodGroup(BoundMethodGroup node, AnalyzedArguments analyzedArguments, Boolean isMethodGroupConversion, HashSet`1&amp; useSiteDiagnostics, Boolean inferWithDynamic, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 6254
   at Microsoft.CodeAnalysis.CSharp.Binder.ResolveMethodGroupInternal(BoundMethodGroup methodGroup, CSharpSyntaxNode expression, String methodName, AnalyzedArguments analyzedArguments, Boolean isMethodGroupConversion, HashSet`1&amp; useSiteDiagnostics, Boolean inferWithDynamic, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 6147
   at Microsoft.CodeAnalysis.CSharp.Binder.ResolveMethodGroup(BoundMethodGroup node, CSharpSyntaxNode expression, String methodName, AnalyzedArguments analyzedArguments, Boolean isMethodGroupConversion, HashSet`1&amp; useSiteDiagnostics, Boolean inferWithDynamic, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 6122
   at Microsoft.CodeAnalysis.CSharp.Binder.BindMethodGroupInvocation(CSharpSyntaxNode syntax, CSharpSyntaxNode expression, String methodName, BoundMethodGroup methodGroup, AnalyzedArguments analyzedArguments, DiagnosticBag diagnostics, CSharpSyntaxNode queryClause, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Invocation.cs:line 452
   at Microsoft.CodeAnalysis.CSharp.Binder.BindInvocationExpression(CSharpSyntaxNode node, CSharpSyntaxNode expression, String methodName, BoundExpression boundExpression, AnalyzedArguments analyzedArguments, DiagnosticBag diagnostics, CSharpSyntaxNode queryClause, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Invocation.cs:line 222
   at Microsoft.CodeAnalysis.CSharp.Binder.BindInvocationExpression(InvocationExpressionSyntax node, DiagnosticBag diagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Invocation.cs:line 165
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 408
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpression(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 353
   at Microsoft.CodeAnalysis.CSharp.Binder.BindValue(ExpressionSyntax node, DiagnosticBag diagnostics, BindValueKind valueKind) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 288
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionStatement(CSharpSyntaxNode node, ExpressionSyntax syntax, Boolean allowsAnyExpression, DiagnosticBag diagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 418
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionStatement(ExpressionStatementSyntax node, DiagnosticBag diagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 411
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 49
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.IncrementalBinder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs:line 1639
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs:line 1996
   at Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\MethodBodySemanticModel.cs:line 48
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs:line 1397
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLowerBoundNode(CSharpSyntaxNode node) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs:line 369
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node, CSharpSyntaxNode&amp; bindableNode, BoundNode&amp; lowestBoundNode, BoundNode&amp; highestBoundNode, BoundNode&amp; boundParent) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs:line 896
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetSymbolInfoWorker(CSharpSyntaxNode node, SymbolInfoOptions options, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs:line 775
   at Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetSymbolInfoWorker(CSharpSyntaxNode node, SymbolInfoOptions options, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs:line 173
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(ExpressionSyntax expression, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs:line 504
   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\CSharpExtensions.cs:line 443
   at Microsoft.CodeAnalysis.CSharp.Extensions.ExpressionSyntaxExtensions.TryReplaceWithAlias(ExpressionSyntax node, SemanticModel semanticModel, Boolean preferAliasToQualifiedName, CancellationToken cancellationToken, IAliasSymbol&amp; aliasReplacement) in C:\Roslyn\Main\Open\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs:line 868
   at Microsoft.CodeAnalysis.CSharp.Extensions.ExpressionSyntaxExtensions.TryReduce(MemberAccessExpressionSyntax memberAccess, SemanticModel semanticModel, TypeSyntax&amp; replacementNode, TextSpan&amp; issueSpan, OptionSet optionSet, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs:line 722
   at Microsoft.CodeAnalysis.CSharp.Extensions.ExpressionSyntaxExtensions.TryReduceExplicitName(ExpressionSyntax expression, SemanticModel semanticModel, TypeSyntax&amp; replacementNode, TextSpan&amp; issueSpan, OptionSet optionSet, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs:line 665
   at Microsoft.CodeAnalysis.CSharp.Extensions.ExpressionSyntaxExtensions.TryReduceOrSimplifyExplicitName(ExpressionSyntax expression, SemanticModel semanticModel, ExpressionSyntax&amp; replacementNode, TextSpan&amp; issueSpan, OptionSet optionSet, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs:line 637
   at Microsoft.CodeAnalysis.CSharp.Diagnostics.SimplifyTypeNames.CSharpSimplifyTypeNamesDiagnosticAnalyzer.CanSimplifyTypeNameExpression(SemanticModel model, SyntaxNode node, OptionSet optionSet, TextSpan&amp; issueSpan, String&amp; diagnosticId, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Features\CSharp\Diagnostics\Analyzers\CSharpSimplifyTypeNamesDiagnosticAnalyzer.cs:line 132
   at Microsoft.CodeAnalysis.CSharp.Diagnostics.SimplifyTypeNames.CSharpSimplifyTypeNamesDiagnosticAnalyzer.CanSimplifyTypeNameExpressionCore(SemanticModel model, SyntaxNode node, OptionSet optionSet, TextSpan&amp; issueSpan, String&amp; diagnosticId, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Features\CSharp\Diagnostics\Analyzers\CSharpSimplifyTypeNamesDiagnosticAnalyzer.cs:line 93
   at Microsoft.CodeAnalysis.Diagnostics.SimplifyTypeNames.SimplifyTypeNamesDiagnosticAnalyzerBase`1.TrySimplifyTypeNameExpression(SemanticModel model, SyntaxNode node, AnalyzerOptions analyzerOptions, Diagnostic&amp; diagnostic, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Features\Core\Diagnostics\Analyzers\SimplifyTypeNamesDiagnosticAnalyzerBase.cs:line 83
   at Microsoft.CodeAnalysis.CSharp.Diagnostics.SimplifyTypeNames.CSharpSimplifyTypeNamesDiagnosticAnalyzer.&lt;&gt;c__DisplayClass2_0.&lt;AnalyzeNode&gt;b__1(SyntaxNode n) in C:\Roslyn\Main\Open\src\Features\CSharp\Diagnostics\Analyzers\CSharpSimplifyTypeNamesDiagnosticAnalyzer.cs:line 47
   at Microsoft.CodeAnalysis.SyntaxNode.ChildSyntaxListEnumeratorStack..ctor(SyntaxNode startingNode, Func`2 descendIntoChildren) in C:\Roslyn\Main\Open\src\Compilers\Core\Portable\Syntax\SyntaxNode.Iterators.cs:line 50
   at Microsoft.CodeAnalysis.SyntaxNode.&lt;DescendantNodesOnly&gt;d__157.MoveNext() in C:\Roslyn\Main\Open\src\Compilers\Core\Portable\Syntax\SyntaxNode.Iterators.cs:line 378
   at Microsoft.CodeAnalysis.CSharp.Diagnostics.SimplifyTypeNames.CSharpSimplifyTypeNamesDiagnosticAnalyzer.AnalyzeNode(SyntaxNodeAnalysisContext context) in C:\Roslyn\Main\Open\src\Features\CSharp\Diagnostics\Analyzers\CSharpSimplifyTypeNamesDiagnosticAnalyzer.cs:line 58
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.&lt;&gt;c__DisplayClass32_0`1.&lt;ExecuteSyntaxNodeAction&gt;b__1() in C:\Roslyn\Main\Open\src\Compilers\Core\AnalyzerDriver\AnalyzerExecutor.cs:line 298
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.ExecuteAndCatchIfThrows(DiagnosticAnalyzer analyzer, Action analyze, Action`3 onAnalyzerException, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Compilers\Core\AnalyzerDriver\AnalyzerExecutor.cs:line 501
5/10/2015 4:31:38 PM
Source: First chance exception: System.Collections.Immutable
StackTrace:    at System.Collections.Immutable.ImmutableArray`1.Builder.get_Item(Int32 index)
   at Microsoft.CodeAnalysis.ArrayBuilder`1.get_Item(Int32 index) in C:\Roslyn\Main\Open\src\Compilers\Core\SharedCollections\ArrayBuilder.cs:line 83
   at Microsoft.CodeAnalysis.CSharp.AnalyzedArguments.Argument(Int32 i) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\AnalyzedArguments.cs:line 37
   at Microsoft.CodeAnalysis.CSharp.OverloadResolution.IsApplicable(Symbol candidate, EffectiveParameters parameters, AnalyzedArguments arguments, ImmutableArray`1 argsToParameters, Boolean isVararg, Boolean hasAnyRefOmittedArgument, Boolean ignoreOpenTypes, HashSet`1&amp; useSiteDiagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolution.cs:line 2594
   at Microsoft.CodeAnalysis.CSharp.OverloadResolution.IsApplicable[TMember](TMember member, TMember leastOverriddenMember, ArrayBuilder`1 typeArgumentsBuilder, AnalyzedArguments arguments, EffectiveParameters originalEffectiveParameters, EffectiveParameters constructedEffectiveParameters, ImmutableArray`1 argsToParamsMap, Boolean hasAnyRefOmittedArgument, HashSet`1&amp; useSiteDiagnostics, Boolean inferWithDynamic) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolution.cs:line 2504
   at Microsoft.CodeAnalysis.CSharp.OverloadResolution.IsMemberApplicableInNormalForm[TMember](TMember member, TMember leastOverriddenMember, ArrayBuilder`1 typeArguments, AnalyzedArguments arguments, Boolean isMethodGroupConversion, Boolean allowRefOmittedArguments, Boolean inferWithDynamic, HashSet`1&amp; useSiteDiagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolution.cs:line 2325
   at Microsoft.CodeAnalysis.CSharp.OverloadResolution.AddMemberToCandidateSet[TMember](TMember member, ArrayBuilder`1 results, ArrayBuilder`1 members, ArrayBuilder`1 typeArguments, AnalyzedArguments arguments, Boolean completeResults, Boolean isMethodGroupConversion, Boolean allowRefOmittedArguments, Dictionary`2 containingTypeMapOpt, Boolean inferWithDynamic, HashSet`1&amp; useSiteDiagnostics, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolution.cs:line 495
   at Microsoft.CodeAnalysis.CSharp.OverloadResolution.PerformMemberOverloadResolution[TMember](ArrayBuilder`1 results, ArrayBuilder`1 members, ArrayBuilder`1 typeArguments, AnalyzedArguments arguments, Boolean completeResults, Boolean isMethodGroupConversion, Boolean allowRefOmittedArguments, HashSet`1&amp; useSiteDiagnostics, Boolean inferWithDynamic, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolution.cs:line 233
   at Microsoft.CodeAnalysis.CSharp.OverloadResolution.MethodOrPropertyOverloadResolution[TMember](ArrayBuilder`1 members, ArrayBuilder`1 typeArguments, AnalyzedArguments arguments, OverloadResolutionResult`1 result, Boolean isMethodGroupConversion, Boolean allowRefOmittedArguments, HashSet`1&amp; useSiteDiagnostics, Boolean inferWithDynamic, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolution.cs:line 136
   at Microsoft.CodeAnalysis.CSharp.OverloadResolution.MethodInvocationOverloadResolution(ArrayBuilder`1 methods, ArrayBuilder`1 typeArguments, AnalyzedArguments arguments, OverloadResolutionResult`1 result, HashSet`1&amp; useSiteDiagnostics, Boolean isMethodGroupConversion, Boolean allowRefOmittedArguments, Boolean inferWithDynamic, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolution.cs:line 101
   at Microsoft.CodeAnalysis.CSharp.Binder.ResolveDefaultMethodGroup(BoundMethodGroup node, AnalyzedArguments analyzedArguments, Boolean isMethodGroupConversion, HashSet`1&amp; useSiteDiagnostics, Boolean inferWithDynamic, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 6254
   at Microsoft.CodeAnalysis.CSharp.Binder.ResolveMethodGroupInternal(BoundMethodGroup methodGroup, CSharpSyntaxNode expression, String methodName, AnalyzedArguments analyzedArguments, Boolean isMethodGroupConversion, HashSet`1&amp; useSiteDiagnostics, Boolean inferWithDynamic, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 6147
   at Microsoft.CodeAnalysis.CSharp.Binder.ResolveMethodGroup(BoundMethodGroup node, CSharpSyntaxNode expression, String methodName, AnalyzedArguments analyzedArguments, Boolean isMethodGroupConversion, HashSet`1&amp; useSiteDiagnostics, Boolean inferWithDynamic, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 6122
   at Microsoft.CodeAnalysis.CSharp.Binder.BindMethodGroupInvocation(CSharpSyntaxNode syntax, CSharpSyntaxNode expression, String methodName, BoundMethodGroup methodGroup, AnalyzedArguments analyzedArguments, DiagnosticBag diagnostics, CSharpSyntaxNode queryClause, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Invocation.cs:line 452
   at Microsoft.CodeAnalysis.CSharp.Binder.BindInvocationExpression(CSharpSyntaxNode node, CSharpSyntaxNode expression, String methodName, BoundExpression boundExpression, AnalyzedArguments analyzedArguments, DiagnosticBag diagnostics, CSharpSyntaxNode queryClause, Boolean allowUnexpandedForm) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Invocation.cs:line 222
   at Microsoft.CodeAnalysis.CSharp.Binder.BindInvocationExpression(InvocationExpressionSyntax node, DiagnosticBag diagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Invocation.cs:line 165
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 408
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpression(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 353
   at Microsoft.CodeAnalysis.CSharp.Binder.BindValue(ExpressionSyntax node, DiagnosticBag diagnostics, BindValueKind valueKind) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 288
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionStatement(CSharpSyntaxNode node, ExpressionSyntax syntax, Boolean allowsAnyExpression, DiagnosticBag diagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 418
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionStatement(ExpressionStatementSyntax node, DiagnosticBag diagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 411
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 49
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.IncrementalBinder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs:line 1639
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs:line 1996
   at Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\MethodBodySemanticModel.cs:line 48
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs:line 1397
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLowerBoundNode(CSharpSyntaxNode node) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs:line 369
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node, CSharpSyntaxNode&amp; bindableNode, BoundNode&amp; lowestBoundNode, BoundNode&amp; highestBoundNode, BoundNode&amp; boundParent) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs:line 896
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetSymbolInfoWorker(CSharpSyntaxNode node, SymbolInfoOptions options, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs:line 775
   at Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetSymbolInfoWorker(CSharpSyntaxNode node, SymbolInfoOptions options, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs:line 173
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(ExpressionSyntax expression, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs:line 504
   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Compilers\CSharp\Portable\CSharpExtensions.cs:line 443
   at Microsoft.CodeAnalysis.CSharp.Extensions.ExpressionSyntaxExtensions.TryReplaceWithAlias(ExpressionSyntax node, SemanticModel semanticModel, Boolean preferAliasToQualifiedName, CancellationToken cancellationToken, IAliasSymbol&amp; aliasReplacement) in C:\Roslyn\Main\Open\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs:line 868
   at Microsoft.CodeAnalysis.CSharp.Extensions.ExpressionSyntaxExtensions.TryReduce(MemberAccessExpressionSyntax memberAccess, SemanticModel semanticModel, TypeSyntax&amp; replacementNode, TextSpan&amp; issueSpan, OptionSet optionSet, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs:line 722
   at Microsoft.CodeAnalysis.CSharp.Extensions.ExpressionSyntaxExtensions.TryReduceExplicitName(ExpressionSyntax expression, SemanticModel semanticModel, TypeSyntax&amp; replacementNode, TextSpan&amp; issueSpan, OptionSet optionSet, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs:line 665
   at Microsoft.CodeAnalysis.CSharp.Extensions.ExpressionSyntaxExtensions.TryReduceOrSimplifyExplicitName(ExpressionSyntax expression, SemanticModel semanticModel, ExpressionSyntax&amp; replacementNode, TextSpan&amp; issueSpan, OptionSet optionSet, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs:line 637
   at Microsoft.CodeAnalysis.CSharp.Diagnostics.SimplifyTypeNames.CSharpSimplifyTypeNamesDiagnosticAnalyzer.CanSimplifyTypeNameExpression(SemanticModel model, SyntaxNode node, OptionSet optionSet, TextSpan&amp; issueSpan, String&amp; diagnosticId, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Features\CSharp\Diagnostics\Analyzers\CSharpSimplifyTypeNamesDiagnosticAnalyzer.cs:line 132
   at Microsoft.CodeAnalysis.CSharp.Diagnostics.SimplifyTypeNames.CSharpSimplifyTypeNamesDiagnosticAnalyzer.CanSimplifyTypeNameExpressionCore(SemanticModel model, SyntaxNode node, OptionSet optionSet, TextSpan&amp; issueSpan, String&amp; diagnosticId, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Features\CSharp\Diagnostics\Analyzers\CSharpSimplifyTypeNamesDiagnosticAnalyzer.cs:line 93
   at Microsoft.CodeAnalysis.Diagnostics.SimplifyTypeNames.SimplifyTypeNamesDiagnosticAnalyzerBase`1.TrySimplifyTypeNameExpression(SemanticModel model, SyntaxNode node, AnalyzerOptions analyzerOptions, Diagnostic&amp; diagnostic, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Features\Core\Diagnostics\Analyzers\SimplifyTypeNamesDiagnosticAnalyzerBase.cs:line 83
   at Microsoft.CodeAnalysis.CSharp.Diagnostics.SimplifyTypeNames.CSharpSimplifyTypeNamesDiagnosticAnalyzer.&lt;&gt;c__DisplayClass2_0.&lt;AnalyzeNode&gt;b__1(SyntaxNode n) in C:\Roslyn\Main\Open\src\Features\CSharp\Diagnostics\Analyzers\CSharpSimplifyTypeNamesDiagnosticAnalyzer.cs:line 47
   at Microsoft.CodeAnalysis.SyntaxNode.ChildSyntaxListEnumeratorStack..ctor(SyntaxNode startingNode, Func`2 descendIntoChildren) in C:\Roslyn\Main\Open\src\Compilers\Core\Portable\Syntax\SyntaxNode.Iterators.cs:line 50
   at Microsoft.CodeAnalysis.SyntaxNode.&lt;DescendantNodesOnly&gt;d__157.MoveNext() in C:\Roslyn\Main\Open\src\Compilers\Core\Portable\Syntax\SyntaxNode.Iterators.cs:line 378
   at Microsoft.CodeAnalysis.CSharp.Diagnostics.SimplifyTypeNames.CSharpSimplifyTypeNamesDiagnosticAnalyzer.AnalyzeNode(SyntaxNodeAnalysisContext context) in C:\Roslyn\Main\Open\src\Features\CSharp\Diagnostics\Analyzers\CSharpSimplifyTypeNamesDiagnosticAnalyzer.cs:line 58
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.&lt;&gt;c__DisplayClass32_0`1.&lt;ExecuteSyntaxNodeAction&gt;b__1() in C:\Roslyn\Main\Open\src\Compilers\Core\AnalyzerDriver\AnalyzerExecutor.cs:line 298
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.ExecuteAndCatchIfThrows(DiagnosticAnalyzer analyzer, Action analyze, Action`3 onAnalyzerException, CancellationToken cancellationToken) in C:\Roslyn\Main\Open\src\Compilers\Core\AnalyzerDriver\AnalyzerExecutor.cs:line 501
```

&lt;!---
@huboard:{"order":2603.5,"milestone_order":2631,"custom_state":""}
--&gt;
</Description>
        <CreatedDate>10/05/2015</CreatedDate>
        <ClosedDate>13/05/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Binder/Binder_Expressions.cs</File>
      <File>src/Compilers/CSharp/Portable/Binder/Semantics/OverloadResolution/OverloadResolution_ArgsToParameters.cs</File>
      <File>src/Compilers/CSharp/Test/Semantic/Semantics/OverloadResolutionTests.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>2673</IssueID>
    <Title>Don't ignore reference properties and documentation provider passed to MetadataReference.CreateFromAssembly</Title>
    <Description>Fixes #897, #854.
</Description>
    <CreatedDate>12/05/2015</CreatedDate>
    <ClosedDate>12/05/2015</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>897</IssueID>
        <Title>Fix to pass the documentation argument</Title>
        <Description>The bug is described in issue #854
</Description>
        <CreatedDate>26/02/2015</CreatedDate>
        <ClosedDate>12/05/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>854</IssueID>
        <Title>ISymbol.GetDocumentationCommentXml() returns always string.Empty</Title>
        <Description>The call `ISymbol.GetDocumentationCommentXml()` returns always `string.Empty` when the Symbol represents a member of the .NET Framework (e.g. `System.Console.WriteLine`) or a member of a custom Assembly that has a XML documentation file.

It works only for members that are defined via `SourceText` and has the XML comment defined.

I create the assembly references via `MetadataReference.CreateFromAssembly`. A method overload of [CreateFromAssembly](http://source.roslyn.codeplex.com/#Microsoft.CodeAnalysis/MetadataReference/MetadataReference.cs,343f1f8eceb748ff,references) supports a `DocumentationProvder` as parameter but does not use it. This seems to be a bug.

How can I support Documentation for referred .NET Framework assemblies?
</Description>
        <CreatedDate>25/02/2015</CreatedDate>
        <ClosedDate>12/05/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/Core/CodeAnalysisTest/MetadataReferences/MetadataReferenceTests.cs</File>
      <File>src/Compilers/Core/Portable/MetadataReference/MetadataReference.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>2558</IssueID>
    <Title>Blended node pooling</Title>
    <Description>Limit the size of BlendedNode arrays returned to the pool in C# incremental parsing. The 4096 value was determined by gathering statistics on typing scenarios in a reasonably large solution. The pathological case described in #2551 has over 2^19 elements.
Fixes #2551 
</Description>
    <CreatedDate>06/05/2015</CreatedDate>
    <ClosedDate>07/05/2015</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>2551</IssueID>
        <Title>The parser should have caps on the BlendedNode[] pool</Title>
        <Description>Context:

&gt; http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Parser/SyntaxParser.cs,32

The parser caches `BlendedNode[]` allocations using our standard object pools.  This particular array is used for operations like look ahead in the parser.  The array is dynamically grown on demand to accommodate the desired look ahead length. 

When the source file contains bad code this array can get incredibly large.  One such internal bug report sees the array at 2 ^ 24 elements.  In such scenarios we should not be returning the object to the pool.  It just serves to increase the memory footprint of the process.  I'm unsure what the cap should be but 2 ^ 24 seems to be above it ;) 

Yes we should definitely focus on fixing the look ahead issues to not allocate so many elements.  But there will always be code that tricks the parser into going down bad paths and we should do our best to recover from those scenarios.  
</Description>
        <CreatedDate>06/05/2015</CreatedDate>
        <ClosedDate>07/05/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>2551</IssueID>
        <Title>The parser should have caps on the BlendedNode[] pool</Title>
        <Description>Context:

&gt; http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Parser/SyntaxParser.cs,32

The parser caches `BlendedNode[]` allocations using our standard object pools.  This particular array is used for operations like look ahead in the parser.  The array is dynamically grown on demand to accommodate the desired look ahead length. 

When the source file contains bad code this array can get incredibly large.  One such internal bug report sees the array at 2 ^ 24 elements.  In such scenarios we should not be returning the object to the pool.  It just serves to increase the memory footprint of the process.  I'm unsure what the cap should be but 2 ^ 24 seems to be above it ;) 

Yes we should definitely focus on fixing the look ahead issues to not allocate so many elements.  But there will always be code that tricks the parser into going down bad paths and we should do our best to recover from those scenarios.  
</Description>
        <CreatedDate>06/05/2015</CreatedDate>
        <ClosedDate>07/05/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Compilers/CSharp/Portable/Parser/SyntaxParser.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>2515</IssueID>
    <Title>track non roslyn text buffer changes as well as roslyn text buffer chang...</Title>
    <Description>...es to delay solution crawler

There are 2 things incremental processor takes care of

@1 is making sure we delay processing any work until there is enough idle (ex, typing) in host.
@2 is managing cancellation and pending works.

we used to do #1 and #2 only for Roslyn files. and that is usually fine since most of time solution contains only roslyn files.

but for mixed solution (ex, Roslyn files + HTML + JS + CSS), #2 still makes sense but #1 doesn't. We want to pause any work while something is going on in other project types as well.

we need to make sure we play nice with neighbors as well.

now, we don't care where changes are coming from. if there is any change in host, we puase oursevles for a while.
</Description>
    <CreatedDate>05/05/2015</CreatedDate>
    <ClosedDate>07/05/2015</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>1</IssueID>
        <Title>Initial port and addition of README.md</Title>
        <Description>This is a port of the readme from CodePlex.  Some of the links have been updated to point to locations on GitHub, but many of the links still point back to CodePlex as comparable GitHub locations are currently absent.
</Description>
        <CreatedDate>14/01/2015</CreatedDate>
        <ClosedDate>14/01/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>2</IssueID>
        <Title>Update links in README.md with ported wiki content</Title>
        <Description>
        </Description>
        <CreatedDate>14/01/2015</CreatedDate>
        <ClosedDate>14/01/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>2</IssueID>
        <Title>Update links in README.md with ported wiki content</Title>
        <Description>
        </Description>
        <CreatedDate>14/01/2015</CreatedDate>
        <ClosedDate>14/01/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>1</IssueID>
        <Title>Initial port and addition of README.md</Title>
        <Description>This is a port of the readme from CodePlex.  Some of the links have been updated to point to locations on GitHub, but many of the links still point back to CodePlex as comparable GitHub locations are currently absent.
</Description>
        <CreatedDate>14/01/2015</CreatedDate>
        <ClosedDate>14/01/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/Features/Core/SolutionCrawler/IDocumentTrackingService.cs</File>
      <File>src/Features/Core/SolutionCrawler/WorkCoordinator.GlobalOperationAwareIdleProcessor.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/ProjectSystem/DocumentProvider.cs</File>
      <File>src/VisualStudio/Core/Def/Implementation/Workspace/VisualStudioDocumentTrackingService.cs</File>
      <File>src/VisualStudio/Core/Def/RoslynDocumentProvider.cs</File>
    </Files>
  </PullRequest>
  <PullRequest>
    <IssueID>2508</IssueID>
    <Title>Introduce entry named 'Default' in solution explorer context menu for an...</Title>
    <Description>...alyzers

Fixes #1512

The solution explorer context menu that allows users to change severity of analyzer-reported diagnostics currently displays the following entries -
Error
Warning
Info
Hidden
None

When the context menu is displayed, a check mark is displayed next to the entry representing the severity of diagnostic as configured in the project's ruleset file. This works fine in cases where a severity is explicitly specified for the diagnostic in the ruleset file.

However, in cases where the severity is not explicitly specified in the ruleset file, the diagnostic is assigned its 'default' severity and we don't display a check mark against any entry in the above menu. As noted in #1512, this is confusing because the 'default' severity is also one of the severities listed above.

This change introduces an additional entry named 'Default' in the above menu that will be checked in cases where the dagnostic does not have an explicitly specified severity in the ruleset file. If the user clicks this entry to change the severity of some diagnostic to 'Default', the entry corresponding to this diagnostic is removed from the ruleset file.

**Before:**
![before](https://cloud.githubusercontent.com/assets/10579684/7465648/087a0606-f289-11e4-8010-35d7e661c624.PNG)

**After:**
![after](https://cloud.githubusercontent.com/assets/10579684/7465636/d6fd651e-f288-11e4-8d06-ba0b66a321fc.PNG)
</Description>
    <CreatedDate>05/05/2015</CreatedDate>
    <ClosedDate>05/05/2015</ClosedDate>
    <Issues>
      <Issue>
        <IssueID>1512</IssueID>
        <Title>"Set Rule Severity" has no checked items for current effective severity</Title>
        <Description>![nonechecked_effectiveseverity](https://cloud.githubusercontent.com/assets/10605811/6796004/8fd23338-d1a7-11e4-955e-17c44ef2d971.jpg)

I am seeing no severity checked for the default rule. Changing the effective severity to something else causes the new severity to show with a check mark and from then on it always shows the correct effective severity checked.
</Description>
        <CreatedDate>24/03/2015</CreatedDate>
        <ClosedDate>05/05/2015</ClosedDate>
      </Issue>
      <Issue>
        <IssueID>1512</IssueID>
        <Title>"Set Rule Severity" has no checked items for current effective severity</Title>
        <Description>![nonechecked_effectiveseverity](https://cloud.githubusercontent.com/assets/10605811/6796004/8fd23338-d1a7-11e4-955e-17c44ef2d971.jpg)

I am seeing no severity checked for the default rule. Changing the effective severity to something else causes the new severity to show with a check mark and from then on it always shows the correct effective severity checked.
</Description>
        <CreatedDate>24/03/2015</CreatedDate>
        <ClosedDate>05/05/2015</ClosedDate>
      </Issue>
    </Issues>
    <Files>
      <File>src/VisualStudio/Core/Def/ID.RoslynCommands.cs</File>
      <File>src/VisualStudio/Core/SolutionExplorerShim/AnalyzersCommandHandler.cs</File>
      <File>src/VisualStudio/Core/SolutionExplorerShim/DiagnosticItem/DiagnosticItem.cs</File>
    </Files>
  </PullRequest>
</PullRequests>