IssueID,Title,Description,Title_Description,PullRequestID,FixedByID,RepoID
5974,Clear RequestContext when spawning connections,"This was causing reliability issues because new connections could occasionally be started due to a Ping message, which has a `""Ping""` `RequestContext` header set. The connection would then capture that `RequestContext` and would import it into messages created by the `SiloConnection` itself. These messages would then be treated as though they were Ping messages by the remote silo.

Examples of such messages are:
* Rejections for messages destined to an old silo generation
* Directory lookups - this is trickier, it relies on an optimization whereby `IncomingMessageAgent.ReceiveMessage` is called synchronously from the connection 

This would result in timeouts (which can prevent a silo from starting), active silos being declared dead, obscure exceptions such as `Unrecoverable Rejection (info: System.InvalidOperationException: Expected result of type Orleans.GrainDirectory.AddressesAndTag but encountered a null value.)`, and `NullReferenceExceptions` from `ActivationDirectory.FindTarget`","Clear RequestContext when spawning connections  This was causing reliability issues because new connections could occasionally be started due to a Ping message, which has a `""Ping""` `RequestContext` header set. The connection would then capture that `Requ",6357,ReubenBond,orleans
6014,Simplify ConnectionListener.RunAsync,Fixing in response to feedback from @davidfowl,Simplify ConnectionListener.RunAsync  Fixing in response to feedback from @davidfowl,6357,ReubenBond,orleans
6298,Possible issue in SimpleQueueCacheCursor.RecordDeliveryFailure,"I'm looking at the code for `SimpleQueueCacheCursor.RecordDeliveryFailure()`. That code is called by the `PersistentStreamPullingAgent` when the current value retrieved from the cursor could not be delivered. The function looks like this:

https://github.com/dotnet/orleans/blob/7090d7dbb62032f664488c38c6fda85bc4cbb45b/src/OrleansProviders/Streams/Common/SimpleCache/SimpleQueueCacheCursor.cs#L111-L120

The confusing thing is that `Element` is documented as pointing to the next element after current. So it would seem like the DeliveryFailure flag is being set on the element after the one that failed. Which might not be much of a problem as long as such an element always exists, and the code that consumes consumes this flag looks ahead (but that would certainly warrant a comment).  However there is not always a next item, and it looks like the code that consumes this (`SimpleQueueCacheItem.DrainBucket`)  does not look ahead.

So am I missing something, or is this buggy?

If this is buggy, fixing this directly seems tricky, because the value in the cursor's `current` field may no longer even be in the cache, since it could be in the previous cache bucket relative to `Element`, and therefore would be eligible for cleanup.",Possible issue in SimpleQueueCacheCursor.RecordDeliveryFailure  I'm looking at the code for `SimpleQueueCacheCursor.RecordDeliveryFailure()`. That code is called by the `PersistentStreamPullingAgent` when the current value retrieved from the cursor could,6299,KevinCathcart,orleans
6281,SimpleQueueCache mixes delivery receipts,"I need for a custom implementation of IQueueAdapterFactory. In my solution I would like to use SimpleQueueAdapterCache for IQueueAdapterCache GetQueueAdapterCache() method's response. But if I use this implementation I experiences the calls of IQueueAdapterReceiver.MessagesDeliveredAsync(IList<IBatchContainer> messages) are confused.

Expected behavior:
MessagesDeliveredAsync should be called after the subscribed grain processed the IBatchContainer successfully. If the grain throws exception the method shouldn't be called until the retry period (which is 1 min as default) timing out. After the time out the method call shouldn't contain the failed messages. It's important because we can send ACK to the queue after a success message processing.

Current behavior:

1. If there is only one message in the cache it won’t wait to finish processing of it.
2. If there are more than one message in the cache it won’t wait to finish processing of last batch.
3. If processing of any message from the cache is failed the next one batch will be marked as failure (except if the message was the last one in that case nothing will be marked). The marked messages won’t be passed to the MessagesDeliveredAsync method as parameter. So the failed messages will be passed but some of the success won’t be.

Implementation issues:

1. When tries to get the next batch from the cursor here: https://github.com/dotnet/orleans/blob/9699b6df713e461765a825c2d40af0079f6f18de/src/OrleansProviders/Streams/Common/SimpleCache/SimpleQueueCache.cs#L244
it will remove the cursor from the cached message if it was the last one. This will cause the purge thinks there is no consumer on the message here: https://github.com/dotnet/orleans/blob/9699b6df713e461765a825c2d40af0079f6f18de/src/OrleansProviders/Streams/Common/SimpleCache/SimpleQueueCache.cs#L92
2. Reason is same as above.
3. Here the cache should filter the failed messages:
https://github.com/dotnet/orleans/blob/9699b6df713e461765a825c2d40af0079f6f18de/src/OrleansProviders/Streams/Common/SimpleCache/SimpleQueueCache.cs#L121 
But when sets its state here:
https://github.com/dotnet/orleans/blob/9699b6df713e461765a825c2d40af0079f6f18de/src/OrleansProviders/Streams/Common/SimpleCache/SimpleQueueCacheCursor.cs#L118
the Element.Value will point to the next one and not to the “current” variable however the method is called for the “current”.


I created a short code sample for repro:
https://github.com/Gaben007/OrleansCustomStreamProviderTest",SimpleQueueCache mixes delivery receipts  I need for a custom implementation of IQueueAdapterFactory. In my solution I would like to use SimpleQueueAdapterCache for IQueueAdapterCache GetQueueAdapterCache() method's response. But if I use this implementat,6299,KevinCathcart,orleans
6263,Schedule received messages onto .NET ThreadPool,"","Schedule received messages onto .NET ThreadPool  ",6261,ReubenBond,orleans
6264,"Remove AsynchAgent, Executor, and related","Note that this is based on #6261, so that must be merged first, after which I will rebase this onto master","Remove AsynchAgent, Executor, and related  Note that this is based on #6261, so that must be merged first, after which I will rebase this onto master",6261,ReubenBond,orleans
5818,Implementing a method in an interface which hides a method in a base interface will cause codegen errors which don't easily give in to human understanding,"kidding but having an interface like 

```csharp
interface BaseFoo : IGrainWithStringKey
{
Task Bar();
}
```

And another

```
interface Foo : BaseFoo
{
new Task Bar();
}
```

Will cause codegen issues using both the `Microsoft.Orleans.CodeGenerator.MSBuild` package and the older one and the error mentions the id of the interface/method being a duplicate but the id cannot be found in codegen, however thanks to @ReubenBond  I found that if you look at the line mentioned, t he method will be there.

Double clicking in VS 2019 does not bring the codegen file up since it is in obj folder so you should know where it is to find it.

Best is to either have an analyzer not allowing methods hiding parent methods (since this is an error most of the times) or at least show an error with the method names involved. IMHO fixing this to generate correct code for it is not even required since almost always you don't want to do this in your interfaces","Implementing a method in an interface which hides a method in a base interface will cause codegen errors which don't easily give in to human understanding  kidding but having an interface like 

```csharp
interface BaseFoo : IGrainWithStringKey
{
Tas",6007,ReubenBond,orleans
5295,The switch statement contains multiple cases with label value...,"Grain interfaces with duplicate/hidden method definitions of a base interface cause invalid code to be generated.

Example:
```C#
public interface IBaseGrain : IGrainWithGuidKey
{
    Task Foo();
}

public interface IFooGrain : IBaseGrain
{
    Task Foo();
}
```

Ends up generating:

```C#
switch (methodId)
{
    case (int)0x6D596ED9:
        return ""Foo"";
    // ...
    case (int)0x6D596ED9:
        return ""Foo"";
    // ...
}
```

Normal VS setup does cause a warning on the hidden method but that doesn't break compilation. The generated code does.

I'll see if I can get around to a PR. Not sure I'll have time though. :( Likely either deduping in GrainInterfaceCommon.GenerateGrainInterfaceAndMethodSwitch *or*, perhaps more properly, accounting for hidden methods during ID generation in OrleansLegacyCompat.GetMethodId...","The switch statement contains multiple cases with label value...  Grain interfaces with duplicate/hidden method definitions of a base interface cause invalid code to be generated.

Example:
```C#
public interface IBaseGrain : IGrainWithGuidKey
{",6007,ReubenBond,orleans
4748,Exception thrown during OnActivateAsync not posted to client?,"I try this: a grain implemented Grain(T), while the entity T can not be found in storage during OnActivateAsync, a EntityNotFoundException will be thrown. And the exception will not be posted to the client. How can I handle this error?","Exception thrown during OnActivateAsync not posted to client?  I try this: a grain implemented Grain(T), while the entity T can not be found in storage during OnActivateAsync, a EntityNotFoundException will be thrown. And the exception will not be posted",5998,ReubenBond,orleans
5397,Test Reliability: ExceptionPropagation_ClientToGrain_SerializationFailure,"UnitTests.General.ExceptionPropagationTests.ExceptionPropagation_ClientToGrain_SerializationFailure is flaky. Example test run: https://ci.dot.net/job/dotnet_orleans/job/master/job/functional_prtest/2578/testReport/junit/UnitTests.General/ExceptionPropagationTests/ExceptionPropagation_ClientToGrain_SerializationFailure/

```
Stacktrace

MESSAGE:
Assert.Throws() Failure\r\nExpected: typeof(System.NotSupportedException)\r\nActual: 
typeof(System.TimeoutException): Response did not arrive on time in 00:00:30 for message: Request 
*cli/1770639c@44a482a6->S127.0.0.1:42555:0*grn/415DDB74/41aaf750 #5478: . Target History is: 
<S127.0.0.1:42555:0:*grn/415DDB74/41aaf750:>.

+++++++++++++++++++
STACK TRACE:
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at 
System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
```",Test Reliability: ExceptionPropagation_ClientToGrain_SerializationFailure  UnitTests.General.ExceptionPropagationTests.ExceptionPropagation_ClientToGrain_SerializationFailure is flaky. Example test run: https://ci.dot.net/job/dotnet_orleans/job/master/job,5998,ReubenBond,orleans
5978,Exception deserialization failure,"When the client does not refer to the server's Exception type, Client will fail and timeout error will be raised.I think there should be a general approach.","Exception deserialization failure  When the client does not refer to the server's Exception type, Client will fail and timeout error will be raised.I think there should be a general approach.",5998,ReubenBond,orleans
5847,IMembershipOracle not added to services in 2.4.0?,"Doing a test-run upgrade to 2.4.0 and my health-check hosted service, which is modeled partially off of the one in Samples\2.3, fails to resolve its dependency on `IMembershipOracle` when using `UseOrleans`, crashing the startup process. I don't see anything in the change log or reviewing the recent commits that indicates registration of this type was removed. I _do_ see that there is now another type implementing the `IHealthCheckParticipant` interface, `MembershipTableManager` (registration of which was added in DefaultSiloServices). I've update my hosted service to expect an `IEnumerable<IHealthCheckParticipant>` instead of just the `IMembershipOracle` and things are working smoothly now. Would this be the suggested work around?","IMembershipOracle not added to services in 2.4.0?  Doing a test-run upgrade to 2.4.0 and my health-check hosted service, which is modeled partially off of the one in Samples\2.3, fails to resolve its dependency on `IMembershipOracle` when using `UseOrlean",5988,ReubenBond,orleans
5987,Remove unused IMembershipOracle interface,"Fixes #5985

See #5847","Remove unused IMembershipOracle interface  Fixes #5985

See #5847",5988,ReubenBond,orleans
5985,Remove IMembershipOracle,"`IMembershipOracle` is no longer used as it has been split up into smaller parts which are each responsible for less. We should remove it for 3.0

Fixes #5847","Remove IMembershipOracle  `IMembershipOracle` is no longer used as it has been split up into smaller parts which are each responsible for less. We should remove it for 3.0

Fixes #5847",5987,ReubenBond,orleans
5847,IMembershipOracle not added to services in 2.4.0?,"Doing a test-run upgrade to 2.4.0 and my health-check hosted service, which is modeled partially off of the one in Samples\2.3, fails to resolve its dependency on `IMembershipOracle` when using `UseOrleans`, crashing the startup process. I don't see anything in the change log or reviewing the recent commits that indicates registration of this type was removed. I _do_ see that there is now another type implementing the `IHealthCheckParticipant` interface, `MembershipTableManager` (registration of which was added in DefaultSiloServices). I've update my hosted service to expect an `IEnumerable<IHealthCheckParticipant>` instead of just the `IMembershipOracle` and things are working smoothly now. Would this be the suggested work around?","IMembershipOracle not added to services in 2.4.0?  Doing a test-run upgrade to 2.4.0 and my health-check hosted service, which is modeled partially off of the one in Samples\2.3, fails to resolve its dependency on `IMembershipOracle` when using `UseOrlean",5987,ReubenBond,orleans
5925,Unable to use TestSilo on 3.0,"According to this https://github.com/dotnet/orleans/blob/dad62cc16d4d6de671563f6b1e54196f617926a5/src/Orleans.Core/Logging/FileLogger.cs#L141 it looks like we're depending on the _old_ pubternal types there were all removed on .Net Core 3.0. 

With that we're unable to run unit test using the TestCluster as it fail to start with this:

```
warn: Microsoft.Orleans.Networking[0]
      Connection to endpoint S127.0.0.1:25980:0 terminated with exception System.AggregateException: An error occurred while writing to logger(s). (Could not load type 'Microsoft.Extensions.Logging.Abstractions.Internal.NullScope' from assembly 'Microsoft.Extensions.Logging.Abstractions, Version=3.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60'.)
       ---> System.TypeLoadException: Could not load type 'Microsoft.Extensions.Logging.Abstractions.Internal.NullScope' from assembly 'Microsoft.Extensions.Logging.Abstractions, Version=3.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60'.
         at Orleans.Logging.FileLogger.BeginScope[TState](TState state)
         at Microsoft.Extensions.Logging.ScopeLogger.CreateScope[TState](TState state)
         at Microsoft.Extensions.Logging.Logger.BeginScope[TState](TState state)
         --- End of inner exception stack trace ---
         at Microsoft.Extensions.Logging.Logger.ThrowLoggingError(List`1 exceptions)
         at Microsoft.Extensions.Logging.Logger.BeginScope[TState](TState state)
         at Orleans.Runtime.Messaging.NetworkingTrace.BeginScope[TState](TState state)
         at Orleans.Runtime.Messaging.ConnectionManager.BeginConnectionScope(Connection connection)
         at Orleans.Runtime.Messaging.ConnectionManager.<>c__DisplayClass19_1.<<ConnectAsync>b__0>d.MoveNext()
```

And the test silo is killed.

I've tried to avoid to load Orleans provider but it looks like it doesn't not respect my `ClearProviders` call and add its own anyway:

```
hostBuilder.ConfigureLogging(log =>
            {
                log.ClearProviders();
                log.AddConsole();
            });
```

According to https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.abstractions.internal.nullscope?view=aspnetcore-2.2&viewFallbackFrom=aspnetcore-3.0 the type indeed was removed...

Any workarounds for now?

Thanks!",Unable to use TestSilo on 3.0  According to this https://github.com/dotnet/orleans/blob/dad62cc16d4d6de671563f6b1e54196f617926a5/src/Orleans.Core/Logging/FileLogger.cs#L141 it looks like we're depending on the _old_ pubternal types there were all removed,5943,ReubenBond,orleans
5611,Exceptions when using aspnetcore preview 5,"Hello

I just made the simplest app possible with orleans and aspnetcore preview 5

``` C#
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.Hosting;
using Orleans.Hosting;

namespace WebApplication6
{
    public class Program
    {
        public static void Main(string[] args)
        {
            CreateHostBuilder(args).Build().Run();
        }

        public static IHostBuilder CreateHostBuilder(string[] args) =>
            Host.CreateDefaultBuilder(args)
                .ConfigureWebHostDefaults(webBuilder => { webBuilder.UseStartup<Startup>(); })
                .UseOrleans(x =>
                {
                    x.UseLocalhostClustering();
                });
    }
}
```

it threw this when I started it:

`System.AggregateException: 'Some services are not able to be constructed (Error while validating the service descriptor 'ServiceType: Orleans.Streams.Core.IStreamSubscriptionHandleFactory Lifetime: Singleton ImplementationType: Orleans.Streams.StreamSubscriptionHandlerFactory': Unable to resolve service for type 'Orleans.Streams.IStreamProvider' while attempting to activate 'Orleans.Streams.StreamSubscriptionHandlerFactory'.)`","Exceptions when using aspnetcore preview 5  Hello

I just made the simplest app possible with orleans and aspnetcore preview 5

``` C#
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.Hosting;
using Orleans.Hosting;

namespace WebAp",5943,ReubenBond,orleans
5859,Log options on silo and client startup,"","Log options on silo and client startup  ",5864,sergeybykov,orleans
5863,Fix for Clustering providers that does not implement extended Membership Protocol,Fix for #5857,Fix for Clustering providers that does not implement extended Membership Protocol  Fix for #5857,5864,sergeybykov,orleans
5859,Log options on silo and client startup,"","Log options on silo and client startup  ",5862,sergeybykov,orleans
5863,Fix for Clustering providers that does not implement extended Membership Protocol,Fix for #5857,Fix for Clustering providers that does not implement extended Membership Protocol  Fix for #5857,5862,sergeybykov,orleans
5701,LocalGrainDirectory: use membership snapshots,"","LocalGrainDirectory: use membership snapshots  ",5744,ReubenBond,orleans
5731,Fix race introduced in membership,"","Fix race introduced in membership  ",5744,ReubenBond,orleans
5473,Microsoft.Orleans.CodeGenerator.MSBuild 2.2.4 infinite loop,"The following code is probably causing an infinite loop in `Microsoft.Orleans.CodeGenerator.MSBuild`. 
When I build the following code, it hangs after generating `..orleans.g.args.txt`

this is the exit error message:
```
Orleans.CodeGenerator - command-line = SourceToSource /code/GrainInterfaces/obj/Debug/netstandard2.0/GrainInterfaces.orleans.g.args.txt
<...hangs for a long time...>
         Process is terminating due to StackOverflowException.
```

This code compiles without problem with `Microsoft.Orleans.OrleansCodeGenerator.Build`, `2.2.4`

GrainInterface.cs

```
    public interface IFoo : IGrainWithGuidKey
    {
        Task Bar(Complex request);
    }
```

Complex.cs
```
    public class Complex : Simple<Complex>
    {    
    }
    
    public abstract class Simple<T> where T : Simple<T>
    {
        public T DoSomething(T input)
        {
            // do something to input
            return input;
        }
    }
```

It is probably this line `public abstract class Simple<T> where T : Simple<T>` that is causing the infinite loop.","Microsoft.Orleans.CodeGenerator.MSBuild 2.2.4 infinite loop  The following code is probably causing an infinite loop in `Microsoft.Orleans.CodeGenerator.MSBuild`. 
When I build the following code, it hangs after generating `..orleans.g.args.txt`

this",5690,sergeybykov,orleans
5688,Fix #5473 - StackOverflowException in codegen for recursively defined types,Fixes #5473,Fix #5473 - StackOverflowException in codegen for recursively defined types  Fixes #5473,5690,sergeybykov,orleans
5661,Unable to set MetadataPropertyHandling on serializer in AdoNet persistence,"WHen  using `TypeNameHandling` settings which write the type info to the serialized JSON, deserialization only works when the `$id` and `$type` property are the first two properties in the serialized JSON string.

For example, it is possible to get this serialized JSON:

```
{
  ""$id"": ""1"",
  ""$type"": ""HelloWorld.Grains.GreetingArchive, HelloWorld.Grains"",
  ""Greetings"": {
    ""$type"": ""System.Collections.Generic.List`1[[HelloWorld.Interfaces.IInterface, HelloWorld.Interfaces]], System.Private.CoreLib"",
    ""$values"": [
      {
        ""$id"": ""2"",
        ""Foo"": ""Bar"",
        ""$type"": ""HelloWorld.Interfaces.Item, HelloWorld.Interfaces"",
        ""Message"": ""Good morning, my friend!""
      }
    ]
  }
}
```

Which will not deserialize

>Could not create an instance of type HelloWorld.Interfaces.IInterface. Type is an interface or abstract class and cannot be instantiated. Path 'Greetings.$values[0].Foo', line 1, position 252

However, it is possible for JSON.NET to deserialize this JSON by setting `MetadataPropertyHandling = MetadataPropertyHandling.ReadAhead` - however this option is not exposed by `AdoNetGrainStorageOptions` (as an aside, nor are many other options on the `JsonSerializerSettings`).

This issue causes many problems on deserialization when grain state contains an array/collection of concrete interface implementations. 
","Unable to set MetadataPropertyHandling on serializer in AdoNet persistence  WHen  using `TypeNameHandling` settings which write the type info to the serialized JSON, deserialization only works when the `$id` and `$type` property are the first two properti",5684,sergeybykov,orleans
5662,Add ConfigureJsonSerializerSettings delegate to storage providers,…pertyHandling to serializer settings,Add ConfigureJsonSerializerSettings delegate to storage providers  …pertyHandling to serializer settings,5684,sergeybykov,orleans
5656,Make transaction log group max size configurable,"When trying to determine cause of broken lock exceptions this was useful.
I can also see it being used to adapt to different storage latencies.","Make transaction log group max size configurable  When trying to determine cause of broken lock exceptions this was useful.
I can also see it being used to adapt to different storage latencies.",5684,sergeybykov,orleans
5677,Reduce delay localdirectory when cluster membership is not stable,"When the `LocalGrainDirectory` receives a register/unregister request that needs to be forwarded (it can happen when all silos doesn't have the same view of the cluster membership), it currently wait 5 seconds before forwarding, to allow some time for the membership changes to propagate.

200ms seems to be a better value since with gossip the membership change should propagate quickly.","Reduce delay localdirectory when cluster membership is not stable  When the `LocalGrainDirectory` receives a register/unregister request that needs to be forwarded (it can happen when all silos doesn't have the same view of the cluster membership), it cur",5684,sergeybykov,orleans
5570,Prevent NullReferenceException with some storage providers when state is Nullable<T>,"Fixes #5569 

The change has been tested in a real cluster.","Prevent NullReferenceException with some storage providers when state is Nullable<T>  Fixes #5569 

The change has been tested in a real cluster.",5576,sergeybykov,orleans
5575,Fix RequestContext.PropagateActivityId value in Hosted Client scenario,"When hosted client is enabled (default in 2.3.0+), the value of `SiloMessagingOptions.PropagateActivityId` is being overridden by `ClientMessagingOptions.PropagateActivityId` in the `ClusterClient` constructor.

This workaround ensures that the `SiloMessagingOptions` value takes precedence. It's not perfect - a user could set conflicting values on both classes.

See long-term fix in #5574","Fix RequestContext.PropagateActivityId value in Hosted Client scenario  When hosted client is enabled (default in 2.3.0+), the value of `SiloMessagingOptions.PropagateActivityId` is being overridden by `ClientMessagingOptions.PropagateActivityId` in the `",5576,sergeybykov,orleans
828,Adding optional TLS/encryption to transport channel,"Adding TLS option to client-silo and inter-silo communications would make a great end-to-end encryption promise when combined with encryption between silo and storage. It looks like using TLS in socket connections involves adding a configuration option to settings and then applying it to socket connections. Encryption between silos and storage is less clear to me otherwise than that it may require more than simply changing connection string (for instance, here's background material for [Azure Table Storage](http://blogs.msdn.com/b/windowsazurestorage/archive/2015/04/28/client-side-encryption-for-microsoft-azure-storage-preview.aspx)).

To get this going, what would be needed to add encryption?
1. Where and what kind of parameters should be added to configuration to support TLS on client-silo and inter-silo communications? It would feel like it's appropriate to allow different settings to apply to option between inter-silo and client-silo communications.
2. Whe are in code are relevant places handling socket communications and apply encryption settings?
3. Some consideration should be given on adding encryption on per-provider basis and maybe separated to their respective tickets, but I'll add here to get things going.",Adding optional TLS/encryption to transport channel  Adding TLS option to client-silo and inter-silo communications would make a great end-to-end encryption promise when combined with encryption between silo and storage. It looks like using TLS in socket,5436,ReubenBond,orleans
1372,Outsourcing of network layer to 3rd party libraries,"This question has been brought up more than once - should we 'outsource' the low level networking/socket layer of the Orleans stack to a 3rd party library instead of maintaining the code that deals with socket connections, sending/receiving messages, and buffer pool management within the Orleans codebase.

Potential benefits:
- Reduction of the codebase and its maintenance cost 
- 'Free' support for features like TLS
- Pluggable networking layer that would allow to swap implementations in the future easily
- Ability to easily add additional network protocols, such as HTTP, AMQP, MQTT

Concerns:
- Loss of control and flexibility in detecting and handling network issues
- Loss of low level performance optimizations
- Serialization needs buffer pools for efficiency even if we outsource buffer management for communication

Another somewhat related question that's been discussed is about opening up the Orleans messaging protocol, so that requests to grains could be sent without the need for OrleansClient and from different software stacks and languages.

The first step is to have a virtual meeting to go over the existing implementation of the networking/messaging layer to get interested people more familiar with the status quo and to answer any questions about it.

This issue is intended for accumulating initial questions and ideas in preparation for the meeting. Please comment to add or correct.",Outsourcing of network layer to 3rd party libraries  This question has been brought up more than once - should we 'outsource' the low level networking/socket layer of the Orleans stack to a 3rd party library instead of maintaining the code that deals with,5436,ReubenBond,orleans
307,"Orleans sockets, would there be need for more performance?","Out of curiosity I took a look at [SocketManager](https://github.com/dotnet/orleans/blob/master/src/Orleans/Messaging/SocketManager.cs) and [related](https://github.com/dotnet/orleans/search?utf8=%E2%9C%93&q=SocketManager) and I was wondering has anyone considered either [SocketEventAsyncArgs](https://msdn.microsoft.com/en-us/library/system.net.sockets.socketasynceventargs%28v=vs.110%29.aspx) or things like [RIO](http://channel9.msdn.com/Events/Build/BUILD2011/SAC-593T) (if this is a good source)/[RDMA](https://msdn.microsoft.com/en-us/library/cc904397%28v=vs.85%29.aspx)?

Long time ago, during the .NET 3.5 era (before `async`, that is) and when Windows Server 2003 was good stuff, I implemented a high-performance soft-realtime socket server and got much better performance with [SocketAsyncEventArgs](https://msdn.microsoft.com/en-us/library/system.net.sockets.socketasynceventargs%28v=vs.110%29.aspx). I suppose one factor here is how much of churn there is in senders (e.g. new connections) and world has moved on a bit with the new async interfaces.

Nevertheless, I was thinking some computing scenarios and things like high-performance trading (those guys strip down Linux kernels or have moved to FPGA already) where not so long ago this was quite hot. Some problems I once upon time dodgde are nicely enumerated at [Long running async and memory fragmentation](http://ayende.com/blog/170243/long-running-async-and-memory-fragmentation) (of RavenDb fame, see especially the discussion) and I noticed Cassandra is using [SocketEventAsyncArgs too](https://github.com/datastax/csharp-driver/blob/7150905d316f5cc2da2d598b2eee461c0292cb46/src/Cassandra/TcpSocket.cs#L39). As a final note for those curious [Awaiting Socket Operations](http://blogs.msdn.com/b/pfxteam/archive/2011/12/15/10248293.aspx).

Now that I got this far, I wonder does anyone have use cases for maximum socket performance or would it be nice to have features like these (as in closer to metal and less memory pinning)? Inter-datacenter messaging perhaps? Some inter-silo computing transferring a lot of data?","Orleans sockets, would there be need for more performance?  Out of curiosity I took a look at [SocketManager](https://github.com/dotnet/orleans/blob/master/src/Orleans/Messaging/SocketManager.cs) and [related](https://github.com/dotnet/orleans/search?utf8",5436,ReubenBond,orleans
5184,Add GSI cache maintentance and tests,"Fixes the problem where a global-single-instance grain becomes permanently unavailable on a cluster because its directory entry points to a remote cluster that is no longer responsive, even if that cluster has been removed from the multi-cluster.

I added tests to expose the problem behavior, and code that implements a fix.

**Tests:**

The tests use two clusters A and B, create a grain in A, then access it from B (which means cluster B now caches the reference to the grain in A). Then I block communication from A to B (to simulate cluster A going down), and change the multi-cluster configuration to remove A from the multi-cluster (to simulate an admin responding to the outage). Then I try to access the grain from B. Without the fix, this times out trying to contact a non-responding silo in cluster A. With the fix (and if I wait long enough for the cache cleanup to complete before trying to access the grain) this succeeds because the dangling cached reference was removed.

The difference between the two tests is scale (number of grains, silos, clients).

**Fix:**

I added code that validates GSI remote references stored in the grain directory. It is triggered both periodically (30s default), and also immediately after a multi-cluster configuration change.

The validation logic is pretty simple: To check if a reference to a remote cluster should be kept, it pings the silo, and the silo responds with its cluster ID (this is not a throughput hazard… the whole validation happens at a low period, there is only one ping per remote silo, and the ping is a tiny message).

If the response indicates the cluster is not part of the configuration, OR if the response times out, we remove the GSI remote reference from the grain directory. 

This is always safe from a correctness perspective (the reference is logically just a cache), and from a performance perspective, I believe it is ok also: if things are in flux or we timed out for random reasons, it just means the cache may be removed sooner than necessary, but still not “extremely too soon” since this whole validation triggers at a modest period (30s default). 
","Add GSI cache maintentance and tests  Fixes the problem where a global-single-instance grain becomes permanently unavailable on a cluster because its directory entry points to a remote cluster that is no longer responsive, even if that cluster has been re",5254,sergeybykov,orleans
5145,Fix call chain reentrancy,"Current behavior is to only allow call chain re-entrancy on A->B->A or A->A. This adds a new option for allowing A->B->C->A. Also flow the reentrancy context via RequestContext so that it can be viewed and serialized by the application layer.

* Refactor re-entrancy tests to use common code
* Change bool to enum in config and introduce new option CallChainReentrancyStrategy.EntireChain

Passes call chain tests. Sending an early version for feedback on the approach.

Remaining questions:
* Do we want to reconcile the code for Single Call and full call chain?
* Do we want to eliminate the option for single call (probably needs perf testing to determine impact)
* Still need to figure out logging in tests",Fix call chain reentrancy  Current behavior is to only allow call chain re-entrancy on A->B->A or A->A. This adds a new option for allowing A->B->C->A. Also flow the reentrancy context via RequestContext so that it can be viewed and serialized by the appl,5254,sergeybykov,orleans
5225,Remove RequestInvocationHistorySummary to fix backward compatibility,"#5145 was a breaking change (my bad)

Removing the added type `RequestInvocationHistorySummary` and using the previous `RequestInvocationHistory` implementation fix the bc issue while keeping the fix from #5145","Remove RequestInvocationHistorySummary to fix backward compatibility  #5145 was a breaking change (my bad)

Removing the added type `RequestInvocationHistorySummary` and using the previous `RequestInvocationHistory` implementation fix the bc issue while",5254,sergeybykov,orleans
5249,"Revert: Fix call chain reentrancy (#5145, #5225)",#5145 apparently caused a noticeable performance regression (12%-15%). This is to revert it along with #5225 that accompanied it. We can revisit the change and look at optimizing it post 2.2.0.,"Revert: Fix call chain reentrancy (#5145, #5225)  #5145 apparently caused a noticeable performance regression (12%-15%). This is to revert it along with #5225 that accompanied it. We can revisit the change and look at optimizing it post 2.2.0.",5254,sergeybykov,orleans
5145,Fix call chain reentrancy,"Current behavior is to only allow call chain re-entrancy on A->B->A or A->A. This adds a new option for allowing A->B->C->A. Also flow the reentrancy context via RequestContext so that it can be viewed and serialized by the application layer.

* Refactor re-entrancy tests to use common code
* Change bool to enum in config and introduce new option CallChainReentrancyStrategy.EntireChain

Passes call chain tests. Sending an early version for feedback on the approach.

Remaining questions:
* Do we want to reconcile the code for Single Call and full call chain?
* Do we want to eliminate the option for single call (probably needs perf testing to determine impact)
* Still need to figure out logging in tests",Fix call chain reentrancy  Current behavior is to only allow call chain re-entrancy on A->B->A or A->A. This adds a new option for allowing A->B->C->A. Also flow the reentrancy context via RequestContext so that it can be viewed and serialized by the appl,5249,sergeybykov,orleans
5225,Remove RequestInvocationHistorySummary to fix backward compatibility,"#5145 was a breaking change (my bad)

Removing the added type `RequestInvocationHistorySummary` and using the previous `RequestInvocationHistory` implementation fix the bc issue while keeping the fix from #5145","Remove RequestInvocationHistorySummary to fix backward compatibility  #5145 was a breaking change (my bad)

Removing the added type `RequestInvocationHistorySummary` and using the previous `RequestInvocationHistory` implementation fix the bc issue while",5249,sergeybykov,orleans
5236,Update ZooKeeperNetEx package to 3.4.12.1,"","Update ZooKeeperNetEx package to 3.4.12.1  ",5242,sergeybykov,orleans
5238,Include exception in TryForwardRequest info log,Adds the `Exception` to the existing log message.,Include exception in TryForwardRequest info log  Adds the `Exception` to the existing log message.,5242,sergeybykov,orleans
5230,Improve logging of stream delivery errors.,Attempt to address #5205,Improve logging of stream delivery errors.  Attempt to address #5205,5242,sergeybykov,orleans
5214,Support ProxyGatewayEndpoint from legacy configuration,"Propagates the `ProxyGatewayEndpoint` setting from legacy `NodeConfiguration` to `EndpointOptions`. The silo-to-silo endpoint options are being propagated correctly and don't need to change.

~~`GatewayPort` is redundant and should not be used if `GatewayEndpoint` is set, but it shouldn't hurt to explicitly set it anyway.~~ EDIT: setting gateway port here `GatewayPort` wasn't redundant: it was being used to determine whether or not to start a gateway, etc. I added changes to fix that.","Support ProxyGatewayEndpoint from legacy configuration  Propagates the `ProxyGatewayEndpoint` setting from legacy `NodeConfiguration` to `EndpointOptions`. The silo-to-silo endpoint options are being propagated correctly and don't need to change.

~~`Ga",5242,sergeybykov,orleans
5213,Fix AzureSilo startup,"We saw an issue with `AzureSilo` which amounts to discrepancies between the membership table entry published manually by `AzureSilo` during startup and the entry published by the `IMembershipTable` implementation.

Two main changes: 

* Do not manually publish an entry into the table
* Do not manually configure a silo generation (which will be overwritten later anyway).

We can include this post 2.2.0-rc1","Fix AzureSilo startup  We saw an issue with `AzureSilo` which amounts to discrepancies between the membership table entry published manually by `AzureSilo` during startup and the entry published by the `IMembershipTable` implementation.

Two main change",5228,sergeybykov,orleans
5225,Remove RequestInvocationHistorySummary to fix backward compatibility,"#5145 was a breaking change (my bad)

Removing the added type `RequestInvocationHistorySummary` and using the previous `RequestInvocationHistory` implementation fix the bc issue while keeping the fix from #5145","Remove RequestInvocationHistorySummary to fix backward compatibility  #5145 was a breaking change (my bad)

Removing the added type `RequestInvocationHistorySummary` and using the previous `RequestInvocationHistory` implementation fix the bc issue while",5228,sergeybykov,orleans
5145,Fix call chain reentrancy,"Current behavior is to only allow call chain re-entrancy on A->B->A or A->A. This adds a new option for allowing A->B->C->A. Also flow the reentrancy context via RequestContext so that it can be viewed and serialized by the application layer.

* Refactor re-entrancy tests to use common code
* Change bool to enum in config and introduce new option CallChainReentrancyStrategy.EntireChain

Passes call chain tests. Sending an early version for feedback on the approach.

Remaining questions:
* Do we want to reconcile the code for Single Call and full call chain?
* Do we want to eliminate the option for single call (probably needs perf testing to determine impact)
* Still need to figure out logging in tests",Fix call chain reentrancy  Current behavior is to only allow call chain re-entrancy on A->B->A or A->A. This adds a new option for allowing A->B->C->A. Also flow the reentrancy context via RequestContext so that it can be viewed and serialized by the appl,5225,benjaminpetit,orleans
4382,Don't enforce reentrancy for one way requests,"The deadlock prevention mechanism shouldn't affect the one-way requests, as they can not cause the deadlocks. 

This PR fixes the following cases:
- A -> B -> A chain:
![image 1](https://user-images.githubusercontent.com/5787619/38162256-b41fba08-34e6-11e8-9a29-3bbc027ea7bf.png)
 - And A -> A chain: 
![image](https://user-images.githubusercontent.com/5787619/38162212-f1d77080-34e5-11e8-8a9a-f93eca7979af.png)

Thanks to @ReubenBond for this finding and images. ","Don't enforce reentrancy for one way requests  The deadlock prevention mechanism shouldn't affect the one-way requests, as they can not cause the deadlocks. 

This PR fixes the following cases:
- A -> B -> A chain:
![image 1](https://user-images.githu",5086,benjaminpetit,orleans
5080,Orleans.Storage.InconsistentStateException after migrating to Orleans 2.1 (repro sample included),"I have an issue after updating to Orleans 2.1. I am using `MemoryGrainStorage` for my integrational tests, and tests started failing after update (maybe problem not in memory storage, but in new scheduler). I have created small project to reproduce this issue. I think this is trivial flow for grains and shouldn't throw any exceptions.
[Grains.zip](https://github.com/dotnet/orleans/files/2457102/Grains.zip)
","Orleans.Storage.InconsistentStateException after migrating to Orleans 2.1 (repro sample included)  I have an issue after updating to Orleans 2.1. I am using `MemoryGrainStorage` for my integrational tests, and tests started failing after update (maybe pro",5086,benjaminpetit,orleans
5059,Inconsistent State Exception on PubSub grain,"Hello folks,

When we are starting a silo, it get several messages about duplicated activations of a grain, the PubSub grain, which is weird because they happen on a single silo as well. After that, those grains are being deactivated and then I see `InconsistentStateException` from the PubSub grain state storage.  After it appear over and over, looks like the silo give up trying to activate them and then we start to the see messages of `.NET Runtime Platform stalled for XXXX - possibly GC?...` and the mem count is growing until eat the whole machine memory (last time we tried, it was 22Gb when I stopped the process + we had 8gb of logs!). 

Here is a piece of the logs when initializing the silo. It is important to notice that we are using AWS providers but it happens even with in-memory grain storage.

```
[2018-10-02 19:11:11.369] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue5] [INFO] [Orleans.Providers.Streams.SimpleMessageStream.SimpleMessageStreamProvider.InventoryClientStreamProvider] - Initialized SimpleMessageStreamProvider with name InventoryClientStreamProvider and with property FireAndForgetDelivery: True, OptimizeForImmutableData: True and PubSubType: ExplicitGrainBasedAndImplicit
[2018-10-02 19:11:11.514] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [WARN] [Orleans.Persistence.DynamoDB.DynamoDBStorage] - Intermediate error upserting to the table localGutemberg_GrainState
[2018-10-02 19:11:11.517] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [WARN] [Orleans.Persistence.DynamoDB.DynamoDBStorage] - Intermediate error upserting to the table localGutemberg_GrainState
[2018-10-02 19:11:11.520] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [WARN] [Orleans.Persistence.DynamoDB.DynamoDBStorage] - Intermediate error upserting to the table localGutemberg_GrainState
[2018-10-02 19:11:11.689] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [ERROR] [Orleans.Storage.DynamoDBGrainStorage] - Error from storage provider DynamoDBGrainStorage.Orleans.Streams.PubSubRendezvousGrain during WriteState for grain Type=Orleans.Streams.PubSubRendezvousGrain Pk=*grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786 Id=GrainReference:*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected Error=

Exc level 0: Orleans.Storage.InconsistentStateException: Invalid grain state
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateAsync(String grainType, GrainReference grainReference, IGrainState grainState) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 171
   at Orleans.Core.StateStorageBridge`1.WriteStateAsync() in D:\build\agent\_work\17\s\src\Orleans.Runtime\Storage\StateStorageBridge.cs:line 100
Exc level 1: Amazon.DynamoDBv2.Model.ConditionalCheckFailedException: The conditional request failed
   at Amazon.Runtime.Internal.HttpErrorResponseExceptionHandler.HandleException(IExecutionContext executionContext, HttpErrorResponseException exception) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\HttpErrorResponseExceptionHandler.cs:line 60
   at Amazon.Runtime.Internal.ErrorHandler.ProcessException(IExecutionContext executionContext, Exception exception) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\ErrorHandler.cs:line 212
   at Amazon.Runtime.Internal.ErrorHandler.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\ErrorHandler.cs:line 104
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.CredentialsRetriever.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\Handlers\CredentialsRetriever.cs:line 98
   at Amazon.Runtime.Internal.RetryHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.RetryHandler.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\RetryHandler\RetryHandler.cs:line 137
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.ErrorCallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.MetricsHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Orleans.Persistence.DynamoDB.DynamoDBStorage.UpsertEntryAsync(String tableName, Dictionary`2 keys, Dictionary`2 fields, String conditionExpression, Dictionary`2 conditionValues, String extraExpression, Dictionary`2 extraExpressionValues) in D:\build\agent\_work\17\s\src\AWS\Shared\Storage\DynamoDBStorage.cs:line 287
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateInternal(IGrainState grainState, GrainStateRecord record, Boolean clear) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 234
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateAsync(String grainType, GrainReference grainReference, IGrainState grainState) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 167
Exc level 2: Amazon.Runtime.Internal.HttpErrorResponseException: Exception of type 'Amazon.Runtime.Internal.HttpErrorResponseException' was thrown.
   at Amazon.Runtime.HttpWebRequestMessage.GetResponseAsync(CancellationToken cancellationToken) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\HttpHandler\_mobile\HttpRequestMessageFactory.cs:line 443
   at Amazon.Runtime.Internal.HttpHandler`1.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\HttpHandler\HttpHandler.cs:line 175
   at Amazon.Runtime.Internal.Unmarshaller.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.ErrorHandler.InvokeAsync[T](IExecutionContext executionContext)
[2018-10-02 19:11:11.719] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [ERROR] [Orleans.Streams.PubSubRendezvousGrain.S10.1.8.29:11111:276203453.*grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786] - Failed to register a stream producer.  Stream: OnDisconnected-144627d0-3bb3-5d6a-8e9d-3389d225348e-ClientStreamProvider, Producer: GrainReference:*grn/D1BCF3B4/00000000+003ae096-090a-0d02-0018-0218071ef200
[2018-10-02 19:11:11.740] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [INFO] [Orleans.Runtime.Catalog] - DeactivateActivationOnIdle: [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b729e883 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] later when become idle.
[2018-10-02 19:11:11.747] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [INFO] [Orleans.Grain.InvokeException] - Deactivating [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b729e883 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] due to inconsistent state.
[2018-10-02 19:11:11.750] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [INFO] [Orleans.Runtime.Catalog] - DeactivateActivationOnIdle: [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b729e883 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] already being destroyed or invalid.
[2018-10-02 19:11:11.765] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [WARN] [Orleans.Runtime.Scheduler.WorkItemGroup] - Task [Id=5261, Status=RanToCompletion] in WorkGroup [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b729e883 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] took elapsed time 0:00:00.2416379 for execution, which is longer than 00:00:00.2000000. Running on thread System.Threading.Thread
[2018-10-02 19:11:11.779] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [ERROR] [Orleans.Storage.DynamoDBGrainStorage] - Error from storage provider DynamoDBGrainStorage.Orleans.Streams.PubSubRendezvousGrain during WriteState for grain Type=Orleans.Streams.PubSubRendezvousGrain Pk=*grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786 Id=GrainReference:*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected Error=

Exc level 0: Orleans.Storage.InconsistentStateException: Invalid grain state
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateAsync(String grainType, GrainReference grainReference, IGrainState grainState) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 171
   at Orleans.Core.StateStorageBridge`1.WriteStateAsync() in D:\build\agent\_work\17\s\src\Orleans.Runtime\Storage\StateStorageBridge.cs:line 100
Exc level 1: Amazon.DynamoDBv2.Model.ConditionalCheckFailedException: The conditional request failed
   at Amazon.Runtime.Internal.HttpErrorResponseExceptionHandler.HandleException(IExecutionContext executionContext, HttpErrorResponseException exception) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\HttpErrorResponseExceptionHandler.cs:line 60
   at Amazon.Runtime.Internal.ErrorHandler.ProcessException(IExecutionContext executionContext, Exception exception) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\ErrorHandler.cs:line 212
   at Amazon.Runtime.Internal.ErrorHandler.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\ErrorHandler.cs:line 104
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.CredentialsRetriever.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\Handlers\CredentialsRetriever.cs:line 98
   at Amazon.Runtime.Internal.RetryHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.RetryHandler.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\RetryHandler\RetryHandler.cs:line 137
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.ErrorCallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.MetricsHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Orleans.Persistence.DynamoDB.DynamoDBStorage.UpsertEntryAsync(String tableName, Dictionary`2 keys, Dictionary`2 fields, String conditionExpression, Dictionary`2 conditionValues, String extraExpression, Dictionary`2 extraExpressionValues) in D:\build\agent\_work\17\s\src\AWS\Shared\Storage\DynamoDBStorage.cs:line 287
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateInternal(IGrainState grainState, GrainStateRecord record, Boolean clear) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 234
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateAsync(String grainType, GrainReference grainReference, IGrainState grainState) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 167
Exc level 2: Amazon.Runtime.Internal.HttpErrorResponseException: Exception of type 'Amazon.Runtime.Internal.HttpErrorResponseException' was thrown.
   at Amazon.Runtime.HttpWebRequestMessage.GetResponseAsync(CancellationToken cancellationToken) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\HttpHandler\_mobile\HttpRequestMessageFactory.cs:line 443
   at Amazon.Runtime.Internal.HttpHandler`1.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\HttpHandler\HttpHandler.cs:line 175
   at Amazon.Runtime.Internal.Unmarshaller.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.ErrorHandler.InvokeAsync[T](IExecutionContext executionContext)
[2018-10-02 19:11:11.791] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [ERROR] [Orleans.Streams.PubSubRendezvousGrain.S10.1.8.29:11111:276203453.*grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786] - Failed to register a stream producer.  Stream: OnDisconnected-144627d0-3bb3-5d6a-8e9d-3389d225348e-ClientStreamProvider, Producer: GrainReference:*grn/8E291998/00000000+003ae096-090a-0d02-0018-0218071ef200
[2018-10-02 19:11:11.795] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [INFO] [Orleans.Runtime.Catalog] - DeactivateActivationOnIdle: [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b729e883 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] already being destroyed or invalid.
[2018-10-02 19:11:11.801] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [INFO] [Orleans.Grain.InvokeException] - Deactivating [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b729e883 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] due to inconsistent state.
[2018-10-02 19:11:11.805] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [INFO] [Orleans.Runtime.Catalog] - DeactivateActivationOnIdle: [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b729e883 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] already being destroyed or invalid.
[2018-10-02 19:11:11.821] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [ERROR] [Orleans.Storage.DynamoDBGrainStorage] - Error from storage provider DynamoDBGrainStorage.Orleans.Streams.PubSubRendezvousGrain during WriteState for grain Type=Orleans.Streams.PubSubRendezvousGrain Pk=*grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786 Id=GrainReference:*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected Error=

Exc level 0: Orleans.Storage.InconsistentStateException: Invalid grain state
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateAsync(String grainType, GrainReference grainReference, IGrainState grainState) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 171
   at Orleans.Core.StateStorageBridge`1.WriteStateAsync() in D:\build\agent\_work\17\s\src\Orleans.Runtime\Storage\StateStorageBridge.cs:line 100
Exc level 1: Amazon.DynamoDBv2.Model.ConditionalCheckFailedException: The conditional request failed
   at Amazon.Runtime.Internal.HttpErrorResponseExceptionHandler.HandleException(IExecutionContext executionContext, HttpErrorResponseException exception) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\HttpErrorResponseExceptionHandler.cs:line 60
   at Amazon.Runtime.Internal.ErrorHandler.ProcessException(IExecutionContext executionContext, Exception exception) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\ErrorHandler.cs:line 212
   at Amazon.Runtime.Internal.ErrorHandler.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\ErrorHandler.cs:line 104
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.CredentialsRetriever.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\Handlers\CredentialsRetriever.cs:line 98
   at Amazon.Runtime.Internal.RetryHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.RetryHandler.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\RetryHandler\RetryHandler.cs:line 137
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.ErrorCallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.MetricsHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Orleans.Persistence.DynamoDB.DynamoDBStorage.UpsertEntryAsync(String tableName, Dictionary`2 keys, Dictionary`2 fields, String conditionExpression, Dictionary`2 conditionValues, String extraExpression, Dictionary`2 extraExpressionValues) in D:\build\agent\_work\17\s\src\AWS\Shared\Storage\DynamoDBStorage.cs:line 287
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateInternal(IGrainState grainState, GrainStateRecord record, Boolean clear) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 234
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateAsync(String grainType, GrainReference grainReference, IGrainState grainState) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 167
Exc level 2: Amazon.Runtime.Internal.HttpErrorResponseException: Exception of type 'Amazon.Runtime.Internal.HttpErrorResponseException' was thrown.
   at Amazon.Runtime.HttpWebRequestMessage.GetResponseAsync(CancellationToken cancellationToken) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\HttpHandler\_mobile\HttpRequestMessageFactory.cs:line 443
   at Amazon.Runtime.Internal.HttpHandler`1.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\HttpHandler\HttpHandler.cs:line 175
   at Amazon.Runtime.Internal.Unmarshaller.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.ErrorHandler.InvokeAsync[T](IExecutionContext executionContext)
[2018-10-02 19:11:11.843] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [ERROR] [Orleans.Streams.PubSubRendezvousGrain.S10.1.8.29:11111:276203453.*grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786] - Failed to register a stream producer.  Stream: OnDisconnected-144627d0-3bb3-5d6a-8e9d-3389d225348e-ClientStreamProvider, Producer: GrainReference:*grn/9C2A0175/00000000+003ae096-090a-0d02-0018-0218071ef200
[2018-10-02 19:11:11.845] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [INFO] [Orleans.Runtime.Catalog] - DeactivateActivationOnIdle: [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b729e883 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] already being destroyed or invalid.
[2018-10-02 19:11:11.849] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [INFO] [Orleans.Grain.InvokeException] - Deactivating [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b729e883 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] due to inconsistent state.
[2018-10-02 19:11:11.854] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [INFO] [Orleans.Runtime.Catalog] - DeactivateActivationOnIdle: [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b729e883 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] already being destroyed or invalid.
[2018-10-02 19:11:11.879] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [INFO] [Orleans.Runtime.Catalog] - Starting DestroyActivations #0 of 1 activations
[2018-10-02 19:11:12.015] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue1] [INFO] [Orleans.Runtime.Dispatcher] - Forwarding 4 requests destined for address S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b729e883 to address  after Finished Destroy Activation.
[2018-10-02 19:11:12.017] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue0] [INFO] [Orleans.Runtime.Dispatcher] - Trying to forward after Finished Destroy Activation, ForwardCount = 0. Message Request S10.1.8.29:11111:276203453*grn/D1BCF3B4/00000000+003ae096-090a-0d02-0018-0218071ef200@be7db6a5->S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b729e883 #791: .
[2018-10-02 19:11:12.018] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue1] [INFO] [Orleans.Runtime.Catalog] - Done FinishDestroyActivations #0 - Destroyed 1 Activations.
[2018-10-02 19:11:12.019] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue0] [INFO] [Orleans.Runtime.Dispatcher] - Trying to forward after Finished Destroy Activation, ForwardCount = 0. Message Request S10.1.8.29:11111:276203453*grn/8E291998/00000000+003ae096-090a-0d02-0018-0218071ef200@01c7bab5->S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b729e883 #881: .
[2018-10-02 19:11:12.021] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue0] [INFO] [Orleans.Runtime.Dispatcher] - Trying to forward after Finished Destroy Activation, ForwardCount = 0. Message Request S10.1.8.29:11111:276203453*grn/9C2A0175/00000000+003ae096-090a-0d02-0018-0218071ef200@7d817981->S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b729e883 #990: .
[2018-10-02 19:11:12.053] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue0] [INFO] [Orleans.Runtime.Dispatcher] - Trying to forward after Finished Destroy Activation, ForwardCount = 0. Message Request S10.1.8.29:11111:276203453*grn/38B8C332/00000000+003ae096-090a-0d02-0018-0218071ef200@10e43fbd->S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b729e883 #1165: .
[2018-10-02 19:11:12.057] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue0] [INFO] [Orleans.Runtime.Catalog] - Tried to create a duplicate activation S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@dc4fe4ab, but we'll use S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@f26d2584 instead. GrainInstanceType is Orleans.Streams.PubSubRendezvousGrain. Primary Directory partition for this grain is S10.1.8.29:11111:276203453. Full activation address is [ActivationAddress: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@dc4fe4ab, Full GrainId: [GrainId: *grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786, IdCategory: KeyExtGrain, BaseTypeCode: 1903070868 (x716E8E94), PrimaryKey: 144627d0-3bb3-5d6a-8e9d-3389d225348e (x{0x144627d0,0x3bb3,0x5d6a,{0x8e,0x9d,0x33,0x89,0xd2,0x25,0x34,0x8e}}), UniformHashCode: 4270266246 (0xFE871786), KeyExtension: ClientStreamProvider_OnDisconnected], Full ActivationId: @4b53de7f534a8c5a81d406d0dc4fe4ab0000000000000000]. We have 1 messages to forward.
[2018-10-02 19:11:12.058] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue1] [INFO] [Orleans.Runtime.Catalog] - Tried to create a duplicate activation S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@94a65c96, but we'll use S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@f26d2584 instead. GrainInstanceType is Orleans.Streams.PubSubRendezvousGrain. Primary Directory partition for this grain is S10.1.8.29:11111:276203453. Full activation address is [ActivationAddress: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@94a65c96, Full GrainId: [GrainId: *grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786, IdCategory: KeyExtGrain, BaseTypeCode: 1903070868 (x716E8E94), PrimaryKey: 144627d0-3bb3-5d6a-8e9d-3389d225348e (x{0x144627d0,0x3bb3,0x5d6a,{0x8e,0x9d,0x33,0x89,0xd2,0x25,0x34,0x8e}}), UniformHashCode: 4270266246 (0xFE871786), KeyExtension: ClientStreamProvider_OnDisconnected], Full ActivationId: @4d0a14e4c0c856e7ffafb6e394a65c960000000000000000]. We have 1 messages to forward.
[2018-10-02 19:11:12.062] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue0] [INFO] [Orleans.Runtime.Dispatcher] - Forwarding 1 requests destined for address S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@dc4fe4ab to address S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@f26d2584 after Duplicate activation.
[2018-10-02 19:11:12.069] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue1] [INFO] [Orleans.Runtime.Dispatcher] - Forwarding 1 requests destined for address S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@94a65c96 to address S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@f26d2584 after Duplicate activation.
[2018-10-02 19:11:12.070] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue0] [INFO] [Orleans.Runtime.Dispatcher] - Trying to forward after Duplicate activation, ForwardCount = 1. Message NewPlacement Request S10.1.8.29:11111:276203453*grn/9C2A0175/00000000+003ae096-090a-0d02-0018-0218071ef200@7d817981->S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@dc4fe4ab #990[ForwardCount=1]: .
[2018-10-02 19:11:12.071] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue1] [INFO] [Orleans.Runtime.Catalog] - Tried to create a duplicate activation S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@5239098f, but we'll use S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@f26d2584 instead. GrainInstanceType is Orleans.Streams.PubSubRendezvousGrain. Primary Directory partition for this grain is S10.1.8.29:11111:276203453. Full activation address is [ActivationAddress: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@5239098f, Full GrainId: [GrainId: *grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786, IdCategory: KeyExtGrain, BaseTypeCode: 1903070868 (x716E8E94), PrimaryKey: 144627d0-3bb3-5d6a-8e9d-3389d225348e (x{0x144627d0,0x3bb3,0x5d6a,{0x8e,0x9d,0x33,0x89,0xd2,0x25,0x34,0x8e}}), UniformHashCode: 4270266246 (0xFE871786), KeyExtension: ClientStreamProvider_OnDisconnected], Full ActivationId: @4b49cc711d3404dd7ebe73525239098f0000000000000000]. We have 1 messages to forward.
[2018-10-02 19:11:12.072] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue0] [INFO] [Orleans.Runtime.Dispatcher] - Trying to forward after Duplicate activation, ForwardCount = 1. Message NewPlacement Request S10.1.8.29:11111:276203453*grn/38B8C332/00000000+003ae096-090a-0d02-0018-0218071ef200@10e43fbd->S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@94a65c96 #1165[ForwardCount=1]: .
[2018-10-02 19:11:12.078] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue1] [INFO] [Orleans.Runtime.Dispatcher] - Forwarding 1 requests destined for address S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@5239098f to address S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@f26d2584 after Duplicate activation.
[2018-10-02 19:11:12.081] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue0] [INFO] [Orleans.Runtime.Dispatcher] - Trying to forward after Duplicate activation, ForwardCount = 1. Message NewPlacement Request S10.1.8.29:11111:276203453*grn/8E291998/00000000+003ae096-090a-0d02-0018-0218071ef200@01c7bab5->S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@5239098f #881[ForwardCount=1]: .
[2018-10-02 19:11:12.180] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [WARN] [Orleans.Persistence.DynamoDB.DynamoDBStorage] - Intermediate error upserting to the table localGutemberg_GrainState
[2018-10-02 19:11:12.191] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [WARN] [Orleans.Persistence.DynamoDB.DynamoDBStorage] - Intermediate error upserting to the table localGutemberg_GrainState
[2018-10-02 19:11:12.215] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [ERROR] [Orleans.Storage.DynamoDBGrainStorage] - Error from storage provider DynamoDBGrainStorage.Orleans.Streams.PubSubRendezvousGrain during WriteState for grain Type=Orleans.Streams.PubSubRendezvousGrain Pk=*grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786 Id=GrainReference:*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected Error=

Exc level 0: Orleans.Storage.InconsistentStateException: Invalid grain state
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateAsync(String grainType, GrainReference grainReference, IGrainState grainState) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 171
   at Orleans.Core.StateStorageBridge`1.WriteStateAsync() in D:\build\agent\_work\17\s\src\Orleans.Runtime\Storage\StateStorageBridge.cs:line 100
Exc level 1: Amazon.DynamoDBv2.Model.ConditionalCheckFailedException: The conditional request failed
   at Amazon.Runtime.Internal.HttpErrorResponseExceptionHandler.HandleException(IExecutionContext executionContext, HttpErrorResponseException exception) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\HttpErrorResponseExceptionHandler.cs:line 60
   at Amazon.Runtime.Internal.ErrorHandler.ProcessException(IExecutionContext executionContext, Exception exception) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\ErrorHandler.cs:line 212
   at Amazon.Runtime.Internal.ErrorHandler.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\ErrorHandler.cs:line 104
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.CredentialsRetriever.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\Handlers\CredentialsRetriever.cs:line 98
   at Amazon.Runtime.Internal.RetryHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.RetryHandler.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Co","Inconsistent State Exception on PubSub grain  Hello folks,

When we are starting a silo, it get several messages about duplicated activations of a grain, the PubSub grain, which is weird because they happen on a single silo as well. After that, those gr",5086,benjaminpetit,orleans
5073,[WIP] Support Service Fabric Stateful Service hosting,"Fixes #1059. I consider this satisfying enough of #1059 that we can close that issue and add any extra ""good to have"" features in separate PRs with individual issues if required.

This PR will be split up into multiple parts:

1. Enabling packaging of `Microsoft.Orleans.Clustering.ServiceFabric` package, which was not included in 2.0. `IMembershipOracle` ..
2. `StatefulServicePlacement` - so that activations are placed deterministically by mapping from grain id to SF partition id (SF partition ids / counts are fixed at deployment time and the service must be deleted and redeployed to 'change' the partition count/scheme).
3. Changes to support placement directors which do not use the grain directory. In short, adds an `IsUsingGrainDirectory` prop to `PlacementStrategy` and removes the existing special-casing around `StatelessWorkerPlacement` being the only placement strategy which can bypass the directory. (PR #5074)
4. Changes to support activations which have a deterministic `ActivationId` (related to the above) so that a grain which is placed using `StatefulServicePlacement` has a fixed `ActivationId` which can be computed from its `GrainId` (i.e, 1:1 relationship). It's possible that this will be contentious, since previously an `ActivationId` was ephemeral. This change is important, though, because it lets us route calls without needing to learn the `ActivationId` from another source (the grain directory). This is implemented by adding an `IsDeterministicActivationId` property to `PlacementStrategy`, which is then used in `PlacementDirectorsManager.AddActivation`. (PR #5082)
5. A storage provider backed by Service Fabric Reliable Collections.
6. Hosting utilities for wiring everything together, to make hosting Orleans on SF as simple as possible.","[WIP] Support Service Fabric Stateful Service hosting  Fixes #1059. I consider this satisfying enough of #1059 that we can close that issue and add any extra ""good to have"" features in separate PRs with individual issues if required.

This PR will be sp",5082,ReubenBond,orleans
5082,Allow placement strategies to specify deterministic activation ids,"When grains are placed using the (upcoming) Service Fabric Stateful Service strategy, there is no grain directory involvement and hence we need a mechanism to determine which activation id to use when routing messages.

This PR enables that functionality but keeps it *`internal`* so that it will only be exposed to the SF library for now. The reasoning here is that it's unlikely anyone else will need it and if someone stumbles upon this they may opt-in to it for their placement strategy without understanding the consequences.

If `PlacementStrategy.IsDeterministicActivationId` is `true`, then all activations for a particular grain will have an `ActivationId` whose `Key` is equal to the grain's `GrainId.Key`. If `false`, then no behavior changes and `ActivationId` is randomly generated.

Without this PR, initial calls to already-activated grains placed using `StatefulServicePlacement` will round-trip to the target silo using the incorrect generated `ActivationId` and the silo will need to forward those calls to the correct activation. The response message will invalidate the caller's routing cache, but will not specify the activation's new address, so the caller will continue to call using incorrect `ActivationId`s. This is *benign* but unpleasant and inefficient. Users would almost certainly complain about warnings and other garbage in their logs. It is also slower. This PR enables the first and subsequent call to succeed without any round-trips for routing info.

See #5073 under part 4:
> Changes to support activations which have a deterministic `ActivationId` (related to the above) so that a grain which is placed using `StatefulServicePlacement` has a fixed `ActivationId` which can be computed from its `GrainId` (i.e, 1:1 relationship). It's possible that this will be contentious, since previously an `ActivationId` was ephemeral. This change is important, though, because it lets us route calls without needing to learn the `ActivationId` from another source (the grain directory). This is implemented by adding an `IsDeterministicActivationId` property to `PlacementStrategy`, which is then used in `PlacementDirectorsManager.AddActivation`. (PR #5082)","Allow placement strategies to specify deterministic activation ids  When grains are placed using the (upcoming) Service Fabric Stateful Service strategy, there is no grain directory involvement and hence we need a mechanism to determine which activation i",5082,ReubenBond,orleans
4923,Transction recovery bug fixes.,"","Transction recovery bug fixes.  ",4961,xiazen,orleans
3843,Fix programatic subscribe bugs,"Fix bugs 
- #3817 
- use `StreamSubscriptionManager.RemoveSubscription` with custom `IStreamIdentity` implementation throws casting exception
  
  ","Fix programatic subscribe bugs  Fix bugs 
- #3817 
- use `StreamSubscriptionManager.RemoveSubscription` with custom `IStreamIdentity` implementation throws casting exception
  
  ",4943,sergeybykov,orleans
3851,Add StreamSubscriptionHandleFactory to subscribe onbehalf feature,"subscribe on behalf feature has a bug in it which makes it unusable. The cause of the bug is, in streaming infra, stream type is not parsed correctly to `IStreamSubscriptionObserver.OnSubscribe`. This PR introduces `IStreamSubscriptionHandleFactory` which requires user to give that type information, as a way to fix that bug. 

There were other solutions discussed for this bug , but they all require more engineer hours. Based on the team's current capacity, this seems to be the best way ATM to fix it.","Add StreamSubscriptionHandleFactory to subscribe onbehalf feature  subscribe on behalf feature has a bug in it which makes it unusable. The cause of the bug is, in streaming infra, stream type is not parsed correctly to `IStreamSubscriptionObserver.OnSubs",4943,sergeybykov,orleans
4956,"Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0","Orleans version: 2.1.0-beta1

SDK: .NET Core 2.1.401

Tragetframework: netstandard2.0

Detail:  Works find,if I switch targetframework to netcoreapp2.1.

ErrorMessage:
 Orleans-CodeGen - Generating file C:\Users\Jz.Fan\Source\Repos\Ray\Ray.Core\obj\Debug\netstandard2.0\Ray.Core.orleans.g.cs
  warn: Orleans.CodeGenerator.RoslynCodeGenerator[101723]
        Exception loading types from assembly 'Ray.Core, Version=1.1.5.0, Culture=neutral, PublicKeyToken=null':
        Exc level 0: System.Reflection.ReflectionTypeLoadException: Unable to load one or more of the requested types. Retrieve the LoaderExceptions property for more information.
           at System.Reflection.RuntimeModule.GetTypes(RuntimeModule module)
           at System.Reflection.RuntimeAssembly.get_DefinedTypes()
           at Orleans.Runtime.TypeUtils.GetDefinedTypes(Assembly assembly, ILogger logger) in D:\build\agent\_work\25\s\src\Orleans.Core\CodeGeneration\TypeUtils.cs:line 561
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。.
  System.Reflection.ReflectionTypeLoadException: Unable to load one or more of the requested types. Retrieve the LoaderExceptions property for more information.
     at System.Reflection.RuntimeModule.GetTypes(RuntimeModule module)
     at System.Reflection.RuntimeAssembly.get_DefinedTypes()
     at Orleans.Runtime.TypeUtils.GetDefinedTypes(Assembly assembly, ILogger logger) in D:\build\agent\_work\25\s\src\Orleans.Core\CodeGeneration\TypeUtils.cs:line 561
  warn: Orleans.CodeGenerator.RoslynCodeGenerator[101723]
        Exception loading types from assembly 'Ray.Core, Version=1.1.5.0, Culture=neutral, PublicKeyToken=null':
        Exc level 0: System.Reflection.ReflectionTypeLoadException: Unable to load one or more of the requested types. Retrieve the LoaderExceptions property for more information.
           at System.Reflection.RuntimeModule.GetTypes(RuntimeModule module)
           at System.Reflection.RuntimeAssembly.get_DefinedTypes()
           at Orleans.Runtime.TypeUtils.GetDefinedTypes(Assembly assembly, ILogger logger) in D:\build\agent\_work\25\s\src\Orleans.Core\CodeGeneration\TypeUtils.cs:line 561
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。.
  System.Reflection.ReflectionTypeLoadException: Unable to load one or more of the requested types. Retrieve the LoaderExceptions property for more information.
     at System.Reflection.RuntimeModule.GetTypes(RuntimeModule module)
     at System.Reflection.RuntimeAssembly.get_DefinedTypes()
     at Orleans.Runtime.TypeUtils.GetDefinedTypes(Assembly assembly, ILogger logger) in D:\build\agent\_work\25\s\src\Orleans.Core\CodeGeneration\TypeUtils.cs:line 561
  Orleans-CodeGen - Generated file written C:\Users\Jz.Fan\Source\Repos\Ray\Ray.Core\obj\Debug\netstandard2.0\Ray.Core.orleans.g.cs","Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0  Orleans version: 2.1.0-beta1

SDK: .NET Core 2.1.401

Tragetframework: netstandard2.0

Detail:  Works find,if I switch targetframework to netcoreapp2.1.

ErrorMes",4934,ReubenBond,orleans
3880,Build Time Code Generation on MacOS Failing 2.0.0-beta3,"When attempting to build a 2.0.0 project on MacOS Sierra we get the attached Msbuild error: https://i.imgur.com/ikpdTq1.png

The text if the image won't load is as follows:

The ""Orleans.CodeGeneration.GetDotNetHost"" task could not be loaded for the assembly '.../Orleans.CodeGeneration.Build.dll'. Could not resolve type with token 0100001e (from typeref, class/assembly System.MarshalByRefObject, System.Runtime, Version=4.2.0.0, Culture=neutral....

It looks like that goes on to cause a ReflectionTypeLoadException in MSBuild.
","Build Time Code Generation on MacOS Failing 2.0.0-beta3  When attempting to build a 2.0.0 project on MacOS Sierra we get the attached Msbuild error: https://i.imgur.com/ikpdTq1.png

The text if the image won't load is as follows:

The ""Orleans.CodeGen",4934,ReubenBond,orleans
4915,Error Updating Orleans project to Roslyn 2.9.0,"Using .net core 2.1,

**Note 1**: Not sure if this is a Roslyn issue or an Orleans issue
**Note 2**: Version 2.8.2 of both packages below works just fine

Upgraded Roslyn, used by one of my grains to the following:
1.  Microsoft.CodeAnalysis.Scripting 2.9.0
2. Microsoft.CodeAnalysis.CSharp.Scripting 2.9.0

Get this error: **""@obj\Debug\netstandard2.0\codegen\IvcOrleansGrains.orleans.g.args.txt"""" exited with code 3.**

The assemblies changed in the nuget update process:
Successfully uninstalled 'Microsoft.CodeAnalysis.Analyzers 1.1.0' from IvcOrleansGrains
Successfully uninstalled 'Microsoft.CodeAnalysis.Common 2.8.2' from IvcOrleansGrains
Successfully uninstalled 'Microsoft.CodeAnalysis.CSharp 2.8.2' from IvcOrleansGrains
Successfully uninstalled 'Microsoft.CodeAnalysis.CSharp.Scripting 2.8.2' from IvcOrleansGrains
Successfully uninstalled 'Microsoft.CodeAnalysis.Scripting 2.8.2' from IvcOrleansGrains
Successfully uninstalled 'Microsoft.CodeAnalysis.Scripting.Common 2.8.2' from IvcOrleansGrains
Successfully uninstalled 'System.Collections.Immutable 1.3.1' from IvcOrleansGrains
Successfully uninstalled 'System.Reflection.Metadata 1.4.2' from IvcOrleansGrains

Successfully installed 'Microsoft.CodeAnalysis.Analyzers 2.6.1' to IvcOrleansGrains
Successfully installed 'Microsoft.CodeAnalysis.Common 2.9.0' to IvcOrleansGrains
Successfully installed 'Microsoft.CodeAnalysis.CSharp 2.9.0' to IvcOrleansGrains
Successfully installed 'Microsoft.CodeAnalysis.CSharp.Scripting 2.9.0' to IvcOrleansGrains
Successfully installed 'Microsoft.CodeAnalysis.Scripting 2.9.0' to IvcOrleansGrains
Successfully installed 'Microsoft.CodeAnalysis.Scripting.Common 2.9.0' to IvcOrleansGrains
Successfully installed 'System.Collections.Immutable 1.5.0' to IvcOrleansGrains
Successfully installed 'System.Reflection.Metadata 1.6.0' to IvcOrleansGrains
","Error Updating Orleans project to Roslyn 2.9.0  Using .net core 2.1,

**Note 1**: Not sure if this is a Roslyn issue or an Orleans issue
**Note 2**: Version 2.8.2 of both packages below works just fine

Upgraded Roslyn, used by one of my grains to th",4934,ReubenBond,orleans
4812,Build time codegen quite unstable on Orleans 2.x,"Hello folks, 

I saw some issues pointing out multiple issues with build time codegen after Orleans 2.x was released.

In fact, I've suffering since 2.0 release with multiple different issues with it. Some PR were made attempting to fix but which just failed.

I'm opening this issue in an attempt to bring team's attention to this matter as it is turning build time codegen practically unusable the way it is now.

As discussed with @ReubenBond, it looks like the new codegen he is working is going to fix if not all, the majority of those current issues but the work is on hold due to other team's priorities. 

It is a major block on multiple projects I'm working with so I would appreciate if Reuben have a bit more of time to dedicate to it. 

Thank you all!","Build time codegen quite unstable on Orleans 2.x  Hello folks, 

I saw some issues pointing out multiple issues with build time codegen after Orleans 2.x was released.

In fact, I've suffering since 2.0 release with multiple different issues with it.",4934,ReubenBond,orleans
4500,[2.0] Build-time Code Generation fails when referencing a project that contains service references.,"As above. With a library targeting .NET Standard 2.0, a grain interface project references a project that contains a service reference, leading to the following build-time error:

```
13>Orleans-CodeGen - Generating file C:\<company>\<project>.ExecutionGrains.Interfaces\obj\Debug\netstandard2.0\<project>.ExecutionGrains.Interfaces.orleans.g.cs
13>warn: Orleans.CodeGenerator.RoslynCodeGenerator[101723]
13>      Exception loading types from assembly '<project>.Models, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null':
13>      Exc level 0: System.Reflection.ReflectionTypeLoadException: Unable to load one or more of the requested types. Retrieve the LoaderExceptions property for more information.
13>         at System.Reflection.RuntimeModule.GetTypes(RuntimeModule module)
13>         at System.Reflection.RuntimeAssembly.get_DefinedTypes()
13>         at Orleans.Runtime.TypeUtils.GetDefinedTypes(Assembly assembly, ILogger logger) in D:\build\agent2\_work\8\s\src\Orleans.Core\CodeGeneration\TypeUtils.cs:line 561
13>      Exc level 1: System.BadImageFormatException: Could not load file or assembly 'System.ServiceModel.Primitives, Version=4.5.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. Reference assemblies should not be loaded for execution.  They can only be loaded in the Reflection-only loader context. (Exception from HRESULT: 0x80131058)
13>      Exc level 2: System.BadImageFormatException: Cannot load a reference assembly for execution.
13>      Exc level 1: System.BadImageFormatException: Could not load file or assembly 'System.ServiceModel.Primitives, Version=4.5.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. Reference assemblies should not be loaded for execution.  They can only be loaded in the Reflection-only loader context. (Exception from HRESULT: 0x80131058)
13>      Exc level 2: System.BadImageFormatException: Cannot load a reference assembly for execution.
13>      Exc level 1: System.BadImageFormatException: Could not load file or assembly 'System.ServiceModel.Primitives, Version=4.5.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. Reference assemblies should not be loaded for execution.  They can only be loaded in the Reflection-only loader context. (Exception from HRESULT: 0x80131058)
13>      Exc level 2: System.BadImageFormatException: Cannot load a reference assembly for execution.
13>      Exc level 1: System.BadImageFormatException: Could not load file or assembly 'System.ServiceModel.Primitives, Version=4.5.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. Reference assemblies should not be loaded for execution.  They can only be loaded in the Reflection-only loader context. (Exception from HRESULT: 0x80131058)
13>      Exc level 2: System.BadImageFormatException: Cannot load a reference assembly for execution.
13>      Exc level 1: System.BadImageFormatException: Could not load file or assembly 'System.ServiceModel.Primitives, Version=4.5.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. Reference assemblies should not be loaded for execution.  They can only be loaded in the Reflection-only loader context. (Exception from HRESULT: 0x80131058)
13>      Exc level 2: System.BadImageFormatException: Cannot load a reference assembly for execution.
13>      Exc level 1: System.BadImageFormatException: Could not load file or assembly 'System.ServiceModel.Primitives, Version=4.5.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. Reference assemblies should not be loaded for execution.  They can only be loaded in the Reflection-only loader context. (Exception from HRESULT: 0x80131058)
13>      Exc level 2: System.BadImageFormatException: Cannot load a reference assembly for execution.
13>      Exc level 1: System.BadImageFormatException: Could not load file or assembly 'System.ServiceModel.Primitives, Version=4.5.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. Reference assemblies should not be loaded for execution.  They can only be loaded in the Reflection-only loader context. (Exception from HRESULT: 0x80131058)
13>      Exc level 2: System.BadImageFormatException: Cannot load a reference assembly for execution.
13>      Exc level 1: System.BadImageFormatException: Could not load file or assembly 'System.ServiceModel.Primitives, Version=4.5.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. Reference assemblies should not be loaded for execution.  They can only be loaded in the Reflection-only loader context. (Exception from HRESULT: 0x80131058)
13>      Exc level 2: System.BadImageFormatException: Cannot load a reference assembly for execution..
13>System.Reflection.ReflectionTypeLoadException: Unable to load one or more of the requested types. Retrieve the LoaderExceptions property for more information.
13>   at System.Reflection.RuntimeModule.GetTypes(RuntimeModule module)
13>   at System.Reflection.RuntimeAssembly.get_DefinedTypes()
13>   at Orleans.Runtime.TypeUtils.GetDefinedTypes(Assembly assembly, ILogger logger) in D:\build\agent2\_work\8\s\src\Orleans.Core\CodeGeneration\TypeUtils.cs:line 561
13>-- Code Generation FAILED --
13>
13>Exc level 0: System.ArgumentException: A BadImageFormatException has been thrown while parsing the signature. This is likely due to lack of a generic context. Ensure genericTypeArguments and genericMethodArguments are provided and contain enough context.
13>   at System.Reflection.RuntimeModule.ResolveType(Int32 metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
13>   at System.Reflection.CustomAttribute.FilterCustomAttributeRecord(CustomAttributeRecord caRecord, MetadataImport scope, Assembly& lastAptcaOkAssembly, RuntimeModule decoratedModule, MetadataToken decoratedToken, RuntimeType attributeFilterType, Boolean mustBeInheritable, Object[] attributes, IList derivedAttributes, RuntimeType& attributeType, IRuntimeMethodInfo& ctor, Boolean& ctorHasParameters, Boolean& isVarArg)
13>   at System.Reflection.CustomAttribute.GetCustomAttributes(RuntimeModule decoratedModule, Int32 decoratedMetadataToken, Int32 pcaCount, RuntimeType attributeFilterType, Boolean mustBeInheritable, IList derivedAttributes, Boolean isDecoratedTargetSecurityTransparent)
13>   at System.Reflection.CustomAttribute.GetCustomAttributes(RuntimeType type, RuntimeType caType, Boolean inherit)
13>   at System.Attribute.GetCustomAttributes(MemberInfo element, Type type, Boolean inherit)
13>   at System.Attribute.GetCustomAttribute(MemberInfo element, Type attributeType, Boolean inherit)
13>   at System.Reflection.CustomAttributeExtensions.GetCustomAttribute[T](MemberInfo element)
13>   at Orleans.CodeGenerator.RoslynCodeGenerator.AddSerializationTypes(SerializationTypeDescriptions serializationTypes, Assembly targetAssembly, List`1 assemblies) in D:\build\agent2\_work\8\s\src\Orleans.CodeGeneration\RoslynCodeGenerator.cs:line 434
13>   at Orleans.CodeGenerator.RoslynCodeGenerator.GenerateCode(Assembly targetAssembly, List`1 assemblies) in D:\build\agent2\_work\8\s\src\Orleans.CodeGeneration\RoslynCodeGenerator.cs:line 327
13>   at Orleans.CodeGenerator.RoslynCodeGenerator.GenerateSourceForAssembly(Assembly input) in D:\build\agent2\_work\8\s\src\Orleans.CodeGeneration\RoslynCodeGenerator.cs:line 162
13>   at Orleans.CodeGeneration.CodeGenerator.GenerateSourceForAssembly(Assembly grainAssembly, LogLevel logLevel)
13>   at Orleans.CodeGeneration.CodeGenerator.GenerateCodeInternal(CodeGenOptions options)
13>   at Orleans.CodeGeneration.CodeGenerator.GenerateCode(CodeGenOptions options)
13>   at Orleans.CodeGeneration.Program.Main(String[] args)
13>Exc level 1: System.BadImageFormatException: Could not load file or assembly 'System.ServiceModel.Primitives, Version=4.5.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. Reference assemblies should not be loaded for execution.  They can only be loaded in the Reflection-only loader context. (Exception from HRESULT: 0x80131058)
13>   at System.ModuleHandle.ResolveType(RuntimeModule module, Int32 typeToken, IntPtr* typeInstArgs, Int32 typeInstCount, IntPtr* methodInstArgs, Int32 methodInstCount, ObjectHandleOnStack type)
13>   at System.ModuleHandle.ResolveTypeHandleInternal(RuntimeModule module, Int32 typeToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext)
13>   at System.Reflection.RuntimeModule.ResolveType(Int32 metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
13>Exc level 2: System.BadImageFormatException: Cannot load a reference assembly for execution.
13>C:\Users\user\.nuget\packages\microsoft.orleans.orleanscodegenerator.build\2.0.0\build\Microsoft.Orleans.OrleansCodeGenerator.Build.targets(76,5): error MSB3073: The command """"dotnet"" ""C:\Users\user\.nuget\packages\microsoft.orleans.orleanscodegenerator.build\2.0.0\build\..\tasks\netcoreapp2.0\Orleans.CodeGeneration.Build.dll"" ""@obj\Debug\netstandard2.0\codegen\<project>.ExecutionGrains.Interfaces.orleans.g.args.txt"""" exited with code 3.
13>Done building project ""<project>.ExecutionGrains.Interfaces.csproj"" -- FAILED.
```","[2.0] Build-time Code Generation fails when referencing a project that contains service references.  As above. With a library targeting .NET Standard 2.0, a grain interface project references a project that contains a service reference, leading to the fol",4934,ReubenBond,orleans
4295,Build-time generation issue in Microsoft.Orleans.OrleansCodeGenerator.Build,"Hi guys,

Found the following issue in the latest 2.0.0-rc-2 version.

**Download for the the reproduction:**
[OrleansIssue.Libs.zip](https://github.com/dotnet/orleans/files/1841533/OrleansIssue.Libs.zip)

One of my grain uses RabbitMq to receive messages.
The moment I reference the NuGet pacakge RabbitMQ.Client v5.0.1 (.NET 4.5.1) and used a type from the package in a grain the this error comes up:

`..OrleansIssue.Libs\packages\Microsoft.Orleans.OrleansCodeGenerator.Build.2.0.0-rc2\build\..\tasks\net461\Orleans.CodeGeneration.Build.exe"" ""@obj\Debug\codegen\OrleansIssue.Libs.orleans.g.args.txt"""" exited with code 3.`

And the build output:

```
1>  Orleans-CodeGen - Generating file <path>source\repos\OrleansIssue.Libs\obj\Debug\OrleansIssue.Libs.orleans.g.cs
1>  warn: Orleans.CodeGenerator.RoslynCodeGenerator[101723]
1>        Exception loading types from assembly 'RabbitMQ.Client, Version=5.0.0.0, Culture=neutral, PublicKeyToken=89e7d7c5feba84ce': 
1>        Exc level 0: System.Reflection.ReflectionTypeLoadException: Unable to load one or more of the requested types. Retrieve the LoaderExceptions property for more information.
1>           at System.Reflection.RuntimeModule.GetTypes(RuntimeModule module)
1>           at System.Reflection.RuntimeAssembly.get_DefinedTypes()
1>           at Orleans.Runtime.TypeUtils.GetDefinedTypes(Assembly assembly, ILogger logger) in D:\build\agent\_work\9\s\src\Orleans.Core\CodeGeneration\TypeUtils.cs:line 561
1>        Exc level 1: System.IO.FileLoadException: Could not load file or assembly 'Microsoft.Diagnostics.Tracing.EventSource, Version=1.1.28.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' or one of its dependencies. The located assembly's manifest definition does not match the assembly reference. (Exception from HRESULT: 0x80131040)
1>        Exc level 2: System.IO.FileLoadException: The located assembly's manifest definition does not match the assembly reference. (Exception from HRESULT: 0x80131040)
1>        Exc level 1: System.IO.FileLoadException: The located assembly's manifest definition does not match the assembly reference. (Exception from HRESULT: 0x80131040).
1>  System.Reflection.ReflectionTypeLoadException: Unable to load one or more of the requested types. Retrieve the LoaderExceptions property for more information.
1>     at System.Reflection.RuntimeModule.GetTypes(RuntimeModule module)
1>     at System.Reflection.RuntimeAssembly.get_DefinedTypes()
1>     at Orleans.Runtime.TypeUtils.GetDefinedTypes(Assembly assembly, ILogger logger) in D:\build\agent\_work\9\s\src\Orleans.Core\CodeGeneration\TypeUtils.cs:line 561
1>  -- Code Generation FAILED -- 
1>  
```

After some digging I found a relation with `Microsoft.Diagnostics.Tracing.EventSource.Redist`. As soon as this package is **downgraded** from 2.0.0-> 1.1.28 the issue is resolved.

Please note that there is no compilation error in the code,  its only the grain code generation at build-time.

Code:

```
 public class MyGrain : Grain, IMyGrain
    {
        // RabbitMq type from RabbitMQ.Client
        private ConnectionFactory _factory;

        public Task DoWork()
        {
            throw new NotImplementedException();
        }
    }
```

Involved packages:

Used RabbitMq package:
`<package id=""RabbitMQ.Client"" version=""5.0.1"" targetFramework=""net471"" />`

Package that throws the error:
`package id=""Microsoft.Orleans.OrleansCodeGenerator.Build"" version=""2.0.0-rc2"" targetFramework=""net471""`

Can someone find out what goes wrong here?","Build-time generation issue in Microsoft.Orleans.OrleansCodeGenerator.Build  Hi guys,

Found the following issue in the latest 2.0.0-rc-2 version.

**Download for the the reproduction:**
[OrleansIssue.Libs.zip](https://github.com/dotnet/orleans/files",4934,ReubenBond,orleans
2896,Project fails to build after adding OrleansCodeGenerator.Build package if platform is x86,"**Build error is:**
The command """"c:\Projects\orleanstest\packages\Microsoft.Orleans.OrleansCodeGenerator.Build.1.4.0\build\..\tools\ClientGenerator.exe"" ""@obj\Release\orleanstest.codegen.args.txt"""" exited with code 3.

**Build output is:**
```
1>------ Rebuild All started: Project: orleanstest, Configuration: Release Any CPU ------
1>  [OrleansCodeGeneration] - Project=orleanstest
1>  orleanstest -> c:\Projects\orleanstest\orleanstest\bin\Release\orleanstest.exe
1>  Orleans-CodeGen - command-line = ""c:\Projects\orleanstest\packages\Microsoft.Orleans.OrleansCodeGenerator.Build.1.4.0\build\..\tools\ClientGenerator.exe""  ""@obj\Release\orleanstest.codegen.args.txt""
1>  Orleans-CodeGen - Reading code-gen params from file=obj\Release\orleanstest.codegen.args.txt
1>  MISSING: Path not exists: c:\Projects\orleanstest\orleanstest\obj\Release\orleanstest.codegen.cs
1>  Orleans-CodeGen - Options 
1>  	InputLib=c:\Projects\orleanstest\orleanstest\obj\Release\orleanstest.exe
1>  	OutputFileName=c:\Projects\orleanstest\orleanstest\obj\Release\orleanstest.codegen.cs
1>  Orleans-CodeGen - Using referenced libraries:
1>  	Microsoft.CodeAnalysis.CSharp.dll => c:\Projects\orleanstest\packages\Microsoft.CodeAnalysis.CSharp.1.3.2\lib\net45\Microsoft.CodeAnalysis.CSharp.dll
1>  	Microsoft.CodeAnalysis.dll => c:\Projects\orleanstest\packages\Microsoft.CodeAnalysis.Common.1.3.2\lib\net45\Microsoft.CodeAnalysis.dll
1>  	Microsoft.CSharp.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Microsoft.CSharp.dll
1>  	Microsoft.Extensions.DependencyInjection.Abstractions.dll => c:\Projects\orleanstest\packages\Microsoft.Extensions.DependencyInjection.Abstractions.1.0.0\lib\netstandard1.0\Microsoft.Extensions.DependencyInjection.Abstractions.dll
1>  	Microsoft.Extensions.DependencyInjection.dll => c:\Projects\orleanstest\packages\Microsoft.Extensions.DependencyInjection.1.0.0\lib\netstandard1.1\Microsoft.Extensions.DependencyInjection.dll
1>  	mscorlib.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\mscorlib.dll
1>  	Newtonsoft.Json.dll => c:\Projects\orleanstest\packages\Newtonsoft.Json.7.0.1\lib\net45\Newtonsoft.Json.dll
1>  	Orleans.dll => c:\Projects\orleanstest\packages\Microsoft.Orleans.Core.1.4.0\lib\net451\Orleans.dll
1>  	System.Collections.Immutable.dll => c:\Projects\orleanstest\packages\System.Collections.Immutable.1.1.37\lib\dotnet\System.Collections.Immutable.dll
1>  	System.Core.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\System.Core.dll
1>  	System.Data.DataSetExtensions.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\System.Data.DataSetExtensions.dll
1>  	System.Data.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\System.Data.dll
1>  	System.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\System.dll
1>  	System.Net.Http.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\System.Net.Http.dll
1>  	System.Reflection.Metadata.dll => c:\Projects\orleanstest\packages\System.Reflection.Metadata.1.2.0\lib\portable-net45+win8\System.Reflection.Metadata.dll
1>  	System.Xml.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\System.Xml.dll
1>  	System.Xml.Linq.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\System.Xml.Linq.dll
1>  	System.Collections.Concurrent.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.Collections.Concurrent.dll
1>  	System.Collections.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.Collections.dll
1>  	System.ComponentModel.Annotations.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.ComponentModel.Annotations.dll
1>  	System.ComponentModel.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.ComponentModel.dll
1>  	System.ComponentModel.EventBasedAsync.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.ComponentModel.EventBasedAsync.dll
1>  	System.Diagnostics.Contracts.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.Diagnostics.Contracts.dll
1>  	System.Diagnostics.Debug.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.Diagnostics.Debug.dll
1>  	System.Diagnostics.Tools.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.Diagnostics.Tools.dll
1>  	System.Diagnostics.Tracing.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.Diagnostics.Tracing.dll
1>  	System.Dynamic.Runtime.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.Dynamic.Runtime.dll
1>  	System.Globalization.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.Globalization.dll
1>  	System.IO.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.IO.dll
1>  	System.Linq.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.Linq.dll
1>  	System.Linq.Expressions.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.Linq.Expressions.dll
1>  	System.Linq.Parallel.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.Linq.Parallel.dll
1>  	System.Linq.Queryable.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.Linq.Queryable.dll
1>  	System.Net.NetworkInformation.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.Net.NetworkInformation.dll
1>  	System.Net.Primitives.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.Net.Primitives.dll
1>  	System.Net.Requests.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.Net.Requests.dll
1>  	System.ObjectModel.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.ObjectModel.dll
1>  	System.Reflection.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.Reflection.dll
1>  	System.Reflection.Emit.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.Reflection.Emit.dll
1>  	System.Reflection.Emit.ILGeneration.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.Reflection.Emit.ILGeneration.dll
1>  	System.Reflection.Emit.Lightweight.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.Reflection.Emit.Lightweight.dll
1>  	System.Reflection.Extensions.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.Reflection.Extensions.dll
1>  	System.Reflection.Primitives.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.Reflection.Primitives.dll
1>  	System.Resources.ResourceManager.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.Resources.ResourceManager.dll
1>  	System.Runtime.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.Runtime.dll
1>  	System.Runtime.Extensions.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.Runtime.Extensions.dll
1>  	System.Runtime.InteropServices.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.Runtime.InteropServices.dll
1>  	System.Runtime.InteropServices.WindowsRuntime.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.Runtime.InteropServices.WindowsRuntime.dll
1>  	System.Runtime.Numerics.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.Runtime.Numerics.dll
1>  	System.Runtime.Serialization.Json.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.Runtime.Serialization.Json.dll
1>  	System.Runtime.Serialization.Primitives.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.Runtime.Serialization.Primitives.dll
1>  	System.Runtime.Serialization.Xml.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.Runtime.Serialization.Xml.dll
1>  	System.Security.Principal.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.Security.Principal.dll
1>  	System.ServiceModel.Duplex.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.ServiceModel.Duplex.dll
1>  	System.ServiceModel.Http.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.ServiceModel.Http.dll
1>  	System.ServiceModel.NetTcp.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.ServiceModel.NetTcp.dll
1>  	System.ServiceModel.Primitives.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.ServiceModel.Primitives.dll
1>  	System.ServiceModel.Security.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.ServiceModel.Security.dll
1>  	System.Text.Encoding.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.Text.Encoding.dll
1>  	System.Text.Encoding.Extensions.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.Text.Encoding.Extensions.dll
1>  	System.Text.RegularExpressions.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.Text.RegularExpressions.dll
1>  	System.Threading.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.Threading.dll
1>  	System.Threading.Tasks.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.Threading.Tasks.dll
1>  	System.Threading.Tasks.Parallel.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.Threading.Tasks.Parallel.dll
1>  	System.Threading.Timer.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.Threading.Timer.dll
1>  	System.Xml.ReaderWriter.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.Xml.ReaderWriter.dll
1>  	System.Xml.XDocument.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.Xml.XDocument.dll
1>  	System.Xml.XmlSerializer.dll => C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\Facades\System.Xml.XmlSerializer.dll
1>  -- Code-gen FAILED -- 
1>  
1>  Exc level 0: System.BadImageFormatException: Could not load file or assembly 'file:///c:\Projects\orleanstest\orleanstest\obj\Release\orleanstest.exe' or one of its dependencies. An attempt was made to load a program with an incorrect format.
1>     at System.Reflection.RuntimeAssembly._nLoad(AssemblyName fileName, String codeBase, Evidence assemblySecurity, RuntimeAssembly locationHint, StackCrawlMark& stackMark, IntPtr pPrivHostBinder, Boolean throwOnFileNotFound, Boolean forIntrospection, Boolean suppressSecurityChecks)
1>     at System.Reflection.RuntimeAssembly.InternalLoadAssemblyName(AssemblyName assemblyRef, Evidence assemblySecurity, RuntimeAssembly reqAssembly, StackCrawlMark& stackMark, IntPtr pPrivHostBinder, Boolean throwOnFileNotFound, Boolean forIntrospection, Boolean suppressSecurityChecks)
1>     at System.Reflection.RuntimeAssembly.InternalLoadFrom(String assemblyFile, Evidence securityEvidence, Byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm, Boolean forIntrospection, Boolean suppressSecurityChecks, StackCrawlMark& stackMark)
1>     at System.Reflection.Assembly.LoadFrom(String assemblyFile)
1>     at Orleans.CodeGeneration.GrainClientGenerator.CreateGrainClient(CodeGenOptions options)
1>     at Orleans.CodeGeneration.GrainClientGenerator.CreateGrainClient(CodeGenOptions options)
1>     at Orleans.CodeGeneration.GrainClientGenerator.CreateGrainClientAssembly(CodeGenOptions options)
1>     at Orleans.CodeGeneration.GrainClientGenerator.RunMain(String[] args)

```


**To recreate this bug**, simply create a new project, add the latest Microsoft.Orleans.OrleansCodeGenerator.Build nuget package, change the project's platform target to x86, and build.","Project fails to build after adding OrleansCodeGenerator.Build package if platform is x86  **Build error is:**
The command """"c:\Projects\orleanstest\packages\Microsoft.Orleans.OrleansCodeGenerator.Build.1.4.0\build\..\tools\ClientGenerator.exe"" ""@obj\Rel",4934,ReubenBond,orleans
4875,Revisit silo stop/shutdown timeout,"","Revisit silo stop/shutdown timeout  ",4883,benjaminpetit,orleans
4774,Race condition with interleaved messages using TCS,"We're extensively using the async batcher pattern described by @hataytuna in this book
https://github.com/hataytuna/Distributed/raw/master/Applied%20Actor%20Model%20with%20Orleans%20v1.1.pdf It is crucial to performance boosts we got from batching in our system.

We figured out that problem we're experiencing with graceful shutdown described in #4757 is due to Orleans not being able to deactivate some of the grains. This only happens when TaskCompletionSource is used (along with the buffering and timer-based completion).

I have a failing test (#4773) for this scenario you can pull and check. On the surface, it looks like after DeactivateOnIdle is called Orleans disposes the timer while there interleaved requests, which leaves tasks in the uncompleted state, thus preventing Orleans from deactivating the grain.

Please, advice what can be done wrt to this issue.","Race condition with interleaved messages using TCS  We're extensively using the async batcher pattern described by @hataytuna in this book
https://github.com/hataytuna/Distributed/raw/master/Applied%20Actor%20Model%20with%20Orleans%20v1.1.pdf It is cruci",4883,benjaminpetit,orleans
4757,Incorrect silo shutdown behavior,"We're experiencing serious problems with a rolling update after migration to 2.0. Let me explain our architecture: we have a single heterogenous Azure queue processed by multiple workers (Competing Consumers pattern). Each message in this queue may be destined to a differrent actor. The setup is quite similar to how built-in Azure Queue Streaming Provider works. See diagram below.

![2018-07-11 12_06_43-untitled diagram xml - draw io](https://user-images.githubusercontent.com/107726/42562033-5785be38-8503-11e8-9e9e-055862a2d9c4.png)

Each node runs pulling agent (queue poller)  and the corresponding TPL DataFlow pipeline outside of the silo but within the same process with the silo (ie embedded). It could happen that recipent actor may reside on a different silo and so the client may forward the message to another silo, which is normal of course. Also there number of other actors that may exchange messages across silos, also normal, of course, since that's the whole point of having Orleans.

The problem arises when we try to shutdown the silo during rolling update. My expectation of Orleans' silo shutdown behavior when `StopAsync()` is called:
1. Don't accept any *new* requests into the silo, neither from clients nor from other silos (basically, close silo gateway)
2. Wait until all outstanding requests are completed (or failed or timed out) and return results
3. Deactivate all actors
4. Done

Instead, what we see from logs is that upon receiving `StopAsync()` Orleans almost immedietely deactivates all actors and then for 1 minute it bounces requests from other clients/silos by trying to forward them to non-existent activations (and they are not reactivated on the current silo of course since it's shutting down), and after 1 minute it kills itself after silo stop timeout is expired (which is 1 minute as I can see from the code). During this time it (Orleans.Runtime.Dispatcher) spills tens of thousands of log messages like:

```
Trying to forward after Non-existent activation, ForwardCount = 0. Message Request S10.31.5.14:100:268955504*cli/586efeb6@0c49119e->S10.31.5.14:100:268955504*grn/2FB327A8/00000000+124531@dd334eba #17019
```

And

```
Forwarding failed: tried to forward message Request S10.31.5.14:100:268955504*cli/586efeb6@0c49119e->S10.31.5.14:100:268955504*grn/2FB327A8/00000000+136155@897e8889 #17002[ForwardCount=1]:  for 1 times after Non-existent activation to invalid activation. Rejecting now.
```

And
 
```
Intermediate NonExistentActivation for message Request S10.31.5.14:100:268955504*cli/ee2e539e@6615b9ac->S10.31.5.14:100:268955504*grn/2FB327A8/00000000+121772@882812ba #46821: , with Exception Orleans.Runtime.Catalog+NonExistentActivationException: Non-existent activation: [ActivationAddress: S10.31.5.14:100:268955504*grn/2FB327A8/00000000+121772@882812ba, Full GrainId: [GrainId: *grn/2FB327A8/00000000000000000000000000000000060000002fb327a8+121772-0x577BB16A, IdCategory: KeyExtGrain, BaseTypeCode: 800270248 (x2FB327A8), PrimaryKey: 0 (x0), UniformHashCode: 1467724138 (0x577BB16A), KeyExtension: 121772], Full ActivationId: @42851f391a09207a71eff3b7882812ba0000000000000000], grain type: Fun.LegacyTheme.
   at Orleans.Runtime.Catalog.GetOrCreateActivation(ActivationAddress address, Boolean newPlacement, String grainType, String genericArguments, Dictionary`2 requestContextData, Task& activatedPromise)
   at Orleans.Runtime.Dispatcher.ReceiveMessage(Message message)
```

This is unacceptable behavior for us, as:
1. The whole cluster restart takes more than 10 minutes (more then 2 minutes per node. we have 5 nodes at the moment). Which is super slow.
2. Since during this time deactivated actors are not re-activated on other silos, queue messages are timing out and are returned to queue. For 10 minutes chaos which occur during restart messages may breach dequeue count threshold and be moved to quarantine queue. Which is super bad.
4. During restart the queue length may grow up to 100x, leading to client visible processing delays and additional stress. 
3. Our logs cluster (ES) is not made from rubber and on each restart Orleans can easily generate 0.5M log messages. With 10 deployments per day Orleans logs take a considerable amount of space.

The question is what are we doing wrong? No matter what we do we can't gracefully shutdown the silo. Our shutdown routine:
1. Stop all local pulling agents (silo local queue poller).
2. Wait\complete\cancel local pipeline
3. Stop the silo
4. Diconnect local client

It seems that all those steps are useless since requests from other clients\silos are still accepted by the silo after `StopAsync` is issued. I can't trace whether those requests were accepted just before `StopAsync()` but even if they are, Orleans *should not deactivate* actors until all those requests are completed.

P.S. I didn't include in this conversation hundreds of thousands of `SiloUnavailableException` and `OrleansMessageRejectionException` raised by sibling nodes during each restart - I belive it's a topic of its own (perhaps retries could be advised as the solution).",Incorrect silo shutdown behavior  We're experiencing serious problems with a rolling update after migration to 2.0. Let me explain our architecture: we have a single heterogenous Azure queue processed by multiple workers (Competing Consumers pattern). Eac,4883,benjaminpetit,orleans
4852,Revisit handling of StatelessWorker grains during shutdown,"Base on the feedback in #4757, we need to reconsider how StatelessWorker grains are handled during silo shutdown.","Revisit handling of StatelessWorker grains during shutdown  Base on the feedback in #4757, we need to reconsider how StatelessWorker grains are handled during silo shutdown.",4853,benjaminpetit,orleans
4757,Incorrect silo shutdown behavior,"We're experiencing serious problems with a rolling update after migration to 2.0. Let me explain our architecture: we have a single heterogenous Azure queue processed by multiple workers (Competing Consumers pattern). Each message in this queue may be destined to a differrent actor. The setup is quite similar to how built-in Azure Queue Streaming Provider works. See diagram below.

![2018-07-11 12_06_43-untitled diagram xml - draw io](https://user-images.githubusercontent.com/107726/42562033-5785be38-8503-11e8-9e9e-055862a2d9c4.png)

Each node runs pulling agent (queue poller)  and the corresponding TPL DataFlow pipeline outside of the silo but within the same process with the silo (ie embedded). It could happen that recipent actor may reside on a different silo and so the client may forward the message to another silo, which is normal of course. Also there number of other actors that may exchange messages across silos, also normal, of course, since that's the whole point of having Orleans.

The problem arises when we try to shutdown the silo during rolling update. My expectation of Orleans' silo shutdown behavior when `StopAsync()` is called:
1. Don't accept any *new* requests into the silo, neither from clients nor from other silos (basically, close silo gateway)
2. Wait until all outstanding requests are completed (or failed or timed out) and return results
3. Deactivate all actors
4. Done

Instead, what we see from logs is that upon receiving `StopAsync()` Orleans almost immedietely deactivates all actors and then for 1 minute it bounces requests from other clients/silos by trying to forward them to non-existent activations (and they are not reactivated on the current silo of course since it's shutting down), and after 1 minute it kills itself after silo stop timeout is expired (which is 1 minute as I can see from the code). During this time it (Orleans.Runtime.Dispatcher) spills tens of thousands of log messages like:

```
Trying to forward after Non-existent activation, ForwardCount = 0. Message Request S10.31.5.14:100:268955504*cli/586efeb6@0c49119e->S10.31.5.14:100:268955504*grn/2FB327A8/00000000+124531@dd334eba #17019
```

And

```
Forwarding failed: tried to forward message Request S10.31.5.14:100:268955504*cli/586efeb6@0c49119e->S10.31.5.14:100:268955504*grn/2FB327A8/00000000+136155@897e8889 #17002[ForwardCount=1]:  for 1 times after Non-existent activation to invalid activation. Rejecting now.
```

And
 
```
Intermediate NonExistentActivation for message Request S10.31.5.14:100:268955504*cli/ee2e539e@6615b9ac->S10.31.5.14:100:268955504*grn/2FB327A8/00000000+121772@882812ba #46821: , with Exception Orleans.Runtime.Catalog+NonExistentActivationException: Non-existent activation: [ActivationAddress: S10.31.5.14:100:268955504*grn/2FB327A8/00000000+121772@882812ba, Full GrainId: [GrainId: *grn/2FB327A8/00000000000000000000000000000000060000002fb327a8+121772-0x577BB16A, IdCategory: KeyExtGrain, BaseTypeCode: 800270248 (x2FB327A8), PrimaryKey: 0 (x0), UniformHashCode: 1467724138 (0x577BB16A), KeyExtension: 121772], Full ActivationId: @42851f391a09207a71eff3b7882812ba0000000000000000], grain type: Fun.LegacyTheme.
   at Orleans.Runtime.Catalog.GetOrCreateActivation(ActivationAddress address, Boolean newPlacement, String grainType, String genericArguments, Dictionary`2 requestContextData, Task& activatedPromise)
   at Orleans.Runtime.Dispatcher.ReceiveMessage(Message message)
```

This is unacceptable behavior for us, as:
1. The whole cluster restart takes more than 10 minutes (more then 2 minutes per node. we have 5 nodes at the moment). Which is super slow.
2. Since during this time deactivated actors are not re-activated on other silos, queue messages are timing out and are returned to queue. For 10 minutes chaos which occur during restart messages may breach dequeue count threshold and be moved to quarantine queue. Which is super bad.
4. During restart the queue length may grow up to 100x, leading to client visible processing delays and additional stress. 
3. Our logs cluster (ES) is not made from rubber and on each restart Orleans can easily generate 0.5M log messages. With 10 deployments per day Orleans logs take a considerable amount of space.

The question is what are we doing wrong? No matter what we do we can't gracefully shutdown the silo. Our shutdown routine:
1. Stop all local pulling agents (silo local queue poller).
2. Wait\complete\cancel local pipeline
3. Stop the silo
4. Diconnect local client

It seems that all those steps are useless since requests from other clients\silos are still accepted by the silo after `StopAsync` is issued. I can't trace whether those requests were accepted just before `StopAsync()` but even if they are, Orleans *should not deactivate* actors until all those requests are completed.

P.S. I didn't include in this conversation hundreds of thousands of `SiloUnavailableException` and `OrleansMessageRejectionException` raised by sibling nodes during each restart - I belive it's a topic of its own (perhaps retries could be advised as the solution).",Incorrect silo shutdown behavior  We're experiencing serious problems with a rolling update after migration to 2.0. Let me explain our architecture: we have a single heterogenous Azure queue processed by multiple workers (Competing Consumers pattern). Eac,4853,benjaminpetit,orleans
4509,Consolidate SiloStatisticsOptions and ClientStatisticsOptions,"The options system doesn't handle inheritance.
The divide between `SiloStatisticsOptions` and `ClientStatisticsOptions` complicates things unnecessarily.

Also split out `DeploymentLoadPublishingOptions`","Consolidate SiloStatisticsOptions and ClientStatisticsOptions  The options system doesn't handle inheritance.
The divide between `SiloStatisticsOptions` and `ClientStatisticsOptions` complicates things unnecessarily.

Also split out `DeploymentLoadPubl",4515,ReubenBond,orleans
4499,StatisticsLevel.Verbose causes serialization exceptions,"
- Orleans 2.0

**config:**
``` csharp
client = new ClientBuilder()
    .Configure<ClusterOptions>(options =>
    {
        options.ClusterId = clusterId;
        options.ServiceId = ServiceId.ToString();
    })
    .Configure<ClientStatisticsOptions>(options =>
    {
        options.CollectionLevel = StatisticsLevel.Verbose;
    })
    .UseZooKeeperClustering((ZooKeeperGatewayListProviderOptions options) =>
    {
        options.ConnectionString = zookeeper;
    })
    .ConfigureApplicationParts(parts => parts.AddApplicationPart(typeof(ISampleGrain).Assembly))
    .ConfigureLogging(logging=>logging.AddConsole())
    .Build();
```


**log:**
> warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://10.0.1.18:10300/262055360[100159]                               
      Unexpected error serializing message to gateway gwy.tcp://10.0.1.18:10300/262055360.                                      
System.NullReferenceException: Object reference not set to an instance of an object.                                            
   at Orleans.Serialization.SerializationManager.SerializeMessageHeaders(HeadersContainer headers, SerializationContext context)
   at Orleans.Runtime.Message.Serialize(SerializationManager serializationManager, Int32& headerLengthOut, Int32& bodyLengthOut)
   at Orleans.Messaging.OutgoingMessageSender.Process(Message msg)                                                              
warn: Orleans.OutsideRuntimeClient[104202]                                                                                      
      Refresh the GrainTypeResolver failed. WIll be retried after                                                               
Orleans.Runtime.OrleansMessageRejectionException: Unexpected error serializing message to gateway gwy.tcp://10.0.1.18:10300/262055360. System.NullReferenceException: Object reference not set to an instance of an object.
    at Orleans.Serialization.SerializationManager.SerializeMessageHeaders(HeadersContainer headers, SerializationContext context)
    at Orleans.Runtime.Message.Serialize(SerializationManager serializationManager, Int32& headerLengthOut, Int32& bodyLengthOut)
    at Orleans.Messaging.OutgoingMessageSender.Process(Message msg)                                                              
    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()                                                            
    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)                            
    at Orleans.Runtime.OutgoingCallInvoker.<Invoke>d__21.MoveNext()     
","StatisticsLevel.Verbose causes serialization exceptions  
- Orleans 2.0

**config:**
``` csharp
client = new ClientBuilder()
    .Configure<ClusterOptions>(options =>
    {
        options.ClusterId = clusterId;
        options.ServiceId = Servic",4515,ReubenBond,orleans
3980,Add networking mask options in EndpointOptions,"Related issue: #3203 

Right now, using the legacy configuration, in the case of a ""multi-homed"" server, to force the selection of a specific IP address for the membership/gateway table, users have to use `GlobalConfiguration.SubNet`.  This solution is not suitable if the networks available on the server are not using network sliced in 8/16/24.

With this implementation in `EndpointOptions`, the user can use a real network address, with a real network mask.","Add networking mask options in EndpointOptions  Related issue: #3203 

Right now, using the legacy configuration, in the case of a ""multi-homed"" server, to force the selection of a specific IP address for the membership/gateway table, users have to use",4005,benjaminpetit,orleans
3676,Allow listening on an address that is different from the externally reachable address,"It would be nice if Orleans supports listening in an address that is not necessarily the same one that is externally addressable.
A very common example of this is when running in containers, where the Silo could be configured to bind to localhost and a fixed port, but then this is mapped into a virtual network and the host acts like a NAT.

So basically allow all the silos in their containers to listen on `localhost:22222` and `localhost:30000` but in their membership register with a distinct IP address and/or a different port that is passed in by the host (it should support changing ports, not just IP, since there might be many silos/containers running in the same host, and to avoid port conflicts with the host).

This might be a good candidate for doing when we replace the legacy `ClusterConfiguration` with the new `IOptions`-based configuration.","Allow listening on an address that is different from the externally reachable address  It would be nice if Orleans supports listening in an address that is not necessarily the same one that is externally addressable.
A very common example of this is when",4005,benjaminpetit,orleans
3202,Update What's New with 1.4.2 and 1.5.0,"","Update What's New with 1.4.2 and 1.5.0  ",4005,benjaminpetit,orleans
3984,Gateway cannot be called using localhost when running in non-local silo mode.  Kubernetes pod scenerio,"This is the scenario that breaks:

- Orleans silo running in container listening on port 22222 and gateway 40000 with IP.Any using Azure table membership
- Web app in container listening to port 80 using Orleans client calling Gateway client endpoint 127.0.0.1 port 40000
- Both containers are in side one Kubernetes Statefulset pod with external port 80 exposed.
- Silo to silo communications works well.

It is expected that the web app can communicate with the Orleans silo at localhost:40000 inside the pod.  This is not the case.  It seems that the gateway will always listen on the same address as the silo address.

```
this.gatewayAddressLazy = new Lazy<SiloAddress>(() => endpointOptions.ProxyPort != 0 ? SiloAddress.New(new IPEndPoint(this.SiloAddress.Endpoint.Address, endpointOptions.ProxyPort), 0) : null);
```
The config setting below where IP address is set to ANY is not being honored:
```
config.Defaults.ProxyGatewayEndpoint = new IPEndPoint(IPAddress.Any, 40000);
```

This breaks any sidecar scenarios in containerized applications.","Gateway cannot be called using localhost when running in non-local silo mode.  Kubernetes pod scenerio  This is the scenario that breaks:

- Orleans silo running in container listening on port 22222 and gateway 40000 with IP.Any using Azure table member",4005,benjaminpetit,orleans
3954,Configuration Works - StorageOptions,"The original cluster and client configurations used a shared account key for general storage and reminder storage.  This pattern has been carried over in the StorageOptions.  This is a questionable pattern as there is no reason to assume authentication/authorization for various storage systems can be generalized in such a way, nor is it possible to provide reasonable defaults or security for such information.

Identify storage needs (by component) for framework, work out abstractions and configuration.  Leave extension configurations to the extensions.",Configuration Works - StorageOptions  The original cluster and client configurations used a shared account key for general storage and reminder storage.  This pattern has been carried over in the StorageOptions.  This is a questionable pattern as there is,4000,ReubenBond,orleans
3953,Configuration Work - assembly loaded types,"Many patterns carried over from the legacy configuration use strings or enums to identify component implementations.  These settings trigger assembly loads of pre defined assemblies and creation of types assumed to be in those assemblies.  This pattern is error prone and poorly maintainable.

In new systems this is done by requiring component implementations to be registered in the container by name and configured values are used by named service resolution, but no consensus has been built around this pattern.

We need to design a better pattern and replace the legacy pattern.",Configuration Work - assembly loaded types  Many patterns carried over from the legacy configuration use strings or enums to identify component implementations.  These settings trigger assembly loads of pre defined assemblies and creation of types assumed,4000,ReubenBond,orleans
3955,Configuration Work - Formatters,Add options formatters for all the new options. (many already have formatters),Configuration Work - Formatters  Add options formatters for all the new options. (many already have formatters),3972,jason-bragg,orleans
3950,Configuration Work - XML docs,"While moving from monolithic Cluster and Client configurations to options, settings without xml comments were copied without comment, leaving it unclear what these settings are for.

We need to go through all of the new options and ensure that the options themselves as well as all of it's properties have xml comments.","Configuration Work - XML docs  While moving from monolithic Cluster and Client configurations to options, settings without xml comments were copied without comment, leaving it unclear what these settings are for.

We need to go through all of the new op",3972,jason-bragg,orleans
3567,Bring CPU and Memory statistics back,"When Orleans master move to netstandard, we temporarily disabled CPU and Memory statistics reporting , because these two statistics rely on performance counters. There was complication on CPU and memory statistics reporting at the time
- performance counters wasn't supported in netstandard in early versions
- performance counters only work in windows. So when we move to netstandard, we need to find a way to report CPU and memory statistics in other platforms too.  

Now the situation is more clearer with netstandad 2.0. We know that per counters are coming back to netstandard, although only on windows But regardless, we need to find a way to bring CPU and Memory statistic back, on windows, and other platforms.","Bring CPU and Memory statistics back   When Orleans master move to netstandard, we temporarily disabled CPU and Memory statistics reporting , because these two statistics rely on performance counters. There was complication on CPU and memory statistics re",3891,benjaminpetit,orleans
3586,Performance Counter alternatives in 2.0.0,"In current Orleans we are using Performance counters for multiple things:
- Expose [Orleans system metrics](https://github.com/dotnet/orleans/blob/master/src/Orleans.Core/Statistics/RuntimeStatisticsGroup.cs) as Performance counters
- Read CPU utilization for the load shedding [streaming](https://github.com/dotnet/orleans/blob/bfcc00f4fcd001334431bbf2511915e75747c192/src/Orleans.Runtime/Streams/LoadShedQueueFlowController.cs) feature
- Collect [Thread context switch](https://github.com/dotnet/orleans/blob/bfcc00f4fcd001334431bbf2511915e75747c192/src/Orleans.Core/Statistics/ThreadTrackingStatistic.cs#L209) statistics
- Make it possible to [register performance counters](https://github.com/dotnet/orleans/blob/bfcc00f4fcd001334431bbf2511915e75747c192/src/Orleans.TelemetryConsumers.Counters/OrleansPerfCounterTelemetryConsumer.cs) for grain by grain type, so grain count per type can be monitored

As Orleans 2.0 will support multiple OS platforms, Performance Counters are not a viable way ahead, so we're looking for alternate solutions:
- Keep the performance counter feature, but separate it into a Windows only package
- Move away from performance counters at all and implement a similar functionality on top of [System.Diagnostics.Tracing.EventSource](https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.tracing.eventsource?view=netcore-2.0) and associated classes, since they're part of .Net Standard 2.0
- Since reading the processor utilization without elevated privileges through ETW is not possible, it's probable, that load shedding will be abstracted out from the system and be a Windows only feature in Orleans 2.0

Building on top of the Tracing infrastructure it enables us to provide richer statistics and insights - with the support of event payloads - into a running system which can be consumed with standard ETW (Event Tracing for Windows) tools, when running under Windows, like [perfview](https://github.com/Microsoft/perfview).","Performance Counter alternatives in 2.0.0  In current Orleans we are using Performance counters for multiple things:
- Expose [Orleans system metrics](https://github.com/dotnet/orleans/blob/master/src/Orleans.Core/Statistics/RuntimeStatisticsGroup.cs) as",3891,benjaminpetit,orleans
3214,Allow interception in GrainClient for outgoing grain method invocations,"We are currently investigating how to implement end-to-end tracing using DiagnosticsSource ( https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.DiagnosticSource/src/HttpCorrelationProtocol.md )

Looking at HttpClient's diagnostichandler implementation (https://github.com/dotnet/corefx/blob/c082d21361608e3cc2ea3cddd90c2a0306828002/src/System.Net.Http/src/System/Net/Http/DiagnosticsHandler.cs), I would like to be able to intercept an outgoing remote grain invocation in the client and Start / End an activity in the DiagnosticsSource, but intercepting the end of a remote grain invocation is not possible with a `ClientInvokeCallback`",Allow interception in GrainClient for outgoing grain method invocations  We are currently investigating how to implement end-to-end tracing using DiagnosticsSource ( https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.DiagnosticSource/src/,3842,ReubenBond,orleans
2125,Question: Can grain client interceptors be used to intercept grain-to-grain call?,"In my service there are numerous grain to grain calls, and I like to implement general retry logic on the caller side and like to know whether Orleans interceptors could be used for it. Server-side interceptors don't seem to fit since AFAIK they run on the callee side, not the caller. Grain client interceptors doesn't seem to fit as well since grain to grain doesn't use the static GrainClient. Is there a built way to do what I want? ","Question: Can grain client interceptors be used to intercept grain-to-grain call?  In my service there are numerous grain to grain calls, and I like to implement general retry logic on the caller side and like to know whether Orleans interceptors could be",3842,ReubenBond,orleans
3598,Cannot find an implementation class for grain interface .net core 2.0 (orleans 2.0.0-preview4),"Hello, I'm trying to run orleans on .net core 2.0 and persistently get an error: Cannot find an implementation class for grain interface: Contracts.IHelloGrain. Make sure the grain assembly was correctly deployed and loaded in the silo. Here is the [source code](https://github.com/galamai/Solution1) that I try. What am I doing wrong and how do I fix it?","Cannot find an implementation class for grain interface .net core 2.0 (orleans 2.0.0-preview4)  Hello, I'm trying to run orleans on .net core 2.0 and persistently get an error: Cannot find an implementation class for grain interface: Contracts.IHelloGrain",3603,ReubenBond,orleans
3597,Microsoft.Orleans.OrleansCodeGenerator.Build Cant't Build,"![image](https://user-images.githubusercontent.com/13499426/31983974-30867ecc-b992-11e7-8b68-7eb690c65f3f.png)

![image](https://user-images.githubusercontent.com/13499426/31998040-dfe6b07a-b9c0-11e7-935b-f44934f5537a.png)

1>Expression: [Recursive resource lookup bug]
1>Description: Infinite recursion during resource lookup within System.Private.CoreLib.  This may be a bug in System.Private.CoreLib, or potentially in certain extensibility points such as assembly resolve events or CultureInfo names.  Resource name: ArgumentNull_Generic
1>Stack Trace:


But Microsoft.Orleans.OrleansCodeGenerator work well.","Microsoft.Orleans.OrleansCodeGenerator.Build Cant't Build  ![image](https://user-images.githubusercontent.com/13499426/31983974-30867ecc-b992-11e7-8b68-7eb690c65f3f.png)

![image](https://user-images.githubusercontent.com/13499426/31998040-dfe6b07a-b9c0",3603,ReubenBond,orleans
2733,Rename or remove DuplicateActivationException to prevent confusion,"`DuplicateActivationException` doesn't mean that a duplicate activation has been created. It is just a means to resolve a race between two or more silos trying concurrently to register activations for the same grain. However, the very name of the exception class and the message of it misleads people to think that they get duplicate activations.

I suggest we rename the exception class to prevent this confusion from happening.

`RegistrationRaceException`? `ActivationAlreadyRegisteredException`? `ExistingActivationException`?",Rename or remove DuplicateActivationException to prevent confusion   `DuplicateActivationException` doesn't mean that a duplicate activation has been created. It is just a means to resolve a race between two or more silos trying concurrently to register a,3130,ReubenBond,orleans
3129,Convert IMembershipTableGrain into a SystemTarget,"Currently the `IMembershipTableGrain` is special in that it is registered by the primary using the special-purpose `Catalog.CreateSystemGrain(...)` method.

This all only exists for the purpose of `IMembershipTableGrain` which is only valid for test scenarios - it's not reliable in the distributed systems sense of the word.

Ideally, we could remove that method and the notion of a system grain.","Convert IMembershipTableGrain into a SystemTarget  Currently the `IMembershipTableGrain` is special in that it is registered by the primary using the special-purpose `Catalog.CreateSystemGrain(...)` method.

This all only exists for the purpose of `IMem",3130,ReubenBond,orleans
3120,"Upcoming changes on EHStreamProvider, MemoryStreamProvider and GeneratorStreamProvider in 1.5","Per discussion in #3104 , Since for EventhubStreamProvider, MemoryStreamProvider and GeneratorStreamProvider, the stream provider settings of `DataMaxAgeInCache` and `DataMinTimeInCache` conflicts with `CacheSizeInMb`, we reached the decision that

- We will remove `CacheSzieInMb `setting and its related infrastructure, including cache eviction logic around it and `FixedSizeObjectPool`, to simplify the system and avoid problems mentioned in #3104
- Add `DataMaxAgeInCache `and `DataMinTineInCache` setting to all three stream providers

- Add statistic monitoring too all three stream providers

After 1.5, for these three stream providers, `DataMaxAgeInCache`and `DataMinTineInCache `will be the only criteria used to predicate cache eviction. Be sure to monitor your stream provider behavior using our new monitoring feature (#3014) in 1.5 to choose the correct value for `DataMaxAgeInCache` and `DataMinTineInCache`, since these two will be two of the main influences for cache size","Upcoming changes on EHStreamProvider, MemoryStreamProvider and GeneratorStreamProvider in 1.5  Per discussion in #3104 , Since for EventhubStreamProvider, MemoryStreamProvider and GeneratorStreamProvider, the stream provider settings of `DataMaxAgeInCache",3126,xiazen,orleans
3104,Subtle but important behavior change in orleans streaming coming with 1.5,"We made several changes to Orleans streaming system in 1.5, including new features and bug fixes, some of which are included in Orleans 1.5 beta, remaining of which will be included in future 1.5 official release. 

Aside from obvious changes you can see in our beta release note:
1. Added extension points to EventHubAdapterFactory #2930
2. Added SlowConsumingPressureMonitor for EventHub streams #2873
3. Programmable stream subscribe API #2741 #2796 #2909 

There's a subtle behavior change in EventHubStreamProvider eco system's cache purge logic, which may not be obvious to end users, but may bring confusion. Let me recap 1.4 and compare it to 1.5 to demonstrate. 
## The behavior change
In EventHubStreamProvider, different cache can be configured to use its own block pool or share block pool with other caches. When messages are added to the cache, cache allocate blocks from block pool to store those messages. When messages expired, there's purging logic kicking in and return purged blocks back to block pool. How messages are purged and how blocks are freed to block pool is what it is subtle different between 1.4 and 1.5.

In 1.4, when the fixed size block pool is full, it send a purge request to the cache (name it cache1) which owns its oldest block (block0), requesting it return block 0 back. This ""purge block 0"" request will enqueue cache1's purgeQueue and wait there. So overtime, cache1 will have a purgeQueue which is full of ""purge block x"" requests. Whenever new messages are added to cache1, it will dequeue a ""purge block x"" request from its purgeQueue and do a purge action. This purge action includes two steps: 1. mark messages as purged if they expired, 2 is return block x to the block pool. **But** because this purge action would return block x to the pool whether it has valid messages (messages which haven't expired yet) or not, it produces cache miss bug. This behavior is fine historically to its initial users. But when more and more users started to use EHStreamProvider, this became a problem , because it violates its time based purge promise, which is configured using DataMaxAgeInCache and DataMinTimeInCache in its EHStreamProviderSettings. This bug is fixed in #2934 , which was included in 1.5beta. 

After that fix, in 1.5beta, messages would only be purged if it expired. Cache now will do a time based purge every time when pulling agent try to `ReadFromQueue`, which is more frequent compared to 1.4.  In its time based purge action, it will do two things, 1 is mark messages as purged if they expired, 2 is put purged blocks into a purgedBlock queue if its messages are all purged. When the block pool send a ""purge block x"" request to the cache, the cache will free every blocks in its purgedBlock queue up to this block x. In this way, we won't be freeing blocks which still contains valid messages.
## What users need to do
This fix brings up a dilemma, which is why I want to write this post. Since even when the block pool is full and it sends out the ""purge oldest block"" request,  the oldest block is not always purged anymore in 1.5. The promise on ""fixed size"" is not enforced. **Size of block pool depends more on DataMaxAgeInCache and DataMinTimeInCache  settings, less on CacheSizeInMb**. And since CacheSizeInMb is be essentially based on DataMinTimeInCache and DataMaxAgeInCache Settings, we think it is a good direction to go. And we may remove CacheSizeInMb related settings and infra in the future. 

And to help end users tune their settings to avoid memory allocation related issues, we will be releasing statistic monitoring feature (#3014) in 1.5, which will help end users to understand their cache's behavior and tune their settings to a optimal value. 

Last thing I want to bring up, there could be a bad behavior in 1.5 beta streaming if you used EHStreamProvider under a massive delivery scenario (for example, 15190 TPS per silo). The cause of it is : in massive delivery scenario, purge block x request from block pool can be always too new to purge, hence ""free block"" action will not be performed even when the cache's purgeBlocks queue is not empty. This results in purged blocks not able to be freed to the pool, which leads to unnecessary memory allocation and potentially out of memory exception from your host. If you see memory issues in streaming when migrating to 1.5 beta, this might be the cause. And we will be including a fix for that in 1.5 . ","Subtle but important behavior change in orleans streaming coming with 1.5  We made several changes to Orleans streaming system in 1.5, including new features and bug fixes, some of which are included in Orleans 1.5 beta, remaining of which will be include",3126,xiazen,orleans
2750,Having a null grain reference as a property on a GrainState object results in an exception,"Having a Grain state object fails to persist if a grain Interface property is unset (`null`)

Solution is to set EventGrainState.Metadata.Owner = to a grain reference.


**Code:**
```csharp
 public class EventGrainState
    {
        public bool IsInitialized { get; set; }
        public ObjectMetadata Metadata { get; set; } = new ObjectMetadata();
        public string Name { get; set; }
        public EventData Data { get; set; } = new EventData();
        public TimeSpan Interval { get; set; }
    }
   public class ObjectMetadata
    {
        public DateTime CreatedDate { get; internal set; }
        public DateTime ModifiedDate { get; internal set; }
        public IUserGrain Owner { get; internal set; }
    }
    public class EventData
    {
        public string EventType { get; set; }
        public string Parameters { get; set; }
    }
```

**Stack Trace:**

```Cannot pass null as an argument to AsReference
Parameter name: grain
   at Orleans.GrainExtensions.AsReference[TGrainInterface](IAddressable grain)
   at NRC.Services.Scheduler.Grains.OrleansCodeGenNRC_Services_Scheduler_Grains_ObjectMetadataSerializer.DeepCopier(Object original)
   at Orleans.Serialization.SerializationManager.DeepCopyInner(Object original)
   at NRC.Services.Scheduler.Grains.OrleansCodeGenNRC_Services_Scheduler_Grains_EventGrainStateSerializer.DeepCopier(Object original)
   at Orleans.Serialization.SerializationManager.DeepCopyInner(Object original)
   at Orleans.OrleansCodeGenOrleans_GrainStateSerializer`1.DeepCopier(Object original)
   at Orleans.Serialization.SerializationManager.<>c__DisplayClass61_0.<Register>b__0(Object obj)
   at Orleans.Serialization.SerializationManager.DeepCopyInner(Object original)
   at Orleans.Serialization.SerializationManager.DeepCopierHelper(Type t, Object original)
   at Orleans.Serialization.SerializationManager.DeepCopyInner(Object original)
   at Orleans.Serialization.SerializationManager.DeepCopy(Object original)
   at Orleans.Runtime.GrainReference.InvokeMethodAsync[T](Int32 methodId, Object[] arguments, InvokeMethodOptions options, SiloAddress silo)
   at Orleans.Storage.OrleansCodeGenMemoryStorageGrainReference.WriteStateAsync(String grainType, String grainId, IGrainState grainState)
   at Orleans.Storage.MemoryStorage.<WriteStateAsync>d__21.MoveNext()
```","Having a null grain reference as a property on a GrainState object results in an exception  Having a Grain state object fails to persist if a grain Interface property is unset (`null`)

Solution is to set EventGrainState.Metadata.Owner = to a grain refe",2756,ReubenBond,orleans
2751,Serializing State classes with null grain references fail in 1.4,"As @ReubenBond  and I discussed when I want to serialize a State using WriteStateAsync, if the state class contains a reference to a grain interface say `IPlayer` which was a `GrainWithStringKey` , the serializer (the generated code) throws an exception `ArgumentNullException` when calling `AsReference`

The test failed on a relatively lohng running project which was ok on previous Orleans versions. I can post more info if needed","Serializing State classes with null grain references fail in 1.4  As @ReubenBond  and I discussed when I want to serialize a State using WriteStateAsync, if the state class contains a reference to a grain interface say `IPlayer` which was a `GrainWithStri",2756,ReubenBond,orleans
2591,[Breaking Change] Improve serializer registration,"Since we will not be supporting static `SerialzationManager.Register(...)` method, we need to change the signature of the method used to register custom serializers so that it takes some kind of context (eg, `ISerializerRegistrar`) so that serializers can be registered.

In a local branch, I've made the following changes:
* `[Serializer(typeof(TargetType))]` automatically registers the type it's attached to as the serializer for `TargetType`. This includes when `TargetType` is an open generic.
* Generated serializers no longer have `Register` methods or the associated attribute.
* No additional class is generated for generic types since the Register method is no longer needed. i.e, no ""master registerer"" class.
* The `Register` method in types marked with `[RegisterSerializer]` must accept a parameter of type `ISerializerRegistrar`.

So `[RegisterSerializer]` is rarely required. The one place it's required in our codebase is for the tests which register the same serializer for multiple different JSON types (`JObject`, `JArray`, etc) but that could just as easily be accomplished using an `IExternalSerializer` implementation. We could even remove `[RegisterSerializer]` altogether, but I'm not suggesting that yet.

Does this all sound fine?

Related to #467 

EDIT: oh, and the `[RegisterSerializer]` change is a good candidate for something to add to a code analyzer","[Breaking Change] Improve serializer registration  Since we will not be supporting static `SerialzationManager.Register(...)` method, we need to change the signature of the method used to register custom serializers so that it takes some kind of context (",2592,ReubenBond,orleans
467,Make the GrainClient class non-static,"Connecting to multiple Orleans Silos from the same client is not possible because the Orleans client class is static and there can be only one of it in a process. Making the `GrainClient` non-static will help solving this issue.

Client code will create an instance of `GrainClient` instead of using the static `GrainClient.Initialize` as follows:

``` csharp
        IGrainClient orleansClient = new GrainClient(“DevTestClientConfiguration.xml”);
        IGrainFactory grainFactory = orleansClient.GrainFactory;
        IHello grain = grainFactory.GetGrain<IHello>(“0”);
```

---

@gabikliot wrote:
TODOs:
- [x] Remove all static mutable fields from client runtime.
- [ ] Static Interners
- [x] `RuntimeClient.Current.SendRequest`
- [ ] Static `TraceLogger` instances
- [ ] Static mutable fields inside `TraceLogger`
- [x] Placement Singletons
- [x] Serializer internal collections
- [ ] All statistics counters",Make the GrainClient class non-static  Connecting to multiple Orleans Silos from the same client is not possible because the Orleans client class is static and there can be only one of it in a process. Making the `GrainClient` non-static will help solving,2592,ReubenBond,orleans
2743,migrate off AppDomainTestHook,"Remove usage of AppDomainTestHook on BootstrapProviderTests.cs , PersistenceGrainTests.cs, and StreamPubSubReliabilityTests. 

leaving GeoClusterTests the only tests using AppDomainTestHook","migrate off AppDomainTestHook  Remove usage of AppDomainTestHook on BootstrapProviderTests.cs , PersistenceGrainTests.cs, and StreamPubSubReliabilityTests. 

leaving GeoClusterTests the only tests using AppDomainTestHook",2583,xiazen,orleans
2547,[Proposal] Non-static SerializationManager changes,"In order to complete the work required for non-static grain clients (#467), it would be very helpful to make `SerializationManager` also non-static so that we can deserialize grain references correctly.

`GrainReferences` need to have access to services provided by Orleans in order to function (for example, they need to make remote calls). Therefore, I think it's a good idea to change the way that serialization and deserialization work. I'm proposing these changes and want your feedback:

* Serialization methods accept an `ISerializationContext`/`IDeserializationContext`/`ICopyContext` in their signature. The methods will all look something like this:
```C#
public interface IExternalSerializer
{
    void Initialize(Logger logger);
    bool IsSupportedType(Type itemType);
    object DeepCopy(object source, ICopyContext context);
    void Serialize(object item, ISerializationContext context, Type expectedType);
    object Deserialize(Type expectedType, IDeserializationContext context);
}
```

`SerializationContext` & `DerserializationContext`:
* Add a `Stream` property which includes the `BinaryTokenStreamWriter`/`BinaryTokenStreamReader`.
* Add a `ServiceProvider` property of type `IServiceProvider`.
* Add a `SerializationManager` property for convenient access to `SerializationManager` (could also be accessed via DI).
* Are pooled rather than being thread-static.

The implications of this are:
* `SerializationManager` can be made non-static
* Serializers can access services provided by Orleans (or the user, since it's the same container)
* Serializers will need to be adjusted to satisfy the new signature (i.e, this is a **breaking change**), but I will create Roslyn Analyzers to ensure that breakages aren't hidden or inexplicable: ![Roslyn Analyzer Prototype](http://i.imgur.com/koq7g2t.gif)

Alternatives:
* Keep method signatures the same and pass those context objects inside of `BinaryTokenStreamReader` and `BinaryTokenStreamWriter`. I think this is messy and myopic.
* Add an `IOnDeserialized` interface which accepts an `IServiceProvider`. I played with this. It will help for non-static grain clients, but not with making `SerializationManager` non-static.
* Others?

Thoughts?","[Proposal] Non-static SerializationManager changes  In order to complete the work required for non-static grain clients (#467), it would be very helpful to make `SerializationManager` also non-static so that we can deserialize grain references correctly.",2558,ReubenBond,orleans
467,Make the GrainClient class non-static,"Connecting to multiple Orleans Silos from the same client is not possible because the Orleans client class is static and there can be only one of it in a process. Making the `GrainClient` non-static will help solving this issue.

Client code will create an instance of `GrainClient` instead of using the static `GrainClient.Initialize` as follows:

``` csharp
        IGrainClient orleansClient = new GrainClient(“DevTestClientConfiguration.xml”);
        IGrainFactory grainFactory = orleansClient.GrainFactory;
        IHello grain = grainFactory.GetGrain<IHello>(“0”);
```

---

@gabikliot wrote:
TODOs:
- [x] Remove all static mutable fields from client runtime.
- [ ] Static Interners
- [x] `RuntimeClient.Current.SendRequest`
- [ ] Static `TraceLogger` instances
- [ ] Static mutable fields inside `TraceLogger`
- [x] Placement Singletons
- [x] Serializer internal collections
- [ ] All statistics counters",Make the GrainClient class non-static  Connecting to multiple Orleans Silos from the same client is not possible because the Orleans client class is static and there can be only one of it in a process. Making the `GrainClient` non-static will help solving,2558,ReubenBond,orleans
2143,[WIP] Orleans 2.X,"_This issue will be a ""root"" issue to track the progress on 2.0 milestone following the steps agreed at [Meetup 10](https://youtu.be/_SbIbYkY88o)._ 

The main target on this milestone is the port to [.Net Core](https://github.com/dotnet/coreclr) but other features like enhanced deployment & cluster management in multiple hosting environments, pervasive DI, new persistence layer, etc., but all them basically follow the major goal to be compatible with .Net Core. 

The initial strategy is to keep working on the port on `master` branch by having a separated and temporary solution where we will target `.Net Standard` while using new projects ""linking"" to the `.cs` files and following the guidelines [here](https://docs.microsoft.com/en-us/dotnet/articles/core/tutorials/target-dotnetcore-with-msbuild) (thanks to @jdom for this briliant idea). The reason for that strategy and not the current one (have a separated branch for that) is to reduce the merge complexity and be able to hotfix and add non-breaking changes to 1.3.x releases while we still working on .Net Core port. We will focus on have any breaking change on hold to 2.0 but that doesn't block us from having new features being released under 1.x.y tag.

The tasks will be distributed across multiple phases defined as **_CRAWL_**, **_WALK_** and **_RUN_**.  So, here is the list of macro-tasks that we should cover in this story and each one of them will be tracked by a separated issue and its sub-issues referenced here. 
- [x] **_CRAWL_**
  - [x] .Net Core Compatible Binaries - #2145
  - [x] Orleans 2.0 (beta is out)
- [ ] **_WALK_**
  - [x] Building on .Net Core 
  - [ ] Testing on .Net Core
  - [ ] Orleans 2.X
- [ ] **_RUN_**
  - [ ] Cross-platform testing
  - [ ] Orleans 2.Y

**Note**: #368 was tracking it before but since most of the issues there were already completed and we moved to a new strategy, from now on, lets keep the discussion about that here.
","[WIP] Orleans 2.X  _This issue will be a ""root"" issue to track the progress on 2.0 milestone following the steps agreed at [Meetup 10](https://youtu.be/_SbIbYkY88o)._ 

The main target on this milestone is the port to [.Net Core](https://github.com/dotn",2470,galvesribeiro,orleans
2145,[CRAWL Phase] .Net Core Compatibility,"_This issue will track the **CRAWL** phase of Orleans 2.X milestone as tracked by #2143_

The idea with this task is to basically make Orleans Core compatible with [.Net Core](https://github.com/dotnet/coreclr), by having it target [.Net Standard](https://docs.microsoft.com/en-us/dotnet/articles/standard/library) and have the minimal impact as possible in the current codebase. 

Since .Net Core tooling still unreliable and will (drastically) change before it reach RTM, we are following the guidelines from [here](https://docs.microsoft.com/en-us/dotnet/articles/core/tutorials/target-dotnetcore-with-msbuild)  and in a new temporary solution we will work at `master` branch.

The target is to have Orleans building and running on .Net Full CLR and .Net Core (hence why target .Net Standard) on Windows and have the full test set only for the .Net Full CLR (.Net 4.6.1+) while having basic validation on .Net Core on Windows. 

We will focus on Windows as a baseline but that doesn't mean people can't run tests on Linux/OSX once this work is done. That means that the core test set will focus on .Net Full CLR and basic .Net Core on Windows but you can test your Orleans application on .Net Core supported OSes. The test framework should stay as is. That means the major efforts will not be to update the test kit to multiple OSes and full .Net Core coverage but, if you feel comfortable, we still accept (and really encourage and appreciate!) PRs however, it will take lower priority (and of course efforts on review) from the core team and people from the community working on this port.

Here are the macro tasks and its issues that will be tracked for this phase:
- [x] Add new solution targeting .Net Standard Library 1.5 (`netstandard15`) - #2177 
- [x] Build Orleans.vNext.sln in the CI Build.cmd script - #2353 #2362
- [x] Replace Binary Serializer - #2162
- [x] Move Performance Counters to its own TelemetryConsumer - #2122 
- [x] Use supported overloads from Socket class - #2195 
- [x] Remove usage of named mutexes #2366
- [x] Remove AppDomain usage for assembly loading/scanning - #2025 and in continued progress by @attilah 
- [x] Run non-silo tests (not blocked by Silo not working in memory) - in progress by @xiazen
- [x] Avoid Silo being MarshalByRefObject but support running tests - #2196 
- [x] Avoid test hooks being MarshalByRefObject (a few still pending) - #2333
- [x] Avoid usages of CallContext - #2197 
- [x] Run all silo tests that do not use extensibility features (such as external storage providers)
- [x] Add storage providers with tests (all implementations that support .net standard out of the box) - #2615
- [x] Add stream providers with tests (all implementations that support .net standard out of the box) - #2615 and #2637
- [x] Extract client implementation from main Orleans.dll (with should have the minimal abstractions)
- [x] Migrate off the MSBuild hack for building .NET Standard once new tooling is available
- [x] Support codegen in the final tooling
- [x] Remove all `NETSTANDARD_TODO` comments by implementing workarounds
- [x] Clean up: Remove all `NETSTANDARD` comments by moving platform specific components to platform specific DLLs
- [x] Design our desired 2.0 nuget package structure (IDs and contents)
- [x] Restructure vNext projects to recreate our expected 2.0 nuget packages output structure
- [x] Full test set passing on .Net Framework 4.6.2 (`net462`)
- [x] Basic validation tests on .Net Core 1.0 (`netcoreapp10`)

**Note**: This list will be updated as new sub-tasks (issues and/or PRs) will emerge from this work.
","[CRAWL Phase] .Net Core Compatibility  _This issue will track the **CRAWL** phase of Orleans 2.X milestone as tracked by #2143_

The idea with this task is to basically make Orleans Core compatible with [.Net Core](https://github.com/dotnet/coreclr), by",2470,galvesribeiro,orleans
2145,[CRAWL Phase] .Net Core Compatibility,"_This issue will track the **CRAWL** phase of Orleans 2.X milestone as tracked by #2143_

The idea with this task is to basically make Orleans Core compatible with [.Net Core](https://github.com/dotnet/coreclr), by having it target [.Net Standard](https://docs.microsoft.com/en-us/dotnet/articles/standard/library) and have the minimal impact as possible in the current codebase. 

Since .Net Core tooling still unreliable and will (drastically) change before it reach RTM, we are following the guidelines from [here](https://docs.microsoft.com/en-us/dotnet/articles/core/tutorials/target-dotnetcore-with-msbuild)  and in a new temporary solution we will work at `master` branch.

The target is to have Orleans building and running on .Net Full CLR and .Net Core (hence why target .Net Standard) on Windows and have the full test set only for the .Net Full CLR (.Net 4.6.1+) while having basic validation on .Net Core on Windows. 

We will focus on Windows as a baseline but that doesn't mean people can't run tests on Linux/OSX once this work is done. That means that the core test set will focus on .Net Full CLR and basic .Net Core on Windows but you can test your Orleans application on .Net Core supported OSes. The test framework should stay as is. That means the major efforts will not be to update the test kit to multiple OSes and full .Net Core coverage but, if you feel comfortable, we still accept (and really encourage and appreciate!) PRs however, it will take lower priority (and of course efforts on review) from the core team and people from the community working on this port.

Here are the macro tasks and its issues that will be tracked for this phase:
- [x] Add new solution targeting .Net Standard Library 1.5 (`netstandard15`) - #2177 
- [x] Build Orleans.vNext.sln in the CI Build.cmd script - #2353 #2362
- [x] Replace Binary Serializer - #2162
- [x] Move Performance Counters to its own TelemetryConsumer - #2122 
- [x] Use supported overloads from Socket class - #2195 
- [x] Remove usage of named mutexes #2366
- [x] Remove AppDomain usage for assembly loading/scanning - #2025 and in continued progress by @attilah 
- [x] Run non-silo tests (not blocked by Silo not working in memory) - in progress by @xiazen
- [x] Avoid Silo being MarshalByRefObject but support running tests - #2196 
- [x] Avoid test hooks being MarshalByRefObject (a few still pending) - #2333
- [x] Avoid usages of CallContext - #2197 
- [x] Run all silo tests that do not use extensibility features (such as external storage providers)
- [x] Add storage providers with tests (all implementations that support .net standard out of the box) - #2615
- [x] Add stream providers with tests (all implementations that support .net standard out of the box) - #2615 and #2637
- [x] Extract client implementation from main Orleans.dll (with should have the minimal abstractions)
- [x] Migrate off the MSBuild hack for building .NET Standard once new tooling is available
- [x] Support codegen in the final tooling
- [x] Remove all `NETSTANDARD_TODO` comments by implementing workarounds
- [x] Clean up: Remove all `NETSTANDARD` comments by moving platform specific components to platform specific DLLs
- [x] Design our desired 2.0 nuget package structure (IDs and contents)
- [x] Restructure vNext projects to recreate our expected 2.0 nuget packages output structure
- [x] Full test set passing on .Net Framework 4.6.2 (`net462`)
- [x] Basic validation tests on .Net Core 1.0 (`netcoreapp10`)

**Note**: This list will be updated as new sub-tasks (issues and/or PRs) will emerge from this work.
","[CRAWL Phase] .Net Core Compatibility  _This issue will track the **CRAWL** phase of Orleans 2.X milestone as tracked by #2143_

The idea with this task is to basically make Orleans Core compatible with [.Net Core](https://github.com/dotnet/coreclr), by",2462,galvesribeiro,orleans
2366,Remove usage of named mutexes,"As part of the first test of Orleans in .Net Core (#2145), I tried to run the @jdom Hello World sample project in Linux but it throw `PlatformNotSupportedException`:

```
Named synchronization primitives are not supported on this platform.
Exception = System.PlatformNotSupportedException: Named synchronization primitives are not supported on this platform.
   at System.Threading.EventWaitHandle..ctor(Boolean initialState, EventResetMode mode, String name, Boolean& createdNew, EventWaitHandleSecurity eventSecurity)
   at Orleans.Runtime.Host.SiloHost.StartOrleansSilo(Boolean catchExceptions)
```

That is one of the issues on coreclr repo related to it: https://github.com/dotnet/coreclr/issues/3422

We need to find a workaround for it.","Remove usage of named mutexes  As part of the first test of Orleans in .Net Core (#2145), I tried to run the @jdom Hello World sample project in Linux but it throw `PlatformNotSupportedException`:

```
Named synchronization primitives are not supported",2462,galvesribeiro,orleans
2322,move over BasicActivationTests,"moved TestUtils in Tester to TestExtention , renamed it TesterUtils. ","move over BasicActivationTests  moved TestUtils in Tester to TestExtention , renamed it TesterUtils. ",2323,xiazen,orleans
2070,[WIP] Service Fabric support,"This is an implementation of deeper Service Fabric support (#1059).
It's not ready for use, so please don't use it. I'm pushing an early revision so that people can see what this might look like. It will change significantly before it's merged and may be split into multiple PRs.
- `OrleansCommunicationListener` + a helper class, `OrleansServiceListener`: Allows users to host a silo in a Stateful or Stateless Reliable Service (Service Fabric parlance). Silos can co-exist with Web APIs, WCF services, etc. The silo will publish an endpoint called ""Orleans"" which is used when locating the service.
- `OrleansServiceFabricExtensions`: Helper class which adds an `.AddServiceFabricSupport()` extension method to `IServiceCollection` so that the relevant services can be made available via dependency injection.
- `ReliableDictionaryStateProvider`: an `IStorageProvider` which replicates state from the local primary to remote secondary replicas.
- (internal) `ServiceFabricNamingServiceGatewayProvider`: `IMembershipTable` & `IGatewayListProvider` implementation which uses SF's internal strong-consistency Naming Service as the store, eliminating the need for Azure Tables. SF's Naming Service is similar to Zookeeper.
- (internal) `ServiceFabricPartitionPlacementDirector`: Placement director which maps grains to SF partitions (and hence silos) based on ID. This allows state state
- (internal) `PartitionResolver`: Helper class which maps SF partitions to Orleans silo endpoints. Used by the placement provider.
- (internal) `OrleansFabricSilo`: Internal silo management class which hosts the Orleans silo instance and manages its lifecycle in accordance with SF's lifecycle notifications (via `OrleansCommunicationListener`.

I made changes to DI which will not be merged - I am using a delegate to configure DI, but it looks as though we will mirror ASP.NET's system instead. The projects in the Samples folder will be placed in their own solutions (and will be moved around a bit).

Before this is ready to be merged, it is crucial to ensure that the placement director works as advertised and that grains can never migrate to another Service Fabric partition. SF partition counts/names are fixed once deployed, but a single executable can host multiple partitions and SF can migrate partitions between nodes during failover and for load balancing. With Orleans currently having many static classes and being unable to host multiple silos in the same AppDomain, this PR cannot guarantee that a grain is actually on the primary for its partition.  This also lacks tests.","[WIP] Service Fabric support  This is an implementation of deeper Service Fabric support (#1059).
It's not ready for use, so please don't use it. I'm pushing an early revision so that people can see what this might look like. It will change significantly",2120,ReubenBond,orleans
1059,Support deep Service Fabric integration,"[Service Fabric](https://azure.microsoft.com/en-us/services/service-fabric/) is a great platform for application hosting which offers high-density hosting, application upgrade, and state replication.

Many users, such as myself, would rather use Orleans than Service Fabric Reliable Actors. There are many reasons for this, including that Orleans is much more mature, open source, and feature rich.

We have [integration packages](https://www.nuget.org/packages/Microsoft.Orleans.ServiceFabric) for hosting Orleans atop Service Fabric. This integration is simple and effective but does not allow Orleans to gain all of the benefits which Service Fabric has to offer, such as collocated state.

Orleans should be the obvious choice for Virtual Actors in any hosting environment, so there is some additional work to be done which I would like insight into and assistance with.

This issue is for discussion and tracking of that work.
### Basic Integration:
- [x] **Hosting**: Basic stateless, unpartitioned service hosting. Use the existing [NuGet packages](https://www.nuget.org/packages/Microsoft.Orleans.ServiceFabric).
### Integration Required for Collocated State:
- [x] **Gateway Provider**: Implement an `IGatewayListProvider` based on Service Fabric's `NamingService`. Added in #2542
- [x] **Cluster Membership Provider**: Silos need to be discoverable by clients & each other. ~~This should involve creating an `IMembershipTable` implementation which leverages Fabric's `NamingService` or `PropertyService`.~~ This involves creating an `IMembershipOracle` implementation which can receive updates directly from Service Fabric in addition to periodically polling partitions. Added in #2542
- [ ] **Grain Placement**: Orleans should be partitioned and grain placement should deterministically map `GrainId` to partitions. Using consistent hashing means that we do not need to hold/maintain a grain directory. One potential downside to this approach is that we rely on the randomness of GrainIds to balance load across hosts and cannot perform load shedding in a granular fashion. This is mitigated by using a significant number of partitions, allowing Service Fabric to perform this load balancing at the partition level by shifting partitions between nodes based. This change requires only that we configure a new `PlacementStrategy`/`PlacementDirector` which resolves `GrainId` to `SiloAddress` based upon Service Fabric partitions. We can optionally eliminate the Grain Directory when we are using Service Fabric, but keeping the Grain Directory around allows us to use different placement strategies (as long as they are stateless or use a state provider which doesn't require consistent mapping between `GrainId` & Fabric partition.)
- [ ] **Partitioned hosting**: This should only require a Service Fabric configuration change: **Placement** handles the important parts.
- [ ] **State Providers**: deterministic grain placement allows us to use collocated, replicated state. State providers will be based upon `IReliableDictionary<GrainId,byte[]>`, using Service Fabric's Reliable Services model.
### Extras:
- [ ] **Reminder Service**: Reminder Services should be pluggable so that we can provide a Service Fabric-based reminder service.
- [ ] **Stream Provider**: Service Fabric has an `IReliableQueue<T>` which can be used to produce an `IStreamProvider`.
- [ ] **Storage Provider**: Collocated state requires the **Grain Placement** change, but we can also create a simple state service for in-cluster, non-collocated state. That would allow us to use the existing placement strategies.
### General Work Which Would Help:

Much of this work would be much easier if dependency injection was used more pervasively throughout Orleans. There should not be a `GatewayProviderType` enum and there definitely should not be a `GatewayProviderType.ZooKeeper` value. Those things should be configured in a strongly typed manner.
### Result:

Ultimately, this will give us integration which is on-par with Service Fabric's Reliable Actors implementation. We will also have all of the added features of Orleans.

Anything I've missed? Any obvious/subtle challenged which I may have overlooked?","Support deep Service Fabric integration  [Service Fabric](https://azure.microsoft.com/en-us/services/service-fabric/) is a great platform for application hosting which offers high-density hosting, application upgrade, and state replication.

Many users,",2120,ReubenBond,orleans
2006,Amazon AWS integration,"This issue is part of #2005 by implementing a minimal set of providers to make Orleans to run well by integrating Amazon AWS services.
- [x] DynamoDB Grain State persistence provider (#2007)
- [x] DynamoDB Membership Provider (#2008) 
- [x] DynamoDB Reminder Provider (#2045) 
- [x] SQS Stream Provider (#2053) 
- [ ] DynamoDB Metrics and Statistics
- [ ] Kinesis Stream Provider","Amazon AWS integration  This issue is part of #2005 by implementing a minimal set of providers to make Orleans to run well by integrating Amazon AWS services.
- [x] DynamoDB Grain State persistence provider (#2007)
- [x] DynamoDB Membership Provider (#2",2053,galvesribeiro,orleans
2005,Orleans and Cloud Service Providers,"Although Orleans can run perfectly on-premises and on any other Cloud Service Provider (CSP), I saw people asking about having a deeper/transparent integration with those CSPs by leverage their service offers.

This issue will track a series of issues that will implement minimal providers like the ones already created for Azure but instead, targeting other major CSPs:
- [ ] Amazon Web Services (AWS) - #2006 
- [ ] Google Cloud Platform (GCP) - #2057 

Feel free to make suggestions of other major CSPs to be included on this list or if you wish to contribute on those. Discussions about an specific CSP's provider implementation please keep inside its linked issue.

Lets put Orleans to run everywhere! :dancer: ","Orleans and Cloud Service Providers  Although Orleans can run perfectly on-premises and on any other Cloud Service Provider (CSP), I saw people asking about having a deeper/transparent integration with those CSPs by leverage their service offers.

This",2053,galvesribeiro,orleans
2006,Amazon AWS integration,"This issue is part of #2005 by implementing a minimal set of providers to make Orleans to run well by integrating Amazon AWS services.
- [x] DynamoDB Grain State persistence provider (#2007)
- [x] DynamoDB Membership Provider (#2008) 
- [x] DynamoDB Reminder Provider (#2045) 
- [x] SQS Stream Provider (#2053) 
- [ ] DynamoDB Metrics and Statistics
- [ ] Kinesis Stream Provider","Amazon AWS integration  This issue is part of #2005 by implementing a minimal set of providers to make Orleans to run well by integrating Amazon AWS services.
- [x] DynamoDB Grain State persistence provider (#2007)
- [x] DynamoDB Membership Provider (#2",2045,galvesribeiro,orleans
2005,Orleans and Cloud Service Providers,"Although Orleans can run perfectly on-premises and on any other Cloud Service Provider (CSP), I saw people asking about having a deeper/transparent integration with those CSPs by leverage their service offers.

This issue will track a series of issues that will implement minimal providers like the ones already created for Azure but instead, targeting other major CSPs:
- [ ] Amazon Web Services (AWS) - #2006 
- [ ] Google Cloud Platform (GCP) - #2057 

Feel free to make suggestions of other major CSPs to be included on this list or if you wish to contribute on those. Discussions about an specific CSP's provider implementation please keep inside its linked issue.

Lets put Orleans to run everywhere! :dancer: ","Orleans and Cloud Service Providers  Although Orleans can run perfectly on-premises and on any other Cloud Service Provider (CSP), I saw people asking about having a deeper/transparent integration with those CSPs by leverage their service offers.

This",2045,galvesribeiro,orleans
2006,Amazon AWS integration,"This issue is part of #2005 by implementing a minimal set of providers to make Orleans to run well by integrating Amazon AWS services.
- [x] DynamoDB Grain State persistence provider (#2007)
- [x] DynamoDB Membership Provider (#2008) 
- [x] DynamoDB Reminder Provider (#2045) 
- [x] SQS Stream Provider (#2053) 
- [ ] DynamoDB Metrics and Statistics
- [ ] Kinesis Stream Provider","Amazon AWS integration  This issue is part of #2005 by implementing a minimal set of providers to make Orleans to run well by integrating Amazon AWS services.
- [x] DynamoDB Grain State persistence provider (#2007)
- [x] DynamoDB Membership Provider (#2",2008,galvesribeiro,orleans
2005,Orleans and Cloud Service Providers,"Although Orleans can run perfectly on-premises and on any other Cloud Service Provider (CSP), I saw people asking about having a deeper/transparent integration with those CSPs by leverage their service offers.

This issue will track a series of issues that will implement minimal providers like the ones already created for Azure but instead, targeting other major CSPs:
- [ ] Amazon Web Services (AWS) - #2006 
- [ ] Google Cloud Platform (GCP) - #2057 

Feel free to make suggestions of other major CSPs to be included on this list or if you wish to contribute on those. Discussions about an specific CSP's provider implementation please keep inside its linked issue.

Lets put Orleans to run everywhere! :dancer: ","Orleans and Cloud Service Providers  Although Orleans can run perfectly on-premises and on any other Cloud Service Provider (CSP), I saw people asking about having a deeper/transparent integration with those CSPs by leverage their service offers.

This",2008,galvesribeiro,orleans
2006,Amazon AWS integration,"This issue is part of #2005 by implementing a minimal set of providers to make Orleans to run well by integrating Amazon AWS services.
- [x] DynamoDB Grain State persistence provider (#2007)
- [x] DynamoDB Membership Provider (#2008) 
- [x] DynamoDB Reminder Provider (#2045) 
- [x] SQS Stream Provider (#2053) 
- [ ] DynamoDB Metrics and Statistics
- [ ] Kinesis Stream Provider","Amazon AWS integration  This issue is part of #2005 by implementing a minimal set of providers to make Orleans to run well by integrating Amazon AWS services.
- [x] DynamoDB Grain State persistence provider (#2007)
- [x] DynamoDB Membership Provider (#2",2007,galvesribeiro,orleans
2005,Orleans and Cloud Service Providers,"Although Orleans can run perfectly on-premises and on any other Cloud Service Provider (CSP), I saw people asking about having a deeper/transparent integration with those CSPs by leverage their service offers.

This issue will track a series of issues that will implement minimal providers like the ones already created for Azure but instead, targeting other major CSPs:
- [ ] Amazon Web Services (AWS) - #2006 
- [ ] Google Cloud Platform (GCP) - #2057 

Feel free to make suggestions of other major CSPs to be included on this list or if you wish to contribute on those. Discussions about an specific CSP's provider implementation please keep inside its linked issue.

Lets put Orleans to run everywhere! :dancer: ","Orleans and Cloud Service Providers  Although Orleans can run perfectly on-premises and on any other Cloud Service Provider (CSP), I saw people asking about having a deeper/transparent integration with those CSPs by leverage their service offers.

This",2007,galvesribeiro,orleans
1429,Remove dead client producer from pub sub,"The pubsub system was unable to detect (and remove) dead producers on unavailable clients.  This would put the pubsub system in a non-recoverable state where all further subscriptions on a stream would fail.","Remove dead client producer from pub sub  The pubsub system was unable to detect (and remove) dead producers on unavailable clients.  This would put the pubsub system in a non-recoverable state where all further subscriptions on a stream would fail.",1647,jdom,orleans
1610,EventHubStreamProvider flow control,"Introduced basic flow control mechanism to Persistent Stream Provider's adapter.
Added minimal flow control to EventHubStreamProvider that uses relative positions of cursors in cache to detect risk of cache miss errors, and reduces read rate in those cases.

Possible flow control mechanisms under consideration:
Load Shedding - Use silo load shedding detection to turn off queue readers.
Event/Second upper bound - Use configurable max event per second read rate.

This change minimally addresses Flow Control described in Recoverable Event Hub Persistent Stream Provider - Part 2 #1454","EventHubStreamProvider flow control  Introduced basic flow control mechanism to Persistent Stream Provider's adapter.
Added minimal flow control to EventHubStreamProvider that uses relative positions of cursors in cache to detect risk of cache miss error",1647,jdom,orleans
1421,Client Stream Producers are not being removed,"I'm getting failures when subscribing to a stream from a client.
The use case is a client is the producer, and a client is a subscriber.  No custom grains are being used.

The problem is that the producers (the client) are not being removed from the storage data.
So when a subscriber is added, the storage still contains the old producer, and the system attempts to contact the old producer and a failure (`System.Collections.Generic.KeyNotFoundException: No activation for client *cli/97a45295`) occurs.

the error is occuring at https://github.com/dotnet/orleans/blob/master/src/OrleansRuntime/Streams/PubSub/PubSubRendezvousGrain.cs#L185

We probably need a better exception for the disappeared client, and then catch that exception and remove the producer.","Client Stream Producers are not being removed  I'm getting failures when subscribing to a stream from a client.
The use case is a client is the producer, and a client is a subscriber.  No custom grains are being used.

The problem is that the producers",1637,jason-bragg,orleans
982,await stream.SubscribeAsync(observer) fails with outdated client producer,"For an explicit stream subscription (grain is IAsyncObserver subscribing to stream), we are occasionally seeing this error; typically shortly after the silo starts.

```
StreamId: e9f1969d-3192-4a26-b801-9721322b417d, Error: System.AggregateException: One or more errors occurred. ---> Orleans.Runtime.OrleansException:  System.Collections.Generic.KeyNotFoundException: No activation for client *cli/004e9b88
   at Orleans.Runtime.Placement.PlacementDirectorsManager.<SelectOrAddActivation>d__0.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.Runtime.Dispatcher.<AddressMessage>d__17.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.Runtime.Dispatcher.<AsyncSendMessage>d__14.MoveNext()
   at Orleans.Streams.PubSubRendezvousGrain.<RegisterConsumer>d__1b.MoveNext()
   --- End of inner exception stack trace ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.Runtime.GrainReference.<InvokeMethodAsync>d__0`1.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.Streams.StreamConsumer`1.<SubscribeAsync>d__0.MoveNext()
```","await stream.SubscribeAsync(observer) fails with outdated client producer  For an explicit stream subscription (grain is IAsyncObserver subscribing to stream), we are occasionally seeing this error; typically shortly after the silo starts.

```
StreamI",1637,jason-bragg,orleans
1429,Remove dead client producer from pub sub,"The pubsub system was unable to detect (and remove) dead producers on unavailable clients.  This would put the pubsub system in a non-recoverable state where all further subscriptions on a stream would fail.","Remove dead client producer from pub sub  The pubsub system was unable to detect (and remove) dead producers on unavailable clients.  This would put the pubsub system in a non-recoverable state where all further subscriptions on a stream would fail.",1633,jason-bragg,orleans
1421,Client Stream Producers are not being removed,"I'm getting failures when subscribing to a stream from a client.
The use case is a client is the producer, and a client is a subscriber.  No custom grains are being used.

The problem is that the producers (the client) are not being removed from the storage data.
So when a subscriber is added, the storage still contains the old producer, and the system attempts to contact the old producer and a failure (`System.Collections.Generic.KeyNotFoundException: No activation for client *cli/97a45295`) occurs.

the error is occuring at https://github.com/dotnet/orleans/blob/master/src/OrleansRuntime/Streams/PubSub/PubSubRendezvousGrain.cs#L185

We probably need a better exception for the disappeared client, and then catch that exception and remove the producer.","Client Stream Producers are not being removed  I'm getting failures when subscribing to a stream from a client.
The use case is a client is the producer, and a client is a subscriber.  No custom grains are being used.

The problem is that the producers",1633,jason-bragg,orleans
982,await stream.SubscribeAsync(observer) fails with outdated client producer,"For an explicit stream subscription (grain is IAsyncObserver subscribing to stream), we are occasionally seeing this error; typically shortly after the silo starts.

```
StreamId: e9f1969d-3192-4a26-b801-9721322b417d, Error: System.AggregateException: One or more errors occurred. ---> Orleans.Runtime.OrleansException:  System.Collections.Generic.KeyNotFoundException: No activation for client *cli/004e9b88
   at Orleans.Runtime.Placement.PlacementDirectorsManager.<SelectOrAddActivation>d__0.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.Runtime.Dispatcher.<AddressMessage>d__17.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.Runtime.Dispatcher.<AsyncSendMessage>d__14.MoveNext()
   at Orleans.Streams.PubSubRendezvousGrain.<RegisterConsumer>d__1b.MoveNext()
   --- End of inner exception stack trace ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.Runtime.GrainReference.<InvokeMethodAsync>d__0`1.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.Streams.StreamConsumer`1.<SubscribeAsync>d__0.MoveNext()
```","await stream.SubscribeAsync(observer) fails with outdated client producer  For an explicit stream subscription (grain is IAsyncObserver subscribing to stream), we are occasionally seeing this error; typically shortly after the silo starts.

```
StreamI",1633,jason-bragg,orleans
1096,Recoverable Event Hub Persistent Stream Provider,"Much of Orleans streaming infrastructure was designed to support the following requirements:
- Ordered streams, with data duplication allowed – Events must be delivered to consumers in order.  Duplicate events are allowed.  For instance, a stream of events e1, e2, e3, e4, e5 can be delivered to a consumer ordered as e1, e2, e3, e4, e1, e2, e5, but can’t be delivered in the order e1, e4, e5, e2, e3, e4, e5.
- Recoverable/Rewindable – Consumers can recover from transient errors in stream processing by resuming stream consumption from the sequence token of the last successfully processed event.  Since this is intended only to compensate for transient stream processing errors, only 30 minutes of recoverable stream data is required.
- Persistent streams – Events must be persisted upon generation.  Processing of the event can be delayed, but persistence of the event must be immediate.
- Performant – Must support stream delivery of 2000+ events per second per silo with below 40% CPU utilization.

These requirements came from [343 Industries](https://www.halowaypoint.com/en-us), an early adopter and co-developer of Orleans streaming technology.  [343 Industries](https://www.halowaypoint.com/en-us) developed a recoverable stream provider using EventHub.  This EventHub Stream Provider is being contributed to the Orleans open source project.  During the process of porting this technology to Orleans, the stream provider will be refactored and reorganized to conform to Orleans open source conventions, but the core architecture and requirements must be preserved.

This stream provider will be introduced in the following stages (plan subject to change):
1. Minimal non-recoverable EventHub stream provider
   - Introduction of a new ServiceBus specific project.  OrleansServiceBus.  This will be comparable to the azure specific project OrleansAzureUtils.
   - Development of EventHubQueueAdapter comparable to AzureQueueAdapter, with similar limitations.
     1. Non-rewindable
     2. Will use simple queue cache.
   - Define an EventHubStreamProvider that is a persistent stream provider that uses the EventHubAdapter.
   - Add test coverage for EventHubStreamProvider comparable to that of AzureQueueStreamProvider.
2. Introduce PooledQueueCache (open to better name).  This will be an implementation of the IQueueCache interface which can cache up to 30 minutes of data while minimizing impact to garbage collection.
   - This implementation will cache raw serialized events in pooled blocks of memory that are reused and never collected by garbage collection system.
   - Add PooledQueueCache BVT tests.
3. Add recoverable stream tests using the test stream provider GeneratorStreamProvider with a PooledQueueCache.
4. Update EventHubStreamProvider to be recoverable.
   - Update EventHubQueueAdapter to use PooledQueueCache.
   - EventHubQueueAdapter to persist state that tracks offset into EventHub partition.
   - Add recoverable stream tests comparable to those built against GeneratorStreamProvider.","Recoverable Event Hub Persistent Stream Provider  Much of Orleans streaming infrastructure was designed to support the following requirements:
- Ordered streams, with data duplication allowed – Events must be delivered to consumers in order.  Duplicate e",1375,jason-bragg,orleans
1289,Stream Recovery Tests,"Added testing for some basic stream recovery tests.
Tests use test generated streams
Tests are limited to implicit subscriptions
Tests transient stream processing errors, exercising delivery retry and stream rewind logic.
Tests non-transient stream processing errors, exercising exhaustion of delivery retries and error notification.","Stream Recovery Tests  Added testing for some basic stream recovery tests.
Tests use test generated streams
Tests are limited to implicit subscriptions
Tests transient stream processing errors, exercising delivery retry and stream rewind logic.
Tests",1340,jason-bragg,orleans
1313,GetOrAddConfigurationForNode,"Rename GetConfigurationForNode to GetOrAddConfigurationForNode.

Follow-up for comments in Stream Recovery Tests #1289 ","GetOrAddConfigurationForNode  Rename GetConfigurationForNode to GetOrAddConfigurationForNode.

Follow-up for comments in Stream Recovery Tests #1289 ",1340,jason-bragg,orleans
1325,Fixed a bug of not properly handling DeactivateOnIdle inside OnActivateAsync.,"Discovered by @richorama while working of [""Raft on Orleans""](https://github.com/richorama/OrleansRaft/issues/1).

We used to just ignore the `DeactivateOnIdle` call made inside `OnActivateAsync` (there was just never a scenario for a grain to refuse to activate cleanly).
This fixes the bug.

Notice that refusing to activate via `DeactivateOnIdle` differs from throwing exception from within  `OnActivateAsync` in that in the former case `OnDeactivateAsync` will be called (since `OnActivateAsync` succeeded, thus we have to call `OnDeactivateAsync` before deactivating this activation). In the exception case  `OnDeactivateAsync` will not be called.","Fixed a bug of not properly handling DeactivateOnIdle inside OnActivateAsync.  Discovered by @richorama while working of [""Raft on Orleans""](https://github.com/richorama/OrleansRaft/issues/1).

We used to just ignore the `DeactivateOnIdle` call made ins",1332,gabikliot,orleans
910,Remove strong naming,"This will allow Orleans to freely consume non-strong-named dependencies, such as Microsoft.Framework.DependencyInjection.Abstractions.","Remove strong naming  This will allow Orleans to freely consume non-strong-named dependencies, such as Microsoft.Framework.DependencyInjection.Abstractions.",911,jthelin,orleans
905,Dependency on privately-signed assembly 'Microsoft.Framework.DependencyInjection',"Pull request #827 added to `OrleansRuntime.dll` the following two assembly references:

> Microsoft.Framework.DependencyInjection
> Microsoft.Framework.DependencyInjection.Abstractions

These are required for staring a silo. If they can't be found, the following exception is thrown:

```
System.IO.FileNotFoundException: Could not load file or assembly 'Microsoft.Framework.DependencyInjection.Abstractions, Version=1.0.0.0, Culture=neutral, PublicKeyToken=96418ba87a82bc1c' or one of its dependencies. The system cannot find the file specified.
   at Orleans.Runtime.Startup.ConfigureStartupBuilder.ConfigureStartup(String startupTypeName)
   at Orleans.Runtime.Silo..ctor(String name, SiloType siloType, ClusterConfiguration config, ILocalDataStore keyStore)
   at Orleans.Runtime.Silo..ctor(String name, SiloType siloType, ClusterConfiguration config)
   at Orleans.Runtime.Host.SiloHost.InitializeOrleansSilo()
```

Unfortunately, these two dependencies haven't been added to the appropriate .nuspec file, so they aren't installed automatically. But the real issue is, installing those NuGet packages manually doesn't solve the problem. After they're installed, you get the following exception when starting a silo:

```
System.IO.FileLoadException: Could not load file or assembly 'Microsoft.Framework.DependencyInjection.Abstractions, Version=1.0.0.0, Culture=neutral, PublicKeyToken=96418ba87a82bc1c' or one of its dependencies. The located assembly's manifest definition does not match the assembly reference. (Exception from HRESULT: 0x80131040)
   at Orleans.Runtime.Startup.ConfigureStartupBuilder.ConfigureStartup(String startupTypeName)
   at Orleans.Runtime.Silo..ctor(String name, SiloType siloType, ClusterConfiguration config, ILocalDataStore keyStore)
   at Orleans.Runtime.Silo..ctor(String name, SiloType siloType, ClusterConfiguration config)
   at Orleans.Runtime.Host.SiloHost.InitializeOrleansSilo()
```

This is caused by `OrleanRuntime.dll` referencing a private version of the `Microsoft.Framework.DependencyInjection.Abstractions` assembly that is signed during build (this is done using a pre-build event, at OrleanRuntime.csproj:238). This private version is not available outside the Orleans build process. Using the publicly available assembly that you get from installing the `Microsoft.Framework.DependencyInjection` NuGet package doesn't satisfy the assembly reference, since the public key token is different. Therefore, any silo that uses the OrleansRuntime NuGet package built from a version of Orleans after pull request #827 fails to start with the above exceptions.","Dependency on privately-signed assembly 'Microsoft.Framework.DependencyInjection'  Pull request #827 added to `OrleansRuntime.dll` the following two assembly references:

> Microsoft.Framework.DependencyInjection
> Microsoft.Framework.DependencyInjecti",911,jthelin,orleans
696,MemoryStorageProvider does not respect grain state default constructor upon initialization,"When grain state is initialized from the MemoryStorageProvider, the default constructor is called, and if no previous state is found it initializes all of the properties on the state to null. In `ReadStateAsync`, if the call to 

```
IDictionary<string, object> state = await storageGrain.ReadStateAsync(STATE_STORE_NAME, id);
```

returns null. `SetAll(null)` then resets the properties to null after the grain state constructor has been called.","MemoryStorageProvider does not respect grain state default constructor upon initialization  When grain state is initialized from the MemoryStorageProvider, the default constructor is called, and if no previous state is found it initializes all of the prop",700,gabikliot,orleans
697,expose issue with the memory storage provider and state initialization,"Unit test exposing issue #696 ","expose issue with the memory storage provider and state initialization  Unit test exposing issue #696 ",700,gabikliot,orleans
654,Added a serialization test for json serialization of complex types.,"Investigated issue reported in #651.
Found that there is no problem with Orleans's serialization, it works correctly as expected. ","Added a serialization test for json serialization of complex types.  Investigated issue reported in #651.
Found that there is no problem with Orleans's serialization, it works correctly as expected. ",660,gabikliot,orleans
651,"[Do-not-merge] Tests for serializing objects inside a Dictionary<string, object>","","[Do-not-merge] Tests for serializing objects inside a Dictionary<string, object>  ",660,gabikliot,orleans
576,Delivery Policy for Persistent Stream Providers,"Added retry to stream pulling agent.
Added stream error handler to adapter factory.

EDIT: by @gabikliot
Some background on this change: 
As explained in http://dotnet.github.io/orleans/Orleans-Streams/ and http://dotnet.github.io/orleans/Orleans-Streams/Stream-Providers Orleans streams guarantees are shaped via [Stream Providers](http://dotnet.github.io/orleans/Orleans-Streams/Stream-Providers). Different Stream Providers have different event delivery and ordering guarantees. For example, SMS Provider provides best effort, at most once event delivery guarantee .
AQ provider relies on internal AQ retry mechanism that will hide the event from the queue and if not deleted it will reappear. As such, AQ provider does not guarantee ordering and may deliver the same event more than once (in the presence of message delivery failures).

In addition, we are now actively working on a fully-reliable, recoverable stream provider that guarantees ordering and at most once delivery. 
This PR is a component of this future recoverable stream provider. It allows to specify the retry policy for events that failed to be delivered and also error handling policy that is invoked after all retries fail. One implementaion of this policy, which we ship by default, will be to log the failed event into a special ""failed events"" Azure table and also ""fault"" the stream subsription. That way stream consumers will get a clear notification about this error and will be able to recover, by re-subscribing from a previous point in time and by looking at the ""failed events"" Azure table.","Delivery Policy for Persistent Stream Providers  Added retry to stream pulling agent.
Added stream error handler to adapter factory.

EDIT: by @gabikliot
Some background on this change: 
As explained in http://dotnet.github.io/orleans/Orleans-Streams",585,gabikliot,orleans
347,Improvements to relational database handling in Orleans,"Starts a fix for #255.

An attempt to improve relational database handling in Orleans. If this approach is all right, I'd appreciate help either someone pointing a place to move the files or pulling this PR in and moving the files around. After which the work would continue with the relocated files (possibly in a separate PR).
#### Points of note:
1. Code is not used anywhere at the moment. A feasible approach to make use of it initially could be use in tests by modifying [Local.testsetting](https://github.com/dotnet/orleans/blob/master/src/Local.testsettings#L6) by adding [CreateTables.sql](https://github.com/dotnet/orleans/blob/master/src/OrleansProviders/SQLServer/CreateTables.sql) to the set of included items in tests [MembershipTablePluginTests](https://github.com/dotnet/orleans/blob/master/src/TesterInternal/StorageTests/MembershipTablePluginTests.cs#L38) and create database as appropriate for testing (code follows) and add the tables in the script in (one has to remove the `DELETE` clauses, likely also the `SELECT` clauses.
2. Laying this foundation should support all databases with ADO.NET providers.
3. Should make it easier to add new relational backends so that they are easily testable. This is achieved chiefly with special template queries. See `RelationalConstants`.
4. Should not hinder adding further features such as using stored procedures or reading
   multiple resultsets.
5. Is asynchronous all the way.
6. Does not have logging facilities added.
7. Includes a few reflection utilities to make use easier, though hand-tune queries are possible too and likely should be favoured. An example of such is at `ExistsAsync`.
8. Current Orleans queries aren't added to the newer code base. One approach would be to turn them to extensions methods.
9. Related to point number eight, currently data would be inserted in a loop, but a more efficient would be multi-row `INSERT INTO VALUES`, which is possible, but having a few methods to assembly the query string from a provided collection string would make it nicer. On the TODO list.
#### Additional notes:
1. Perhaps it would be useful to create a new project, e.g. `Orleans.DataStorage` wherein to put data storage related functionality.
2. Perhaps it would be useful to define an interface according to HTTP verbs (GET/PUT/PATCH/DELETE). This way adding any storage backend would look like being easier. Caveat emptor, I haven't studied this in depth.
3. Perhaps it would be useful to create a special `ReflectionCache` component, which would include the source of type and a timestamp when added.
4. Perhaps it would be feasible to add a project like `Orleans.UnitTests`, which would contain clearly unit test like functionality.

In the following debugger and/or open database might be handy. This is a simpble usage example (""works on my machine"")

``` C#
     using System.Data.Common;
     using System.Linq;
     using UnitTests.StorageTests.Utilities;


    namespace OrleansTest
    {
    public struct Test
    {
        public int configuration_id { get; set; }

        public string description { get; set; }
    }


    class Program
    {
        static void Main(string[] args)
        {
            var sqlServer = RelationalConstants.GetRelationalConstants().First(i => i.InvariantName == WellKnownRelationalInvariants.SqlServer);
            var db = GenericRelationalStorage.CreateInstance(sqlServer.InvariantName, sqlServer.DefaultConnectionString);

            //Read some data from the master database.
            var r1 = db.ReadAsync<Test>(""SELECT * FROM sys.configurations WHERE configuration_id < @Id"", new { Id = 200 }).Result;

            //Create a new database if it doesn't exist already. This needs to be done with a valid connection string.
            //The one in default template connects to master database, which always exists.
            if (!db.ExistsAsync(""Testtest"").Result)
            {
                db.CreateAsync(""Testtest"").Wait();
            }

            //Now that there's a new database, let's connect to it...
            var csb = new DbConnectionStringBuilder();
            csb.ConnectionString = sqlServer.DefaultConnectionString;
            csb[""Initial Catalog""] = ""Testtest"";
            db = GenericRelationalStorage.CreateInstance(sqlServer.InvariantName, csb.ConnectionString);

            //Create a new table. Note to refactor .ExecuteAsync so that adding ""null"" isn't needed. INFORMATION_SCHEMA should be a somewhat implemented standard metadata table...
            var r2 = db.ExecuteAsync(""IF EXISTS(SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Test') DROP TABLE Test;"", null).Result;
            var r3 = db.ExecuteAsync(""CREATE TABLE Test(Id INT PRIMARY KEY IDENTITY(1, 1) NOT NULL, Data NVARCHAR(256) NOT NULL);"", null).Result;            
            var r4 = db.ExecuteAsync(""INSERT INTO Test(Data) VALUES(@Data);"", new { Data = ""Some data 1..."" }).Result;
            var r5 = db.ExecuteAsync(""INSERT INTO dbo.Test(Data) VALUES(@Data);"", new { Data = ""Some data 2..."" }).Result;
            var r6 = db.ExecuteAsync(""DELETE FROM Test WHERE Id = @Id;"", new { Id = 1 }).Result;
        }
        }
    }
```","Improvements to relational database handling in Orleans  Starts a fix for #255.

An attempt to improve relational database handling in Orleans. If this approach is all right, I'd appreciate help either someone pointing a place to move the files or pulli",578,gabikliot,orleans
573,Orleans statistics floats have decimal separators written in culture specific format to storage,"Orleans statistics floats have decimal separators written in culture specific format. I think the intention is to store data in culture invariant way. I have verified this is  an issue with SQL Server where statistics are written to the table as

| StatValue | Statistic |
| --- | --- |
| 6,572005 | Runtime.CpuUsage |
| 1,588444 | Runtime.GC.PercentOfTimeInGC |

in systems where decimal separator is not dot (e.g. Finnish). In relational database the code is [here](https://github.com/dotnet/orleans/blob/master/src/Orleans/Storage/OrleansRelationalExtensions.cs#L287). For Table Storage the code is [here](https://github.com/dotnet/orleans/blob/master/src/OrleansAzureUtils/Storage/StatsTableDataManager.cs#L146). I would imagine it has a similar issue.

I recall .NET Design Guidelines tell that `.ToString` is to print culture aware strings, so in that sense the `.ToString` code is right, the callers are wrong. One way to provide a fix is to add an overload to `ToString` that accepts a `CultureInfo` parameter. An example: [Single.ToString Method (IFormatProvider)](https://msdn.microsoft.com/en-us/library/7tdhaxxa%28v=vs.110%29.aspx).

Tangential notes:
- Maybe adding a `DebuggerDisplay` to `ICounter`.
- It would look like sensible to refactor the relational code so that statistic values are always numeric.",Orleans statistics floats have decimal separators written in culture specific format to storage  Orleans statistics floats have decimal separators written in culture specific format. I think the intention is to store data in culture invariant way. I have,578,gabikliot,orleans
530,A number of small ZK MBR table cleanup fixes.,"Only set maxStaleness for GatewayListProvider.
No need in log4Net.
Use CultureInfo.InvariantCulture when converting ZK rowVersion to string eTag.","A number of small ZK MBR table cleanup fixes.  Only set maxStaleness for GatewayListProvider.
No need in log4Net.
Use CultureInfo.InvariantCulture when converting ZK rowVersion to string eTag.",545,shayhatsor,orleans
535,NotImplementedReminderTable to disable reminders,"When using ZooKeeper as a membership provider , the reminders provider is set to GrainBasedReminderTable (as a fallback). This seemed to work fine. But it doesn't.
The scenario:
1) 5 silos are started as secondary and are active in the same deployment. (named Silo1-Silo5)
2) all silos crash
3) Silo1 is restarted
4) Silo1 adds a suspected dead entry for Silo2-Silo5
5) Silo1 tries to get the grain for the GrainBasedReminderTable.
6) the hash result says that Silo3 knows where the GrainBasedReminderTable is.
7) Silo1 suspicion isn't enough to change the ring. 
8) Silo1 can't start its reminder service and crashes. This happens continuously until enough silos are started and the membership table reflects reality.

I've added a NotImplementedReminderTable reminder table implementation that just throws when reminders are used by grains. IMO this is much better than the fallback to GrainBasedReminderTable, which gives grains the illusion of persistent storage which in reality doesn't exist.","NotImplementedReminderTable to disable reminders  When using ZooKeeper as a membership provider , the reminders provider is set to GrainBasedReminderTable (as a fallback). This seemed to work fine. But it doesn't.
The scenario:
1) 5 silos are started as",538,gabikliot,orleans
511,Replace compile-time code generation of GrainReference subclasses (stubs),"This is a sub issue for #474 (Minimize/eliminate the usage of code generation in Orleans). Motivations for this are covered in that issue, so I won't reiterate.

@gabikliot mentioned some different techniques for eliminating the need for compile-time code generation of `GrainReference` subclasses including the possibility of using dynamic method invocation, reflection, or runtime code generation (eg, using Roslyn. See #40).

I believe that runtime code generation is the most optimal approach: it has the best amortized performance at runtime. Other options might be sufficient, though. The performance of `dynamic` has apparently improved somewhat, so that might now be a viable option.","Replace compile-time code generation of GrainReference subclasses (stubs)  This is a sub issue for #474 (Minimize/eliminate the usage of code generation in Orleans). Motivations for this are covered in that issue, so I won't reiterate.

@gabikliot menti",528,ReubenBond,orleans
510,Replace compile-time code generation of IGrainMethodInvoker,"This is a sub issue for #474 (Minimize/eliminate the usage of code generation in Orleans). Motivations for this are covered in that issue, so I won't reiterate.

@gabikliot mentioned some different techniques for eliminating the need for compile-time code generation of IGrainMethodInvoker including the possibility of using dynamic method invocation, reflection, or runtime code generation (eg, using Roslyn. See #40).

I believe that runtime code generation is the most optimal approach: it has the best amortized performance at runtime. Other options might be sufficient, though.","Replace compile-time code generation of IGrainMethodInvoker  This is a sub issue for #474 (Minimize/eliminate the usage of code generation in Orleans). Motivations for this are covered in that issue, so I won't reiterate.

@gabikliot mentioned some diff",528,ReubenBond,orleans
381,Call OnDeactivateAsync on silo shutdown,"Would it be possible to add so OnDeactivateAsync is called on all grains in the silo when a silo is shutdown?

The scenario for this is that a complete crash of a silo is a very rare occurrence so if the grains get this call when the silo goes down in a nice way (For host update or grain version refresh) they could do a nicer handover to the next activation by serializing any data they have.  

This would also help in the case where you save data on a timer. If this signal is sent then you could save the data only when the OnDeactiveAsync was received. Even if you did use a timer to save it periodically you would be sure to save the latest data using this. Even if you can recover this would be nicer since no data would be lost. ","Call OnDeactivateAsync on silo shutdown  Would it be possible to add so OnDeactivateAsync is called on all grains in the silo when a silo is shutdown?

The scenario for this is that a complete crash of a silo is a very rare occurrence so if the grains g",457,gabikliot,orleans
320,Handling multiple environments / versions of a cluster,"Hi 

We're struggling with questions around handling versioning and environments of an Orleans application (details ahead), and I'm hoping there might be some directions or tips on how to handle this. If there was already a discussion about this (I didn't find one), please point me to it. 

The situation in question:

You (we) have an Orleans application, and there are state-full grains in it. 
Now we want to deploy a new version of the application. There are two main steps for deploying a new version: 
1. Upload the new version to a staging environment. In this phase the old and the new version lives side by side, and the new version is being tested.
2. Deploy the new version to production. Since this requires a cluster restart, it actually means deploy the new version to a new cluster, and then ""switch"" between the old and new clusters.

Both this steps contain a bag of problems with handling grains and their states.
For the sake of the example, lets assume we have in the application a _UserGrain_ that represents the state of a user. 

So while in staging, if the same user switches between staging and production, there may be a conflict between the states in each environment. Since there's a _UserGrain_ for the user in each environment, each holding its own state, they will be different (even if it gets persisted, the other grain in the second cluster does not know it needs to refresh its state).

A different flavor of the problem appears when switching between the old and new versions. This is never a ""singular point in time"" event (unless you can sustain downtime, which you normally can't). This means that there might be requests that are still handled by the old version while the new version is already up. So again - a _UserGrain_ of a user might change state in the old version while this not being recognized by the new version. 

This can be potentially handled by ""streaming"" all changes from the old version to the new version, but this seems to be a huge overhead and complication to the system. 

Are there any best practices for handling this? How do you handle production changes?","Handling multiple environments / versions of a cluster  Hi 

We're struggling with questions around handling versioning and environments of an Orleans application (details ahead), and I'm hoping there might be some directions or tips on how to handle th",457,gabikliot,orleans
413,Refactored silo statuses to use IsTerminating and better encapsulation of usage of IsTerminating in various places.,"No logic change. 
A first step towards Gracefull Shutdown, related to:
https://github.com/dotnet/orleans/issues/381
https://github.com/dotnet/orleans/issues/320#issuecomment-101035028
http://orleans.codeplex.com/discussions/637820#post1425137","Refactored silo statuses to use IsTerminating and better encapsulation of usage of IsTerminating in various places.  No logic change. 
A first step towards Gracefull Shutdown, related to:
https://github.com/dotnet/orleans/issues/381
https://github.com/",457,gabikliot,orleans
448,Added Silo.Shutdown call.,"Call Silo.Shutdown  from Azure Orleans Silo host and regular Orleans Silo host Stop() methods.
Deactivate all grains in this silo properly upon Silo.Shutdown call.

This is a 2nd step towards Gracefull Shutdown, related to:
#381
#320 (comment)

http://orleans.codeplex.com/discussions/637820#post1425137
Continues the work in #413.

Still a bit more work is required, to properly unsure that silo does not accept any new grain requests after the grains were deactivated and before silo is fully dead (so that we don't reactivate some grains again). This PR definitely leaves us in a better state than before we Deactivated all grains, so I feel like it can be merged even before the next level of improvements is done.","Added Silo.Shutdown call.  Call Silo.Shutdown  from Azure Orleans Silo host and regular Orleans Silo host Stop() methods.
Deactivate all grains in this silo properly upon Silo.Shutdown call.

This is a 2nd step towards Gracefull Shutdown, related to:",457,gabikliot,orleans
381,Call OnDeactivateAsync on silo shutdown,"Would it be possible to add so OnDeactivateAsync is called on all grains in the silo when a silo is shutdown?

The scenario for this is that a complete crash of a silo is a very rare occurrence so if the grains get this call when the silo goes down in a nice way (For host update or grain version refresh) they could do a nicer handover to the next activation by serializing any data they have.  

This would also help in the case where you save data on a timer. If this signal is sent then you could save the data only when the OnDeactiveAsync was received. Even if you did use a timer to save it periodically you would be sure to save the latest data using this. Even if you can recover this would be nicer since no data would be lost. ","Call OnDeactivateAsync on silo shutdown  Would it be possible to add so OnDeactivateAsync is called on all grains in the silo when a silo is shutdown?

The scenario for this is that a complete crash of a silo is a very rare occurrence so if the grains g",448,gabikliot,orleans
320,Handling multiple environments / versions of a cluster,"Hi 

We're struggling with questions around handling versioning and environments of an Orleans application (details ahead), and I'm hoping there might be some directions or tips on how to handle this. If there was already a discussion about this (I didn't find one), please point me to it. 

The situation in question:

You (we) have an Orleans application, and there are state-full grains in it. 
Now we want to deploy a new version of the application. There are two main steps for deploying a new version: 
1. Upload the new version to a staging environment. In this phase the old and the new version lives side by side, and the new version is being tested.
2. Deploy the new version to production. Since this requires a cluster restart, it actually means deploy the new version to a new cluster, and then ""switch"" between the old and new clusters.

Both this steps contain a bag of problems with handling grains and their states.
For the sake of the example, lets assume we have in the application a _UserGrain_ that represents the state of a user. 

So while in staging, if the same user switches between staging and production, there may be a conflict between the states in each environment. Since there's a _UserGrain_ for the user in each environment, each holding its own state, they will be different (even if it gets persisted, the other grain in the second cluster does not know it needs to refresh its state).

A different flavor of the problem appears when switching between the old and new versions. This is never a ""singular point in time"" event (unless you can sustain downtime, which you normally can't). This means that there might be requests that are still handled by the old version while the new version is already up. So again - a _UserGrain_ of a user might change state in the old version while this not being recognized by the new version. 

This can be potentially handled by ""streaming"" all changes from the old version to the new version, but this seems to be a huge overhead and complication to the system. 

Are there any best practices for handling this? How do you handle production changes?","Handling multiple environments / versions of a cluster  Hi 

We're struggling with questions around handling versioning and environments of an Orleans application (details ahead), and I'm hoping there might be some directions or tips on how to handle th",448,gabikliot,orleans
413,Refactored silo statuses to use IsTerminating and better encapsulation of usage of IsTerminating in various places.,"No logic change. 
A first step towards Gracefull Shutdown, related to:
https://github.com/dotnet/orleans/issues/381
https://github.com/dotnet/orleans/issues/320#issuecomment-101035028
http://orleans.codeplex.com/discussions/637820#post1425137","Refactored silo statuses to use IsTerminating and better encapsulation of usage of IsTerminating in various places.  No logic change. 
A first step towards Gracefull Shutdown, related to:
https://github.com/dotnet/orleans/issues/381
https://github.com/",448,gabikliot,orleans
362,Make the Grain class unit testable,"## Problem

In the current version of Orleans, I faced two issues when writing unit tests. 
1. The GrainFactory is static and cannot be mocked or stubbed in a simple way. 
2. The GetPrimaryKey(),GetPrimaryKeyLong() and GetPrimaryKeyString() methods are also difficult to mock/stub for more than one reason (one of them being that they are extension methods).

For this reason, it is not possible to test Orleans grains without starting a Silo. There are many disadvantages of relying on a Silo:
1. The class under test is not completely isolated because some of the code being tested is communicating with the Orleans runtime.
2. It's not possible to cover all branches/lines of code because there is no simple way to tell the Silo to fail or throw a specific exception (which is possible with mocks).
3. The tests are slower to run and harder to setup.
## Proposal

To solve the above issues, I added two properties to the Grain class:

``` csharp
        public IGrainLocator GrainLocator { get; set; }
        public IGrainIdentifier Identifier { get; set; }
```

The default implementations simply forward the calls to the existing **GrainFactory** and extensions methods respectively. During unit testing, the default implementations can be simply replaced with mock objects using constructor or setter injection. The **IGrainLocator** and **IGrainIdentifier** interfaces are as follows.

``` csharp
    public interface IGrainLocator
    {
        TGrainInterface GetGrain<TGrainInterface>(Guid primaryKey, string grainClassNamePrefix = null) where TGrainInterface : IGrainWithGuidKey;
        TGrainInterface GetGrain<TGrainInterface>(long primaryKey, string grainClassNamePrefix = null) where TGrainInterface : IGrainWithIntegerKey;
        TGrainInterface GetGrain<TGrainInterface>(string primaryKey, string grainClassNamePrefix = null) where TGrainInterface : IGrainWithStringKey;
    }

    public interface IGrainIdentifier
    {
        Guid AsGuid();
        long AsLong();
        string AsString();
    }
```
## Usage

Here is an example that shows how the new Api can be used during unit testing.

In this example, we have a **DeviceGrain** and a **PrefsGrain**. The **DeviceGrain** uses the **PrefsGrain** to save it’s preferences. Assume that the device has a screen and one of its prefs is the screen background color.

``` csharp
    public class DeviceGrain : Grain, IDeviceGrain
    {
        private const string BackgroundColor = ""background_color"";

        public Task<string> GetScreenBackgroundColor()
        {
            return GetPrefsGrain().GetValue(BackgroundColor);
        }

        public Task SetBackgroundColor(string color)
        {
            return GetPrefsGrain().SetValue(new KeyValuePair<string, string>(BackgroundColor, color));
        }

        private IPrefsGrain GetPrefsGrain()
        {
            return GrainLocator.GetGrain<IPrefsGrain>(Identifier.AsString());
        }
    }
```

Notice that the `GetPrefsGrain()` is using the new API to communicate with the prefs grain and to find its **Id** (of course the current Orleans **GrainFactory** still works for backward compatibility). Below a unit test for the `GetScreenBackgroundColor()` method (I used **Moq** for mocking here):

``` csharp
        [TestMethod]
        public void TestGetScreenBackgroundColor()
        {
            var prefsGrainMock = new Mock<IPrefsGrain>();
            prefsGrainMock.Setup(prefs => prefs.GetValue(""background_color"")).Returns(Task.FromResult(""black""));

            var grainLocatorMock = new Mock<IGrainLocator>();
            grainLocatorMock.Setup(grainLocator => grainLocator.GetGrain<IPrefsGrain>(""deviceId"", null)).Returns(prefsGrainMock.Object);

            var grainIdentifierMock = new Mock<IGrainIdentifier>();
            grainIdentifierMock.Setup(identifier => identifier.AsString()).Returns(""deviceId"");

            DeviceGrain device = new DeviceGrain() {GrainLocator = grainLocatorMock.Object, Identifier = grainIdentifierMock.Object};
            Assert.AreEqual(""black"", device.GetScreenBackgroundColor().Result);
        }
```

As you can see in the example above, it is very easy to replace the **IGrainLocator** and **IGrainIdentifier** with mocks during unit testing. In addition, using properties instead of a static class or extension methods makes it possible to use **dependency injection** to replace the grain factory and identifier. As a result, with rather simple changes, the unit testing experience of Orleans grains is much better.
## Pull Request
#363","Make the Grain class unit testable  ## Problem

In the current version of Orleans, I faced two issues when writing unit tests. 
1. The GrainFactory is static and cannot be mocked or stubbed in a simple way. 
2. The GetPrimaryKey(),GetPrimaryKeyLong()",443,nehmebilal,orleans
48,Unit testing of grains,"@yevhen and @kspeakman expressed some ideas for a better approach to unit testing grains. Let's discuss the ideas here.","Unit testing of grains  @yevhen and @kspeakman expressed some ideas for a better approach to unit testing grains. Let's discuss the ideas here.",443,nehmebilal,orleans
408,OrleansTestingHost Package - Part 2,"Some final tweaks and fixes to the new TestingSiloHost following on from PR #405
- Eliminate some final places with ""UnitTest"" in class / file names.
- Normalize namespace in OrleansTestingHost package to align with naming convention in other packages.
- Split out some remaining public classes into their own source code files, for easier understanding of the OrleansTestingHost package contents.
- Include some default testing silo / client config files in NuGet package.
- Include NuGet package init.ps1 script to correctly handle install of silo / client config files into target project.

Then, change existing Tester projects over to use the new TestingSiloHost package.","OrleansTestingHost Package - Part 2  Some final tweaks and fixes to the new TestingSiloHost following on from PR #405
- Eliminate some final places with ""UnitTest"" in class / file names.
- Normalize namespace in OrleansTestingHost package to align with",422,jthelin,orleans
420,Need a different client config for testing client-side streams.,"Fixes bug in Nightly test suite introduced by PR #408 

Failure case was: SMSDeactivationTest_ClientConsumer","Need a different client config for testing client-side streams.  Fixes bug in Nightly test suite introduced by PR #408 

Failure case was: SMSDeactivationTest_ClientConsumer",422,jthelin,orleans
421,Testing host part 3,"Fixes bug in Nightly test suite introduced by PR #408 

Failure case was: SMSDeactivationTest_ClientConsumer

Change:
- Need a different client config for testing client-side streams.

This PR replaces #420 which got into a bit of a mess!","Testing host part 3  Fixes bug in Nightly test suite introduced by PR #408 

Failure case was: SMSDeactivationTest_ClientConsumer

Change:
- Need a different client config for testing client-side streams.

This PR replaces #420 which got into a bit",422,jthelin,orleans
